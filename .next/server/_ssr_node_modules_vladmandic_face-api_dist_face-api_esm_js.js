/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_node_modules_vladmandic_face-api_dist_face-api_esm_js";
exports.ids = ["_ssr_node_modules_vladmandic_face-api_dist_face-api_esm_js"];
exports.modules = {

/***/ "(ssr)/./node_modules/@vladmandic/face-api/dist sync recursive":
/*!******************************************************!*\
  !*** ./node_modules/@vladmandic/face-api/dist/ sync ***!
  \******************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "(ssr)/./node_modules/@vladmandic/face-api/dist sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "(ssr)/./node_modules/@vladmandic/face-api/dist/face-api.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@vladmandic/face-api/dist/face-api.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgeGenderNet: () => (/* binding */ ug),\n/* harmony export */   BoundingBox: () => (/* binding */ bp),\n/* harmony export */   Box: () => (/* binding */ mn),\n/* harmony export */   ComposableTask: () => (/* binding */ Oa),\n/* harmony export */   ComputeAllFaceDescriptorsTask: () => (/* binding */ Bs),\n/* harmony export */   ComputeFaceDescriptorsTaskBase: () => (/* binding */ yg),\n/* harmony export */   ComputeSingleFaceDescriptorTask: () => (/* binding */ Vs),\n/* harmony export */   DetectAllFaceLandmarksTask: () => (/* binding */ vg),\n/* harmony export */   DetectAllFacesTask: () => (/* binding */ Gd),\n/* harmony export */   DetectFaceLandmarksTaskBase: () => (/* binding */ xg),\n/* harmony export */   DetectFacesTaskBase: () => (/* binding */ kg),\n/* harmony export */   DetectSingleFaceLandmarksTask: () => (/* binding */ wg),\n/* harmony export */   DetectSingleFaceTask: () => (/* binding */ Ig),\n/* harmony export */   Dimensions: () => (/* binding */ aa),\n/* harmony export */   FACE_EXPRESSION_LABELS: () => (/* binding */ rD),\n/* harmony export */   FaceDetection: () => (/* binding */ Ft),\n/* harmony export */   FaceDetectionNet: () => (/* binding */ TD),\n/* harmony export */   FaceExpressionNet: () => (/* binding */ sg),\n/* harmony export */   FaceExpressions: () => (/* binding */ Os),\n/* harmony export */   FaceLandmark68Net: () => (/* binding */ Dp),\n/* harmony export */   FaceLandmark68TinyNet: () => (/* binding */ cg),\n/* harmony export */   FaceLandmarkNet: () => (/* binding */ fD),\n/* harmony export */   FaceLandmarks: () => (/* binding */ ka),\n/* harmony export */   FaceLandmarks5: () => (/* binding */ H$),\n/* harmony export */   FaceLandmarks68: () => (/* binding */ vp),\n/* harmony export */   FaceMatch: () => (/* binding */ Dd),\n/* harmony export */   FaceMatcher: () => (/* binding */ WD),\n/* harmony export */   FaceRecognitionNet: () => (/* binding */ Rp),\n/* harmony export */   Gender: () => (/* binding */ Ck),\n/* harmony export */   LabeledBox: () => (/* binding */ Rd),\n/* harmony export */   LabeledFaceDescriptors: () => (/* binding */ rl),\n/* harmony export */   NetInput: () => (/* binding */ Wr),\n/* harmony export */   NeuralNetwork: () => (/* binding */ fn),\n/* harmony export */   ObjectDetection: () => (/* binding */ yp),\n/* harmony export */   Point: () => (/* binding */ He),\n/* harmony export */   PredictedBox: () => (/* binding */ j$),\n/* harmony export */   Rect: () => (/* binding */ xp),\n/* harmony export */   SsdMobilenetv1: () => (/* binding */ ll),\n/* harmony export */   SsdMobilenetv1Options: () => (/* binding */ Ma),\n/* harmony export */   TinyFaceDetector: () => (/* binding */ zp),\n/* harmony export */   TinyFaceDetectorOptions: () => (/* binding */ fg),\n/* harmony export */   TinyYolov2: () => (/* binding */ Pp),\n/* harmony export */   TinyYolov2Options: () => (/* binding */ yr),\n/* harmony export */   allFaces: () => (/* binding */ OAe),\n/* harmony export */   allFacesSsdMobilenetv1: () => (/* binding */ mge),\n/* harmony export */   allFacesTinyYolov2: () => (/* binding */ MAe),\n/* harmony export */   awaitMediaLoaded: () => (/* binding */ q$),\n/* harmony export */   bufferToImage: () => (/* binding */ K$),\n/* harmony export */   computeFaceDescriptor: () => (/* binding */ v_e),\n/* harmony export */   createCanvas: () => (/* binding */ Np),\n/* harmony export */   createCanvasFromMedia: () => (/* binding */ Zf),\n/* harmony export */   createFaceDetectionNet: () => (/* binding */ YCe),\n/* harmony export */   createFaceRecognitionNet: () => (/* binding */ Y2e),\n/* harmony export */   createSsdMobilenetv1: () => (/* binding */ lge),\n/* harmony export */   createTinyFaceDetector: () => (/* binding */ eFe),\n/* harmony export */   createTinyYolov2: () => (/* binding */ BEe),\n/* harmony export */   detectAllFaces: () => (/* binding */ Dk),\n/* harmony export */   detectFaceLandmarks: () => (/* binding */ dge),\n/* harmony export */   detectFaceLandmarksTiny: () => (/* binding */ x_e),\n/* harmony export */   detectLandmarks: () => (/* binding */ $_e),\n/* harmony export */   detectSingleFace: () => (/* binding */ _Ae),\n/* harmony export */   draw: () => (/* binding */ iD),\n/* harmony export */   env: () => (/* binding */ at),\n/* harmony export */   euclideanDistance: () => (/* binding */ zD),\n/* harmony export */   extendWithAge: () => (/* binding */ Fk),\n/* harmony export */   extendWithFaceDescriptor: () => (/* binding */ Ak),\n/* harmony export */   extendWithFaceDetection: () => (/* binding */ wp),\n/* harmony export */   extendWithFaceExpressions: () => (/* binding */ Nk),\n/* harmony export */   extendWithFaceLandmarks: () => (/* binding */ Vd),\n/* harmony export */   extendWithGender: () => (/* binding */ $k),\n/* harmony export */   extractFaceTensors: () => (/* binding */ Ld),\n/* harmony export */   extractFaces: () => (/* binding */ Pd),\n/* harmony export */   fetchImage: () => (/* binding */ sIe),\n/* harmony export */   fetchJson: () => (/* binding */ Z$),\n/* harmony export */   fetchNetWeights: () => (/* binding */ pIe),\n/* harmony export */   fetchOrThrow: () => (/* binding */ Ms),\n/* harmony export */   fetchVideo: () => (/* binding */ gIe),\n/* harmony export */   getContext2dOrThrow: () => (/* binding */ ra),\n/* harmony export */   getMediaDimensions: () => (/* binding */ Sp),\n/* harmony export */   imageTensorToCanvas: () => (/* binding */ X$),\n/* harmony export */   imageToSquare: () => (/* binding */ Y$),\n/* harmony export */   inverseSigmoid: () => (/* binding */ v0e),\n/* harmony export */   iou: () => (/* binding */ B$),\n/* harmony export */   isMediaElement: () => (/* binding */ Sk),\n/* harmony export */   isMediaLoaded: () => (/* binding */ Yf),\n/* harmony export */   isWithAge: () => (/* binding */ eCe),\n/* harmony export */   isWithFaceDetection: () => (/* binding */ zr),\n/* harmony export */   isWithFaceExpressions: () => (/* binding */ sD),\n/* harmony export */   isWithFaceLandmarks: () => (/* binding */ Fp),\n/* harmony export */   isWithGender: () => (/* binding */ rCe),\n/* harmony export */   loadAgeGenderModel: () => (/* binding */ __e),\n/* harmony export */   loadFaceDetectionModel: () => (/* binding */ A_e),\n/* harmony export */   loadFaceExpressionModel: () => (/* binding */ E_e),\n/* harmony export */   loadFaceLandmarkModel: () => (/* binding */ N_e),\n/* harmony export */   loadFaceLandmarkTinyModel: () => (/* binding */ T_e),\n/* harmony export */   loadFaceRecognitionModel: () => (/* binding */ C_e),\n/* harmony export */   loadSsdMobilenetv1Model: () => (/* binding */ hge),\n/* harmony export */   loadTinyFaceDetectorModel: () => (/* binding */ I_e),\n/* harmony export */   loadTinyYolov2Model: () => (/* binding */ S_e),\n/* harmony export */   loadWeightMap: () => (/* binding */ Q$),\n/* harmony export */   locateFaces: () => (/* binding */ F_e),\n/* harmony export */   matchDimensions: () => (/* binding */ IIe),\n/* harmony export */   minBbox: () => (/* binding */ V$),\n/* harmony export */   nets: () => (/* binding */ rt),\n/* harmony export */   nonMaxSuppression: () => (/* binding */ U$),\n/* harmony export */   normalize: () => (/* binding */ br),\n/* harmony export */   padToSquare: () => (/* binding */ G$),\n/* harmony export */   predictAgeAndGender: () => (/* binding */ k_e),\n/* harmony export */   recognizeFaceExpressions: () => (/* binding */ w_e),\n/* harmony export */   resizeResults: () => (/* binding */ fge),\n/* harmony export */   resolveInput: () => (/* binding */ kp),\n/* harmony export */   shuffleArray: () => (/* binding */ y0e),\n/* harmony export */   sigmoid: () => (/* binding */ qf),\n/* harmony export */   ssdMobilenetv1: () => (/* binding */ cge),\n/* harmony export */   tf: () => (/* binding */ Pe),\n/* harmony export */   tinyFaceDetector: () => (/* binding */ b_e),\n/* harmony export */   tinyYolov2: () => (/* binding */ y_e),\n/* harmony export */   toNetInput: () => (/* binding */ vt),\n/* harmony export */   utils: () => (/* binding */ W$),\n/* harmony export */   validateConfig: () => (/* binding */ DD),\n/* harmony export */   version: () => (/* binding */ cFe)\n/* harmony export */ });\n/*\n  Face-API\n  homepage: <https://github.com/vladmandic/face-api>\n  author: <https://github.com/vladmandic>'\n*/\n\nvar vR=Object.defineProperty;var wR=(e=> true?__webpack_require__(\"(ssr)/./node_modules/@vladmandic/face-api/dist sync recursive\"):0)(function(e){if(true)return __webpack_require__(\"(ssr)/./node_modules/@vladmandic/face-api/dist sync recursive\").apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var ax=(e,t)=>{for(var n in t)vR(e,n,{get:t[n],enumerable:!0})};var Pe={};ax(Pe,{Abs:()=>Yl,Acos:()=>Ni,Acosh:()=>Ti,AdadeltaOptimizer:()=>Vw,AdagradOptimizer:()=>Uw,AdamOptimizer:()=>Gw,AdamaxOptimizer:()=>Hw,Add:()=>vs,AddN:()=>Ci,All:()=>Zl,Any:()=>Jl,ArgMax:()=>Ql,ArgMin:()=>eu,Asin:()=>Ei,Asinh:()=>_i,Atan:()=>Ai,Atan2:()=>$i,Atanh:()=>Fi,AvgPool:()=>Di,AvgPool3D:()=>tu,AvgPool3DGrad:()=>Rc,AvgPoolGrad:()=>Dc,BackendWasm:()=>L$,BatchMatMul:()=>Ri,BatchToSpaceND:()=>nu,Bincount:()=>au,BitwiseAnd:()=>ru,BroadcastArgs:()=>Mc,BroadcastTo:()=>HS,Callback:()=>PC,CallbackList:()=>A2,Cast:()=>Mi,Ceil:()=>Oi,ClipByValue:()=>ws,Complex:()=>wm,ComplexAbs:()=>Oc,Concat:()=>su,Conv2D:()=>Pi,Conv2DBackpropFilter:()=>km,Conv2DBackpropInput:()=>Li,Conv3D:()=>zi,Conv3DBackpropFilterV2:()=>iu,Conv3DBackpropInputV2:()=>ou,Cos:()=>Wi,Cosh:()=>Bi,CropAndResize:()=>uu,Cumprod:()=>lu,Cumsum:()=>Vi,CustomCallback:()=>$2,DataStorage:()=>ym,DenseBincount:()=>Pc,DepthToSpace:()=>pu,DepthwiseConv2dNative:()=>Ui,DepthwiseConv2dNativeBackpropFilter:()=>Im,DepthwiseConv2dNativeBackpropInput:()=>Sm,Diag:()=>Lc,Dilation2D:()=>Gi,Dilation2DBackpropFilter:()=>Rl,Dilation2DBackpropInput:()=>Dl,Draw:()=>Nm,ENV:()=>Tv,EarlyStopping:()=>LC,Einsum:()=>Tm,Elu:()=>ji,EluGrad:()=>cu,Environment:()=>US,Equal:()=>du,Erf:()=>qi,Exp:()=>Ki,ExpandDims:()=>hu,Expm1:()=>Xi,FFT:()=>Cm,Fill:()=>zc,FlipLeftRight:()=>mu,Floor:()=>Yi,FloorDiv:()=>Zi,FromPixels:()=>Hh,FusedBatchNorm:()=>Ji,FusedConv2D:()=>oi,FusedDepthwiseConv2D:()=>li,GPGPUContext:()=>Wh,GatherNd:()=>gu,GatherV2:()=>fu,GraphModel:()=>F1,Greater:()=>bu,GreaterEqual:()=>Qi,History:()=>F2,IFFT:()=>Em,Identity:()=>eo,Imag:()=>_m,InputSpec:()=>zt,IsFinite:()=>to,IsInf:()=>no,IsNan:()=>ao,KernelBackend:()=>Fc,LRN:()=>oo,LRNGrad:()=>Su,LayerVariable:()=>k2,LayersModel:()=>Er,LeakyRelu:()=>ro,Less:()=>yu,LessEqual:()=>xu,LinSpace:()=>vu,Log:()=>so,Log1p:()=>io,LogSoftmax:()=>qS,LogicalAnd:()=>wu,LogicalNot:()=>ku,LogicalOr:()=>Iu,LogicalXor:()=>jS,LowerBound:()=>dM,MathBackendCPU:()=>R1,MathBackendWebGL:()=>lk,MatrixBandPart:()=>hM,Max:()=>lo,MaxPool:()=>po,MaxPool3D:()=>Nu,MaxPool3DGrad:()=>Bc,MaxPoolGrad:()=>Wc,MaxPoolWithArgmax:()=>Vc,Maximum:()=>uo,Mean:()=>co,Min:()=>ho,Minimum:()=>mo,MirrorPad:()=>fo,Mod:()=>go,MomentumOptimizer:()=>jw,Multinomial:()=>Tu,Multiply:()=>bo,Neg:()=>Cu,NonMaxSuppressionV3:()=>_u,NonMaxSuppressionV4:()=>Au,NonMaxSuppressionV5:()=>Fu,NotEqual:()=>Eu,OP_SCOPE_SUFFIX:()=>Fv,OneHot:()=>yo,OnesLike:()=>$u,Optimizer:()=>Rr,OptimizerConstructors:()=>t2,Pack:()=>Du,PadV2:()=>xo,Pool:()=>mM,Pow:()=>vo,Prelu:()=>wo,Prod:()=>ko,RMSPropOptimizer:()=>qw,RNN:()=>Mr,RaggedGather:()=>Am,RaggedRange:()=>Fm,RaggedTensorToTensor:()=>$m,Range:()=>Uc,Rank:()=>kx,Real:()=>Dm,RealDiv:()=>Hi,Reciprocal:()=>Io,Reduction:()=>kn,Relu:()=>So,Relu6:()=>Co,Reshape:()=>Ru,ResizeBilinear:()=>To,ResizeBilinearGrad:()=>Ou,ResizeNearestNeighbor:()=>No,ResizeNearestNeighborGrad:()=>Mu,Reverse:()=>Eo,RotateWithOffset:()=>Zu,Round:()=>_o,Rsqrt:()=>Ao,SGDOptimizer:()=>ff,ScatterNd:()=>Pu,SearchSorted:()=>zu,Select:()=>Wu,Selu:()=>Fo,Sequential:()=>Ef,Sigmoid:()=>Mo,Sign:()=>Ro,Sin:()=>$o,Sinh:()=>Do,Slice:()=>Bu,Softmax:()=>zo,Softplus:()=>Oo,SpaceToBatchND:()=>Vu,SparseFillEmptyRows:()=>Gc,SparseReshape:()=>Gu,SparseSegmentMean:()=>Hc,SparseSegmentSum:()=>jc,SparseToDense:()=>Hu,SplitV:()=>Uu,Sqrt:()=>Po,Square:()=>qc,SquaredDifference:()=>Wo,StaticRegexReplace:()=>Kc,Step:()=>Is,StridedSlice:()=>ju,StringNGrams:()=>Xc,StringSplit:()=>Yc,StringToHashBucketFast:()=>Zc,Sub:()=>Bo,Sum:()=>Lo,SymbolicTensor:()=>Ha,Tan:()=>Vo,Tanh:()=>Uo,Tensor:()=>Ce,TensorBuffer:()=>Wt,TensorScatterUpdate:()=>Lu,Tile:()=>ks,TopK:()=>qu,Transform:()=>Ku,Transpose:()=>Cr,Unique:()=>Jc,Unpack:()=>Xu,UnsortedSegmentSum:()=>Qc,UpperBound:()=>fM,Variable:()=>os,ZerosLike:()=>Yu,_FusedMatMul:()=>ii,abs:()=>Lt,acos:()=>Pv,acosh:()=>Lv,add:()=>X,addN:()=>vN,all:()=>Lm,any:()=>yc,argMax:()=>di,argMin:()=>zv,asin:()=>Wv,asinh:()=>Bv,atan:()=>Vv,atan2:()=>Uv,atanh:()=>Gv,avgPool:()=>ya,avgPool3d:()=>jv,backend:()=>Dv,backend_util:()=>T,basicLSTMCell:()=>SN,batchNorm:()=>Ns,batchNorm2d:()=>qv,batchNorm3d:()=>Kv,batchNorm4d:()=>Xv,batchToSpaceND:()=>id,bincount:()=>Yv,bitwiseAnd:()=>NN,booleanMaskAsync:()=>mT,broadcastArgs:()=>TN,broadcastTo:()=>ai,broadcast_util:()=>Ju,browser:()=>qo,buffer:()=>Oe,callbacks:()=>dq,cast:()=>re,ceil:()=>Zv,clipByValue:()=>an,clone:()=>sr,complex:()=>_r,concat:()=>et,concat1d:()=>Jv,concat2d:()=>Qv,concat3d:()=>ew,concat4d:()=>tw,constraints:()=>T2,conv1d:()=>zm,conv2d:()=>$t,conv2dTranspose:()=>Wm,conv3d:()=>aw,conv3dTranspose:()=>rw,copyRegisteredKernels:()=>xM,cos:()=>od,cosh:()=>Bm,cosineWindow:()=>pf,cumprod:()=>wc,cumsum:()=>Vm,customGrad:()=>pr,data:()=>lE,denseBincount:()=>Xh,deprecationWarn:()=>$v,depthToSpace:()=>sw,depthwiseConv2d:()=>Ts,deregisterOp:()=>fq,device_util:()=>ad,diag:()=>EN,dilation2d:()=>iw,disableDeprecationWarnings:()=>ZM,dispose:()=>Ee,disposeVariables:()=>JM,div:()=>he,divNoNan:()=>ow,dot:()=>lw,dropout:()=>Pw,einsum:()=>Zs,elu:()=>Qu,enableDebugMode:()=>YM,enableProdMode:()=>XM,enclosingPowerOfTwo:()=>Lw,engine:()=>Ta,ensureShape:()=>AN,env:()=>G,equal:()=>Jn,erf:()=>Um,euclideanNorm:()=>cw,exp:()=>dn,expandDims:()=>Gt,expm1:()=>dw,eye:()=>Gm,fft:()=>bd,fill:()=>yn,findBackend:()=>rO,findBackendFactory:()=>sO,floor:()=>tp,floorDiv:()=>Pm,forceHalfFloat:()=>$A,fused:()=>Vl,gather:()=>np,gatherND:()=>yT,gather_util:()=>Yw,getBackend:()=>oN,getGradient:()=>vx,getKernel:()=>fc,getKernelsForBackend:()=>jh,getThreadsCount:()=>_fe,gpgpu_util:()=>uA,grad:()=>P3,grads:()=>L3,greater:()=>Cn,greaterEqual:()=>$r,ifft:()=>Bl,imag:()=>ld,image:()=>Zn,inTopKAsync:()=>xT,initializers:()=>C2,input:()=>j2,io:()=>jt,irfft:()=>af,isFinite:()=>hw,isInf:()=>mw,isNaN:()=>fw,keep:()=>Ht,kernel_impls:()=>mr,layers:()=>E2,leakyRelu:()=>ud,less:()=>Pl,lessEqual:()=>Cs,linalg:()=>Bw,linspace:()=>MN,loadGraphModel:()=>w5,loadGraphModelSync:()=>k5,loadLayersModel:()=>oj,localResponseNormalization:()=>gw,log:()=>Qn,log1p:()=>pd,logSigmoid:()=>bw,logSoftmax:()=>jm,logSumExp:()=>cd,logicalAnd:()=>_a,logicalNot:()=>dd,logicalOr:()=>qm,logicalXor:()=>yw,losses:()=>FT,lowerBound:()=>PN,matMul:()=>$e,math:()=>VT,max:()=>ma,maxPool:()=>Dt,maxPool3d:()=>xw,maxPoolWithArgmax:()=>LN,maximum:()=>hr,mean:()=>Ct,memory:()=>Kh,meshgrid:()=>zN,metrics:()=>RC,min:()=>Ol,minimum:()=>ds,mirrorPad:()=>vw,mod:()=>ww,model:()=>pj,models:()=>MC,moments:()=>hd,movingAverage:()=>fT,mul:()=>z,multiRNNCell:()=>WN,multinomial:()=>BN,neg:()=>yt,nextFrame:()=>Zw,norm:()=>ep,notEqual:()=>fi,oneHot:()=>Ll,ones:()=>Pn,onesLike:()=>ea,op:()=>L,outerProduct:()=>VN,pad:()=>xa,pad1d:()=>UN,pad2d:()=>GN,pad3d:()=>HN,pad4d:()=>jN,pool:()=>kw,pow:()=>ur,prelu:()=>fd,print:()=>Ov,prod:()=>Iw,profile:()=>QM,raggedGather:()=>qN,raggedRange:()=>KN,raggedTensorToTensor:()=>XN,rand:()=>YN,randomGamma:()=>eT,randomNormal:()=>Xm,randomStandardNormal:()=>tT,randomUniform:()=>Es,randomUniformInt:()=>nT,range:()=>gi,ready:()=>nO,real:()=>zl,reciprocal:()=>Ew,registerBackend:()=>Om,registerCallbackConstructor:()=>dj,registerGradient:()=>KS,registerKernel:()=>ed,registerOp:()=>mq,regularizers:()=>OC,relu:()=>Ke,relu6:()=>Ym,removeBackend:()=>aO,reshape:()=>W,reverse:()=>ba,reverse1d:()=>aT,reverse2d:()=>rT,reverse3d:()=>sT,reverse4d:()=>iT,rfft:()=>yd,round:()=>Zm,rsqrt:()=>Jm,scalar:()=>xe,scatterND:()=>gT,scatter_util:()=>sf,searchSorted:()=>Km,selu:()=>Qm,separableConv2d:()=>_s,sequential:()=>cj,serialization:()=>ne,setBackend:()=>tO,setPlatform:()=>iO,setThreadsCount:()=>Efe,setWasmPath:()=>Tfe,setWasmPaths:()=>Cfe,setWebGLContext:()=>D_,setdiff1dAsync:()=>oT,shared:()=>M1,sigmoid:()=>ha,sign:()=>_w,signal:()=>AT,sin:()=>ef,sinh:()=>tf,slice:()=>Ve,slice1d:()=>gd,slice2d:()=>nf,slice3d:()=>Ho,slice4d:()=>Wl,slice_util:()=>Kt,softmax:()=>qa,softplus:()=>Go,spaceToBatchND:()=>md,sparse:()=>$T,sparseToDense:()=>bT,spectral:()=>_T,split:()=>Ln,sqrt:()=>rn,square:()=>pt,squaredDifference:()=>rf,squeeze:()=>As,stack:()=>At,step:()=>jo,stridedSlice:()=>Aw,string:()=>DT,sub:()=>pe,sum:()=>fe,sumOutType:()=>Mm,tan:()=>Fw,tanh:()=>cs,tensor:()=>bn,tensor1d:()=>je,tensor2d:()=>Ea,tensor3d:()=>xd,tensor4d:()=>Fa,tensor5d:()=>lT,tensor6d:()=>uT,tensorScatterUpdate:()=>cT,tensor_util:()=>Wa,test_util:()=>ZN,tidy:()=>O,tile:()=>On,time:()=>eO,topk:()=>Dw,train:()=>Xs,transpose:()=>De,truncatedNormal:()=>lf,unique:()=>Rw,unregisterGradient:()=>yM,unregisterKernel:()=>bM,unsortedSegmentSum:()=>uf,unstack:()=>dt,upcastType:()=>fa,upperBound:()=>dT,util:()=>w,valueAndGrad:()=>z3,valueAndGrads:()=>W3,variable:()=>Mw,variableGrads:()=>ON,version:()=>Ofe,version_converter:()=>S5,version_core:()=>p4,version_cpu:()=>NK,version_layers:()=>v0,version_wasm:()=>Afe,version_webgl:()=>mee,webgl:()=>fee,webgl_util:()=>$_,where:()=>nn,whereAsync:()=>Ow,zeros:()=>It,zerosLike:()=>qe});var kR=Object.create,kv=Object.defineProperty,IR=Object.getOwnPropertyDescriptor,SR=Object.getOwnPropertyNames,NR=Object.getPrototypeOf,TR=Object.prototype.hasOwnProperty,Vt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),_e=(e,t)=>{for(var n in t)kv(e,n,{get:t[n],enumerable:!0})},CR=(e,t,n,a)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of SR(t))!TR.call(e,r)&&r!==n&&kv(e,r,{get:()=>t[r],enumerable:!(a=IR(t,r))||a.enumerable});return e},xs=(e,t,n)=>(n=e!=null?kR(NR(e)):{},CR(t||!e||!e.__esModule?kv(n,\"default\",{value:e,enumerable:!0}):n,e)),ER=Vt((e,t)=>{t.exports=a;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(S){}function a(S,M,B){this.low=S|0,this.high=M|0,this.unsigned=!!B}a.prototype.__isLong__,Object.defineProperty(a.prototype,\"__isLong__\",{value:!0});function r(S){return(S&&S.__isLong__)===!0}a.isLong=r;var s={},i={};function o(S,M){var B,U,H;return M?(S>>>=0,(H=0<=S&&S<256)&&(U=i[S],U)?U:(B=u(S,(S|0)<0?-1:0,!0),H&&(i[S]=B),B)):(S|=0,(H=-128<=S&&S<128)&&(U=s[S],U)?U:(B=u(S,S<0?-1:0,!1),H&&(s[S]=B),B))}a.fromInt=o;function l(S,M){if(isNaN(S))return M?v:x;if(M){if(S<0)return v;if(S>=g)return F}else{if(S<=-b)return D;if(S+1>=b)return _}return S<0?l(-S,M).neg():u(S%f|0,S/f|0,M)}a.fromNumber=l;function u(S,M,B){return new a(S,M,B)}a.fromBits=u;var p=Math.pow;function d(S,M,B){if(S.length===0)throw Error(\"empty string\");if(S===\"NaN\"||S===\"Infinity\"||S===\"+Infinity\"||S===\"-Infinity\")return x;if(typeof M==\"number\"?(B=M,M=!1):M=!!M,B=B||10,B<2||36<B)throw RangeError(\"radix\");var U;if((U=S.indexOf(\"-\"))>0)throw Error(\"interior hyphen\");if(U===0)return d(S.substring(1),M,B).neg();for(var H=l(p(B,8)),q=x,K=0;K<S.length;K+=8){var Z=Math.min(8,S.length-K),J=parseInt(S.substring(K,K+Z),B);if(Z<8){var ee=l(p(B,Z));q=q.mul(ee).add(l(J))}else q=q.mul(H),q=q.add(l(J))}return q.unsigned=M,q}a.fromString=d;function c(S,M){return typeof S==\"number\"?l(S,M):typeof S==\"string\"?d(S,M):u(S.low,S.high,typeof M==\"boolean\"?M:S.unsigned)}a.fromValue=c;var h=65536,m=1<<24,f=h*h,g=f*f,b=g/2,y=o(m),x=o(0);a.ZERO=x;var v=o(0,!0);a.UZERO=v;var I=o(1);a.ONE=I;var N=o(1,!0);a.UONE=N;var C=o(-1);a.NEG_ONE=C;var _=u(-1,2147483647,!1);a.MAX_VALUE=_;var F=u(-1,-1,!0);a.MAX_UNSIGNED_VALUE=F;var D=u(0,-2147483648,!1);a.MIN_VALUE=D;var $=a.prototype;$.toInt=function(){return this.unsigned?this.low>>>0:this.low},$.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},$.toString=function(S){if(S=S||10,S<2||36<S)throw RangeError(\"radix\");if(this.isZero())return\"0\";if(this.isNegative())if(this.eq(D)){var M=l(S),B=this.div(M),U=B.mul(M).sub(this);return B.toString(S)+U.toInt().toString(S)}else return\"-\"+this.neg().toString(S);for(var H=l(p(S,6),this.unsigned),q=this,K=\"\";;){var Z=q.div(H),J=q.sub(Z.mul(H)).toInt()>>>0,ee=J.toString(S);if(q=Z,q.isZero())return ee+K;for(;ee.length<6;)ee=\"0\"+ee;K=\"\"+ee+K}},$.getHighBits=function(){return this.high},$.getHighBitsUnsigned=function(){return this.high>>>0},$.getLowBits=function(){return this.low},$.getLowBitsUnsigned=function(){return this.low>>>0},$.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var S=this.high!=0?this.high:this.low,M=31;M>0&&!(S&1<<M);M--);return this.high!=0?M+33:M+1},$.isZero=function(){return this.high===0&&this.low===0},$.eqz=$.isZero,$.isNegative=function(){return!this.unsigned&&this.high<0},$.isPositive=function(){return this.unsigned||this.high>=0},$.isOdd=function(){return(this.low&1)===1},$.isEven=function(){return(this.low&1)===0},$.equals=function(S){return r(S)||(S=c(S)),this.unsigned!==S.unsigned&&this.high>>>31===1&&S.high>>>31===1?!1:this.high===S.high&&this.low===S.low},$.eq=$.equals,$.notEquals=function(S){return!this.eq(S)},$.neq=$.notEquals,$.ne=$.notEquals,$.lessThan=function(S){return this.comp(S)<0},$.lt=$.lessThan,$.lessThanOrEqual=function(S){return this.comp(S)<=0},$.lte=$.lessThanOrEqual,$.le=$.lessThanOrEqual,$.greaterThan=function(S){return this.comp(S)>0},$.gt=$.greaterThan,$.greaterThanOrEqual=function(S){return this.comp(S)>=0},$.gte=$.greaterThanOrEqual,$.ge=$.greaterThanOrEqual,$.compare=function(S){if(r(S)||(S=c(S)),this.eq(S))return 0;var M=this.isNegative(),B=S.isNegative();return M&&!B?-1:!M&&B?1:this.unsigned?S.high>>>0>this.high>>>0||S.high===this.high&&S.low>>>0>this.low>>>0?-1:1:this.sub(S).isNegative()?-1:1},$.comp=$.compare,$.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add(I)},$.neg=$.negate,$.add=function(S){r(S)||(S=c(S));var M=this.high>>>16,B=this.high&65535,U=this.low>>>16,H=this.low&65535,q=S.high>>>16,K=S.high&65535,Z=S.low>>>16,J=S.low&65535,ee=0,ae=0,te=0,se=0;return se+=H+J,te+=se>>>16,se&=65535,te+=U+Z,ae+=te>>>16,te&=65535,ae+=B+K,ee+=ae>>>16,ae&=65535,ee+=M+q,ee&=65535,u(te<<16|se,ee<<16|ae,this.unsigned)},$.subtract=function(S){return r(S)||(S=c(S)),this.add(S.neg())},$.sub=$.subtract,$.multiply=function(S){if(this.isZero())return x;if(r(S)||(S=c(S)),n){var M=n.mul(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}if(S.isZero())return x;if(this.eq(D))return S.isOdd()?D:x;if(S.eq(D))return this.isOdd()?D:x;if(this.isNegative())return S.isNegative()?this.neg().mul(S.neg()):this.neg().mul(S).neg();if(S.isNegative())return this.mul(S.neg()).neg();if(this.lt(y)&&S.lt(y))return l(this.toNumber()*S.toNumber(),this.unsigned);var B=this.high>>>16,U=this.high&65535,H=this.low>>>16,q=this.low&65535,K=S.high>>>16,Z=S.high&65535,J=S.low>>>16,ee=S.low&65535,ae=0,te=0,se=0,ie=0;return ie+=q*ee,se+=ie>>>16,ie&=65535,se+=H*ee,te+=se>>>16,se&=65535,se+=q*J,te+=se>>>16,se&=65535,te+=U*ee,ae+=te>>>16,te&=65535,te+=H*J,ae+=te>>>16,te&=65535,te+=q*Z,ae+=te>>>16,te&=65535,ae+=B*ee+U*J+H*Z+q*K,ae&=65535,u(se<<16|ie,ae<<16|te,this.unsigned)},$.mul=$.multiply,$.divide=function(S){if(r(S)||(S=c(S)),S.isZero())throw Error(\"division by zero\");if(n){if(!this.unsigned&&this.high===-2147483648&&S.low===-1&&S.high===-1)return this;var M=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:x;var B,U,H;if(this.unsigned){if(S.unsigned||(S=S.toUnsigned()),S.gt(this))return v;if(S.gt(this.shru(1)))return N;H=v}else{if(this.eq(D)){if(S.eq(I)||S.eq(C))return D;if(S.eq(D))return I;var q=this.shr(1);return B=q.div(S).shl(1),B.eq(x)?S.isNegative()?I:C:(U=this.sub(S.mul(B)),H=B.add(U.div(S)),H)}else if(S.eq(D))return this.unsigned?v:x;if(this.isNegative())return S.isNegative()?this.neg().div(S.neg()):this.neg().div(S).neg();if(S.isNegative())return this.div(S.neg()).neg();H=x}for(U=this;U.gte(S);){B=Math.max(1,Math.floor(U.toNumber()/S.toNumber()));for(var K=Math.ceil(Math.log(B)/Math.LN2),Z=K<=48?1:p(2,K-48),J=l(B),ee=J.mul(S);ee.isNegative()||ee.gt(U);)B-=Z,J=l(B,this.unsigned),ee=J.mul(S);J.isZero()&&(J=I),H=H.add(J),U=U.sub(ee)}return H},$.div=$.divide,$.modulo=function(S){if(r(S)||(S=c(S)),n){var M=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,S.low,S.high);return u(M,n.get_high(),this.unsigned)}return this.sub(this.div(S).mul(S))},$.mod=$.modulo,$.rem=$.modulo,$.not=function(){return u(~this.low,~this.high,this.unsigned)},$.and=function(S){return r(S)||(S=c(S)),u(this.low&S.low,this.high&S.high,this.unsigned)},$.or=function(S){return r(S)||(S=c(S)),u(this.low|S.low,this.high|S.high,this.unsigned)},$.xor=function(S){return r(S)||(S=c(S)),u(this.low^S.low,this.high^S.high,this.unsigned)},$.shiftLeft=function(S){return r(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?u(this.low<<S,this.high<<S|this.low>>>32-S,this.unsigned):u(0,this.low<<S-32,this.unsigned)},$.shl=$.shiftLeft,$.shiftRight=function(S){return r(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?u(this.low>>>S|this.high<<32-S,this.high>>S,this.unsigned):u(this.high>>S-32,this.high>=0?0:-1,this.unsigned)},$.shr=$.shiftRight,$.shiftRightUnsigned=function(S){if(r(S)&&(S=S.toInt()),S&=63,S===0)return this;var M=this.high;if(S<32){var B=this.low;return u(B>>>S|M<<32-S,M>>>S,this.unsigned)}else return S===32?u(M,0,this.unsigned):u(M>>>S-32,0,this.unsigned)},$.shru=$.shiftRightUnsigned,$.shr_u=$.shiftRightUnsigned,$.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},$.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},$.toBytes=function(S){return S?this.toBytesLE():this.toBytesBE()},$.toBytesLE=function(){var S=this.high,M=this.low;return[M&255,M>>>8&255,M>>>16&255,M>>>24,S&255,S>>>8&255,S>>>16&255,S>>>24]},$.toBytesBE=function(){var S=this.high,M=this.low;return[S>>>24,S>>>16&255,S>>>8&255,S&255,M>>>24,M>>>16&255,M>>>8&255,M&255]},a.fromBytes=function(S,M,B){return B?a.fromBytesLE(S,M):a.fromBytesBE(S,M)},a.fromBytesLE=function(S,M){return new a(S[0]|S[1]<<8|S[2]<<16|S[3]<<24,S[4]|S[5]<<8|S[6]<<16|S[7]<<24,M)},a.fromBytesBE=function(S,M){return new a(S[4]<<24|S[5]<<16|S[6]<<8|S[7],S[0]<<24|S[1]<<16|S[2]<<8|S[3],M)}}),_R=Vt(()=>{}),AR=Vt(()=>{}),FR=Vt((e,t)=>{(function(n,a,r){function s(u){var p=this,d=l();p.next=function(){var c=2091639*p.s0+p.c*23283064365386963e-26;return p.s0=p.s1,p.s1=p.s2,p.s2=c-(p.c=c|0)},p.c=1,p.s0=d(\" \"),p.s1=d(\" \"),p.s2=d(\" \"),p.s0-=d(u),p.s0<0&&(p.s0+=1),p.s1-=d(u),p.s1<0&&(p.s1+=1),p.s2-=d(u),p.s2<0&&(p.s2+=1),d=null}function i(u,p){return p.c=u.c,p.s0=u.s0,p.s1=u.s1,p.s2=u.s2,p}function o(u,p){var d=new s(u),c=p&&p.state,h=d.next;return h.int32=function(){return d.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,c&&(typeof c==\"object\"&&i(c,d),h.state=function(){return i(d,{})}),h}function l(){var u=4022871197,p=function(d){d=String(d);for(var c=0;c<d.length;c++){u+=d.charCodeAt(c);var h=.02519603282416938*u;u=h>>>0,h-=u,h*=u,u=h>>>0,h-=u,u+=h*4294967296}return(u>>>0)*23283064365386963e-26};return p}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),$R=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this,p=\"\";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var c=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^c^c>>>8},l===(l|0)?u.x=l:p+=l;for(var d=0;d<p.length+64;d++)u.x^=p.charCodeAt(d)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(typeof d==\"object\"&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),DR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this,p=\"\";u.next=function(){var c=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(c^c<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:p+=l;for(var d=0;d<p.length+64;d++)u.x^=p.charCodeAt(d)|0,d==p.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(typeof d==\"object\"&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),RR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this;u.next=function(){var d=u.x,c=u.i,h,m,f;return h=d[c],h^=h>>>7,m=h^h<<24,h=d[c+1&7],m^=h^h>>>10,h=d[c+3&7],m^=h^h>>>3,h=d[c+4&7],m^=h^h<<7,h=d[c+7&7],h=h^h<<13,m^=h^h<<9,d[c]=m,u.i=c+1&7,m};function p(d,c){var h,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=\"\"+c,h=0;h<c.length;++h)f[h&7]=f[h&7]<<15^c.charCodeAt(h)+f[h+1&7]<<13;for(;f.length<8;)f.push(0);for(h=0;h<8&&f[h]===0;++h);for(h==8?m=f[7]=-1:m=f[h],d.x=f,d.i=0,h=256;h>0;--h)d.next()}p(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(d.x&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),MR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this;u.next=function(){var d=u.w,c=u.X,h=u.i,m,f;return u.w=d=d+1640531527|0,f=c[h+34&127],m=c[h=h+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[h]=f^m,u.i=h,f+(d^d>>>16)|0};function p(d,c){var h,m,f,g,b,y=[],x=128;for(c===(c|0)?(m=c,c=null):(c=c+\"\\0\",m=0,x=Math.max(x,c.length)),f=0,g=-32;g<x;++g)c&&(m^=c.charCodeAt((g+32)%c.length)),g===0&&(b=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,g>=0&&(b=b+1640531527|0,h=y[g&127]^=m+b,f=h==0?f+1:0);for(f>=128&&(y[(c&&c.length||0)&127]=-1),f=127,g=4*128;g>0;--g)m=y[f+34&127],h=y[f=f+1&127],m^=m<<13,h^=h<<17,m^=m>>>15,h^=h>>>12,y[f]=m^h;d.w=b,d.X=y,d.i=f}p(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(d.X&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),OR=Vt((e,t)=>{(function(n,a,r){function s(l){var u=this,p=\"\";u.next=function(){var c=u.b,h=u.c,m=u.d,f=u.a;return c=c<<25^c>>>7^h,h=h-m|0,m=m<<24^m>>>8^f,f=f-c|0,u.b=c=c<<20^c>>>12^h,u.c=h=h-m|0,u.d=m<<16^h>>>16^f,u.a=f-c|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):p+=l;for(var d=0;d<p.length+20;d++)u.b^=p.charCodeAt(d)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var p=new s(l),d=u&&u.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var h=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(h+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,d&&(typeof d==\"object\"&&i(d,p),c.state=function(){return i(p,{})}),c}a&&a.exports?a.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(e,typeof t==\"object\"&&t,typeof define==\"function\"&&define)}),PR=Vt(()=>{}),LR=Vt((e,t)=>{(function(n,a,r){var s=256,i=6,o=52,l=\"random\",u=r.pow(s,i),p=r.pow(2,o),d=p*2,c=s-1,h;function m(I,N,C){var _=[];N=N==!0?{entropy:!0}:N||{};var F=y(b(N.entropy?[I,v(a)]:I==null?x():I,3),_),D=new f(_),$=function(){for(var S=D.g(i),M=u,B=0;S<p;)S=(S+B)*s,M*=s,B=D.g(1);for(;S>=d;)S/=2,M/=2,B>>>=1;return(S+B)/M};return $.int32=function(){return D.g(4)|0},$.quick=function(){return D.g(4)/4294967296},$.double=$,y(v(D.S),a),(N.pass||C||function(S,M,B,U){return U&&(U.S&&g(U,D),S.state=function(){return g(D,{})}),B?(r[l]=S,M):S})($,F,\"global\"in N?N.global:this==r,N.state)}function f(I){var N,C=I.length,_=this,F=0,D=_.i=_.j=0,$=_.S=[];for(C||(I=[C++]);F<s;)$[F]=F++;for(F=0;F<s;F++)$[F]=$[D=c&D+I[F%C]+(N=$[F])],$[D]=N;(_.g=function(S){for(var M,B=0,U=_.i,H=_.j,q=_.S;S--;)M=q[U=c&U+1],B=B*s+q[c&(q[U]=q[H=c&H+M])+(q[H]=M)];return _.i=U,_.j=H,B})(s)}function g(I,N){return N.i=I.i,N.j=I.j,N.S=I.S.slice(),N}function b(I,N){var C=[],_=typeof I,F;if(N&&_==\"object\")for(F in I)try{C.push(b(I[F],N-1))}catch(D){}return C.length?C:_==\"string\"?I:I+\"\\0\"}function y(I,N){for(var C=I+\"\",_,F=0;F<C.length;)N[c&F]=c&(_^=N[c&F]*19)+C.charCodeAt(F++);return v(N)}function x(){try{var I;return h&&(I=h.randomBytes)?I=I(s):(I=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(I)),v(I)}catch(_){var N=n.navigator,C=N&&N.plugins;return[+new Date,n,C,n.screen,v(a)]}}function v(I){return String.fromCharCode.apply(0,I)}if(y(r.random(),a),typeof t==\"object\"&&t.exports){t.exports=m;try{h=PR()}catch(I){}}else typeof define==\"function\"&&__webpack_require__.amdO?define(function(){return m}):r[\"seed\"+l]=m})(typeof self!=\"undefined\"?self:e,[],Math)}),bm=Vt((e,t)=>{var n=FR(),a=$R(),r=DR(),s=RR(),i=MR(),o=OR(),l=LR();l.alea=n,l.xor128=a,l.xorwow=r,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),FS=Vt(()=>{}),Iv=Vt(()=>{}),$S=Vt(()=>{}),zR=Vt(()=>{}),WR=Vt(()=>{}),BR=Vt(()=>{}),VR=Vt((e,t)=>{var n=(()=>{var a=typeof document!=\"undefined\"&&document.currentScript?document.currentScript.src:void 0;return  true&&(a=a||__filename),function(r){r=r||{};function s(){return ue.buffer!=Re&&ut(ue.buffer),gt}function i(){return ue.buffer!=Re&&ut(ue.buffer),Gn}function o(){return ue.buffer!=Re&&ut(ue.buffer),Ot}function l(){return ue.buffer!=Re&&ut(ue.buffer),un}function u(){return ue.buffer!=Re&&ut(ue.buffer),Fn}function p(){return ue.buffer!=Re&&ut(ue.buffer),oa}function d(){return ue.buffer!=Re&&ut(ue.buffer),$n}var c=typeof r!=\"undefined\"?r:{},h,m;c.ready=new Promise(function(R,j){h=R,m=j});var f;typeof process!=\"undefined\"&&process.listeners&&(f={uncaughtException:process.listeners(\"uncaughtException\"),unhandledRejection:process.listeners(\"unhandledRejection\")});var g=Object.assign({},c),b=[],y=\"./this.program\",x=(R,j)=>{throw j},v=typeof window==\"object\",I=typeof importScripts==\"function\",N=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",C=c.ENVIRONMENT_IS_PTHREAD||!1,_=\"\";function F(R){return c.locateFile?c.locateFile(R,_):_+R}var D,$,S,M;function B(R){R instanceof Gs||J(\"exiting due to exception: \"+R)}if(N){var U=Iv(),H=$S();I?_=H.dirname(_)+\"/\":_=__dirname+\"/\",D=(j,le)=>(j=gl(j)?new URL(j):H.normalize(j),U.readFileSync(j,le?void 0:\"utf8\")),S=j=>{var le=D(j,!0);return le.buffer||(le=new Uint8Array(le)),le},$=(j,le,Ne)=>{j=gl(j)?new URL(j):H.normalize(j),U.readFile(j,function(Me,Fe){Me?Ne(Me):le(Fe.buffer)})},process.argv.length>1&&(y=process.argv[1].replace(/\\\\/g,\"/\")),b=process.argv.slice(2),process.on(\"uncaughtException\",function(j){if(!(j instanceof Gs))throw j}),process.on(\"unhandledRejection\",function(j){throw j}),x=(j,le)=>{if(Ia())throw process.exitCode=j,le;B(le),process.exit(j)},c.inspect=function(){return\"[Emscripten Module object]\"};let R;try{R=zR()}catch(j){throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'),j}global.Worker=R.Worker}else(v||I)&&(I?_=self.location.href:typeof document!=\"undefined\"&&document.currentScript&&(_=document.currentScript.src),typeof a!=\"undefined\"&&a&&(_=a),_.indexOf(\"blob:\")!==0?_=_.substr(0,_.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):_=\"\",N||(D=R=>{var j=new XMLHttpRequest;return j.open(\"GET\",R,!1),j.send(null),j.responseText},I&&(S=R=>{var j=new XMLHttpRequest;return j.open(\"GET\",R,!1),j.responseType=\"arraybuffer\",j.send(null),new Uint8Array(j.response)}),$=(R,j,le)=>{var Ne=new XMLHttpRequest;Ne.open(\"GET\",R,!0),Ne.responseType=\"arraybuffer\",Ne.onload=()=>{if(Ne.status==200||Ne.status==0&&Ne.response){j(Ne.response);return}le()},Ne.onerror=le,Ne.send(null)}),M=R=>document.title=R);N&&typeof performance==\"undefined\"&&(global.performance=WR().performance);var q=console.log.bind(console),K=console.warn.bind(console);N&&(q=R=>U.writeSync(1,R+`\n`),K=R=>U.writeSync(2,R+`\n`));var Z=c.print||q,J=c.printErr||K;Object.assign(c,g),g=null,c.arguments&&(b=c.arguments),c.thisProgram&&(y=c.thisProgram),c.quit&&(x=c.quit);var ee=4,ae=Atomics.load,te=Atomics.store,se=Atomics.compareExchange,ie;c.wasmBinary&&(ie=c.wasmBinary);var ve=c.noExitRuntime||!0;typeof WebAssembly!=\"object\"&&Us(\"no native wasm support detected\");var ue,ye,ke=!1,Se;function Le(R,j){R||Us(j)}var Ue=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):void 0;function mt(R,j,le){j>>>=0;for(var Ne=j+le,Me=j;R[Me]&&!(Me>=Ne);)++Me;if(Me-j>16&&R.buffer&&Ue)return Ue.decode(R.buffer instanceof SharedArrayBuffer?R.slice(j,Me):R.subarray(j,Me));for(var Fe=\"\";j<Me;){var me=R[j++];if(!(me&128)){Fe+=String.fromCharCode(me);continue}var we=R[j++]&63;if((me&224)==192){Fe+=String.fromCharCode((me&31)<<6|we);continue}var Tt=R[j++]&63;if((me&240)==224?me=(me&15)<<12|we<<6|Tt:me=(me&7)<<18|we<<12|Tt<<6|R[j++]&63,me<65536)Fe+=String.fromCharCode(me);else{var ua=me-65536;Fe+=String.fromCharCode(55296|ua>>10,56320|ua&1023)}}return Fe}function st(R,j){return R>>>=0,R?mt(i(),R,j):\"\"}function tt(R,j,le,Ne){if(le>>>=0,!(Ne>0))return 0;for(var Me=le,Fe=le+Ne-1,me=0;me<R.length;++me){var we=R.charCodeAt(me);if(we>=55296&&we<=57343){var Tt=R.charCodeAt(++me);we=65536+((we&1023)<<10)|Tt&1023}if(we<=127){if(le>=Fe)break;j[le++>>>0]=we}else if(we<=2047){if(le+1>=Fe)break;j[le++>>>0]=192|we>>6,j[le++>>>0]=128|we&63}else if(we<=65535){if(le+2>=Fe)break;j[le++>>>0]=224|we>>12,j[le++>>>0]=128|we>>6&63,j[le++>>>0]=128|we&63}else{if(le+3>=Fe)break;j[le++>>>0]=240|we>>18,j[le++>>>0]=128|we>>12&63,j[le++>>>0]=128|we>>6&63,j[le++>>>0]=128|we&63}}return j[le>>>0]=0,le-Me}function nt(R,j,le){return tt(R,i(),j,le)}var Re,gt,Gn,Ot,ia,un,Fn,oa,$n;C&&(Re=c.buffer);function ut(R){Re=R,c.HEAP8=gt=new Int8Array(R),c.HEAP16=Ot=new Int16Array(R),c.HEAP32=un=new Int32Array(R),c.HEAPU8=Gn=new Uint8Array(R),c.HEAPU16=ia=new Uint16Array(R),c.HEAPU32=Fn=new Uint32Array(R),c.HEAPF32=oa=new Float32Array(R),c.HEAPF64=$n=new Float64Array(R)}var Dn=c.INITIAL_MEMORY||16777216;if(C)ue=c.wasmMemory,Re=c.buffer;else if(c.wasmMemory)ue=c.wasmMemory;else if(ue=new WebAssembly.Memory({initial:Dn/65536,maximum:65536,shared:!0}),!(ue.buffer instanceof SharedArrayBuffer))throw J(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),N&&J(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"),Error(\"bad memory\");ue&&(Re=ue.buffer),Dn=Re.byteLength,ut(Re);var Hn,xr=[],ml=[],Za=[],Wp=!1;function Ia(){return ve}function Ur(){if(c.preRun)for(typeof c.preRun==\"function\"&&(c.preRun=[c.preRun]);c.preRun.length;)Sg(c.preRun.shift());Vp(xr)}function Jt(){Wp=!0,!C&&Vp(ml)}function Hd(){if(!C){if(c.postRun)for(typeof c.postRun==\"function\"&&(c.postRun=[c.postRun]);c.postRun.length;)Rk(c.postRun.shift());Vp(Za)}}function Sg(R){xr.unshift(R)}function Ng(R){ml.unshift(R)}function Rk(R){Za.unshift(R)}var Gr=0,fl=null,vr=null;function Tg(R){Gr++,c.monitorRunDependencies&&c.monitorRunDependencies(Gr)}function jd(R){if(Gr--,c.monitorRunDependencies&&c.monitorRunDependencies(Gr),Gr==0&&(fl!==null&&(clearInterval(fl),fl=null),vr)){var j=vr;vr=null,j()}}function Us(R){c.onAbort&&c.onAbort(R),R=\"Aborted(\"+R+\")\",J(R),ke=!0,Se=1,R+=\". Build with -sASSERTIONS for more info.\";var j=new WebAssembly.RuntimeError(R);throw m(j),j}var Cg=\"data:application/octet-stream;base64,\";function qd(R){return R.startsWith(Cg)}function gl(R){return R.startsWith(\"file://\")}var gn;gn=\"tfjs-backend-wasm-threaded-simd.wasm\",qd(gn)||(gn=F(gn));function Kd(R){try{if(R==gn&&ie)return new Uint8Array(ie);if(S)return S(R);throw\"both async and sync fetching of the wasm failed\"}catch(j){Us(j)}}function Eg(){if(!ie&&(v||I)){if(typeof fetch==\"function\"&&!gl(gn))return fetch(gn,{credentials:\"same-origin\"}).then(function(R){if(!R.ok)throw\"failed to load wasm binary file at '\"+gn+\"'\";return R.arrayBuffer()}).catch(function(){return Kd(gn)});if($)return new Promise(function(R,j){$(gn,function(le){R(new Uint8Array(le))},j)})}return Promise.resolve().then(function(){return Kd(gn)})}function _g(){var R={env:oh,wasi_snapshot_preview1:oh};function j(me,we){var Tt=me.exports;if(c.asm=Tt,Lg(c.asm._emscripten_tls_init),Hn=c.asm.__indirect_function_table,Ng(c.asm.__wasm_call_ctors),ye=we,!C){var ua=Ae.unusedWorkers.length;Ae.unusedWorkers.forEach(function(kr){Ae.loadWasmModuleToWorker(kr,function(){--ua||jd(\"wasm-instantiate\")})})}}C||Tg(\"wasm-instantiate\");function le(me){j(me.instance,me.module)}function Ne(me){return Eg().then(function(we){return WebAssembly.instantiate(we,R)}).then(function(we){return we}).then(me,function(we){J(\"failed to asynchronously prepare wasm: \"+we),Us(we)})}function Me(){return!ie&&typeof WebAssembly.instantiateStreaming==\"function\"&&!qd(gn)&&!gl(gn)&&!N&&typeof fetch==\"function\"?fetch(gn,{credentials:\"same-origin\"}).then(function(me){var we=WebAssembly.instantiateStreaming(me,R);return we.then(le,function(Tt){return J(\"wasm streaming compile failed: \"+Tt),J(\"falling back to ArrayBuffer instantiation\"),Ne(le)})}):Ne(le)}if(c.instantiateWasm)try{var Fe=c.instantiateWasm(R,j);return Fe}catch(me){J(\"Module.instantiateWasm callback failed with error: \"+me),m(me)}return Me().catch(m),{}}var Mk,Ok,Xd={};function Gs(R){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+R+\")\",this.status=R}function Ag(R){var j=Ae.pthreads[R];delete Ae.pthreads[R],j.terminate(),ex(R),Ae.runningWorkers.splice(Ae.runningWorkers.indexOf(j),1),j.pthread_ptr=0}function Fg(R){var j=Ae.pthreads[R];j.postMessage({cmd:\"cancel\"})}function Bp(R){var j=Ae.pthreads[R];Le(j),Ae.returnWorkerToPool(j)}function $g(R){var j=Ae.getNewWorker();if(!j)return 6;Ae.runningWorkers.push(j),Ae.pthreads[R.pthread_ptr]=j,j.pthread_ptr=R.pthread_ptr;var le={cmd:\"run\",start_routine:R.startRoutine,arg:R.arg,pthread_ptr:R.pthread_ptr};return j.runPthread=()=>{N&&j.ref(),j.postMessage(le,R.transferList),delete j.runPthread},j.loaded&&j.runPthread(),0}var Yd={varargs:void 0,get:function(){Yd.varargs+=4;var R=l()[Yd.varargs-4>>>2];return R},getStr:function(R){var j=st(R);return j}};function Zd(R){if(C)return Hr(1,1,R);Se=R,Ia()||(Ae.terminateAllThreads(),c.onExit&&c.onExit(R),ke=!0),x(R,new Gs(R))}function Dg(R,j){if(Se=R,!j&&C)throw Qd(R),\"unwind\";Zd(R)}var Jd=Dg;function Rg(R){if(R instanceof Gs||R==\"unwind\")return Se;x(1,R)}var Ae={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){C?Ae.initWorker():Ae.initMainThread()},initMainThread:function(){for(var R=8;R--;)Ae.allocateUnusedWorker()},initWorker:function(){ve=!1},setExitStatus:function(R){Se=R},terminateAllThreads:function(){for(var R of Object.values(Ae.pthreads))Ae.returnWorkerToPool(R);for(var R of Ae.unusedWorkers)R.terminate();Ae.unusedWorkers=[]},returnWorkerToPool:function(R){var j=R.pthread_ptr;delete Ae.pthreads[j],Ae.unusedWorkers.push(R),Ae.runningWorkers.splice(Ae.runningWorkers.indexOf(R),1),R.pthread_ptr=0,N&&R.unref(),ex(j)},receiveObjectTransfer:function(R){},threadInitTLS:function(){Ae.tlsInitFunctions.forEach(R=>R())},loadWasmModuleToWorker:function(R,j){R.onmessage=Fe=>{var me=Fe.data,we=me.cmd;if(R.pthread_ptr&&(Ae.currentProxiedOperationCallerThread=R.pthread_ptr),me.targetThread&&me.targetThread!=hh()){var Tt=Ae.pthreads[me.targetThread];Tt?Tt.postMessage(me,me.transferList):J('Internal error! Worker sent a message \"'+we+'\" to target pthread '+me.targetThread+\", but that thread no longer exists!\"),Ae.currentProxiedOperationCallerThread=void 0;return}we===\"processProxyingQueue\"?Up(me.queue):we===\"spawnThread\"?$g(me):we===\"cleanupThread\"?Bp(me.thread):we===\"killThread\"?Ag(me.thread):we===\"cancelThread\"?Fg(me.thread):we===\"loaded\"?(R.loaded=!0,N&&R.unref(),j&&j(R),R.runPthread&&R.runPthread()):we===\"print\"?Z(\"Thread \"+me.threadId+\": \"+me.text):we===\"printErr\"?J(\"Thread \"+me.threadId+\": \"+me.text):we===\"alert\"?alert(\"Thread \"+me.threadId+\": \"+me.text):me.target===\"setimmediate\"?R.postMessage(me):we===\"callHandler\"?c[me.handler](...me.args):we&&J(\"worker sent an unknown command \"+we),Ae.currentProxiedOperationCallerThread=void 0},R.onerror=Fe=>{var me=\"worker sent an error!\";throw J(me+\" \"+Fe.filename+\":\"+Fe.lineno+\": \"+Fe.message),Fe},N&&(R.on(\"message\",function(Fe){R.onmessage({data:Fe})}),R.on(\"error\",function(Fe){R.onerror(Fe)}),R.on(\"detachedExit\",function(){}));var le=[],Ne=[\"onExit\",\"onAbort\",\"print\",\"printErr\"];for(var Me of Ne)c.hasOwnProperty(Me)&&le.push(Me);R.postMessage({cmd:\"load\",handlers:le,urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:ue,wasmModule:ye})},allocateUnusedWorker:function(){var R,j=F(\"tfjs-backend-wasm-threaded-simd.worker.js\");R=new Worker(j),Ae.unusedWorkers.push(R)},getNewWorker:function(){return Ae.unusedWorkers.length==0&&(Ae.allocateUnusedWorker(),Ae.loadWasmModuleToWorker(Ae.unusedWorkers[0])),Ae.unusedWorkers.pop()}};c.PThread=Ae;function Vp(R){for(;R.length>0;)R.shift()(c)}function Mg(){var R=hh(),j=l()[R+52>>>2],le=l()[R+56>>>2],Ne=j-le;Vk(j,Ne),mh(j)}c.establishStackSpace=Mg;function Qd(R){if(C)return Hr(2,0,R);try{Jd(R)}catch(j){Rg(j)}}var bl=[];function Og(R){var j=bl[R];return j||(R>=bl.length&&(bl.length=R+1),bl[R]=j=Hn.get(R)),j}function Pg(R,j){var le=Og(R)(j);Ia()?Ae.setExitStatus(le):Bk(le)}c.invokeEntryPoint=Pg;function Lg(R){Ae.tlsInitFunctions.push(R)}function zg(R){Lk(R,!I,1,!v),Ae.threadInitTLS()}function Wg(R){C?postMessage({cmd:\"cleanupThread\",thread:R}):Bp(R)}function eh(R,j,le,Ne){return C?Hr(3,1,R,j,le,Ne):th(R,j,le,Ne)}function th(R,j,le,Ne){if(typeof SharedArrayBuffer==\"undefined\")return J(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var Me=[],Fe=0;if(C&&(Me.length===0||Fe))return eh(R,j,le,Ne);if(Fe)return Fe;var me={startRoutine:le,pthread_ptr:R,arg:Ne,transferList:Me};return C?(me.cmd=\"spawnThread\",postMessage(me,Me),0):$g(me)}function Bg(){return 65536}var Vg=!0;function Ug(){return Vg}function Up(R){Atomics.store(l(),R>>2,1),hh()&&Wk(R),Atomics.compareExchange(l(),R>>2,1,0)}c.executeNotifiedProxyingQueue=Up;function Gg(R,j,le,Ne){if(R==j)setTimeout(()=>Up(Ne));else if(C)postMessage({targetThread:R,cmd:\"processProxyingQueue\",queue:Ne});else{var Me=Ae.pthreads[R];if(!Me)return;Me.postMessage({cmd:\"processProxyingQueue\",queue:Ne})}return 1}function Hg(R,j,le){return-1}function jg(){Us(\"\")}function Hs(R){Hs.shown||(Hs.shown={}),Hs.shown[R]||(Hs.shown[R]=1,N&&(R=\"warning: \"+R),J(R))}function qg(){N||I||Hs(\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\")}function Kg(){return Date.now()}function nh(){return 4294901760}function Xg(){return nh()}var Gp;N?Gp=()=>{var R=process.hrtime();return R[0]*1e3+R[1]/1e6}:Gp=()=>performance.timeOrigin+performance.now();function Yg(R,j,le){i().copyWithin(R>>>0,j>>>0,j+le>>>0)}function Zg(){return N?BR().cpus().length:navigator.hardwareConcurrency}function Jg(R){var j=tx(),le=R();return mh(j),le}function Hr(R,j){var le=arguments.length-2,Ne=arguments;return Jg(()=>{for(var Me=le,Fe=fh(Me*8),me=Fe>>3,we=0;we<le;we++){var Tt=Ne[2+we];d()[me+we>>>0]=Tt}return zk(R,Me,Fe,j)})}var Hp=[];function Qg(R,j,le){Hp.length=j;for(var Ne=le>>3,Me=0;Me<j;Me++)Hp[Me]=d()[Ne+Me>>>0];var Fe=R<0,me=Fe?Xd[-R-1]:lb[R];return me.apply(null,Hp)}function eb(R){try{return ue.grow(R-Re.byteLength+65535>>>16),ut(ue.buffer),1}catch(j){}}function tb(R){var j=i().length;if(R=R>>>0,R<=j)return!1;var le=nh();if(R>le)return!1;let Ne=(Tt,ua)=>Tt+(ua-Tt%ua)%ua;for(var Me=1;Me<=4;Me*=2){var Fe=j*(1+.2/Me);Fe=Math.min(Fe,R+100663296);var me=Math.min(le,Ne(Math.max(R,Fe),65536)),we=eb(me);if(we)return!0}return!1}function nb(){throw\"unwind\"}function ah(R){return C?Hr(4,1,R):52}function rh(R,j,le,Ne,Me){return C?Hr(5,1,R,j,le,Ne,Me):70}var ab=[null,[],[]];function rb(R,j){var le=ab[R];j===0||j===10?((R===1?Z:J)(mt(le,0)),le.length=0):le.push(j)}function sh(R,j,le,Ne){if(C)return Hr(6,1,R,j,le,Ne);for(var Me=0,Fe=0;Fe<le;Fe++){var me=u()[j>>>2],we=u()[j+4>>>2];j+=8;for(var Tt=0;Tt<we;Tt++)rb(R,i()[me+Tt>>>0]);Me+=we}return u()[Ne>>>2]=Me,0}function ih(R){var j=c[\"_\"+R];return j}function sb(R,j){s().set(R,j>>>0)}function ib(R,j,le,Ne,Me){var Fe={string:pa=>{var wl=0;if(pa!=null&&pa!==0){var Hk=(pa.length<<2)+1;wl=fh(Hk),nt(pa,wl,Hk)}return wl},array:pa=>{var wl=fh(pa.length);return sb(pa,wl),wl}};function me(pa){return j===\"string\"?st(pa):j===\"boolean\"?!!pa:pa}var we=ih(R),Tt=[],ua=0;if(Ne)for(var kr=0;kr<Ne.length;kr++){var Gk=Fe[le[kr]];Gk?(ua===0&&(ua=tx()),Tt[kr]=Gk(Ne[kr])):Tt[kr]=Ne[kr]}var nx=we.apply(null,Tt);function xR(pa){return ua!==0&&mh(ua),me(pa)}return nx=xR(nx),nx}function ob(R,j,le,Ne){le=le||[];var Me=le.every(me=>me===\"number\"||me===\"boolean\"),Fe=j!==\"string\";return Fe&&Me&&!Ne?ih(R):function(){return ib(R,j,le,arguments,Ne)}}Ae.init();var lb=[null,Zd,Qd,eh,ah,rh,sh],oh={__emscripten_init_main_thread_js:zg,__emscripten_thread_cleanup:Wg,__pthread_create_js:th,_emscripten_default_pthread_stack_size:Bg,_emscripten_get_now_is_monotonic:Ug,_emscripten_notify_task_queue:Gg,_emscripten_set_offscreencanvas_size:Hg,abort:jg,emscripten_check_blocking_allowed:qg,emscripten_date_now:Kg,emscripten_get_heap_max:Xg,emscripten_get_now:Gp,emscripten_memcpy_big:Yg,emscripten_num_logical_cores:Zg,emscripten_receive_on_main_thread_js:Qg,emscripten_resize_heap:tb,emscripten_unwind_to_js_event_loop:nb,exit:Jd,fd_close:ah,fd_seek:rh,fd_write:sh,memory:ue||c.wasmMemory},Pk=_g(),ub=c.___wasm_call_ctors=function(){return(ub=c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},pb=c._init=function(){return(pb=c._init=c.asm.init).apply(null,arguments)},cb=c._init_with_threads_count=function(){return(cb=c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},db=c._get_threads_count=function(){return(db=c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},hb=c._register_tensor=function(){return(hb=c._register_tensor=c.asm.register_tensor).apply(null,arguments)},mb=c._dispose_data=function(){return(mb=c._dispose_data=c.asm.dispose_data).apply(null,arguments)},fb=c._dispose=function(){return(fb=c._dispose=c.asm.dispose).apply(null,arguments)},gb=c._Abs=function(){return(gb=c._Abs=c.asm.Abs).apply(null,arguments)},bb=c._Acos=function(){return(bb=c._Acos=c.asm.Acos).apply(null,arguments)},yb=c._Acosh=function(){return(yb=c._Acosh=c.asm.Acosh).apply(null,arguments)},xb=c._Add=function(){return(xb=c._Add=c.asm.Add).apply(null,arguments)},vb=c._AddN=function(){return(vb=c._AddN=c.asm.AddN).apply(null,arguments)},wb=c._All=function(){return(wb=c._All=c.asm.All).apply(null,arguments)},kb=c._Any=function(){return(kb=c._Any=c.asm.Any).apply(null,arguments)},Ib=c._ArgMax=function(){return(Ib=c._ArgMax=c.asm.ArgMax).apply(null,arguments)},Sb=c._ArgMin=function(){return(Sb=c._ArgMin=c.asm.ArgMin).apply(null,arguments)},Nb=c._Asin=function(){return(Nb=c._Asin=c.asm.Asin).apply(null,arguments)},Tb=c._Asinh=function(){return(Tb=c._Asinh=c.asm.Asinh).apply(null,arguments)},Cb=c._Atan=function(){return(Cb=c._Atan=c.asm.Atan).apply(null,arguments)},Eb=c._Atan2=function(){return(Eb=c._Atan2=c.asm.Atan2).apply(null,arguments)},_b=c._Atanh=function(){return(_b=c._Atanh=c.asm.Atanh).apply(null,arguments)},Ab=c._AvgPool=function(){return(Ab=c._AvgPool=c.asm.AvgPool).apply(null,arguments)},Fb=c._AvgPool3D=function(){return(Fb=c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},$b=c._AvgPool3DGrad=function(){return($b=c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},Db=c._AvgPoolGrad=function(){return(Db=c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},Rb=c._BatchMatMul=function(){return(Rb=c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},Mb=c._Bincount=function(){return(Mb=c._Bincount=c.asm.Bincount).apply(null,arguments)},Ob=c._BitwiseAnd=function(){return(Ob=c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},Pb=c._Ceil=function(){return(Pb=c._Ceil=c.asm.Ceil).apply(null,arguments)},Lb=c._ClipByValue=function(){return(Lb=c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},zb=c._Conv2D=function(){return(zb=c._Conv2D=c.asm.Conv2D).apply(null,arguments)},Wb=c._Conv2DBackpropInput=function(){return(Wb=c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},Bb=c._Conv3D=function(){return(Bb=c._Conv3D=c.asm.Conv3D).apply(null,arguments)},Vb=c._Conv3DBackpropFilterV2=function(){return(Vb=c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Ub=c._Conv3DBackpropInputV2=function(){return(Ub=c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},Gb=c._Cos=function(){return(Gb=c._Cos=c.asm.Cos).apply(null,arguments)},Hb=c._Cosh=function(){return(Hb=c._Cosh=c.asm.Cosh).apply(null,arguments)},jb=c._CropAndResize=function(){return(jb=c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},qb=c._Cumprod=function(){return(qb=c._Cumprod=c.asm.Cumprod).apply(null,arguments)},Kb=c._Cumsum=function(){return(Kb=c._Cumsum=c.asm.Cumsum).apply(null,arguments)},Xb=c._DenseBincount=function(){return(Xb=c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},Yb=c._DepthToSpace=function(){return(Yb=c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},Zb=c._DepthwiseConv2dNative=function(){return(Zb=c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},Jb=c._Diag=function(){return(Jb=c._Diag=c.asm.Diag).apply(null,arguments)},Qb=c._Dilation2D=function(){return(Qb=c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},ey=c._Dilation2DBackpropFilter=function(){return(ey=c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},ty=c._Dilation2DBackpropInput=function(){return(ty=c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},ny=c._Elu=function(){return(ny=c._Elu=c.asm.Elu).apply(null,arguments)},ay=c._EluGrad=function(){return(ay=c._EluGrad=c.asm.EluGrad).apply(null,arguments)},ry=c._Equal=function(){return(ry=c._Equal=c.asm.Equal).apply(null,arguments)},sy=c._Erf=function(){return(sy=c._Erf=c.asm.Erf).apply(null,arguments)},iy=c._Exp=function(){return(iy=c._Exp=c.asm.Exp).apply(null,arguments)},oy=c._Expm1=function(){return(oy=c._Expm1=c.asm.Expm1).apply(null,arguments)},ly=c._FlipLeftRight=function(){return(ly=c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},uy=c._Floor=function(){return(uy=c._Floor=c.asm.Floor).apply(null,arguments)},py=c._FloorDiv=function(){return(py=c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},cy=c._FusedBatchNorm=function(){return(cy=c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},dy=c._FusedConv2D=function(){return(dy=c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},hy=c._FusedDepthwiseConv2D=function(){return(hy=c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},my=c._Gather=function(){return(my=c._Gather=c.asm.Gather).apply(null,arguments)},fy=c._GatherNd=function(){return(fy=c._GatherNd=c.asm.GatherNd).apply(null,arguments)},gy=c._Greater=function(){return(gy=c._Greater=c.asm.Greater).apply(null,arguments)},by=c._GreaterEqual=function(){return(by=c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},yy=c._IsFinite=function(){return(yy=c._IsFinite=c.asm.IsFinite).apply(null,arguments)},xy=c._IsInf=function(){return(xy=c._IsInf=c.asm.IsInf).apply(null,arguments)},vy=c._IsNan=function(){return(vy=c._IsNan=c.asm.IsNan).apply(null,arguments)},wy=c._LRN=function(){return(wy=c._LRN=c.asm.LRN).apply(null,arguments)},ky=c._LRNGrad=function(){return(ky=c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},Iy=c._LeakyRelu=function(){return(Iy=c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},Sy=c._Less=function(){return(Sy=c._Less=c.asm.Less).apply(null,arguments)},Ny=c._LessEqual=function(){return(Ny=c._LessEqual=c.asm.LessEqual).apply(null,arguments)},Ty=c._LinSpace=function(){return(Ty=c._LinSpace=c.asm.LinSpace).apply(null,arguments)},Cy=c._Log=function(){return(Cy=c._Log=c.asm.Log).apply(null,arguments)},Ey=c._Log1p=function(){return(Ey=c._Log1p=c.asm.Log1p).apply(null,arguments)},_y=c._LogicalAnd=function(){return(_y=c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},Ay=c._LogicalNot=function(){return(Ay=c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},Fy=c._LogicalOr=function(){return(Fy=c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},$y=c._LogicalXor=function(){return($y=c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},Dy=c._Max=function(){return(Dy=c._Max=c.asm.Max).apply(null,arguments)},Ry=c._MaxPool=function(){return(Ry=c._MaxPool=c.asm.MaxPool).apply(null,arguments)},My=c._MaxPool3D=function(){return(My=c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},Oy=c._MaxPool3DGrad=function(){return(Oy=c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},Py=c._MaxPoolGrad=function(){return(Py=c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},Ly=c._MaxPoolWithArgmax=function(){return(Ly=c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},zy=c._Maximum=function(){return(zy=c._Maximum=c.asm.Maximum).apply(null,arguments)},Wy=c._Mean=function(){return(Wy=c._Mean=c.asm.Mean).apply(null,arguments)},By=c._Min=function(){return(By=c._Min=c.asm.Min).apply(null,arguments)},Vy=c._Minimum=function(){return(Vy=c._Minimum=c.asm.Minimum).apply(null,arguments)},Uy=c._MirrorPad=function(){return(Uy=c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},Gy=c._Mod=function(){return(Gy=c._Mod=c.asm.Mod).apply(null,arguments)},Hy=c._Multinomial=function(){return(Hy=c._Multinomial=c.asm.Multinomial).apply(null,arguments)},jy=c._Multiply=function(){return(jy=c._Multiply=c.asm.Multiply).apply(null,arguments)},qy=c._Neg=function(){return(qy=c._Neg=c.asm.Neg).apply(null,arguments)},Ky=c._NonMaxSuppressionV3=function(){return(Ky=c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},Xy=c._NonMaxSuppressionV4=function(){return(Xy=c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},lh=c._NonMaxSuppressionV5=function(){return(lh=c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},uh=c._NotEqual=function(){return(uh=c._NotEqual=c.asm.NotEqual).apply(null,arguments)},jp=c._OneHot=function(){return(jp=c._OneHot=c.asm.OneHot).apply(null,arguments)},Yy=c._PadV2=function(){return(Yy=c._PadV2=c.asm.PadV2).apply(null,arguments)},Zy=c._Pow=function(){return(Zy=c._Pow=c.asm.Pow).apply(null,arguments)},yl=c._Prelu=function(){return(yl=c._Prelu=c.asm.Prelu).apply(null,arguments)},ph=c._Prod=function(){return(ph=c._Prod=c.asm.Prod).apply(null,arguments)},xl=c._RealDiv=function(){return(xl=c._RealDiv=c.asm.RealDiv).apply(null,arguments)},vl=c._Reciprocal=function(){return(vl=c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},Jy=c._Relu=function(){return(Jy=c._Relu=c.asm.Relu).apply(null,arguments)},Y=c._Relu6=function(){return(Y=c._Relu6=c.asm.Relu6).apply(null,arguments)},oe=c._ResizeBilinear=function(){return(oe=c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},Ie=c._ResizeBilinearGrad=function(){return(Ie=c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},Ye=c._ResizeNearestNeighbor=function(){return(Ye=c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},wt=c._ResizeNearestNeighborGrad=function(){return(wt=c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},kt=c._Reverse=function(){return(kt=c._Reverse=c.asm.Reverse).apply(null,arguments)},Ge=c._RotateWithOffset=function(){return(Ge=c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},Be=c._Round=function(){return(Be=c._Round=c.asm.Round).apply(null,arguments)},Pt=c._Rsqrt=function(){return(Pt=c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},la=c._ScatterNd=function(){return(la=c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},wr=c._SearchSorted=function(){return(wr=c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},ch=c._SelectV2=function(){return(ch=c._SelectV2=c.asm.SelectV2).apply(null,arguments)},qp=c._Selu=function(){return(qp=c._Selu=c.asm.Selu).apply(null,arguments)},Qy=c._Sigmoid=function(){return(Qy=c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},Rn=c._Sign=function(){return(Rn=c._Sign=c.asm.Sign).apply(null,arguments)},jr=c._Sin=function(){return(jr=c._Sin=c.asm.Sin).apply(null,arguments)},dh=c._Sinh=function(){return(dh=c._Sinh=c.asm.Sinh).apply(null,arguments)},BD=c._Softmax=function(){return(BD=c._Softmax=c.asm.Softmax).apply(null,arguments)},VD=c._Softplus=function(){return(VD=c._Softplus=c.asm.Softplus).apply(null,arguments)},UD=c._SparseFillEmptyRows=function(){return(UD=c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},GD=c._SparseReshape=function(){return(GD=c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},HD=c._SparseSegmentReduction=function(){return(HD=c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},jD=c._SparseToDense=function(){return(jD=c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},qD=c._Sqrt=function(){return(qD=c._Sqrt=c.asm.Sqrt).apply(null,arguments)},KD=c._Square=function(){return(KD=c._Square=c.asm.Square).apply(null,arguments)},XD=c._SquaredDifference=function(){return(XD=c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},YD=c._Step=function(){return(YD=c._Step=c.asm.Step).apply(null,arguments)},ZD=c._StridedSlice=function(){return(ZD=c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},JD=c._Sub=function(){return(JD=c._Sub=c.asm.Sub).apply(null,arguments)},QD=c._Sum=function(){return(QD=c._Sum=c.asm.Sum).apply(null,arguments)},eR=c._Tan=function(){return(eR=c._Tan=c.asm.Tan).apply(null,arguments)},tR=c._Tanh=function(){return(tR=c._Tanh=c.asm.Tanh).apply(null,arguments)},nR=c._TensorScatterUpdate=function(){return(nR=c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},aR=c._Tile=function(){return(aR=c._Tile=c.asm.Tile).apply(null,arguments)},rR=c._TopK=function(){return(rR=c._TopK=c.asm.TopK).apply(null,arguments)},sR=c._Transform=function(){return(sR=c._Transform=c.asm.Transform).apply(null,arguments)},iR=c._Transpose=function(){return(iR=c._Transpose=c.asm.Transpose).apply(null,arguments)},oR=c.__FusedMatMul=function(){return(oR=c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},lR=c._malloc=function(){return(lR=c._malloc=c.asm.malloc).apply(null,arguments)},uR=c._free=function(){return(uR=c._free=c.asm.free).apply(null,arguments)},pR=c.__emscripten_tls_init=function(){return(pR=c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)},hh=c._pthread_self=function(){return(hh=c._pthread_self=c.asm.pthread_self).apply(null,arguments)},cR=c.___errno_location=function(){return(cR=c.___errno_location=c.asm.__errno_location).apply(null,arguments)},Lk=c.__emscripten_thread_init=function(){return(Lk=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)},dR=c.__emscripten_thread_crashed=function(){return(dR=c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},hR=c._emscripten_main_thread_process_queued_calls=function(){return(hR=c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},mR=c._emscripten_main_browser_thread_id=function(){return(mR=c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)},zk=c._emscripten_run_in_main_runtime_thread_js=function(){return(zk=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},fR=c._emscripten_dispatch_to_thread_=function(){return(fR=c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},Wk=c.__emscripten_proxy_execute_task_queue=function(){return(Wk=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},ex=c.__emscripten_thread_free_data=function(){return(ex=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Bk=c.__emscripten_thread_exit=function(){return(Bk=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Vk=c._emscripten_stack_set_limits=function(){return(Vk=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},tx=c.stackSave=function(){return(tx=c.stackSave=c.asm.stackSave).apply(null,arguments)},mh=c.stackRestore=function(){return(mh=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},fh=c.stackAlloc=function(){return(fh=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)},gR=c.dynCall_iijjiiii=function(){return(gR=c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},bR=c.dynCall_jiji=function(){return(bR=c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)};c.keepRuntimeAlive=Ia,c.wasmMemory=ue,c.cwrap=ob,c.ExitStatus=Gs,c.PThread=Ae;var gh;vr=function R(){gh||Uk(),gh||(vr=R)};function Uk(R){if(R=R||b,Gr>0)return;if(C){h(c),Jt(),startWorker(c);return}if(Ur(),Gr>0)return;function j(){gh||(gh=!0,c.calledRun=!0,!ke&&(Jt(),h(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),Hd()))}c.setStatus?(c.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){c.setStatus(\"\")},1),j()},1)):j()}if(c.preInit)for(typeof c.preInit==\"function\"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();Uk();var bh;f&&(bh={uncaughtException:process.listeners(\"uncaughtException\").filter(function(R){return!f.uncaughtException.indexOf(R)>-1}),unhandledRejection:process.listeners(\"unhandledRejection\").filter(function(R){return!f.unhandledRejection.indexOf(R)>-1})});var yh;if(typeof WasmBackendModule!=\"undefined\")yh=WasmBackendModule;else if(typeof r!=\"undefined\")yh=r;else throw new Error(\"Could not find wasm module in post.js\");if(bh){var yR=yh._dispose;yh._dispose=function(){yR(),bh.uncaughtException.forEach(function(R){process.removeListener(\"uncaughtException\",R)}),bh.unhandledRejection.forEach(function(R){process.removeListener(\"unhandledRejection\",R)})}}return r.ready}})();typeof e==\"object\"&&typeof t==\"object\"?t.exports=n:typeof define==\"function\"&&__webpack_require__.amdO?define([],function(){return n}):typeof e==\"object\"&&(e.WasmBackendModuleThreadedSimd=n)}),UR=Vt((e,t)=>{t.exports.wasmWorkerContents=`\"use strict\";var Module={};var ENVIRONMENT_IS_NODE=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require(\"worker_threads\");var parentPort=nodeWorkerThreads.parentPort;parentPort.on(\"message\",data=>onmessage({data:data}));var fs=require(\"fs\");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,\"utf8\")+\"//# sourceURL=\"+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(\" \");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+\"\n\");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:text,threadId:Module[\"_pthread_self\"]()})}var err=threadPrintErr;self.alert=threadAlert;Module[\"instantiateWasm\"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module[\"wasmModule\"],info);receiveInstance(instance);Module[\"wasmModule\"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({\"cmd\":\"loaded\"})};self.onmessage=e=>{try{if(e.data.cmd===\"load\"){Module[\"wasmModule\"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:\"callHandler\",handler:handler,args:[...arguments]})}}Module[\"wasmMemory\"]=e.data.wasmMemory;Module[\"buffer\"]=Module[\"wasmMemory\"].buffer;Module[\"ENVIRONMENT_IS_PTHREAD\"]=true;if(typeof e.data.urlOrBlob==\"string\"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd===\"run\"){Module[\"__emscripten_thread_init\"](e.data.pthread_ptr,0,0,1);Module[\"establishStackSpace\"]();Module[\"PThread\"].receiveObjectTransfer(e.data);Module[\"PThread\"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module[\"executeNotifiedProxyingQueue\"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module[\"invokeEntryPoint\"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!=\"unwind\"){if(ex instanceof Module[\"ExitStatus\"]){if(Module[\"keepRuntimeAlive\"]()){}else{Module[\"__emscripten_thread_exit\"](ex.status)}}else{throw ex}}}}else if(e.data.cmd===\"cancel\"){if(Module[\"_pthread_self\"]()){Module[\"__emscripten_thread_exit\"](-1)}}else if(e.data.target===\"setimmediate\"){}else if(e.data.cmd===\"processProxyingQueue\"){if(initializedJS){Module[\"executeNotifiedProxyingQueue\"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err(\"worker.js received unknown command \"+e.data.cmd);err(e.data)}}catch(ex){if(Module[\"__emscripten_thread_crashed\"]){Module[\"__emscripten_thread_crashed\"]()}throw ex}};`}),GR=Vt((e,t)=>{var n=(()=>{var a=typeof document!=\"undefined\"&&document.currentScript?document.currentScript.src:void 0;return  true&&(a=a||__filename),function(r){r=r||{};var s=typeof r!=\"undefined\"?r:{},i,o;s.ready=new Promise(function(Y,oe){i=Y,o=oe});var l;typeof process!=\"undefined\"&&process.listeners&&(l={uncaughtException:process.listeners(\"uncaughtException\"),unhandledRejection:process.listeners(\"unhandledRejection\")});var u=Object.assign({},s),p=[],d=\"./this.program\",c=(Y,oe)=>{throw oe},h=typeof window==\"object\",m=typeof importScripts==\"function\",f=typeof process==\"object\"&&typeof process.versions==\"object\"&&typeof process.versions.node==\"string\",g=\"\";function b(Y){return s.locateFile?s.locateFile(Y,g):g+Y}var y,x,v,I;function N(Y){Y instanceof fl||D(\"exiting due to exception: \"+Y)}if(f){var C=Iv(),_=$S();m?g=_.dirname(g)+\"/\":g=__dirname+\"/\",y=(Y,oe)=>(Y=Ur(Y)?new URL(Y):_.normalize(Y),C.readFileSync(Y,oe?void 0:\"utf8\")),v=Y=>{var oe=y(Y,!0);return oe.buffer||(oe=new Uint8Array(oe)),oe},x=(Y,oe,Ie)=>{Y=Ur(Y)?new URL(Y):_.normalize(Y),C.readFile(Y,function(Ye,wt){Ye?Ie(Ye):oe(wt.buffer)})},process.argv.length>1&&(d=process.argv[1].replace(/\\\\/g,\"/\")),p=process.argv.slice(2),process.on(\"uncaughtException\",function(Y){if(!(Y instanceof fl))throw Y}),process.on(\"unhandledRejection\",function(Y){throw Y}),c=(Y,oe)=>{if(Gn())throw process.exitCode=Y,oe;N(oe),process.exit(Y)},s.inspect=function(){return\"[Emscripten Module object]\"}}else(h||m)&&(m?g=self.location.href:typeof document!=\"undefined\"&&document.currentScript&&(g=document.currentScript.src),a&&(g=a),g.indexOf(\"blob:\")!==0?g=g.substr(0,g.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):g=\"\",y=Y=>{var oe=new XMLHttpRequest;return oe.open(\"GET\",Y,!1),oe.send(null),oe.responseText},m&&(v=Y=>{var oe=new XMLHttpRequest;return oe.open(\"GET\",Y,!1),oe.responseType=\"arraybuffer\",oe.send(null),new Uint8Array(oe.response)}),x=(Y,oe,Ie)=>{var Ye=new XMLHttpRequest;Ye.open(\"GET\",Y,!0),Ye.responseType=\"arraybuffer\",Ye.onload=()=>{if(Ye.status==200||Ye.status==0&&Ye.response){oe(Ye.response);return}Ie()},Ye.onerror=Ie,Ye.send(null)},I=Y=>document.title=Y);var F=s.print||console.log.bind(console),D=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&(p=s.arguments),s.thisProgram&&(d=s.thisProgram),s.quit&&(c=s.quit);var $=4,S;s.wasmBinary&&(S=s.wasmBinary);var M=s.noExitRuntime||!0;typeof WebAssembly!=\"object\"&&Za(\"no native wasm support detected\");var B,U=!1,H;function q(Y,oe){Y||Za(oe)}var K=typeof TextDecoder!=\"undefined\"?new TextDecoder(\"utf8\"):void 0;function Z(Y,oe,Ie){oe>>>=0;for(var Ye=oe+Ie,wt=oe;Y[wt]&&!(wt>=Ye);)++wt;if(wt-oe>16&&Y.buffer&&K)return K.decode(Y.subarray(oe,wt));for(var kt=\"\";oe<wt;){var Ge=Y[oe++];if(!(Ge&128)){kt+=String.fromCharCode(Ge);continue}var Be=Y[oe++]&63;if((Ge&224)==192){kt+=String.fromCharCode((Ge&31)<<6|Be);continue}var Pt=Y[oe++]&63;if((Ge&240)==224?Ge=(Ge&15)<<12|Be<<6|Pt:Ge=(Ge&7)<<18|Be<<12|Pt<<6|Y[oe++]&63,Ge<65536)kt+=String.fromCharCode(Ge);else{var la=Ge-65536;kt+=String.fromCharCode(55296|la>>10,56320|la&1023)}}return kt}function J(Y,oe){return Y>>>=0,Y?Z(ie,Y,oe):\"\"}function ee(Y,oe,Ie,Ye){if(Ie>>>=0,!(Ye>0))return 0;for(var wt=Ie,kt=Ie+Ye-1,Ge=0;Ge<Y.length;++Ge){var Be=Y.charCodeAt(Ge);if(Be>=55296&&Be<=57343){var Pt=Y.charCodeAt(++Ge);Be=65536+((Be&1023)<<10)|Pt&1023}if(Be<=127){if(Ie>=kt)break;oe[Ie++>>>0]=Be}else if(Be<=2047){if(Ie+1>=kt)break;oe[Ie++>>>0]=192|Be>>6,oe[Ie++>>>0]=128|Be&63}else if(Be<=65535){if(Ie+2>=kt)break;oe[Ie++>>>0]=224|Be>>12,oe[Ie++>>>0]=128|Be>>6&63,oe[Ie++>>>0]=128|Be&63}else{if(Ie+3>=kt)break;oe[Ie++>>>0]=240|Be>>18,oe[Ie++>>>0]=128|Be>>12&63,oe[Ie++>>>0]=128|Be>>6&63,oe[Ie++>>>0]=128|Be&63}}return oe[Ie>>>0]=0,Ie-wt}function ae(Y,oe,Ie){return ee(Y,ie,oe,Ie)}var te,se,ie,ve,ue,ye,ke,Se,Le;function Ue(Y){te=Y,s.HEAP8=se=new Int8Array(Y),s.HEAP16=ve=new Int16Array(Y),s.HEAP32=ye=new Int32Array(Y),s.HEAPU8=ie=new Uint8Array(Y),s.HEAPU16=ue=new Uint16Array(Y),s.HEAPU32=ke=new Uint32Array(Y),s.HEAPF32=Se=new Float32Array(Y),s.HEAPF64=Le=new Float64Array(Y)}var mt=s.INITIAL_MEMORY||16777216,st,tt=[],nt=[],Re=[],gt=!1;function Gn(){return M}function Ot(){if(s.preRun)for(typeof s.preRun==\"function\"&&(s.preRun=[s.preRun]);s.preRun.length;)Fn(s.preRun.shift());vr(tt)}function ia(){gt=!0,vr(nt)}function un(){if(s.postRun)for(typeof s.postRun==\"function\"&&(s.postRun=[s.postRun]);s.postRun.length;)$n(s.postRun.shift());vr(Re)}function Fn(Y){tt.unshift(Y)}function oa(Y){nt.unshift(Y)}function $n(Y){Re.unshift(Y)}var ut=0,Dn=null,Hn=null;function xr(Y){ut++,s.monitorRunDependencies&&s.monitorRunDependencies(ut)}function ml(Y){if(ut--,s.monitorRunDependencies&&s.monitorRunDependencies(ut),ut==0&&(Dn!==null&&(clearInterval(Dn),Dn=null),Hn)){var oe=Hn;Hn=null,oe()}}function Za(Y){s.onAbort&&s.onAbort(Y),Y=\"Aborted(\"+Y+\")\",D(Y),U=!0,H=1,Y+=\". Build with -sASSERTIONS for more info.\";var oe=new WebAssembly.RuntimeError(Y);throw o(oe),oe}var Wp=\"data:application/octet-stream;base64,\";function Ia(Y){return Y.startsWith(Wp)}function Ur(Y){return Y.startsWith(\"file://\")}var Jt;Jt=\"tfjs-backend-wasm.wasm\",Ia(Jt)||(Jt=b(Jt));function Hd(Y){try{if(Y==Jt&&S)return new Uint8Array(S);if(v)return v(Y);throw\"both async and sync fetching of the wasm failed\"}catch(oe){Za(oe)}}function Sg(){if(!S&&(h||m)){if(typeof fetch==\"function\"&&!Ur(Jt))return fetch(Jt,{credentials:\"same-origin\"}).then(function(Y){if(!Y.ok)throw\"failed to load wasm binary file at '\"+Jt+\"'\";return Y.arrayBuffer()}).catch(function(){return Hd(Jt)});if(x)return new Promise(function(Y,oe){x(Jt,function(Ie){Y(new Uint8Array(Ie))},oe)})}return Promise.resolve().then(function(){return Hd(Jt)})}function Ng(){var Y={env:Bp,wasi_snapshot_preview1:Bp};function oe(Ge,Be){var Pt=Ge.exports;s.asm=Pt,B=s.asm.memory,Ue(B.buffer),st=s.asm.__indirect_function_table,oa(s.asm.__wasm_call_ctors),ml(\"wasm-instantiate\")}xr(\"wasm-instantiate\");function Ie(Ge){oe(Ge.instance)}function Ye(Ge){return Sg().then(function(Be){return WebAssembly.instantiate(Be,Y)}).then(function(Be){return Be}).then(Ge,function(Be){D(\"failed to asynchronously prepare wasm: \"+Be),Za(Be)})}function wt(){return!S&&typeof WebAssembly.instantiateStreaming==\"function\"&&!Ia(Jt)&&!Ur(Jt)&&!f&&typeof fetch==\"function\"?fetch(Jt,{credentials:\"same-origin\"}).then(function(Ge){var Be=WebAssembly.instantiateStreaming(Ge,Y);return Be.then(Ie,function(Pt){return D(\"wasm streaming compile failed: \"+Pt),D(\"falling back to ArrayBuffer instantiation\"),Ye(Ie)})}):Ye(Ie)}if(s.instantiateWasm)try{var kt=s.instantiateWasm(Y,oe);return kt}catch(Ge){D(\"Module.instantiateWasm callback failed with error: \"+Ge),o(Ge)}return wt().catch(o),{}}var Rk,Gr;function fl(Y){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+Y+\")\",this.status=Y}function vr(Y){for(;Y.length>0;)Y.shift()(s)}function Tg(){Za(\"\")}function jd(){return 4294901760}function Us(){return jd()}function Cg(Y,oe,Ie){ie.copyWithin(Y>>>0,oe>>>0,oe+Ie>>>0)}function qd(Y){try{return B.grow(Y-te.byteLength+65535>>>16),Ue(B.buffer),1}catch(oe){}}function gl(Y){var oe=ie.length;Y=Y>>>0;var Ie=jd();if(Y>Ie)return!1;let Ye=(Pt,la)=>Pt+(la-Pt%la)%la;for(var wt=1;wt<=4;wt*=2){var kt=oe*(1+.2/wt);kt=Math.min(kt,Y+100663296);var Ge=Math.min(Ie,Ye(Math.max(Y,kt),65536)),Be=qd(Ge);if(Be)return!0}return!1}var gn={varargs:void 0,get:function(){gn.varargs+=4;var Y=ye[gn.varargs-4>>>2];return Y},getStr:function(Y){var oe=J(Y);return oe}};function Kd(Y){return 52}function Eg(Y,oe,Ie,Ye,wt){return 70}var _g=[null,[],[]];function Mk(Y,oe){var Ie=_g[Y];oe===0||oe===10?((Y===1?F:D)(Z(Ie,0)),Ie.length=0):Ie.push(oe)}function Ok(Y,oe,Ie,Ye){for(var wt=0,kt=0;kt<Ie;kt++){var Ge=ke[oe>>>2],Be=ke[oe+4>>>2];oe+=8;for(var Pt=0;Pt<Be;Pt++)Mk(Y,ie[Ge+Pt>>>0]);wt+=Be}return ke[Ye>>>2]=wt,0}function Xd(Y){var oe=s[\"_\"+Y];return oe}function Gs(Y,oe){se.set(Y,oe>>>0)}function Ag(Y,oe,Ie,Ye,wt){var kt={string:Rn=>{var jr=0;if(Rn!=null&&Rn!==0){var dh=(Rn.length<<2)+1;jr=jp(dh),ae(Rn,jr,dh)}return jr},array:Rn=>{var jr=jp(Rn.length);return Gs(Rn,jr),jr}};function Ge(Rn){return oe===\"string\"?J(Rn):oe===\"boolean\"?!!Rn:Rn}var Be=Xd(Y),Pt=[],la=0;if(Ye)for(var wr=0;wr<Ye.length;wr++){var ch=kt[Ie[wr]];ch?(la===0&&(la=lh()),Pt[wr]=ch(Ye[wr])):Pt[wr]=Ye[wr]}var qp=Be.apply(null,Pt);function Qy(Rn){return la!==0&&uh(la),Ge(Rn)}return qp=Qy(qp),qp}function Fg(Y,oe,Ie,Ye){Ie=Ie||[];var wt=Ie.every(Ge=>Ge===\"number\"||Ge===\"boolean\"),kt=oe!==\"string\";return kt&&wt&&!Ye?Xd(Y):function(){return Ag(Y,oe,Ie,arguments,Ye)}}var Bp={abort:Tg,emscripten_get_heap_max:Us,emscripten_memcpy_big:Cg,emscripten_resize_heap:gl,fd_close:Kd,fd_seek:Eg,fd_write:Ok},$g=Ng(),Yd=s.___wasm_call_ctors=function(){return(Yd=s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},Zd=s._init=function(){return(Zd=s._init=s.asm.init).apply(null,arguments)},Dg=s._init_with_threads_count=function(){return(Dg=s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},Jd=s._get_threads_count=function(){return(Jd=s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},Rg=s._register_tensor=function(){return(Rg=s._register_tensor=s.asm.register_tensor).apply(null,arguments)},Ae=s._dispose_data=function(){return(Ae=s._dispose_data=s.asm.dispose_data).apply(null,arguments)},Vp=s._dispose=function(){return(Vp=s._dispose=s.asm.dispose).apply(null,arguments)},Mg=s._Abs=function(){return(Mg=s._Abs=s.asm.Abs).apply(null,arguments)},Qd=s._Acos=function(){return(Qd=s._Acos=s.asm.Acos).apply(null,arguments)},bl=s._Acosh=function(){return(bl=s._Acosh=s.asm.Acosh).apply(null,arguments)},Og=s._Add=function(){return(Og=s._Add=s.asm.Add).apply(null,arguments)},Pg=s._AddN=function(){return(Pg=s._AddN=s.asm.AddN).apply(null,arguments)},Lg=s._All=function(){return(Lg=s._All=s.asm.All).apply(null,arguments)},zg=s._Any=function(){return(zg=s._Any=s.asm.Any).apply(null,arguments)},Wg=s._ArgMax=function(){return(Wg=s._ArgMax=s.asm.ArgMax).apply(null,arguments)},eh=s._ArgMin=function(){return(eh=s._ArgMin=s.asm.ArgMin).apply(null,arguments)},th=s._Asin=function(){return(th=s._Asin=s.asm.Asin).apply(null,arguments)},Bg=s._Asinh=function(){return(Bg=s._Asinh=s.asm.Asinh).apply(null,arguments)},Vg=s._Atan=function(){return(Vg=s._Atan=s.asm.Atan).apply(null,arguments)},Ug=s._Atan2=function(){return(Ug=s._Atan2=s.asm.Atan2).apply(null,arguments)},Up=s._Atanh=function(){return(Up=s._Atanh=s.asm.Atanh).apply(null,arguments)},Gg=s._AvgPool=function(){return(Gg=s._AvgPool=s.asm.AvgPool).apply(null,arguments)},Hg=s._AvgPool3D=function(){return(Hg=s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},jg=s._AvgPool3DGrad=function(){return(jg=s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},Hs=s._AvgPoolGrad=function(){return(Hs=s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},qg=s._BatchMatMul=function(){return(qg=s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},Kg=s._Bincount=function(){return(Kg=s._Bincount=s.asm.Bincount).apply(null,arguments)},nh=s._BitwiseAnd=function(){return(nh=s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},Xg=s._Ceil=function(){return(Xg=s._Ceil=s.asm.Ceil).apply(null,arguments)},Gp=s._ClipByValue=function(){return(Gp=s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},Yg=s._Conv2D=function(){return(Yg=s._Conv2D=s.asm.Conv2D).apply(null,arguments)},Zg=s._Conv2DBackpropInput=function(){return(Zg=s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},Jg=s._Conv3D=function(){return(Jg=s._Conv3D=s.asm.Conv3D).apply(null,arguments)},Hr=s._Conv3DBackpropFilterV2=function(){return(Hr=s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},Hp=s._Conv3DBackpropInputV2=function(){return(Hp=s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},Qg=s._Cos=function(){return(Qg=s._Cos=s.asm.Cos).apply(null,arguments)},eb=s._Cosh=function(){return(eb=s._Cosh=s.asm.Cosh).apply(null,arguments)},tb=s._CropAndResize=function(){return(tb=s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},nb=s._Cumprod=function(){return(nb=s._Cumprod=s.asm.Cumprod).apply(null,arguments)},ah=s._Cumsum=function(){return(ah=s._Cumsum=s.asm.Cumsum).apply(null,arguments)},rh=s._DenseBincount=function(){return(rh=s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},ab=s._DepthToSpace=function(){return(ab=s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},rb=s._DepthwiseConv2dNative=function(){return(rb=s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},sh=s._Diag=function(){return(sh=s._Diag=s.asm.Diag).apply(null,arguments)},ih=s._Dilation2D=function(){return(ih=s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},sb=s._Dilation2DBackpropFilter=function(){return(sb=s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},ib=s._Dilation2DBackpropInput=function(){return(ib=s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},ob=s._Elu=function(){return(ob=s._Elu=s.asm.Elu).apply(null,arguments)},lb=s._EluGrad=function(){return(lb=s._EluGrad=s.asm.EluGrad).apply(null,arguments)},oh=s._Equal=function(){return(oh=s._Equal=s.asm.Equal).apply(null,arguments)},Pk=s._Erf=function(){return(Pk=s._Erf=s.asm.Erf).apply(null,arguments)},ub=s._Exp=function(){return(ub=s._Exp=s.asm.Exp).apply(null,arguments)},pb=s._Expm1=function(){return(pb=s._Expm1=s.asm.Expm1).apply(null,arguments)},cb=s._FlipLeftRight=function(){return(cb=s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},db=s._Floor=function(){return(db=s._Floor=s.asm.Floor).apply(null,arguments)},hb=s._FloorDiv=function(){return(hb=s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},mb=s._FusedBatchNorm=function(){return(mb=s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},fb=s._FusedConv2D=function(){return(fb=s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},gb=s._FusedDepthwiseConv2D=function(){return(gb=s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},bb=s._Gather=function(){return(bb=s._Gather=s.asm.Gather).apply(null,arguments)},yb=s._GatherNd=function(){return(yb=s._GatherNd=s.asm.GatherNd).apply(null,arguments)},xb=s._Greater=function(){return(xb=s._Greater=s.asm.Greater).apply(null,arguments)},vb=s._GreaterEqual=function(){return(vb=s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},wb=s._IsFinite=function(){return(wb=s._IsFinite=s.asm.IsFinite).apply(null,arguments)},kb=s._IsInf=function(){return(kb=s._IsInf=s.asm.IsInf).apply(null,arguments)},Ib=s._IsNan=function(){return(Ib=s._IsNan=s.asm.IsNan).apply(null,arguments)},Sb=s._LRN=function(){return(Sb=s._LRN=s.asm.LRN).apply(null,arguments)},Nb=s._LRNGrad=function(){return(Nb=s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},Tb=s._LeakyRelu=function(){return(Tb=s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},Cb=s._Less=function(){return(Cb=s._Less=s.asm.Less).apply(null,arguments)},Eb=s._LessEqual=function(){return(Eb=s._LessEqual=s.asm.LessEqual).apply(null,arguments)},_b=s._LinSpace=function(){return(_b=s._LinSpace=s.asm.LinSpace).apply(null,arguments)},Ab=s._Log=function(){return(Ab=s._Log=s.asm.Log).apply(null,arguments)},Fb=s._Log1p=function(){return(Fb=s._Log1p=s.asm.Log1p).apply(null,arguments)},$b=s._LogicalAnd=function(){return($b=s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},Db=s._LogicalNot=function(){return(Db=s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},Rb=s._LogicalOr=function(){return(Rb=s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},Mb=s._LogicalXor=function(){return(Mb=s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},Ob=s._Max=function(){return(Ob=s._Max=s.asm.Max).apply(null,arguments)},Pb=s._MaxPool=function(){return(Pb=s._MaxPool=s.asm.MaxPool).apply(null,arguments)},Lb=s._MaxPool3D=function(){return(Lb=s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},zb=s._MaxPool3DGrad=function(){return(zb=s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},Wb=s._MaxPoolGrad=function(){return(Wb=s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},Bb=s._MaxPoolWithArgmax=function(){return(Bb=s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},Vb=s._Maximum=function(){return(Vb=s._Maximum=s.asm.Maximum).apply(null,arguments)},Ub=s._Mean=function(){return(Ub=s._Mean=s.asm.Mean).apply(null,arguments)},Gb=s._Min=function(){return(Gb=s._Min=s.asm.Min).apply(null,arguments)},Hb=s._Minimum=function(){return(Hb=s._Minimum=s.asm.Minimum).apply(null,arguments)},jb=s._MirrorPad=function(){return(jb=s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},qb=s._Mod=function(){return(qb=s._Mod=s.asm.Mod).apply(null,arguments)},Kb=s._Multinomial=function(){return(Kb=s._Multinomial=s.asm.Multinomial).apply(null,arguments)},Xb=s._Multiply=function(){return(Xb=s._Multiply=s.asm.Multiply).apply(null,arguments)},Yb=s._Neg=function(){return(Yb=s._Neg=s.asm.Neg).apply(null,arguments)},Zb=s._NonMaxSuppressionV3=function(){return(Zb=s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},Jb=s._NonMaxSuppressionV4=function(){return(Jb=s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},Qb=s._NonMaxSuppressionV5=function(){return(Qb=s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},ey=s._NotEqual=function(){return(ey=s._NotEqual=s.asm.NotEqual).apply(null,arguments)},ty=s._OneHot=function(){return(ty=s._OneHot=s.asm.OneHot).apply(null,arguments)},ny=s._PadV2=function(){return(ny=s._PadV2=s.asm.PadV2).apply(null,arguments)},ay=s._Pow=function(){return(ay=s._Pow=s.asm.Pow).apply(null,arguments)},ry=s._Prelu=function(){return(ry=s._Prelu=s.asm.Prelu).apply(null,arguments)},sy=s._Prod=function(){return(sy=s._Prod=s.asm.Prod).apply(null,arguments)},iy=s._RealDiv=function(){return(iy=s._RealDiv=s.asm.RealDiv).apply(null,arguments)},oy=s._Reciprocal=function(){return(oy=s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},ly=s._Relu=function(){return(ly=s._Relu=s.asm.Relu).apply(null,arguments)},uy=s._Relu6=function(){return(uy=s._Relu6=s.asm.Relu6).apply(null,arguments)},py=s._ResizeBilinear=function(){return(py=s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},cy=s._ResizeBilinearGrad=function(){return(cy=s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},dy=s._ResizeNearestNeighbor=function(){return(dy=s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},hy=s._ResizeNearestNeighborGrad=function(){return(hy=s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},my=s._Reverse=function(){return(my=s._Reverse=s.asm.Reverse).apply(null,arguments)},fy=s._RotateWithOffset=function(){return(fy=s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},gy=s._Round=function(){return(gy=s._Round=s.asm.Round).apply(null,arguments)},by=s._Rsqrt=function(){return(by=s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},yy=s._ScatterNd=function(){return(yy=s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},xy=s._SearchSorted=function(){return(xy=s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},vy=s._SelectV2=function(){return(vy=s._SelectV2=s.asm.SelectV2).apply(null,arguments)},wy=s._Selu=function(){return(wy=s._Selu=s.asm.Selu).apply(null,arguments)},ky=s._Sigmoid=function(){return(ky=s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},Iy=s._Sign=function(){return(Iy=s._Sign=s.asm.Sign).apply(null,arguments)},Sy=s._Sin=function(){return(Sy=s._Sin=s.asm.Sin).apply(null,arguments)},Ny=s._Sinh=function(){return(Ny=s._Sinh=s.asm.Sinh).apply(null,arguments)},Ty=s._Softmax=function(){return(Ty=s._Softmax=s.asm.Softmax).apply(null,arguments)},Cy=s._Softplus=function(){return(Cy=s._Softplus=s.asm.Softplus).apply(null,arguments)},Ey=s._SparseFillEmptyRows=function(){return(Ey=s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},_y=s._SparseReshape=function(){return(_y=s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},Ay=s._SparseSegmentReduction=function(){return(Ay=s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},Fy=s._SparseToDense=function(){return(Fy=s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},$y=s._Sqrt=function(){return($y=s._Sqrt=s.asm.Sqrt).apply(null,arguments)},Dy=s._Square=function(){return(Dy=s._Square=s.asm.Square).apply(null,arguments)},Ry=s._SquaredDifference=function(){return(Ry=s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},My=s._Step=function(){return(My=s._Step=s.asm.Step).apply(null,arguments)},Oy=s._StridedSlice=function(){return(Oy=s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},Py=s._Sub=function(){return(Py=s._Sub=s.asm.Sub).apply(null,arguments)},Ly=s._Sum=function(){return(Ly=s._Sum=s.asm.Sum).apply(null,arguments)},zy=s._Tan=function(){return(zy=s._Tan=s.asm.Tan).apply(null,arguments)},Wy=s._Tanh=function(){return(Wy=s._Tanh=s.asm.Tanh).apply(null,arguments)},By=s._TensorScatterUpdate=function(){return(By=s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},Vy=s._Tile=function(){return(Vy=s._Tile=s.asm.Tile).apply(null,arguments)},Uy=s._TopK=function(){return(Uy=s._TopK=s.asm.TopK).apply(null,arguments)},Gy=s._Transform=function(){return(Gy=s._Transform=s.asm.Transform).apply(null,arguments)},Hy=s._Transpose=function(){return(Hy=s._Transpose=s.asm.Transpose).apply(null,arguments)},jy=s.__FusedMatMul=function(){return(jy=s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},qy=s._malloc=function(){return(qy=s._malloc=s.asm.malloc).apply(null,arguments)},Ky=s._free=function(){return(Ky=s._free=s.asm.free).apply(null,arguments)},Xy=s.___errno_location=function(){return(Xy=s.___errno_location=s.asm.__errno_location).apply(null,arguments)},lh=s.stackSave=function(){return(lh=s.stackSave=s.asm.stackSave).apply(null,arguments)},uh=s.stackRestore=function(){return(uh=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},jp=s.stackAlloc=function(){return(jp=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)},Yy=s.dynCall_iijjiiii=function(){return(Yy=s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},Zy=s.dynCall_jiji=function(){return(Zy=s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)};s.cwrap=Fg;var yl;Hn=function Y(){yl||ph(),yl||(Hn=Y)};function ph(Y){if(Y=Y||p,ut>0||(Ot(),ut>0))return;function oe(){yl||(yl=!0,s.calledRun=!0,!U&&(ia(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),un()))}s.setStatus?(s.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){s.setStatus(\"\")},1),oe()},1)):oe()}if(s.preInit)for(typeof s.preInit==\"function\"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();ph();var xl;l&&(xl={uncaughtException:process.listeners(\"uncaughtException\").filter(function(Y){return!l.uncaughtException.indexOf(Y)>-1}),unhandledRejection:process.listeners(\"unhandledRejection\").filter(function(Y){return!l.unhandledRejection.indexOf(Y)>-1})});var vl;if(typeof r!=\"undefined\")vl=r;else if(typeof WasmBackendModuleThreadedSimd!=\"undefined\")vl=WasmBackendModuleThreadedSimd;else throw new Error(\"Could not find wasm module in post.js\");if(xl){var Jy=vl._dispose;vl._dispose=function(){Jy(),xl.uncaughtException.forEach(function(Y){process.removeListener(\"uncaughtException\",Y)}),xl.unhandledRejection.forEach(function(Y){process.removeListener(\"unhandledRejection\",Y)})}}return r.ready}})();typeof e==\"object\"&&typeof t==\"object\"?t.exports=n:typeof define==\"function\"&&__webpack_require__.amdO?define([],function(){return n}):typeof e==\"object\"&&(e.WasmBackendModule=n)}),ym=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Fc=class{refCount(e){return jn(\"refCount\")}incRef(e){return jn(\"incRef\")}timerAvailable(){return!0}time(e){return jn(\"time\")}read(e){return jn(\"read\")}readSync(e){return jn(\"readSync\")}readToGPU(e,t){return jn(\"readToGPU\")}numDataIds(){return jn(\"numDataIds\")}disposeData(e,t){return jn(\"disposeData\")}write(e,t,n){return jn(\"write\")}move(e,t,n,a,r){return jn(\"move\")}createTensorFromGPUData(e,t,n){return jn(\"createTensorFromGPUData\")}memory(){return jn(\"memory\")}floatPrecision(){return jn(\"floatPrecision\")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return jn(\"dispose\")}};function jn(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function DS(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Vh(e,t,n)}function HR(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,Vh(e,n,a),Vh(t,n,a)}function hc(e,t,n){return Math.max(e,Math.min(t,n))}function jR(e){return e%2===0?e:e+1}function Vh(e,t,n){let a=e[t];e[t]=e[n],e[n]=a}function qR(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function KR(e,t){let n=Math.random();return t*n+(1-n)*e}function XR(e,t){let n=0;for(let a=0;a<e.length;a++){let r=Number(e[a])-Number(t[a]);n+=r*r}return n}function A(e,t){if(!e)throw new Error(typeof t==\"string\"?t:t())}function Nn(e,t,n=\"\"){A(Ar(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Si(e){A(e!=null,()=>\"The input to the tensor constructor must be a non-null value.\")}function ot(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function YR(e){return e.length===0}function RS(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Ar(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function $l(e){return e%1===0}function ZR(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function JR(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function QR(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return DS(t),t}function uc(e,t){return t<=e.length?e:e+\" \".repeat(t-e.length)}function eM(e,t=r=>0,n,a){return new Promise((r,s)=>{let i=0,o=()=>{if(e()){r();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}a!=null?a(o,l):setTimeout(o,l)};o()})}function tM(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(a!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${s}`);a=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(a===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let r=e.slice();return r[a]=t/n,r}function Aa(e,t){let n=t.length;return e=e==null?t.map((a,r)=>r):[].concat(e),A(e.every(a=>a>=-n&&a<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),A(e.every(a=>$l(a)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(a=>a<0?n+a:a)}function MS(e,t){let n=[],a=[],r=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||r?null:Aa(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),a.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),a.push(o))}return{newShape:n,keptDims:a}}function OS(e,t){return Sv(e,t)}function Sv(e,t){let n=null;if(e==null||e===\"float32\")n=new Float32Array(t);else if(e===\"int32\")n=new Int32Array(t);else if(e===\"bool\")n=new Uint8Array(t);else if(e===\"string\")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function PS(e,t){for(let n=0;n<e.length;n++){let a=e[n];if(isNaN(a)||!isFinite(a))throw Error(`A tensor of type ${t} being uploaded contains ${a}.`)}}function LS(e){return e===\"bool\"||e===\"complex64\"||e===\"float32\"||e===\"int32\"||e===\"string\"}function nM(e,t){return!(t===\"complex64\"||t===\"float32\"&&e!==\"complex64\"||t===\"int32\"&&e!==\"float32\"&&e!==\"complex64\"||t===\"bool\"&&e===\"bool\")}function Uh(e){if(e===\"float32\"||e===\"int32\")return 4;if(e===\"complex64\")return 8;if(e===\"bool\")return 1;throw new Error(`Unknown dtype ${e}`)}function zS(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Jr(e){return typeof e==\"string\"||e instanceof String}function WS(e){return typeof e==\"boolean\"}function BS(e){return typeof e==\"number\"}function $c(e){return Array.isArray(e)?$c(e[0]):e instanceof Float32Array?\"float32\":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?\"int32\":BS(e)?\"float32\":Jr(e)?\"string\":WS(e)?\"bool\":\"float32\"}function ss(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Gh(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Xl(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function VS(e,t,n,a=!1){let r=new Array;if(t.length===1){let s=t[0]*(a?2:1);for(let i=0;i<s;i++)r[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(a?2:1);for(let l=0;l<s;l++)r[l]=VS(e+l*o,i,n,a)}return r}function El(e,t,n=!1){if(e.length===0)return t[0];let a=e.reduce((r,s)=>r*s)*(n?2:1);if(a===0)return[];if(a!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?\" for a complex tensor\":\"\"}.`);return VS(0,e,t,n)}function aM(e,t){if(Array.isArray(e))return e;if(t===\"float32\")return e instanceof Float32Array?e:new Float32Array(e);if(t===\"int32\")return e instanceof Int32Array?e:new Int32Array(e);if(t===\"bool\"||t===\"string\")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Nv(e,t){let n=xm(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function xm(e,t){if(t==null||t===\"float32\"||t===\"complex64\")return new Float32Array(e);if(t===\"int32\")return new Int32Array(e);if(t===\"bool\")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function rM(e,t){let n=e.reduce((a,r)=>a*r,1);if(t==null||t===\"float32\")return El(e,new Float32Array(n));if(t===\"int32\")return El(e,new Int32Array(n));if(t===\"bool\")return El(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function na(e){e.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function sM(e,t,n){if(t===0)return 0;if(t===1)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function iM(e,t,n){if(t===0)return[];if(t===1)return[e];let a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function vm(e){return e&&e.then&&typeof e.then==\"function\"}var jk=\"tfjsflags\",US=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=oM,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let a=this.urlFlags[e];G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.warn(`Setting feature override from URL ${e}: ${a}.`),this.set(e,a)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(vm(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global==\"undefined\"||typeof this.global.location==\"undefined\"||typeof this.global.location.search==\"undefined\")return;let e=this.getQueryParams(this.global.location.search);jk in e&&e[jk].split(\",\").forEach(t=>{let[n,a]=t.split(\":\");this.urlFlags[n]=uM(n,a)})}};function oM(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...a)=>(lM(t,a[0],a[1]),a.join(\"=\"))),t}function lM(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||\"\")}function uM(e,t){let n=t.toLowerCase();return n===\"true\"||n===\"false\"?n===\"true\":`${+n}`===n?+n:t}function G(){return Tv}var Tv=null;function pM(e){Tv=e}var rx;function GS(){if(rx==null){let e;if(typeof window!=\"undefined\")e=window;else if(typeof global!=\"undefined\")e=global;else if(typeof process!=\"undefined\")e=process;else if(typeof self!=\"undefined\")e=self;else throw new Error(\"Could not find a global object\");rx=e}return rx}function cM(){let e=GS();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Cv(e,t){let n=cM();if(n.has(e))return n.get(e);{let a=t();return n.set(e,a),n.get(e)}}var Yl=\"Abs\",Ni=\"Acos\",Ti=\"Acosh\",vs=\"Add\",Ci=\"AddN\",Zl=\"All\",Jl=\"Any\",Ql=\"ArgMax\",eu=\"ArgMin\",Ei=\"Asin\",_i=\"Asinh\",Ai=\"Atan\",Fi=\"Atanh\",$i=\"Atan2\",Di=\"AvgPool\",Dc=\"AvgPoolGrad\",tu=\"AvgPool3D\",Rc=\"AvgPool3DGrad\",Ri=\"BatchMatMul\",nu=\"BatchToSpaceND\",au=\"Bincount\",ru=\"BitwiseAnd\",HS=\"BroadcastTo\",Mc=\"BroadcastArgs\",Mi=\"Cast\",Oi=\"Ceil\",ws=\"ClipByValue\",wm=\"Complex\",Oc=\"ComplexAbs\",su=\"Concat\",Pi=\"Conv2D\",km=\"Conv2DBackpropFilter\",Li=\"Conv2DBackpropInput\",zi=\"Conv3D\",iu=\"Conv3DBackpropFilterV2\",ou=\"Conv3DBackpropInputV2\",Wi=\"Cos\",Bi=\"Cosh\",lu=\"Cumprod\",Vi=\"Cumsum\",uu=\"CropAndResize\",Pc=\"DenseBincount\",pu=\"DepthToSpace\",Ui=\"DepthwiseConv2dNative\",Im=\"DepthwiseConv2dNativeBackpropFilter\",Sm=\"DepthwiseConv2dNativeBackpropInput\",Lc=\"Diag\",Gi=\"Dilation2D\",Dl=\"Dilation2DBackpropInput\",Rl=\"Dilation2DBackpropFilter\",Nm=\"Draw\",Hi=\"RealDiv\",Tm=\"Einsum\",ji=\"Elu\",cu=\"EluGrad\",qi=\"Erf\",du=\"Equal\",Ki=\"Exp\",hu=\"ExpandDims\",Xi=\"Expm1\",Cm=\"FFT\",zc=\"Fill\",mu=\"FlipLeftRight\",Yi=\"Floor\",Zi=\"FloorDiv\",Ji=\"FusedBatchNorm\",fu=\"GatherV2\",gu=\"GatherNd\",bu=\"Greater\",Qi=\"GreaterEqual\",eo=\"Identity\",Em=\"IFFT\",_m=\"Imag\",to=\"IsFinite\",no=\"IsInf\",ao=\"IsNan\",ro=\"LeakyRelu\",yu=\"Less\",xu=\"LessEqual\",vu=\"LinSpace\",so=\"Log\",io=\"Log1p\",wu=\"LogicalAnd\",ku=\"LogicalNot\",Iu=\"LogicalOr\",jS=\"LogicalXor\",qS=\"LogSoftmax\",dM=\"LowerBound\",oo=\"LRN\",Su=\"LRNGrad\",hM=\"MatrixBandPart\",lo=\"Max\",uo=\"Maximum\",po=\"MaxPool\",Wc=\"MaxPoolGrad\",Nu=\"MaxPool3D\",Bc=\"MaxPool3DGrad\",Vc=\"MaxPoolWithArgmax\",co=\"Mean\",ho=\"Min\",mo=\"Minimum\",fo=\"MirrorPad\",go=\"Mod\",Tu=\"Multinomial\",bo=\"Multiply\",Cu=\"Neg\",Eu=\"NotEqual\",_u=\"NonMaxSuppressionV3\",Au=\"NonMaxSuppressionV4\",Fu=\"NonMaxSuppressionV5\",$u=\"OnesLike\",yo=\"OneHot\",Du=\"Pack\",xo=\"PadV2\",mM=\"Pool\",vo=\"Pow\",wo=\"Prelu\",ko=\"Prod\",Am=\"RaggedGather\",Fm=\"RaggedRange\",$m=\"RaggedTensorToTensor\",Uc=\"Range\",Dm=\"Real\",Io=\"Reciprocal\",So=\"Relu\",Ru=\"Reshape\",No=\"ResizeNearestNeighbor\",Mu=\"ResizeNearestNeighborGrad\",To=\"ResizeBilinear\",Ou=\"ResizeBilinearGrad\",Co=\"Relu6\",Eo=\"Reverse\",_o=\"Round\",Ao=\"Rsqrt\",Pu=\"ScatterNd\",Lu=\"TensorScatterUpdate\",zu=\"SearchSorted\",Wu=\"Select\",Fo=\"Selu\",Bu=\"Slice\",$o=\"Sin\",Do=\"Sinh\",Ro=\"Sign\",Mo=\"Sigmoid\",Oo=\"Softplus\",Po=\"Sqrt\",Lo=\"Sum\",Vu=\"SpaceToBatchND\",Uu=\"SplitV\",zo=\"Softmax\",Gc=\"SparseFillEmptyRows\",Gu=\"SparseReshape\",Hc=\"SparseSegmentMean\",jc=\"SparseSegmentSum\",Hu=\"SparseToDense\",Wo=\"SquaredDifference\",qc=\"Square\",Kc=\"StaticRegexReplace\",ju=\"StridedSlice\",Xc=\"StringNGrams\",Yc=\"StringSplit\",Zc=\"StringToHashBucketFast\",Bo=\"Sub\",Vo=\"Tan\",Uo=\"Tanh\",ks=\"Tile\",qu=\"TopK\",Ku=\"Transform\",Cr=\"Transpose\",Jc=\"Unique\",Xu=\"Unpack\",Qc=\"UnsortedSegmentSum\",fM=\"UpperBound\",Yu=\"ZerosLike\",Is=\"Step\",Hh=\"FromPixels\",Zu=\"RotateWithOffset\",ii=\"_FusedMatMul\",oi=\"FusedConv2D\",li=\"FusedDepthwiseConv2D\";function Zr(...e){G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.warn(...e)}function gM(...e){G().getBool(\"IS_TEST\")||G().getBool(\"PROD\")||console.log(...e)}var Ml=Cv(\"kernelRegistry\",()=>new Map),mc=Cv(\"gradRegistry\",()=>new Map);function fc(e,t){let n=Ev(e,t);return Ml.get(n)}function vx(e){return mc.get(e)}function jh(e){let t=Ml.entries(),n=[];for(;;){let{done:a,value:r}=t.next();if(a)break;let[s,i]=r,[o]=s.split(\"_\");o===e&&n.push(i)}return n}function ed(e){let{kernelName:t,backendName:n}=e,a=Ev(t,n);Ml.has(a)&&Zr(`The kernel '${t}' for backend '${n}' is already registered`),Ml.set(a,e)}function KS(e){let{kernelName:t}=e;mc.has(t)&&G().getBool(\"DEBUG\")&&Zr(`Overriding the gradient for '${t}'`),mc.set(t,e)}function bM(e,t){let n=Ev(e,t);if(!Ml.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Ml.delete(n)}function yM(e){if(!mc.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);mc.delete(e)}function xM(e,t){jh(e).forEach(n=>{let a=Object.assign({},n,{backendName:t});ed(a)})}function Ev(e,t){return`${t}_${e}`}var w={};_e(w,{arraysEqual:()=>Ar,arraysEqualWithNull:()=>RS,assert:()=>A,assertNonNegativeIntegerDimensions:()=>na,assertNonNull:()=>Si,assertShapesMatch:()=>Nn,bytesFromStringArray:()=>zS,bytesPerElement:()=>Uh,checkConversionForErrors:()=>PS,clamp:()=>hc,computeStrides:()=>Xl,convertBackendValuesAndArrayBuffer:()=>aM,createScalarValue:()=>NM,createShuffledIndices:()=>QR,decodeString:()=>qh,distSquared:()=>XR,encodeString:()=>nd,fetch:()=>CM,fingerPrint64:()=>SM,flatten:()=>is,getArrayFromDType:()=>Sv,getTypedArrayFromDType:()=>OS,hasEncodingLoss:()=>nM,hexToLong:()=>td,indexToLoc:()=>iM,inferDtype:()=>$c,inferFromImplicitShape:()=>tM,isBoolean:()=>WS,isFunction:()=>ss,isInt:()=>$l,isNumber:()=>BS,isPromise:()=>vm,isScalarShape:()=>YR,isString:()=>Jr,isTypedArray:()=>en,isValidDtype:()=>LS,locToIndex:()=>sM,makeOnesTypedArray:()=>Nv,makeZerosNestedTypedArray:()=>rM,makeZerosTypedArray:()=>xm,nearestDivisor:()=>Gh,nearestLargerEven:()=>jR,now:()=>gc,parseAxisParam:()=>Aa,randUniform:()=>KR,repeatedTry:()=>eM,rightPad:()=>uc,shuffle:()=>DS,shuffleCombo:()=>HR,sizeFromShape:()=>ot,sizeToSquarishShape:()=>JR,squeezeShape:()=>MS,sum:()=>qR,swap:()=>Vh,tanh:()=>ZR,toNestedArray:()=>El,toTypedArray:()=>Rm});function XS(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var qk=xs(ER()),Ys=qk.default||qk;function td(e){return Ys.fromString(e,!0,16)}var YS=td(\"c3a5c85c97cb3127\"),Ks=td(\"b492b66fbe98f273\"),wn=td(\"9ae16a3b2f90404f\");function wx(e){return e.xor(e.shru(47))}function ZS(e,t,n){let a=e.slice(t,t+n);return Ys.fromBytes(Array.from(a),!0,!0)}function bt(e,t){return ZS(e,t,8)}function Kk(e,t){return ZS(e,t,4)}function Qt(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function ns(e,t,n=td(\"9ddfea08eb382d69\")){let a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function vM(e,t,n,a,r,s){r=r.add(e),s=Qt(s.add(r).add(a),21);let i=r;return r=r.add(t),r=r.add(n),s=s.add(Qt(r,44)),[r.add(a),s.add(i)]}function xh(e,t,n,a){return vM(bt(e,t),bt(e,t+8),bt(e,t+16),bt(e,t+24),n,a)}function wM(e,t=e.length){if(t>=8){let n=wn.add(t*2),a=bt(e,0).add(wn),r=bt(e,t-8),s=Qt(r,37).mul(n).add(a),i=Qt(a,25).add(r).mul(n);return ns(s,i,n)}if(t>=4){let n=wn.add(t*2),a=Kk(e,0);return ns(a.shl(3).add(t),Kk(e,t-4),n)}if(t>0){let n=e[0],a=e[t>>1],r=e[t-1],s=n+(a<<8),i=t+(r<<2);return wx(wn.mul(s).xor(YS.mul(i))).mul(wn)}return wn}function kM(e,t=e.length){let n=wn.add(t*2),a=bt(e,0).mul(Ks),r=bt(e,8),s=bt(e,t-8).mul(n),i=bt(e,t-16).mul(wn);return ns(Qt(a.add(r),43).add(Qt(s,30)).add(i),a.add(Qt(r.add(wn),18)).add(s),n)}function IM(e,t=e.length){let n=wn.add(t*2),a=bt(e,0).mul(wn),r=bt(e,8),s=bt(e,t-8).mul(n),i=bt(e,t-16).mul(wn),o=Qt(a.add(r),43).add(Qt(s,30)).add(i),l=ns(o,a.add(Qt(r.add(wn),18)).add(s),n),u=bt(e,16).mul(n),p=bt(e,24),d=o.add(bt(e,t-32)).mul(n),c=l.add(bt(e,t-24)).mul(n);return ns(Qt(u.add(p),43).add(Qt(d,30)).add(c),u.add(Qt(p.add(a),18)).add(d),n)}function SM(e,t=e.length){let n=Ys.fromNumber(81,!0);if(t<=32)return t<=16?wM(e,t):kM(e,t);if(t<=64)return IM(e,t);let a=n,r=n.mul(Ks).add(113),s=wx(r.mul(wn).add(113)).mul(wn),i=[Ys.UZERO,Ys.UZERO],o=[Ys.UZERO,Ys.UZERO];a=a.mul(wn).add(bt(e,0));let l=0,u=(t-1>>6)*64,p=u+(t-1&63)-63;do a=Qt(a.add(r).add(i[0]).add(bt(e,l+8)),37).mul(Ks),r=Qt(r.add(i[1]).add(bt(e,l+48)),42).mul(Ks),a=a.xor(o[1]),r=r.add(i[0]).add(bt(e,l+40)),s=Qt(s.add(o[0]),33).mul(Ks),i=xh(e,l,i[1].mul(Ks),a.add(o[0])),o=xh(e,l+32,s.add(o[1]),r.add(bt(e,l+16))),[s,a]=[a,s],l+=64;while(l!==u);let d=Ks.add(s.and(255).shl(1));return l=p,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),a=Qt(a.add(r).add(i[0]).add(bt(e,l+8)),37).mul(d),r=Qt(r.add(i[1]).add(bt(e,l+48)),42).mul(d),a=a.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(bt(e,l+40))),s=Qt(s.add(o[0]),33).mul(d),i=xh(e,l,i[1].mul(d),a.add(o[0])),o=xh(e,l+32,s.add(o[1]),r.add(bt(e,l+16))),[s,a]=[a,s],ns(ns(i[0],o[0],d).add(wx(r).mul(YS)).add(s),ns(i[1],o[1],d).add(a),d)}function NM(e,t){return t===\"string\"?nd(e):Rm([e],t)}function TM(e,t){return e instanceof Float32Array&&t===\"float32\"||e instanceof Int32Array&&t===\"int32\"||e instanceof Uint8Array&&t===\"bool\"}function Rm(e,t){if(t===\"string\")throw new Error(\"Cannot convert a string[] to a TypedArray\");if(Array.isArray(e)&&(e=is(e)),G().getBool(\"DEBUG\")&&PS(e,t),TM(e,t))return e;if(t==null||t===\"float32\"||t===\"complex64\")return new Float32Array(e);if(t===\"int32\")return new Int32Array(e);if(t===\"bool\"){let n=new Uint8Array(e.length);for(let a=0;a<n.length;++a)Math.round(e[a])!==0&&(n[a]=1);return n}else throw new Error(`Unknown data type ${t}`)}function gc(){return G().platform.now()}function CM(e,t){return G().platform.fetch(e,t)}function nd(e,t=\"utf-8\"){return t=t||\"utf-8\",G().platform.encode(e,t)}function qh(e,t=\"utf-8\"){return t=t||\"utf-8\",G().platform.decode(e,t)}function en(e){return G().platform.isTypedArray!=null?G().platform.isTypedArray(e):XS(e)}function is(e,t=[],n=!1){if(t==null&&(t=[]),typeof e==\"boolean\"||typeof e==\"number\"||typeof e==\"string\"||vm(e)||e==null||en(e)&&n)t.push(e);else if(Array.isArray(e)||en(e))for(let a=0;a<e.length;++a)is(e[a],t,n);else{let a=-1;for(let r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(a=Math.max(a,Number(r)));for(let r=0;r<=a;r++)is(e[r],t,n)}return t}var EM=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new AM)}profileKernel(e,t,n){let a,r=()=>{a=n()},s,i=gc();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(let o of a)o.dataSync();s=Promise.resolve({kernelMs:gc()-i})}if(G().getBool(\"CHECK_COMPUTATION_FOR_ERRORS\"))for(let o=0;o<a.length;o++){let l=a[o];l.data().then(u=>{_M(u,l.dtype,e)})}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():\"\")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),a,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],r,o[2])})})}};function _M(e,t,n){if(t!==\"float32\")return!1;for(let a=0;a<e.length;a++){let r=e[a];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var AM=class{logKernelProfile(e,t,n,a,r,s){let i=typeof a==\"number\"?uc(`${a}ms`,9):a.error,o=uc(e,25),l=t.rank,u=t.size,p=uc(t.shape.toString(),14),d=\"\";for(let c in r){let h=r[c];if(h!=null){let m=h.shape||t.shape,f=m.length;d+=`${c}: ${f}D ${f>0?m:\"\"} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${p}\t%c${u}\t%c${d}\t%c${s}`,\"font-weight:bold\",\"color:red\",\"color:blue\",\"color: orange\",\"color: green\",\"color: steelblue\")}};function FM(e,t,n){let a={},r={};for(let l=0;l<t.length;l++)a[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],p=u.inputs;for(let d in p){let c=p[d],h=!1;for(let m=0;m<t.length;m++)if(a[c.id]){u.outputs.forEach(f=>a[f.id]=!0),h=!0,r[u.id]=!0;break}if(h)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],p=u.inputs;for(let d=0;d<u.outputs.length;d++)if(s[u.outputs[d].id]){for(let c in p)s[p[c].id]=!0,i[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(r[u.id]&&i[u.id]){let p={};for(let c in u.inputs){let h=u.inputs[c];a[h.id]&&(p[c]=h)}let d=Object.assign({},u);d.inputs=p,d.outputs=u.outputs,o.push(d)}}return o}function $M(e,t,n,a){for(let r=t.length-1;r>=0;r--){let s=t[r],i=[];if(s.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!==\"float32\")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let p=s.inputs[l];if(!Ar(u.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${p.shape}'`);if(e[p.id]==null)e[p.id]=u;else{let d=e[p.id];e[p.id]=a(d,u),d.dispose()}}}}var Xk=20,Kp=3,sx=7;function DM(e,t,n,a){let r=Xl(t),s=RM(e,t,n,r),i=t.length,o=Dh(e,t,n,r,s),l=[\"Tensor\"];return a&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push(\"  values:\")),l.push(o.map(u=>\"    \"+u).join(`\n`)),l.join(`\n`)}function RM(e,t,n,a){let r=ot(t),s=a[a.length-1],i=new Array(s).fill(0),o=t.length,l=n===\"complex64\"?ec(e):e;if(o>1)for(let u=0;u<r/s;u++){let p=u*s;for(let d=0;d<s;d++)i[d]=Math.max(i[d],Qp(l[p+d],0,n).length)}return i}function Qp(e,t,n){let a;return Array.isArray(e)?a=`${parseFloat(e[0].toFixed(sx))} + ${parseFloat(e[1].toFixed(sx))}j`:Jr(e)?a=`'${e}'`:n===\"bool\"?a=JS(e):a=parseFloat(e.toFixed(sx)).toString(),uc(a,t)}function JS(e){return e===0?\"false\":\"true\"}function Dh(e,t,n,a,r,s=!0){let i=n===\"complex64\"?2:1,o=t[0],l=t.length;if(l===0){if(n===\"complex64\"){let f=ec(e);return[Qp(f[0],0,n)]}return n===\"bool\"?[JS(e[0])]:[e[0].toString()]}if(l===1){if(o>Xk){let f=Kp*i,g=Array.from(e.slice(0,f)),b=Array.from(e.slice((o-Kp)*i,o*i));return n===\"complex64\"&&(g=ec(g),b=ec(b)),[\"[\"+g.map((y,x)=>Qp(y,r[x],n)).join(\", \")+\", ..., \"+b.map((y,x)=>Qp(y,r[o-Kp+x],n)).join(\", \")+\"]\"]}return[\"[\"+(n===\"complex64\"?ec(e):Array.from(e)).map((f,g)=>Qp(f,r[g],n)).join(\", \")+\"]\"]}let u=t.slice(1),p=a.slice(1),d=a[0]*i,c=[];if(o>Xk){for(let f=0;f<Kp;f++){let g=f*d,b=g+d;c.push(...Dh(e.slice(g,b),u,n,p,r,!1))}c.push(\"...\");for(let f=o-Kp;f<o;f++){let g=f*d,b=g+d;c.push(...Dh(e.slice(g,b),u,n,p,r,f===o-1))}}else for(let f=0;f<o;f++){let g=f*d,b=g+d;c.push(...Dh(e.slice(g,b),u,n,p,r,f===o-1))}let h=l===2?\",\":\"\";c[0]=\"[\"+(o>0?c[0]+h:\"\");for(let f=1;f<c.length-1;f++)c[f]=\" \"+c[f]+h;let m=`,\n`;for(let f=2;f<l;f++)m+=`\n`;return c[c.length-1]=\" \"+c[c.length-1]+\"]\"+(s?\"\":m),c}function ec(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Wt=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ot(e),n!=null){let a=n.length;A(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if(t===\"complex64\")throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");this.values=n||Sv(t,this.size),this.strides=Xl(e)}set(e,...t){t.length===0&&(t=[0]),A(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let a of e){if(a<0||a>=this.shape[t]){let r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let n=e[e.length-1];for(let a=0;a<e.length-1;++a)n+=this.strides[a]*e[a];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return za().makeTensor(this.values,this.shape,this.dtype)}},za=null,Sl=null,MM=null;function OM(e){za=e}function PM(e){Sl=e}function LM(e){MM=e}var Ce=class{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||\"float32\",this.size=ot(e),this.strides=Xl(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():\"higher\"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Sl.buffer(this.shape,this.dtype,e)}bufferSync(){return Sl.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return El(this.shape,e,this.dtype===\"complex64\")}arraySync(){return El(this.shape,this.dataSync(),this.dtype===\"complex64\")}async data(){this.throwIfDisposed();let e=za().read(this.dataId);if(this.dtype===\"string\"){let t=await e;try{return t.map(n=>qh(n))}catch(n){throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\")}}return e}dataToGPU(e){return this.throwIfDisposed(),za().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=za().readSync(this.dataId);if(this.dtype===\"string\")try{return e.map(t=>qh(t))}catch(t){throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\")}return e}async bytes(){this.throwIfDisposed();let e=await za().read(this.dataId);return this.dtype===\"string\"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),za().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error(\"Tensor is disposed.\")}print(e=!1){return Sl.print(this,e)}clone(){return this.throwIfDisposed(),Sl.clone(this)}toString(e=!1){let t=this.dataSync();return DM(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Sl.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),za().makeVariable(this,e,t,n)}};Object.defineProperty(Ce,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Q(){return Cv(\"Tensor\",()=>Ce)}Q();var os=class extends Ce{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ar(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);za().disposeTensor(this),this.dataId=e.dataId,za().incRef(this,null)}dispose(){za().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(os,Symbol.hasInstance,{value:e=>e instanceof Ce&&e.assign!=null&&e.assign instanceof Function});var Wa={};_e(Wa,{assertTypesMatch:()=>tN,getTensorsInContainer:()=>_v,isTensorInList:()=>WM,makeTypesMatch:()=>_t});var kx;(function(e){e.R0=\"R0\",e.R1=\"R1\",e.R2=\"R2\",e.R3=\"R3\",e.R4=\"R4\",e.R5=\"R5\",e.R6=\"R6\"})(kx||(kx={}));var Ix;(function(e){e.float32=\"float32\",e.int32=\"int32\",e.bool=\"int32\",e.complex64=\"complex64\"})(Ix||(Ix={}));var Sx;(function(e){e.float32=\"float32\",e.int32=\"int32\",e.bool=\"bool\",e.complex64=\"complex64\"})(Sx||(Sx={}));var Nx;(function(e){e.float32=\"float32\",e.int32=\"float32\",e.bool=\"float32\",e.complex64=\"complex64\"})(Nx||(Nx={}));var Tx;(function(e){e.float32=\"complex64\",e.int32=\"complex64\",e.bool=\"complex64\",e.complex64=\"complex64\"})(Tx||(Tx={}));var zM={float32:Nx,int32:Ix,bool:Sx,complex64:Tx};function fa(e,t){if(e===\"string\"||t===\"string\"){if(e===\"string\"&&t===\"string\")return\"string\";throw new Error(`Can not upcast ${e} with ${t}`)}return zM[e][t]}function Mm(e){return fa(e,\"int32\")}function QS(e){return e!=null&&typeof e==\"object\"&&\"texture\"in e&&e.texture instanceof WebGLTexture}function eN(e){return typeof GPUBuffer!=\"undefined\"&&e!=null&&typeof e==\"object\"&&\"buffer\"in e&&e.buffer instanceof GPUBuffer}function _t(e,t){if(e.dtype===t.dtype)return[e,t];let n=fa(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function tN(e,t){A(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function WM(e,t){return t.some(n=>n.id===e.id)}function _v(e){let t=[];return nN(e,t,new Set),t}function nN(e,t,n){if(e==null)return;if(e instanceof Ce){t.push(e);return}if(!BM(e))return;let a=e;for(let r in a){let s=a[r];n.has(s)||(n.add(s),nN(s,t,n))}}function BM(e){return Array.isArray(e)||typeof e==\"object\"}function ix(e){return e.kernelName!=null}var Yk=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Av=class Cx{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Yk}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n];if(await this.initializeBackend(a).success){await this.setBackend(a);return}}throw new Error(\"Could not initialize any backends, all backend initializations failed.\")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,a=1){return t in this.registryFactory?(Zr(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:a},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:a}=this.initializeBackend(t);if(!(a?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new EM(this.backendInstance),!0}setupRegisteredKernels(){jh(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){jh(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let a=n.factory();if(a&&!(a instanceof Fc)&&typeof a.then==\"function\"){let r=++this.pendingBackendInitId,s=a.then(i=>r<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Zr(`Initialization of backend ${t} failed`),Zr(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(a){return Zr(`Initialization of backend ${t} failed`),Zr(a.stack||a.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error(\"No backend found in registry.\");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let a=t[n],{success:r,asyncInit:s}=this.initializeBackend(a);if(s||r)return{name:a,asyncInit:s}}throw new Error(\"Could not initialize any backends, all backend initializations failed.\")}moveData(t,n){let a=this.state.tensorInfo.get(n),r=a.backend,s=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),a.backend=t,t.move(n,s,a.shape,a.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let a=null;if(n==null){if(typeof t!=\"function\")throw new Error(\"Please provide a function to tidy()\");n=t}else{if(typeof t!=\"string\"&&!(t instanceof String))throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");if(typeof n!=\"function\")throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");a=t}let r;return this.scopedRun(()=>this.startScope(a),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error(\"Cannot return a Promise inside of tidy.\"),r))}scopedRun(t,n,a){t();try{let r=a();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Cx.nextTensorId++}nextVariableId(){return Cx.nextVariableId++}clone(t){let n=P.runKernel(eo,{x:t}),a={x:t},r=i=>({x:()=>{let o=\"float32\",l={x:i},u={dtype:o};return P.runKernel(Mi,l,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,a,[n],r,s,{}),n}runKernel(t,n,a){if(this.backendName==null&&this.backend,fc(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:a})}shouldCheckForMemLeaks(){return this.ENV.getBool(\"IS_TEST\")}checkKernelForMemLeak(t,n,a){let r=this.backend.numDataIds(),s=0;a.forEach(l=>{s+=l.dtype===\"complex64\"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,a=[],r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,u=ix(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:\"\";if(ix(t)){let{kernelName:m,inputs:f,attrs:g}=t;this.backendName==null&&this.backend;let b=fc(m,this.backendName);A(b!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),o=()=>{let y=this.backend.numDataIds();l=b.kernelFunc({inputs:f,attrs:g,backend:this.backend});let x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,y,x);let v=x.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(r){let I=this.getTensorsForGradient(m,f,v);a=this.saveTensorsForBackwardMode(I)}return v}}else{let{forwardFunc:m}=t,f=g=>{r&&(a=g.map(b=>this.keep(this.clone(b))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>m(this.backend,f));let b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,b),b}}let{inputs:p,attrs:d}=t,c=ix(t)?null:t.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool(\"DEBUG\")&&!this.state.profiling?n=o():(h=this.profiler.profileKernel(u,p,()=>o()),this.ENV.getBool(\"DEBUG\")&&this.profiler.logKernelProfile(h),n=h.outputs)}),r&&this.addTapeNode(u,p,n,c,a,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(m=>p[m]!=null?p[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,a){let r=vx(t);if(r!=null){let s=r.inputsToSave||[],i=r.outputsToSave||[],o;r.saveAllInputs?(A(Array.isArray(n),()=>\"saveAllInputs is true, expected inputs to be an array.\"),o=Object.keys(n).map(u=>n[u])):o=s.map(u=>n[u]);let l=a.filter((u,p)=>i[p]);return o.concat(l)}return[]}makeTensor(t,n,a,r){if(t==null)throw new Error(\"Values passed to engine.makeTensor() are null\");a=a||\"float32\",r=r||this.backend;let s=t;a===\"string\"&&Jr(t[0])&&(s=t.map(l=>nd(l)));let i=r.write(s,n,a),o=new Ce(n,a,i,this.nextTensorId());if(this.trackTensor(o,r),a===\"string\"){let l=this.state.tensorInfo.get(i),u=zS(s);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,a,r){a=a||\"float32\";let s={dataId:t,shape:n,dtype:a};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,n){let{dataId:a,shape:r,dtype:s}=t,i=new Ce(r,s,a,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,a,r){a=a||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let s=new os(t,n,a,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype===\"string\"&&this.state.numStringTensors++;let a=0;t.dtype!==\"complex64\"&&t.dtype!==\"string\"&&(a=t.size*Uh(t.dtype)),this.state.numBytes+=a,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:a})),t instanceof os||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype===\"string\"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!==\"complex64\"&&t.dtype!==\"string\"){let a=t.size*Uh(t.dtype);this.state.numBytes-=a}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push(\"Memory usage by string tensors is approximate (2 bytes per character)\")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,a=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-a;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,a,r,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:a,saved:s},l=vx(t);l!=null&&(r=l.gradFunc),r!=null&&(o.gradient=u=>(u=u.map((p,d)=>{if(p==null){let c=a[d],h=xm(c.size,c.dtype);return this.makeTensor(h,c.shape,c.dtype)}return p}),r(u.length>1?u:u[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:\"unnamed scope\",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=_v(t),a=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!a.has(i.id)&&i.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(t,n,a,r=!1){if(A(n.length>0,()=>\"gradients() received an empty list of xs.\"),a!=null&&a.dtype!==\"float32\")throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy(\"forward\",t));A(s instanceof Ce,()=>\"The result y returned by f() must be a tensor.\");let i=FM(this.state.activeTape,n,s);if(!r&&i.length===0&&n.length>0)throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");return this.tidy(\"backward\",()=>{let o={};o[s.id]=a==null?VM(s.shape):a,$M(o,i,u=>this.tidy(u),UM);let l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let p of u.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return A(ss(t),()=>\"The f passed in customGrad(f) must be a function.\"),(...n)=>{A(n.every(o=>o instanceof Ce),()=>\"The args passed in customGrad(f)(x1, x2,...) must all be tensors\");let a,r={};n.forEach((o,l)=>{r[l]=o});let s=(o,l)=>(a=t(...n,l),A(a.value instanceof Ce,()=>\"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\"),A(ss(a.gradFunc),()=>\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\"),a.value),i=(o,l)=>{let u=a.gradFunc(o,l),p=Array.isArray(u)?u:[u];A(p.length===n.length,()=>\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\"),A(p.every(c=>c instanceof Ce),()=>\"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\");let d={};return p.forEach((c,h)=>{d[h]=()=>c}),d};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=gc(),a=await this.backend.time(t);return a.wallMs=gc()-n,a}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Yk;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Av.nextTensorId=0;Av.nextVariableId=0;function VM(e){let t=Nv(ot(e),\"float32\");return P.makeTensor(t,e,\"float32\")}function aN(){let e=GS();if(e._tfengine==null){let t=new US(e);e._tfengine=new Av(t)}return pM(e._tfengine.ENV),OM(()=>e._tfengine),e._tfengine}var P=aN();function UM(e,t){let n={a:e,b:t};return P.runKernel(vs,n)}var ad={};_e(ad,{isBrowser:()=>rN,isMobile:()=>jM,mockIsMobile:()=>HM});function GM(){return typeof navigator!=\"undefined\"&&navigator!=null}var Ex;function HM(e){Ex=e}function jM(e){if(Ex!==void 0)return Ex;if(e||GM()){if(e||(e=navigator),e.product===\"ReactNative\")return!0;let t=e.userAgent||e.vendor||(typeof window!=\"undefined\"?window.opera:\"\");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(t.substr(0,4))}return!1}function rN(){return typeof window!=\"undefined\"&&window.document!=null||typeof WorkerGlobalScope!=\"undefined\"}var Wn=G();Wn.registerFlag(\"DEBUG\",()=>!1,e=>{e&&console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\")});Wn.registerFlag(\"IS_BROWSER\",()=>rN());Wn.registerFlag(\"IS_NODE\",()=>typeof process!=\"undefined\"&&typeof process.versions!=\"undefined\"&&typeof process.versions.node!=\"undefined\");Wn.registerFlag(\"IS_CHROME\",()=>typeof navigator!=\"undefined\"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Wn.registerFlag(\"IS_SAFARI\",()=>typeof navigator!=\"undefined\"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Wn.registerFlag(\"PROD\",()=>!1);Wn.registerFlag(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\",()=>Wn.getBool(\"DEBUG\"));Wn.registerFlag(\"DEPRECATION_WARNINGS_ENABLED\",()=>!0);Wn.registerFlag(\"IS_TEST\",()=>!1);Wn.registerFlag(\"CHECK_COMPUTATION_FOR_ERRORS\",()=>Wn.getBool(\"DEBUG\"));Wn.registerFlag(\"WRAP_TO_IMAGEBITMAP\",()=>!1);Wn.registerFlag(\"CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU\",()=>!1);Wn.registerFlag(\"USE_SETTIMEOUTCUSTOM\",()=>!1);function lr(e,t){let n=e;if(en(e))return t===\"string\"?[]:[e.length];if(QS(e)){let r=e.channels||\"RGBA\";return[e.height,e.width*r.length]}else if(eN(e))return[e.buffer.size/(t==null?4:Uh(t))];if(!Array.isArray(e))return[];let a=[];for(;Array.isArray(n)||en(n)&&t!==\"string\";)a.push(n.length),n=n[0];return Array.isArray(e)&&G().getBool(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\")&&sN(e,a,[]),a}function sN(e,t,n){if(n=n||[],!Array.isArray(e)&&!en(e)){A(t.length===0,()=>`Element arr[${n.join(\"][\")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${n.join(\"][\")}] should be a primitive, but is an array of ${e.length} elements`),A(e.length===t[0],()=>`Element arr[${n.join(\"][\")}] should have ${t[0]} elements, but has ${e.length} elements`);let a=t.slice(1);for(let r=0;r<e.length;++r)sN(e[r],a,n.concat(r))}function Zk(e,t,n,a){if(e!==\"string_or_numeric\"){if(e==null)throw new Error(\"Expected dtype cannot be null.\");if(e!==\"numeric\"&&e!==t||e===\"numeric\"&&t===\"string\")throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`)}}function E(e,t,n,a=\"numeric\"){if(e instanceof Q())return Zk(a,e.dtype,t,n),e;let r=$c(e);if(r!==\"string\"&&[\"bool\",\"int32\",\"float32\"].indexOf(a)>=0&&(r=a),Zk(a,r,t,n),e==null||!en(e)&&!Array.isArray(e)&&typeof e!=\"number\"&&typeof e!=\"boolean\"&&typeof e!=\"string\"){let o=e==null?\"null\":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=lr(e,r);!en(e)&&!Array.isArray(e)&&(e=[e]);let i=r!==\"string\"?Rm(e,r):is(e,[],!0);return P.makeTensor(i,s,r)}function bc(e,t,n,a=\"numeric\"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \\`Tensor[]\\` or \\`TensorLike[]\\``);return e.map((r,s)=>E(r,`${t}[${s}]`,n,a))}var Fv=\"__op\";function L(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],a=e[n];n.endsWith(\"_\")&&(n=n.substring(0,n.length-1)),n=n+Fv;let r=(...s)=>{P.startScope(n);try{let i=a(...s);return vm(i)&&console.error(\"Cannot return a Promise inside of tidy.\"),P.endScope(i),i}catch(i){throw P.endScope(null),i}};return Object.defineProperty(r,\"name\",{value:n,configurable:!0}),r}function qM(e,t){let n=E(e,\"real\",\"complex\"),a=E(t,\"imag\",\"complex\");Nn(n.shape,a.shape,`real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);let r={real:n,imag:a};return P.runKernel(wm,r)}var _r=L({complex_:qM});function Ss(e,t,n,a){if(a==null)a=$c(e);else if(a===\"complex64\")throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");if(eN(e)||QS(e)){if(a!==\"float32\"&&a!==\"int32\")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);return P.backend.createTensorFromGPUData(e,t||n,a)}if(!en(e)&&!Array.isArray(e)&&typeof e!=\"number\"&&typeof e!=\"boolean\"&&typeof e!=\"string\")throw new Error(\"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray\");if(t!=null){na(t);let r=ot(t),s=ot(n);A(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==ot(t.slice(i)):!0;A(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!en(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=a!==\"string\"?Rm(e,a):is(e,[],!0),P.makeTensor(e,t,a)}function bn(e,t,n){let a=lr(e,n);return Ss(e,t,a,n)}var ui={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Fr=class iN{static join(t){return new iN(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(a=>en(a)?a.buffer:a),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let a=0;a<t.length;a++){let r=t[a];a!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+r.byteLength;this.shards.push({buffer:r,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let a=this.findShardForByte(t);if(a===-1)throw new Error(`Could not find start shard for byte ${t}`);let r=n-t,s=new ArrayBuffer(r),i=new Uint8Array(s),o=0;for(let l=a;l<this.shards.length;l++){let u=this.shards[l],p=t+o-u.start,d=o,c=Math.min(n,u.end)-u.start,h=new Uint8Array(u.buffer,p,c-p);if(i.set(h,d),o+=h.length,n<u.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let a=KM(this.shards,n);return a===-1?-1:(this.previousShardIndex=a,this.previousShardIndex)}};function KM(e,t){let n=0,a=e.length;for(;n<=a;){let r=Math.floor((a-n)/2)+n,s=t(e[r]);if(s===0)return r;s<0?a=r:n=r+1}return-1}function XM(){G().set(\"PROD\",!0)}function YM(){G().set(\"DEBUG\",!0)}function ZM(){G().set(\"DEPRECATION_WARNINGS_ENABLED\",!1),console.warn(\"TensorFlow.js deprecation warnings have been disabled.\")}function $v(e){G().getBool(\"DEPRECATION_WARNINGS_ENABLED\")&&console.warn(e+\" You can disable deprecation warnings with tf.disableDeprecationWarnings().\")}LM($v);function JM(){P.disposeVariables()}function Ta(){return P}function Kh(){return P.memory()}function QM(e){return P.profile(e)}function O(e,t){return P.tidy(e,t)}function Ee(e){_v(e).forEach(t=>t.dispose())}function Ht(e){return P.keep(e)}function eO(e){return P.time(e)}function tO(e){return P.setBackend(e)}function nO(){return P.ready()}function oN(){return P.backendName}function aO(e){P.removeBackend(e)}function rO(e){return P.findBackend(e)}function sO(e){return P.findBackendFactory(e)}function Om(e,t,n=1){return P.registerBackend(e,t,n)}function Dv(){return P.backend}function iO(e,t){G().setPlatform(e,t)}var ls=4;async function oO(e,t){let n=[],a=[],r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){let o=r[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!==\"float32\"&&l.dtype!==\"int32\"&&l.dtype!==\"bool\"&&l.dtype!==\"string\"&&l.dtype!==\"complex64\")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype===\"string\"){let p=new Promise(async d=>{let c=await l.bytes(),h=c.reduce((g,b)=>g+b.length,0)+ls*c.length,m=new Uint8Array(h),f=0;for(let g=0;g<c.length;g++){let b=c[g],y=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(y,f),f+=ls,m.set(b,f),f+=b.length}d(m)});a.push(p)}else a.push(l.data());t!=null&&(u.group=t),n.push(u)}let s=await Promise.all(a);return{data:pO(s),specs:n}}function lN(e,t){let n=new Fr(e),a={},r=0;for(let s of t){let i=lO(s,(o,l)=>n.slice(r+o,r+l));a[s.name]=uN(s,n.slice(r,r+i)),r+=i}return a}function lO(e,t){let n=ot(e.shape),a;if(\"quantization\"in e){let r=e.quantization;a=ui[r.dtype]}else if(e.dtype===\"string\"){let r=0;for(let s=0;s<n;s++)r+=ls+new Uint32Array(t(r,r+ls))[0];return r}else a=ui[e.dtype];return n*a}async function uO(e,t){let n=ot(e.shape),a;if(\"quantization\"in e){let r=e.quantization;a=ui[r.dtype]}else if(e.dtype===\"string\"){let r=0;for(let s=0;s<n;s++)r+=ls+new Uint32Array(await t(r,r+ls))[0];return r}else a=ui[e.dtype];return n*a}function uN(e,t){let n=e.name,a=e.dtype,r=e.shape,s=ot(r),i,o=0;if(\"quantization\"in e){let l=e.quantization;if(l.dtype===\"uint8\"||l.dtype===\"uint16\"){if(!(\"min\"in l&&\"scale\"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype===\"float16\"){if(a!==\"float32\")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=ui[l.dtype],p=l.dtype===\"uint8\"?new Uint8Array(t):new Uint16Array(t);if(a===\"float32\")if(l.dtype===\"uint8\"||l.dtype===\"uint16\"){i=new Float32Array(p.length);for(let d=0;d<p.length;d++){let c=p[d];i[d]=c*l.scale+l.min}}else if(l.dtype===\"float16\")i=bO()(p);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(a===\"int32\"){if(l.dtype!==\"uint8\"&&l.dtype!==\"uint16\")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(p.length);for(let d=0;d<p.length;d++){let c=p[d];i[d]=Math.round(c*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*u}else if(a===\"string\"){let l=ot(e.shape);i=[];for(let u=0;u<l;u++){let p=new Uint32Array(t.slice(o,o+ls))[0];o+=ls;let d=new Uint8Array(t.slice(o,o+p));i.push(d),o+=p}}else{let l=ui[a];if(a===\"float32\")i=new Float32Array(t);else if(a===\"int32\")i=new Int32Array(t);else if(a===\"bool\")i=new Uint8Array(t);else if(a===\"complex64\"){i=new Float32Array(t);let u=new Float32Array(i.length/2),p=new Float32Array(i.length/2);for(let m=0;m<u.length;m++)u[m]=i[m*2],p[m]=i[m*2+1];let d=bn(u,r,\"float32\"),c=bn(p,r,\"float32\"),h=_r(d,c);return d.dispose(),c.dispose(),h}else throw new Error(`Unsupported dtype in weight '${n}': ${a}`);o+=s*l}return bn(i,r,a)}async function Jk(e,t,n){let a=new Uint8Array(t);for(;a.byteLength<n;){let{done:r,value:s}=await e.read();if(r&&s==null){let o=n-a.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(a.length+s.byteLength);i.set(a,0),i.set(new Uint8Array(s),a.length),a=i}return a.buffer}async function pN(e,t){let n={},a=e.getReader(),r=new ArrayBuffer(0);for(let s of t){let i=await uO(s,async(u,p)=>(r=await Jk(a,r,p),r.slice(u,p)));r=await Jk(a,r,i);let o=r.slice(0,i);r=r.slice(i);let l=uN(s,o);if(n[s.name]=l,oN()===\"webgpu\"){let u=Dv();\"uploadToGPU\"in u&&ot(l.shape)>=G().get(\"WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD\")&&u.uploadToGPU(l.dataId)}}return n}function pO(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let a=new Uint8Array(t),r=0;return n.forEach(s=>{a.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),a.buffer}var Rv=typeof Buffer!=\"undefined\"&&(typeof Blob==\"undefined\"||typeof atob==\"undefined\"||typeof btoa==\"undefined\");function Qk(e){return Rv?Buffer.byteLength(e,\"utf8\"):new Blob([e]).size}function cO(e){if(Rv)return Buffer.from(e).toString(\"base64\");let t=new Uint8Array(e),n=\"\";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}function dO(e){if(Rv){let a=Buffer.from(e,\"base64\");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}function hO(e){return Fr.join(e)}function eI(e){let t=\"/\";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function cN(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function dN(e,t,n){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error(\"modelJSON has weightsManifest but weightSpecs is null\");if(!n)throw new Error(\"modelJSON has weightsManifest but weightData is null\");a.weightSpecs=t,a.weightData=n}return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),a}async function Mv(e,t){let n,a;return e.weightsManifest!=null&&([n,a]=await t(e.weightsManifest)),dN(e,n,a)}function rd(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");return{dateSaved:new Date,modelTopologyType:\"JSON\",modelTopologyBytes:e.modelTopology==null?0:Qk(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Qk(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Fr(e.weightData).byteLength}}function _x(e){let t=[];for(let n of e)t.push(...n.weights);return t}function mO(){let e=n=>{let a=n<<13,r=0;for(;!(a&8388608);)r-=8388608,a<<=1;return a&=-8388609,r+=947912704,a|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function fO(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function gO(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function bO(){let e=mO(),t=fO(),n=gO();return a=>{let r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let i=0;i<a.length;i++){let o=a[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(r)}}var ga=class La{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return La.instance==null&&(La.instance=new La),La.instance}static registerSaveRouter(t){La.getInstance().saveRouters.push(t)}static registerLoadRouter(t){La.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return La.getHandlers(t,\"save\")}static getLoadHandlers(t,n){return La.getHandlers(t,\"load\",n)}static getHandlers(t,n,a){let r=[];return(n===\"load\"?La.getInstance().loadRouters:La.getInstance().saveRouters).forEach(s=>{let i=s(t,a);i!==null&&r.push(i)}),r}},yO=e=>ga.registerSaveRouter(e),xO=e=>ga.registerLoadRouter(e),vO=e=>ga.getSaveHandlers(e),wO=(e,t)=>ga.getLoadHandlers(e,t),Ax=\"tensorflowjs\",Fx=1,ti=\"models_store\",Qr=\"model_info_store\";function hN(){if(!G().getBool(\"IS_BROWSER\"))throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");let e=typeof window==\"undefined\"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error(\"The current browser does not appear to support IndexedDB.\");return t}function $x(e){let t=e.result;t.createObjectStore(ti,{keyPath:\"modelPath\"}),t.createObjectStore(Qr,{keyPath:\"modelPath\"})}var pi=class{constructor(e){if(this.indexedDB=hN(),e==null||!e)throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,a)=>{let r=this.indexedDB.open(Ax,Fx);r.onupgradeneeded=()=>$x(r),r.onsuccess=()=>{let s=r.result;if(t==null){let i=s.transaction(ti,\"readonly\"),o=i.objectStore(ti).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),a(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=Fr.join(t.weightData);let i=rd(t),o=s.transaction(Qr,\"readwrite\"),l=o.objectStore(Qr),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return a(d)}let p;u.onsuccess=()=>{p=s.transaction(ti,\"readwrite\");let d=p.objectStore(ti),c;try{c=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(h){return a(h)}c.onsuccess=()=>n({modelArtifactsInfo:i}),c.onerror=h=>{l=o.objectStore(Qr);let m=l.delete(this.modelPath);m.onsuccess=()=>(s.close(),a(c.error)),m.onerror=f=>(s.close(),a(c.error))}},u.onerror=d=>(s.close(),a(u.error)),o.oncomplete=()=>{p==null?s.close():p.oncomplete=()=>s.close()}}},r.onerror=s=>a(r.error)})}};pi.URL_SCHEME=\"indexeddb://\";var mN=e=>G().getBool(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(pi.URL_SCHEME)?kO(e.slice(pi.URL_SCHEME.length)):null;ga.registerSaveRouter(mN);ga.registerLoadRouter(mN);function kO(e){return new pi(e)}function IO(e){return e.startsWith(pi.URL_SCHEME)?e.slice(pi.URL_SCHEME.length):e}var SO=class{constructor(){this.indexedDB=hN()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Ax,Fx);n.onupgradeneeded=()=>$x(n),n.onsuccess=()=>{let a=n.result,r=a.transaction(Qr,\"readonly\"),s=r.objectStore(Qr).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=a=>t(n.error)})}async removeModel(e){return e=IO(e),new Promise((t,n)=>{let a=this.indexedDB.open(Ax,Fx);a.onupgradeneeded=()=>$x(a),a.onsuccess=()=>{let r=a.result,s=r.transaction(Qr,\"readwrite\"),i=s.objectStore(Qr),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=i.delete(e),p=()=>{l=r.transaction(ti,\"readwrite\");let d=l.objectStore(ti).delete(e);d.onsuccess=()=>t(o.result.modelArtifactsInfo),d.onerror=c=>n(o.error)};u.onsuccess=p,u.onerror=d=>(p(),r.close(),n(o.error))}},o.onerror=u=>(r.close(),n(o.error)),s.oncomplete=()=>{l==null?r.close():l.oncomplete=()=>r.close()}},a.onerror=r=>n(a.error)})}},Tr=\"/\",Nl=\"tensorflowjs_models\",fN=\"info\",NO=\"model_topology\",TO=\"weight_specs\",CO=\"weight_data\",EO=\"model_metadata\";function gN(e){return{info:[Nl,e,fN].join(Tr),topology:[Nl,e,NO].join(Tr),weightSpecs:[Nl,e,TO].join(Tr),weightData:[Nl,e,CO].join(Tr),modelMetadata:[Nl,e,EO].join(Tr)}}function bN(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function _O(e){let t=e.split(Tr);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Tr)}function AO(e){return e.startsWith(ci.URL_SCHEME)?e.slice(ci.URL_SCHEME.length):e}var ci=class{constructor(e){if(!G().getBool(\"IS_BROWSER\")||typeof window==\"undefined\"||typeof window.localStorage==\"undefined\")throw new Error(\"The current environment does not support local storage.\");if(this.LS=window.localStorage,e==null||!e)throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");this.modelPath=e,this.keys=gN(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=rd(e),r=Fr.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,cO(r));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:a}}catch(s){throw bN(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!==\"JSON\")throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=a;let r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){let i=JSON.parse(r);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=dO(s),t}};ci.URL_SCHEME=\"localstorage://\";var yN=e=>G().getBool(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(ci.URL_SCHEME)?FO(e.slice(ci.URL_SCHEME.length)):null;ga.registerSaveRouter(yN);ga.registerLoadRouter(yN);function FO(e){return new ci(e)}var $O=class{constructor(){A(G().getBool(\"IS_BROWSER\"),()=>\"Current environment is not a web browser\"),A(typeof window==\"undefined\"||typeof window.localStorage!=\"undefined\",()=>\"Current browser does not appear to support localStorage\"),this.LS=window.localStorage}async listModels(){let e={},t=Nl+Tr,n=Tr+fN;for(let a=0;a<this.LS.length;++a){let r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){let s=_O(r);e[s]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=AO(e);let t=gN(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return bN(t),n}},_l=\"://\",us=class qr{constructor(){this.managers={}}static getInstance(){return qr.instance==null&&(qr.instance=new qr),qr.instance}static registerManager(t,n){A(t!=null,()=>\"scheme must not be undefined or null.\"),t.endsWith(_l)&&(t=t.slice(0,t.indexOf(_l))),A(t.length>0,()=>\"scheme must not be an empty string.\");let a=qr.getInstance();A(a.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=n}static getManager(t){let n=qr.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(qr.getInstance().managers)}};function Rh(e){if(e.indexOf(_l)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${us.getSchemes().join(\",\")}`);return{scheme:e.split(_l)[0],path:e.split(_l)[1]}}async function xN(e,t,n=!1){A(e!==t,()=>`Old path and new path are the same: '${e}'`);let a=ga.getLoadHandlers(e);A(a.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),A(a.length<2,()=>`Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);let r=a[0],s=ga.getSaveHandlers(t);A(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(s.length<2,()=>`Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);let i=s[0],o=Rh(e).scheme,l=Rh(e).path,u=o===Rh(e).scheme,p=await r.load();n&&u&&await us.getManager(o).removeModel(l);let d=await i.save(p);return n&&!u&&await us.getManager(o).removeModel(l),d.modelArtifactsInfo}async function DO(){let e=us.getSchemes(),t={};for(let n of e){let a=await us.getManager(n).listModels();for(let r in a){let s=n+_l+r;t[s]=a[r]}}return t}async function RO(e){let t=Rh(e);return us.getManager(t.scheme).removeModel(t.path)}async function MO(e,t){return xN(e,t,!1)}async function OO(e,t){return xN(e,t,!0)}var PO=class{constructor(){this.messageName=\"setTimeoutCustom\",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!==\"utf-8\"&&t!==\"utf8\")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window==\"undefined\"||!G().getBool(\"USE_SETTIMEOUTCUSTOM\")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},\"*\")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener(\"message\",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let a=this.functionRefs[n.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return XS(e)}};if(G().get(\"IS_BROWSER\")){G().setPlatform(\"browser\",new PO);try{us.registerManager(ci.URL_SCHEME,new $O)}catch(e){}try{us.registerManager(pi.URL_SCHEME,new SO)}catch(e){}}var LO={importFetch:()=>_R()},ox,zO=class{constructor(){this.util=AR(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return G().global.fetch!=null?G().global.fetch(e,t):(ox==null&&(ox=LO.importFetch()),ox(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!==\"utf-8\"&&t!==\"utf8\")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?\"\":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};G().get(\"IS_NODE\")&&!G().get(\"IS_BROWSER\")&&G().setPlatform(\"node\",new zO);function Oe(e,t=\"float32\",n){return t=t||\"float32\",na(e),new Wt(e,t,n)}function WO(e,t){let n=E(e,\"x\",\"cast\");if(!LS(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t===\"string\"&&n.dtype!==\"string\"||t!==\"string\"&&n.dtype===\"string\")throw new Error(\"Only strings can be casted to strings\");let a={x:n},r={dtype:t};return P.runKernel(Mi,a,r)}var re=L({cast_:WO});function BO(e){let t={x:E(e,\"x\",\"clone\",\"string_or_numeric\")};return P.runKernel(eo,t)}var sr=L({clone_:BO});function Ov(e,t=!1){console.log(e.toString(t))}aN();var VO={buffer:Oe,cast:re,clone:sr,print:Ov};PM(VO);function UO(e,t){let n=E(e,\"a\",\"add\"),a=E(t,\"b\",\"add\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(vs,r)}var X=L({add_:UO});function GO(e,t){let n=E(e,\"a\",\"floorDiv\"),a=E(t,\"b\",\"floorDiv\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(Zi,r)}var Pm=L({floorDiv_:GO});function HO(e,t){let n=E(e,\"a\",\"div\"),a=E(t,\"b\",\"div\");if([n,a]=_t(n,a),n.dtype===\"int32\"&&a.dtype===\"int32\")return Pm(n,a);let r={a:n,b:a},s={};return P.runKernel(Hi,r,s)}var he=L({div_:HO});function jO(e,t){let n=E(e,\"a\",\"mul\"),a=E(t,\"b\",\"mul\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(bo,r)}var z=L({mul_:jO});function qO(e){let t=E(e,\"x\",\"abs\");if(t.dtype===\"complex64\"){let n={x:t};return P.runKernel(Oc,n)}else{let n={x:t};return P.runKernel(Yl,n)}}var Lt=L({abs_:qO});function KO(e){let t={x:E(e,\"x\",\"acos\")};return P.runKernel(Ni,t)}var Pv=L({acos_:KO});function XO(e){let t={x:E(e,\"x\",\"acosh\")};return P.runKernel(Ti,t)}var Lv=L({acosh_:XO});function YO(e){A(Array.isArray(e),()=>\"The argument passed to tf.addN() must be a list of tensors\"),A(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((r,s)=>E(r,`tensors${s}`,\"addN\")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error(\"All tensors passed to tf.addN() must have the same dtype\")}),t.forEach(r=>{if(!Ar(r.shape,n.shape))throw new Error(\"All tensors passed to tf.addN() must have the same shape\")});let a=t;return P.runKernel(Ci,a)}var vN=L({addN_:YO});function ZO(e,t=null,n=!1){let a={x:E(e,\"x\",\"all\",\"bool\")},r={axis:t,keepDims:n};return P.runKernel(Zl,a,r)}var Lm=L({all_:ZO});function JO(e,t=null,n=!1){let a={x:E(e,\"x\",\"any\",\"bool\")},r={axis:t,keepDims:n};return P.runKernel(Jl,a,r)}var yc=L({any_:JO});function QO(e,t=0){let n={x:E(e,\"x\",\"argMax\")},a={axis:t};return P.runKernel(Ql,n,a)}var di=L({argMax_:QO});function eP(e,t=0){let n={x:E(e,\"x\",\"argMin\")},a={axis:t};return P.runKernel(eu,n,a)}var zv=L({argMin_:eP});function tP(e){let t={x:E(e,\"x\",\"asin\")};return P.runKernel(Ei,t)}var Wv=L({asin_:tP});function nP(e){let t={x:E(e,\"x\",\"asinh\")};return P.runKernel(_i,t)}var Bv=L({asinh_:nP});function aP(e){let t={x:E(e,\"x\",\"atan\")};return P.runKernel(Ai,t)}var Vv=L({atan_:aP});function rP(e,t){let n=E(e,\"a\",\"atan2\"),a=E(t,\"b\",\"atan2\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel($i,r)}var Uv=L({atan2_:rP});function sP(e){let t={x:E(e,\"x\",\"atanh\")};return P.runKernel(Fi,t)}var Gv=L({atanh_:sP});function iP(e,t,n,a,r=\"NHWC\",s){let i=e[3],o=[...t,i],l=IN(r);return sd(e,o,n,s,a,null,null,l)}function wN(e,t,n,a,r,s,i=\"channelsLast\"){let[o,l]=xc(t),u;if(i===\"channelsLast\")u=[o,l,e[3],e[3]];else if(i===\"channelsFirst\")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return sd(e,u,n,a,r,s,!1,i)}function oP(e,t,n,a,r,s,i=\"NDHWC\"){let[o,l,u]=Dx(t),p,d;if(i===\"NDHWC\")d=\"channelsLast\",p=[o,l,u,e[4],e[4]];else if(i===\"NCDHW\")d=\"channelsFirst\",p=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return kN(e,p,n,a,r,!1,d,s)}function sd(e,t,n,a,r,s,i=!1,o=\"channelsLast\"){let[l,u,p,d]=[-1,-1,-1,-1];if(o===\"channelsLast\")[l,u,p,d]=e;else if(o===\"channelsFirst\")[l,d,u,p]=e;else throw new Error(`Unknown dataFormat ${o}`);let[c,h,,m]=t,[f,g]=xc(n),[b,y]=xc(a),x=Al(c,b),v=Al(h,y),{padInfo:I,outHeight:N,outWidth:C}=pP(r,u,p,f,g,x,v,s,o),_=i?m*d:m,F;return o===\"channelsFirst\"?F=[l,_,N,C]:o===\"channelsLast\"&&(F=[l,N,C,_]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:p,inChannels:d,outHeight:N,outWidth:C,outChannels:_,padInfo:I,strideHeight:f,strideWidth:g,filterHeight:c,filterWidth:h,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:F,filterShape:t}}function kN(e,t,n,a,r,s=!1,i=\"channelsLast\",o){let[l,u,p,d,c]=[-1,-1,-1,-1,-1];if(i===\"channelsLast\")[l,u,p,d,c]=e;else if(i===\"channelsFirst\")[l,c,u,p,d]=e;else throw new Error(`Unknown dataFormat ${i}`);let[h,m,f,,g]=t,[b,y,x]=Dx(n),[v,I,N]=Dx(a),C=Al(h,v),_=Al(m,I),F=Al(f,N),{padInfo:D,outDepth:$,outHeight:S,outWidth:M}=cP(r,u,p,d,b,y,x,C,_,F,o),B=s?g*c:g,U;return i===\"channelsFirst\"?U=[l,B,$,S,M]:i===\"channelsLast\"&&(U=[l,$,S,M,B]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:p,inWidth:d,inChannels:c,outDepth:$,outHeight:S,outWidth:M,outChannels:B,padInfo:D,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:h,filterHeight:m,filterWidth:f,effectiveFilterDepth:C,effectiveFilterHeight:_,effectiveFilterWidth:F,dilationDepth:v,dilationHeight:I,dilationWidth:N,inShape:e,outShape:U,filterShape:t}}function lP(e,t,n,a,r){a==null&&(a=Hv(e,t,n));let s=e[0],i=e[1],o=vc((s-t+2*a)/n+1,r),l=vc((i-t+2*a)/n+1,r);return[o,l]}function uP(e,t,n,a,r,s){r==null&&(r=Hv(e,t[0],a[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=vc((e[o]-t[o]+2*r)/a[o]+1,s));return i}function Hv(e,t,n,a=1){let r=Al(t,a);return Math.floor((e[0]*(n-1)-n+r)/2)}function xc(e){return typeof e==\"number\"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Dx(e){return typeof e==\"number\"?[e,e,e]:e}function Al(e,t){return t<=1?e:e+(e-1)*(t-1)}function pP(e,t,n,a,r,s,i,o,l){let u,p,d;if(typeof e==\"number\"){u={top:e,bottom:e,left:e,right:e,type:e===0?\"VALID\":\"NUMBER\"};let c=lP([t,n],s,a,e,o);p=c[0],d=c[1]}else if(e===\"same\"){p=Math.ceil(t/a),d=Math.ceil(n/r);let c=Math.max(0,(p-1)*a+s-t),h=Math.max(0,(d-1)*r+i-n),m=Math.floor(c/2),f=c-m,g=Math.floor(h/2),b=h-g;u={top:m,bottom:f,left:g,right:b,type:\"SAME\"}}else if(e===\"valid\")u={top:0,bottom:0,left:0,right:0,type:\"VALID\"},p=Math.ceil((t-s+1)/a),d=Math.ceil((n-i+1)/r);else if(typeof e==\"object\"){let c=l===\"channelsLast\"?e[1][0]:e[2][0],h=l===\"channelsLast\"?e[1][1]:e[2][1],m=l===\"channelsLast\"?e[2][0]:e[3][0],f=l===\"channelsLast\"?e[2][1]:e[3][1];u={top:c,bottom:h,left:m,right:f,type:c===0&&h===0&&m===0&&f===0?\"VALID\":\"EXPLICIT\"},p=vc((t-s+c+h)/a+1,o),d=vc((n-i+m+f)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:p,outWidth:d}}function cP(e,t,n,a,r,s,i,o,l,u,p){let d,c,h,m;if(e===\"valid\"&&(e=0),typeof e==\"number\"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?\"VALID\":\"NUMBER\"};let f=uP([t,n,a,1],[o,l,u],1,[r,s,i],e,p);c=f[0],h=f[1],m=f[2]}else if(e===\"same\"){c=Math.ceil(t/r),h=Math.ceil(n/s),m=Math.ceil(a/i);let f=(c-1)*r+o-t,g=(h-1)*s+l-n,b=(m-1)*i+u-a,y=Math.floor(f/2),x=f-y,v=Math.floor(g/2),I=g-v,N=Math.floor(b/2),C=b-N;d={top:v,bottom:I,left:N,right:C,front:y,back:x,type:\"SAME\"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:c,outHeight:h,outWidth:m}}function vc(e,t){if(!t)return Math.trunc(e);switch(t){case\"round\":return Math.round(e);case\"ceil\":return Math.ceil(e);case\"floor\":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function ps(e){let[t,n,a]=xc(e);return t===1&&n===1&&a===1}function dr(e,t){return ps(e)||ps(t)}function hi(e){return xc(e).every(t=>t>0)}function IN(e){if(e===\"NHWC\")return\"channelsLast\";if(e===\"NCHW\")return\"channelsFirst\";throw new Error(`Unknown dataFormat ${e}`)}function Tn(e,t,n){if(n!=null){if(typeof t==\"string\")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t==\"number\")A($l(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t==\"object\")t.forEach(a=>{a.forEach(r=>{A($l(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function dP(e,t){let n={x:E(e,\"x\",\"reshape\",\"string_or_numeric\")},a={shape:t};return P.runKernel(Ru,n,a)}var W=L({reshape_:dP});function hP(e,t,n,a,r){let s=E(e,\"x\",\"avgPool\",\"float32\"),i=1;A(dr(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Tn(\"avgPool\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r},d=P.runKernel(Di,u,p);return d=re(d,s.dtype),l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var ya=L({avgPool_:hP});function mP(e,t,n,a,r,s=\"NDHWC\"){let i=E(e,\"x\",\"avgPool3d\",\"float32\"),o=i,l=!1;i.rank===4&&(l=!0,o=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),A(s===\"NDHWC\",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),A(typeof n==\"number\"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Tn(\"avgPool3d\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=P.runKernel(tu,u,p);return d=re(d,o.dtype),l?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var jv=L({avgPool3d_:mP});function fP(e,t=0){A(e.length>=1,()=>\"Pass at least one tensor to concat\");let n=bc(e,\"tensors\",\"concat\",\"string_or_numeric\");if(n[0].dtype===\"complex64\"&&n.forEach(s=>{if(s.dtype!==\"complex64\")throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${s.dtype}. `)}),n.length===1)return sr(n[0]);let a=n,r={axis:t};return P.runKernel(su,a,r)}var et=L({concat_:fP});function gP(e,t,n=!1,a=!1){let r=E(e,\"a\",\"matMul\"),s=E(t,\"b\",\"matMul\");[r,s]=_t(r,s);let i={a:r,b:s},o={transposeA:n,transposeB:a};return P.runKernel(Ri,i,o)}var $e=L({matMul_:gP});function bP(e){let t={x:E(e,\"x\",\"sigmoid\",\"float32\")};return P.runKernel(Mo,t)}var ha=L({sigmoid_:bP});function yP(e,t,n){let a=E(e,\"x\",\"slice\",\"string_or_numeric\");if(a.rank===0)throw new Error(\"Slicing scalar is not possible\");let r={x:a},s={begin:t,size:n};return P.runKernel(Bu,r,s)}var Ve=L({slice_:yP});function xP(e){let t={x:E(e,\"x\",\"tanh\",\"float32\")};return P.runKernel(Uo,t)}var cs=L({tanh_:xP});function vP(e,t,n,a,r,s){let i=E(e,\"forgetBias\",\"basicLSTMCell\"),o=E(t,\"lstmKernel\",\"basicLSTMCell\"),l=E(n,\"lstmBias\",\"basicLSTMCell\"),u=E(a,\"data\",\"basicLSTMCell\"),p=E(r,\"c\",\"basicLSTMCell\"),d=E(s,\"h\",\"basicLSTMCell\"),c=et([u,d],1),h=$e(c,o),m=X(h,l),f=m.shape[0],g=m.shape[1]/4,b=[f,g],y=Ve(m,[0,0],b),x=Ve(m,[0,g],b),v=Ve(m,[0,g*2],b),I=Ve(m,[0,g*3],b),N=X(z(ha(y),cs(x)),z(p,ha(X(i,v)))),C=z(cs(N),ha(I));return[N,C]}var SN=L({basicLSTMCell_:vP});function wP(e,t,n){let a=E(e,\"x\",\"batchToSpaceND\"),r=t.reduce((o,l)=>o*l);A(a.rank>=1+t.length,()=>`input rank is ${a.rank} but should be > than blockShape.length ${t.length}`),A(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),A(a.shape[0]%r===0,()=>`input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(\" * \")} === ${r}`);let s={x:a},i={blockShape:t,crops:n};return P.runKernel(nu,s,i)}var id=L({batchToSpaceND_:wP});function kP(e){let t;return e.rank===0||e.rank===1?t=W(e,[1,1,1,e.size]):e.rank===2?t=W(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function IP(e,t,n,a,r,s){s==null&&(s=.001);let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(o.rank===l.rank,()=>\"Batch normalization gradient requires mean and variance to have equal ranks.\"),A(p==null||o.rank===p.rank,()=>\"Batch normalization gradient requires mean and offset to have equal ranks.\"),A(u==null||o.rank===u.rank,()=>\"Batch normalization gradient requires mean and scale to have equal ranks.\");let d={x:kP(i),scale:u,offset:p,mean:o,variance:l},c={varianceEpsilon:s},h=P.runKernel(Ji,d,c);return W(h,i.shape)}var Ns=L({batchNorm_:IP});function SP(e,t,n,a,r,s){let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;return a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),p!=null&&A(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Ns(i,o,l,p,u,s)}var qv=L({batchNorm2d_:SP});function NP(e,t,n,a,r,s){let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;return a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),p!=null&&A(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Ns(i,o,l,p,u,s)}var Kv=L({batchNorm3d_:NP});function TP(e,t,n,a,r,s){let i=E(e,\"x\",\"batchNorm\"),o=E(t,\"mean\",\"batchNorm\"),l=E(n,\"variance\",\"batchNorm\"),u;r!=null&&(u=E(r,\"scale\",\"batchNorm\"));let p;return a!=null&&(p=E(a,\"offset\",\"batchNorm\")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),p!=null&&A(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Ns(i,o,l,p,u,s)}var Xv=L({batchNorm4d_:TP});function CP(e,t,n){let a=E(e,\"x\",\"bincount\"),r=E(t,\"weights\",\"bincount\");A(a.dtype===\"int32\",()=>`Error in bincount: input dtype must be int32, but got ${a.dtype}`),A(n>=0,()=>`size must be non-negative, but got ${n}.`),A(r.size===a.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);let s={x:a,weights:r},i={size:n};return P.runKernel(au,s,i)}var Yv=L({bincount_:CP});function EP(e,t){let n=E(e,\"x\",\"bitwiseAnd\"),a=E(t,\"y\",\"bitwiseAnd\");if(!Ar(n.shape,a.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);if(n.dtype!==\"int32\"||a.dtype!==\"int32\")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);let r={a:n,b:a};return P.runKernel(ru,r)}var NN=L({bitwiseAnd_:EP});function _P(e,t){let n=E(e,\"s0\",\"broadcastArgs\",\"int32\"),a=E(t,\"s1\",\"broadcastArgs\",\"int32\");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(a.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);let r={s0:n,s1:a};return P.runKernel(Mc,r)}var TN=L({broadcastArgs_:_P});function AP(e,t){let n=E(e,\"broadcastTo\",\"x\"),a=n.shape;if(na(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=W(n,l)}let r=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return sr(n);let i={x:n},o={reps:s};return P.runKernel(ks,i,o)}var ai=L({broadcastTo_:AP});function FP(e){let t={x:E(e,\"x\",\"ceil\",\"float32\")};return P.runKernel(Oi,t)}var Zv=L({ceil_:FP});function yn(e,t,n){na(e),n=n||$c(t);let a={shape:e,value:t,dtype:n};return P.runKernel(zc,{},a)}function $P(e,t,n){let a=E(e,\"x\",\"clipByValue\");if(A(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return yn(a.shape,t,a.dtype);let r={x:a},s={clipValueMin:t,clipValueMax:n};return P.runKernel(ws,r,s)}var an=L({clipByValue_:$P});function DP(e){return et(e,0)}var Jv=L({concat1d_:DP});function RP(e,t){return et(e,t)}var Qv=L({concat2d_:RP});function MP(e,t){return et(e,t)}var ew=L({concat3d_:MP});function OP(e,t){return et(e,t)}var tw=L({concat4d_:OP});function PP(e,t,n,a,r=\"NHWC\",s=[1,1],i){let o=E(e,\"x\",\"conv2d\",\"float32\"),l=E(t,\"filter\",\"conv2d\",\"float32\"),u=o,p=!1;o.rank===3&&(p=!0,u=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Tn(\"conv2d\",a,i);let d=r===\"NHWC\"?u.shape[3]:u.shape[1];A(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),A(dr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),A(hi(s),()=>\"Error in conv2D: Dilated rates should be larger than 0.\"),A(hi(n),()=>\"Error in conv2D: Strides should be larger than 0.\");let c={x:u,filter:l},h={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},m=P.runKernel(Pi,c,h);return p?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var $t=L({conv2d_:PP});function LP(e,t,n,a,r=\"NWC\",s=1,i){let o=E(e,\"x\",\"conv1d\"),l=E(t,\"filter\",\"conv1d\"),u=o,p=!1;o.rank===2&&(p=!0,u=W(o,[1,o.shape[0],o.shape[1]])),A(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),A(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Tn(\"conv1d\",a,i),A(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),A(dr(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),A(hi(s),()=>\"Error in conv1D: Dilated rates should be larger than 0.\"),A(hi(n),()=>\"Error in conv1D: Stride should be larger than 0.\"),A(r===\"NWC\",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let d=W(l,[1,l.shape[0],l.shape[1],l.shape[2]]),c=W(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=$t(c,d,[1,n],a,\"NHWC\",[1,s],i);return p?W(h,[h.shape[2],h.shape[3]]):W(h,[h.shape[0],h.shape[2],h.shape[3]])}var zm=L({conv1d_:LP});function zP(e,t,n,a,r,s=\"NHWC\",i){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),A(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),A(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),A(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let p=s===\"NHWC\"?o[3]:o[1],d=s===\"NHWC\"?l.shape[3]:l.shape[1];A(p===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${n.shape[2]}.`),A(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Tn(\"conv2dDerInput\",r,i);let c={dy:l,filter:n},h={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},m=P.runKernel(Li,c,h);return u?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var nw=L({conv2DBackpropInput_:zP});function WP(e,t,n,a,r,s){let i=E(e,\"x\",\"conv2dTranspose\"),o=E(t,\"filter\",\"conv2dTranspose\");return nw(n,i,o,a,r,\"NHWC\",s)}var Wm=L({conv2dTranspose_:WP});function BP(e,t,n,a,r=\"NDHWC\",s=[1,1,1]){let i=E(e,\"x\",\"conv3d\"),o=E(t,\"filter\",\"conv3d\"),l=i,u=!1;i.rank===4&&(u=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),A(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),A(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),A(dr(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),A(r===\"NDHWC\",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),A(hi(s),()=>\"Error in conv3D: Dilated rates should be larger than 0.\"),A(hi(n),()=>\"Error in conv3D: Strides should be larger than 0.\");let p={x:l,filter:o},d={strides:n,pad:a,dataFormat:r,dilations:s},c=P.runKernel(zi,p,d);return u?W(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var aw=L({conv3d_:BP});function VP(e,t,n,a,r){A(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];A(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),A(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),A(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let p={dy:i,filter:n},d={pad:r,strides:a,inputShape:s},c=P.runKernel(ou,p,d);return o?W(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var CN=L({conv3DBackpropInput_:VP});function UP(e,t,n,a,r){let s=E(e,\"x\",\"conv3dTranspose\"),i=E(t,\"filter\",\"conv3dTranspose\");return CN(n,s,i,a,r)}var rw=L({conv3dTranspose_:UP});function GP(e){let t={x:E(e,\"x\",\"cos\",\"float32\")};return P.runKernel(Wi,t)}var od=L({cos_:GP});function HP(e){let t={x:E(e,\"x\",\"cosh\",\"float32\")};return P.runKernel(Bi,t)}var Bm=L({cosh_:HP});function jP(e,t=0,n=!1,a=!1){let r={x:E(e,\"x\",\"cumprod\")},s={axis:t,exclusive:n,reverse:a};return P.runKernel(lu,r,s)}var wc=L({cumprod_:jP});function qP(e,t=0,n=!1,a=!1){let r={x:E(e,\"x\",\"cumsum\")},s={axis:t,exclusive:n,reverse:a};return P.runKernel(Vi,r,s)}var Vm=L({cumsum_:qP});function KP(e,t,n,a=!1){let r=E(e,\"x\",\"denseBincount\"),s=E(t,\"weights\",\"denseBincount\");A(r.dtype===\"int32\",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),A(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),A(n>=0,()=>`size must be non-negative, but got ${n}.`),A(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);let i={x:r,weights:s},o={size:n,binaryOutput:a};return P.runKernel(Pc,i,o)}var Xh=L({denseBincount_:KP});function XP(e,t,n=\"NHWC\"){let a=E(e,\"x\",\"depthToSpace\",\"float32\"),r=n===\"NHWC\"?a.shape[1]:a.shape[2],s=n===\"NHWC\"?a.shape[2]:a.shape[3],i=n===\"NHWC\"?a.shape[3]:a.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${a.shape}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${a.shape}`),A(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${a.shape}`);let o={x:a},l={blockSize:t,dataFormat:n};return P.runKernel(pu,o,l)}var sw=L({depthToSpace_:XP});function YP(e,t,n,a,r=\"NHWC\",s=[1,1],i){let o=E(e,\"x\",\"depthwiseConv2d\",\"float32\"),l=E(t,\"filter\",\"depthwiseConv2d\",\"float32\"),u=o,p=!1;o.rank===3&&(p=!0,u=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=r===\"NHWC\"?u.shape[3]:u.shape[1];A(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Tn(\"depthwiseConv2d\",a,i);let c={x:u,filter:l},h={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i},m=P.runKernel(Ui,c,h);return p?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Ts=L({depthwiseConv2d_:YP});function ZP(e){let t={x:E(e,\"x\",\"diag\")};return P.runKernel(Lc,t)}var EN=L({diag_:ZP});function JP(e,t,n,a,r=[1,1],s=\"NHWC\"){let i=E(e,\"x\",\"dilation2d\"),o=E(t,\"filter\",\"dilation2d\");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),A(s===\"NHWC\",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,u=!1;i.rank===3&&(l=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),A(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let p={x:l,filter:o},d={strides:n,pad:a,dilations:r},c=P.runKernel(Gi,p,d);return u?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var iw=L({dilation2d_:JP}),Ju={};_e(Ju,{assertAndGetBroadcastShape:()=>ct,getBroadcastDims:()=>_N,getReductionAxes:()=>Bt});function _N(e,t){let n=e.length,a=[];for(let r=0;r<n;r++){let s=n-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&i===1&&a.unshift(s)}return a}function Bt(e,t){let n=[];for(let a=0;a<t.length;a++){let r=e[e.length-a-1],s=t.length-a-1,i=t[s];(r==null||r===1&&i>1)&&n.unshift(s)}return n}function ct(e,t){let n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];s==null&&(s=1);let i=t[t.length-r-1];if(i==null&&(i=1),s===1)a[n-r-1]=i;else if(i===1)a[n-r-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else a[n-r-1]=s}return a}function QP(e,t){let n=E(e,\"a\",\"equal\",\"string_or_numeric\"),a=E(t,\"b\",\"equal\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(du,r)}var Jn=L({equal_:QP});function e3(e,t,n){let a=E(t,\"a\",\"where\"),r=E(n,\"b\",\"where\"),s=E(e,\"condition\",\"where\",\"bool\"),i=ct(ct(s.shape,a.shape),r.shape),o=ai(s,i),l=ai(a,i),u=ai(r,i),p={condition:o,t:l,e:u};return P.runKernel(Wu,p)}var nn=L({where_:e3});function t3(e){let t={x:E(e,\"x\",\"zerosLike\")};return P.runKernel(Yu,t)}var qe=L({zerosLike_:t3});function n3(e,t){let n=E(e,\"a\",\"div\"),a=E(t,\"b\",\"div\");[n,a]=_t(n,a);let r=he(n,a),s=qe(r),i=Jn(a,s);return nn(i,s,r)}var ow=L({divNoNan_:n3});function a3(e,t){let n=E(e,\"t1\",\"dot\"),a=E(t,\"t2\",\"dot\");A((n.rank===1||n.rank===2)&&(a.rank===1||a.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);let r=n.rank===1?n.size:n.shape[1],s=a.rank===1?a.size:a.shape[0];if(A(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),n.rank===1&&a.rank===1){let i=W(n,[1,-1]),o=W(a,[-1,1]),l=$e(i,o);return W(l,[])}else if(n.rank===1&&a.rank===2){let i=W(n,[1,-1]),o=W(a,[a.shape[0],a.shape[1]]),l=$e(i,o);return W(l,[l.size])}else if(n.rank===2&&a.rank===1){let i=W(a,[-1,1]),o=$e(n,i);return W(o,[o.size])}else{let i=W(a,[a.shape[0],a.shape[1]]);return $e(n,i)}}var lw=L({dot_:a3});function r3(e,...t){let n=t.map((r,s)=>E(r,`tensors${s}`,\"einsum\")),a={equation:e};return P.runKernel(Tm,n,a)}var Zs=L({einsum_:r3});function s3(e){let t={x:E(e,\"x\",\"elu\",\"float32\")};return P.runKernel(ji,t)}var Qu=L({elu_:s3});function i3(e,t){let n=E(e,\"x\",\"ensureShape\",\"string_or_numeric\");if(!RS(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var AN=L({ensureShape_:i3});function o3(e){let t=E(e,\"x\",\"erf\");A(t.dtype===\"int32\"||t.dtype===\"float32\",()=>\"Input dtype must be `int32` or `float32`.\"),t.dtype===\"int32\"&&(t=re(t,\"float32\"));let n={x:t};return P.runKernel(qi,n)}var Um=L({erf_:o3});function uw(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function FN(e,t,n){let a=e.length+t.length,r=[],s=0,i=0;for(let o=0;o<a;o++)n.indexOf(o)===-1?r.push(e[s++]):r.push(t[i++]);return r}function $N(e,t){let n=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&n.push(e[s]);let r=t.map(s=>e[s]);return[n,r]}function mi(e,t){let n=t.map(a=>1);return FN(e,n,t)}function l3(e,t,n){A(uw(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function DN(e,t){if(uw(e,t))return null;let n=[];for(let a=0;a<t;++a)e.indexOf(a)===-1&&n.push(a);return e.forEach(a=>n.push(a)),n}function pw(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function u3(e,t){let n=[];for(let a=t-e;a<t;++a)n.push(a);return n}function p3(e,t=null,n=!1){let a={x:E(e,\"x\",\"max\")},r={reductionIndices:t,keepDims:n};return P.runKernel(lo,a,r)}var ma=L({max_:p3});function c3(e,t=null,n=!1){let a={x:E(e,\"x\",\"min\")},r={axis:t,keepDims:n};return P.runKernel(ho,a,r)}var Ol=L({min_:c3});function d3(e,t){let n=E(e,\"base\",\"pow\"),a=E(t,\"exp\",\"pow\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(vo,r)}var ur=L({pow_:d3});function xe(e,t){if((en(e)&&t!==\"string\"||Array.isArray(e))&&t!==\"complex64\")throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean|string)\");if(t===\"string\"&&en(e)&&!(e instanceof Uint8Array))throw new Error(\"When making a scalar from encoded string, the value must be `Uint8Array`.\");return Ss(e,[],[],t)}function h3(e){let t={x:E(e,\"x\",\"sqrt\",\"float32\")};return P.runKernel(Po,t)}var rn=L({sqrt_:h3});function m3(e){let t=E(e,\"x\",\"square\"),n={};return P.runKernel(\"Square\",{x:t},n)}var pt=L({square_:m3});function f3(e,t=null,n=!1){let a=E(e,\"x\",\"sum\");a.dtype===\"bool\"&&(a=re(a,\"int32\"));let r={x:a},s={axis:t,keepDims:n};return P.runKernel(Lo,r,s)}var fe=L({sum_:f3});function g3(e,t=\"euclidean\",n=null,a=!1){e=E(e,\"x\",\"norm\");let r=RN(e,t,n),s=r.shape;if(a){let i=Aa(n,e.shape);s=mi(r.shape,i)}return W(r,s)}function RN(e,t,n=null){if(e.rank===0)return Lt(e);if(e.rank!==1&&n===null)return RN(W(e,[-1]),t,n);if(e.rank===1||typeof n==\"number\"||Array.isArray(n)&&n.length===1){if(t===1)return fe(Lt(e),n);if(t===1/0)return ma(Lt(e),n);if(t===-1/0)return Ol(Lt(e),n);if(t===\"euclidean\"||t===2)return rn(fe(ur(Lt(e),xe(2,\"int32\")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return ma(fe(Lt(e),n[0]),n[1]-1);if(t===1/0)return ma(fe(Lt(e),n[1]),n[0]);if(t===-1/0)return Ol(fe(Lt(e),n[1]),n[0]);if(t===\"fro\"||t===\"euclidean\")return rn(fe(pt(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var ep=L({norm_:g3});function b3(e,t=null,n=!1){return ep(e,\"euclidean\",t,n)}var cw=L({euclideanNorm_:b3});function y3(e){let t={x:E(e,\"x\",\"exp\")};return P.runKernel(Ki,t)}var dn=L({exp_:y3});function x3(e,t=0){let n=E(e,\"x\",\"expandDims\",\"string_or_numeric\");A(t<=n.rank,()=>\"Axis must be <= rank of the tensor\");let a={input:n},r={dim:t};return P.runKernel(hu,a,r)}var Gt=L({expandDims_:x3});function v3(e){let t={x:E(e,\"x\",\"expm1\")};return P.runKernel(Xi,t)}var dw=L({expm1_:v3});function w3(e,t){let n=E(e,\"x\",\"tile\",\"string_or_numeric\");A(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let a={x:n},r={reps:t};return P.runKernel(ks,a,r)}var On=L({tile_:w3});function k3(e,t,n,a=\"float32\"){t==null&&(t=e);let r=Oe([e,t],a),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);let i=W(r.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return On(Gt(i,0),[n[0],1,1]);if(n.length===2)return On(Gt(Gt(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return On(Gt(Gt(Gt(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Gm=L({eye_:k3});function I3(e){let t={x:E(e,\"x\",\"floor\",\"float32\")};return P.runKernel(Yi,t)}var tp=L({floor_:I3});function S3(e,t,n=0,a=0){let r=E(e,\"x\",\"gather\"),s=E(t,\"indices\",\"gather\",\"int32\"),i={x:r,indices:s},o={axis:n,batchDims:a};return P.runKernel(fu,i,o)}var np=L({gather_:S3});function N3(e,t){let n=E(e,\"a\",\"greater\",\"string_or_numeric\"),a=E(t,\"b\",\"greater\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(bu,r)}var Cn=L({greater_:N3});function T3(e,t){let n=E(e,\"a\",\"greaterEqual\",\"string_or_numeric\"),a=E(t,\"b\",\"greaterEqual\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(Qi,r)}var $r=L({greaterEqual_:T3});function C3(e){let t={input:E(e,\"input\",\"imag\")};return P.runKernel(_m,t)}var ld=L({imag_:C3});function E3(e){let t={x:E(e,\"x\",\"isFinite\")};return P.runKernel(to,t)}var hw=L({isFinite_:E3});function _3(e){let t={x:E(e,\"x\",\"isInf\")};return P.runKernel(no,t)}var mw=L({isInf_:_3});function A3(e){let t={x:E(e,\"x\",\"isNaN\")};return P.runKernel(ao,t)}var fw=L({isNaN_:A3});function F3(e,t=.2){let n={x:E(e,\"x\",\"leakyRelu\")},a={alpha:t};return P.runKernel(ro,n,a)}var ud=L({leakyRelu_:F3});function $3(e,t){let n=E(e,\"a\",\"less\",\"string_or_numeric\"),a=E(t,\"b\",\"less\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(yu,r)}var Pl=L({less_:$3});function D3(e,t){let n=E(e,\"a\",\"lessEqual\",\"string_or_numeric\"),a=E(t,\"b\",\"lessEqual\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(xu,r)}var Cs=L({lessEqual_:D3});function MN(e,t,n){if(n<=0)throw new Error(\"The number of values should be positive.\");let a={start:e,stop:t,num:n};return P.runKernel(vu,{},a)}function R3(e,t=5,n=1,a=1,r=.5){let s=E(e,\"x\",\"localResponseNormalization\");A(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`),A($l(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:a,beta:r},p=P.runKernel(oo,l,u);return o?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var gw=L({localResponseNormalization_:R3});function M3(e){let t={x:E(e,\"x\",\"log\",\"float32\")};return P.runKernel(so,t)}var Qn=L({log_:M3});function O3(e){let t={x:E(e,\"x\",\"log1p\")};return P.runKernel(io,t)}var pd=L({log1p_:O3});function P3(e){return A(ss(e),()=>\"The f passed in grad(f) must be a function\"),(t,n)=>{let a=E(t,\"x\",\"tf.grad\",\"string_or_numeric\"),r=n!=null?E(n,\"dy\",\"tf.grad\"):null;return P.tidy(()=>{let{value:s,grads:i}=P.gradients(()=>e(a),[a],r);return r!=null&&Nn(s.shape,r.shape,\"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"),Hm(i),i[0]})}}function L3(e){return A(ss(e),()=>\"The f passed in grads(f) must be a function\"),(t,n)=>{A(Array.isArray(t),()=>\"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s\");let a=bc(t,\"args\",\"tf.grads\",\"string_or_numeric\"),r=n!=null?E(n,\"dy\",\"tf.grads\"):null;return P.tidy(()=>{let{value:s,grads:i}=P.gradients(()=>e(...a),a,r);return r!=null&&Nn(s.shape,r.shape,\"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),Hm(i),i})}}function z3(e){return A(ss(e),()=>\"The f passed in valueAndGrad(f) must be a function\"),(t,n)=>{A(t instanceof Ce,()=>\"The x passed in valueAndGrad(f)(x) must be a tensor\"),A(n==null||n instanceof Ce,()=>\"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\");let{grads:a,value:r}=P.gradients(()=>e(t),[t],n);return Hm(a),{grad:a[0],value:r}}}function W3(e){return A(ss(e),()=>\"The f passed in valueAndGrads(f) must be a function\"),(t,n)=>{A(Array.isArray(t)&&t.every(r=>r instanceof Ce),()=>\"The args passed in valueAndGrads(f)(args) must be array of tensors\"),A(n==null||n instanceof Ce,()=>\"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\");let a=P.gradients(()=>e(...t),t,n);return n!=null&&Nn(a.value.shape,n.shape,\"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),Hm(a.grads),a}}function ON(e,t){A(ss(e),()=>\"The f passed in variableGrads(f) must be a function\"),A(t==null||Array.isArray(t)&&t.every(u=>u instanceof os),()=>\"The varList passed in variableGrads(f, varList) must be an array of variables\");let n=t!=null;if(!n){t=[];for(let u in P.registeredVariables)t.push(P.registeredVariables[u])}let a=n?t.filter(u=>!u.trainable):null,r=t.length;t=t.filter(u=>u.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let s=!0,{value:i,grads:o}=P.gradients(e,t,null,s);A(o.some(u=>u!=null),()=>\"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\"),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,p)=>{o[p]!=null&&(l[u.name]=o[p])}),a!=null&&a.forEach(u=>l[u.name]=null),{value:i,grads:l}}function pr(e){return P.customGrad(e)}function Hm(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.`)}function B3(e){let t={x:E(e,\"x\",\"neg\")};return P.runKernel(Cu,t)}var yt=L({neg_:B3});function V3(e){let t={x:E(e,\"x\",\"softplus\")};return P.runKernel(Oo,t)}var Go=L({softplus_:V3});function U3(e){let t=E(e,\"x\",\"logSigmoid\");return pr(n=>({value:yt(Go(yt(n))),gradFunc:a=>z(a,ha(yt(n)))}))(t)}var bw=L({logSigmoid_:U3});function G3(e,t){let n=E(e,\"a\",\"sub\"),a=E(t,\"b\",\"sub\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(Bo,r)}var pe=L({sub_:G3});function H3(e,t=-1){let n=E(e,\"logits\",\"logSoftmax\");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return pr((a,r)=>{let s=ma(a,t,!0),i=pe(a,s),o=pe(re(i,\"float32\"),Qn(fe(dn(i),t,!0)));return r([o]),{value:o,gradFunc:(l,u)=>{let[p]=u,d=!0,c=dn(p);return pe(l,z(fe(l,t,d),c))}}})(n)}var jm=L({logSoftmax_:H3});function j3(e,t=null,n=!1){let a=E(e,\"x\",\"logSumExp\"),r=Aa(t,a.shape),s=ma(a,r,!0),i=pe(a,s),o=dn(i),l=fe(o,r),u=Qn(l),p=X(W(s,u.shape),u);if(n){let d=mi(p.shape,r);return W(p,d)}return p}var cd=L({logSumExp_:j3});function q3(e,t){let n=E(e,\"a\",\"logicalAnd\",\"bool\"),a=E(t,\"b\",\"logicalAnd\",\"bool\");ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(wu,r)}var _a=L({logicalAnd_:q3});function K3(e){let t={x:E(e,\"x\",\"logicalNot\",\"bool\")};return P.runKernel(ku,t)}var dd=L({logicalNot_:K3});function X3(e,t){let n=E(e,\"a\",\"logicalOr\",\"bool\"),a=E(t,\"b\",\"logicalOr\",\"bool\");ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(Iu,r)}var qm=L({logicalOr_:X3});function Y3(e,t){let n=E(e,\"a\",\"logicalXor\",\"bool\"),a=E(t,\"b\",\"logicalXor\",\"bool\");return ct(n.shape,a.shape),_a(qm(e,t),dd(_a(e,t)))}var yw=L({logicalXor_:Y3}),vh=2147483648;function Z3(e,t,n=\"left\"){let a=E(e,\"sortedSequence\",\"searchSorted\"),r=E(t,\"values\",\"searchSorted\"),s=a.shape[a.shape.length-1],i=r.shape[r.shape.length-1],o=W(a,[-1,s]),l=W(r,[-1,i]);if(o.rank<2)throw new Error(\"Sorted input argument must be at least 2-dimensional\");if(o.shape[0]!==l.shape[0])throw new Error(\"Leading dimension of 'sortedSequence' and 'values' must match.\");if(ot(l.shape)>=vh)throw new Error(`values tensor size must less than ${vh}`);if(o.shape[1]>=vh)throw new Error(`trailing dim_size must less than ${vh} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},p={side:n};return P.runKernel(zu,u,p)}var Km=L({searchSorted_:Z3});function PN(e,t){return Km(e,t,\"left\")}function J3(e,t,n,a,r){let s=E(e,\"x\",\"maxPool\"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),A(dr(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Tn(\"maxPool\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r},d=P.runKernel(po,u,p);return l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Dt=L({maxPool_:J3});function Q3(e,t=[1,1,1],n,a,r,s=\"NDHWC\"){let i=E(e,\"x\",\"maxPool3d\"),o=i,l=!1;i.rank===4&&(l=!0,o=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),A(s===\"NDHWC\",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Tn(\"maxPool3d\",a,r);let u={x:o},p={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},d=P.runKernel(Nu,u,p);return l?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var xw=L({maxPool3d_:Q3});function eL(e,t,n,a,r=!1){let s={x:E(e,\"x\",\"maxPoolWithArgmax\")},i={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},o=P.runKernel(Vc,s,i);return{result:o[0],indexes:o[1]}}var LN=L({maxPoolWithArgmax_:eL});function tL(e,t){let n=E(e,\"a\",\"maximum\"),a=E(t,\"b\",\"maximum\");[n,a]=_t(n,a),n.dtype===\"bool\"&&(n=re(n,\"int32\"),a=re(a,\"int32\")),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(uo,r)}var hr=L({maximum_:tL});function nL(e,t=null,n=!1){let a={x:E(e,\"x\",\"mean\")},r={axis:t,keepDims:n};return P.runKernel(co,a,r)}var Ct=L({mean_:nL});function It(e,t=\"float32\"){if(na(e),t===\"complex64\"){let a=It(e,\"float32\"),r=It(e,\"float32\");return _r(a,r)}let n=xm(ot(e),t);return P.makeTensor(n,e,t)}function Pn(e,t=\"float32\"){if(na(e),t===\"complex64\"){let a=Pn(e,\"float32\"),r=It(e,\"float32\");return _r(a,r)}let n=Nv(ot(e),t);return P.makeTensor(n,e,t)}function zN(e,t,{indexing:n=\"xy\"}={}){if(n!==\"xy\"&&n!==\"ij\")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let a=E(e,\"x\",\"meshgrid\",e instanceof Ce?e.dtype:\"float32\");if(t===void 0)return[a];let r=E(t,\"y\",\"meshgrid\",t instanceof Ce?t.dtype:\"float32\"),s=ot(a.shape),i=ot(r.shape);return n===\"xy\"?(a=W(a,[1,-1]),r=W(r,[-1,1]),[$e(Pn([i,1],a.dtype),a),$e(r,Pn([1,s],r.dtype))]):(a=W(a,[-1,1]),r=W(r,[1,-1]),[$e(a,Pn([1,i],a.dtype)),$e(Pn([s,1],r.dtype),r)])}function aL(e,t){let n=E(e,\"a\",\"minimum\"),a=E(t,\"b\",\"minimum\");[n,a]=_t(n,a),n.dtype===\"bool\"&&(n=re(n,\"int32\"),a=re(a,\"int32\")),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(mo,r)}var ds=L({minimum_:aL});function rL(e,t,n){A(n===\"reflect\"||n===\"symmetric\",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let a=E(e,\"x\",\"mirrorPad\");if(a.rank===0)throw new Error(\"mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad\");A(t.length===a.rank,()=>`Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);let r=n===\"reflect\"?1:0;for(let o=0;o<a.rank;o++)A(t[o].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),A(t[o][0]>=0&&t[o][0]<=a.shape[o]-r&&t[o][1]>=0&&t[o][1]<=a.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${a.shape[o]-r} or less than 0 for input of shape ${a.shape}`);let s={paddings:t,mode:n},i={x:a};return P.runKernel(fo,i,s)}var vw=L({mirrorPad_:rL});function sL(e,t){let n=E(e,\"a\",\"mod\"),a=E(t,\"b\",\"mod\");[n,a]=_t(n,a);let r={a:n,b:a};return P.runKernel(go,r)}var ww=L({mod_:sL});function iL(e,t=null,n=!1){e=E(e,\"x\",\"moments\");let a=Aa(t,e.shape),r=Ct(e,a,n),s=r.shape;n||(s=mi(r.shape,a));let i=pt(pe(re(e,\"float32\"),W(r,s))),o=Ct(i,a,n);return{mean:r,variance:o}}var hd=L({moments_:iL});function oL(e,t,n,a){let r=E(t,\"data\",\"multiRNNCell\"),s=bc(n,\"c\",\"multiRNNCell\"),i=bc(a,\"h\",\"multiRNNCell\"),o=r,l=[];for(let d=0;d<e.length;d++){let c=e[d](o,s[d],i[d]);l.push(c[0]),l.push(c[1]),o=c[1]}let u=[],p=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),p.push(l[d+1]);return[u,p]}var WN=L({multiRNNCell_:oL});function lL(e,t,n,a=!1){let r=E(e,\"logits\",\"multinomial\"),s=r.size,i=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?W(r,[1,-1]):r},l={numSamples:t,seed:n,normalized:a},u=P.runKernel(Tu,o,l);return i===1?W(u,[u.size]):u}var BN=L({multinomial_:lL});function uL(e,t){let n=E(e,\"a\",\"notEqual\",\"string_or_numeric\"),a=E(t,\"b\",\"notEqual\",\"string_or_numeric\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a};return P.runKernel(Eu,r)}var fi=L({notEqual_:uL});function pL(e,t,n=1,a=0,r=\"int32\"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:E(e,\"indices\",\"oneHot\",\"int32\")},i={dtype:r,depth:t,onValue:n,offValue:a};return P.runKernel(yo,s,i)}var Ll=L({oneHot_:pL});function cL(e){let t={x:E(e,\"x\",\"onesLike\")};return P.runKernel($u,t)}var ea=L({onesLike_:cL});function dL(e,t){let n=E(e,\"v1\",\"outerProduct\"),a=E(t,\"v2\",\"outerProduct\");A(n.rank===1&&a.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);let r=W(n,[-1,1]),s=W(a,[1,-1]);return $e(r,s)}var VN=L({outerProduct_:dL});function hL(e,t,n=0){let a=E(e,\"x\",\"pad\");if(a.rank===0)throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");let r={paddings:t,constantValue:n},s={x:a};return P.runKernel(xo,s,r)}var xa=L({pad_:hL});function mL(e,t,n=0){return A(t.length===2,()=>\"Invalid number of paddings. Must be length of 2.\"),xa(e,[t],n)}var UN=L({pad1d_:mL});function fL(e,t,n=0){return A(t.length===2&&t[0].length===2&&t[1].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),xa(e,t,n)}var GN=L({pad2d_:fL});function gL(e,t,n=0){return A(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),xa(e,t,n)}var HN=L({pad3d_:gL});function bL(e,t,n=0){return A(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>\"Invalid number of paddings. Must be length of 2 each.\"),xa(e,t,n)}var jN=L({pad4d_:bL});function yL(e,t,n){let a=E(e,\"x\",\"spaceToBatchND\");A(a.rank>=1+t.length,()=>`input rank ${a.rank} should be > than [blockShape] ${t.length}`),A(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),A(a.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:a},s={blockShape:t,paddings:n};return P.runKernel(Vu,r,s)}var md=L({spaceToBatchND_:yL});function xL(e,t,n,a,r,s,i){r==null&&(r=[1,1]),s==null&&(s=1),a===0&&(a=\"valid\");let o=E(e,\"x\",\"maxPool\"),l=o,u=!1;o.rank===3&&(u=!0,l=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(dr(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);let p=wN(l.shape,t,s,r,a),d=[p.dilationHeight,p.dilationWidth],c;a===\"same\"?c=wL([p.filterHeight,p.filterWidth],d):c=[[0,0],[0,0]];let h=d[0]===1&&d[1]===1,[m,f]=vL([p.inHeight,p.inWidth],d,c),g=h?a:\"valid\",b=h?l:md(l,d,m),y=(n===\"avg\"?()=>ya(b,t,s,g,i):()=>Dt(b,t,s,g,i))(),x=h?y:id(y,d,f);return u?W(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function vL(e,t,n){let a=n.map(p=>p[0]),r=n.map(p=>p[1]),s=e.concat(a,r),i=t.map((p,d)=>(p-s[d]%p)%p),o=r.map((p,d)=>p+i[d]),l=t.map((p,d)=>[a[d],o[d]]),u=t.map((p,d)=>[0,i[d]]);return[l,u]}function wL(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),a=n.map(s=>Math.floor(s/2)),r=n.map((s,i)=>s-a[i]);return n.map((s,i)=>[a[i],r[i]])}var kw=L({pool_:xL});function kL(e,t){let n=E(e,\"x\",\"prelu\"),a=E(t,\"alpha\",\"prelu\"),r={x:n,alpha:a};return P.runKernel(wo,r)}var fd=L({prelu_:kL});function IL(e,t=null,n=!1){let a=E(e,\"x\",\"prod\");a.dtype===\"bool\"&&(a=re(a,\"int32\"));let r={x:a},s={axis:t,keepDims:n};return P.runKernel(ko,r,s)}var Iw=L({prod_:IL});function SL(e,t,n,a){let r=e.map((p,d)=>E(p,`tensors${d}`,\"raggedGather\",\"int32\")),s=E(t,\"paramsDenseValues\",\"raggedGather\"),i=E(n,\"indices\",\"raggedGather\",\"int32\"),o={paramsNestedSplits:r,paramsDenseValues:s,indices:i},l={outputRaggedRank:a},u=P.runKernel(Am,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var qN=L({raggedGather_:SL});function NL(e,t,n){let a=E(e,\"starts\",\"raggedRange\"),r=E(t,\"limits\",\"raggedRange\",a.dtype),s=E(n,\"deltas\",\"raggedRange\",a.dtype),i={starts:a,limits:r,deltas:s},o=P.runKernel(Fm,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var KN=L({raggedRange_:NL});function TL(e,t,n,a,r){let s=E(e,\"shape\",\"raggedTensorToTensor\",\"int32\"),i=E(t,\"values\",\"raggedTensorToTensor\"),o=E(n,\"defaultValue\",\"raggedTensorToTensor\",i.dtype),l=a.map((d,c)=>E(d,`tensors${c}`,\"raggedTensorToTensor\",\"int32\")),u={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},p={rowPartitionTypes:r};return P.runKernel($m,u,p)}var XN=L({raggedTensorToTensor_:TL});function CL(e,t,n){na(e);let a=ot(e),r=null;if(n==null||n===\"float32\")r=new Float32Array(a);else if(n===\"int32\")r=new Int32Array(a);else if(n===\"bool\")r=new Uint8Array(a);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<a;s++)r[s]=t();return P.makeTensor(r,e,n)}var YN=L({rand_:CL}),Sw=xs(bm()),ZN={};_e(ZN,{TEST_EPSILON_FLOAT16:()=>JN,createVideoElement:()=>ML,encodeStrings:()=>QN,expectArrayBuffersEqual:()=>RL,expectArraysClose:()=>_L,expectArraysEqual:()=>FL,expectNumbersClose:()=>$L,expectPromiseToFail:()=>AL,expectValuesInRange:()=>DL,play:()=>OL,testEpsilon:()=>Nw});var EL=.001,JN=.1;function _L(e,t,n){return n==null&&(n=Nw()),Rx(e,t,(a,r)=>Tw(a,r,n))}function Nw(){return P.backend.floatPrecision()===32?EL:JN}function Rx(e,t,n){let a=!0;if((en(e)||en(t))&&(a=!1),en(e)&&en(t)&&(a=!0),a){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=lr(e),o=lr(t);if(!Ar(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let r=en(e)?e:is(e),s=en(t)?t:is(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.\nActual:   ${r}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let o=r[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.\nActual:   ${r}.\nExpected: ${s}.`)}typeof expect!=\"undefined\"&&expect().nothing()}function AL(e,t){e().then(()=>t.fail(),()=>t()),typeof expect!=\"undefined\"&&expect().nothing()}function FL(e,t){let n=typeof t==\"string\"||typeof t==\"number\"||typeof t==\"boolean\"?[t]:t;return Jr(e)||Jr(e[0])||Jr(t)||Jr(t[0])?Rx(e,n,(a,r)=>a==r):Rx(e,t,(a,r)=>Tw(a,r,0))}function $L(e,t,n){if(n==null&&(n=Nw()),!Tw(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect!=\"undefined\"&&expect().nothing()}function Tw(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function DL(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`)}function RL(e,t){let n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`)}function QN(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?QN(n):e[t]=nd(n)}return e}function ML(e){let t=document.createElement(\"video\");return\"playsInline\"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position=\"fixed\",t.style.left=\"0px\",t.style.top=\"0px\",t.preload=\"auto\",t.appendChild(e),new Promise(n=>{t.addEventListener(\"loadeddata\",a=>n(t)),t.load()})}async function OL(e){await e.play(),\"requestVideoFrameCallback\"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var Cw=class{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=r||Math.random();this.random=Sw.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let a=this.nextVal;return this.nextVal=NaN,a}let e,t,n=!1;for(;!n;){let a,r,s;do a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*i,t=this.mean+this.stdDev*r*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype===\"float32\"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},PL=class{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;let r=a||Math.random();this.randu=Sw.alea(r.toString()),this.randn=new Cw(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do a=this.randn.nextValue(),s=1+this.c*a;while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype===\"float32\"?e:Math.round(e)}},LL=class{constructor(e=0,t=1,n,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype===\"float32\",this.min=e,this.range=t-e,this.dtype=n,a==null&&(a=Math.random()),typeof a==\"number\"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Sw.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function zL(e,t,n=1,a=\"float32\",r){if(na(e),n==null&&(n=1),a==null&&(a=\"float32\"),a!==\"float32\"&&a!==\"int32\")throw new Error(`Unsupported data type ${a}`);let s=new PL(t,n,a,r),i=Oe(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var eT=L({randomGamma_:zL});function WL(e,t=0,n=1,a,r){if(na(e),a!=null&&a===\"bool\")throw new Error(`Unsupported data type ${a}`);let s=new Cw(t,n,a,!1,r),i=Oe(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Xm=L({randomNormal_:WL});function BL(e,t,n){if(t!=null&&t===\"bool\")throw new Error(`Unsupported data type ${t}`);return Xm(e,0,1,t,n)}var tT=L({randomStandardNormal_:BL});function VL(e,t=0,n=1,a=\"float32\",r){na(e);let s=Oe(e,a),i=new LL(t,n,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var Es=L({randomUniform_:VL});function UL(e,t,n,a){return Es(e,t,n,\"int32\",a)}var nT=L({randomUniformInt_:UL});function gi(e,t,n=1,a=\"float32\"){if(n===0)throw new Error(\"Cannot have a step of zero\");let r={start:e,stop:t,step:n,dtype:a};return P.runKernel(Uc,{},r)}function GL(e){let t={input:E(e,\"input\",\"real\")};return P.runKernel(Dm,t)}var zl=L({real_:GL});function HL(e){let t={x:E(e,\"x\",\"reciprocal\")};return P.runKernel(Io,t)}var Ew=L({reciprocal_:HL});function jL(e){let t={x:E(e,\"x\",\"relu\")};return P.runKernel(So,t)}var Ke=L({relu_:jL});function qL(e){let t={x:E(e,\"x\",\"relu6\")};return P.runKernel(Co,t)}var Ym=L({relu6_:qL});function KL(e,t){let n={x:E(e,\"x\",\"reverse\")},a={dims:t};return P.runKernel(Eo,n,a)}var ba=L({reverse_:KL});function XL(e){let t=E(e,\"x\",\"reverse\");return A(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ba(t,0)}var aT=L({reverse1d_:XL});function YL(e,t){let n=E(e,\"x\",\"reverse\");return A(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),ba(n,t)}var rT=L({reverse2d_:YL});function ZL(e,t){let n=E(e,\"x\",\"reverse\");return A(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),ba(n,t)}var sT=L({reverse3d_:ZL});function JL(e,t){let n=E(e,\"x\",\"reverse\");return A(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),ba(n,t)}var iT=L({reverse4d_:JL});function QL(e){let t={x:E(e,\"x\",\"round\")};return P.runKernel(_o,t)}var Zm=L({round_:QL});function ez(e){let t={x:E(e,\"x\",\"rsqrt\",\"float32\")};return P.runKernel(Ao,t)}var Jm=L({rsqrt_:ez});function tz(e){let t={x:E(e,\"x\",\"selu\")};return P.runKernel(Fo,t)}var Qm=L({selu_:tz});function nz(e,t,n,a,r,s=[1,1],i=\"NHWC\"){let o=E(e,\"x\",\"separableConv2d\"),l=E(t,\"depthwiseFilter\",\"separableConv2d\"),u=E(n,\"pointwiseFilter\",\"separableConv2d\"),p=o,d=!1;if(o.rank===3&&(d=!0,p=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i===\"NCHW\")throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");A(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),A(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let c=l.shape[2],h=l.shape[3];A(u.shape[2]===c*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${c*h}, but got ${u.shape[2]}.`);let m=Ts(p,l,a,r,i,s),f=$t(m,u,1,\"valid\",i);return d?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var _s=L({separableConv2d_:nz});async function az(e,t){let n=E(e,\"x\",\"setdiff1d\"),a=E(t,\"y\",\"setdiff1d\");A(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),A(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),A(a.rank===1,()=>`y should be 1D tensor, but got y (${a.shape}).`);let r=await n.data(),s=await a.data(),i=new Set(s),o=0;for(let p=0;p<r.length;p++)i.has(r[p])||o++;let l=new Wt([o],n.dtype),u=new Wt([o],\"int32\");for(let p=0,d=0;p<r.length;p++)i.has(r[p])||(l.values[d]=r[p],u.values[d]=p,d++);return[l.toTensor(),u.toTensor()]}var oT=az;function rz(e){let t={x:E(e,\"x\",\"sign\")};return P.runKernel(Ro,t)}var _w=L({sign_:rz});function sz(e){let t={x:E(e,\"x\",\"sin\",\"float32\")};return P.runKernel($o,t)}var ef=L({sin_:sz});function iz(e){let t={x:E(e,\"x\",\"sinh\")};return P.runKernel(Do,t)}var tf=L({sinh_:iz});function oz(e,t,n){let a=E(e,\"x\",\"slice1d\");return A(a.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`),Ve(a,[t],[n])}var gd=L({slice1d_:oz});function lz(e,t,n){let a=E(e,\"x\",\"slice2d\");return A(a.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`),Ve(a,t,n)}var nf=L({slice2d_:lz});function uz(e,t,n){let a=E(e,\"x\",\"slice3d\");return A(a.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`),Ve(a,t,n)}var Ho=L({slice3d_:uz});function pz(e,t,n){let a=E(e,\"x\",\"slice4d\");return A(a.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`),Ve(a,t,n)}var Wl=L({slice4d_:pz});function cz(e,t=-1){let n=E(e,\"logits\",\"softmax\",\"float32\");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let a={logits:n},r={dim:t};return P.runKernel(zo,a,r)}var qa=L({softmax_:cz});function dz(e){A(e.dtype===\"complex64\",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return P.runKernel(Cm,t)}var bd=L({fft_:dz});function hz(e){A(e.dtype===\"complex64\",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return P.runKernel(Em,t)}var Bl=L({ifft_:hz});function mz(e){let t=e.shape[e.shape.length-1],n=e.size/t,a;if(t<=2){let r=W(e,[n,t]);a=Bl(r)}else{let r=[n,2*(t-1)],s=W(zl(e),[n,t]),i=W(ld(e),[n,t]),o=ba(Ve(s,[0,1],[n,t-2]),1),l=z(ba(Ve(i,[0,1],[n,t-2]),1),xe(-1)),u=et([s,o],1),p=et([i,l],1),d=W(_r(u,p),[r[0],r[1]]);a=Bl(d)}if(a=zl(a),e.rank===3&&e.shape[0]!==0){let r=a,s=e.shape[0];a=W(a,[s,a.shape[0]/s,a.shape[1]]),r.dispose()}return a}var af=L({irfft_:mz});function fz(e,t,n=0){let a={x:E(e,\"x\",\"split\")},r={numOrSizeSplits:t,axis:n};return P.runKernel(Uu,a,r)}var Ln=L({split_:fz});function gz(e,t){A(e.dtype===\"float32\",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n,r;if(t!=null&&t<n){let m=e.shape.map(g=>0),f=e.shape.map(g=>g);f[e.shape.length-1]=t,r=Ve(e,m,f),n=t}else if(t!=null&&t>n){let m=e.shape.map(f=>f);m[e.shape.length-1]=t-n,r=et([e,It(m)],e.shape.length-1),n=t}else r=e;let s=qe(r),i=W(_r(r,s),[a,n]),o=bd(i),l=Math.floor(n/2)+1,u=zl(o),p=ld(o),d=Ln(u,[l,n-l],u.shape.length-1),c=Ln(p,[l,n-l],p.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=l,W(_r(d[0],c[0]),h)}var yd=L({rfft_:gz});function bz(e,t){let n=E(e,\"a\",\"squaredDifference\"),a=E(t,\"b\",\"squaredDifference\");[n,a]=_t(n,a),ct(n.shape,a.shape);let r={a:n,b:a},s={};return P.runKernel(Wo,r,s)}var rf=L({squaredDifference_:bz});function yz(e,t){let n=E(e,\"x\",\"squeeze\",\"string_or_numeric\");return W(n,MS(n.shape,t).newShape)}var As=L({squeeze_:yz});function xz(e,t=0){let n=bc(e,\"tensors\",\"stack\",\"string_or_numeric\");A(n.length>=1,()=>\"Pass at least one tensor to tf.stack\"),n.length>0&&A(t<=n[0].rank,()=>\"Axis must be <= rank of the tensor\");let a=n,r={axis:t};return P.runKernel(Du,a,r)}var At=L({stack_:xz});function vz(e,t=0){let n={x:E(e,\"x\",\"step\")},a={alpha:t};return P.runKernel(Is,n,a)}var jo=L({step_:vz});function wz(e,t,n,a,r=0,s=0,i=0,o=0,l=0){let u={x:E(e,\"x\",\"stridedSlice\",\"string_or_numeric\")},p={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return P.runKernel(ju,u,p)}var Aw=L({stridedSlice_:wz});function kz(e){let t={x:E(e,\"x\",\"tan\",\"float32\")};return P.runKernel(Vo,t)}var Fw=L({tan_:kz});function je(e,t){Si(e);let n=lr(e,t);if(n.length!==1)throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");return Ss(e,null,n,t)}function Ea(e,t,n){if(Si(e),t!=null&&t.length!==2)throw new Error(\"tensor2d() requires shape to have two numbers\");let a=lr(e,n);if(a.length!==2&&a.length!==1)throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");return Ss(e,t,a,n)}function xd(e,t,n){if(Si(e),t!=null&&t.length!==3)throw new Error(\"tensor3d() requires shape to have three numbers\");let a=lr(e,n);if(a.length!==3&&a.length!==1)throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");return Ss(e,t,a,n)}function Fa(e,t,n){if(Si(e),t!=null&&t.length!==4)throw new Error(\"tensor4d() requires shape to have four numbers\");let a=lr(e,n);if(a.length!==4&&a.length!==1)throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");return Ss(e,t,a,n)}function lT(e,t,n){if(Si(e),t!=null&&t.length!==5)throw new Error(\"tensor5d() requires shape to have five numbers\");let a=lr(e,n);if(a.length!==5&&a.length!==1)throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");return Ss(e,t,a,n)}function uT(e,t,n){if(Si(e),t!=null&&t.length!==6)throw new Error(\"tensor6d() requires shape to have six numbers\");let a=lr(e,n);if(a.length!==6&&a.length!==1)throw new Error(\"tensor6d() requires values to be number[][][][][][] or flat/TypedArray\");if(a.length===1&&t==null)throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");return t=t||a,Ss(e,t,a,n)}var sf={};_e(sf,{calculateShapes:()=>pT,validateInput:()=>of,validateUpdateShape:()=>$w});function $w(e,t,n){let a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<a+(n.rank-r))throw new Error(s+` Output shape length < ${a+(n.rank-r)}`);if(n.rank!==r+e.length-a)throw new Error(s+` update.rank != ${r+e.length-a}`);for(let i=0;i<r;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==e[i+a])throw new Error(s+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function of(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!==\"int32\")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}$w(n,t,e)}function pT(e,t,n){let a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length,i=1;for(let d=r;d<s;++d)i*=n[d];let o=r<1?1:r,l=ot(t.shape)/o,u=[...Xl(n.slice(0,r)),1],p=ot(n);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:u,outputSize:p}}function Iz(e,t,n){let a=E(e,\"tensor\",\"tensorScatterupdate\"),r=E(t,\"indices\",\"tensorScatterupdate\",\"int32\"),s=E(n,\"updates\",\"tensorScatterupdate\");if(of(s,r,a.shape),a.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${s.dtype}.`);let i={tensor:a,indices:r,updates:s},o={};return P.runKernel(Lu,i,o)}var cT=L({tensorScatterUpdate_:Iz});function Sz(e,t=1,n=!0){let a=E(e,\"x\",\"topk\");if(a.rank===0)throw new Error(\"topk() expects the input to be of rank 1 or higher\");let r=a.shape[a.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let s={x:a},i={k:t,sorted:n},[o,l]=P.runKernel(qu,s,i);return{values:o,indices:l}}var Dw=L({topk_:Sz});function Nz(e,t=0,n=1,a,r){if(na(e),a!=null&&a===\"bool\")throw new Error(\"Unsupported data type $ { dtype }\");let s=new Cw(t,n,a,!0,r),i=Oe(e,a);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var lf=L({truncatedNormal_:Nz});function Tz(e,t=0){let n=E(e,\"x\",\"unique\",\"string_or_numeric\");A(n.rank>0,()=>\"The input tensor must be at least 1D\");let a={x:n},r={axis:t},[s,i]=P.runKernel(Jc,a,r);return{values:s,indices:i}}var Rw=L({unique_:Tz});function Cz(e,t,n){let a=E(e,\"x\",\"unsortedSegmentSum\"),r=E(t,\"segmentIds\",\"unsortedSegmentSum\",\"int32\");A($l(n),()=>\"numSegments must be of dtype int\");let s={x:a,segmentIds:r},i={numSegments:n};return P.runKernel(Qc,s,i)}var uf=L({unsortedSegmentSum_:Cz});function Ez(e,t=0){let n=E(e,\"x\",\"unstack\",\"string_or_numeric\");A(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let a={value:n},r={axis:t};return P.runKernel(Xu,a,r)}var dt=L({unstack_:Ez});function dT(e,t){return Km(e,t,\"right\")}function Mw(e,t=!0,n,a){return P.makeVariable(e,t,n,a)}function hT(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let a=Oe(e,\"int32\"),r=Oe([n.length,e.length],\"int32\");for(let s=0;s<n.length;s++){let i=a.indexToLoc(n[s]),o=s*e.length;r.values.set(i,o)}return r.toTensor()}async function _z(e){let t=E(e,\"condition\",\"whereAsync\",\"bool\"),n=await t.data(),a=hT(t.shape,n);return e!==t&&t.dispose(),a}var Ow=_z;async function Az(e,t,n){let a=E(e,\"tensor\",\"boolMask\"),r=E(t,\"mask\",\"boolMask\",\"bool\"),s=n==null?0:n,i=r.rank,o=a.shape;A(i>0,()=>\"mask cannot be scalar\"),Nn(o.slice(s,s+i),r.shape,\"mask's shape must match the first K dimensions of tensor's shape,\");let l=1;for(let f=s;f<s+i;f++)l*=o[f];let u=o.slice(0,s).concat([l],o.slice(s+i)),p=W(a,u),d=W(r,[-1]),c=await Ow(d),h=As(c,[1]),m=np(p,h,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),h.dispose(),p.dispose(),d.dispose(),c.dispose(),m}var mT=Az;function Fz(e,t,n){let a=E(e,\"x\",\"transpose\");if(t==null&&(t=a.shape.map((i,o)=>o).reverse()),A(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`),t.forEach(i=>{A(i>=0&&i<a.rank,()=>`All entries in 'perm' must be between 0 and ${a.rank-1} but got ${t}`)}),a.rank<=1)return a.clone();let r={x:a},s={perm:t};return a.dtype===\"complex64\"?O(()=>{let i=zl(a),o=ld(a);return i=P.runKernel(Cr,{x:i},s),o=P.runKernel(Cr,{x:o},s),n&&(o=yt(o)),_r(i,o)}):P.runKernel(Cr,r,s)}var De=L({transpose_:Fz});function $z(e,t,n,a,r=!0){let s=E(e,\"v\",\"movingAverage\"),i=E(t,\"x\",\"movingAverage\"),o=E(n,\"decay\",\"movingAverage\");tN(s,i),A(Ar(s.shape,i.shape),()=>\"Shape mismatch in v and x\");let l=xe(1),u=pe(l,o),p=z(pe(i,s),u);if(r){A(a!=null,()=>\"When using zeroDebias: true, step is required.\");let d=E(a,\"step\",\"movingAverage\");p=he(p,pe(l,ur(o,d)))}return X(s,p)}var fT=L({movingAverage_:$z});function Dz(e,t,n){na(n);let a=E(e,\"indices\",\"scatterND\",\"int32\"),r=E(t,\"updates\",\"scatterND\");of(r,a,n);let s={indices:a,updates:r},i={shape:n};return P.runKernel(Pu,s,i)}var gT=L({scatterND_:Dz});function Rz(e,t,n,a){if(e.dtype!==\"int32\")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==a.dtype)throw new Error(\"sparseValues.dtype must match defaultValues.dtype\")}function Mz(e,t,n,a=0){na(n);let r=E(e,\"sparseIndices\",\"sparseToDense\",\"int32\"),s=E(t,\"sparseValues\",\"sparseToDense\",\"string_or_numeric\"),i=E(a,\"defaultValue\",\"sparseToDense\",s.dtype);Rz(r,s,n,i);let o={sparseIndices:r,sparseValues:s,defaultValue:i},l={outputShape:n};return P.runKernel(Hu,o,l)}var bT=L({sparseToDense_:Mz});function Oz(e,t){let n=E(t,\"indices\",\"gatherND\",\"int32\"),a={params:E(e,\"x\",\"gatherND\",\"string_or_numeric\"),indices:n};return P.runKernel(gu,a)}var yT=L({gatherND_:Oz});function Pz(e,t){if(t==null)return e.shape.slice();if(Ar(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let a=0;a<e.shape.length;a++)t[a]==null&&e.shape[a]!=null?n.push(e.shape[a]):n.push(t[a]);return n}return t}function Lz(e,t,n,a){let r=E(e,\"x\",\"dropout\");if(A(r.dtype===\"float32\",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Ce?r.clone():r;let s=Pz(r,n),i=1-t,o=he(tp(X(Es(s,0,1,\"float32\",a),i)),i);return z(r,o)}var Pw=L({dropout_:Lz});function Lw(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function pf(e,t,n){let a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(i)}return je(r,\"float32\")}async function zz(e,t,n=1){let a=E(e,\"predictions\",\"inTopK\"),r=E(t,\"targets\",\"inTopK\");A(a.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`),A(a.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`),Nn(a.shape.slice(0,a.shape.length-1),r.shape,\"predictions's shape should be align with the targets' shape, except the last dimension.\");let s=a.shape[a.shape.length-1];A(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await a.data(),o=await r.data(),[l,u]=[i.length/s,s],p=OS(\"bool\",l);for(let d=0;d<l;d++){let c=d*u,h=i.subarray(c,c+u),m=[];for(let f=0;f<h.length;f++)m.push({value:h[f],index:f});m.sort((f,g)=>g.value-f.value),p[d]=0;for(let f=0;f<n;f++)if(m[f].index===o[d]){p[d]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),bn(p,r.shape,\"bool\")}var xT=zz,Vl={};_e(Vl,{conv2d:()=>Vz,depthwiseConv2d:()=>jz,matMul:()=>Kz});function Wz(e,t,n,a,r,s=\"NHWC\",i){let o=e;e.rank===3&&(o=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=W(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),A(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),A(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=s===\"NHWC\"?o.shape[3]:o.shape[1],p=s===\"NHWC\"?l.shape[3]:l.shape[1];A(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),A(p===n[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${n[3]}).`),Tn(\"conv2dDerFilter\",r,i);let d={x:o,dy:l},c={strides:a,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:n};return P.runKernel(km,d,c)}var zw=L({conv2DBackpropFilter_:Wz});function cf(e,t,n){if(n==null||n===\"linear\")return e;if(n===\"relu\")return z(e,jo(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function df(e,t){let n=t,a=Bt(e.shape,t.shape);return a.length>0&&(n=fe(n,a)),W(n,e.shape)}function hf(e,t,n,a){if(t===\"linear\")return e;if(t===\"relu\")return Ke(e);if(t===\"elu\")return Qu(e);if(t===\"relu6\")return Ym(e);if(t===\"prelu\")return fd(e,n);if(t===\"leakyrelu\")return ud(e,a);if(t===\"sigmoid\")return ha(e);throw new Error(`Unknown fused activation ${t}.`)}var mf=(e,t)=>!(e>0)||t===\"linear\";function Bz({x:e,filter:t,strides:n,pad:a,dataFormat:r=\"NHWC\",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l=\"linear\",preluActivationWeights:u,leakyreluAlpha:p}){if(l=l||\"linear\",mf(P.state.gradientDepth,l)===!1){A(r===\"NHWC\",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let N=$t(e,t,n,a,r,s,i);return o!=null&&(N=X(N,o)),hf(N,l,u,p)}let d=E(e,\"x\",\"conv2d\",\"float32\"),c=E(t,\"filter\",\"conv2d\",\"float32\"),h=d,m=!1;d.rank===3&&(m=!0,h=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),A(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),A(c.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${c.rank}.`),Tn(\"fused conv2d\",a,i);let f=r===\"NHWC\"?h.shape[3]:h.shape[1];A(c.shape[2]===f,()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${c.shape[2]}.`),A(dr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let g=sd(h.shape,c.shape,n,s,a,i),b;o!=null&&(b=E(o,\"bias\",\"fused conv2d\"),[b]=_t(b,d),r===\"NHWC\"?ct(g.outShape,b.shape):(A(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),A(b.shape.length===0||b.shape[0]===g.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let y;if(u!=null){let N=u.shape;if(A(N.length<=1||N.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${N.length}.`),N.length===1)A(N[0]===1||N[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the number of output channels (${g.outChannels}).`);else if(N.length===3)try{ct(N,g.outShape)}catch(C){let _=`Error in fused conv2d: PReLU activation weights (${N}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(_)}y=E(u,\"prelu weights\",\"fused conv2d\")}let x=(N,C)=>{A(r===\"NHWC\",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);let[_,F,D,$]=C,S=cf(N,D,l);A(ps(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let M=nw(F.shape,S,_,n,a),B=zw(F,S,_.shape,n,a),U=[M,B];if($!=null){let H=df($,S);U.push(H)}return U},v={x:h,filter:c,bias:b,preluActivationWeights:y},I={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return o==null?pr((N,C,_)=>{let F=P.runKernel(oi,v,I);return _([C,N,F]),m&&(F=W(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:x}})(h,c):pr((N,C,_,F)=>{let D=P.runKernel(oi,v,I);return F([C,N,D,_]),m&&(D=W(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:x}})(h,c,b)}var Vz=L({fusedConv2d_:Bz});function Uz(e,t,n,a,r,s=[1,1],i){let o=e;e.rank===3&&(o=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},p={strides:a,pad:r,dimRoundingMode:i,dilations:s,filterShape:n};return P.runKernel(Im,u,p)}var vT=L({depthwiseConv2dNativeBackpropFilter_:Uz});function Gz(e,t,n,a,r,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},p={strides:a,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},d=P.runKernel(Sm,u,p);return l?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var wT=L({depthwiseConv2dNativeBackpropInput_:Gz});function Hz({x:e,filter:t,strides:n,pad:a,dataFormat:r=\"NHWC\",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l=\"linear\",preluActivationWeights:u,leakyreluAlpha:p}){if(mf(P.state.gradientDepth,l)===!1){let I=Ts(e,t,n,a,r,s,i);return o!=null&&(I=X(I,o)),hf(I,l,u,p)}let d=E(e,\"x\",\"depthwiseConv2d\",\"float32\"),c=E(t,\"filter\",\"depthwiseConv2d\",\"float32\"),h=d,m=!1;d.rank===3&&(m=!0,h=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),A(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),A(c.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`),A(h.shape[3]===c.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),s==null&&(s=[1,1]),A(dr(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),Tn(\"fused depthwiseConv2d\",a,i);let f=sd(h.shape,c.shape,n,s,a,i,!0),g;o!=null&&(g=E(o,\"bias\",\"fused conv2d\"),[g]=_t(g,d),ct(f.outShape,g.shape));let b;u!=null&&(b=E(u,\"prelu weights\",\"fused depthwiseConv2d\"));let y=(I,N)=>{A(ps(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[C,_,F,D]=N,$=cf(I,F,l),S=wT(_.shape,$,C,n,a,s,i),M=vT(_,$,C.shape,n,a,s,i);if(D!=null){let B=df(g,$);return[S,M,B]}return[S,M]},x={x:h,filter:c,bias:g,preluActivationWeights:b},v={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return o==null?pr((I,N,C)=>{let _=P.runKernel(li,x,v);return C([N,I,_]),m&&(_=W(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:y}})(h,c):pr((I,N,C,_)=>{let F=P.runKernel(li,x,v);return _([N,I,F,C]),m&&(F=W(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:y}})(h,c,g)}var jz=L({fusedDepthwiseConv2d_:Hz});function qz({a:e,b:t,transposeA:n=!1,transposeB:a=!1,bias:r,activation:s=\"linear\",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(mf(P.state.gradientDepth,s)===!1){let D=$e(e,t,n,a);return r!=null&&(D=X(D,r)),hf(D,s,i,o)}let l=E(e,\"a\",\"fused matMul\"),u=E(t,\"b\",\"fused matMul\");[l,u]=_t(l,u);let p=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=a?u.shape[u.rank-1]:u.shape[u.rank-2],c=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=a?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),f=u.shape.slice(0,-2),g=ot(m),b=ot(f);A(p===d,()=>`Error in fused matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${a} must match.`);let y=ct(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([c,h]),x=n?W(l,[g,p,c]):W(l,[g,c,p]),v=a?W(u,[b,h,d]):W(u,[b,d,h]),I;r!=null&&(I=E(r,\"bias\",\"fused matMul\"),[I]=_t(I,l),ct(y,I.shape));let N;i!=null&&(N=E(i,\"prelu weights\",\"fused matMul\"));let C=(D,$)=>{let[S,M,B,U]=$,H=cf(W(D,B.shape),B,s),q,K;if(!n&&!a?(q=$e(H,M,!1,!0),K=$e(S,H,!0,!1)):!n&&a?(q=$e(H,M,!1,!1),K=$e(H,S,!0,!1)):n&&!a?(q=$e(M,H,!1,!0),K=$e(S,H,!1,!1)):(q=$e(M,H,!0,!0),K=$e(H,S,!0,!0)),r!=null){let Z=df(U,H);return[q,K,Z]}else return[q,K]},_={a:x,b:v,bias:I,preluActivationWeights:N},F={transposeA:n,transposeB:a,activation:s,leakyreluAlpha:o};return r==null?pr((D,$,S)=>{let M=P.runKernel(ii,_,F);return S([D,$,M]),{value:W(M,y),gradFunc:C}})(x,v):pr((D,$,S,M)=>{let B=P.runKernel(ii,_,F);return M([D,$,B,S]),{value:W(B,y),gradFunc:C}})(x,v,I)}var Kz=L({fusedMatMul_:qz});function Xz(e){return pf(e,.54,.46)}var Yz=L({hammingWindow_:Xz});function Zz(e){return pf(e,.5,.5)}var kT=L({hannWindow_:Zz});function Jz(e,t,n,a=!1,r=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Ve(e,s,t)),s+=n;if(a)for(;s<e.size;){let o=s+t-e.size,l=et([Ve(e,s,t-o),yn([o],r)]);i.push(l),s+=n}return i.length===0?Ea([],[0,t]):W(et(i),[i.length,t])}var IT=L({frame_:Jz});function Qz(e,t,n,a,r=kT){a==null&&(a=Lw(t));let s=IT(e,t,n),i=z(s,r(t));return yd(i,a)}var eW=L({stft_:Qz});function tW(e,t,n,a,r=\"bilinear\",s=0){let i=E(e,\"image\",\"cropAndResize\"),o=E(t,\"boxes\",\"cropAndResize\",\"float32\"),l=E(n,\"boxInd\",\"cropAndResize\",\"int32\"),u=o.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),A(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),A(a.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`),A(a[0]>=1&&a[1]>=1,()=>`cropSize must be atleast [1,1], but was ${a}`),A(r===\"bilinear\"||r===\"nearest\",()=>`method must be bilinear or nearest, but was ${r}`);let p={image:i,boxes:o,boxInd:l},d={method:r,extrapolationValue:s,cropSize:a};return P.runKernel(uu,p,d)}var nW=L({cropAndResize_:tW});function aW(e){let t=E(e,\"image\",\"flipLeftRight\",\"float32\");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return P.runKernel(mu,n,{})}var rW=L({flipLeftRight_:aW});function sW(e){let t=E(e,\"image\",\"grayscaleToRGB\"),n=t.rank-1,a=t.shape[n];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(a===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);let r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,On(t,r)}var iW=L({grayscaleToRGB_:sW});function oW(e){let t=E(e,\"image\",\"RGBToGrayscale\"),n=t.rank-1,a=t.shape[n];A(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),A(a===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);let r=t.dtype,s=re(t,\"float32\"),i=je([.2989,.587,.114]),o;switch(t.rank){case 2:o=Zs(\"ij,j->i\",s,i);break;case 3:o=Zs(\"ijk,k->ij\",s,i);break;case 4:o=Zs(\"ijkl,l->ijk\",s,i);break;case 5:o=Zs(\"ijklm,m->ijkl\",s,i);break;case 6:o=Zs(\"ijklmn,n->ijklm\",s,i);break;default:throw new Error(\"Not a valid tensor rank.\")}return o=Gt(o,-1),re(o,r)}var lW=L({rgbToGrayscale_:oW});function uW(e,t,n=0,a=.5){let r=E(e,\"image\",\"rotateWithOffset\",\"float32\");A(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let s={image:r},i={radians:t,fillValue:n,center:a};return P.runKernel(Zu,s,i)}var pW=L({rotateWithOffset_:uW});function ap(e,t,n,a,r,s){a==null&&(a=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),A(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),A(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),A(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),A(t.rank===1,()=>\"scores must be a 1D tensor\"),A(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),A(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}function cW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=E(e,\"boxes\",\"nonMaxSuppression\",\"float32\"),i=E(t,\"scores\",\"nonMaxSuppression\",\"float32\"),o=ap(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return P.runKernel(_u,{boxes:s,scores:i},l)}var dW=L({nonMaxSuppression_:cW});function hW(e,t,n){let a=mW(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function mW(e,t,n){return gW(e,t,n||fW)}function fW(e,t){return e>t?1:e<t?-1:0}function gW(e,t,n){let a=0,r=e.length,s=0,i=!1;for(;a<r;){s=a+(r-a>>>1);let o=n(t,e[s]);o>0?a=s+1:(r=s,i=!o)}return i?a:-a-1}function ST(e,t,n,a,r){return Ww(e,t,n,a,r,0)}function NT(e,t,n,a,r,s){return Ww(e,t,n,a,r,0,!1,s,!0)}function TT(e,t,n,a,r,s){return Ww(e,t,n,a,r,s,!0)}function Ww(e,t,n,a,r,s,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>r&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(tI);let p=s>0?-.5/s:0,d=[],c=[];for(;d.length<n&&u.length>0;){let g=u.pop(),{score:b,boxIndex:y,suppressBeginIndex:x}=g;if(b<r)break;let v=!1;for(let I=d.length-1;I>=x;--I){let N=bW(e,y,d[I]);if(N>=a){v=!0;break}if(g.score=g.score*yW(a,p,N),g.score<=r)break}g.suppressBeginIndex=d.length,v||(g.score===b?(d.push(y),c.push(g.score)):g.score>r&&hW(u,g,tI))}let h=d.length,m=n-h;o&&m>0&&(d.push(...new Array(m).fill(0)),c.push(...new Array(m).fill(0)));let f={selectedIndices:d};return i&&(f.selectedScores=c),l&&(f.validOutputs=h),f}function bW(e,t,n){let a=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),s=Math.min(a[0],a[2]),i=Math.min(a[1],a[3]),o=Math.max(a[0],a[2]),l=Math.max(a[1],a[3]),u=Math.min(r[0],r[2]),p=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),h=(o-s)*(l-i),m=(d-u)*(c-p);if(h<=0||m<=0)return 0;let f=Math.max(s,u),g=Math.max(i,p),b=Math.min(o,d),y=Math.min(l,c),x=Math.max(b-f,0)*Math.max(y-g,0);return x/(h+m-x)}function yW(e,t,n){let a=Math.exp(t*n*n);return n<=e?a:0}function tI(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function xW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY){let s=E(e,\"boxes\",\"nonMaxSuppressionAsync\"),i=E(t,\"scores\",\"nonMaxSuppressionAsync\"),o=ap(s,i,n,a,r);n=o.maxOutputSize,a=o.iouThreshold,r=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],p=l[1],{selectedIndices:d}=ST(u,p,n,a,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),je(d,\"int32\")}var vW=xW;function wW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=E(e,\"boxes\",\"nonMaxSuppression\"),o=E(t,\"scores\",\"nonMaxSuppression\"),l=ap(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},p={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},d=P.runKernel(Fu,u,p);return{selectedIndices:d[0],selectedScores:d[1]}}var kW=L({nonMaxSuppressionWithScore_:wW});async function IW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=E(e,\"boxes\",\"nonMaxSuppressionAsync\"),o=E(t,\"scores\",\"nonMaxSuppressionAsync\"),l=ap(i,o,n,a,r,s);n=l.maxOutputSize,a=l.iouThreshold,r=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),p=u[0],d=u[1],{selectedIndices:c,selectedScores:h}=TT(p,d,n,a,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:je(c,\"int32\"),selectedScores:je(h)}}var SW=IW;function NW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=E(e,\"boxes\",\"nonMaxSuppression\"),o=E(t,\"scores\",\"nonMaxSuppression\"),l=ap(i,o,n,a,r,null),u=l.maxOutputSize,p=l.iouThreshold,d=l.scoreThreshold,c={boxes:i,scores:o},h={maxOutputSize:u,iouThreshold:p,scoreThreshold:d,padToMaxOutputSize:s},m=P.runKernel(Au,c,h);return{selectedIndices:m[0],validOutputs:m[1]}}var TW=L({nonMaxSuppressionPadded_:NW});async function CW(e,t,n,a=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=E(e,\"boxes\",\"nonMaxSuppressionAsync\"),o=E(t,\"scores\",\"nonMaxSuppressionAsync\"),l=ap(i,o,n,a,r,null),u=l.maxOutputSize,p=l.iouThreshold,d=l.scoreThreshold,[c,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:f}=NT(c,h,u,p,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:je(m,\"int32\"),validOutputs:xe(f,\"int32\")}}var EW=CW;function _W(e,t,n=!1,a=!1){let r=E(e,\"images\",\"resizeBilinear\");A(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(a===!1||n===!1,()=>\"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.\");let s=r,i=!1;r.rank===3&&(i=!0,s=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=P.runKernel(To,o,l);return i?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var CT=L({resizeBilinear_:_W});function AW(e,t,n=!1,a=!1){let r=E(e,\"images\",\"resizeNearestNeighbor\");A(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(r.dtype===\"float32\"||r.dtype===\"int32\",()=>\"`images` must have `int32` or `float32` as dtype\"),A(a===!1||n===!1,()=>\"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.\");let s=r,i=!1;r.rank===3&&(i=!0,s=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:a,size:t},u=P.runKernel(No,o,l);return i?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var ET=L({resizeNearestNeighbor_:AW});function FW(e,t=\"binary\",n=!1,a=.5){let r=E(e,\"image\",\"threshold\"),s=.2989,i=.587,o=.114,l=r.shape[0]*r.shape[1],u=z(je([a]),255),p,d,c,h;if(A(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),A(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),A(r.dtype===\"int32\"||r.dtype===\"float32\",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),A(t===\"otsu\"||t===\"binary\",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[p,d,c]=Ln(r,[1,1,1],-1);let f=z(p,s),g=z(d,i),b=z(c,o);h=X(X(f,g),b)}else h=e;if(t===\"otsu\"){let f=Yv(re(Zm(h),\"int32\"),bn([]),256);u=$W(f,l)}let m=n?Cs(h,u):Cn(h,u);return re(z(m,255),\"int32\")}function $W(e,t){let n=je([-1]),a=je([0]),r=je([0]),s,i,o,l,u,p;for(let d=0;d<e.size-1;d++){s=Ve(e,0,d+1),i=Ve(e,d+1),u=he(fe(s),t),p=he(fe(i),t);let c=fe(z(s,gi(0,s.size)));o=he(c,fe(s));let h=yn(i.shape,s.size),m=X(gi(0,i.size),h),f=z(i,m);l=he(fe(f),fe(i));let g=pe(o,l),b=pe(o,l),y=z(u,p);r=z(z(y,g),b);let x=Cn(r,a);a=nn(x,r,a),n=nn(x,je([d]),n)}return n}var DW=L({threshold_:FW});function RW(e,t,n=\"nearest\",a=\"constant\",r=0,s){let i=E(e,\"image\",\"transform\",\"float32\"),o=E(t,\"transforms\",\"transform\",\"float32\");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>\"Error in transform: Input transform should be batch x 8 or 1 x 8\"),A(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},u={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return P.runKernel(Ku,l,u)}var MW=L({transform_:RW});function OW(e,t,n){let a=E(e,\"a\",\"bandPart\");A(a.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${a.rank}.`);let r=a.shape,[s,i]=a.shape.slice(-2),o,l;typeof t==\"number\"?(A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=E(t<0?s:t,\"numLower\",\"bandPart\")):(A(t.dtype===\"int32\",()=>\"bandPart(): numLower's dtype must be an int32.\"),o=nn(Pl(t,0),s,ds(t,s))),typeof n==\"number\"?(A(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),A(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=E(n<0?i:n,\"numUpper\",\"bandPart\")):(A(n.dtype===\"int32\",()=>\"bandPart(): numUpper's dtype must be an int32.\"),l=nn(Pl(n,0),i,ds(n,i)));let u=W(gi(0,s,1,\"int32\"),[-1,1]),p=gi(0,i,1,\"int32\"),d=pe(u,p),c=_a(Cs(d,o),$r(d,yt(l))),h=It([s,i],a.dtype);return W(At(dt(W(a,[-1,s,i])).map(m=>nn(c,m,h))),r)}var PW=L({bandPart_:OW});function LW(e){let t;if(Array.isArray(e)){t=!1,A(e!=null&&e.length>0,()=>\"Gram-Schmidt process: input must not be null, undefined, or empty\");let r=e[0].shape[0];for(let s=1;s<e.length;++s)A(e[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`)}else t=!0,e=Ln(e,e.shape[0],0).map(r=>As(r,[0]));A(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],a=e;for(let r=0;r<e.length;++r)n.push(P.tidy(()=>{let s=a[r];if(r>0)for(let i=0;i<r;++i){let o=z(fe(z(n[i],s)),n[i]);s=pe(s,o)}return he(s,ep(s,\"euclidean\"))}));return t?At(n,0):n}var zW=L({gramSchmidt_:LW});function WW(e,t=!1){if(A(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return nI(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),a=dt(W(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach(l=>{let[u,p]=nI(l,t);r.push(u),s.push(p)});let i=W(At(r,0),e.shape),o=W(At(s,0),e.shape);return[i,o]}}function nI(e,t=!1){return P.tidy(()=>{A(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],a=e.shape[1],r=Gm(n),s=sr(e),i=Ea([[1]],[1,1]),o=sr(i),l=n>=a?a:n;for(let u=0;u<l;++u){let p=s,d=o,c=r;[o,s,r]=P.tidy(()=>{let h=Ve(s,[u,u],[n-u,1]),m=ep(h),f=Ve(s,[u,u],[1,1]),g=nn(Cn(f,0),Ea([[-1]]),Ea([[1]])),b=pe(f,z(g,m)),y=he(h,b);y.shape[0]===1?o=sr(i):o=et([i,Ve(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let x=yt(he($e(g,b),m)),v=Ve(s,[u,0],[n-u,a]),I=z(x,o),N=De(o);if(u===0)s=pe(v,$e(I,$e(N,v)));else{let F=pe(v,$e(I,$e(N,v)));s=et([Ve(s,[0,0],[u,a]),F],0)}let C=De(I),_=Ve(r,[0,u],[n,r.shape[1]-u]);if(u===0)r=pe(_,$e($e(_,o),C));else{let F=pe(_,$e($e(_,o),C));r=et([Ve(r,[0,0],[n,u]),F],1)}return[o,s,r]}),Ee([p,d,c])}return!t&&n>a&&(r=Ve(r,[0,0],[n,a]),s=Ve(s,[0,0],[a,a])),[r,s]})}var BW=L({qr_:WW}),kn;(function(e){e[e.NONE=0]=\"NONE\",e[e.MEAN=1]=\"MEAN\",e[e.SUM=2]=\"SUM\",e[e.SUM_BY_NONZERO_WEIGHTS=3]=\"SUM_BY_NONZERO_WEIGHTS\"})(kn||(kn={}));function VW(e,t,n=kn.SUM_BY_NONZERO_WEIGHTS){let a=E(e,\"losses\",\"computeWeightedLoss\"),r=null;t!=null&&(r=E(t,\"weights\",\"computeWeightedLoss\"));let s=r==null?a:z(a,r);if(n===kn.NONE)return s;if(n===kn.SUM)return fe(s);if(n===kn.MEAN){if(r==null)return Ct(s);{let i=a.size/r.size,o=he(fe(s),fe(r));return i>1?he(o,xe(i)):o}}if(n===kn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return he(fe(s),xe(a.size));{let i=z(r,Pn(a.shape)),o=re(fe(fi(i,xe(0))),\"float32\");return he(fe(s),o)}}throw Error(`Unknown reduction: ${n}`)}var Dr=L({computeWeightedLoss_:VW});function UW(e,t,n,a=kn.SUM_BY_NONZERO_WEIGHTS){let r=E(e,\"labels\",\"absoluteDifference\"),s=E(t,\"predictions\",\"absoluteDifference\"),i=null;n!=null&&(i=E(n,\"weights\",\"absoluteDifference\")),Nn(r.shape,s.shape,\"Error in absoluteDifference: \");let o=Lt(pe(r,s));return Dr(o,i,a)}var GW=L({absoluteDifference_:UW});function HW(e,t,n,a,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"labels\",\"cosineDistance\"),i=E(t,\"predictions\",\"cosineDistance\"),o=null;a!=null&&(o=E(a,\"weights\",\"cosineDistance\")),Nn(s.shape,i.shape,\"Error in cosineDistance: \");let l=xe(1),u=pe(l,fe(z(s,i),n,!0));return Dr(u,o,r)}var jW=L({cosineDistance_:HW});function qW(e,t,n,a=kn.SUM_BY_NONZERO_WEIGHTS){let r=E(e,\"labels\",\"hingeLoss\"),s=E(t,\"predictions\",\"hingeLoss\"),i=null;n!=null&&(i=E(n,\"weights\",\"hingeLoss\")),Nn(r.shape,s.shape,\"Error in hingeLoss: \");let o=xe(1);r=pe(z(xe(2),r),o);let l=Ke(pe(o,z(r,s)));return Dr(l,i,a)}var KW=L({hingeLoss_:qW});function XW(e,t,n,a=1,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"labels\",\"huberLoss\"),i=E(t,\"predictions\",\"huberLoss\"),o=null;n!=null&&(o=E(n,\"weights\",\"huberLoss\")),Nn(s.shape,i.shape,\"Error in huberLoss: \");let l=xe(a),u=Lt(pe(i,s)),p=ds(u,l),d=pe(u,p),c=X(z(xe(.5),pt(p)),z(l,d));return Dr(c,o,r)}var YW=L({huberLoss_:XW});function ZW(e,t,n,a=1e-7,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"labels\",\"logLoss\"),i=E(t,\"predictions\",\"logLoss\"),o=null;n!=null&&(o=E(n,\"weights\",\"logLoss\")),Nn(s.shape,i.shape,\"Error in logLoss: \");let l=xe(1),u=xe(a),p=yt(z(s,Qn(X(i,u)))),d=z(pe(l,s),Qn(X(pe(l,i),u))),c=pe(p,d);return Dr(c,o,r)}var JW=L({logLoss_:ZW});function QW(e,t,n,a=kn.SUM_BY_NONZERO_WEIGHTS){let r=E(e,\"labels\",\"meanSquaredError\"),s=E(t,\"predictions\",\"meanSquaredError\"),i=null;n!=null&&(i=E(n,\"weights\",\"meanSquaredError\")),Nn(r.shape,s.shape,\"Error in meanSquaredError: \");let o=rf(r,s);return Dr(o,i,a)}var eB=L({meanSquaredError_:QW});function tB(e,t){let n=E(e,\"labels\",\"sigmoidCrossEntropyWithLogits\"),a=E(t,\"logits\",\"sigmoidCrossEntropyWithLogits\");Nn(n.shape,a.shape,\"Error in sigmoidCrossEntropyWithLogits: \");let r=Ke(a),s=z(a,n),i=pd(dn(yt(Lt(a))));return X(pe(r,s),i)}function nB(e,t,n,a=0,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"multiClassLabels\",\"sigmoidCrossEntropy\"),i=E(t,\"logits\",\"sigmoidCrossEntropy\"),o=null;if(n!=null&&(o=E(n,\"weights\",\"sigmoidCrossEntropy\")),Nn(s.shape,i.shape,\"Error in sigmoidCrossEntropy: \"),a>0){let u=xe(a),p=xe(1),d=xe(.5);s=X(z(s,pe(p,u)),z(d,u))}let l=tB(s,i);return Dr(l,o,r)}var aB=L({sigmoidCrossEntropy_:nB});function rB(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return pr((a,r,s)=>{let i=cd(r,[n],!0),o=pe(re(r,\"float32\"),i);s([a,o]);let l=yt(z(o,a));return{value:fe(l,[n]),gradFunc:(u,p)=>{let[d,c]=p,h=mi(u.shape,[n]);return[z(W(u,h),pe(re(d,\"float32\"),dn(c))),z(W(u,h),pe(dn(c),re(d,\"float32\")))]}}})(e,t)}function sB(e,t,n,a=0,r=kn.SUM_BY_NONZERO_WEIGHTS){let s=E(e,\"onehotLabels\",\"softmaxCrossEntropy\"),i=E(t,\"logits\",\"softmaxCrossEntropy\"),o=null;if(n!=null&&(o=E(n,\"weights\",\"softmaxCrossEntropy\")),Nn(s.shape,i.shape,\"Error in softmaxCrossEntropy: \"),a>0){let u=xe(a),p=xe(1),d=xe(s.shape[1]);s=X(z(s,pe(p,u)),he(u,d))}let l=rB(s,i);return Dr(l,o,r)}var iB=L({softmaxCrossEntropy_:sB});function oB(e,t,n,a){let r=E(e,\"indices\",\"sparseFillEmptyRows\",\"int32\"),s=E(t,\"values\",\"sparseFillEmptyRows\"),i=E(n,\"denseShape\",\"sparseFillEmptyRows\",\"int32\"),o=E(a,\"defaultValue\",\"sparseFillEmptyRows\",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape\n        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:r,values:s,denseShape:i,defaultValue:o},u=P.runKernel(Gc,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var lB=L({sparseFillEmptyRows_:oB});function uB(e,t,n){let a=E(e,\"inputIndices\",\"sparseReshape\",\"int32\"),r=E(t,\"inputShape\",\"sparseReshape\",\"int32\"),s=E(n,\"newShape\",\"sparseReshape\",\"int32\");if(a.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape\n        ${a.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:a,inputShape:r,newShape:s},o=P.runKernel(Gu,i);return{outputIndices:o[0],outputShape:o[1]}}var pB=L({sparseReshape_:uB});function cB(e,t,n){let a=E(e,\"data\",\"sparseSegmentMean\"),r=E(t,\"indices\",\"sparseSegmentMean\",\"int32\"),s=E(n,\"segmentIds\",\"sparseSegmentMean\",\"int32\");if(a.rank<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return P.runKernel(Hc,i)}var dB=L({sparseSegmentMean_:cB});function hB(e,t,n){let a=E(e,\"data\",\"sparseSegmentSum\"),r=E(t,\"indices\",\"sparseSegmentSum\",\"int32\"),s=E(n,\"segmentIds\",\"sparseSegmentSum\",\"int32\");if(a.rank<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:a,indices:r,segmentIds:s};return P.runKernel(jc,i)}var mB=L({sparseSegmentSum_:hB});function fB(e,t,n,a,r,s,i,o){let l=E(e,\"data\",\"stringNGrams\",\"string\");if(l.dtype!==\"string\")throw new Error(\"Data must be of datatype string\");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=E(t,\"dataSplits\",\"stringNGrams\");if(u.dtype!==\"int32\")throw new Error(\"Data splits must be of datatype int32\");let p={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},c=P.runKernel(Xc,d,p);return{nGrams:c[0],nGramsSplits:c[1]}}var gB=L({stringNGrams_:fB});function bB(e,t,n=!0){let a=E(e,\"input\",\"stringSplit\",\"string\"),r=E(t,\"delimiter\",\"stringSplit\",\"string\");if(a.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);let s={skipEmpty:n},i={input:a,delimiter:r},o=P.runKernel(Yc,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var yB=L({stringSplit_:bB});function xB(e,t){let n=E(e,\"input\",\"stringToHashBucketFast\",\"string\"),a={numBuckets:t};if(t<=0)throw new Error(\"Number of buckets must be at least 1\");let r={input:n};return P.runKernel(Zc,r,a)}var vB=L({stringToHashBucketFast_:xB});function wB(e,t,n,a=!0){let r=E(e,\"input\",\"staticRegexReplace\",\"string\"),s={pattern:t,rewrite:n,replaceGlobal:a};return P.runKernel(Kc,{x:r},s)}var kB=L({staticRegexReplace_:wB}),_T={fft:bd,ifft:Bl,rfft:yd,irfft:af},AT={hammingWindow:Yz,hannWindow:kT,frame:IT,stft:eW},Zn={flipLeftRight:rW,grayscaleToRGB:iW,resizeNearestNeighbor:ET,resizeBilinear:CT,rgbToGrayscale:lW,rotateWithOffset:pW,cropAndResize:nW,nonMaxSuppression:dW,nonMaxSuppressionAsync:vW,nonMaxSuppressionWithScore:kW,nonMaxSuppressionWithScoreAsync:SW,nonMaxSuppressionPadded:TW,nonMaxSuppressionPaddedAsync:EW,threshold:DW,transform:MW},Bw={bandPart:PW,gramSchmidt:zW,qr:BW},FT={absoluteDifference:GW,computeWeightedLoss:Dr,cosineDistance:jW,hingeLoss:KW,huberLoss:YW,logLoss:JW,meanSquaredError:eB,sigmoidCrossEntropy:aB,softmaxCrossEntropy:iB},$T={sparseFillEmptyRows:lB,sparseReshape:pB,sparseSegmentMean:dB,sparseSegmentSum:mB},DT={stringNGrams:gB,stringSplit:yB,stringToHashBucketFast:vB,staticRegexReplace:kB},ne={};_e(ne,{Serializable:()=>RT,SerializationMap:()=>MT,getRegisteredName:()=>SB,registerClass:()=>OT});var IB=new Map,Mx=new Map,RT=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},MT=class Tl{constructor(){this.classNameMap={}}static getMap(){return Tl.instance==null&&(Tl.instance=new Tl),Tl.instance}static register(t){Tl.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function OT(e,t,n){A(e.className!=null,()=>\"Class being registered does not have the static className property defined.\"),A(typeof e.className==\"string\",()=>\"className is required to be a string, but got type \"+typeof e.className),A(e.className.length>0,()=>\"Class being registered has an empty-string as its className, which is disallowed.\"),typeof t==\"undefined\"&&(t=\"Custom\"),typeof n==\"undefined\"&&(n=e.className);let a=n,r=t+\">\"+a;return MT.register(e),IB.set(r,e),Mx.set(e,r),e}function SB(e){return Mx.has(e)?Mx.get(e):e.className}var Rr=class extends RT{minimize(e,t=!1,n){let{value:a,grads:r}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:r[i.name]}));this.applyGradients(s)}else this.applyGradients(r);return Ee(r),t?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return ON(e,t)}dispose(){this.iterations_!=null&&Ee(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:\"iter\",tensor:xe(this.iterations_,\"int32\")}}async getWeights(){throw new Error(\"getWeights() is not implemented for this optimizer yet.\")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Rr,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var Vw=class extends Rr{static get className(){return\"Adadelta\"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=P.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t],r=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:O(()=>qe(a).variable(r))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:O(()=>qe(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;O(()=>{let l=X(z(i,this.rho),z(pt(s),1-this.rho)),u=z(he(rn(X(o,this.epsilon)),rn(X(i,this.epsilon))),s),p=X(z(o,this.rho),z(pt(u),1-this.rho));i.assign(l),o.assign(p);let d=X(z(u,-this.learningRate),a);a.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ee(this.accumulatedGrads.map(e=>e.variable)),Ee(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},Uw=class extends Rr{static get className(){return\"Adagrad\"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:O(()=>yn(a.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=this.accumulatedGrads[n].variable;O(()=>{let i=X(s,pt(r));s.assign(i);let o=X(z(he(r,rn(X(i,P.backend.epsilon()))),-this.learningRate),a);a.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ee(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},Gw=class extends Rr{static get className(){return\"Adam\"}constructor(e,t,n,a=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],O(()=>{this.accBeta1=xe(t).variable(),this.accBeta2=xe(n).variable()}),a==null&&(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);O(()=>{let n=pe(1,this.accBeta1),a=pe(1,this.accBeta2);t.forEach((r,s)=>{let i=P.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:O(()=>qe(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${r}/v`,variable:O(()=>qe(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,p=this.accumulatedSecondMoment[s].variable,d=X(z(u,this.beta1),z(l,1-this.beta1)),c=X(z(p,this.beta2),z(pt(l),1-this.beta2)),h=he(d,n),m=he(c,a);u.assign(d),p.assign(c);let f=X(z(he(h,X(rn(m),this.epsilon)),-this.learningRate),i);i.assign(f)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ee(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),O(()=>{this.accBeta1.assign(ur(this.beta1,this.iterations_+1)),this.accBeta2.assign(ur(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Hw=class extends Rr{static get className(){return\"Adamax\"}constructor(e,t,n,a=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],O(()=>{this.iteration=xe(0).variable(),this.accBeta1=xe(t).variable()}),a==null&&(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);O(()=>{let n=pe(1,this.accBeta1),a=he(-this.learningRate,X(z(this.iteration,this.decay),1));t.forEach((r,s)=>{let i=P.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:qe(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${r}/v`,variable:qe(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[r];if(l==null)return;let u=this.accumulatedFirstMoment[s].variable,p=this.accumulatedWeightedInfNorm[s].variable,d=X(z(u,this.beta1),z(l,1-this.beta1)),c=z(p,this.beta2),h=Lt(l),m=hr(c,h);u.assign(d),p.assign(m);let f=X(z(he(a,n),he(d,X(m,this.epsilon))),i);i.assign(f)}),this.iteration.assign(X(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ee(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error(\"getWeights() is not implemented for Adamax yet.\")}async setWeights(e){throw new Error(\"setWeights() is not implemented for Adamax yet.\")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},ff=class extends Rr{static get className(){return\"SGD\"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let r=P.registeredVariables[t];O(()=>{let s=X(z(this.c,a),r);r.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ht(xe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error(\"SGD optimizer does not have settable weights.\")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},jw=class extends ff{static get className(){return\"Momentum\"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=xe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:O(()=>qe(a).variable(!1))});let r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&O(()=>{let i,o=X(z(this.m,r),s);this.useNesterov?i=X(z(this.c,X(s,z(o,this.m))),a):i=X(z(this.c,o),a),r.assign(o),a.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ee(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},qw=class extends Rr{static get className(){return\"RMSProp\"}constructor(e,t=.9,n=0,a=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,a==null&&(this.epsilon=P.backend.epsilon()),e==null)throw new Error(\"learningRate for RMSPropOptimizer must be defined.\")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let a=P.registeredVariables[t],r=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:O(()=>qe(a).variable(r))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:O(()=>qe(a).variable(r))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:O(()=>qe(a).variable(r))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;O(()=>{let l=X(z(i,this.decay),z(pt(s),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,p=X(z(u,this.decay),z(s,1-this.decay)),d=he(z(s,this.learningRate),rn(pe(l,X(pt(p),this.epsilon)))),c=X(z(o,this.momentum),d);i.assign(l),u.assign(p),o.assign(c);let h=pe(a,c);a.assign(h)}else{let u=X(z(i,this.decay),z(pt(s),1-this.decay)),p=X(z(o,this.momentum),he(z(s,this.learningRate),rn(X(u,this.epsilon))));i.assign(u),o.assign(p);let d=pe(a,p);a.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ee(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ee(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ee(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(a=>({originalName:a.name,variable:a.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},NB=[Vw,Uw,Gw,Hw,jw,qw,ff];function TB(){for(let e of NB)OT(e)}var jt={};_e(jt,{CompositeArrayBuffer:()=>Fr,browserFiles:()=>DB,browserHTTPRequest:()=>zB,concatenateArrayBuffers:()=>hO,copyModel:()=>MO,decodeWeights:()=>lN,decodeWeightsStream:()=>pN,encodeWeights:()=>oO,fromMemory:()=>BB,fromMemorySync:()=>BT,getLoadHandlers:()=>wO,getModelArtifactsForJSON:()=>Mv,getModelArtifactsForJSONSync:()=>dN,getModelArtifactsInfoForJSON:()=>rd,getSaveHandlers:()=>vO,getWeightSpecs:()=>_x,http:()=>Xw,isHTTPScheme:()=>Px,listModels:()=>DO,loadWeights:()=>MB,moveModel:()=>OO,registerLoadRouter:()=>xO,registerSaveRouter:()=>yO,removeModel:()=>RO,weightsLoaderFactory:()=>LT,withSaveHandler:()=>VB,withSaveHandlerSync:()=>UB});var CB=\"model\",EB=\".json\",_B=\".weights.bin\";function aI(e){return new Promise(t=>setTimeout(t)).then(e)}var Yh=class Ox{constructor(t){if(!G().getBool(\"IS_BROWSER\"))throw new Error(\"browserDownloads() cannot proceed because the current environment is not a browser.\");t.startsWith(Ox.URL_SCHEME)&&(t=t.slice(Ox.URL_SCHEME.length)),(t==null||t.length===0)&&(t=CB),this.modelJsonFileName=t+EB,this.weightDataFileName=t+_B}async save(t){if(typeof document==\"undefined\")throw new Error(\"Browser downloads are not supported in this environment since `document` is not present\");let n=Fr.join(t.weightData),a=window.URL.createObjectURL(new Blob([n],{type:\"application/octet-stream\"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserDownloads.save() does not support saving model topology in binary formats yet.\");{let r=[{paths:[\"./\"+this.weightDataFileName],weights:t.weightSpecs}],s=cN(t,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:\"application/json\"})),o=this.modelJsonAnchor==null?document.createElement(\"a\"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await aI(()=>o.dispatchEvent(new MouseEvent(\"click\"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement(\"a\"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=a,await aI(()=>l.dispatchEvent(new MouseEvent(\"click\")))}return{modelArtifactsInfo:rd(t)}}}};Yh.URL_SCHEME=\"downloads://\";var AB=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=a=>{let r=JSON.parse(a.target.result),s=r.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=Mv(r,o=>this.loadWeights(o));e(i)},n.onerror=a=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let a=this.checkManifestAndWeightFiles(e),r=n.map(s=>this.loadWeightsFile(s,a[s]));return Promise.all(r).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,a)=>{let r=new FileReader;r.onload=s=>{let i=s.target.result;n(i)},r.onerror=s=>a(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(r=>eI(r.name)),a={};for(let r of e)r.paths.forEach(s=>{let i=eI(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);a[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}},FB=e=>G().getBool(\"IS_BROWSER\")&&!Array.isArray(e)&&e.startsWith(Yh.URL_SCHEME)?$B(e.slice(Yh.URL_SCHEME.length)):null;ga.registerSaveRouter(FB);function $B(e=\"model\"){return new Yh(e)}function DB(e){return new AB(e)}function rI(e,t,n,a){i(e),n=n==null?0:n,a=a==null?1:a,o(n,a);let r=0,s=l=>(l.then(u=>{let p=n+ ++r/e.length*(a-n);return t(p),u}),l);function i(l){A(l!=null&&Array.isArray(l)&&l.length>0,()=>\"promises must be a none empty array\")}function o(l,u){A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),A(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(s))}async function PT(e,t){t==null&&(t={});let n=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,a=e.map(s=>n(s,t.requestInit,{isBinary:!0})),r=(t.onProgress==null?await Promise.all(a):await rI(a,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(r):await rI(r,t.onProgress,.5,1)}function RB(e,t){var n;let a=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,r=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;r<e.length;){s||(s=(await a(e[r],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=await s.read();if(l){r++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}i.enqueue(u);return}i.close()}})}async function MB(e,t=\"\",n,a){return LT(r=>PT(r,{requestInit:a}))(e,t,n)}function LT(e){return async(t,n=\"\",a)=>{let r=t.map(()=>!1),s={},i=a!=null?a.map(()=>!1):[],o=[];if(t.forEach((h,m)=>{let f=0;h.weights.forEach(g=>{let b=\"quantization\"in g?g.quantization.dtype:g.dtype,y=ui[b]*ot(g.shape),x=()=>{r[m]=!0,s[m]==null&&(s[m]=[]),s[m].push({manifestEntry:g,groupOffset:f,sizeBytes:y})};a!=null?a.forEach((v,I)=>{v===g.name&&(x(),i[I]=!0)}):x(),o.push(g.name),f+=y})}),!i.every(h=>h)){let h=a.filter((m,f)=>!i[f]);throw new Error(`Could not find weights in manifest with names: ${h.join(\", \")}. \nManifest JSON has weights with names: ${o.join(\", \")}.`)}let l=r.reduce((h,m,f)=>(m&&h.push(f),h),[]),u=[];l.forEach(h=>{t[h].paths.forEach(m=>{let f=n+(n.endsWith(\"/\")?\"\":\"/\")+m;u.push(f)})});let p=await e(u),d={},c=0;return l.forEach(h=>{let m=t[h].paths.length,f=new Fr(p.slice(c,c+m));s[h].forEach(g=>{let b=f.slice(g.groupOffset,g.groupOffset+g.sizeBytes),y=lN(b,[g.manifestEntry]);for(let x in y)d[x]=y[x]}),c+=m}),d}}var OB=\"application/octet-stream\",PB=\"application/json\",Kw=class{constructor(e,t){if(this.DEFAULT_METHOD=\"POST\",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(A(typeof t.fetchFunc==\"function\",()=>\"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\"),this.fetch=t.fetchFunc):this.fetch=G().platform.fetch,A(e!=null&&e.length>0,()=>\"URL path for http must not be null, undefined or empty.\"),Array.isArray(e)&&A(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:[\"./model.weights.bin\"],weights:e.weightSpecs}],a=cN(e,n);if(t.body.append(\"model.json\",new Blob([JSON.stringify(a)],{type:PB}),\"model.json\"),e.weightData!=null){let s=Fr.join(e.weightData);t.body.append(\"model.weights.bin\",new Blob([s],{type:OB}),\"model.weights.bin\")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:rd(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(r){let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(\".pb\")?s+=\" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.\":s+=\" Please make sure the server is serving valid JSON for this request.\",new Error(s)}let n=t.modelTopology,a=t.weightsManifest;if(n==null&&a==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return Mv(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=_x(e.weightsManifest),a=()=>RB(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:a})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=LB(t),r=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(r+l+a);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=_x(e),a=await PT(t,this.loadOptions);return[n,a]}};Kw.URL_SCHEME_REGEX=/^https?:\\/\\//;function LB(e){let t=e.lastIndexOf(\"/\"),n=e.lastIndexOf(\"?\"),a=e.substring(0,t),r=n>t?e.substring(n):\"\";return[a+\"/\",r]}function Px(e){return e.match(Kw.URL_SCHEME_REGEX)!=null}var zT=(e,t)=>{if(typeof fetch==\"undefined\"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(a=>Px(a)):n=Px(e),n)return Xw(e,t)}return null};ga.registerSaveRouter(zT);ga.registerLoadRouter(zT);function Xw(e,t){return new Kw(e,t)}function zB(e,t){return Xw(e,t)}var lx=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},WT=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},WB=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function BB(e,t,n,a){let r=arguments;return new WB(BT(...r))}function BT(e,t,n,a){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new lx(e):(console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"),new lx({modelTopology:e})):(console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"),new lx({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a}))}function VB(e){return new WT(e)}function UB(e){return new WT(e)}var VT={};_e(VT,{confusionMatrix:()=>HB});function GB(e,t,n){let a=E(e,\"labels\",\"confusionMatrix\"),r=E(t,\"predictions\",\"confusionMatrix\");A(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),A(a.rank===1,()=>`Expected the rank of labels to be 1, but got ${a.rank}`),A(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),A(a.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),A(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Ll(re(a,\"int32\"),n),i=Ll(re(r,\"int32\"),n),o=De(s),l=$e(o,i);return re(l,\"int32\")}var HB=L({confusionMatrix_:GB}),qo={};_e(qo,{draw:()=>QB,fromPixels:()=>e4,fromPixelsAsync:()=>YB,toPixels:()=>JB});var js,sI=!1;function UT(e,t=3){if(t>4)throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");if(e==null)throw new Error(\"pixels passed to tf.browser.fromPixels() can not be null\");let n=!1,a=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData!=\"undefined\"&&e instanceof ImageData)a=!0;else if(typeof HTMLVideoElement!=\"undefined\"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement!=\"undefined\"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap!=\"undefined\"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(fc(Hh,P.backendName)!=null){let c={pixels:e},h={numChannels:t};return P.runKernel(Hh,c,h)}let[l,u]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height],p;if(i)p=e.getContext(\"2d\").getImageData(0,0,l,u).data;else if(a||n)p=e.data;else if(s||r||o){if(js==null)if(typeof document==\"undefined\")if(typeof OffscreenCanvas!=\"undefined\"&&typeof OffscreenCanvasRenderingContext2D!=\"undefined\")js=new OffscreenCanvas(1,1).getContext(\"2d\");else throw new Error(\"Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.\");else js=document.createElement(\"canvas\").getContext(\"2d\",{willReadFrequently:!0});js.canvas.width=l,js.canvas.height=u,js.drawImage(e,0,0,l,u),p=js.getImageData(0,0,l,u).data}let d;if(t===4)d=new Int32Array(p);else{let c=l*u;d=new Int32Array(c*t);for(let h=0;h<c;h++)for(let m=0;m<t;++m)d[h*t+m]=p[h*4+m]}return xd(d,[u,l,t],\"int32\")}function jB(e){return e!=null&&e.data instanceof Uint8Array}function qB(){return typeof window!=\"undefined\"&&typeof ImageBitmap!=\"undefined\"&&window.hasOwnProperty(\"createImageBitmap\")}function KB(e){return e!=null&&e.width!==0&&e.height!==0}function XB(e){return qB()&&!(e instanceof ImageBitmap)&&KB(e)&&!jB(e)}async function YB(e,t=3){let n=null;if(G().getBool(\"WRAP_TO_IMAGEBITMAP\")&&XB(e)){let a;try{a=await createImageBitmap(e,{premultiplyAlpha:\"none\"})}catch(r){a=null}a!=null&&a.width===e.width&&a.height===e.height?n=a:n=e}else n=e;return UT(n,t)}function GT(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!==\"float32\"&&e.dtype!==\"int32\")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function ZB(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function JB(e,t){let n=E(e,\"img\",\"toPixels\");if(!(e instanceof Ce)){let u=n;n=re(u,\"int32\"),u.dispose()}GT(n);let[a,r]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype===\"float32\"?255:1,l=new Uint8ClampedArray(r*a*4);for(let u=0;u<a*r;++u){let p=[0,0,0,255];for(let c=0;c<s;c++){let h=i[u*s+c];if(n.dtype===\"float32\"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(n.dtype===\"int32\"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);s===1?(p[0]=h*o,p[1]=h*o,p[2]=h*o):p[c]=h*o}let d=u*4;l[d+0]=Math.round(p[0]),l[d+1]=Math.round(p[1]),l[d+2]=Math.round(p[2]),l[d+3]=Math.round(p[3])}if(t!=null){sI||fc(Nm,P.backendName)!=null&&(console.warn(\"tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead.\"),sI=!0),t.width=r,t.height=a;let u=t.getContext(\"2d\"),p=new ImageData(l,r,a);u.putImageData(p,0,0)}return n!==e&&n.dispose(),l}function QB(e,t,n){let a=E(e,\"img\",\"draw\");if(!(e instanceof Ce)){let i=a;a=re(i,\"int32\"),i.dispose()}GT(a),ZB(n==null?void 0:n.imageOptions);let r={image:a},s={canvas:t,options:n};P.runKernel(Nm,r,s)}var e4=L({fromPixels_:UT}),Yw={};_e(Yw,{prepareAndValidate:()=>HT});function HT(e,t){let n=e.shape.length,a=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(a<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);if(t.dtype!==\"int32\")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[a-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a-1]} vs. ${n}`);if(ot(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let r=t.shape,s=r[r.length-1],i=1;for(let d=0;d<r.length-1;++d)i*=r[d];let o=e.shape,l=r.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);let p=[...Xl(e.shape).map(d=>d/u),1].slice(0,s);return[l,i,u,p]}var Kt={};_e(Kt,{assertParamsValid:()=>n4,computeFlatOffset:()=>o4,computeOutShape:()=>r4,getNormalizedAxes:()=>s4,isSliceContinous:()=>i4,maskToAxes:()=>a4,parseSliceParams:()=>e2,sliceInfo:()=>l4,startForAxis:()=>JT,startIndicesWithElidedDims:()=>XT,stopForAxis:()=>QT,stopIndicesWithElidedDims:()=>YT,stridesForAxis:()=>ZT,stridesWithElidedDims:()=>jT});var Lx=-2,t4=-1;function n4(e,t,n){let a=e.shape.length;A(a===t.length,()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`),A(a===n.length,()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);for(let r=0;r<a;++r)A(t[r]+n[r]<=e.shape[r],()=>`Error in slice${a}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function a4(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function r4(e,t,n){let a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function jT(e,t,n,a){let r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)s===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function qT(e,t,n){return n<=e?n:n-(t-1)}function KT(e,t){let n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function s4(e,t,n,a,r,s,i,o,l){let u=e.length,p=new Array(u),d=new Array(u),c=new Array(u);if(t.length&&n>0){let h=t[0],m=n+1;p=XT(i,h,m,a,e),d=YT(o,h,m,r,e),c=jT(s,h,m,e)}else for(let h=0;h<u;h++)p[h]=JT(i,a,s,e,h,l),d[h]=QT(o,r,s,e,h,l),c[h]=ZT(s,h,l);return{begin:p,end:d,strides:c}}function XT(e,t,n,a,r){let s=[...r],i=KT(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=qT(t,n,o),u=a[l];e&1<<l&&(u=0),s[o]=u}return s}function YT(e,t,n,a,r){let s=[...r],i=KT(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=qT(t,n,o),u=a[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),s[o]=u}for(let o=0;o<s.length;o++){let l=r[o];s[o]<0&&(s[o]+=l),s[o]=hc(0,s[o],r[o])}return s}function ZT(e,t,n){let a=e[t];return(n&1<<t||a==null)&&(a=1),a}function JT(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),i=hc(0,i,l-1),i}function QT(e,t,n,a,r,s){let i=t[r],o=n[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=a[r];return i<0&&(i+=l),o>0?i=hc(0,i,l):i=hc(-1,i,l-1),i}function i4(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function o4(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function e2(e,t,n){let a,r=e.shape.length;typeof t==\"number\"?a=[t,...new Array(r-1).fill(0)]:t.length<r?a=t.concat(new Array(r-t.length).fill(0)):a=t.slice(),a.forEach(i=>{A(i!==-1,()=>\"slice() does not support negative begin indexing.\")});let s;return n==null?s=new Array(r).fill(-1):typeof n==\"number\"?s=[n,...new Array(r-1).fill(-1)]:n.length<r?s=n.concat(new Array(r-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-a[o])),[a,s]}function l4(e,t,n,a,r,s,i,o,l){let u;if(a==null?(u=new Array(t.length),u.fill(1)):u=a,i!=null&&i&i-1)throw new Error(\"Multiple ellipses in slice is not allowed.\");let p=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let y=0;y<d.dims;y++)p&&1<<y&o&&d.numAddAxisAfterEllipsis++,1<<y&i&&(p=!0);p||(d.ellipsisMask|=1<<d.dims,d.dims++);let c={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};u4(d,c);let h=!0,m=!0,f=!0,g=[],b=[];for(let y=0;y<e.length;++y){if(c.strides[y]===0)throw Error(`strides[${y}] must be non-zero`);let x=!!(c.shrinkAxisMask&1<<y),v=e[y];if(v===-1){g.push(x?1:-1);continue}let I=[c.beginMask&1<<y,c.endMask&1<<y],N=[c.strides[y]>0?0:-1,c.strides[y]>0?v:v-1];if(x&&c.strides[y]<=0)throw Error(\"only stride 1 allowed on non-range indexing.\");f=f&&c.strides[y]===1;let C=!!(c.beginMask&1<<y&&c.endMask&1<<y);if(c.beginValid&&c.endValid){if(x){let $=c.begin[y]<0?v+c.begin[y]:c.begin[y];if(c.begin[y]=$,c.end[y]=c.begin[y]+1,$<0||$>=v)throw Error(`slice index ${c.begin[y]} of dimension ${y} out of bounds.`)}else c.begin[y]=iI(c.begin[y],0,c.strides[y],v,I,N),c.end[y]=iI(c.end[y],1,c.strides[y],v,I,N);let D=c.strides[y]===1&&c.begin[y]===0&&c.end[y]===v;h=h&&D,m=m&&(y===0&&c.strides[y]===1||D)}else h=h&&c.strides[y]===1&&C,m=m&&(y===0&&c.strides[y]===1||C);let _,F=!1;if(c.beginValid&&c.endValid?(_=c.end[y]-c.begin[y],F=!0):x?(_=1,F=!0):C&&v>=0&&(c.strides[y]<0?_=-v:_=v,F=!0),F){let D;_===0||_<0!=c.strides[y]<0?D=0:D=Math.trunc(_/c.strides[y])+(_%c.strides[y]!==0?1:0),g.push(D)}else g.push(-1)}for(let y=0;y<c.finalShapeGatherIndices.length;++y){let x=c.finalShapeGatherIndices[y];x>=0?b.push(g[x]):x===Lx&&b.push(1)}return{finalShapeSparse:b.filter((y,x)=>c.finalShapeGatherIndices[x]!==Lx),finalShape:b,isIdentity:h,sliceDim0:m,isSimpleSlice:f,begin:c.begin,end:c.end,strides:c.strides}}function u4(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(Lx),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[a]),e.end!=null&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(t4),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}function iI(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{let i=e<0?a+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var p4=\"4.22.0\",t2=class{static sgd(e){return new ff(e)}static momentum(e,t,n=!1){return new jw(e,t,n)}static rmsprop(e,t=.9,n=0,a=null,r=!1){return new qw(e,t,n,a,r)}static adam(e=.001,t=.9,n=.999,a=null){return new Gw(e,t,n,a)}static adadelta(e=.001,t=.95,n=null){return new Vw(e,t,n)}static adamax(e=.002,t=.9,n=.999,a=null,r=0){return new Hw(e,t,n,a,r)}static adagrad(e,t=.1){return new Uw(e,t)}},Xs=t2,c4=typeof requestAnimationFrame!=\"undefined\"?requestAnimationFrame:typeof setImmediate!=\"undefined\"?setImmediate:e=>e();function Zw(){return new Promise(e=>c4(()=>e()))}var T={};_e(T,{ERF_A1:()=>T4,ERF_A2:()=>C4,ERF_A3:()=>E4,ERF_A4:()=>_4,ERF_A5:()=>A4,ERF_P:()=>N4,PARALLELIZE_THRESHOLD:()=>Jw,RowPartitionType:()=>er,SELU_SCALE:()=>a2,SELU_SCALEALPHA:()=>n2,applyActivation:()=>hf,assertAndGetBroadcastShape:()=>ct,assertAxesAreInnerMostDims:()=>l3,assertParamsConsistent:()=>d4,assignToTypedArray:()=>O4,axesAreInnerMostDims:()=>uw,calculateShapes:()=>pT,checkEinsumDimSizes:()=>V4,checkPadOnDimRoundingMode:()=>Tn,combineLocations:()=>FN,combineRaggedTensorToTensorShapes:()=>m4,complexWithEvenIndex:()=>D4,complexWithOddIndex:()=>R4,computeConv2DInfo:()=>sd,computeConv3DInfo:()=>kN,computeDefaultPad:()=>Hv,computeDilation2DInfo:()=>iP,computeOptimalWindowSize:()=>y4,computeOutAndReduceShapes:()=>$N,computeOutShape:()=>h4,computePool2DInfo:()=>wN,computePool3DInfo:()=>oP,convertConv2DDataFormat:()=>IN,decodeEinsumEquation:()=>W4,eitherStridesOrDilationsAreOne:()=>dr,expandShapeToKeepDim:()=>mi,exponent:()=>L4,exponents:()=>P4,fromStringArrayToUint8:()=>uV,fromUint8ToStringArray:()=>lV,getAxesPermutation:()=>DN,getBroadcastDims:()=>_N,getComplexWithIndex:()=>M4,getEinsumComputePath:()=>U4,getEinsumPermutation:()=>B4,getFusedBiasGradient:()=>df,getFusedDyActivation:()=>cf,getImageCenter:()=>x4,getInnerMostAxes:()=>u3,getPermuted:()=>w4,getRaggedRank:()=>g4,getReductionAxes:()=>Bt,getReshaped:()=>v4,getReshapedPermuted:()=>k4,getRowPartitionTypesHelper:()=>f4,getSliceBeginCoords:()=>I4,getSliceSize:()=>S4,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>q4,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>K4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>X4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>J4,getSparseReshapeInputOutputMismatchErrorMessage:()=>eV,getSparseReshapeInputOutputMultipleErrorMessage:()=>Q4,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Y4,getSparseReshapeNegativeOutputDimErrorMessage:()=>Z4,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>rV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>tV,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>nV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>aV,getUndoAxesPermutation:()=>pw,isIdentityPermutation:()=>G4,log:()=>gM,mergeRealAndImagArrays:()=>F4,prepareAndValidate:()=>HT,prepareSplitSize:()=>j4,segment_util:()=>r2,shouldFuse:()=>mf,slice_util:()=>Kt,splitRealAndImagArrays:()=>$4,stridesOrDilationsArePositive:()=>hi,tupleValuesAreOne:()=>ps,upcastType:()=>fa,validateDefaultValueShape:()=>b4,validateInput:()=>of,validateUpdateShape:()=>$w,warn:()=>Zr});function d4(e,t){let n=e[0].length;e.forEach((r,s)=>{A(r.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),A(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let a=e[0];e.forEach((r,s)=>{for(let i=0;i<n;i++)A(i===t||r[i]===a[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`)})}function h4(e,t){let n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var er;(function(e){e[e.FIRST_DIM_SIZE=0]=\"FIRST_DIM_SIZE\",e[e.VALUE_ROWIDS=1]=\"VALUE_ROWIDS\",e[e.ROW_LENGTHS=2]=\"ROW_LENGTHS\",e[e.ROW_SPLITS=3]=\"ROW_SPLITS\",e[e.ROW_LIMITS=4]=\"ROW_LIMITS\",e[e.ROW_STARTS=5]=\"ROW_STARTS\"})(er||(er={}));function m4(e,t,n){let a=new Array;if(n==null&&t==null)return a;if(t==null)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(n==null)return a;if(e+n.length!==a.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${a.length}`);for(let r=1;r<n.length;++r){let s=n[r],i=a[a.length-n.length+r],o=a[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${s} but shape[${r+e}] = ${o}`)}else a[i]=s}return a}function f4(e){let t={FIRST_DIM_SIZE:er.FIRST_DIM_SIZE,VALUE_ROWIDS:er.VALUE_ROWIDS,ROW_LENGTHS:er.ROW_LENGTHS,ROW_SPLITS:er.ROW_SPLITS,ROW_LIMITS:er.ROW_LIMITS,ROW_STARTS:er.ROW_STARTS},n=[];for(let a of e)if(a in t)n.push(t[a]);else break;return n}function g4(e){return e.length===0?0:e[0]===er.FIRST_DIM_SIZE?e.length-1:e.length}function b4(e,t){if(e==null||t==null)return;let n=e.length,a=t.length;if(n>=a)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);for(let r=0;r<Math.min(n,a-1);++r){let s=e[r],i=t[r+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${s} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}var Jw=30;function y4(e){return e<=Jw?e:Gh(e,Math.floor(Math.sqrt(e)))}function x4(e,t,n){let a=n*(typeof e==\"number\"?e:e[0]),r=t*(typeof e==\"number\"?e:e[1]);return[a,r]}function v4(e,t,n,a=!0){let r=[];if(a)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)r=r.concat([e[i+1]/t[i],t[i]]);r=r.concat(e.slice(s+1))}return r}function w4(e,t,n=!0){let a=[];if(n){a.push(t);for(let r=t+1;r<e;++r)r<=2*t?(a.push(r),a.push(r-(t+1))):a.push(r)}else{let r=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):r.push(i);a.push(...r),a.push(0),a.push(...s)}return a}function k4(e,t,n,a=!0){let r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function I4(e,t){let n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function S4(e,t,n){let a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}var n2=1.7580993408473768,a2=1.0507009873554805,N4=.3275911,T4=.254829592,C4=-.284496736,E4=1.421413741,_4=-1.453152027,A4=1.061405429;function F4(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function $4(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function D4(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function R4(e){let t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function M4(e,t){let n=e[t*2],a=e[t*2+1];return{real:n,imag:a}}function O4(e,t,n,a){e[a*2]=t,e[a*2+1]=n}function P4(e,t){let n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function L4(e,t,n){let a=(n?2:-2)*Math.PI*(e/t),r=Math.cos(a),s=Math.sin(a);return{real:r,imag:s}}var ux=\"->\",z4=/->/g,oI=\",\",lI=\"...\";function W4(e,t){e=e.replace(/\\s/g,\"\");let n=(e.length-e.replace(z4,\"\").length)/ux.length;if(n<1)throw new Error(\"Equations without an arrow are not supported.\");if(n>1)throw new Error(`Equation must contain exactly one arrow (\"${ux}\").`);let[a,r]=e.split(ux);A(a.indexOf(lI)===-1,()=>`The ellipsis notation (\"${lI}\") is not supported yet.`);let s=a.split(oI),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error(\"Support for more than 2 input tensors is not implemented yet.\");let o=[];for(let c=0;c<r.length;++c){let h=r[c];if(!s.some(m=>m.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);o.indexOf(h)===-1&&o.push(h)}for(let c=0;c<a.length;++c){let h=a[c];o.indexOf(h)===-1&&h!==oI&&o.push(h)}let l=new Array(s.length);for(let c=0;c<i;++c){if(new Set(s[c].split(\"\")).size!==s[c].length)throw new Error(`Found duplicate axes in input component ${s[c]}. Support for duplicate axes in input is not implemented yet.`);l[c]=[];for(let h=0;h<s[c].length;++h)l[c].push(o.indexOf(s[c][h]))}let u=o.length,p=r.length,d=[];for(let c=p;c<u;++c)d.push(c);return{allDims:o,summedDims:d,idDims:l}}function B4(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;let a=[];for(let r=0;r<e;++r)n[r]===-1&&a.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:a}}function V4(e,t,n){let a=new Array(e);for(let r=0;r<n.length;++r){let s=n[r].shape;for(let i=0;i<t[r].length;++i)a[t[r][i]]===void 0?a[t[r][i]]=s[i]:A(a[t[r][i]]===s[i],()=>`Expected dimension ${a[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function U4(e,t){let n=e,a=[],r=0;e.length===0&&n.push(-1),r=e.length+1;for(let i=0;i<r;++i)a.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=H4(t,o);for(let u of l)s.indexOf(u)===-1&&(a[i].push(u),s.push(u))}return{path:n,steps:a}}function G4(e){return e.every((t,n)=>t===n)}function H4(e,t){let n=[];for(let a=0;a<e.length;++a)(e[a].length===0||e[a].indexOf(t)!==-1||t===-1)&&n.push(a);return n}function j4(e,t,n=0){let a=[];if(typeof t==\"number\")A(e.shape[n]%t===0,()=>\"Number of splits must evenly divide the axis.\"),a=new Array(t).fill(e.shape[n]/t);else{let r=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);A(r<=1,()=>\"There should be only one negative value in split array.\");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}A(e.shape[n]===t.reduce((i,o)=>i+o),()=>\"The sum of sizes must match the size of the axis dimension.\"),a=t}return a}function q4(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function K4(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function X4(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Y4(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Z4(e,t){return`size ${e} must be non-negative, not ${t}`}function J4(){return\"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero\"}function Q4(e,t){let n=ot(e),a=ot(t);return`Input to reshape is a SparseTensor with ${n}\n  dense values, but the requested shape requires a multiple of ${a}. inputShape=${e} outputShape= ${t}`}function eV(e,t){let n=ot(e),a=ot(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${a}. inputShape=${e} outputShape=${t}`}function tV(){return\"segment ids must be >= 0\"}function nV(){return\"segment ids are not increasing\"}function aV(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function rV(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var r2={};_e(r2,{collectGatherOpShapeInfo:()=>oV,computeOutShape:()=>iV,segOpComputeOptimalWindowSize:()=>sV});function sV(e,t){let n=!1,a;for(e<=Jw?(a=e,n=!0):a=Gh(e,Math.floor(Math.sqrt(e)));!n;)a>t||a===e?n=!0:a=Gh(e,a+1);return a}function iV(e,t,n){let a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function oV(e,t,n,a){let r=t.shape.length,s=e.shape.length;if(a!==0&&(a<-r||a>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);if(a<0&&(a+=r),a>s)throw new Error(`batchDims (${a}) must be less than rank(x) (\n    ${s}).`);if(n<a)throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);for(let d=0;d<a;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,p=1;for(let d=0;d<a;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=a;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=a;d<r;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),p*=e.shape[d];return{batchSize:l,sliceSize:p,outerSize:u,dimSize:i,outputShape:o}}function lV(e){try{return e.map(t=>qh(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function uV(e){return e.map(t=>nd(t))}var mr={};_e(mr,{nonMaxSuppressionV3Impl:()=>ST,nonMaxSuppressionV4Impl:()=>NT,nonMaxSuppressionV5Impl:()=>TT,whereImpl:()=>hT});TB();var s2={kernelName:Yl,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,jo(re(n,\"float32\"),-1))}}},pV={kernelName:Ni,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=pt(re(n,\"float32\")),r=rn(pe(xe(1),a));return yt(he(e,r))}}}},cV={kernelName:Ti,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=rn(pe(pt(re(n,\"float32\")),1));return he(e,a)}}}},dV={kernelName:vs,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=e,i=Bt(n.shape,r);return i.length>0&&(s=fe(s,i)),W(s,n.shape)},b:()=>{let s=e,i=Bt(a.shape,r);return i.length>0&&(s=fe(s,i)),W(s,a.shape)}}}},hV={kernelName:Ci,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((a,r)=>{n[r]=()=>e.clone()}),n}},mV={kernelName:Ql,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>qe(n)}}},fV={kernelName:eu,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>qe(n)}}},gV={kernelName:Ei,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,rn(pe(xe(1),pt(re(n,\"float32\")))))}}},bV={kernelName:_i,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=rn(X(xe(1),pt(re(n,\"float32\"))));return he(e,a)}}}},yV={kernelName:$i,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=X(pt(n),pt(a)),i=z(e,he(a,s)),o=Bt(n.shape,r);return o.length>0&&(i=fe(i,o)),W(i,n.shape)},b:()=>{let s=X(pt(n),pt(a)),i=yt(z(e,he(n,s))),o=Bt(a.shape,r);return o.length>0&&(i=fe(i,o)),W(i,a.shape)}}}},xV={kernelName:Ai,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,X(pt(re(n,\"float32\")),1))}}},vV={kernelName:Fi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,pe(xe(1),pt(re(n,\"float32\"))))}}};function wV(e,t,n,a,r,s){let i=E(e,\"dy\",\"avgPool3dGrad\"),o=E(t,\"input\",\"avgPool3dGrad\"),l=i,u=o,p=!1;o.rank===4&&(p=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),A(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),A(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Tn(\"avgPool3dGrad\",r,s);let d={dy:l,input:u},c={filterSize:n,strides:a,pad:r,dimRoundingMode:s},h=P.runKernel(Rc,d,c);return p?W(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var kV=L({avgPool3dGrad_:wV}),IV={kernelName:tu,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>kV(e,a,r,s,i,o)}}};function SV(e,t,n,a,r){let s=E(e,\"dy\",\"avgPoolGrad\"),i=E(t,\"input\",\"avgPoolGrad\");A(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,u=!1;i.rank===3&&(u=!0,o=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),A(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let p={dy:l,input:o},d={filterSize:n,strides:a,pad:r},c=P.runKernel(Dc,p,d);return u?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var NV=L({avgPoolGrad_:SV}),TV={kernelName:Di,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{filterSize:r,strides:s,pad:i}=n;return{x:()=>NV(e,a,r,s,i)}}},CV={kernelName:Ri,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t,n)=>{let[a,r]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>$e(e,r,!1,!0),b:()=>$e(a,e,!0,!1)}:!s&&i?{a:()=>$e(e,r,!1,!1),b:()=>$e(e,a,!0,!1)}:s&&!i?{a:()=>$e(r,e,!1,!0),b:()=>$e(a,e,!1,!1)}:{a:()=>$e(r,e,!0,!0),b:()=>$e(e,a,!0,!0)}}},EV={kernelName:nu,gradFunc:(e,t,n)=>{let{blockShape:a,crops:r}=n;return{x:()=>md(e,a,r)}}},_V={kernelName:HS,gradFunc:(e,t,n)=>{let a=n,r=a.inputShape,s=a.shape,i=Array.from(s);for(let l=r.length-1;l>=0;l--)if(r[l]===s[l])i[l]=1;else if(r[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>fe(e,o,!0)}}},AV={kernelName:Mi,gradFunc:e=>({x:()=>e.clone()})},FV={kernelName:Oi,gradFunc:e=>({x:()=>qe(e)})},$V={kernelName:ws,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>nn(_a($r(a,r),Cs(a,s)),e,qe(e))}}},DV={kernelName:Oc,inputsToSave:[\"x\"],gradFunc:s2.gradFunc},RV={kernelName:su,saveAllInputs:!0,gradFunc:(e,t,n)=>{let a=t.map(o=>o.shape),{axis:r}=n,s=Aa(r,t[0].shape)[0],i=a.map(o=>o[s]);return Ln(e,i,s).map(o=>()=>o)}},MV={kernelName:Pi,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let[a,r]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return A(ps(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>nw(a.shape,e,r,i,o,l),filter:()=>zw(a,e,r.shape,i,o,l)}}},OV={kernelName:Li,inputsToSave:[\"dy\",\"filter\"],gradFunc:(e,t,n)=>{let[a,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>$t(e,r,s,i,o,1,l),filter:()=>zw(e,a,r.shape,s,i,o,l)}}};function PV(e,t,n,a,r){let s=e;e.rank===4&&(s=W(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),A(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),A(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:a,pad:r,filterShape:n};return P.runKernel(iu,o,l)}var LV=L({conv3DBackpropFilter_:PV}),zV={kernelName:zi,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s}=n;A(ps(a),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let[i,o]=t;return{x:()=>CN(i.shape,e,o,r,s),filter:()=>LV(i,e,o.shape,r,s)}}},WV={kernelName:Wi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(yt(ef(re(n,\"float32\"))),e)}}},BV={kernelName:Bi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(tf(re(n,\"float32\")),e)}}},VV={kernelName:Vi,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r,exclusive:s,reverse:i}=n;return{x:()=>{let o=DN([r],a.rank),l=Vm(e,r,s,!i);return o!=null&&(l=De(l,o)),l}}}},UV={kernelName:Ui,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let{dilations:a,strides:r,pad:s,dimRoundingMode:i}=n,o=a==null?[1,1]:a;A(ps(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),A(dr(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Tn(\"depthwiseConv2d\",s,i),{x:()=>wT(l.shape,e,u,r,s,o,i),filter:()=>vT(l,e,u.shape,r,s,o,i)}}},GV={kernelName:Gi,inputsToSave:[\"x\",\"filter\"],gradFunc:(e,t,n)=>{let[a,r]=t,s={x:a,filter:r,dy:e},i={x:a,filter:r,dy:e};return{x:()=>P.runKernel(Dl,s,n),filter:()=>P.runKernel(Rl,i,n)}}},HV={kernelName:ji,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,a={dy:e,y:n};return{x:()=>P.runKernel(cu,a)}}},jV={kernelName:qi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t,a=z(dn(yt(pt(n))),2/Math.sqrt(Math.PI));return{x:()=>z(e,a)}}},qV={kernelName:Ki,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,n)}}},KV={kernelName:hu,inputsToSave:[\"input\"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>W(e,n.shape)}}},XV={kernelName:Xi,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,dn(n))}}},YV={kernelName:Yi,gradFunc:e=>({x:()=>qe(e)})},ZV={kernelName:Zi,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=he(e,re(a,\"float32\")),i=Bt(n.shape,r);return i.length>0?W(fe(s,i),n.shape):s},b:()=>{let s=z(e,re(n,\"float32\")),i=Bt(a.shape,r);i.length>0&&(s=W(fe(s,i),a.shape));let o=pt(a);return yt(he(s,re(o,\"float32\")))}}}},JV={kernelName:Ji,inputsToSave:[\"x\",\"mean\",\"variance\",\"scale\"],gradFunc:(e,t,n)=>{let{varianceEpsilon:a}=n,[r,s,i,o]=t,l=o==null?xe(1):o,u=Bt(s.shape,r.shape),p=[];if(s.rank===1){for(let f=0;f<r.shape.length-1;++f)p.push(r.shape[f]);p.push(1)}let d=pe(r,s),c=z(e,l),h=Jm(X(i,xe(a))),m=z(z(z(h,h),h),xe(-.5));return{x:()=>s.rank===1?W(z(z(e,On(W(h,[1,1,1,s.shape[0]]),p)),l),r.shape):W(z(z(e,h),l),r.shape),mean:()=>{let f=z(z(h,xe(-1)),c);return s.rank===1&&(f=fe(f,u)),W(f,s.shape)},variance:()=>{let f=z(z(m,d),c);return s.rank===1&&(f=fe(f,u)),W(f,s.shape)},scale:()=>{let f=z(d,h),g=z(e,f);return s.rank===1&&(g=fe(g,u)),W(g,s.shape)},offset:()=>{let f=e;return s.rank===1&&(f=fe(f,u)),W(f,s.shape)}}}},QV={kernelName:fu,inputsToSave:[\"x\",\"indices\"],gradFunc:(e,t,n)=>{let[a,r]=t,{axis:s,batchDims:i}=n,o=Aa(s,a.shape)[0],l=(u,p,d)=>()=>{let c=u.shape,h=p.size,m=c.slice(0,o),f=m.length,g=c.slice(s,c.length).slice(1),b=g.length,y=uI(0,f),x=uI(f+1,f+1+b),v=pI([m,[h],g]),I=W(d,v),N=W(p,[h]),C=pI([[f],y,x]),_=De(I,C),F=uf(_,N,u.shape[o]),D=pw(C);return F=De(F,D),F};if(i===1){let u=a.shape[0],p=a.split(u,0);return{x:()=>At(p.map((d,c)=>l(d,r.slice(c,1),e.slice(c,1))())).reshape(a.shape),indices:()=>r}}else return{x:l(a,r,e),indices:()=>r}}};function uI(e,t){let n=[];for(let a=e;a<t;++a)n.push(a);return n}function pI(e){let t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}var eU={kernelName:Qi,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>qe(n),b:()=>qe(a)}}},tU={kernelName:eo,gradFunc:e=>({x:()=>re(e,\"float32\")})},nU={kernelName:to,gradFunc:e=>({x:()=>qe(e)})},aU={kernelName:no,gradFunc:e=>({x:()=>qe(e)})},rU={kernelName:ao,gradFunc:e=>({x:()=>qe(e)})},sU={kernelName:ro,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{alpha:r}=n,s=Cn(a,0);return{x:()=>nn(s,e,z(e,r))}}},iU={kernelName:io,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,X(n,1))}}},oU={kernelName:so,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,re(n,\"float32\"))}}},lU={kernelName:qS,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n;return{logits:()=>{let s=dn(a);return pe(e,z(fe(e,r,!0),s))}}}};function uU(e,t,n,a=5,r=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:a,bias:r,alpha:s,beta:i};return P.runKernel(Su,o,l)}var pU=L({localResponseNormalizationBackprop_:uU}),cU={kernelName:oo,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>pU(a,r,e,s,i,o,l)}}};function i2(e,t,n,a){return t.rank<n.rank&&(t=W(t,mi(t.shape,a))),e.rank<n.rank&&(e=W(e,mi(e.shape,a))),{x:()=>z(e,re(Jn(n,t),e.dtype))}}var cI={kernelName:lo,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{reductionIndices:r}=a,s=t[0],i=t[1],o=Aa(r,s.shape),l=i2(e,i,s,o);return{x:()=>l.x()}}},dU={kernelName:uo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>z(e,re($r(n,a),\"float32\")),b:()=>z(e,re(Pl(n,a),\"float32\"))}}};function hU(e,t,n,a,r,s,i){let o=E(e,\"dy\",\"maxPool3dGrad\"),l=E(t,\"input\",\"maxPool3dGrad\"),u=E(n,\"output\",\"maxPool3dGrad\"),p=o,d=l,c=u,h=!1;l.rank===4&&(h=!0,p=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=W(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),c=W(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),A(p.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),A(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),A(c.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${c.rank}.`),Tn(\"maxPool3dGrad\",s,i);let m={dy:p,input:d,output:c},f={filterSize:a,strides:r,pad:s,dimRoundingMode:i},g=P.runKernel(Bc,m,f);return h?W(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var mU=L({maxPool3dGrad_:hU}),fU={kernelName:Nu,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>mU(e,a,r,s,i,o,l)}}};function gU(e,t,n,a,r,s,i){let o=E(e,\"dy\",\"maxPoolGrad\"),l=E(t,\"input\",\"maxPoolGrad\"),u=E(n,\"output\",\"maxPoolGrad\");A(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),A(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),A(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Tn(\"maxPoolGrad\",s,i);let p={dy:o,input:l,output:u},d={filterSize:a,strides:r,pad:s,dimRoundingMode:i};return P.runKernel(Wc,p,d)}var bU=L({maxPoolGrad_:gU}),yU={kernelName:po,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a,r]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>bU(e,a,r,s,i,o)}}},xU={kernelName:co,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=Aa(r,a.shape),i=$N(a.shape,s)[1],o=ot(i);return{x:()=>{let l=a.shape.slice();s.forEach(p=>{l[p]=1});let u=W(e,l);return he(z(u,Pn(a.shape,\"float32\")),o)}}}},vU={kernelName:ho,inputsToSave:[\"x\"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let a=n,{axis:r}=a,[s,i]=t,o=Aa(r,s.shape),l=i2(e,i,s,o);return{x:()=>l.x()}}},wU={kernelName:mo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t;return{a:()=>z(e,re(Cs(n,a),\"float32\")),b:()=>z(e,re(Cn(n,a),\"float32\"))}}},kU={kernelName:fo,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>Ve(e,s,a.shape)}}},IU={kernelName:go,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=Bt(n.shape,r);return s.length>0?W(fe(e,s),n.shape):e},b:()=>{let s=z(e,yt(tp(he(n,a)))),i=Bt(a.shape,r);return i.length>0?W(fe(s,i),a.shape):s}}}},SU={kernelName:bo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=z(e,re(a,\"float32\")),i=Bt(n.shape,r);return i.length>0?W(fe(s,i),n.shape):s},b:()=>{let s=z(e,re(n,\"float32\")),i=Bt(a.shape,r);return i.length>0?W(fe(s,i),a.shape):s}}}},NU={kernelName:Cu,gradFunc:e=>({x:()=>yt(e)})},TU={kernelName:yo,inputsToSave:[\"indices\"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>It(n.shape,\"float32\")}}},CU={kernelName:$u,gradFunc:e=>({x:()=>qe(e)})},EU={kernelName:Du,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:a}=n;return dt(e,a).map(r=>()=>r)}},dI={kernelName:xo,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let a=t[0],{paddings:r}=n,s=r.map(i=>i[0]);return{x:()=>Ve(e,s,a.shape)}}},_U={kernelName:vo,inputsToSave:[\"a\",\"b\"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,a,r]=t,s=n,i=a,o=ct(s.shape,i.shape);return{a:()=>{let l=re(i,\"float32\"),u=z(e,z(l,ur(s,pe(l,xe(1))))),p=Bt(s.shape,o);return p.length>0&&(u=fe(u,p)),W(u,s.shape)},b:()=>{let l=Cn(s,0),u=nn(l,Qn(s),qe(s)),p=z(e,z(r,u)),d=Bt(i.shape,o);return d.length>0&&(p=fe(p,d)),W(p,i.shape)}}}},AU={kernelName:wo,inputsToSave:[\"x\",\"alpha\"],gradFunc:(e,t)=>{let[n,a]=t,r=Cn(n,0);return{x:()=>nn(r,e,z(e,a)),alpha:()=>{let s=nn(r,qe(e),z(e,n)),i=Bt(a.shape,e.shape);return i.length>0&&(s=fe(s,i)),W(s,a.shape)}}}};function FU(e,t,n){let a=e.shape.slice();a[n]=1;let r=W(t,a),s=wc(e,n,!0,!1),i=wc(e,n,!0,!0),o=z(s,i);return z(r,o)}function $U(e,t,n){let a=e.shape.length,r=a-n.length,s=T.getAxesPermutation(n,a),i=e;s!=null&&(i=De(e,s));let o=i.shape.slice(),l=o.splice(a-n.length,n.length).reduce((d,c)=>d*c,1);o.push(l);let u=i.reshape(o),p=FU(u,t,r);if(p=p.reshape(i.shape),s!=null){let d=T.getUndoAxesPermutation(s);p=De(p,d)}return p}var DU={kernelName:ko,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{axis:r}=n,s=[];return r==null?s=a.shape.map((i,o)=>o):typeof r==\"number\"?s=[r]:s=r,{x:()=>$U(a,e,s)}}},RU={kernelName:Hi,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=he(e,re(a,\"float32\")),i=Bt(n.shape,r);return i.length>0?W(fe(s,i),n.shape):s},b:()=>{let s=z(e,re(n,\"float32\")),i=Bt(a.shape,r);i.length>0&&(s=W(fe(s,i),a.shape));let o=pt(a);return yt(he(s,re(o,\"float32\")))}}}},MU={kernelName:Io,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,yt(pt(n)))}}},OU={kernelName:Co,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t,a=z(Cs(n,6),jo(n));return{x:()=>z(e,re(a,\"float32\"))}}},PU={kernelName:So,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,re(jo(n),\"float32\"))}}},LU={kernelName:Ru,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,n.shape)}}},zU={kernelName:To,inputsToSave:[\"images\"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>P.runKernel(Ou,r,n)}}},WU={kernelName:No,inputsToSave:[\"images\"],gradFunc:(e,t,n)=>{let[a]=t,r={dy:e,images:a};return{images:()=>P.runKernel(Mu,r,n)}}},BU={kernelName:Eo,gradFunc:(e,t,n)=>{let{dims:a}=n,r=Aa(a,e.shape);return{x:()=>ba(e,r)}}},VU={kernelName:_o,gradFunc:e=>({x:()=>qe(e)})},UU={kernelName:Ao,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>yt(he(e,z(ur(n,1.5),2)))}}},GU={kernelName:Wu,inputsToSave:[\"condition\"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>re(qe(n),\"float32\"),t:()=>z(e,re(n,e.dtype)),e:()=>z(e,re(dd(n),e.dtype))}}},HU={kernelName:Fo,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let a=Cn(n,xe(0)),r=xe(n2),s=xe(a2),i=z(e,s),o=z(z(e,r),dn(re(n,\"float32\")));return nn(a,i,o)}}}},jU={kernelName:Mo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(n,pe(xe(1),n)))}}},qU={kernelName:Ro,gradFunc:e=>({x:()=>qe(e)})},KU={kernelName:$o,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(od(re(n,\"float32\")),e)}}},XU={kernelName:Do,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(Bm(re(n,\"float32\")),e)}}},YU={kernelName:Bu,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{begin:r,size:s}=n,i=a.shape,[o,l]=e2(a,r,s),u=[];for(let p=0;p<e.rank;p++)u.push([o[p],i[p]-o[p]-l[p]]);return{x:()=>xa(e,u)}}},ZU={kernelName:zo,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[a]=t,{dim:r}=n,s=!0,i=z(e,a);return{logits:()=>pe(i,z(fe(i,[r],s),a))}}},JU={kernelName:Oo,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,ha(n))}}},hI={kernelName:Vu,gradFunc:(e,t,n)=>{let{blockShape:a,paddings:r}=n;return{x:()=>id(e,a,r)}}},mI={kernelName:Uu,gradFunc:(e,t,n)=>{let{axis:a}=n;return{x:()=>et(e,a)}}},QU={kernelName:Po,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,z(rn(re(n,\"float32\")),2))}}},eG={kernelName:qc,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(re(n,\"float32\"),2))}}},tG={kernelName:Wo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=xe(2);return{a:()=>z(e,z(r,pe(n,a))),b:()=>z(e,z(r,pe(a,n)))}}},nG={kernelName:Is,gradFunc:e=>({x:()=>qe(e)})},aG={kernelName:Bo,inputsToSave:[\"a\",\"b\"],gradFunc:(e,t)=>{let[n,a]=t,r=ct(n.shape,a.shape);return{a:()=>{let s=e,i=Bt(n.shape,r);return i.length>0&&(s=fe(s,i)),W(s,n.shape)},b:()=>{let s=e,i=Bt(a.shape,r);return i.length>0&&(s=fe(s,i)),W(yt(s),a.shape)}}}},rG={kernelName:Lo,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,r=a.shape.slice(),{axis:s}=n;Aa(s,a.shape).forEach(l=>{r[l]=1});let i=W(e,r),o=z(i,Pn(a.shape,\"float32\"));return{x:()=>o}}},sG={kernelName:Vo,inputsToSave:[\"x\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>he(e,pt(od(n)))}}},iG={kernelName:Uo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(pe(xe(1),pt(n)),e)}}},oG={kernelName:ks,inputsToSave:[\"x\"],gradFunc:(e,t,n)=>{let[a]=t,{reps:r}=n;return{x:()=>{let s=qe(a);if(a.rank===1)for(let i=0;i<r[0];++i)s=X(s,Ve(e,[i*a.shape[0]],[a.shape[0]]));else if(a.rank===2)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)s=X(s,Ve(e,[i*a.shape[0],o*a.shape[1]],[a.shape[0],a.shape[1]]));else if(a.rank===3)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)s=X(s,Ve(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else if(a.rank===4)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)for(let u=0;u<r[3];++u)s=X(s,Ve(e,[i*a.shape[0],o*a.shape[1],l*a.shape[2],u*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${a.rank} tensors yet.`);return s}}}},lG={kernelName:Cr,gradFunc:(e,t,n)=>{let a=n,{perm:r}=a,s=pw(r);return{x:()=>De(e,s)}}},uG={kernelName:Xu,gradFunc:(e,t,n)=>{let a=n,{axis:r}=a;return{value:()=>At(e,r)}}},pG={kernelName:Qc,inputsToSave:[\"segmentIds\"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>cG(e,n)}}};function cG(e,t){let n=hr(t,qe(t)),a=np(e,n),r=$r(t,xe(0,\"int32\")),s=a.rank-r.rank;for(let o=0;o<s;++o)r=Gt(r,o+1);r=_a(r,Pn(a.shape,\"bool\"));let i=qe(a);return nn(r,a,i)}var dG={kernelName:Yu,gradFunc:e=>({x:()=>qe(e)})},hG=[s2,pV,cV,dV,hV,mV,fV,gV,bV,yV,xV,vV,IV,TV,CV,EV,_V,AV,FV,$V,DV,RV,OV,MV,zV,WV,BV,VV,UV,GV,RU,HV,jV,qV,KV,XV,ZV,YV,JV,QV,eU,tU,nU,aU,rU,sU,iU,oU,lU,cU,cI,cI,dU,fU,yU,xU,vU,wU,kU,IU,SU,NU,TU,CU,EU,dI,dI,_U,AU,DU,MU,OU,PU,LU,zU,WU,BU,VU,UU,GU,HU,jU,qU,KU,XU,YU,ZU,JU,hI,hI,mI,mI,QU,tG,eG,nG,aG,rG,sG,iG,oG,lG,uG,pG,dG];for(let e of hG)KS(e);Q().prototype.abs=function(){return this.throwIfDisposed(),Lt(this)};Q().prototype.acos=function(){return this.throwIfDisposed(),Pv(this)};Q().prototype.acosh=function(){return this.throwIfDisposed(),Lv(this)};Q().prototype.add=function(e){return this.throwIfDisposed(),X(this,e)};Q().prototype.all=function(e,t){return this.throwIfDisposed(),Lm(this,e,t)};Q().prototype.any=function(e,t){return this.throwIfDisposed(),yc(this,e,t)};Q().prototype.argMax=function(e){return this.throwIfDisposed(),di(this,e)};Q().prototype.argMin=function(e){return this.throwIfDisposed(),zv(this,e)};Q().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>\"The array must have only 1 element.\"),W(this,[])};Q().prototype.asType=function(e){return this.throwIfDisposed(),re(this,e)};Q().prototype.as1D=function(){return this.throwIfDisposed(),W(this,[this.size])};Q().prototype.as2D=function(e,t){return this.throwIfDisposed(),W(this,[e,t])};Q().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),W(this,[e,t,n])};Q().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),W(this,[e,t,n,a])};Q().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),W(this,[e,t,n,a,r])};Q().prototype.asin=function(){return this.throwIfDisposed(),Wv(this)};Q().prototype.asinh=function(){return this.throwIfDisposed(),Bv(this)};Q().prototype.atan=function(){return this.throwIfDisposed(),Vv(this)};Q().prototype.atan2=function(e){return this.throwIfDisposed(),Uv(this,e)};Q().prototype.atanh=function(){return this.throwIfDisposed(),Gv(this)};Q().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),ya(this,e,t,n,a)};Q().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),id(this,e,t)};Q().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Ns(this,e,t,n,a,r)};Q().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ai(this,e)};Q().prototype.cast=function(e){return this.throwIfDisposed(),re(this,e)};Q().prototype.ceil=function(){return this.throwIfDisposed(),Zv(this)};Q().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),an(this,e,t)};Q().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ce&&(e=[e]),et([this,...e],t)};Q().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),zm(this,e,t,n,a,r,s)};Q().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),Wm(this,e,t,n,a,r)};Q().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),$t(this,e,t,n,a,r,s)};Q().prototype.cos=function(){return this.throwIfDisposed(),od(this)};Q().prototype.cosh=function(){return this.throwIfDisposed(),Bm(this)};Q().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),wc(this,e,t,n)};Q().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Vm(this,e,t,n)};Q().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),sw(this,e,t)};Q().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),Ts(this,e,t,n,a,r,s)};Q().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),iw(this,e,t,n,a,r)};Q().prototype.divNoNan=function(e){return this.throwIfDisposed(),ow(this,e)};Q().prototype.div=function(e){return this.throwIfDisposed(),he(this,e)};Q().prototype.dot=function(e){return this.throwIfDisposed(),lw(this,e)};Q().prototype.elu=function(){return this.throwIfDisposed(),Qu(this)};Q().prototype.equal=function(e){return this.throwIfDisposed(),Jn(this,e)};Q().prototype.erf=function(){return this.throwIfDisposed(),Um(this)};Q().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),cw(this,e,t)};Q().prototype.exp=function(){return this.throwIfDisposed(),dn(this)};Q().prototype.expandDims=function(e){return this.throwIfDisposed(),Gt(this,e)};Q().prototype.expm1=function(){return this.throwIfDisposed(),dw(this)};Q().prototype.fft=function(){return this.throwIfDisposed(),bd(this)};Q().prototype.flatten=function(){return this.throwIfDisposed(),W(this,[this.size])};Q().prototype.floor=function(){return this.throwIfDisposed(),tp(this)};Q().prototype.floorDiv=function(e){return this.throwIfDisposed(),Pm(this,e)};Q().prototype.gather=function(e,t,n){return this.throwIfDisposed(),np(this,e,t,n)};Q().prototype.greaterEqual=function(e){return this.throwIfDisposed(),$r(this,e)};Q().prototype.greater=function(e){return this.throwIfDisposed(),Cn(this,e)};Q().prototype.ifft=function(){return this.throwIfDisposed(),Bl(this)};Q().prototype.irfft=function(){return this.throwIfDisposed(),af(this)};Q().prototype.isFinite=function(){return this.throwIfDisposed(),hw(this)};Q().prototype.isInf=function(){return this.throwIfDisposed(),mw(this)};Q().prototype.isNaN=function(){return this.throwIfDisposed(),fw(this)};Q().prototype.leakyRelu=function(e){return this.throwIfDisposed(),ud(this,e)};Q().prototype.lessEqual=function(e){return this.throwIfDisposed(),Cs(this,e)};Q().prototype.less=function(e){return this.throwIfDisposed(),Pl(this,e)};Q().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),gw(this,e,t,n,a)};Q().prototype.logSigmoid=function(){return this.throwIfDisposed(),bw(this)};Q().prototype.logSoftmax=function(e){return this.throwIfDisposed(),jm(this,e)};Q().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),cd(this,e,t)};Q().prototype.log=function(){return this.throwIfDisposed(),Qn(this)};Q().prototype.log1p=function(){return this.throwIfDisposed(),pd(this)};Q().prototype.logicalAnd=function(e){return this.throwIfDisposed(),_a(this,e)};Q().prototype.logicalNot=function(){return this.throwIfDisposed(),dd(this)};Q().prototype.logicalOr=function(e){return this.throwIfDisposed(),qm(this,e)};Q().prototype.logicalXor=function(e){return this.throwIfDisposed(),yw(this,e)};Q().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),$e(this,e,t,n)};Q().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Dt(this,e,t,n,a)};Q().prototype.max=function(e,t){return this.throwIfDisposed(),ma(this,e,t)};Q().prototype.maximum=function(e){return this.throwIfDisposed(),hr(this,e)};Q().prototype.mean=function(e,t){return this.throwIfDisposed(),Ct(this,e,t)};Q().prototype.min=function(e,t){return this.throwIfDisposed(),Ol(this,e,t)};Q().prototype.minimum=function(e){return this.throwIfDisposed(),ds(this,e)};Q().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),vw(this,e,t)};Q().prototype.mod=function(e){return this.throwIfDisposed(),ww(this,e)};Q().prototype.mul=function(e){return this.throwIfDisposed(),z(this,e)};Q().prototype.neg=function(){return this.throwIfDisposed(),yt(this)};Q().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ep(this,e,t,n)};Q().prototype.notEqual=function(e){return this.throwIfDisposed(),fi(this,e)};Q().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Ll(this,e,t,n)};Q().prototype.onesLike=function(){return this.throwIfDisposed(),ea(this)};Q().prototype.pad=function(e,t){return this.throwIfDisposed(),xa(this,e,t)};Q().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),kw(this,e,t,n,a,r,s)};Q().prototype.pow=function(e){return this.throwIfDisposed(),ur(this,e)};Q().prototype.prelu=function(e){return this.throwIfDisposed(),fd(this,e)};Q().prototype.prod=function(e,t){return this.throwIfDisposed(),Iw(this,e,t)};Q().prototype.reciprocal=function(){return this.throwIfDisposed(),Ew(this)};Q().prototype.relu=function(){return this.throwIfDisposed(),Ke(this)};Q().prototype.relu6=function(){return this.throwIfDisposed(),Ym(this)};Q().prototype.reshapeAs=function(e){return this.throwIfDisposed(),W(this,e.shape)};Q().prototype.reshape=function(e){return this.throwIfDisposed(),W(this,e)};Q().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),CT(this,e,t,n)};Q().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),ET(this,e,t,n)};Q().prototype.reverse=function(e){return this.throwIfDisposed(),ba(this,e)};Q().prototype.rfft=function(){return this.throwIfDisposed(),yd(this)};Q().prototype.round=function(){return this.throwIfDisposed(),Zm(this)};Q().prototype.rsqrt=function(){return this.throwIfDisposed(),Jm(this)};Q().prototype.selu=function(){return this.throwIfDisposed(),Qm(this)};Q().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),_s(this,e,t,n,a,r,s)};Q().prototype.sigmoid=function(){return this.throwIfDisposed(),ha(this)};Q().prototype.sign=function(){return this.throwIfDisposed(),_w(this)};Q().prototype.sin=function(){return this.throwIfDisposed(),ef(this)};Q().prototype.sinh=function(){return this.throwIfDisposed(),tf(this)};Q().prototype.slice=function(e,t){return this.throwIfDisposed(),Ve(this,e,t)};Q().prototype.softmax=function(e){return this.throwIfDisposed(),qa(this,e)};Q().prototype.softplus=function(){return this.throwIfDisposed(),Go(this)};Q().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),md(this,e,t)};Q().prototype.split=function(e,t){return this.throwIfDisposed(),Ln(this,e,t)};Q().prototype.sqrt=function(){return this.throwIfDisposed(),rn(this)};Q().prototype.square=function(){return this.throwIfDisposed(),pt(this)};Q().prototype.squaredDifference=function(e){return this.throwIfDisposed(),rf(this,e)};Q().prototype.squeeze=function(e){return this.throwIfDisposed(),As(this,e)};Q().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Ce?[this,e]:[this,...e];return At(n,t)};Q().prototype.step=function(e){return this.throwIfDisposed(),jo(this,e)};Q().prototype.stridedSlice=function(e,t,n,a,r,s,i,o){return this.throwIfDisposed(),Aw(this,e,t,n,a,r,s,i,o)};Q().prototype.sub=function(e){return this.throwIfDisposed(),pe(this,e)};Q().prototype.sum=function(e,t){return this.throwIfDisposed(),fe(this,e,t)};Q().prototype.tan=function(){return this.throwIfDisposed(),Fw(this)};Q().prototype.tanh=function(){return this.throwIfDisposed(),cs(this)};Q().prototype.tile=function(e){return this.throwIfDisposed(),On(this,e)};Q().prototype.toBool=function(){return this.throwIfDisposed(),re(this,\"bool\")};Q().prototype.toFloat=function(){return this.throwIfDisposed(),re(this,\"float32\")};Q().prototype.toInt=function(){return this.throwIfDisposed(),re(this,\"int32\")};Q().prototype.topk=function(e,t){return this.throwIfDisposed(),Dw(this,e,t)};Q().prototype.transpose=function(e){return this.throwIfDisposed(),De(this,e)};Q().prototype.unique=function(e){return this.throwIfDisposed(),Rw(this,e)};Q().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),uf(this,e,t)};Q().prototype.unstack=function(e){return this.throwIfDisposed(),dt(this,e)};Q().prototype.where=function(e,t){return this.throwIfDisposed(),nn(e,this,t)};Q().prototype.zerosLike=function(){return this.throwIfDisposed(),qe(this)};var Xr=class o2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,o2.prototype)}},ar=class l2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,l2.prototype)}},V=class u2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,u2.prototype)}},ze=class p2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,p2.prototype)}},mG=class c2 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,c2.prototype)}},d2=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function bi(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function tr(e,t){if(!e)throw new mG(t)}function fI(e,t){let n=0;for(let a of e)a===t&&n++;return n}function Mn(e){return e.length===1?e[0]:e}function it(e){return Array.isArray(e)?e:[e]}function Ir(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,\"$1_$2\").replace(/([a-z])([A-Z])/g,\"$1_$2\").toLowerCase();return t[0]!==\"_\"?t:\"private\"+t}function Js(e){return e.length<=1||e.indexOf(\"_\")===-1?e:e.replace(/[_]+(\\w|$)/g,(t,n)=>n.toUpperCase())}var Sa={};function Qw(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function zx(e){if(!(e==null||typeof e!=\"object\"))if(Array.isArray(e))e.forEach(t=>zx(t));else{let t=Object.keys(e);for(let n of t){let a=e[n];a!=null&&typeof a==\"object\"&&(!Array.isArray(a)&&a.type===\"ndarray\"&&typeof a.value==\"number\"?e[n]=a.value:zx(a))}}}function vd(e,t={},n={},a=\"object\",r=!1){if(typeof e==\"string\"){let s=e,i;if(s in n)i=n[s];else if(s in Sa)i=Sa[s];else if(i=t[s],i==null)throw new V(`Unknown ${a}: ${e}. This may be due to one of the following reasons:\n1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new V(`${a}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in Sa?[o,l]=Sa.className:i in t&&([o,l]=t[i]),o==null)throw new V(`Unknown ${a}: ${i}. This may be due to one of the following reasons:\n1. The ${a} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${a} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let h of Object.keys(Sa))u[h]=Sa[h];for(let h of Object.keys(n))u[h]=n[h];let p=s.config;p.customObjects=u;let d=Object.assign({},Sa);for(let h of Object.keys(n))Sa[h]=n[h];zx(s.config);let c=l(o,s.config,n,r);return Sa=Object.assign({},d),c}else{let u=Object.assign({},Sa);for(let d of Object.keys(n))Sa[d]=n[d];let p=new o(s.config);return Sa=Object.assign({},u),p}}}function fG(e,t){return e<t?-1:e>t?1:0}function wh(e,t){return-1*fG(e,t)}function as(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function gG(e){if(e==null)throw new V(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Ko(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new V(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function e0(e,t,n=0,a=1/0){return tr(n>=0),tr(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every(r=>typeof r===t)}function tn(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,a)=>tn(n,`element ${a+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${h2(e)}.`)}function h2(e){return e===null?\"null\":Array.isArray(e)?\"[\"+e.map(t=>h2(t)).join(\",\")+\"]\":typeof e==\"string\"?`\"${e}\"`:`${e}`}function bG(e,t,n){let a=n!=null?n():w.now(),r;return(...s)=>{let i=n!=null?n():w.now();return i-a<t||(a=i,r=e(...s)),r}}function m2(e){return e===\"relu\"?\"relu\":e===\"linear\"?\"linear\":e===\"elu\"?\"elu\":null}var yG=0;function f2(){return yG++}var kh={};function gf(e=\"\"){return e in kh||(kh[e]=0),kh[e]+=1,e+kh[e].toString()}var xG=[\"channelsFirst\",\"channelsLast\"],vG=[\"nearest\",\"bilinear\"],wG=[\"valid\",\"same\",\"causal\"],kG=[\"max\",\"avg\"],IG=[\"sum\",\"mul\",\"concat\",\"ave\"],kl=new Map;function Rt(e){Ko(xG,\"DataFormat\",e)}function SG(e){Ko(vG,\"InterpolationFormat\",e)}function va(e){Ko(wG,\"PaddingMode\",e)}function g2(e){Ko(kG,\"PoolMode\",e)}var pc=[],gI=\"/\";function ri(e,t){pc.push(e);try{let n=t();return pc.pop(),n}catch(n){throw pc.pop(),n}}function NG(){return pc.length===0?\"\":pc.join(gI)+gI}function b2(e){if(!x2(e))throw new Error(\"Not a valid tensor name: '\"+e+\"'\");return NG()+e}function y2(e){if(!x2(e))throw new Error(\"Not a valid tensor name: '\"+e+\"'\");kl.has(e)||kl.set(e,0);let t=kl.get(e);if(kl.set(e,kl.get(e)+1),t>0){let n=`${e}_${t}`;return kl.set(n,1),n}else return e}var TG=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);function x2(e){return!!e.match(TG)}function CG(e){return e===parseInt(e.toString(),10)}function rs(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function Ul(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a<t&&(t=a)}return t}function hs(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let a=e[n];a>t&&(t=a)}return t}function Ua(e,t){if(t<e)throw new V(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let a=e;a<t;++a)n.push(a);return n}var px;function qt(){return px==null&&(px=Dv().epsilon()),px}function Ga(){return\"channelsLast\"}function ir(e,t){return re(e,t)}function wd(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),W(e,n)}function EG(e,t){return O(()=>{if(e.shape.length!==2)throw new V(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=wd(e,1);return Wx(n,[1,t,1])})}function _G(e){let t=[rs(e.shape)];return W(e,t)}function AG(e){if(e.rank<=1)throw new V(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],rs(e.shape,1)];return W(e,t)}function si(e,t,n){return O(()=>{switch(e.rank){case 1:return gd(e,t,n);case 2:return nf(e,[t,0],[n,e.shape[1]]);case 3:return Ho(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Wl(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ve(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ve(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new V(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function cx(e,t,n){return O(()=>{switch(e.rank){case 1:return gd(e,t,n);case 2:return nf(e,[0,t],[e.shape[0],n]);case 3:return Ho(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Wl(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Ih(e,t,n,a){return O(()=>{switch(e.rank){case 1:return gd(e,t,n);case 2:switch(a){case 1:return si(e,t,n);case 2:return cx(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${a}`)}case 3:switch(a){case 1:return si(e,t,n);case 2:return Ho(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return cx(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${a}`)}case 4:switch(a){case 1:return si(e,t,n);case 2:return Wl(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Wl(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return cx(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${a}`)}default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function t0(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),et(e,t)}function bI(e,t){switch(e.rank){case 1:return Jv([e,t]);case 2:return Qv([e,t],0);case 3:return ew([e,t],0);case 4:return tw([e,t],0);default:throw new V(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Wx(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new V(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return On(e,t)}function bf(e,t=0,n=1,a,r){return Xm(e,t,n,a,r)}function or(e,t,n,a){if(e.rank<2||t.rank<2)throw new ze(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(r!==s)throw new ze(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Vl.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Bx(e.rank,a,Ga()):null,activation:n});{let r=e.shape.slice(),s=r.pop();e=W(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],p=Array.from({length:t.rank},(c,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=W(De(t,p),[l,-1]);let d=[...r,...u];return W(Vl.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Bx(e.rank,a,Ga()):null,activation:n}),d)}}function v2(e,t,n){return O(()=>(Array.isArray(t)?t=je(t,\"int32\"):t=re(t,\"int32\"),np(e,t,n)))}function kd(e){return z(e,e)}function Bx(e,t,n){let a=t.shape;if(t.rank!==1&&t.rank!==e)throw new V(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n===\"channelsFirst\")return a.length===1?W(t,[1,a[0],1,1,1]):W(t,[1,a[3],a[0],a[1],a[2]]);if(n===\"channelsLast\")return a.length===1?W(t,[1,1,1,1,a[0]]):W(t,[1].concat(a))}else if(e===4){if(n===\"channelsFirst\")return a.length===1?W(t,[1,a[0],1,1]):W(t,[1,a[2],a[0],a[1]]);if(n===\"channelsLast\")return a.length===1?W(t,[1,1,1,a[0]]):W(t,[1].concat(a))}else if(e===3){if(n===\"channelsFirst\")return a.length===1?W(t,[1,a[0],1]):W(t,[1,a[1],a[0]]);if(n===\"channelsLast\")return a.length===1?W(t,[1,1,a[0]]):W(t,[1].concat(a))}else if(e<3)return t;throw new V(`Unsupported input rank by biasAdd: ${t.rank}`)}function Ka(e,t,n){return O(()=>(n==null&&(n=Ga()),Rt(n),X(e,Bx(e.rank,t,n))))}function FG(e,t=1){if(t!==1)throw new ze(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Qu(e)}function $G(e){return O(()=>he(e,X(Lt(e),1)))}function w2(e,t,n,a){return O(()=>Pw(e,t,n,a))}function DG(e){return O(()=>{let t=X(.5,z(.2,e));return an(t,0,1)})}function Id(e,t,n=!1){return n?e():t()}var RG=[\"fanIn\",\"fanOut\",\"fanAvg\"],MG=[\"normal\",\"uniform\",\"truncatedNormal\"];function OG(e){Ko(RG,\"FanMode\",e)}function PG(e){Ko(MG,\"Distribution\",e)}var $a=class extends ne.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},n0=class extends $a{apply(e,t){return It(e,t)}};n0.className=\"Zeros\";ne.registerClass(n0);var yf=class extends $a{apply(e,t){return Pn(e,t)}};yf.className=\"Ones\";ne.registerClass(yf);var a0=class extends $a{constructor(e){if(super(),typeof e!=\"object\")throw new V(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new V(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return O(()=>z(xe(this.value),Pn(e,t)))}getConfig(){return{value:this.value}}};a0.className=\"Constant\";ne.registerClass(a0);var r0=class extends $a{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Es(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};r0.className=\"RandomUniform\";ne.registerClass(r0);var s0=class extends $a{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||\"float32\",t!==\"float32\"&&t!==\"int32\")throw new ze(`randomNormal does not support dType ${t}.`);return bf(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};s0.className=\"RandomNormal\";ne.registerClass(s0);var i0=class extends $a{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||\"float32\",t!==\"float32\"&&t!==\"int32\")throw new ze(`truncatedNormal does not support dType ${t}.`);return lf(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};i0.className=\"TruncatedNormal\";ne.registerClass(i0);var o0=class extends $a{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return O(()=>{if(e.length!==2||e[0]!==e[1])throw new V(\"Identity matrix initializer can only be used for 2D square matrices.\");return z(this.gain,Gm(e[0]))})}getConfig(){return{gain:this.gain}}};o0.className=\"Identity\";ne.registerClass(o0);function LG(e,t=\"channelsLast\"){let n,a;if(Rt(t),e.length===2)n=e[0],a=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t===\"channelsFirst\"){let r=rs(e,2);n=e[1]*r,a=e[0]*r}else if(t===\"channelsLast\"){let r=rs(e,0,e.length-2);n=e[e.length-2]*r,a=e[e.length-1]*r}}else{let r=rs(e);n=Math.sqrt(r),a=Math.sqrt(r)}return[n,a]}var Bn=class extends $a{constructor(e){if(super(),e.scale<0)throw new V(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?\"fanIn\":e.mode,OG(this.mode),this.distribution=e.distribution==null?\"normal\":e.distribution,PG(this.distribution),this.seed=e.seed}apply(e,t){let n=LG(e),a=n[0],r=n[1],s=this.scale;if(this.mode===\"fanIn\"?s/=Math.max(1,a):this.mode===\"fanOut\"?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),this.distribution===\"normal\"){let i=Math.sqrt(s);if(t=t||\"float32\",t!==\"float32\"&&t!==\"int32\")throw new ze(`${this.getClassName()} does not support dType ${t}.`);return lf(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return Es(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Bn.className=\"VarianceScaling\";ne.registerClass(Bn);var xf=class extends Bn{constructor(e){super({scale:1,mode:\"fanAvg\",distribution:\"uniform\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};xf.className=\"GlorotUniform\";ne.registerClass(xf);var vf=class extends Bn{constructor(e){super({scale:1,mode:\"fanAvg\",distribution:\"normal\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};vf.className=\"GlorotNormal\";ne.registerClass(vf);var wf=class extends Bn{constructor(e){super({scale:2,mode:\"fanIn\",distribution:\"normal\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};wf.className=\"HeNormal\";ne.registerClass(wf);var kf=class extends Bn{constructor(e){super({scale:2,mode:\"fanIn\",distribution:\"uniform\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};kf.className=\"HeUniform\";ne.registerClass(kf);var If=class extends Bn{constructor(e){super({scale:1,mode:\"fanIn\",distribution:\"normal\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};If.className=\"LeCunNormal\";ne.registerClass(If);var Sf=class extends Bn{constructor(e){super({scale:1,mode:\"fanIn\",distribution:\"uniform\",seed:e==null?null:e.seed})}getClassName(){return Bn.className}};Sf.className=\"LeCunUniform\";ne.registerClass(Sf);var l0=class extends $a{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return O(()=>{if(e.length<2)throw new ze(\"Shape must be at least 2D.\");if(t!==\"int32\"&&t!==\"float32\"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=w.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);let s=[Math.max(a,n),Math.min(a,n)],i=bf(s,0,1,t,this.seed),o=Bw.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return l=z(l,u.sign()),n<a&&(l=l.transpose()),z(xe(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};l0.className=\"Orthogonal\";ne.registerClass(l0);var yI={constant:\"Constant\",glorotNormal:\"GlorotNormal\",glorotUniform:\"GlorotUniform\",heNormal:\"HeNormal\",heUniform:\"HeUniform\",identity:\"Identity\",leCunNormal:\"LeCunNormal\",leCunUniform:\"LeCunUniform\",ones:\"Ones\",orthogonal:\"Orthogonal\",randomNormal:\"RandomNormal\",randomUniform:\"RandomUniform\",truncatedNormal:\"TruncatedNormal\",varianceScaling:\"VarianceScaling\",zeros:\"Zeros\"};function xI(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"initializer\")}function Et(e){return Qw(e)}function St(e){if(typeof e==\"string\"){let t=e in yI?yI[e]:e;if(t===\"GlorotNormal\")return new vf;if(t===\"GlorotUniform\")return new xf;if(t===\"HeNormal\")return new wf;if(t===\"HeUniform\")return new kf;if(t===\"LeCunNormal\")return new If;if(t===\"LeCunUniform\")return new Sf;{let n={};return n.className=t,n.config={},xI(n)}}else return e instanceof $a?e:xI(e)}function Vx(e){return Array.isArray(e)&&Array.isArray(e[0])}function Zh(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Te(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new V(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Je(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new V(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function Jh(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((a,r)=>a*r);return t}var vI=\"Variable\",k2=class{constructor(e,t=\"float32\",n=vI,a=!0,r=null){this.dtype=t==null?\"float32\":t,this.shape=e.shape,this.id=f2(),n=n==null?vI:n,this.originalName=b2(n),this.name=y2(this.originalName),this.trainable_=a,this.constraint=r,this.val=Mw(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),zG(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function zG(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error(\"Shape mismatch: \"+JSON.stringify(e.shape)+\" vs. \"+JSON.stringify(t.shape))}function Ux(e){return e.map(t=>t.read())}function u0(e){e.forEach(t=>{t[0].write(t[1])})}var zt=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Ha=class{constructor(e,t,n,a,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=i,this.id=f2(),s!=null&&(this.originalName=b2(s),this.name=y2(this.originalName)),this.rank=t.length}},WG=0,Nf=class{constructor(e,t){this.callArgs=t,this.id=WG++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},BG=0,We=class extends ne.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=BG++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Ir(n)+\"_\"+gf(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),n=[r].concat(e.inputShape)}this.batchInputShape=n;let a=e.dtype;a==null&&(a=e.inputDType),a==null&&(a=\"float32\"),this.dtype=a}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+\"_ib-\"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new ar(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new V(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Mn(this.getNodeAtIndex(e,\"input\").inputTensors)}getOutputAt(e){return Mn(this.getNodeAtIndex(e,\"output\").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Xr(`Layer ${this.name} has multiple inbound nodes, hence the notion of \"layer input\" is ill-defined. Use \\`getInputAt(nodeIndex)\\` instead.`);if(this.inboundNodes.length===0)throw new Xr(`Layer ${this.name} is not connected, no input to return.`);return Mn(this.getNodeAtIndex(0,\"input\").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Xr(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Xr(`Layer ${this.name} has multiple inbound nodes, hence the notion of \"layer output\" is ill-defined. Use \\`getOutputAt(nodeIndex)\\` instead.`);return Mn(this.getNodeAtIndex(0,\"output\").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error(\"Cannot call the resetStates() method of a non-stateful Layer object.\")}assertInputCompatibility(e){let t=it(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=it(this.inputSpec);if(t.length!==n.length)throw new V(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let a=0;a<t.length;a++){let r=t[a],s=n[a];if(s==null)continue;let i=r.rank;if(s.ndim!=null&&i!==s.ndim)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new V(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let l in s.axes){let u=Number(l),p=s.axes[l],d=u>=0?o[u]:o[o.length+u];if(p!=null&&[p,null].indexOf(d)===-1)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${p} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],u=r.shape[o];if(l!=null&&u!=null&&l!==u)throw new V(`Input ${a} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=it(e),a=GG(e),r=HG(e);if(a===r)throw new V(\"Arguments to apply() must be all SymbolicTensors or all Tensors\");return ri(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of it(e))s.push(i.shape);this.build(Mn(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=it(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=Mn(o),this.activityRegularizer!=null)throw new ze(\"Layer invocation in the presence of activity regularizer(s) is not supported yet.\");return s}else{let s=VG(e),i=this.computeOutputShape(s),o,l=UG(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((u,p)=>new Ha(l,u,this,it(e),t,this.name,p)):o=new Ha(l,i,this,it(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new ze(\"Layer invocation in the presence of activity regularizer(s) is not supported yet.\");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,a)=>{n!=null&&e[a]!=null&&e[a]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Xr(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Xr(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of \"output shape\" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ar(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Jh(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Ux(e?this.trainableWeights:this.weights)}setWeights(e){O(()=>{let t=this.weights;if(t.length!==e.length)throw new V(`You called setWeights(weights) on layer \"${this.name}\" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],a=Ux(t);for(let r=0;r<a.length;++r){let s=a[r],i=t[r],o=e[r];if(!w.arraysEqual(s.shape,o.shape))throw new V(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}u0(n)})}addWeight(e,t,n,a,r,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new V(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n=\"float32\"),this.fastWeightInitDuringBuild&&(a=o!=null?o():St(\"zeros\"));let l=a.apply(t,n),u=new k2(l,n,e,s,i);return l.dispose(),r!=null&&this.addLoss(()=>r.apply(u.read())),s==null&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=it(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let a=this.computeMask(e,n),r=it(t),s=it(a);if(r.length!==s.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let i=0;i<r.length;i++)r[i].kerasMask=s[i]}addInboundNode(e,t,n,a,r,s,i=null){let o=it(e);t=it(t),n=it(n),a=it(a),r=Zh(r),s=Zh(s);let l=[],u=[],p=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),p.push(d.tensorIndex);new Nf({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:p,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function VG(e){e=it(e);let t=[];for(let n of e)t.push(n.shape);return Mn(t)}function UG(e){return\"float32\"}function I2(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let a=t.inboundNodes[n];if(a.inboundLayers.length===0)return a.inputTensors;{let r=[];for(let s=0;s<a.inboundLayers.length;s++){let i=a.inputTensors[s],o=a.inboundLayers[s],l=a.nodeIndices[s],u=I2(i,o,l);for(let p of u)r.indexOf(p)===-1&&r.push(p)}return r}}}function GG(e){let t=!0;for(let n of it(e))if(!(n instanceof Ha)){t=!1;break}return t}function HG(e){let t=!0;for(let n of it(e))if(n instanceof Ha){t=!1;break}return t}var rp=class extends We{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:gf(\"input\").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new V(\"Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.\");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new V(\"An InputLayer should be passed either a `batchInputShape` or an `inputShape`.\");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new V(\"Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.\");let n=e.dtype||\"float32\";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let a=new Ha(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new V(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};rp.className=\"InputLayer\";ne.registerClass(rp);function S2(e){if(e.batchShape==null&&e.shape==null)throw new Error(\"Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.\");if(e.batchShape!=null&&e.shape!=null)throw new V(\"Please provide either a `shape` or `batchShape` argument to Input, but not both.\");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n=\"float32\"),new rp({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function jG(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return re(t,e.dtype)}catch(n){throw new V(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Cl=class N2{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof N2)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,a){if(this.id2Value[t.id]==null)this.id2Value[t.id]=jG(t,n),this.name2Id[t.name]=t.id,a!=null&&(this.id2Mask[t.id]=a);else throw new V(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Ha){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Ha){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Ee(this.id2Mask)}},Qh=new d2,em=new d2;function qG(e){Qh!=null&&Qh.setMaxEntries(e),em!=null&&em.setMaxEntries(e)}function tc(e,t,n,a){let r=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(m=>m.name),l=[],u=t.names();for(let m of o)u.indexOf(m)!==-1?l.push(t.getValue(m)):l.push(null);a!=null&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);let p=o.join(\",\")+\"|\"+t.names().sort().join(\",\"),d=Qh.get(p),c;if(d==null){let m=KG(i,t);d=m.sorted,c=m.recipientCounts,Qh.put(p,d),em.put(p,c)}c={},r||Object.assign(c,em.get(p));let h=new Cl(t);for(let m=0;m<d.length;++m){if(a!=null){let F=Kh().numTensors;F>a.maxNumTensors&&(a.maxNumTensors=F),F<a.minNumTensors&&(a.minNumTensors=F)}let f=d[m],g=f.sourceLayer;if(g instanceof rp)continue;let b=[],y=[],x=[],v=!1;for(let F of f.inputs){let D=h.getValue(F),$=h.getMask(F);b.push(D),y.push($),$!=null&&(v=!0),r||(c[F.name]--,c[F.name]===0&&!t.hasKey(F)&&o.indexOf(F.name)===-1&&!D.isDisposed&&F.sourceLayer.stateful!==!0&&x.push(D))}v&&(n=n||{},n.mask=y[0]);let I=it(g.apply(b,n)),N=null;g.supportsMasking&&(N=g.computeMask(b,y));let C=YG(f),_=Array.isArray(C)?C:[C];for(let F=0;F<_.length;++F){h.hasKey(_[F])||h.add(_[F],I[F],Array.isArray(N)?N[0]:N);let D=o.indexOf(_[F].name);D!==-1&&(l[D]=I[F])}r||Ee(x)}return h.disposeMasks(),s?l:l[0]}function KG(e,t){w.assert(e!=null&&e.length>0,()=>\"Expected at least one fetch, got none\");let n=[],a={};if(e.length===1){let r=wI(e[0],t);n=r.sorted,a=r.recipientMap}else{let r=new Set;for(let s of e){let{sorted:i,recipientMap:o}=wI(s,t);for(let l of i)r.has(l.name)||(n.push(l),r.add(l.name));for(let l in o)a[l]==null&&(a[l]=new Set),o[l].forEach(u=>a[l].add(u))}}return{sorted:n,recipientCounts:XG(a)}}function XG(e){let t={};for(let n in e)t[n]=e[n].size;return t}function wI(e,t){let n=new Set,a=[],r={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),a.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let u of o.inputs)r[u.name]==null&&(r[u.name]=new Set),r[u.name].add(o.name),!n.has(u.name)&&s.push(u)}}return{sorted:a,recipientMap:r}}function YG(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let a=0;a<e.sourceLayer.inboundNodes.length;++a)for(let r of e.sourceLayer.inboundNodes[a].outputTensors)if(r.id===e.id){n=a;break}t=e.sourceLayer.getOutputAt(n)}return t}var ZG=G();ZG.registerFlag(\"TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES\",()=>100,qG);var T2={};_e(T2,{maxNorm:()=>JG,minMaxNorm:()=>tH,nonNeg:()=>eH,unitNorm:()=>QG});function p0(e,t){return O(()=>rn(fe(z(e,e),t,!0)))}var Sd=class extends ne.Serializable{getConfig(){return{}}},c0=class extends Sd{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>{let t=p0(e,this.axis),n=an(t,0,this.maxValue);return z(e,he(n,X(qt(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};c0.className=\"MaxNorm\";ne.registerClass(c0);var d0=class extends Sd{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>he(e,X(qt(),p0(e,this.axis))))}getConfig(){return{axis:this.axis}}};d0.className=\"UnitNorm\";ne.registerClass(d0);var h0=class extends Sd{apply(e){return Ke(e)}};h0.className=\"NonNeg\";ne.registerClass(h0);var m0=class extends Sd{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return O(()=>{let t=p0(e,this.axis),n=X(z(this.rate,an(t,this.minValue,this.maxValue)),z(1-this.rate,t));return z(e,he(n,X(qt(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};m0.className=\"MinMaxNorm\";ne.registerClass(m0);var kI={maxNorm:\"MaxNorm\",minMaxNorm:\"MinMaxNorm\",nonNeg:\"NonNeg\",unitNorm:\"UnitNorm\"};function Xt(e){return Qw(e)}function II(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"constraint\")}function Yt(e){if(e==null)return null;if(typeof e==\"string\"){let t={className:e in kI?kI[e]:e,config:{}};return II(t)}else return e instanceof Sd?e:II(e)}function JG(e){return new c0(e)}function QG(e){return new d0(e)}function eH(){return new h0}function tH(e){return new m0(e)}var C2={};_e(C2,{constant:()=>rH,glorotNormal:()=>cH,glorotUniform:()=>pH,heNormal:()=>dH,heUniform:()=>hH,identity:()=>lH,leCunNormal:()=>mH,leCunUniform:()=>fH,ones:()=>aH,orthogonal:()=>gH,randomNormal:()=>iH,randomUniform:()=>sH,truncatedNormal:()=>oH,varianceScaling:()=>uH,zeros:()=>nH});function nH(){return new n0}function aH(){return new yf}function rH(e){return new a0(e)}function sH(e){return new r0(e)}function iH(e){return new s0(e)}function oH(e){return new i0(e)}function lH(e){return new o0(e)}function uH(e){return new Bn(e)}function pH(e){return new xf(e)}function cH(e){return new vf(e)}function dH(e){return new wf(e)}function hH(e){return new kf(e)}function mH(e){return new If(e)}function fH(e){return new Sf(e)}function gH(e){return new l0(e)}var E2={};_e(E2,{Layer:()=>We,RNN:()=>Mr,RNNCell:()=>Td,activation:()=>qj,add:()=>n6,alphaDropout:()=>z6,average:()=>a6,averagePooling1d:()=>T1,averagePooling2d:()=>C1,averagePooling3d:()=>E1,avgPool1d:()=>d6,avgPool2d:()=>m6,avgPool3d:()=>g6,avgPooling1d:()=>h6,avgPooling2d:()=>f6,avgPooling3d:()=>b6,batchNormalization:()=>u6,bidirectional:()=>F6,categoryEncoding:()=>G6,centerCrop:()=>V6,concatenate:()=>r6,conv1d:()=>Lj,conv2d:()=>zj,conv2dTranspose:()=>Wj,conv3d:()=>Bj,conv3dTranspose:()=>Vj,convLstm2d:()=>C6,convLstm2dCell:()=>E6,cropping2D:()=>Gj,dense:()=>Kj,depthwiseConv2d:()=>jj,dot:()=>l6,dropout:()=>Xj,elu:()=>$j,embedding:()=>t6,flatten:()=>Zj,gaussianDropout:()=>L6,gaussianNoise:()=>P6,globalAveragePooling1d:()=>y6,globalAveragePooling2d:()=>x6,globalMaxPool1d:()=>D6,globalMaxPool2d:()=>R6,globalMaxPooling1d:()=>AC,globalMaxPooling2d:()=>FC,gru:()=>w6,gruCell:()=>k6,input:()=>j2,inputLayer:()=>Fj,layerNormalization:()=>p6,leakyReLU:()=>Rj,lstm:()=>I6,lstmCell:()=>S6,masking:()=>W6,maxPool1d:()=>M6,maxPool2d:()=>O6,maxPooling1d:()=>$C,maxPooling2d:()=>DC,maxPooling3d:()=>v6,maximum:()=>s6,minimum:()=>i6,multiply:()=>o6,permute:()=>e6,prelu:()=>Mj,randomWidth:()=>H6,reLU:()=>Dj,repeatVector:()=>Jj,rescaling:()=>B6,reshape:()=>Qj,resizing:()=>U6,rnn:()=>_6,separableConv2d:()=>Uj,simpleRNN:()=>N6,simpleRNNCell:()=>T6,softmax:()=>Oj,spatialDropout1d:()=>Yj,stackedRNNCells:()=>A6,thresholdedReLU:()=>Pj,timeDistributed:()=>$6,upSampling2d:()=>Hj,zeroPadding2d:()=>c6});async function Kr(e){if(e==null)return;let t=[],n=[],a=[];for(let r in e){let s=e[r];if(typeof s!=\"number\"){let i=s;t.push(i.data()),n.push(r),a.push(i)}}if(t.length>0){let r=await Promise.all(t);for(let s=0;s<r.length;++s)e[n[s]]=r[s][0];Ee(a)}}function _2(e){if(e!=null)for(let t in e){let n=e[t];typeof n!=\"number\"&&n.dispose()}}var SI;(function(e){e[e.SILENT=0]=\"SILENT\",e[e.VERBOSE=1]=\"VERBOSE\"})(SI||(SI={}));var bH=125,Gl=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},A2=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},yH=class extends Gl{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let a in t){let r=t[a];if(typeof r==\"number\")this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+r*n;else{let s;a in this.totals?s=this.totals[a]:this.totals[a]=0;let i=O(()=>X(this.totals[a],z(r,n)));this.totals[a]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]==\"number\"?t[n]=this.totals[n]/this.seen:O(()=>{let a=z(he(1,this.seen),this.totals[n]);t[n]=a,this.totals[n].dispose(),Ht(t[n])}))}},F2=class extends Gl{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let s=this.history[r];for(let i=0;i<s.length;++i)if(typeof s[i]!=\"number\"){let o=s[i];e.push(o.data()),t.push(r),n.push(i)}}let a=await Promise.all(e);for(let r=0;r<a.length;++r)this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}},$2=class extends Gl{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Zw,this.yieldEvery=t||\"auto\",this.yieldEvery===\"auto\"&&(this.yieldEvery=bH),this.yieldEvery===\"never\"&&e.onYield!=null)throw new Error(\"yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback\");w.isNumber(this.yieldEvery)&&(this.maybeWait=bG(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let a=[];this.yield!=null&&(await Kr(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Kr(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Kr(t),n.push(this.epochEnd(e,t))),this.yieldEvery===\"epoch\"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Kr(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Kr(t),n.push(this.batchEnd(e,t))),this.yieldEvery===\"batch\"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Kr(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Kr(e),await this.trainEnd(e))}};function D2(e,t){return e==null&&(e={}),e instanceof Gl?[e]:Array.isArray(e)&&e[0]instanceof Gl?e:it(e).map(n=>new $2(n,t))}var f0=class Ja{constructor(){}static registerCallbackConstructor(t,n){w.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Ja.checkForDuplicate(n),Ja.constructors[t]==null&&(Ja.constructors[t]=[]),Ja.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Ja.constructors)Ja.constructors[+n].forEach(a=>{if(a===t)throw new V(\"Duplicate callback constructor.\")})}static clear(){Ja.constructors={}}static createCallbacks(t){let n=[];for(let a in Ja.constructors){let r=+a;t>=r&&n.push(...Ja.constructors[r])}return n.map(a=>new a)}};f0.constructors={};function R2(e,t,n,a,r,s,i,o,l){let u=new F2,p=[new yH,...f0.createCallbacks(t)];e!=null&&p.push(...e),p.push(u);let d=new A2(p);return d.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function Ba(e,t={},n=!1){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"layer\",n)}function tm(e,t){return O(()=>{e.dtype!==\"float32\"&&(e=re(e,\"float32\"));let n=fe(kd(e),t,!0),a=yn(n.shape,qt()),r=rn(hr(n,a));return he(e,r)})}function Xo(e,t){return O(()=>Ct(kd(pe(t,e)),-1))}function Tf(e,t){return O(()=>Ct(Lt(pe(t,e)),-1))}function sp(e,t){return O(()=>{let n=pe(e,t),a=an(Lt(e),qt(),Number.MAX_VALUE),r=Lt(he(n,a));return z(100,Ct(r,-1))})}function xH(e,t){return O(()=>{let n=an(t,qt(),Number.MAX_VALUE),a=Qn(X(1,n)),r=an(e,qt(),Number.MAX_VALUE),s=Qn(X(1,r));return Ct(kd(pe(a,s)),-1)})}function vH(e,t){return O(()=>{let n=hr(0,pe(1,z(e,t)));return Ct(kd(n),-1)})}function wH(e,t){return O(()=>{let n=hr(0,pe(1,z(e,t)));return Ct(n,-1)})}function kH(e,t){return O(()=>{let n=fe(z(e,t),-1),a=ma(z(pe(1,e),t),-1);return hr(0,X(1,pe(a,n)))})}function IH(e,t){return O(()=>{let n=Math.log(2),a=pe(t,e),r=pe(X(a,Go(z(-2,a))),n);return Ct(r,-1)})}function kc(e,t,n=!1){return O(()=>{if(n)t=qa(t);else{let a=fe(t,t.shape.length-1,!0);t=he(t,a)}return t=an(t,qt(),1-qt()),yt(fe(z(re(e,\"float32\"),Qn(t)),t.shape.length-1))})}function nm(e,t,n=!1){return O(()=>{let a=re(tp(_G(e)),\"int32\");t=an(t,qt(),1-qt());let r=t.shape,s=W(Ll(a,r[r.length-1]),r);return kc(s,t,n)})}function SH(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new V(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return O(()=>{let n=Ke(t),a=yt(Lt(t));return X(pe(n,z(t,e)),pd(dn(a)))})}function Cf(e,t){return O(()=>{let n;return n=an(t,qt(),1-qt()),n=Qn(he(n,pe(1,n))),Ct(SH(e,n),-1)})}function NH(e,t){return O(()=>{let n=an(e,qt(),1),a=an(t,qt(),1);return fe(z(e,Qn(he(n,a))),-1)})}function TH(e,t){return O(()=>{let n=Qn(X(qt(),t));return Ct(pe(t,z(e,n)),-1)})}function g0(e,t){return O(()=>{let n=tm(e,-1),a=tm(t,-1),r=z(n,a);return yt(fe(r,-1))})}var am={meanSquaredError:Xo,meanAbsoluteError:Tf,meanAbsolutePercentageError:sp,meanSquaredLogarithmicError:xH,squaredHinge:vH,hinge:wH,categoricalHinge:kH,logcosh:IH,categoricalCrossentropy:kc,sparseCategoricalCrossentropy:nm,binaryCrossentropy:Cf,kullbackLeiblerDivergence:NH,poisson:TH,cosineProximity:g0};function dx(e){if(typeof e==\"string\"){if(e in am)return am[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes(\"softmaxcrossentropy\")&&(t=`Unknown loss ${e}. Use \"categoricalCrossentropy\" as the string name for tf.losses.softmaxCrossEntropy`),new V(t)}else return e}function b0(e,t){return O(()=>{let n=z(.5,ea(t)),a=ir(Cn(t,n),e.dtype);return Ct(Jn(e,a),-1)})}function y0(e,t){return O(()=>ir(Jn(di(e,-1),di(t,-1)),\"float32\"))}function M2(e,t){return O(()=>re(fe(_a(Jn(e,1),Jn(t,1))),\"float32\"))}function CH(e,t){return O(()=>re(fe(_a(Jn(e,1),Jn(t,0))),\"float32\"))}function EH(e,t){return O(()=>re(fe(_a(Jn(e,0),Jn(t,1))),\"float32\"))}function O2(e,t){return O(()=>{let n=M2(e,t),a=EH(e,t),r=X(n,a);return re(nn(Cn(r,0),he(n,r),0),\"float32\")})}function _H(e,t){return O(()=>{let n=M2(e,t),a=CH(e,t),r=X(n,a);return re(nn(Cn(r,0),he(n,r),0),\"float32\")})}function P2(e,t){return Cf(e,t)}function L2(e,t){return e.rank===t.rank&&(e=As(e,[e.rank-1])),t=di(t,-1),t.dtype!==e.dtype&&(t=re(t,e.dtype)),re(Jn(e,t),\"float32\")}function AH(e,t){return O(()=>{let n=e.sub(t).square().sum(),a=e.sub(e.mean()).square().sum();return xe(1).sub(n.div(a))})}var FH=Xo,$H=Xo,DH=Tf,RH=Tf,MH=sp,OH=sp,x0=kc,PH=g0,z2=nm,rm={binaryAccuracy:b0,categoricalAccuracy:y0,precision:O2,categoricalCrossentropy:x0,sparseCategoricalCrossentropy:z2,mse:FH,MSE:$H,mae:DH,MAE:RH,mape:MH,MAPE:OH,cosine:PH};function LH(e){if(typeof e==\"string\"&&e in rm)return rm[e];if(typeof e!=\"string\"&&e!=null)return e;throw new V(`Unknown metric ${e}`)}function Sh(e){if(tr(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e==\"string\")return e;{let t;for(let n of Object.keys(am))if(am[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(rm))if(rm[n]===e){t=n;break}return t!==void 0?t:e.name}}function zH(e){let t={Adagrad:()=>Xs.adagrad(.01),Adadelta:()=>Xs.adadelta(1,.95,qt()),Adam:()=>Xs.adam(.001,.9,.999,qt()),Adamax:()=>Xs.adamax(.002,.9,.999,qt(),0),RMSProp:()=>Xs.rmsprop(.001,.9,0,qt()),SGD:()=>Xs.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new V(`Unknown Optimizer ${e}`)}function NI(e,t,n=!1){if(e==null||typeof e!=\"object\"||Object.getPrototypeOf(e)!==Object.prototype||!Gx(e))throw new Error(\"User-defined metadata is expected to be a JSON object, but is not.\");if(n){let a=JSON.stringify(e);a.length>1048576&&console.warn(`User-defined metadata of model \"${t}\" is too large in size (length=${a.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Gx(e){if(e===null)return!0;if(typeof e==\"object\")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!=\"string\"||!Gx(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!Gx(t))return!1;return!0}else return!1;else{let t=typeof e;return t===\"string\"||t===\"number\"||t===\"boolean\"}}function WH(e,t,n,a=console.log){let r=VH(e),s=[\"Layer (type)\",\"Input Shape\",\"Output shape\",\"Param #\"];r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(p=>Math.floor(t*p)));let i;if(!r){s.push(\"Receives inputs\"),i=[];for(let p in e.nodesByDepth)i.push(...e.nodesByDepth[p])}a(\"_\".repeat(t)),sm(s,n,a),a(\"=\".repeat(t));let o=e.layers;for(let p=0;p<o.length;++p)r?UH(o[p],n,a):GH(o[p],n,i,a),a((p===o.length-1?\"=\":\"_\").repeat(t));e.checkTrainableWeightsConsistency();let l=BH(e),u=Jh(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a(\"_\".repeat(t))}function BH(e){let t;return e.collectedTrainableWeights!=null?t=Jh(e.collectedTrainableWeights):t=Jh(e.trainableWeights),t}function VH(e){let t=!0,n=[],a=[];for(let r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(let r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(let r of e.layers){let s=!1;for(let i of r.inboundNodes)if(a.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function sm(e,t,n=console.log){let a=\"\";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+\" \"),a+=e[r],a=a.slice(0,t[r]),a+=\" \".repeat(t[r]-a.length);n(a)}function UH(e,t,n){let a,r;try{r=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(\",\")}catch(l){r=\"multiple\"}try{a=JSON.stringify(e.outputShape)}catch(l){a=\"multiple\"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,r,a,e.countParams().toString()];sm(o,t,n)}function GH(e,t,n,a){let r,s;try{s=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(\",\")}catch(d){s=\"multiple\"}try{r=JSON.stringify(e.outputShape)}catch(d){r=\"multiple\"}let i=[];for(let d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let c=0;c<d.inboundLayers.length;++c){let h=d.inboundLayers[c].name,m=d.nodeIndices[c],f=d.tensorIndices[c];i.push(`${h}[${m}][${f}]`)}let o=e.name,l=e.getClassName(),u=i.length===0?\"\":i[0],p=[`${o} (${l})`,s,r,e.countParams().toString(),u];sm(p,t,a);for(let d=1;d<i.length;++d)sm([\"\",\"\",\"\",\"\",i[d]],t,a)}function W2(e,t,n){return(e===\"inboundNodes\"||e===\"outputLayers\"||e===\"inputLayers\")&&t===0&&typeof n==\"string\"}function Ic(e,t){if(e===null)return null;if(typeof e==\"string\")return Js(e);if(typeof e==\"number\"||typeof e==\"boolean\")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];W2(t,r,s)?n.push(s):n.push(Ic(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a];if(a===\"name\"&&typeof r==\"string\")n[a]=r;else{let s=Js(a);n[s]=Ic(r,s)}}return n}}function Hx(e,t){if(e==null)return null;if(typeof e==\"string\")return Ir(e);if(typeof e==\"number\"||typeof e==\"boolean\")return e;if(e instanceof Array){let n=[],a=e.length;for(let r=0;r<a;++r){let s=e[r];W2(t,r,s)?n.push(s):n.push(Hx(s,t))}return n}else{let n={};for(let a of Object.keys(e)){let r=e[a],s=Ir(a);(a===\"name\"||a===\"className\")&&typeof r==\"string\"?n[s]=r:n[s]=Hx(r,a)}return n}}var v0=\"4.22.0\",HH=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split(\"/\");return!isNaN(parseInt(n[n.length-1],10))},jH=class Qa extends We{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=gf(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],as(this.inputs).length!==this.inputs.length)throw new V(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);as(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let x=y.sourceLayer,v=y.nodeIndex,I=y.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(I)}for(let y of this.inputs){let x=y.sourceLayer,v=y.nodeIndex,I=y.tensorIndex;tr(v===0,\"input layer has >1 nodes\"),tr(I===0,\"input layer has >1 tensors\"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let x=this.inputLayers[y];if(!(x instanceof rp))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${y} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let n={},a={},r={},s={},i={},o=[],l=(y,x,v,I,N,C)=>{(I==null||N==null||C==null)&&(I=y.sourceLayer,N=y.nodeIndex,C=y.tensorIndex);let _=I.inboundNodes[N];if(v.indexOf(_)!==-1)throw new ar(`The tensor ${y.name} at layer \"${I.name}\" is part of a cycle.`);if(x.indexOf(_)!==-1)return;this.containerNodes.add(Qa.nodeKey(I,N)),I.id in i||(i[I.id]=Object.keys(i).length),v.indexOf(_)===-1&&v.push(_);let F=_.inboundLayers.length;for(let D=0;D<F;D++){let $=_.inputTensors[D],S=_.inboundLayers[D],M=_.nodeIndices[D],B=_.tensorIndices[D];l($,x,v,S,M,B)}for(x.push(_);v.indexOf(_)>=0;)v.splice(v.indexOf(_),1);o.push(_)},u=[],p=[];for(let y of this.outputs)l(y,u,p);let d=o.slice().reverse();for(let y of d){a[y.id]=y,y.id in n||(n[y.id]=0);let x=n[y.id],v=r[y.outboundLayer.id]==null?0:r[y.outboundLayer.id];x=Math.max(x,v),r[y.outboundLayer.id]=x,s[y.outboundLayer.id]=y.outboundLayer,n[y.id]=x;for(let I=0;I<y.inboundLayers.length;I++){let N=y.inboundLayers[I],C=y.nodeIndices[I],_=N.inboundNodes[C],F=n[_.id]==null?0:n[_.id];n[_.id]=Math.max(x+1,F),a[_.id]=_}}let c={};for(let y in n){let x=n[y];x in c||(c[x]=[]),c[x].push(a[y])}let h={};for(let y in r){let x=r[y];x in h||(h[x]=[]),h[x].push(s[y])}let m=Object.keys(h).map(y=>parseInt(y,10)).sort(wh);this.layers=[];for(let y of m){let x=h[y];x.sort((v,I)=>{let N=i[v.id],C=i[I.id];return N<C?-1:N>C?1:0});for(let v of x)v instanceof Qa&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=h,m=Object.keys(c).map(y=>parseInt(y,10)).sort(wh);let f=this.inputs.slice(),g=[];for(let y of m)for(let x of c[y]){let v=x.outboundLayer;if(v!=null){for(let I of x.inputTensors)if(f.indexOf(I)===-1)throw new ar(`Graph disconnected: cannot obtain value for tensor ${I} at layer \"${v.name}\". The following previous layers were accessed without issue: ${g}`);for(let I of x.outputTensors)f.push(I);g.push(v.name)}}this.nodesByDepth=c;let b=this.layers.map(y=>y.name);for(let y of b){let x=b.filter(v=>v===y).length;if(x!==1)throw new ar(`The name \"${y}\" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(a=>a.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new V(\"Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.\");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let a of this.layers)n.push(...a.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let a={},r=0,s=HH(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let p=s?`${u.name.split(\"/\").slice(0,-1).join(\"/\")+\"/\"}${l}`:u.originalName;if(a[p]!=null)throw new V(`Duplicate weight name: ${p}`);a[p]=u,r++}let i=[];for(let o in t){let l=o;if(a[o]==null){let u=o.split(\"/\");l=u.slice(0,-2).concat([u[u.length-1]]).join(\"/\")}if(a[l]!=null)i.push([a[l],t[o]]);else if(n)throw new V(`Provided weight data has no target variable: ${o}`);delete a[l]}if(n){let o=[];for(let l in a)o.push(l);if(o.length>0)throw new V(`${o.length} of ${r} weights are not set: ${o}`)}u0(i)}parseWeights(t){for(let n in Object.keys(t)){let a=n.split(\"/\"),r=[\"vars\",\"layer_checkpoint_dependencies\"],s=a.map(i=>i.startsWith(\"_\")?i.slice(1):i).filter(i=>!r.includes(i)).join(\"/\");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${v0}`,n.backend=\"TensorFlow.js\",n}toJSON(t,n=!0){let a=Hx(this.updatedConfig());return n?JSON.stringify(a):a}call(t,n){return O(()=>{t=it(t);let a=new Cl;for(let r=0;r<this.inputs.length;++r)a.add(this.inputs[r],t[r]);return tc(this.outputs,a,n)})}computeMask(t,n){return O(()=>{t=it(t);let a;return n==null?a=bi(null,t.length):a=it(n),this.runInternalGraph(t,a)[1]})}computeOutputShape(t){let n=Zh(t);if(n.length!==this.inputLayers.length)throw new V(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let a={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],u=n[o],p=l.name+\"_0_0\";a[p]=u}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(wh);if(r.length>1)for(let o of r){let l=this.nodesByDepth[o];for(let u of l){let p=u.outboundLayer;if(this.inputLayers.map(f=>f.id).indexOf(p.id)!==-1)continue;let d=[];for(let f=0;f<u.inboundLayers.length;f++){let g=u.inboundLayers[f],b=u.nodeIndices[f],y=u.tensorIndices[f],x=`${g.name}_${b}_${y}`,v=a[x];d.push(v)}let c=p.computeOutputShape(Mn(d)),h=Zh(c),m=p.inboundNodes.indexOf(u);for(let f=0;f<h.length;f++){let g=`${p.name}_${m}_${f}`;a[g]=h[f]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],p=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${p}`;i.push(d)}for(let o=0;o<i.length;o++){let l=i[o];tr(l in a),s.push(a[l])}return Mn(s)}runInternalGraph(t,n){n==null&&(n=bi(null,t.length));let a={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],p=t[l],d=n[l];a[u.id]=[p,d]}let r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(wh);for(let l of r){let u=this.nodesByDepth[l];for(let p of u){let d=p.outboundLayer,c=p.inputTensors,h=p.outputTensors,m=new Array;for(let f of c)f.id in a&&m.push(a[f.id]);if(m.length===c.length){let f={},g,b,y,x;if(p.callArgs!=null&&(f=p.callArgs),m.length===1){let[v,I]=m[0];f.mask==null&&(f.mask=I),y=it(d.call(v,f)),x=it(d.computeMask(v,I)),g=[v],b=[I]}else g=m.map(v=>v[0]),b=m.map(v=>v[1]),f.mask==null&&(f.mask=b),y=it(d.call(g,f)),x=it(d.computeMask(g,b));if(d.activityRegularizer)throw new ze(\"LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.\");for(let v=0;v<h.length;++v){let I=h[v],N=y[v],C=x[v];a[I.id]=[N,C]}}}}let s=[],i=[],o=[];for(let l of this.outputs){tr(l.id in a,`Could not compute output ${l.name} : ${l.id}`);let[u,p]=a[l.id];o.push(u.shape),s.push(u),i.push(p)}return[s,i,o]}buildNodeConversionMap(t){let n={},a;for(let r of this.layers){a=r instanceof Qa?1:0;for(let s=0;s<r.inboundNodes.length;s++){let i=Qa.nodeKey(r,s);this.containerNodes.has(i)&&(n[i]=a,a+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new V(\"Provide either a layer name or layer index\");if(typeof t==\"number\")return this.findLayer(t);for(let a of this.layers)if(a.name===t)return a;throw new V(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new V(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return O(()=>{let t=[];for(let n of this.layers)for(let a=0;a<n.inboundNodes.length;++a){let r=Qa.nodeKey(n,a);this.containerNodes.has(r)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),a=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){let c=i.inboundNodes[d],h=Qa.nodeKey(i,d),m={};if(this.containerNodes.has(h)){if(c.callArgs)try{JSON.stringify(c.callArgs),m=c.callArgs}catch(f){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${c.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(c.inboundLayers.length>0){let f=[];for(let g=0;g<c.inboundLayers.length;g++){let b=c.inboundLayers[g],y=c.nodeIndices[g],x=c.tensorIndices[g],v=Qa.nodeKey(b,y),I=n[v];I==null&&(I=0),f.push([b.name,I,x,m])}u.push(f)}}}let p={};p.name=i.name,p.className=o,p.config=l,p.inboundNodes=u,a.push(p)}t.layers=a;let r=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=Qa.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let p=n[u];p==null&&(p=0);let d=this.inputLayersTensorIndices[i];r.push([o.name,p,d])}t.inputLayers=r;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=Qa.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let p=n[u];p==null&&(p=0);let d=this.outputLayersTensorIndices[i];s.push([o.name,p,d])}return t.outputLayers=s,t}static fromConfig(t,n,a={},r=!1){let s={},i={};function o(g,b){g.name in i?i[g.name].push(b):i[g.name]=[b]}function l(g,b){let y=[],x;for(let v of b){let I=v[0],N=v[1],C=v[2];if(x=v[3]==null?{}:v[3],!(I in s)){o(g,b);return}let _=s[I];if(_.inboundNodes.length<=N){o(g,b);return}let F=_.inboundNodes[N];y.push(F.outputTensors[C])}y.length>0&&g.apply(Mn(y),x)}function u(g){let b=g.name,y=Ba(g,n.customObjects!=null?n.customObjects:{});y.setFastWeightInitDuringBuild(r),s[b]=y,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new V(`Corrupted configuration, expected array for nodeData: ${x}`);o(y,x)})}let p=n.name,d=n.layers;for(let g of d)u(g);for(;!gG(i);)for(let g of d){let b=s[g.name];if(b.name in i){let y=i[b.name];delete i[b.name];for(let x of y)l(b,x)}}let c=[],h=[],m=n.inputLayers;for(let g of m){let b=g[0],y=g[1],x=g[2];tr(b in s);let v=s[b].inboundNodes[y].outputTensors;c.push(v[x])}let f=n.outputLayers;for(let g of f){let b=g[0],y=g[1],x=g[2];tr(b in s);let v=s[b].inboundNodes[y].outputTensors;h.push(v[x])}return new t({inputs:c,outputs:h,name:p})}get stateful(){if(this._stateful)throw new V(\"Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.\");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){O(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function qH(e,t,n){let a=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(a===1)return Array.isArray(e)&&e.length===1?e:typeof e==\"object\"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${a} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e==\"object\"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]==\"object\"){let r=[];return t.forEach(s=>{s in e?r.push(e[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${a}) outputs, so ${n} must be either an array with ${a} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function B2(e,t){return qH(e,t,\"classWeight\")}async function V2(e,t,n,a){if(t!=null||a!=null)throw new Error(\"Support sampleWeight is not implemented yet\");if(n!=null){let r=O(()=>{if(e.shape.length===1)return sr(e);if(e.shape.length===2){if(e.shape[1]>1)return di(e,1);if(e.shape[1]===1)return W(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());Ee(r);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),je(i,\"float32\")}else return null}function KH(e,t){return z(e,t)}var XH=32;function U2(e,t){let n,a,r=t;n=r.xs,a=r.ys,w.assert(n!=null&&a!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \\`{xs: xVal, ys: yVal}\\`, where the two values may be \\`tf.Tensor\\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=TI(\"input\",e.inputNames,n),i=TI(\"output\",e.outputNames,a),o=s[0].shape[0];w.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)w.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)w.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function TI(e,t,n){if(n instanceof Ce)return[n];if(Array.isArray(n))return w.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let a=[];for(let r of t){if(n[r]==null)throw new V(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);a.push(n[r])}return a}}function YH(e){if(e.length===3)throw new ze(\"Validation with sample weights is not implemented yet.\");return{xs:e[0],ys:e[1]}}async function ZH(e,t,n){let a=n.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>\"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).\"),w.assert(n!=null,()=>\"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.\"),w.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),w.assert(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),w.assert(n.validationSplit==null,()=>\"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.\"),e.isTraining)throw new Error(\"Cannot start training because another fit() call is ongoing.\");e.isTraining=!0;try{let r=n.validationData!=null,s,i;if(r)if(CI(n.validationData))w.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=YH(n.validationData);s=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;r?u=l.slice().concat(l.map(g=>\"val_\"+g)):u=l.slice();let p=D2(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:c,history:h}=R2(p,d,n.epochs,null,null,JH(t,n),null,r,u);c.setModel(e),e.history=h,await c.onTrainBegin(),e.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,f=await t.iterator();for(;m<n.epochs;){let g={};await c.onEpochBegin(m);let b=0,y=0;for(a||(f=await t.iterator());!a||b<n.batchesPerEpoch;){let x=await f.next();if(a&&x.done){console.warn(`You provided \\`batchesPerEpoch\\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \\`batchesPerEpoch * epochs\\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:v,ys:I}=U2(e,x.value),N={};N.batch=y,N.size=v[0].shape[0],await c.onBatchBegin(y,N);let C=[];if(n.classWeight!=null){let D=B2(n.classWeight,e.outputNames);for(let $=0;$<D.length;++$)C.push(await V2(I[$],null,D[$]))}let _=v.concat(I).concat(C),F=o(_);Ee(_);for(let D=0;D<l.length;++D){let $=l[D],S=F[D];N[$]=S,Ht(S)}await c.onBatchEnd(y,N),_2(N),y++,b++}if(a?b>=n.batchesPerEpoch:x.done){if(r){let v;CI(n.validationData)?v=it(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=it(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?XH:n.validationBatchSize,verbose:0}));for(let I=0;I<e.metricsNames.length;++I)g[`val_${e.metricsNames[I]}`]=v[I]}break}if(e.stopTraining_)break}if(await c.onEpochEnd(m,g),m++,e.stopTraining_)break}return await c.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function JH(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function CI(e){return typeof e.iterator==\"function\"}function QH(e){return typeof e.next==\"function\"}async function ej(e,t,n){n=n||{};let a=n.batches!=null,r=e.testFunction,s=[];if(n.verbose>0)throw new ze(\"Verbose mode is not implemented yet.\");w.assert(!a||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \\`batches\\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=QH(t)?t:await t.iterator(),o=0,l=0;for(;!a||l<n.batches;){let u=await i.next();if(s=O(()=>{if(u.value){let{xs:p,ys:d}=U2(e,u.value),c=p.concat(d),h=O(()=>r(c));if(Ee(c),l===0)for(let f=0;f<h.length;++f)s.push(xe(0));let m=c[0].shape[0];for(let f=0;f<h.length;++f){let g=h[f],b=s[f];s[f]=O(()=>X(s[f],z(m,g))),l>0&&Ee(b)}Ee(h),o+=m,++l}return s}),u.done){a&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \\`batches\\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let p=s[u];s[u]=he(s[u],o),Ee(p)}return Mn(s)}function hx(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Xp(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(a=>si(a,t,n-t)):si(e,t,n-t)}function jx(e,t){return O(()=>e==null?null:Array.isArray(e)?e.map(n=>jx(n,t)):v2(e,t.dtype===\"int32\"?t:re(t,\"int32\")))}function mx(e,t){let n=[],a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function G2(e){let t=[];e instanceof Ce&&(e=[e]);for(let n=0;n<e.length;++n){let a=e[n];if(a.rank===1)t.push(wd(a,1));else{if(a.rank===0)throw new Error(\"Expected tensor to be at least 1D, but received a 0D tensor (scalar).\");t.push(a)}}return t}function Pa(e,t){if(e==null)return;let n=[];if(t instanceof Ce)n.push(t.id);else if(Array.isArray(t))t.forEach(r=>n.push(r.id));else if(t!=null)for(let r in t){let s=t[r];n.push(s.id)}let a=[];if(e instanceof Ce)n.indexOf(e.id)===-1&&a.push(e);else if(Array.isArray(e))e.forEach(r=>{n.indexOf(r.id)===-1&&a.push(r)});else if(e!=null)for(let r in e){let s=e[r];n.indexOf(s.id)===-1&&a.push(s)}a.forEach(r=>{r.isDisposed||r.dispose()})}function tj(e){return e instanceof Ce}function qx(e){return Array.isArray(e)}function EI(e){return!tj(e)&&!qx(e)}function _I(e,t,n,a=!0,r=\"\"){if(t==null||t.length===0){if(e!=null){let i=!1;if(qx(e)&&e.length>0)i=!0;else if(EI(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new V(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(EI(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new V(`No data provided for \"${i}\". Need data for each key in: ${t}`);s.push(e[i])}}else if(qx(e)){if(e=e,e.length!==t.length)throw new V(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new V(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=G2(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let u=o.shape[l],p=n[i][l];if(p!=null&&p>=0&&u!==p)throw new V(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function nj(e,t,n){let a=as(e.map(s=>s.shape[0]));a.sort();let r=as(t.map(s=>s.shape[0]));if(r.sort(),a.length>1)throw new V(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>1)throw new V(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(a.length>0&&r.length>0&&!w.arraysEqual(a,r))throw new V(`Input Tensors should have the same number of samples as target Tensors. Found ${a[0]} input sample(s) and ${r[0]} target sample(s).`)}function aj(e,t,n){let a=[Xo,Cf,kc];for(let r=0;r<e.length;++r){let s=e[r],i=t[r],o=n[r];if(i!=null){if(i===kc&&s.shape[s.shape.length-1]===1)throw new V(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(a.indexOf(i)!==-1){let l=s.shape.slice(1),u=o.slice(1);for(let p=0;p<l.length;++p){let d=l[p],c=u[p];if(c!=null&&d!==c)throw new V(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function AI(e,t,n,a=!0,r=\"\"){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new V(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new V(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${r}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!a)continue;let u=o.shape[l],p=n[i][l];if(p!=null&&p!==u)throw new V(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function rj(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>[]);let n;if(typeof e==\"string\"||typeof e==\"function\")n=[e];else if(Array.isArray(e)||typeof e==\"object\")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(a=>n);{let a=[];for(let r of t){let s=n.hasOwnProperty(r)?n[r]:[];Array.isArray(s)||(s=[s]),a.push(s)}return a}}var sj=\"layers-model\",Er=class extends jH{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new V(\"This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).\");WH(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer==\"string\")this.optimizer_=zH(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Rr))throw new V(\"User-defined optimizer must be an instance of tf.Optimizer.\");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!=\"string\"&&typeof e.loss!=\"function\"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new V(`Unknown entry in loss dictionary: \"${s}\". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output \"${s}\" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(dx(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new V(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>dx(s))}else{let s=dx(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=[\"loss\"],this.metricsTensors=[],ri(\"loss\",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+\"_loss\"))}});let a=rj(e.metrics,this.outputNames),r=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+\"_\"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};ri(\"metric\",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=a[s];(o=>{let l=\"\",u,p,d;for(let c of o){if(typeof c==\"string\"&&[\"accuracy\",\"acc\",\"crossentropy\",\"ce\"].indexOf(c)!==-1){let m=this.internalOutputShapes[s];m[m.length-1]===1||this.lossFunctions[s]===Cf?[\"accuracy\",\"acc\"].indexOf(c)!==-1?p=b0:[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(p=P2):this.lossFunctions[s]===nm?[\"accuracy\",\"acc\"].indexOf(c)!==-1?p=L2:[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(p=z2):[\"accuracy\",\"acc\"].indexOf(c)!==-1?p=y0:[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(p=x0);let f;[\"accuracy\",\"acc\"].indexOf(c)!==-1?f=\"acc\":[\"crossentropy\",\"ce\"].indexOf(c)!==-1&&(f=\"ce\"),d=p,u=l+f}else d=LH(c),u=l+Sh(c);let h;ri(u,()=>{h=d}),r(s,u,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn(\"Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?\")}evaluate(e,t,n={}){let a=n.batchSize==null?32:n.batchSize;hx(a);let r=this.standardizeUserDataXY(e,t,!0,a);try{let s=r[0].concat(r[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,a,n.verbose,n.steps);return Mn(o)}finally{Pa(r[0],e),Pa(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),ej(this,e,t)}checkNumSamples(e,t,n,a=\"steps\"){let r;if(n!=null){if(r=null,t!=null)throw new V(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new V(`Either the input data should have a defined shape, or ${a} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new V(\"`outputs` is an empty Array, which is not allowed.\");let n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new Cl;if(e instanceof Ce&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new V(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new V(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=tc(r,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=bi(null,e.length),n=e.length;for(let a of this.layers){let r=Array.isArray(a.output)?a.output:[a.output],s=r.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=r[o],n--),n===0)break}if(n===0)break}if(n>0){let a=[];throw t.forEach((r,s)=>{r==null&&a.push(e[s])}),new V(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return t}predictLoop(e,t=32,n=!1){return O(()=>{let a=this.checkNumSamples(e);if(n)throw new ze(\"Verbose predictLoop() is not implemented yet.\");let r=mx(a,t),s=this.outputs.map(i=>[]);for(let i=0;i<r.length;++i)O(()=>{let o=r[i][0],l=r[i][1],u=Xp(e,o,l),p=[];if(Array.isArray(u))for(let c=0;c<u.length;++c)p.push({key:this.inputs[c],value:u[c]});else p.push({key:this.inputs[0],value:u});let d=new Cl(p);return tc(this.outputs,d)}).forEach((o,l)=>s[l].push(o));return Mn(s.map(i=>et(i,0)))})}predict(e,t={}){let n=G2(e);AI(n,this.inputNames,this.feedInputShapes,!1);try{let a=t.batchSize==null?32:t.batchSize;return hx(a),this.predictLoop(n,a)}finally{Pa(n,e)}}predictOnBatch(e){AI(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,a){if(this.optimizer_==null)throw new ar(\"You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).\");let r=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===nm?r.push(i.slice(0,i.length-1).concat([1])):r.push(i)}if(e=_I(e,this.feedInputNames,this.feedInputShapes,!1,\"input\"),t=_I(t,this.feedOutputNames,r,!1,\"target\"),nj(e,t,null),aj(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&a!=null&&a>0&&e[0].shape[0]%a!==0)throw new V(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,a,r=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,r,s);if(n!=null)throw new Error(\"sample weight is not supported yet.\");let l=null;if(a!=null){let u=B2(a,this.outputNames);l=[];for(let p=0;p<u.length;++p)l.push(await V2(o[p],null,u[p]))}return[i,o,l]}testLoop(e,t,n,a=0,r){return O(()=>{let s=this.checkNumSamples(t,n,r,\"steps\"),i=[];if(a>0)throw new ze(\"Verbose mode is not implemented yet.\");if(r!=null)throw new ze(\"steps mode in testLoop() is not implemented yet\");{let o=mx(s,n),l=je(Ua(0,s));for(let u=0;u<o.length;++u){let p=o[u][0],d=o[u][1],c=si(l,p,d-p),h=jx(t,c),m=e(h);if(u===0)for(let f=0;f<m.length;++f)i.push(xe(0));for(let f=0;f<m.length;++f){let g=m[f];i[f]=X(i[f],z(d-p,g))}}for(let u=0;u<i.length;++u)i[u]=he(i[u],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let a=e[n],r=a;if(fI(e,a)>1){let s=fI(e.slice(0,n),a);r+=`_${s}`}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let c=0;c<this.inputs.length;++c)l.push({key:this.inputs[c],value:n[c]});let u=new Cl(l),p=tc(this.outputs,u,{training:!0}),d;for(let c=0;c<this.lossFunctions.length;++c){let h=this.lossFunctions[c],m=h(a[c],p[c]);r[c]!=null&&(m=KH(m,r[c]));let f=Ct(m);t.push(f),c===0?d=m:d=X(d,m)}for(let c=0;c<this.metricsTensors.length;++c){let h;if(this.outputs.length>1&&c<this.outputs.length)h=t[c];else{let m=this.metricsTensors[c][0],f=this.metricsTensors[c][1];h=Ct(m(a[f],p[f]))}Ht(h),s.push(h)}return d=Ct(d),this.calculateLosses().forEach(c=>{d=X(d,c)}),d},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>O(()=>{let t=[],n,a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:a[l]});let i=new Cl(s),o=tc(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],p=Ct(u(r[l],o[l]));l===0?n=p:n=X(n,p),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],p=this.metricsTensors[l][1],d=Ct(u(r[p],o[p]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error(\"Cannot start training because another fit() call is ongoing.\");this.isTraining=!0;let a,r,s,i,o,l,u,p,d;try{let c=n.batchSize==null?32:n.batchSize;hx(c);let h=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,c);a=h[0],r=h[1],d=h[2];let m=!1,f;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new ze(\"validationData including sample weights is not supported yet.\"):new V(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let N=await this.standardizeUserData(o,l,null,null,!0,c);u=N[0],p=N[1],f=u.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let N=Math.floor(a[0].shape[0]*(1-n.validationSplit)),C=a[0].shape[0];u=Xp(a,N,C),s=a,a=Xp(a,0,N),p=Xp(r,N,C),i=r,r=Xp(r,0,N),f=u.concat(p)}else n.validationSteps!=null&&(m=!0);let g=a.concat(r).concat(d);this.checkTrainableWeightsConsistency();let b=this.makeTrainFunction(),y=this.getDedupedMetricsNames(),x,v;m?(this.makeTestFunction(),x=this.testFunction,v=y.slice().concat(y.map(N=>\"val_\"+N))):(x=null,f=[],v=y.slice());let I=D2(n.callbacks,n.yieldEvery);return await this.fitLoop(b,g,y,c,n.epochs,n.verbose,I,x,f,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,Pa(a,e),Pa(r,t),Pa(s,e),Pa(i,t),Pa(u,o),Pa(p,l),d!=null&&Ee(d)}}async fitLoop(e,t,n,a,r,s,i,o,l,u,p,d,c,h){a==null&&(a=32),r==null&&(r=1),u==null&&(u=!0),d==null&&(d=0);let m=!1;if(o!=null&&l!=null&&(m=!0),h!=null&&(m=!0,c==null))throw new V(\"Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.\");let f=this.checkNumSamples(t,a,c,\"steps_per_epoch\"),g;f!=null&&(g=Ua(0,f)),s==null&&(s=1);let{callbackList:b,history:y}=R2(i,s,r,d,f,c,a,m,p);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<r;++x){await b.onEpochBegin(x);let v={};if(c!=null)throw new ze(\"stepsPerEpoch mode is not implemented yet.\");{if(u===\"batch\")throw new ze(\"batch shuffling is not implemneted yet\");u&&w.shuffle(g);let I=je(g),N=mx(f,a);for(let C=0;C<N.length;++C){let _={};if(await b.onBatchBegin(C,_),O(()=>{let F=N[C][0],D=N[C][1],$=si(I,F,D-F);_.batch=C,_.size=D-F;let S=jx(t,$),M=e(S);for(let B=0;B<n.length;++B){let U=n[B],H=M[B];_[U]=H,Ht(H)}if(C===N.length-1&&m){let B=this.testLoop(o,l,a);for(let U=0;U<n.length;++U){let H=n[U],q=B[U];Ht(q),v[\"val_\"+H]=q}}}),await b.onBatchEnd(C,_),_2(_),this.stopTraining_)break}I.dispose()}if(await b.onEpochEnd(x,v),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return ZH(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return Ee(s),Pa(n[0],e),Pa(n[1],t),Mn(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Kh().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Kh().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss==\"string\")e=Ir(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!=\"string\")throw new Error(\"Serialization of non-string loss is not supported.\");e=this.loss.map(t=>Ir(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let a of t)if(typeof n[a]==\"string\")e[a]=Ir(n[a]);else throw new Error(\"Serialization of non-string loss is not supported.\")}return e}getMetricIdentifiers(){if(typeof this.metrics==\"string\"||typeof this.metrics==\"function\")return[Ir(Sh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ir(Sh(e)));{let e={};for(let t in this.metrics)e[t]=Ir(Sh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error(\"Loading weight_metrics is not supported yet.\");if(e.loss_weights!=null)throw new Error(\"Loading loss_weights is not supported yet.\");if(e.sample_weight_mode!=null)throw new Error(\"Loading sample_weight_mode is not supported yet.\");let t=Ic(e.optimizer_config),n=Ba(t),a;if(typeof e.loss==\"string\")a=Js(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(s=>Js(s));else if(e.loss!=null){a={};for(let s in e.loss)a[s]=Js(e.loss[s])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(s=>Js(s));else if(e.metrics!=null){r={};for(let s in e.metrics)r[s]=Js(e.metrics[s])}this.compile({loss:a,metrics:r,optimizer:n})}async save(e,t){if(typeof e==\"string\"){let r=jt.getSaveHandlers(e);if(r.length===0)throw new V(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new V(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new V(\"LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.\");let n=await jt.encodeWeights(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:sj,generatedBy:`TensorFlow.js tfjs-layers v${v0}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let r=\"optimizer\",{data:s,specs:i}=await jt.encodeWeights(await this.optimizer.getWeights(),r);n.specs.push(...i),n.data=jt.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(NI(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){NI(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Er.className=\"Model\";ne.registerClass(Er);var H2=class extends Er{};H2.className=\"Functional\";ne.registerClass(H2);async function ij(e,t){\"modelTopology\"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let a=Ic(n),r=Ba(a,t);if(e.weightsManifest!=null){let s=await jt.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(o=>o.originalName)),i={};for(let o of r.weights)i[o.originalName]=s[o.originalName];r.loadWeights(i),Ee(s)}return r}async function oj(e,t){if(t==null&&(t={}),typeof e==\"string\"){let n=jt.getLoadHandlers(e,t);if(n.length===0)n.push(jt.browserHTTPRequest(e,t));else if(n.length>1)throw new V(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return lj(e,void 0,t)}async function lj(e,t,n){if(n==null&&(n={}),e.load==null)throw new V(\"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.\");let a=await e.load(),r=a.modelTopology;r.model_config!=null&&(r=r.model_config);let s=n.strict==null?!0:n.strict,i=a.weightData!=null&&a.weightSpecs!=null&&s,o=Ba(Ic(r),t,i),l=a.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),a.userDefinedMetadata!=null&&o.setUserDefinedMetadata(a.userDefinedMetadata),a.weightData!=null){if(a.weightSpecs==null)throw new V(\"LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.\");let{modelWeights:u,optimizerWeights:p}=uj(a.weightData,a.weightSpecs);o.loadWeights(u,s),o.optimizer!=null&&p.length>0&&await o.optimizer.setWeights(p),Ee(u),Ee(p.map(d=>d.tensor))}return o}function uj(e,t){let n=jt.decodeWeights(e,t),a={},r=[];return t.forEach(s=>{s.group===\"optimizer\"?r.push({name:s.name,tensor:n[s.name]}):a[s.name]=n[s.name]}),{modelWeights:a,optimizerWeights:r}}var Ef=class Kx extends Er{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:gf(\"sequential_\"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new V(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof Kx||t instanceof Er,a;if(n){if(a=t,a.outputs.length!==1)throw new V(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");if(a.inputs.length!==1)throw new V(\"All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.\")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new V(\"The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.\");let r=S2({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+\"_input\"});t.apply(r)}if(n)this.outputs=a.outputs,this.inputs=a.inputs;else{if(t.inboundNodes.length!==1)throw new V(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new V(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=I2(this.outputs[0])}this.inboundNodes=[],new Nf({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:bi(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError(\"There are no layers in the model.\");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Je(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError(\"Sequential model cannot be built: model is empty. Add some layers first.\");this.model=new Er({inputs:this.inputs,outputs:this.outputs[0],name:this.name+\"_model\"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,a=console.log){this.built||this.build(),super.summary(t,n,a)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,a={}){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.evaluate(t,n,a)}async evaluateDataset(t,n){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,a={}){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.fit(t,n,a)}async fitDataset(t,n){if(!this.built)throw new ar(\"The model needs to be compiled before being used.\");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,a={},r=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className===\"Merge\")throw new V(\"Legacy serialization format not supported yet.\");s=n}else w.assert(n.layers!=null,()=>\"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.\"),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof Kx))throw new ze(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let u=Ba(l,void 0,r);r&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(t){if(this.model==null)throw new V(\"Cannot set the stopTraining property of a sequential model before it is compiled.\");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new V(\"Cannot get the stopTraining property of a sequential model before it is compiled.\");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let a={};a.className=n.getClassName(),a.config=n.getConfig(),t.push(a)}return{name:this.name,layers:t}}};Ef.className=\"Sequential\";ne.registerClass(Ef);function pj(e){return new Er(e)}function cj(e){return new Ef(e)}function j2(e){return S2(e)}function dj(e,t){f0.registerCallbackConstructor(e,t)}var xn=class extends ne.Serializable{getConfig(){return{}}},q2=class extends xn{apply(e,t=1){return FG(e,t)}};q2.className=\"elu\";ne.registerClass(q2);var K2=class extends xn{apply(e){return Qm(e)}};K2.className=\"selu\";ne.registerClass(K2);var X2=class extends xn{apply(e){return Ke(e)}};X2.className=\"relu\";ne.registerClass(X2);var Y2=class extends xn{apply(e){return O(()=>ds(6,Ke(e)))}};Y2.className=\"relu6\";ne.registerClass(Y2);var Z2=class extends xn{apply(e){return e}};Z2.className=\"linear\";ne.registerClass(Z2);var J2=class extends xn{apply(e){return ha(e)}};J2.className=\"sigmoid\";ne.registerClass(J2);var Q2=class extends xn{apply(e){return DG(e)}};Q2.className=\"hardSigmoid\";ne.registerClass(Q2);var eC=class extends xn{apply(e){return Go(e)}};eC.className=\"softplus\";ne.registerClass(eC);var tC=class extends xn{apply(e){return $G(e)}};tC.className=\"softsign\";ne.registerClass(tC);var nC=class extends xn{apply(e){return cs(e)}};nC.className=\"tanh\";ne.registerClass(nC);var w0=class extends xn{apply(e,t=-1){return qa(e,t)}};w0.className=\"softmax\";ne.registerClass(w0);var aC=class extends xn{apply(e,t=-1){return jm(e,t)}};aC.className=\"logSoftmax\";ne.registerClass(aC);var rC=class extends xn{apply(e){return O(()=>O(()=>{let t=Math.sqrt(2),n=z(.5,X(1,Um(he(e,t))));return z(e,n)}))}};rC.className=\"gelu\";ne.registerClass(rC);var sC=class extends xn{apply(e){return O(()=>z(.5,z(e,X(1,cs(z(rn(he(2,Math.PI)),X(e,z(.044715,ur(e,3)))))))))}};sC.className=\"gelu_new\";ne.registerClass(sC);var iC=class extends xn{apply(e){return O(()=>z(e,cs(Go(e))))}};iC.className=\"mish\";ne.registerClass(iC);var oC=class extends xn{apply(e,t=1){return O(()=>z(ha(z(e,t)),e))}};oC.className=\"swish\";ne.registerClass(oC);function ms(e){return e.getClassName()}function fx(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"activation\")}function fs(e){if(e==null){let t={};return t.className=\"linear\",t.config={},fx(t)}if(typeof e==\"string\"){let t={};return t.className=e,t.config={},fx(t)}else return e instanceof xn?e:fx(e)}function k0(e){if(e!=null&&typeof e!=\"object\")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var lC=class extends ne.Serializable{},Nd=class extends lC{constructor(e){super(),k0(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return O(()=>{let t=It([1]);return this.hasL1&&(t=X(t,fe(z(this.l1,Lt(e))))),this.hasL2&&(t=X(t,fe(z(this.l2,kd(e))))),W(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Nd.className=\"L1L2\";ne.registerClass(Nd);function hj(e){return k0(e),new Nd({l1:e!=null?e.l1:null,l2:0})}function mj(e){return k0(e),new Nd({l2:e!=null?e.l2:null,l1:0})}var FI={l1l2:\"L1L2\"};function ft(e){return Qw(e)}function $I(e,t={}){return vd(e,ne.SerializationMap.getMap().classNameMap,t,\"regularizer\")}function Nt(e){if(e==null)return null;if(typeof e==\"string\"){let t={className:e in FI?FI[e]:e,config:{}};return $I(t)}else return e instanceof lC?e:$I(e)}var I0=class extends We{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Te(e);let n=Ke(e);return this.maxValue!=null&&(n=an(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};I0.className=\"ReLU\";ne.registerClass(I0);var S0=class extends We{constructor(e){super(e==null?{}:e),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Te(e);return ud(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};S0.className=\"LeakyReLU\";ne.registerClass(S0);var N0=class extends We{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA_INITIALIZER=\"zeros\",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=St(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Nt(e.alphaRegularizer),this.alphaConstraint=Yt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes==\"number\")this.sharedAxes=[e.sharedAxes];else throw new V(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Je(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight(\"alpha\",t,\"float32\",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new zt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Te(e),fd(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Et(this.alphaInitializer),alphaRegularizer:ft(this.alphaRegularizer),alphaConstraint:Xt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};N0.className=\"PReLU\";ne.registerClass(N0);var T0=class extends We{constructor(e){if(super(e==null?{}:e),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new ze(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Te(e);return Qu(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};T0.className=\"ELU\";ne.registerClass(T0);var C0=class extends We{constructor(e){super(e==null?{}:e),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Te(e);return z(n,re(Cn(n,this.theta),\"float32\"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};C0.className=\"ThresholdedReLU\";ne.registerClass(C0);var E0=class extends We{constructor(e){super(e==null?{}:e),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new w0().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return O(()=>{let n=Te(e),a=t.mask;if(a!=null){let r=z(pe(Pn(n.shape),re(a,n.dtype)),xe(-1e9));n=X(n,r)}return this.axis instanceof Array?this.axis.length>1?dn(pe(n,cd(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};E0.className=\"Softmax\";ne.registerClass(E0);function Fl(e,t,n){if(typeof e==\"number\")return bi(e,t);if(e.length!==t)throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let a=0;a<t;++a){let r=e[a];if(!CG(r))throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function Va(e,t,n,a,r=1){if(e==null)return e;let s=t+(t-1)*(r-1),i;return n===\"same\"?i=e:i=e-s+1,Math.floor((i+a-1)/a)}function nr(e,t,n,a){if(e==null)return null;if(a===\"valid\")e=e*t+hs([n-t,0]);else if(a===\"same\")e=e*t;else throw new V(`Unsupport padding mode: ${a}.`);return e}function _0(e,t){return O(()=>(Rt(t),t===\"channelsFirst\"?De(e,[0,2,3,1]):e))}function uC(e,t){return O(()=>(Rt(t),t===\"channelsFirst\"?De(e,[0,2,3,4,1]):e))}function fj(e,t,n,a=1,r=\"valid\",s,i=1){return O(()=>{if(s==null&&(s=Ga()),Rt(s),e.shape.length!==3)throw new V(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new V(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new V(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s===\"channelsFirst\"&&(e=De(e,[0,2,1])),r===\"causal\")throw new ze(\"The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.\");let o=zm(e,t,a,r===\"same\"?\"same\":\"valid\",\"NWC\",i);return n!=null&&(o=Ka(o,n)),o})}function DI(e,t,n,a=[1,1],r=\"valid\",s,i,o=null){return O(()=>{if(s==null&&(s=Ga()),Rt(s),e.rank!==3&&e.rank!==4)throw new V(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new V(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=_0(e,s);if(r===\"causal\")throw new ze(\"The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.\");return l=Vl.conv2d({x:l,filter:t,strides:a,pad:r===\"same\"?\"same\":\"valid\",dilations:i,dataFormat:\"NHWC\",bias:n,activation:o}),s===\"channelsFirst\"&&(l=De(l,[0,3,1,2])),l})}function gj(e,t,n,a=[1,1,1],r=\"valid\",s,i){return O(()=>{if(s==null&&(s=Ga()),Rt(s),e.rank!==4&&e.rank!==5)throw new V(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new V(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=uC(e,s);if(r===\"causal\")throw new ze(\"The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.\");return o=aw(o,t,a,r===\"same\"?\"same\":\"valid\",\"NDHWC\",i),n!=null&&(o=Ka(o,n)),s===\"channelsFirst\"&&(o=De(o,[0,4,1,2,3])),o})}var pC=class cC extends We{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",cC.verifyArgs(n),this.rank=t,tn(this.rank,\"rank\"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ze(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Fl(n.kernelSize,t,\"kernelSize\"),this.strides=Fl(n.strides==null?1:n.strides,t,\"strides\"),this.padding=n.padding==null?\"valid\":n.padding,va(this.padding),this.dataFormat=n.dataFormat==null?\"channelsLast\":n.dataFormat,Rt(this.dataFormat),this.activation=fs(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=St(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Yt(n.biasConstraint),this.biasRegularizer=Nt(n.biasRegularizer),this.activityRegularizer=Nt(n.activityRegularizer),this.dilationRate=Fl(n.dilationRate==null?1:n.dilationRate,t,\"dilationRate\"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new V(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate==\"number\")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new V(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate==\"number\")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new V(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(tr(\"kernelSize\"in t,\"required key 'kernelSize' not in config\"),typeof t.kernelSize!=\"number\"&&!e0(t.kernelSize,\"number\",1,3))throw new V(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ms(this.activation),useBias:this.useBias,biasInitializer:Et(this.biasInitializer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),biasConstraint:Xt(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},_f=class dC extends pC{constructor(t,n){super(t,n),this.kernel=null,dC.verifyArgs(n),this.filters=n.filters,tn(this.filters,\"filters\"),this.kernelInitializer=St(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Yt(n.kernelConstraint),this.kernelRegularizer=Nt(n.kernelRegularizer)}build(t){t=Je(t);let n=this.dataFormat===\"channelsFirst\"?1:t.length-1;if(t[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${t[n]}`);let a=t[n],r=this.kernelSize.concat([a,this.filters]);this.kernel=this.addWeight(\"kernel\",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:a}}],this.built=!0}call(t,n){return O(()=>{t=Te(t);let a,r=this.bias==null?null:this.bias.read(),s=m2(this.activation.getClassName());if(s!=null&&this.rank===2)a=DI(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)a=fj(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)a=DI(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)a=gj(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ze(\"convolutions greater than 3D are not implemented yet.\");this.activation!=null&&(a=this.activation.apply(a))}return a})}computeOutputShape(t){t=Je(t);let n=[],a=this.dataFormat===\"channelsLast\"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<a.length;++s){let i=Va(a[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate==\"number\"?this.dilationRate:this.dilationRate[s]);n.push(i)}let r=[t[0]];return this.dataFormat===\"channelsLast\"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){let t={filters:this.filters,kernelInitializer:Et(this.kernelInitializer),kernelRegularizer:ft(this.kernelRegularizer),kernelConstraint:Xt(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!(\"filters\"in t)||typeof t.filters!=\"number\"||t.filters<1)throw new V(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Af=class hC extends _f{constructor(t){super(2,t),hC.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!=\"number\"&&!e0(t.kernelSize,\"number\",1,2))throw new V(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Af.className=\"Conv2D\";ne.registerClass(Af);var Ff=class mC extends _f{constructor(t){super(3,t),mC.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!=\"number\"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new V(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Ff.className=\"Conv3D\";ne.registerClass(Ff);var A0=class extends Af{constructor(e){if(super(e),this.inputSpec=[new zt({ndim:4})],this.padding!==\"same\"&&this.padding!==\"valid\")throw new V(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Je(e),e.length!==4)throw new V(\"Input should have rank 4; Received input shape: \"+JSON.stringify(e));let t=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[t]==null)throw new V(\"The channel dimension of the inputs should be defined. Found `None`.\");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight(\"kernel\",a,\"float32\",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.filters],\"float32\",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{let n=Te(e);if(n.shape.length!==4)throw new V(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i;this.dataFormat===\"channelsFirst\"?(s=2,i=3):(s=1,i=2);let o=a[s],l=a[i],u=this.kernelSize[0],p=this.kernelSize[1],d=this.strides[0],c=this.strides[1],h=nr(o,d,u,this.padding),m=nr(l,c,p,this.padding),f=[r,h,m,this.filters];this.dataFormat!==\"channelsLast\"&&(n=De(n,[0,2,3,1]));let g=Wm(n,this.kernel.read(),f,this.strides,this.padding);return this.dataFormat!==\"channelsLast\"&&(g=De(g,[0,3,1,2])),this.bias!=null&&(g=Ka(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=Je(e);let t=e.slice(),n,a,r;this.dataFormat===\"channelsFirst\"?(n=1,a=2,r=3):(n=3,a=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[a]=nr(t[a],o,s,this.padding),t[r]=nr(t[r],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};A0.className=\"Conv2DTranspose\";ne.registerClass(A0);var F0=class extends Ff{constructor(e){if(super(e),this.inputSpec=[new zt({ndim:5})],this.padding!==\"same\"&&this.padding!==\"valid\")throw new V(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Je(e),e.length!==5)throw new V(\"Input should have rank 5; Received input shape: \"+JSON.stringify(e));let t=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[t]==null)throw new V(\"The channel dimension of the inputs should be defined. Found `None`.\");let n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight(\"kernel\",a,\"float32\",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.filters],\"float32\",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{let n=Te(e);if(n.shape.length!==5)throw new V(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let a=n.shape,r=a[0],s,i,o;this.dataFormat===\"channelsFirst\"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=a[o],u=a[s],p=a[i],d=this.kernelSize[0],c=this.kernelSize[1],h=this.kernelSize[2],m=this.strides[0],f=this.strides[1],g=this.strides[2],b=nr(l,m,d,this.padding),y=nr(u,f,c,this.padding),x=nr(p,g,h,this.padding),v=[r,b,y,x,this.filters];this.dataFormat!==\"channelsLast\"&&(n=De(n,[0,2,3,4,1]));let I=rw(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!==\"channelsLast\"&&(I=De(I,[0,4,1,2,3])),this.bias!==null&&(I=Ka(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=Je(e);let t=e.slice(),n,a,r,s;this.dataFormat===\"channelsFirst\"?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],p=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[a]=nr(t[a],u,i,this.padding),t[r]=nr(t[r],p,o,this.padding),t[s]=nr(t[s],d,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};F0.className=\"Conv3DTranspose\";ne.registerClass(F0);var fC=class extends _f{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER=\"glorotUniform\",this.DEFAULT_POINTWISE_INITIALIZER=\"glorotUniform\",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new V(\"The `filters` configuration field is required by SeparableConv, but is unspecified.\");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new V(\"Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.\");if(t.padding!=null&&t.padding!==\"same\"&&t.padding!==\"valid\")throw new V(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=St(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Nt(t.depthwiseRegularizer),this.depthwiseConstraint=Yt(t.depthwiseConstraint),this.pointwiseInitializer=St(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Nt(t.pointwiseRegularizer),this.pointwiseConstraint=Yt(t.pointwiseConstraint)}build(e){if(e=Je(e),e.length<this.rank+2)throw new V(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight(\"depthwise_kernel\",a,\"float32\",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight(\"pointwise_kernel\",r,\"float32\",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[this.filters],\"float32\",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new zt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return O(()=>{e=Te(e);let n;if(this.rank===1)throw new ze(\"1D separable convolution is not implemented yet.\");return this.rank===2&&(this.dataFormat===\"channelsFirst\"&&(e=De(e,[0,2,3,1])),n=_s(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,\"NHWC\")),this.useBias&&(n=Ka(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat===\"channelsFirst\"&&(n=De(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Et(this.depthwiseInitializer),e.pointwiseInitializer=Et(this.pointwiseInitializer),e.depthwiseRegularizer=ft(this.depthwiseRegularizer),e.pointwiseRegularizer=ft(this.pointwiseRegularizer),e.depthwiseConstraint=Xt(this.depthwiseConstraint),e.pointwiseConstraint=Xt(this.pointwiseConstraint),e}};fC.className=\"SeparableConv\";var $0=class extends fC{constructor(e){super(2,e)}};$0.className=\"SeparableConv2D\";ne.registerClass($0);var D0=class gC extends _f{constructor(t){super(1,t),gC.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!=\"number\"&&!e0(t.kernelSize,\"number\",1,1))throw new V(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};D0.className=\"Conv1D\";ne.registerClass(D0);var R0=class extends We{constructor(e){super(e),typeof e.cropping==\"number\"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]==\"number\"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?\"channelsLast\":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat===\"channelsFirst\"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return O(()=>{if(e=Te(e),this.dataFormat===\"channelsLast\"){let n=Ih(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ih(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Ih(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ih(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};R0.className=\"Cropping2D\";ne.registerClass(R0);var M0=class extends We{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),this.interpolation=e.interpolation==null?\"nearest\":e.interpolation,SG(this.interpolation)}computeOutputShape(e){if(this.dataFormat===\"channelsFirst\"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return O(()=>{let n=Te(e),a=n.shape;if(this.dataFormat===\"channelsFirst\"){n=De(n,[0,2,3,1]);let r=this.size[0]*a[2],s=this.size[1]*a[3],i=this.interpolation===\"nearest\"?Zn.resizeNearestNeighbor(n,[r,s]):Zn.resizeBilinear(n,[r,s]);return De(i,[0,3,1,2])}else{let r=this.size[0]*a[1],s=this.size[1]*a[2];return this.interpolation===\"nearest\"?Zn.resizeNearestNeighbor(n,[r,s]):Zn.resizeBilinear(n,[r,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};M0.className=\"UpSampling2D\";ne.registerClass(M0);function bj(e,t,n=[1,1],a=\"valid\",r,s){return O(()=>{r==null&&(r=Ga()),Rt(r);let i=_0(e,r);if(e.rank!==4)throw new V(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new V(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Ts(i,t,n,a===\"same\"?\"same\":\"valid\",\"NHWC\",s),r===\"channelsFirst\"&&(i=De(i,[0,3,1,2])),i})}var O0=class extends pC{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=St(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Yt(e.depthwiseConstraint),this.depthwiseRegularizer=Nt(e.depthwiseRegularizer)}build(e){if(e=Je(e),e.length<4)throw new V(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat===\"channelsFirst\"?1:3;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight(\"depthwise_kernel\",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{e=Te(e);let n=bj(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Ka(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Je(e);let t=this.dataFormat===\"channelsFirst\"?e[2]:e[1],n=this.dataFormat===\"channelsFirst\"?e[3]:e[2],a=this.dataFormat===\"channelsFirst\"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Va(t,this.kernelSize[0],this.padding,this.strides[0]),s=Va(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat===\"channelsFirst\"?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Et(this.depthwiseInitializer),e.depthwiseRegularizer=ft(this.depthwiseRegularizer),e.depthwiseConstraint=Xt(this.depthwiseRegularizer),e}};O0.className=\"DepthwiseConv2D\";ne.registerClass(O0);function bC(e,t,n,a){if(Array.isArray(e)){if(t!=null||n!=null)throw new V(\"When inputs is an array, neither initialState or constants should be provided\");a!=null&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return t=r(t),n=r(n),{inputs:e,initialState:t,constants:n}}function yC(e,t,n,a=!1,r,s,i=!1,o=!1){return O(()=>{let l=t.shape.length;if(l<3)throw new V(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(Ua(2,l));if(t=De(t,u),s!=null)throw new ze(\"The rnn() functoin of the deeplearn.js backend does not support constants yet.\");i&&console.warn(\"Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend.\"),r!=null&&(r=re(re(r,\"bool\"),\"float32\"),r.rank===l-1&&(r=Gt(r,-1)),r=De(r,u)),a&&(t=ba(t,0),r!=null&&(r=ba(r,0)));let p=[],d,c=n,h=t.shape[0],m=dt(t),f;r!=null&&(f=dt(r));for(let b=0;b<h;++b){let y=m[b],x=O(()=>e(y,c));if(r==null)d=x[0],c=x[1];else{let v=O(()=>{let I=f[b],N=pe(ea(I),I),C=X(z(x[0],I),z(c[0],N)),_=c.map((F,D)=>X(z(x[1][D],I),z(F,N)));return{output:C,newStates:_}});d=v.output,c=v.newStates}o&&p.push(d)}let g;return o&&(g=At(p,1)),[d,g,c]})}var Mr=class xC extends We{constructor(t){super(t);let n;if(t.cell==null)throw new V(\"cell property is missing for the constructor of RNN.\");if(Array.isArray(t.cell)?n=new Rf({cells:t.cell}):n=t.cell,n.stateSize==null)throw new V(\"The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).\");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new zt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ua(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Vx(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let a=n[0],r;if(this.returnSequences?r=[t[0],t[1],a]:r=[t[0],a],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[r].concat(s)}else return r}computeMask(t,n){return O(()=>{Array.isArray(n)&&(n=n[0]);let a=this.returnSequences?n:null;if(this.returnState){let r=this.states.map(s=>null);return[a].concat(r)}else return a})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let a=0;a<t;++a)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new ze(\"Constants support is not implemented in RNN yet.\");Vx(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,a=t.slice(2);this.inputSpec[0]=new zt({shape:[n,null,...a]});let r=[t[0]].concat(t.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new V(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new zt({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){O(()=>{if(!this.stateful)throw new Xr(\"Cannot call resetStates() on an RNN Layer that is not stateful.\");let a=this.inputSpec[0].shape[0];if(a==null)throw new V(\"If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \\n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.\");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>It([a,r])):this.states_=[It([a,this.cell.stateSize])];else if(t==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>It([a,r])):this.states_[0]=It([a,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let r=0;r<this.states_.length;++r){let s=t[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[a,i];if(!w.arraysEqual(s.shape,o))throw new V(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>Ht(r.clone()))})}apply(t,n){let a=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});let s=bC(t,a,r,this.numConstants);t=s.inputs,a=s.initialState,r=s.constants;let i=[],o=[];if(a!=null){n.initialState=a,i=i.concat(a),this.stateSpec=[];for(let l of a)this.stateSpec.push(new zt({shape:l.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof Ha){let l=[t].concat(i),u=this.inputSpec.concat(o),p=this.inputSpec;this.inputSpec=u;let d=super.apply(l,n);return this.inputSpec=p,d}else return super.apply(t,n)}call(t,n){return O(()=>{let a=n==null?null:n.mask,r=n==null?null:n.training,s=n==null?null:n.initialState;t=Te(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new V(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn(\"Ignoring unroll = true for RNN layer, due to imperative backend.\");let o={training:r},l=yC((h,m)=>{let f=this.cell.call([h].concat(m),o);return[f[0],f.slice(1)]},t,s,this.goBackwards,a,null,this.unroll,this.returnSequences),u=l[0],p=l[1],d=l[2];this.stateful&&this.resetStates(d,r);let c=this.returnSequences?p:u;return this.returnState?[c].concat(d):c})}getInitialState(t){return O(()=>{let n=It(t.shape);return n=fe(n,[1,2]),n=wd(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>a>1?Wx(n,[1,a]):n):this.cell.stateSize>1?[Wx(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let a=this.cell.getConfig();return this.getClassName()===xC.className&&(n.cell={className:this.cell.getClassName(),config:a}),Object.assign(Object.assign(Object.assign({},a),t),n)}static fromConfig(t,n,a={}){let r=n.cell,s=Ba(r,a);return new t(Object.assign(n,{cell:s}))}};Mr.className=\"RNN\";ne.registerClass(Mr);var Td=class extends We{},$f=class extends Td{constructor(e){super(e),this.DEFAULT_ACTIVATION=\"tanh\",this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_RECURRENT_INITIALIZER=\"orthogonal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=Ul([1,hs([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ul([1,hs([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Je(e),this.kernel=this.addWeight(\"kernel\",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(\"recurrent_kernel\",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{if(e=e,e.length!==2)throw new V(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let a=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let r,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?r=or(z(e,s),this.kernel.read()):r=or(e,this.kernel.read()),this.bias!=null&&(r=Ka(r,this.bias.read())),i!=null&&(n=z(n,i));let o=X(r,or(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ms(this.activation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};$f.className=\"SimpleRNNCell\";ne.registerClass($f);var P0=class extends Mr{constructor(e){e.cell=new $f(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return new e(t)}};P0.className=\"SimpleRNN\";ne.registerClass(P0);var Df=class extends Td{constructor(e){if(super(e),this.DEFAULT_ACTIVATION=\"tanh\",this.DEFAULT_RECURRENT_ACTIVATION=\"hardSigmoid\",this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_RECURRENT_INITIALIZER=\"orthogonal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",e.resetAfter)throw new V(\"GRUCell does not support reset_after parameter set to true.\");this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fs(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=Ul([1,hs([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ul([1,hs([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Je(e);let t=e[e.length-1];this.kernel=this.addWeight(\"kernel\",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(\"recurrent_kernel\",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight(\"bias\",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return O(()=>{if(e=e,e.length!==2)throw new V(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let r=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=z(e,r[0]));let u=or(e,this.kernel.read());this.useBias&&(u=Ka(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=z(a,s[0]));let p=this.recurrentKernel.read(),[d,c]=Ln(p,[2*this.units,this.units],p.rank-1),h=or(a,d),[m,f,g]=Ln(u,3,u.rank-1),[b,y]=Ln(h,2,h.rank-1);i=this.recurrentActivation.apply(X(m,b)),o=this.recurrentActivation.apply(X(f,y));let x=or(z(o,a),c);l=this.activation.apply(X(g,x));let v=X(z(i,a),z(X(1,yt(i)),l));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ms(this.activation),recurrentActivation:ms(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Df.className=\"GRUCell\";ne.registerClass(Df);var L0=class extends Mr{constructor(e){e.implementation===0&&console.warn(\"`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.\"),e.cell=new Df(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};L0.className=\"GRU\";ne.registerClass(L0);var Cd=class extends Td{constructor(e){super(e),this.DEFAULT_ACTIVATION=\"tanh\",this.DEFAULT_RECURRENT_ACTIVATION=\"hardSigmoid\",this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_RECURRENT_INITIALIZER=\"orthogonal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fs(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=Ul([1,hs([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ul([1,hs([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Je(e);let n=e[e.length-1];this.kernel=this.addWeight(\"kernel\",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(\"recurrent_kernel\",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let a;if(this.useBias){if(this.unitForgetBias){let r=this.biasInitializer,s=this.units;a=new(t=class extends $a{apply(i,o){let l=r.apply([s]),u=new yf().apply([s]),p=r.apply([s*2]);return bI(bI(l,u),p)}},t.className=\"CustomInit\",t)}else a=this.biasInitializer;this.bias=this.addWeight(\"bias\",[this.units*4],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return O(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new V(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,u,p;0<this.dropout&&this.dropout<1&&(e=z(e,s[0]));let d=or(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=z(a,i[0])),d=X(d,or(a,this.recurrentKernel.read())),this.useBias&&(d=Ka(d,this.bias.read()));let[c,h,m,f]=Ln(d,4,d.rank-1);o=this.recurrentActivation.apply(c),l=this.recurrentActivation.apply(h),u=X(z(l,r),z(o,this.activation.apply(m))),p=this.recurrentActivation.apply(f);let g=z(p,this.activation.apply(u));return[g,g,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ms(this.activation),recurrentActivation:ms(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),recurrentInitializer:Et(this.recurrentInitializer),biasInitializer:Et(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ft(this.kernelRegularizer),recurrentRegularizer:ft(this.recurrentRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};Cd.className=\"LSTMCell\";ne.registerClass(Cd);var z0=class extends Mr{constructor(e){e.implementation===0&&console.warn(\"`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.\"),e.cell=new Cd(e),super(e)}call(e,t){return O(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};z0.className=\"LSTM\";ne.registerClass(z0);var Rf=class extends Td{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return O(()=>{e=e;let n=e.slice(1),a=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?a.push(n.splice(0,i.stateSize.length)):a.push(n.splice(0,1));a.reverse();let r=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=a[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),r.push(s.slice(1))}n=[];for(let i of r.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){Vx(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,a)=>{ri(`RNNCell_${a}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let a=[];for(let r of t.cells)a.push(Ba(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Ux(e)}setWeights(e){let t=[];for(let n of this.cells){let a=n.weights.length,r=e.splice(a);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],r[s]])}u0(t)}};Rf.className=\"StackedRNNCells\";ne.registerClass(Rf);function gs(e){let{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):w2(t(),n),o=()=>Id(i,t,a);return!r||r<=1?Ht(o().clone()):Array(r).fill(void 0).map(o).map(l=>Ht(l.clone()))}var yj=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(e!=null&&typeof Object.getOwnPropertySymbols==\"function\")for(var r=0,a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]]);return n},vC=class extends Mr{constructor(e){if(e.unroll)throw new ze(\"Unrolling is not possible with convolutional RNNs.\");if(Array.isArray(e.cell))throw new ze(\"It is not possible at the moment to stack convolutional cells.\");super(e),this.inputSpec=[new zt({ndim:5})]}call(e,t){return O(()=>{if(this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new V(\"ConvRNN2D cell does not support constants\");let n=t==null?null:t.mask,a=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return O(()=>{let{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)],s=It(r);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){O(()=>{if(!this.stateful)throw new Xr(\"Cannot call resetStates() on an RNN Layer that is not stateful.\");let n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(n[0]==null)throw new V(\"If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \\n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.\");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>It(r)):this.states_=[It(r)];else if(e==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>It(r)):this.states_[0]=It(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=r;if(!w.arraysEqual(i.shape,o))throw new V(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Ht(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:i}=this.cell,o=t===\"channelsFirst\",l=e[o?3:2],u=e[o?4:3],p=Va(l,a[0],r,s[0],i[0]),d=Va(u,a[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[n,p,d]:[p,d,n]]}};vC.className=\"ConvRNN2D\";var Mf=class extends Cd{constructor(e){let{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,tn(this.filters,\"filters\"),this.kernelSize=Fl(n,2,\"kernelSize\"),this.kernelSize.forEach(o=>tn(o,\"kernelSize\")),this.strides=Fl(a||1,2,\"strides\"),this.strides.forEach(o=>tn(o,\"strides\")),this.padding=r||\"valid\",va(this.padding),this.dataFormat=s||\"channelsLast\",Rt(this.dataFormat),this.dilationRate=Fl(i||1,2,\"dilationRate\"),this.dilationRate.forEach(o=>tn(o,\"dilationRate\"))}build(e){var t;e=Je(e);let n=this.dataFormat===\"channelsFirst\"?1:e.length-1;if(e[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[n]}`);let a=e[n],r=4,s=this.kernelSize.concat([a,this.filters*r]);this.kernel=this.addWeight(\"kernel\",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight(\"recurrent_kernel\",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(t=class extends $a{apply(p,d){let c=l.apply([u]),h=Pn([u]),m=l.apply([u*2]);return t0([c,h,m])}},t.className=\"CustomInit\",t)}else o=this.biasInitializer;this.bias=this.addWeight(\"bias\",[this.filters*r],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return O(()=>{if(e.length!==3)throw new V(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,a=e[0],r=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gs({ones:()=>ea(a),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(Z,J,ee)=>!J||!J[ee]?Z:z(J[ee],Z),u=l(a,o,0),p=l(a,o,1),d=l(a,o,2),c=l(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gs({ones:()=>ea(r),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,m=l(r,h,0),f=l(r,h,1),g=l(r,h,2),b=l(r,h,3),y=3,[x,v,I,N]=Ln(this.kernel.read(),i,y),[C,_,F,D]=this.useBias?Ln(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,x,C,this.padding),p=this.inputConv(p,v,_,this.padding),d=this.inputConv(d,I,F,this.padding),c=this.inputConv(c,N,D,this.padding);let[$,S,M,B]=Ln(this.recurrentKernel.read(),i,y);m=this.recurrentConv(m,$),f=this.recurrentConv(f,S),g=this.recurrentConv(g,M),b=this.recurrentConv(b,B);let U=this.recurrentActivation.apply(X(u,m)),H=this.recurrentActivation.apply(X(p,f)),q=X(z(H,s),z(U,this.activation.apply(X(d,g)))),K=z(this.recurrentActivation.apply(X(c,b)),this.activation.apply(q));return[K,K,q]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=yj(e,[\"units\"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){let r=$t(e,t,this.strides,a||\"valid\",this.dataFormat===\"channelsFirst\"?\"NCHW\":\"NHWC\",this.dilationRate);return n?Ka(r,n,this.dataFormat):r}recurrentConv(e,t){return $t(e,t,1,\"same\",this.dataFormat===\"channelsFirst\"?\"NCHW\":\"NHWC\")}};Mf.className=\"ConvLSTM2DCell\";ne.registerClass(Mf);var W0=class extends vC{constructor(e){let t=new Mf(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};W0.className=\"ConvLSTM2D\";ne.registerClass(W0);var Of=class extends We{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(this.noiseShape[a]==null?t[a]:this.noiseShape[a]);return n}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);if(0<this.rate&&this.rate<1){let a=t.training==null?!1:t.training,r=this.getNoiseShape(n);return Id(()=>w2(n,this.rate,r,this.seed),()=>n,a)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Of.className=\"Dropout\";ne.registerClass(Of);var B0=class extends Of{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};B0.className=\"SpatialDropout1D\";ne.registerClass(B0);var V0=class extends We{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER=\"glorotNormal\",this.DEFAULT_BIAS_INITIALIZER=\"zeros\",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,tn(this.units,\"units\"),this.activation=fs(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Yt(e.kernelConstraint),this.biasConstraint=Yt(e.biasConstraint),this.kernelRegularizer=Nt(e.kernelRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Je(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight(\"kernel\",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(\"bias\",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Je(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e),a=m2(this.activation.getClassName()),r;return a!=null?r=or(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=or(n,this.kernel.read()),this.bias!=null&&(r=Ka(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:ms(this.activation),useBias:this.useBias,kernelInitializer:Et(this.kernelInitializer),biasInitializer:Et(this.biasInitializer),kernelRegularizer:ft(this.kernelRegularizer),biasRegularizer:ft(this.biasRegularizer),activityRegularizer:ft(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),biasConstraint:Xt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};V0.className=\"Dense\";ne.registerClass(V0);var U0=class extends We{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Je(e);for(let t of e.slice(1))if(t==null)throw new V(`The shape of the input to \"Flatten\" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete \"input_shape\" or \"batch_input_shape\" argument to the first layer in your model.`);return[e[0],rs(e,1)]}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);if(this.dataFormat===\"channelsFirst\"&&n.rank>1){let a=[0];for(let r=2;r<n.rank;++r)a.push(r);a.push(1),n=De(n,a)}return AG(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};U0.className=\"Flatten\";ne.registerClass(U0);var G0=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.activation=fs(e.activation)}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);return this.activation.apply(n)})}getConfig(){let e={activation:ms(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};G0.className=\"Activation\";ne.registerClass(G0);var H0=class extends We{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return O(()=>(e=Te(e),EG(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};H0.className=\"RepeatVector\";ne.registerClass(H0);var j0=class extends We{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n=\"Total size of new array must be unchanged.\",a=t.slice(),r=1,s=null;for(let o=0;o<a.length;++o){let l=a[o];if(this.isUnknown(l))if(s===null)s=o;else throw new V(\"Can only specifiy one unknown dimension.\");else r*=l}let i=rs(e);if(s!==null){if(r===0||i%r!==0)throw new V(n);a[s]=i/r}else if(i!==r)throw new V(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return W(n,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};j0.className=\"Reshape\";ne.registerClass(j0);var q0=class extends We{constructor(e){if(super(e),e.dims==null)throw new Error(\"Required configuration field `dims` is missing during Permute constructor call.\");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \\`dims\\` to be an Array, but received ${e.dims} instead.`);let t=Ua(1,e.dims.length+1);if(!w.arraysEqual(e.dims.slice().sort(),t))throw new Error(\"Invalid permutation `dims`: \"+JSON.stringify(e.dims)+\" `dims` must contain consecutive integers starting from 1.\");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new zt({ndim:this.dims.length+1})]}computeOutputShape(e){e=Je(e);let t=e.slice();return this.dims.forEach((n,a)=>{t[a+1]=e[n]}),t}call(e,t){return De(Te(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};q0.className=\"Permute\";ne.registerClass(q0);var K0=class extends We{constructor(e){super(e==null?{}:e),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Te(e);return yc(fi(n,this.maskValue),-1)}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e),a=yc(fi(n,this.maskValue),-1,!0);return z(n,re(a,n.dtype))})}};K0.className=\"Masking\";ne.registerClass(K0);var X0=class extends We{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER=\"randomUniform\",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(it(e.inputLength))}this.inputDim=e.inputDim,tn(this.inputDim,\"inputDim\"),this.outputDim=e.outputDim,tn(this.outputDim,\"outputDim\"),this.embeddingsInitializer=St(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Nt(e.embeddingsRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.embeddingsConstraint=Yt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight(\"embeddings\",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return O(()=>this.maskZero?(e=Te(e),fi(e,qe(e))):null)}computeOutputShape(e){if(e=Je(e),this.inputLength==null)return[...e,this.outputDim];let t=it(this.inputLength);if(t.length!==e.length-1)throw new V(`\"inputLength\" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let a=0;a<t.length;++a){let r=t[a],s=e[a+1];if(r!=null&&s!=null&&r!==s)throw new V(`\"inputLength\" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);n.dtype!==\"int32\"&&(n=ir(n,\"int32\"));let a=v2(this.embeddings.read(),W(n,[n.size]));return W(a,Je(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Et(this.embeddingsInitializer),embeddingsRegularizer:ft(this.embeddingsRegularizer),activityRegularizer:ft(this.activityRegularizer),embeddingsConstraint:Xt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};X0.className=\"Embedding\";ne.registerClass(X0);var Yo=class extends We{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ze}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){let r=e[e.length-t.length+a],s=t[a];if(r==null||s==null||r<0||s<0)n.push(null);else if(r===1)n.push(s);else if(s===1)n.push(r);else{if(r!==s)throw new V(\"Operands could not be broadcast together with shapes \"+JSON.stringify(e)+\" \"+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Je(e)]),e=e,e.length<2)throw new V(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=as(t),t.length>1)throw new V(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let a=e.map(r=>r.length);e.indexOf(null)===-1&&as(a).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return O(()=>{if(e=e,this.reshapeRequired){let n=[],a=e.map(r=>r.rank);if(a.indexOf(null)===-1){let r=hs(a);for(let s of e){let i=s.rank;for(let o=0;o<r-i;++o)s=wd(s,1);n.push(s)}return this.mergeFunction(n)}else{let r=!1;for(let o of e){let l=o.rank;if(l==null){let u=o.shape,p=u[0],d=u.slice(1).concat([p]),c=W(o,[p].concat(rs(u.slice(1))));c=De(c,[1,0]),c=W(c,d),n.push(c),r=!0}else if(l>1){let u=Ua(1,l).concat([0]);n.push(De(o,u)),r=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(r){if(i==null){let o=s.shape,l=o.length,u=o[l-1],p=[u].concat(o.slice(0,o.length-1));s=W(De(W(s,[-1,u]),[1,0]),p)}else if(i>1){let o=[i-1].concat(Ua(0,i-1));s=De(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let a=1;a<e.length;++a){let r=e[a]==null?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let a of e)a!=null&&a[0]!==null&&n.push(a[0]);return n=as(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return O(()=>{if(t==null)return null;if(!Array.isArray(t))throw new V(\"`mask` should be an Array\");if(!Array.isArray(e))throw new V(\"`inputs` should be an Array\");if(t.length!==e.length)throw new V(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(a=>a==null))return null;t=t.map(a=>a==null?a:Gt(a,0));let n=t[0];for(let a=1;a<t.length-1;++a)n=_a(n,t[a]);return n})}},Y0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return t})}};Y0.className=\"Add\";ne.registerClass(Y0);var Z0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=z(t,e[n]);return t})}};Z0.className=\"Multiply\";ne.registerClass(Z0);var J0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return z(1/e.length,t)})}};J0.className=\"Average\";ne.registerClass(J0);var Q0=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=hr(t,e[n]);return t})}};Q0.className=\"Maximum\";ne.registerClass(Q0);var e1=class extends Yo{constructor(e){super(e)}mergeFunction(e){return O(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ds(t,e[n]);return t})}};e1.className=\"Minimum\";ne.registerClass(e1);var t1=class extends Yo{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new V(\"A `Concatenate` layer should be called on a list of at least 2 inputs\");e=e;let t=!0;for(let a of e)if(a!=null){t=!1;break}if(t)return;let n=[];for(let a=0;a<e.length;++a){let r=e[a].slice();r.splice(this.axis,1);let s=!1;for(let i of n)if(w.arraysEqual(i,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new V(\"A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: \"+JSON.stringify(e))}mergeFunction(e){return O(()=>t0(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new V(\"A `Concatenate` layer should be called on a list of inputs.\");let t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(let r of t.slice(1)){if(n[a]==null||r[a]==null){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new V(\"`mask` should be an array for Concatenate\");if(!Array.isArray(e))throw new V(\"`inputs` should be an array for Concatenate\");if(t.length!==e.length)throw new V(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return O(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let a=[];for(let s=0;s<e.length;++s)t[s]==null?a.push(re(ea(e[s]),\"bool\")):t[s].rank<e[s].rank?a.push(Gt(t[s],-1)):a.push(t[s]);let r=et(a,this.axis);return Lm(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};t1.className=\"Concatenate\";ne.registerClass(t1);function Yp(e,t){for(;e<0;)e+=t;return e}function xj(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new ze(\"batchDot is not implemented for tensors of 4D or higher rank yet\");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n==\"number\"&&(n=[n,n]),e.dtype===\"complex64\"||t.dtype===\"complex64\")throw new ze(\"batchDot is not implemented for complex64-type Tensors yet.\");let a=e.shape.length,r=t.shape.length;n==null&&(n=[a-1,r-2]);let s=n;return O(()=>{let i;if(a>r){i=a-r;let l=[];for(let u=0;u<i;++u)l.push(1);t=W(t,t.shape.concat(l))}else if(r>a){i=r-a;let l=[];for(let u=0;u<i;++u)l.push(1);e=W(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=fe(z(e,t),s[0]):o=fe(z(De(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,u=s[1]===t.shape.length-1;o=$e(e,t,l,u)}if(i>0){let l;a>r?l=a+r-3:l=a-1;let u=[];for(let p=l;p<l+i;++p)u.push(p);o=As(o,u)}return o.shape.length===1&&(o=Gt(o,1)),o})}var n1=class extends Yo{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>\"A `Dot` layer should be called on a list of exactly 2 inputs.\");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new ze(\"Dot layer does not support tensors of 4D or higher rank yet.\");let a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new V(`Dimension incompatibility: ${t[a[0]]} !== ${n[a[1]]}`)}mergeFunction(e){if(e.length!==2)throw new V(`A \\`Dot\\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],a;return Array.isArray(this.axes)?a=this.axes.map((r,s)=>Yp(r,e[s].shape.length)):a=[Yp(this.axes,t.shape.length),Yp(this.axes,n.shape.length)],this.normalize&&(t=tm(t,a[0]),n=tm(n,a[1])),xj(t,n,a)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Yp(this.axes,e.length),Yp(this.axes,t.length)],n}computeOutputShape(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>\"A `Dot` layer should be called on a list of exactly 2 inputs.\");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new ze(\"Dot layer does not support tensors of 4D or higher rank yet.\");let a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);let r=t.concat(n);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};n1.className=\"Dot\";ne.registerClass(n1);var a1=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);return Id(()=>X(bf(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};a1.className=\"GaussianNoise\";ne.registerClass(a1);var r1=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return O(()=>{this.invokeCallHook(e,t);let n=Te(e);return this.rate>0&&this.rate<1?Id(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return z(n,bf(n.shape,1,a))},()=>n,t.training||!1):n})}};r1.className=\"GaussianDropout\";ne.registerClass(r1);var s1=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Te(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return O(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Id(()=>{let a=Te(e),r=-1.6732632423543772*1.0507009873554805,s=$r(Es(n),this.rate);s=ir(s,\"float32\");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate,l=X(z(a,s),z(X(s,-1),r));return X(z(l,i),o)},()=>Te(e),t.training||!1)}return e})}};s1.className=\"AlphaDropout\";ne.registerClass(s1);function Sc(e,t,n,a,r,s=.001){let i;if(e.rank===2)i=qv(e,t,n,a,r,s);else if(e.rank===3)i=Kv(e,t,n,a,r,s);else if(e.rank===4)i=Xv(e,t,n,a,r,s);else throw new ze(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function vj(e,t,n,a,r=.001){return O(()=>{let s=hd(e,a),i=s.mean,o=s.variance;return[Sc(e,i,o,n,t,r),i,o]})}function wj(e,t,n,a,r=.001){return O(()=>{let s=hd(e,a),i=s.mean,o=s.variance,l=[];for(let h of Ua(0,e.rank))a.indexOf(h)!==-1?l.push(1):l.push(e.shape[h]);let u=W(i,l),p=W(o,l),d=t==null?null:W(t,l),c=n==null?null:W(n,l);return[Sc(e,u,p,c,d,r),i,o]})}function kj(e,t,n,a,r=.001){return w.arraysEqual(a.slice().sort(),Ua(0,e.rank-1))?vj(e,t,n,a,r):wj(e,t,n,a,r)}var i1=class extends We{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=St(e.betaInitializer||\"zeros\"),this.gammaInitializer=St(e.gammaInitializer||\"ones\"),this.movingMeanInitializer=St(e.movingMeanInitializer||\"zeros\"),this.movingVarianceInitializer=St(e.movingVarianceInitializer||\"ones\"),this.betaConstraint=Yt(e.betaConstraint),this.gammaConstraint=Yt(e.gammaConstraint),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer)}build(e){e=Je(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new V(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new zt({ndim:e.length,axes:{[t]:n}})];let a=[n];this.scale&&(this.gamma=this.addWeight(\"gamma\",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight(\"beta\",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight(\"moving_mean\",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight(\"moving_variance\",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return O(()=>{let n=t.training==null?!1:t.training,a=Te(e),r=a.shape,s=r.length,i=Ua(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=bi(1,s);l[o]=r[o];let u=i.slice();u.sort();let p=!w.arraysEqual(u,Ua(0,s).slice(0,s-1)),d=()=>{if(p){let g=W(this.movingMean.read(),l),b=W(this.movingVariance.read(),l),y=this.center?W(this.beta.read(),l):null,x=this.scale?W(this.gamma.read(),l):null;return Sc(a,g,b,y,x,this.epsilon)}else return Sc(a,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[c,h,m]=kj(a,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(g,b,y)=>{O(()=>{let x=1-y,v=g.read(),I=z(pe(v,b),x);g.write(pe(v,I))})};return f(this.movingMean,h,this.momentum),f(this.movingVariance,m,this.momentum),c})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Et(this.betaInitializer),gammaInitializer:Et(this.gammaInitializer),movingMeanInitializer:Et(this.movingMeanInitializer),movingVarianceInitializer:Et(this.movingVarianceInitializer),betaRegularizer:ft(this.betaRegularizer),gammaRegularizer:ft(this.gammaRegularizer),betaConstraint:Xt(this.betaConstraint),gammaConstraint:Xt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};i1.className=\"BatchNormalization\";ne.registerClass(i1);var o1=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis==\"number\"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=St(e.betaInitializer||\"zeros\"),this.gammaInitializer=St(e.gammaInitializer||\"ones\"),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Je(e);let t=e.length;typeof this.axis==\"number\"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==as(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(r=>e[r]),a=!0;this.scale?this.gamma=this.addWeight(\"gamma\",n,\"float32\",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight(\"beta\",n,\"float32\",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){let n=Te(e),a=n.shape,r=a.length;return O(()=>{let{mean:s,variance:i}=hd(n,this.axis,!0),o=bi(1,r);for(let h of this.axis)o[h]=a[h];let l=h=>h!=null&&h.shape.length!==r?W(h,o):h,u=this.scale?l(this.gamma.read()):null,p=this.center?l(this.beta.read()):null,d=[],c=[];for(let h=0;h<r;++h)this.axis.indexOf(h)!==-1?(d.push(a[h]),c.push(1)):(d.push(1),c.push(a[h]));return s=On(s,d),i=On(i,d),u!=null&&(u=On(u,c)),p!=null&&(p=On(p,c)),Sc(n,s,i,p,u,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Et(this.betaInitializer),gammaInitializer:Et(this.gammaInitializer),betaRegularizer:ft(this.betaRegularizer),gammaRegularizer:ft(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};o1.className=\"LayerNormalization\";ne.registerClass(o1);function Ij(e,t,n){return O(()=>{if(e.rank!==4)throw new V(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new V(\"spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.\");if(n==null&&(n=Ga()),n!==\"channelsLast\"&&n!==\"channelsFirst\")throw new V(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let a;return n===\"channelsFirst\"?a=[[0,0],[0,0],t[0],t[1]]:a=[[0,0],t[0],t[1],[0,0]],xa(e,a)})}var l1=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ga():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding==\"number\")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new V(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]==\"number\")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new V(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new V(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new zt({ndim:4})]}computeOutputShape(e){e=Je(e);let t,n;return this.dataFormat===\"channelsFirst\"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return O(()=>Ij(Te(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};l1.className=\"ZeroPadding2D\";ne.registerClass(l1);function Pf(e,t,n,a,r,s){return O(()=>{Rt(r),g2(s),va(a),n==null&&(n=[1,1]),a==null&&(a=\"valid\"),r==null&&(r=Ga()),s==null&&(s=\"max\"),e=_0(e,r);let i,o=a===\"same\"?\"same\":\"valid\";return s===\"max\"?i=Dt(e,t,n,o):i=ya(e,t,n,o),r===\"channelsFirst\"&&(i=De(i,[0,3,1,2])),i})}function wC(e,t,n,a,r,s){return O(()=>{Rt(r),g2(s),va(a),n==null&&(n=[1,1,1]),a==null&&(a=\"valid\"),r==null&&(r=Ga()),s==null&&(s=\"max\"),e=uC(e,r);let i,o=a===\"same\"?\"same\":\"valid\";return s===\"max\"?i=xw(e,t,n,o):i=jv(e,t,n,o),r===\"channelsFirst\"&&(i=De(i,[0,4,1,2,3])),i})}var kC=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize==\"number\")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]==\"number\")this.poolSize=e.poolSize;else throw new V(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(tn(this.poolSize,\"poolSize\"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides==\"number\")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]==\"number\")this.strides=e.strides;else throw new V(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);tn(this.strides,\"strides\"),this.padding=e.padding==null?\"valid\":e.padding,va(this.padding),this.inputSpec=[new zt({ndim:3})]}computeOutputShape(e){e=Je(e);let t=Va(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return O(()=>{this.invokeCallHook(e,t),e=wd(Te(e),2);let n=this.poolingFunction(Te(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,\"channelsLast\");return As(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},u1=class extends kC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"max\")}};u1.className=\"MaxPooling1D\";ne.registerClass(u1);var p1=class extends kC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"avg\")}};p1.className=\"AveragePooling1D\";ne.registerClass(p1);var IC=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new V(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];tn(this.poolSize,\"poolSize\"),tn(this.strides,\"strides\"),this.padding=e.padding==null?\"valid\":e.padding,this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),va(this.padding),this.inputSpec=[new zt({ndim:4})]}computeOutputShape(e){e=Je(e);let t=this.dataFormat===\"channelsFirst\"?e[2]:e[1],n=this.dataFormat===\"channelsFirst\"?e[3]:e[2];return t=Va(t,this.poolSize[0],this.padding,this.strides[0]),n=Va(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat===\"channelsFirst\"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return O(()=>(this.invokeCallHook(e,t),this.poolingFunction(Te(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},c1=class extends IC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"max\")}};c1.className=\"MaxPooling2D\";ne.registerClass(c1);var d1=class extends IC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),Pf(e,t,n,a,r,\"avg\")}};d1.className=\"AveragePooling2D\";ne.registerClass(d1);var SC=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new V(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];tn(this.poolSize,\"poolSize\"),tn(this.strides,\"strides\"),this.padding=e.padding==null?\"valid\":e.padding,this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),va(this.padding),this.inputSpec=[new zt({ndim:5})]}computeOutputShape(e){e=Je(e);let t=this.dataFormat===\"channelsFirst\"?e[2]:e[1],n=this.dataFormat===\"channelsFirst\"?e[3]:e[2],a=this.dataFormat===\"channelsFirst\"?e[4]:e[3];return t=Va(t,this.poolSize[0],this.padding,this.strides[0]),n=Va(n,this.poolSize[1],this.padding,this.strides[1]),a=Va(a,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat===\"channelsFirst\"?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return O(()=>(this.invokeCallHook(e,t),this.poolingFunction(Te(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},h1=class extends SC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),wC(e,t,n,a,r,\"max\")}};h1.className=\"MaxPooling3D\";ne.registerClass(h1);var m1=class extends SC{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return Rt(r),va(a),wC(e,t,n,a,r,\"avg\")}};m1.className=\"AveragePooling3D\";ne.registerClass(m1);var NC=class extends We{constructor(e){super(e),this.inputSpec=[new zt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ze}},f1=class extends NC{constructor(e){super(e||{})}call(e,t){return O(()=>{let n=Te(e);return Ct(n,1)})}};f1.className=\"GlobalAveragePooling1D\";ne.registerClass(f1);var g1=class extends NC{constructor(e){super(e||{})}call(e,t){return O(()=>{let n=Te(e);return ma(n,1)})}};g1.className=\"GlobalMaxPooling1D\";ne.registerClass(g1);var TC=class extends We{constructor(e){super(e),this.dataFormat=e.dataFormat==null?\"channelsLast\":e.dataFormat,Rt(this.dataFormat),this.inputSpec=[new zt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat===\"channelsLast\"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ze}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},b1=class extends TC{call(e,t){return O(()=>{let n=Te(e);return this.dataFormat===\"channelsLast\"?Ct(n,[1,2]):Ct(n,[2,3])})}};b1.className=\"GlobalAveragePooling2D\";ne.registerClass(b1);var y1=class extends TC{call(e,t){return O(()=>{let n=Te(e);return this.dataFormat===\"channelsLast\"?ma(n,[1,2]):ma(n,[2,3])})}};y1.className=\"GlobalMaxPooling2D\";ne.registerClass(y1);var CC=class extends We{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let a=t.layer,r=Ba(a,n);delete t.layer;let s={layer:r};return Object.assign(s,t),new e(s)}},x1=class extends CC{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Je(e),e.length<3)throw new V(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Je(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return O(()=>(e=Te(e),yC((n,a)=>[Te(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};x1.className=\"TimeDistributed\";ne.registerClass(x1);function Sj(e){Ko(IG,\"BidirectionalMergeMode\",e)}var Nj=\"concat\",v1=class extends CC{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ba(n),t.goBackwards=t.goBackwards!==!0;let a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=Ba(a),this.forwardLayer.name=\"forward_\"+this.forwardLayer.name,this.backwardLayer.name=\"backward_\"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Nj:e.mergeMode,Sj(this.mergeMode),e.weights)throw new ze(\"weights support is not implemented for Bidirectional layer yet.\");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,a,r;return this.returnState&&(r=t.slice(1)),n=t[0],n=n,this.mergeMode===\"concat\"?(n[n.length-1]*=2,a=[n]):this.mergeMode==null?a=[n,n.slice()]:a=[n],this.returnState?this.mergeMode==null?a.concat(r).concat(r.slice()):[n].concat(r).concat(r.slice()):Mn(a)}apply(e,t){let n=t==null?null:t.initialState,a=t==null?null:t.constants;t==null&&(t={});let r=bC(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&a==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new V(\"When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.\");t.initialState=n,s.push(...n);let u=n.map(p=>new zt({shape:p.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),i.push(...u)}if(a!=null)throw new ze(\"Support for constants in Bidirectional layers is not implemented yet.\");let o=s[0]instanceof Ha;for(let l of s)if(l instanceof Ha!==o)throw new V(\"The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors\");if(o){let l=[e].concat(s),u=this.inputSpec.concat(i),p=this.inputSpec;this.inputSpec=u;let d=super.apply(l,t);return this.inputSpec=p,d}else return super.apply(e,t)}call(e,t){return O(()=>{let n=t.initialState,a,r;if(n==null)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=ba(r,1));let i;return this.mergeMode===\"concat\"?i=t0([a,r]):this.mergeMode===\"sum\"?i=X(a,r):this.mergeMode===\"ave\"?i=z(.5,X(a,r)):this.mergeMode===\"mul\"?i=z(a,r):this.mergeMode==null&&(i=[a,r]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ri(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ri(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let a=this.forwardLayer.states.map(r=>null);return Array.isArray(n)?n.concat(a).concat(a):[n].concat(a).concat(a)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Ba(t.layer);if(delete t.layer,t.numConstants!=null)throw new ze(\"Deserialization of a Bidirectional layer with numConstants present is not supported yet.\");let a=t;return a.layer=n,new e(a)}};v1.className=\"Bidirectional\";ne.registerClass(v1);var w1=class extends We{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return O(()=>(e=Te(e),e.dtype!==\"float32\"&&(e=ir(e,\"float32\")),X(z(e,this.scale),this.offset)))}};w1.className=\"Rescaling\";ne.registerClass(w1);var{resizeBilinear:Tj,cropAndResize:Cj}=Zn,k1=class extends We{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,s,i,o){return O(()=>{let l,u=!1,p=t/s,d=n/i,c=(a+t)/s,h=(r+n)/i,m=[p,d,c,h],f=[];e.rank===3?(u=!0,l=At([e])):l=e;for(let x=0;x<l.shape[0];x++)f.push(m);let g=bn(f,[f.length,4]),b=gi(0,f.length,1,\"int32\"),y=Cj(l,g,b,[a,r],\"nearest\");return ir(u?Te(dt(y)):y,o)})}upsize(e,t,n,a){return O(()=>{let r=Tj(e,[t,n]);return ir(r,a)})}call(e,t){return O(()=>{let n=Te(e),a=n.dtype,r=n.shape,s=r[r.length-3],i=r[r.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,a):this.upsize(e,this.height,this.width,a)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Je(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};k1.className=\"CenterCrop\";ne.registerClass(k1);function Ej(e,t,n,a){let r=Te(e);if(r.dtype!==\"int32\"&&(r=ir(r,\"int32\")),t===\"int\")return r;let s=r.shape;if(r.rank===0&&(r=Gt(r,-1)),t===\"oneHot\"&&r.shape[r.shape.length-1]!==1&&(r=Gt(r,-1)),r.rank>2)throw new V(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);let i=[\"multiHot\",\"oneHot\"].includes(t),o=r,l;if(typeof a!=\"undefined\"&&t===\"count\"?l=Xh(o,a,n,i):l=Xh(o,[],n,i),t!==\"tfIdf\")return l;if(a)return z(l,a);throw new V(\"When outputMode is 'tfIdf', weights must be provided.\")}var I1=class extends We{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode=\"multiHot\"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Je(e),e==null?[this.numTokens]:this.outputMode===\"oneHot\"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return O(()=>{e=Te(e),e.dtype!==\"int32\"&&(e=ir(e,\"int32\"));let n;if(typeof t.countWeights!=\"undefined\"){if(this.outputMode!==\"count\")throw new V(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Te(t.countWeights)}let a=ma(e),r=Ol(e),s=Cn(this.numTokens,a).bufferSync().get(0),i=$r(r,0).bufferSync().get(0);if(!(s&&i))throw new V(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Ej(e,this.outputMode,this.numTokens,n)})}};I1.className=\"CategoryEncoding\";ne.registerClass(I1);var _j=[\"bilinear\",\"nearest\"],RI=new Set(_j),S1=class extends We{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(RI.has(e.interpolation))this.interpolation=e.interpolation;else throw new V(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation=\"bilinear\";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Je(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return O(()=>{let n=[this.height,this.width];if(this.interpolation===\"bilinear\")return Zn.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation===\"nearest\")return Zn.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...RI]} are supported`)})}};S1.className=\"Resizing\";ne.registerClass(S1);var EC=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};EC.className=\"RandomSeed\";var _C=class extends We{constructor(e){super(e),this.randomGenerator=new EC(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};_C.className=\"BaseRandomLayer\";var Aj=[\"bilinear\",\"nearest\"],MI=new Set(Aj),N1=class extends _C{constructor(e){super(e);let{factor:t,interpolation:n=\"bilinear\"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new V(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new V(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new V(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n)if(MI.has(n))this.interpolation=n;else throw new V(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Je(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return O(()=>{let n=Te(e);this.imgHeight=n.shape[n.shape.length-3];let a=n.shape[n.shape.length-2];this.widthFactor=Es([1],1+this.widthLower,1+this.widthUpper,\"float32\",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*a;r=Math.round(r);let s=[this.imgHeight,r];switch(this.interpolation){case\"bilinear\":return Zn.resizeBilinear(e,s);case\"nearest\":return Zn.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...MI]} are supported`)}})}};N1.className=\"RandomWidth\";ne.registerClass(N1);function Fj(e){return new rp(e)}function $j(e){return new T0(e)}function Dj(e){return new I0(e)}function Rj(e){return new S0(e)}function Mj(e){return new N0(e)}function Oj(e){return new E0(e)}function Pj(e){return new C0(e)}function Lj(e){return new D0(e)}function zj(e){return new Af(e)}function Wj(e){return new A0(e)}function Bj(e){return new Ff(e)}function Vj(e){return new F0(e)}function Uj(e){return new $0(e)}function Gj(e){return new R0(e)}function Hj(e){return new M0(e)}function jj(e){return new O0(e)}function qj(e){return new G0(e)}function Kj(e){return new V0(e)}function Xj(e){return new Of(e)}function Yj(e){return new B0(e)}function Zj(e){return new U0(e)}function Jj(e){return new H0(e)}function Qj(e){return new j0(e)}function e6(e){return new q0(e)}function t6(e){return new X0(e)}function n6(e){return new Y0(e)}function a6(e){return new J0(e)}function r6(e){return new t1(e)}function s6(e){return new Q0(e)}function i6(e){return new e1(e)}function o6(e){return new Z0(e)}function l6(e){return new n1(e)}function u6(e){return new i1(e)}function p6(e){return new o1(e)}function c6(e){return new l1(e)}function T1(e){return new p1(e)}function d6(e){return T1(e)}function h6(e){return T1(e)}function C1(e){return new d1(e)}function m6(e){return C1(e)}function f6(e){return C1(e)}function E1(e){return new m1(e)}function g6(e){return E1(e)}function b6(e){return E1(e)}function y6(e){return new f1(e)}function x6(e){return new b1(e)}function AC(e){return new g1(e)}function FC(e){return new y1(e)}function $C(e){return new u1(e)}function DC(e){return new c1(e)}function v6(e){return new h1(e)}function w6(e){return new L0(e)}function k6(e){return new Df(e)}function I6(e){return new z0(e)}function S6(e){return new Cd(e)}function N6(e){return new P0(e)}function T6(e){return new $f(e)}function C6(e){return new W0(e)}function E6(e){return new Mf(e)}function _6(e){return new Mr(e)}function A6(e){return new Rf(e)}function F6(e){return new v1(e)}function $6(e){return new x1(e)}var D6=AC,R6=FC,M6=$C,O6=DC;function P6(e){return new a1(e)}function L6(e){return new r1(e)}function z6(e){return new s1(e)}function W6(e){return new K0(e)}function B6(e){return new w1(e)}function V6(e){return new k1(e)}function U6(e){return new S1(e)}function G6(e){return new I1(e)}function H6(e){return new N1(e)}var RC={};_e(RC,{MAPE:()=>nq,MSE:()=>sq,binaryAccuracy:()=>j6,binaryCrossentropy:()=>q6,categoricalAccuracy:()=>X6,categoricalCrossentropy:()=>Y6,cosineProximity:()=>Q6,mape:()=>aq,meanAbsoluteError:()=>eq,meanAbsolutePercentageError:()=>tq,meanSquaredError:()=>rq,mse:()=>iq,precision:()=>Z6,r2Score:()=>oq,recall:()=>J6,sparseCategoricalAccuracy:()=>K6});function j6(e,t){return b0(e,t)}function q6(e,t){return P2(e,t)}function K6(e,t){return L2(e,t)}function X6(e,t){return y0(e,t)}function Y6(e,t){return x0(e,t)}function Z6(e,t){return O2(e,t)}function J6(e,t){return _H(e,t)}function Q6(e,t){return g0(e,t)}function eq(e,t){return Tf(e,t)}function tq(e,t){return sp(e,t)}function nq(e,t){return sp(e,t)}function aq(e,t){return sp(e,t)}function rq(e,t){return Xo(e,t)}function sq(e,t){return Xo(e,t)}function iq(e,t){return Xo(e,t)}function oq(e,t){return AH(e,t)}var MC={};_e(MC,{modelFromJSON:()=>ij});var OC={};_e(OC,{l1:()=>uq,l1l2:()=>lq,l2:()=>pq});function lq(e){return new Nd(e)}function uq(e){return hj(e)}function pq(e){return mj(e)}var PC=class extends Gl{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Er))throw new Error(\"model must be a LayersModel, not some other Container\");this.model=e}};function Nh(e,t){return e<t}function OI(e,t){return e>t}var LC=class extends PC{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new ze(\"restoreBestWeights = True is not implemented in EarlyStopping yet.\");this.monitor=e.monitor||\"val_loss\",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||\"auto\",this.baseline=e.baseline,[\"auto\",\"min\",\"max\"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode=\"auto\"),this.mode===\"min\"?this.monitorFunc=Nh:this.mode===\"max\"?this.monitorFunc=OI:this.monitor.indexOf(\"acc\")!==-1?this.monitorFunc=OI:this.monitorFunc=Nh,this.monitorFunc===Nh&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Nh?1/0:-1/0}async onEpochEnd(e,t){await Kr(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function cq(e){return new LC(e)}var dq={earlyStopping:cq},hq=G();hq.registerFlag(\"KEEP_INTERMEDIATE_TENSORS\",()=>!1,e=>{e&&console.warn(\"Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.\")});var qn;(function(e){e[e.DT_INVALID=0]=\"DT_INVALID\",e[e.DT_FLOAT=1]=\"DT_FLOAT\",e[e.DT_DOUBLE=2]=\"DT_DOUBLE\",e[e.DT_INT32=3]=\"DT_INT32\",e[e.DT_UINT8=4]=\"DT_UINT8\",e[e.DT_INT16=5]=\"DT_INT16\",e[e.DT_INT8=6]=\"DT_INT8\",e[e.DT_STRING=7]=\"DT_STRING\",e[e.DT_COMPLEX64=8]=\"DT_COMPLEX64\",e[e.DT_INT64=9]=\"DT_INT64\",e[e.DT_BOOL=10]=\"DT_BOOL\",e[e.DT_QINT8=11]=\"DT_QINT8\",e[e.DT_QUINT8=12]=\"DT_QUINT8\",e[e.DT_QINT32=13]=\"DT_QINT32\",e[e.DT_BFLOAT16=14]=\"DT_BFLOAT16\",e[e.DT_QINT16=15]=\"DT_QINT16\",e[e.DT_QUINT16=16]=\"DT_QUINT16\",e[e.DT_UINT16=17]=\"DT_UINT16\",e[e.DT_COMPLEX128=18]=\"DT_COMPLEX128\",e[e.DT_HALF=19]=\"DT_HALF\",e[e.DT_RESOURCE=20]=\"DT_RESOURCE\",e[e.DT_VARIANT=21]=\"DT_VARIANT\",e[e.DT_UINT32=22]=\"DT_UINT32\",e[e.DT_UINT64=23]=\"DT_UINT64\",e[e.DT_FLOAT_REF=101]=\"DT_FLOAT_REF\",e[e.DT_DOUBLE_REF=102]=\"DT_DOUBLE_REF\",e[e.DT_INT32_REF=103]=\"DT_INT32_REF\",e[e.DT_UINT8_REF=104]=\"DT_UINT8_REF\",e[e.DT_INT16_REF=105]=\"DT_INT16_REF\",e[e.DT_INT8_REF=106]=\"DT_INT8_REF\",e[e.DT_STRING_REF=107]=\"DT_STRING_REF\",e[e.DT_COMPLEX64_REF=108]=\"DT_COMPLEX64_REF\",e[e.DT_INT64_REF=109]=\"DT_INT64_REF\",e[e.DT_BOOL_REF=110]=\"DT_BOOL_REF\",e[e.DT_QINT8_REF=111]=\"DT_QINT8_REF\",e[e.DT_QUINT8_REF=112]=\"DT_QUINT8_REF\",e[e.DT_QINT32_REF=113]=\"DT_QINT32_REF\",e[e.DT_BFLOAT16_REF=114]=\"DT_BFLOAT16_REF\",e[e.DT_QINT16_REF=115]=\"DT_QINT16_REF\",e[e.DT_QUINT16_REF=116]=\"DT_QUINT16_REF\",e[e.DT_UINT16_REF=117]=\"DT_UINT16_REF\",e[e.DT_COMPLEX128_REF=118]=\"DT_COMPLEX128_REF\",e[e.DT_HALF_REF=119]=\"DT_HALF_REF\",e[e.DT_RESOURCE_REF=120]=\"DT_RESOURCE_REF\",e[e.DT_VARIANT_REF=121]=\"DT_VARIANT_REF\",e[e.DT_UINT32_REF=122]=\"DT_UINT32_REF\",e[e.DT_UINT64_REF=123]=\"DT_UINT64_REF\"})(qn||(qn={}));var PI;(function(e){let t;(function(n){n[n.LEGACY=0]=\"LEGACY\",n[n.V1=1]=\"V1\",n[n.V2=2]=\"V2\"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(PI||(PI={}));var _1={};function mq(e,t){let n={tfOpName:e,category:\"custom\",inputs:[],attrs:[],customExecutor:t};_1[e]=n}function zC(e){return _1[e]}function fq(e){delete _1[e]}function k(e,t,n,a,r){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(s.type===\"tensor\")return pn(t.inputNames[u],n,a,r);if(s.type===\"tensors\"){let c=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((h,m)=>{var f;return((f=c[m])===null||f===void 0?void 0:f.op)!==\"NoOp\"}).map(h=>pn(h,n,a,r))}let p=pn(t.inputNames[u],n,a,r),d=p.dataSync();return s.type===\"number\"?d[0]:w.toNestedArray(p.shape,d)}let i=t.attrParams[e];return i&&i.value}function pn(e,t,n,a){let[r,s]=Xn(e,n);if(a!=null){let o=a.getHashTableHandleByName(r);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[im(r,o)]);return i!==void 0?t[im(r,i)][s]:void 0}function LI(e,t,n){return t[im(e,n.currentContextId)]}function Sr(e,t){let[n,a,r]=Xn(e,t);return[im(n,t&&t.currentContextId),a,r]}function im(e,t){return t?`${e}-${t}`:e}function Xn(e,t){if(e===\"\")return[\"\",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let a=e.split(\":\"),r;if(a.length===1)r=[e,0,void 0];else{let s=a[0],i=a.length===3?a[1]:void 0,o=Number(a[a.length-1]);r=[s,o,i]}return n&&t.parseNodeNameCache.set(e,r),r}function Mh(e,t,n){let a=k(\"pad\",e,t,n);if(a===\"explicit\"){a=k(\"explicitPaddings\",e,t,n);let r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=a[s*2],r[s][1]=a[s*2+1];return r}return a}function Nr(e){return e.kept?e:sr(e)}var WC={};_e(WC,{json:()=>gq});var gq=[{tfOpName:\"Add\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"AddV2\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"AddN\",category:\"arithmetic\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}]},{tfOpName:\"BiasAdd\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"Sub\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"RealDiv\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Div\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"DivNoNan\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"FloorDiv\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Mul\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Maximum\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Minimum\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Pow\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"SquaredDifference\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Mod\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"FloorMod\",category:\"arithmetic\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]}],BC={};_e(BC,{json:()=>bq});var bq=[{tfOpName:\"Abs\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Acos\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Asin\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Atan\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Atan2\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"y\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Ceil\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ClipByValue\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"clipValueMin\",type:\"number\"},{start:2,name:\"clipValueMax\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Complex\",category:\"basic_math\",inputs:[{start:0,name:\"real\",type:\"tensor\"},{start:1,name:\"imag\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ComplexAbs\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Cos\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Cosh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Elu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Exp\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Floor\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Log\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Imag\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"outputType\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Neg\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Real\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"outputType\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Prelu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"alpha\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Relu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Relu6\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Selu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sigmoid\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sin\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sinh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sqrt\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Rsqrt\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Square\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Tan\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Tanh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Sign\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Round\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Expm1\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Log1p\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Reciprocal\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Softplus\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Asinh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Acosh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Atanh\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Erf\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LeakyRelu\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"alpha\",name:\"alpha\",type:\"number\",defaultValue:.2},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"IsNan\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"IsFinite\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"IsInf\",category:\"basic_math\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]}],VC={};_e(VC,{json:()=>yq});var yq=[{tfOpName:\"EmptyTensorList\",category:\"control\",inputs:[{start:0,name:\"elementShape\",type:\"shape\"},{start:1,name:\"maxNumElements\",type:\"number\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"LoopCond\",category:\"control\",inputs:[{start:0,name:\"pred\",type:\"tensor\"}]},{tfOpName:\"Switch\",category:\"control\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"pred\",type:\"tensor\"}]},{tfOpName:\"Merge\",category:\"control\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}]},{tfOpName:\"Enter\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"frame_name\",name:\"frameName\",type:\"string\"},{tfName:\"is_constant\",name:\"isConstant\",type:\"bool\"}]},{tfOpName:\"Exit\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"NextIteration\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"TensorArrayV3\",category:\"control\",inputs:[{start:0,name:\"size\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"},{tfName:\"dynamic_size\",name:\"dynamicSize\",type:\"bool\"},{tfName:\"clear_after_read\",name:\"clearAfterRead\",type:\"bool\"},{tfName:\"identical_element_shapes\",name:\"identicalElementShapes\",type:\"bool\"},{tfName:\"tensor_array_name\",name:\"name\",type:\"string\"}]},{tfOpName:\"TensorArrayWriteV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"tensor\",type:\"tensor\"},{start:3,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"TensorArrayReadV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"TensorArrayGatherV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"}]},{tfOpName:\"TensorArrayScatterV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"tensor\",type:\"tensor\"},{start:3,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"TensorArrayConcatV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"element_shape_except0\",name:\"elementShapeExcept0\",type:\"shape\",notSupported:!0}]},{tfOpName:\"TensorArraySplitV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"tensor\",type:\"tensor\"},{start:2,name:\"lengths\",type:\"number[]\"},{start:3,name:\"flowIn\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"TensorArraySizeV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"},{start:1,name:\"flowIn\",type:\"number\"}]},{tfOpName:\"TensorArrayCloseV3\",category:\"control\",inputs:[{start:0,name:\"tensorArrayId\",type:\"tensor\"}]},{tfOpName:\"StatelessIf\",category:\"control\",inputs:[{start:0,name:\"cond\",type:\"tensor\"},{start:1,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"then_branch\",name:\"thenBranch\",type:\"func\"},{tfName:\"else_branch\",name:\"elseBranch\",type:\"func\"}]},{tfOpName:\"If\",category:\"control\",inputs:[{start:0,name:\"cond\",type:\"tensor\"},{start:1,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"then_branch\",name:\"thenBranch\",type:\"func\"},{tfName:\"else_branch\",name:\"elseBranch\",type:\"func\"}]},{tfOpName:\"StatelessWhile\",category:\"control\",inputs:[{start:0,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"cond\",name:\"cond\",type:\"func\"},{tfName:\"body\",name:\"body\",type:\"func\"}]},{tfOpName:\"While\",category:\"control\",inputs:[{start:0,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"cond\",name:\"cond\",type:\"func\"},{tfName:\"body\",name:\"body\",type:\"func\"}]},{tfOpName:\"TensorListScatter\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListScatterV2\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"elementShape\",type:\"shape\"},{start:3,name:\"numElements\",type:\"number\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListGather\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"indices\",type:\"number[]\"},{start:2,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListGetItem\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListSetItem\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"index\",type:\"number\"},{start:2,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListReserve\",category:\"control\",inputs:[{start:0,name:\"elementShape\",type:\"shape\"},{start:1,name:\"numElements\",type:\"number\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListFromTensor\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListStack\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"},{tfName:\"num_elements\",name:\"numElements\",type:\"dtype\"}]},{tfOpName:\"TensorListSplit\",category:\"control\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"},{start:2,name:\"lengths\",type:\"number[]\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListConcat\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"}],attrs:[{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"},{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListConcatV2\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"}],attrs:[{tfName:\"element_shape\",name:\"elementShape\",type:\"shape\"},{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListPopBack\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"elementShape\",type:\"shape\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListPushBack\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"element_dtype\",name:\"elementDType\",type:\"dtype\"}]},{tfOpName:\"TensorListLength\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"}]},{tfOpName:\"TensorListResize\",category:\"control\",inputs:[{start:0,name:\"tensorListId\",type:\"tensor\"},{start:1,name:\"size\",type:\"number\"}]}],UC={};_e(UC,{json:()=>xq});var xq=[{tfOpName:\"AvgPool\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MaxPool\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[],notSupported:!0},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MaxPoolWithArgmax\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"include_batch_in_index\",name:\"includeBatchInIndex\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"AvgPool3D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MaxPool3D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"ksize\",name:\"kernelSize\",type:\"number[]\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Conv1D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"stride\",name:\"stride\",type:\"number\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NWC\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"dilation\",name:\"dilation\",type:\"number\",defaultValue:1}]},{tfOpName:\"Conv2D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"useCudnnOnGpu\",name:\"useCudnnOnGpu\",type:\"bool\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"_FusedConv2D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"},{start:2,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"num_args\",name:\"numArgs\",type:\"number\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"use_cudnn_on_gpu\",name:\"useCudnnOnGpu\",type:\"bool\",defaultValue:!0},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\",defaultValue:[1,1,1,1]},{tfName:\"fused_ops\",name:\"fusedOps\",type:\"string[]\",defaultValue:[]},{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:1e-4},{tfName:\"leakyrelu_alpha\",name:\"leakyreluAlpha\",type:\"number\",defaultValue:.2}]},{tfOpName:\"Conv2DBackpropInput\",category:\"convolution\",inputs:[{start:2,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"},{start:0,name:\"outputShape\",type:\"number[]\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\",notSupported:!0}]},{tfOpName:\"DepthwiseConv2d\",category:\"convolution\",inputs:[{start:0,name:\"input\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"DepthwiseConv2dNative\",category:\"convolution\",inputs:[{start:0,name:\"input\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"FusedDepthwiseConv2dNative\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"},{start:2,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"num_args\",name:\"numArgs\",type:\"number\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\",defaultValue:[1,1,1,1]},{tfName:\"fused_ops\",name:\"fusedOps\",type:\"string[]\",defaultValue:[]},{tfName:\"explicit_paddings\",name:\"explicitPaddings\",type:\"number[]\",defaultValue:[]}]},{tfOpName:\"Conv3D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",defaultValue:\"NHWC\"},{tfName:\"dilations\",name:\"dilations\",type:\"number[]\"}]},{tfOpName:\"Dilation2D\",category:\"convolution\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"filter\",type:\"tensor\"}],attrs:[{tfName:\"strides\",name:\"strides\",type:\"number[]\"},{tfName:\"rates\",name:\"dilations\",type:\"number[]\"},{tfName:\"padding\",name:\"pad\",type:\"string\"}]}],GC={};_e(GC,{json:()=>vq});var vq=[{tfOpName:\"Fill\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"},{start:1,name:\"value\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"LinSpace\",category:\"creation\",inputs:[{start:0,name:\"start\",type:\"number\"},{start:1,name:\"stop\",type:\"number\"},{start:2,name:\"num\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"OneHot\",category:\"creation\",inputs:[{start:0,name:\"indices\",type:\"tensor\"},{start:1,name:\"depth\",type:\"number\"},{start:2,name:\"onValue\",type:\"number\",defaultValue:1},{start:3,name:\"offValue\",type:\"number\",defaultValue:0}],attrs:[{tfName:\"axis\",name:\"axis\",type:\"number\",notSupported:!0},{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Ones\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"OnesLike\",category:\"creation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"RandomStandardNormal\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"seed\",name:\"seed\",type:\"number\",defaultValue:0},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"T\",name:\"T\",type:\"number\",notSupported:!0}]},{tfOpName:\"RandomUniform\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"minval\",name:\"minval\",type:\"number\",defaultValue:0},{tfName:\"maxval\",name:\"maxval\",type:\"number\",defaultValue:1},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"seed\",name:\"seed\",type:\"number\",defaultValue:0},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0},{tfName:\"T\",name:\"T\",type:\"number\",notSupported:!0}]},{tfOpName:\"RandomUniformInt\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"minval\",name:\"minval\",type:\"number\"},{tfName:\"maxval\",name:\"maxval\",type:\"number\"},{tfName:\"seed\",name:\"seed\",type:\"number\",defaultValue:0},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0}]},{tfOpName:\"Range\",category:\"creation\",inputs:[{start:0,name:\"start\",type:\"number\"},{start:1,name:\"stop\",type:\"number\"},{start:2,name:\"step\",type:\"number\",defaultValue:0}],attrs:[{tfName:\"Tidx\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"TruncatedNormal\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"means\",name:\"mean\",type:\"number\",defaultValue:0},{tfName:\"stddev\",name:\"stdDev\",type:\"number\",defaultValue:1},{tfName:\"seed\",name:\"seed\",type:\"number\"},{tfName:\"seed2\",name:\"seed2\",type:\"number\",defaultValue:0,notSupported:!0},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"},{tfName:\"T\",name:\"T\",type:\"number\",notSupported:!0}]},{tfOpName:\"Zeros\",category:\"creation\",inputs:[{start:0,name:\"shape\",type:\"number[]\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"ZerosLike\",category:\"creation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Multinomial\",category:\"creation\",inputs:[{start:0,name:\"logits\",type:\"tensor\"},{start:1,name:\"numSamples\",type:\"number\"}],attrs:[{tfName:\"seed\",name:\"seed\",type:\"number\"},{tfName:\"seed2\",name:\"seed2\",type:\"number\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\"},{tfName:\"output_dtype\",name:\"output_dtype\",type:\"dtype\"}]}],HC={};_e(HC,{json:()=>wq});var wq=[{tfOpName:\"NonMaxSuppressionV2\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"}]},{tfOpName:\"NonMaxSuppressionV3\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"},{start:4,name:\"scoreThreshold\",type:\"number\"}]},{tfOpName:\"NonMaxSuppressionV4\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"},{start:4,name:\"scoreThreshold\",type:\"number\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0},{tfName:\"T_threshold\",name:\"threshold\",type:\"dtype\",notSupported:!0},{tfName:\"pad_to_max_output_size\",name:\"padToMaxOutputSize\",type:\"bool\"}]},{tfOpName:\"NonMaxSuppressionV5\",category:\"dynamic\",inputs:[{start:0,name:\"boxes\",type:\"tensor\"},{start:1,name:\"scores\",type:\"tensor\"},{start:2,name:\"maxOutputSize\",type:\"number\"},{start:3,name:\"iouThreshold\",type:\"number\"},{start:4,name:\"scoreThreshold\",type:\"number\"},{start:5,name:\"softNmsSigma\",type:\"number\"}]},{tfOpName:\"Where\",category:\"dynamic\",inputs:[{start:0,name:\"condition\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ListDiff\",category:\"dynamic\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"y\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]}],jC={};_e(jC,{json:()=>kq});var kq=[{tfOpName:\"LowerBound\",category:\"evaluation\",inputs:[{start:0,name:\"sortedSequence\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"}]},{tfOpName:\"TopKV2\",category:\"evaluation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"k\",type:\"number\"}],attrs:[{tfName:\"sorted\",name:\"sorted\",type:\"bool\"}]},{tfOpName:\"UpperBound\",category:\"evaluation\",inputs:[{start:0,name:\"sortedSequence\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"}]},{tfOpName:\"Unique\",category:\"evaluation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"UniqueV2\",category:\"evaluation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]}],qC={};_e(qC,{json:()=>Iq});var Iq=[{tfOpName:\"PlaceholderWithDefault\",category:\"graph\",inputs:[{start:0,name:\"default\",type:\"tensor\"}],attrs:[{tfName:\"shape\",name:\"shape\",type:\"shape\"},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Placeholder\",category:\"graph\",attrs:[{tfName:\"shape\",name:\"shape\",type:\"shape\"},{tfName:\"dtype\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"Const\",category:\"graph\"},{tfOpName:\"Identity\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"IdentityN\",category:\"graph\",inputs:[{start:0,end:0,name:\"x\",type:\"tensors\"}]},{tfOpName:\"Snapshot\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"Rank\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"Size\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"Shape\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"ShapeN\",category:\"graph\",inputs:[{start:0,end:0,name:\"x\",type:\"tensors\"}]},{tfOpName:\"Print\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"data\",type:\"tensors\"}],attrs:[{tfName:\"message\",name:\"message\",type:\"string\"},{tfName:\"first_n\",name:\"firstN\",type:\"number\",notSupported:!0},{tfName:\"summarize\",name:\"summarize\",type:\"number\",defaultValue:3}]},{tfOpName:\"NoOp\",category:\"graph\",inputs:[]},{tfOpName:\"StopGradient\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"FakeQuantWithMinMaxVars\",category:\"graph\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"min\",name:\"min\",type:\"number\"},{tfName:\"max\",name:\"max\",type:\"number\"}]}],KC={};_e(KC,{json:()=>Sq});var Sq=[{tfOpName:\"HashTable\",category:\"hash_table\",inputs:[],attrs:[{tfName:\"shared_name\",name:\"sharedName\",type:\"string\"},{tfName:\"use_node_name_sharing\",name:\"useNodeNameSharing\",type:\"bool\"},{tfName:\"key_dtype\",name:\"keyDType\",type:\"dtype\"},{tfName:\"value_dtype\",name:\"valueDType\",type:\"dtype\"}]},{tfOpName:\"HashTableV2\",category:\"hash_table\",inputs:[],attrs:[{tfName:\"shared_name\",name:\"sharedName\",type:\"string\"},{tfName:\"use_node_name_sharing\",name:\"useNodeNameSharing\",type:\"bool\"},{tfName:\"key_dtype\",name:\"keyDType\",type:\"dtype\"},{tfName:\"value_dtype\",name:\"valueDType\",type:\"dtype\"}]},{tfOpName:\"LookupTableImport\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableImportV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableFind\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"defaultValue\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableFindV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"defaultValue\",type:\"tensor\"}],attrs:[{tfName:\"Tin\",name:\"tIn\",type:\"dtype\",notSupported:!0},{tfName:\"Tout\",name:\"tOut\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LookupTableSize\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"}]},{tfOpName:\"LookupTableSizeV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"}]},{tfOpName:\"InitializeTable\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}]},{tfOpName:\"InitializeTableV2\",category:\"hash_table\",inputs:[{start:0,name:\"tableHandle\",type:\"tensor\"},{start:1,name:\"keys\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}]}],XC={};_e(XC,{json:()=>Nq});var Nq=[{tfOpName:\"ResizeBilinear\",category:\"image\",inputs:[{start:0,name:\"images\",type:\"tensor\"},{start:1,name:\"size\",type:\"number[]\"}],attrs:[{tfName:\"align_corners\",name:\"alignCorners\",type:\"bool\"},{tfName:\"half_pixel_centers\",name:\"halfPixelCenters\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"ResizeNearestNeighbor\",category:\"image\",inputs:[{start:0,name:\"images\",type:\"tensor\"},{start:1,name:\"size\",type:\"number[]\"}],attrs:[{tfName:\"align_corners\",name:\"alignCorners\",type:\"bool\"},{tfName:\"half_pixel_centers\",name:\"halfPixelCenters\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"CropAndResize\",category:\"image\",inputs:[{start:0,name:\"image\",type:\"tensor\"},{start:1,name:\"boxes\",type:\"tensor\"},{start:2,name:\"boxInd\",type:\"tensor\"},{start:3,name:\"cropSize\",type:\"number[]\"}],attrs:[{tfName:\"method\",name:\"method\",type:\"string\"},{tfName:\"extrapolation_value\",name:\"extrapolationValue\",type:\"number\"}]},{tfOpName:\"ImageProjectiveTransformV3\",category:\"image\",inputs:[{start:0,name:\"images\",type:\"tensor\"},{start:1,name:\"transforms\",type:\"tensor\"},{start:2,name:\"outputShape\",type:\"number[]\"},{start:3,name:\"fillValue\",type:\"number\"}],attrs:[{tfName:\"interpolation\",name:\"interpolation\",type:\"string\"},{tfName:\"fill_mode\",name:\"fillMode\",type:\"string\"}]}],YC={};_e(YC,{json:()=>Tq});var Tq=[{tfOpName:\"Equal\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"NotEqual\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Greater\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"GreaterEqual\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Less\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LessEqual\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LogicalAnd\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LogicalNot\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"LogicalOr\",category:\"logical\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Select\",category:\"logical\",inputs:[{start:0,name:\"condition\",type:\"tensor\"},{start:1,name:\"a\",type:\"tensor\"},{start:2,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"SelectV2\",category:\"logical\",inputs:[{start:0,name:\"condition\",type:\"tensor\"},{start:1,name:\"a\",type:\"tensor\"},{start:2,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"BitwiseAnd\",category:\"logical\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"y\",type:\"tensor\"}]}],ZC={};_e(ZC,{json:()=>Cq});var Cq=[{tfOpName:\"_FusedMatMul\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"},{start:2,end:0,name:\"args\",type:\"tensors\"}],attrs:[{tfName:\"num_args\",name:\"numArgs\",type:\"number\"},{tfName:\"fused_ops\",name:\"fusedOps\",type:\"string[]\",defaultValue:[]},{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:1e-4},{tfName:\"transpose_a\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"transpose_b\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"leakyrelu_alpha\",name:\"leakyreluAlpha\",type:\"number\",defaultValue:.2},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"MatMul\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"transpose_a\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"transpose_b\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"BatchMatMul\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"adj_x\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"adj_y\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"BatchMatMulV2\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"b\",type:\"tensor\"}],attrs:[{tfName:\"adj_x\",name:\"transposeA\",type:\"bool\",defaultValue:!1},{tfName:\"adj_y\",name:\"transposeB\",type:\"bool\",defaultValue:!1},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Transpose\",category:\"matrices\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"perm\",type:\"number[]\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Einsum\",category:\"matrices\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}],attrs:[{tfName:\"equation\",name:\"equation\",type:\"string\"},{tfName:\"N\",name:\"n\",type:\"number\",defaultValue:2},{tfName:\"T\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"MatrixBandPart\",category:\"matrices\",inputs:[{start:0,name:\"a\",type:\"tensor\"},{start:1,name:\"numLower\",type:\"tensor\"},{start:1,name:\"numUpper\",type:\"tensor\"}]}],JC={};_e(JC,{json:()=>Eq});var Eq=[{tfOpName:\"EuclideanNorm\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\",defaultValue:!1}]},{tfOpName:\"FusedBatchNorm\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"scale\",type:\"tensor\"},{start:2,name:\"offset\",type:\"tensor\"},{start:3,name:\"mean\",type:\"tensor\"},{start:4,name:\"variance\",type:\"tensor\"}],attrs:[{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:.001},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"FusedBatchNormV2\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"scale\",type:\"tensor\"},{start:2,name:\"offset\",type:\"tensor\"},{start:3,name:\"mean\",type:\"tensor\"},{start:4,name:\"variance\",type:\"tensor\"}],attrs:[{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:.001},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"FusedBatchNormV3\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"scale\",type:\"tensor\"},{start:2,name:\"offset\",type:\"tensor\"},{start:3,name:\"mean\",type:\"tensor\"},{start:4,name:\"variance\",type:\"tensor\"}],attrs:[{tfName:\"epsilon\",name:\"epsilon\",type:\"number\",defaultValue:.001},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\",notSupported:!0}]},{tfOpName:\"LRN\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"depth_radius\",name:\"radius\",type:\"number\",defaultValue:5},{tfName:\"bias\",name:\"bias\",type:\"number\",defaultValue:1},{tfName:\"alpha\",name:\"alpha\",type:\"number\",defaultValue:1},{tfName:\"beta\",name:\"beta\",type:\"number\",defaultValue:.5}]},{tfOpName:\"Softmax\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"LogSoftmax\",category:\"normalization\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]}],QC={};_e(QC,{json:()=>_q});var _q=[{tfOpName:\"Bincount\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"size\",type:\"number\"},{start:2,name:\"weights\",type:\"tensor\"}]},{tfOpName:\"DenseBincount\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"size\",type:\"number\"},{start:2,name:\"weights\",type:\"tensor\"}],attrs:[{tfName:\"binary_output\",name:\"binaryOutput\",type:\"bool\"}]},{tfOpName:\"Max\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Mean\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Min\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Sum\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"All\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"Any\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"}]},{tfOpName:\"ArgMax\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]},{tfOpName:\"ArgMin\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]},{tfOpName:\"Prod\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}],attrs:[{tfName:\"keep_dims\",name:\"keepDims\",type:\"bool\"},{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"Cumprod\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"exclusive\",name:\"exclusive\",type:\"bool\"},{tfName:\"reverse\",name:\"reverse\",type:\"bool\"}]},{tfOpName:\"Cumsum\",category:\"reduction\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"exclusive\",name:\"exclusive\",type:\"bool\"},{tfName:\"reverse\",name:\"reverse\",type:\"bool\"}]}],eE={};_e(eE,{json:()=>Aq});var Aq=[{tfOpName:\"ConcatV2\",category:\"slice_join\",inputs:[{start:0,end:-1,name:\"tensors\",type:\"tensors\"},{start:-1,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"N\",name:\"n\",type:\"number\",defaultValue:2}]},{tfOpName:\"Concat\",category:\"slice_join\",inputs:[{start:1,end:0,name:\"tensors\",type:\"tensors\"},{start:0,name:\"axis\",type:\"number\"}],attrs:[{tfName:\"N\",name:\"n\",type:\"number\",defaultValue:2}]},{tfOpName:\"GatherV2\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"axis\",type:\"number\",defaultValue:0}],attrs:[{tfName:\"batch_dims\",name:\"batchDims\",type:\"number\",defaultValue:0}]},{tfOpName:\"Gather\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"}],attrs:[{tfName:\"validate_indices\",name:\"validateIndices\",type:\"bool\",notSupported:!0}]},{tfOpName:\"Reverse\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"dims\",type:\"bool[]\"}]},{tfOpName:\"ReverseV2\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number[]\"}]},{tfOpName:\"Slice\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"begin\",type:\"number[]\"},{start:2,name:\"size\",type:\"number[]\"}]},{tfOpName:\"StridedSlice\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"begin\",type:\"number[]\"},{start:2,name:\"end\",type:\"number[]\"},{start:3,name:\"strides\",type:\"number[]\"}],attrs:[{tfName:\"begin_mask\",name:\"beginMask\",type:\"number\",defaultValue:0},{tfName:\"end_mask\",name:\"endMask\",type:\"number\",defaultValue:0},{tfName:\"new_axis_mask\",name:\"newAxisMask\",type:\"number\",defaultValue:0},{tfName:\"ellipsis_mask\",name:\"ellipsisMask\",type:\"number\",defaultValue:0},{tfName:\"shrink_axis_mask\",name:\"shrinkAxisMask\",type:\"number\",defaultValue:0}]},{tfOpName:\"Pack\",category:\"slice_join\",inputs:[{start:0,end:0,name:\"tensors\",type:\"tensors\"}],attrs:[{tfName:\"axis\",name:\"axis\",type:\"number\",defaultValue:0}]},{tfOpName:\"Unpack\",category:\"slice_join\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"}],attrs:[{tfName:\"axis\",name:\"axis\",type:\"number\",defaultValue:0},{tfName:\"num\",name:\"num\",type:\"number\",defaultValue:0,notSupported:!0}]},{tfOpName:\"Tile\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"reps\",type:\"number[]\"}]},{tfOpName:\"Split\",category:\"slice_join\",inputs:[{start:0,name:\"axis\",type:\"number\",defaultValue:0},{start:1,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"num_split\",name:\"numOrSizeSplits\",type:\"number\",defaultValue:1}]},{tfOpName:\"SplitV\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"numOrSizeSplits\",type:\"number[]\"},{start:2,name:\"axis\",type:\"number\",defaultValue:0}]},{tfOpName:\"ScatterNd\",category:\"slice_join\",inputs:[{start:0,name:\"indices\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"},{start:2,name:\"shape\",type:\"number[]\"}]},{tfOpName:\"GatherNd\",category:\"slice_join\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"}]},{tfOpName:\"SparseToDense\",category:\"slice_join\",inputs:[{start:0,name:\"sparseIndices\",type:\"tensor\"},{start:1,name:\"outputShape\",type:\"number[]\"},{start:2,name:\"sparseValues\",type:\"tensor\"},{start:3,name:\"defaultValue\",type:\"tensor\"}],attrs:[{tfName:\"validate_indices\",name:\"validateIndices\",type:\"bool\",defaultValue:!1,notSupported:!0}]},{tfOpName:\"TensorScatterUpdate\",category:\"slice_join\",inputs:[{start:0,name:\"tensor\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"values\",type:\"tensor\"}]}],tE={};_e(tE,{json:()=>Fq});var Fq=[{tfOpName:\"SparseFillEmptyRows\",category:\"sparse\",inputs:[{start:0,name:\"indices\",type:\"tensor\"},{start:1,name:\"values\",type:\"tensor\"},{start:2,name:\"denseShape\",type:\"tensor\"},{start:3,name:\"defaultValue\",type:\"tensor\"}]},{tfOpName:\"SparseReshape\",category:\"sparse\",inputs:[{start:0,name:\"inputIndices\",type:\"tensor\"},{start:1,name:\"inputShape\",type:\"tensor\"},{start:2,name:\"newShape\",type:\"tensor\"}],attrs:[{tfName:\"T\",name:\"dtype\",type:\"dtype\",notSupported:!0}]},{tfOpName:\"SparseSegmentMean\",category:\"sparse\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"segmentIds\",type:\"tensor\"}]},{tfOpName:\"SparseSegmentSum\",category:\"sparse\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"indices\",type:\"tensor\"},{start:2,name:\"segmentIds\",type:\"tensor\"}]}],nE={};_e(nE,{json:()=>$q});var $q=[{tfOpName:\"FFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"IFFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"}]},{tfOpName:\"RFFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"fft_length\",type:\"number\",notSupported:!0}]},{tfOpName:\"IRFFT\",category:\"spectral\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"fft_length\",type:\"number\",notSupported:!0}]}],aE={};_e(aE,{json:()=>Dq});var Dq=[{tfOpName:\"StaticRegexReplace\",category:\"string\",inputs:[{start:0,name:\"input\",type:\"tensor\"}],attrs:[{tfName:\"pattern\",name:\"pattern\",type:\"string\"},{tfName:\"rewrite\",name:\"rewrite\",type:\"string\"},{tfName:\"replace_global\",name:\"replaceGlobal\",type:\"bool\"}]},{tfOpName:\"StringNGrams\",category:\"string\",inputs:[{start:0,name:\"data\",type:\"tensor\"},{start:1,name:\"dataSplits\",type:\"tensor\"}],attrs:[{tfName:\"separator\",name:\"separator\",type:\"string\"},{tfName:\"ngram_widths\",name:\"nGramWidths\",type:\"number[]\"},{tfName:\"left_pad\",name:\"leftPad\",type:\"string\"},{tfName:\"right_pad\",name:\"rightPad\",type:\"string\"},{tfName:\"pad_width\",name:\"padWidth\",type:\"number\"},{tfName:\"preserve_short_sequences\",name:\"preserveShortSequences\",type:\"bool\"}],outputs:[\"ngrams\",\"ngrams_splits\"]},{tfOpName:\"StringSplit\",category:\"string\",inputs:[{start:0,name:\"input\",type:\"tensor\"},{start:1,name:\"delimiter\",type:\"tensor\"}],attrs:[{tfName:\"skip_empty\",name:\"skipEmpty\",type:\"bool\"}],outputs:[\"indices\",\"values\",\"shape\"]},{tfOpName:\"StringToHashBucketFast\",category:\"string\",inputs:[{start:0,name:\"input\",type:\"tensor\"}],attrs:[{tfName:\"num_buckets\",name:\"numBuckets\",type:\"number\"}]}],rE={};_e(rE,{json:()=>Rq});var Rq=[{tfOpName:\"Cast\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"SrcT\",name:\"sdtype\",type:\"dtype\",notSupported:!0},{tfName:\"DstT\",name:\"dtype\",type:\"dtype\"}]},{tfOpName:\"ExpandDims\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"axis\",type:\"number\"}]},{tfOpName:\"MirrorPad\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"padding\",type:\"number[]\"}],attrs:[{tfName:\"mode\",name:\"mode\",type:\"string\"}]},{tfOpName:\"Pad\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"padding\",type:\"number[]\"}],attrs:[{tfName:\"constant_value\",name:\"constantValue\",type:\"number\",defaultValue:0}]},{tfOpName:\"PadV2\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"padding\",type:\"number[]\"},{start:2,name:\"constantValue\",type:\"number\",defaultValue:0}]},{tfOpName:\"Reshape\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"shape\",type:\"number[]\"}]},{tfOpName:\"EnsureShape\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"shape\",type:\"number[]\"}]},{tfOpName:\"Squeeze\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"axis\",tfDeprecatedName:\"squeeze_dims\",name:\"axis\",type:\"number[]\"}]},{tfOpName:\"SpaceToBatchND\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"blockShape\",type:\"number[]\"},{start:2,name:\"paddings\",type:\"number[]\"}]},{tfOpName:\"BatchToSpaceND\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"blockShape\",type:\"number[]\"},{start:2,name:\"crops\",type:\"number[]\"}]},{tfOpName:\"DepthToSpace\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"}],attrs:[{tfName:\"block_size\",name:\"blockSize\",type:\"number\"},{tfName:\"data_format\",name:\"dataFormat\",type:\"string\"}]},{tfOpName:\"BroadcastTo\",category:\"transformation\",inputs:[{start:0,name:\"x\",type:\"tensor\"},{start:1,name:\"shape\",type:\"number[]\"}],attrs:[]},{tfOpName:\"BroadcastArgs\",category:\"transformation\",inputs:[{start:0,name:\"s0\",type:\"tensor\"},{start:1,name:\"s1\",type:\"tensor\"}],attrs:[]}],zI=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[WC,BC,VC,UC,GC,HC,jC,qC,KC,XC,YC,ZC,JC,QC,eE,tE,nE,aE,rE],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,a)=>(n[a.tfOpName]=a,n),{})}transformGraph(e,t={}){let n=e.node,a=[],r=[],s=[],i=n.reduce((m,f)=>(m[f.name]=this.mapNode(f),f.op.startsWith(\"Placeholder\")?a.push(m[f.name]):f.op===\"Const\"?r.push(m[f.name]):(f.input==null||f.input.length===0)&&s.push(m[f.name]),m),{}),o=[],l=[],u={},p={};t!=null&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(m=>{let f=i[m];f.inputNames.forEach((g,b)=>{let[y,,x]=Sr(g),v=i[y];if(v.outputs!=null){let I=v.outputs.indexOf(x);if(I!==-1){let N=`${y}:${I}`;f.inputNames[b]=N}}f.inputs.push(v),v.children.push(f)})}),Object.keys(p).length===0?d.forEach(m=>{let f=i[m];f.children.length===0&&l.push(f)}):Object.keys(p).forEach(m=>{let[f]=Sr(m),g=i[f];g!=null&&(g.signatureKey=p[m],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{let[f]=Sr(m),g=i[f];g&&(g.signatureKey=u[m],o.push(g))}):o=a;let c={};e.library!=null&&e.library.function!=null&&(c=e.library.function.reduce((m,f)=>(m[f.signature.name]=this.mapFunction(f),m),{}));let h={nodes:i,inputs:o,outputs:l,weights:r,placeholders:a,signature:t,functions:c};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=zC(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(a=>a.startsWith(\"^\")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((a,r)=>(a[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},a),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((a,r)=>{let s=r.type,i;switch(r.type){case\"string\":i=Xx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Xx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"string[]\":i=nv(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=nv(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"number\":i=Zx(e.attr,r.tfName,r.defaultValue||0),i===void 0&&r.tfDeprecatedName&&(i=Zx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"number[]\":i=tv(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=tv(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"bool\":i=Yx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Yx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"bool[]\":i=rv(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=rv(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"shape\":i=ev(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=ev(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"shape[]\":i=av(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=av(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"dtype\":i=Jx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Jx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"dtype[]\":i=Qx(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Qx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"func\":i=WI(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=WI(e.attr,r.tfDeprecatedName,r.defaultValue));break;case\"tensor\":case\"tensors\":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return a[r.name]={value:i,type:s},a},{})),n}mapFunction(e){let t=e.nodeDef,n=[],a=[],r={};t!=null&&(r=t.reduce((u,p)=>(u[p.name]=this.mapNode(p),p.op===\"Const\"&&a.push(u[p.name]),u),{}));let s=[],i=[];e.signature.inputArg.forEach(u=>{let[p]=Sr(u.name),d={name:p,op:\"Placeholder\",inputs:[],inputNames:[],category:\"graph\",inputParams:{},attrParams:{dtype:{value:A1(u.type),type:\"dtype\"}},children:[]};d.signatureKey=u.name,s.push(d),r[p]=d}),Object.keys(r).forEach(u=>{let p=r[u];p.inputNames.forEach((d,c)=>{let[h,,m]=Sr(d),f=r[h];if(f.outputs!=null){let g=f.outputs.indexOf(m);if(g!==-1){let b=`${h}:${g}`;p.inputNames[c]=b}}p.inputs.push(f),f.children.push(p)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[p,d]=Sr(o[u.name]),c=r[p];c!=null&&(c.defaultOutput=d,i.push(c))});let l=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:i,weights:a,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function Mq(e){let t=G().global;if(typeof t.atob!=\"undefined\")return t.atob(e);if(typeof Buffer!=\"undefined\")return new Buffer(e,\"base64\").toString();throw new Error(\"Unable to decode base64 in this environment. Missing built-in atob() or Buffer()\")}function sE(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):Mq(e);return t?n:n.toLowerCase()}function Xx(e,t,n,a=!1){let r=e[t];return r!=null?sE(r.s,a):n}function Yx(e,t,n){let a=e[t];return a?a.b:n}function Zx(e,t,n){let a=e[t]||{},r=a.i!=null?a.i:a.f!=null?a.f:n;return typeof r==\"number\"?r:parseInt(r,10)}function A1(e){switch(typeof e==\"string\"&&(e=qn[e]),e){case qn.DT_FLOAT:case qn.DT_HALF:return\"float32\";case qn.DT_INT32:case qn.DT_INT64:case qn.DT_INT8:case qn.DT_UINT8:return\"int32\";case qn.DT_BOOL:return\"bool\";case qn.DT_DOUBLE:return\"float32\";case qn.DT_STRING:return\"string\";case qn.DT_COMPLEX64:case qn.DT_COMPLEX128:return\"complex64\";default:return null}}function WI(e,t,n){let a=e[t];return a&&a.func?a.func.name:n}function Jx(e,t,n){let a=e[t];return a&&a.type?A1(a.type):n}function Qx(e,t,n){let a=e[t];return a&&a.list&&a.list.type?a.list.type.map(r=>A1(r)):n}function iE(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size==\"number\"?t.size:parseInt(t.size,10)):[]}function ev(e,t,n){let a=e[t];return a&&a.shape?iE(a.shape):n}function tv(e,t,n){let a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(r=>typeof r==\"number\"?r:parseInt(r,10)):n}function nv(e,t,n,a=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(s=>sE(s,a)):n}function av(e,t,n){let a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map(r=>iE(r)):n}function rv(e,t,n){let a=e[t];return a&&a.list&&a.list.b?a.list.b:n}var Oq=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(a=>this.getInput(a)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((a,r)=>(a[r]=this.getAttr(r),a),{}))}getInput(e){return pn(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return pn(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Zx(this.node.rawAttrs,e,t);if(n.s!=null)return Xx(this.node.rawAttrs,e,t);if(n.b!=null)return Yx(this.node.rawAttrs,e,t);if(n.shape!=null)return ev(this.node.rawAttrs,e,t);if(n.type!=null)return Jx(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return tv(this.node.rawAttrs,e,t);if(n.list.s!=null)return nv(this.node.rawAttrs,e,t);if(n.list.shape!=null)return av(this.node.rawAttrs,e,t);if(n.list.b!=null)return rv(this.node.rawAttrs,e,t);if(n.list.type!=null)return Qx(this.node.rawAttrs,e,t)}return t}},on={};_e(on,{OP_SCOPE_SUFFIX:()=>Fv,abs:()=>Lt,acos:()=>Pv,acosh:()=>Lv,add:()=>X,addN:()=>vN,all:()=>Lm,any:()=>yc,argMax:()=>di,argMin:()=>zv,asin:()=>Wv,asinh:()=>Bv,atan:()=>Vv,atan2:()=>Uv,atanh:()=>Gv,avgPool:()=>ya,avgPool3d:()=>jv,basicLSTMCell:()=>SN,batchNorm:()=>Ns,batchNorm2d:()=>qv,batchNorm3d:()=>Kv,batchNorm4d:()=>Xv,batchToSpaceND:()=>id,bincount:()=>Yv,bitwiseAnd:()=>NN,booleanMaskAsync:()=>mT,broadcastArgs:()=>TN,broadcastTo:()=>ai,buffer:()=>Oe,cast:()=>re,ceil:()=>Zv,clipByValue:()=>an,clone:()=>sr,complex:()=>_r,concat:()=>et,concat1d:()=>Jv,concat2d:()=>Qv,concat3d:()=>ew,concat4d:()=>tw,conv1d:()=>zm,conv2d:()=>$t,conv2dTranspose:()=>Wm,conv3d:()=>aw,conv3dTranspose:()=>rw,cos:()=>od,cosh:()=>Bm,cosineWindow:()=>pf,cumprod:()=>wc,cumsum:()=>Vm,denseBincount:()=>Xh,depthToSpace:()=>sw,depthwiseConv2d:()=>Ts,diag:()=>EN,dilation2d:()=>iw,div:()=>he,divNoNan:()=>ow,dot:()=>lw,dropout:()=>Pw,einsum:()=>Zs,elu:()=>Qu,enclosingPowerOfTwo:()=>Lw,ensureShape:()=>AN,equal:()=>Jn,erf:()=>Um,euclideanNorm:()=>cw,exp:()=>dn,expandDims:()=>Gt,expm1:()=>dw,eye:()=>Gm,fft:()=>bd,fill:()=>yn,floor:()=>tp,floorDiv:()=>Pm,fused:()=>Vl,gather:()=>np,gatherND:()=>yT,greater:()=>Cn,greaterEqual:()=>$r,ifft:()=>Bl,imag:()=>ld,image:()=>Zn,inTopKAsync:()=>xT,irfft:()=>af,isFinite:()=>hw,isInf:()=>mw,isNaN:()=>fw,leakyRelu:()=>ud,less:()=>Pl,lessEqual:()=>Cs,linalg:()=>Bw,linspace:()=>MN,localResponseNormalization:()=>gw,log:()=>Qn,log1p:()=>pd,logSigmoid:()=>bw,logSoftmax:()=>jm,logSumExp:()=>cd,logicalAnd:()=>_a,logicalNot:()=>dd,logicalOr:()=>qm,logicalXor:()=>yw,losses:()=>FT,lowerBound:()=>PN,matMul:()=>$e,max:()=>ma,maxPool:()=>Dt,maxPool3d:()=>xw,maxPoolWithArgmax:()=>LN,maximum:()=>hr,mean:()=>Ct,meshgrid:()=>zN,min:()=>Ol,minimum:()=>ds,mirrorPad:()=>vw,mod:()=>ww,moments:()=>hd,movingAverage:()=>fT,mul:()=>z,multiRNNCell:()=>WN,multinomial:()=>BN,neg:()=>yt,norm:()=>ep,notEqual:()=>fi,oneHot:()=>Ll,ones:()=>Pn,onesLike:()=>ea,op:()=>L,outerProduct:()=>VN,pad:()=>xa,pad1d:()=>UN,pad2d:()=>GN,pad3d:()=>HN,pad4d:()=>jN,pool:()=>kw,pow:()=>ur,prelu:()=>fd,print:()=>Ov,prod:()=>Iw,raggedGather:()=>qN,raggedRange:()=>KN,raggedTensorToTensor:()=>XN,rand:()=>YN,randomGamma:()=>eT,randomNormal:()=>Xm,randomStandardNormal:()=>tT,randomUniform:()=>Es,randomUniformInt:()=>nT,range:()=>gi,real:()=>zl,reciprocal:()=>Ew,relu:()=>Ke,relu6:()=>Ym,reshape:()=>W,reverse:()=>ba,reverse1d:()=>aT,reverse2d:()=>rT,reverse3d:()=>sT,reverse4d:()=>iT,rfft:()=>yd,round:()=>Zm,rsqrt:()=>Jm,scalar:()=>xe,scatterND:()=>gT,searchSorted:()=>Km,selu:()=>Qm,separableConv2d:()=>_s,setdiff1dAsync:()=>oT,sigmoid:()=>ha,sign:()=>_w,signal:()=>AT,sin:()=>ef,sinh:()=>tf,slice:()=>Ve,slice1d:()=>gd,slice2d:()=>nf,slice3d:()=>Ho,slice4d:()=>Wl,softmax:()=>qa,softplus:()=>Go,spaceToBatchND:()=>md,sparse:()=>$T,sparseToDense:()=>bT,spectral:()=>_T,split:()=>Ln,sqrt:()=>rn,square:()=>pt,squaredDifference:()=>rf,squeeze:()=>As,stack:()=>At,step:()=>jo,stridedSlice:()=>Aw,string:()=>DT,sub:()=>pe,sum:()=>fe,tan:()=>Fw,tanh:()=>cs,tensor:()=>bn,tensor1d:()=>je,tensor2d:()=>Ea,tensor3d:()=>xd,tensor4d:()=>Fa,tensor5d:()=>lT,tensor6d:()=>uT,tensorScatterUpdate:()=>cT,tile:()=>On,topk:()=>Dw,transpose:()=>De,truncatedNormal:()=>lf,unique:()=>Rw,unsortedSegmentSum:()=>uf,unstack:()=>dt,upperBound:()=>dT,variable:()=>Mw,where:()=>nn,whereAsync:()=>Ow,zeros:()=>It,zerosLike:()=>qe});var Pq=(e,t,n,a=on)=>{switch(e.op){case\"BiasAdd\":case\"AddV2\":case\"Add\":return[a.add(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"AddN\":return[a.addN(k(\"tensors\",e,t,n))];case\"FloorMod\":case\"Mod\":return[a.mod(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Mul\":return[a.mul(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"RealDiv\":case\"Div\":return[a.div(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"DivNoNan\":return[a.divNoNan(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"FloorDiv\":return[a.floorDiv(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Sub\":return[a.sub(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Minimum\":return[a.minimum(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Maximum\":return[a.maximum(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Pow\":return[a.pow(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"SquaredDifference\":return[a.squaredDifference(k(\"a\",e,t,n),k(\"b\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Lq=(e,t,n,a=on)=>{switch(e.op){case\"Abs\":case\"ComplexAbs\":return[a.abs(k(\"x\",e,t,n))];case\"Acos\":return[a.acos(k(\"x\",e,t,n))];case\"Acosh\":return[a.acosh(k(\"x\",e,t,n))];case\"Asin\":return[a.asin(k(\"x\",e,t,n))];case\"Asinh\":return[a.asinh(k(\"x\",e,t,n))];case\"Atan\":return[a.atan(k(\"x\",e,t,n))];case\"Atan2\":return[a.atan2(k(\"x\",e,t,n),k(\"y\",e,t,n))];case\"Atanh\":return[a.atanh(k(\"x\",e,t,n))];case\"Ceil\":return[a.ceil(k(\"x\",e,t,n))];case\"Complex\":return[a.complex(k(\"real\",e,t,n),k(\"imag\",e,t,n))];case\"Cos\":return[a.cos(k(\"x\",e,t,n))];case\"Cosh\":return[a.cosh(k(\"x\",e,t,n))];case\"Elu\":return[a.elu(k(\"x\",e,t,n))];case\"Erf\":return[a.erf(k(\"x\",e,t,n))];case\"Exp\":return[a.exp(k(\"x\",e,t,n))];case\"Expm1\":return[a.expm1(k(\"x\",e,t,n))];case\"Floor\":return[a.floor(k(\"x\",e,t,n))];case\"Log\":return[a.log(k(\"x\",e,t,n))];case\"Log1p\":return[a.log1p(k(\"x\",e,t,n))];case\"Imag\":return[a.imag(k(\"x\",e,t,n))];case\"Neg\":return[a.neg(k(\"x\",e,t,n))];case\"Reciprocal\":return[a.reciprocal(k(\"x\",e,t,n))];case\"Real\":return[a.real(k(\"x\",e,t,n))];case\"Relu\":return[a.relu(k(\"x\",e,t,n))];case\"Round\":return[a.round(k(\"x\",e,t,n))];case\"Selu\":return[a.selu(k(\"x\",e,t,n))];case\"Sigmoid\":return[a.sigmoid(k(\"x\",e,t,n))];case\"Sin\":return[a.sin(k(\"x\",e,t,n))];case\"Sign\":return[a.sign(k(\"x\",e,t,n))];case\"Sinh\":return[a.sinh(k(\"x\",e,t,n))];case\"Softplus\":return[a.softplus(k(\"x\",e,t,n))];case\"Sqrt\":return[a.sqrt(k(\"x\",e,t,n))];case\"Square\":return[a.square(k(\"x\",e,t,n))];case\"Tanh\":return[a.tanh(k(\"x\",e,t,n))];case\"Tan\":return[a.tan(k(\"x\",e,t,n))];case\"ClipByValue\":return[a.clipByValue(k(\"x\",e,t,n),k(\"clipValueMin\",e,t,n),k(\"clipValueMax\",e,t,n))];case\"Relu6\":return[a.relu6(k(\"x\",e,t,n))];case\"Rsqrt\":return[a.rsqrt(pn(e.inputNames[0],t,n))];case\"LeakyRelu\":return[a.leakyRelu(k(\"x\",e,t,n),k(\"alpha\",e,t,n))];case\"Prelu\":return[a.prelu(k(\"x\",e,t,n),k(\"alpha\",e,t,n))];case\"IsNan\":return[a.isNaN(pn(e.inputNames[0],t,n))];case\"IsInf\":return[a.isInf(pn(e.inputNames[0],t,n))];case\"IsFinite\":return[a.isFinite(pn(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ca(e,t,n=\"\"){if(!(typeof e==\"number\"||typeof t==\"number\")){w.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let a=0;a<e.length;a++){let r=e[a],s=t[a];w.assert(r<0||s<0||r===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function BI(e){return!(typeof e==\"number\"||e.some(t=>t<0))}function Zp(e,t,n){let a=sv(e,n),r=!BI(a);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(r&&t.forEach(s=>{a=sv(s.shape,a)}),!BI(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function sv(e,t){if(typeof e==\"number\")return t;if(typeof t==\"number\")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let a=0;a<e.length;++a){let r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[a]=r>=0?r:s}return n}var zq=class{constructor(e,t,n,a,r,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=xe(0),Ht(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ca(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Ht(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,a)=>this.write(n,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let a=0;a<this.size();a++)e.push(a)}if(e.length===0)return bn([],[0].concat(this.elementShape));let n=this.readMany(e);return Ca(this.elementShape,n[0].shape,\"TensorArray shape mismatch: \"),At(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return bn([],[0].concat(this.elementShape));let t=[];for(let a=0;a<this.size();a++)t.push(a);let n=this.readMany(t);return Ca(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),et(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,dt(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,a=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=n===0?0:t.size/n,s=[];O(()=>{t=W(t,[1,n,r]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:a[o-1],0],u=[1,e[o],r];s[o]=W(Ve(t,l,u),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},Lf=class iv{get id(){return this.idTensor.id}constructor(t,n,a,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=a,t!=null&&t.forEach(s=>{if(a!==s.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${s.dtype}`);Ca(n,s.shape,\"TensorList shape mismatch: \"),Ht(s)}),this.idTensor=xe(0),this.maxNumElements=r,Ht(this.idTensor)}copy(){return new iv([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,a=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(a!==-1&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Ca(t,this.elementShape,\"TensorList shape mismatch: \");let r=Zp(this.elementShape,this.tensors,t);return O(()=>{let s=this.tensors.map(i=>W(i,r));return At(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error(\"Trying to pop from an empty list.\");let a=Zp(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Ca(r.shape,t,\"TensorList shape mismatch: \"),W(r,a)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Ca(t.shape,this.elementShape,\"TensorList shape mismatch: \"),this.maxNumElements===this.size())throw new Error(\"Trying to push element into a full list.\");Ht(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new iv([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let a=0;a<Math.min(this.tensors.length,t);++a)n.tensors[a]=this.tensors[a];return n}getItem(t,n,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Ca(this.tensors[t].shape,n,\"TensorList shape mismatch: \");let r=Zp(this.elementShape,this.tensors,n);return W(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Ca(this.elementShape,n.shape,\"TensorList shape mismatch: \"),Ht(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,a){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Ca(this.elementShape,a,\"TensorList shape mismatch: \"),t=t.slice(0,this.size());let r=Zp(this.elementShape,this.tensors,a);return t.length===0?bn([],[0].concat(r)):O(()=>{let s=t.map(i=>W(this.tensors[i],r));return At(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Ca(this.elementShape,n,\"TensorList shape mismatch: \");let a=Zp(this.elementShape,this.tensors,n);return this.size()===0?bn([],[0].concat(a)):O(()=>{let r=this.tensors.map(s=>W(s,a));return et(r,0)})}};function Wq(e,t,n){let a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let r=e.shape.slice(1);Ca(r,t,\"TensorList shape mismatch: \");let s=dt(e);return new Lf(s,t,a)}function Bq(e,t,n,a){return new Lf([],e,t,a)}function Vq(e,t,n,a){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(a!=null&&a!==-1&&r>=a)throw new Error(`Max index must be < array size (${r}  vs. ${a})`);let s=new Lf([],n,e.dtype,a),i=dt(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function Uq(e,t,n){let a=0,r=t.map(p=>(a+=p,a));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=sv(s,n),o=a===0?0:e.size/a,l=O(()=>{let p=[];e=W(e,[1,a,o]);for(let d=0;d<t.length;++d){let c=[0,d===0?0:r[d-1],0],h=[1,t[d],o];p[d]=W(Ve(e,c,h),i)}return e.dispose(),p}),u=new Lf([],n,e.dtype,t.length);for(let p=0;p<l.length;p++)u.setItem(p,l[p]);return u}var Gq=async(e,t,n)=>{switch(e.op){case\"If\":case\"StatelessIf\":{let a=k(\"thenBranch\",e,t,n),r=k(\"elseBranch\",e,t,n),s=k(\"cond\",e,t,n),i=k(\"args\",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case\"While\":case\"StatelessWhile\":{let a=k(\"body\",e,t,n),r=k(\"cond\",e,t,n),s=k(\"args\",e,t,n),i=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(p=>p.id),l=await i[0].data();i.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&p.dispose()});let u=s;for(;l[0];){let p=u;u=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let d=u.map(h=>h.id);p.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});let c=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await c[0].data(),c.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return u}case\"LoopCond\":{let a=k(\"pred\",e,t,n);return[Nr(a)]}case\"Switch\":{let a=k(\"pred\",e,t,n),r=k(\"data\",e,t,n);return r.kept||(r=Nr(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case\"Merge\":{let a=e.inputNames.find(r=>pn(r,t,n)!==void 0);if(a){let r=pn(a,t,n);return[Nr(r)]}return}case\"Enter\":{let a=k(\"frameName\",e,t,n),r=k(\"tensor\",e,t,n);return n.enterFrame(a),[Nr(r)]}case\"Exit\":{let a=k(\"tensor\",e,t,n);return n.exitFrame(),[Nr(a)]}case\"NextIteration\":{let a=k(\"tensor\",e,t,n);return n.nextIteration(),[Nr(a)]}case\"TensorArrayV3\":{let a=k(\"size\",e,t,n),r=k(\"dtype\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"dynamicSize\",e,t,n),o=k(\"clearAfterRead\",e,t,n),l=k(\"identicalElementShapes\",e,t,n),u=k(\"name\",e,t,n),p=new zq(u,r,a,s,l,i,o);return n.addTensorArray(p),[p.idTensor,xe(1)]}case\"TensorArrayWriteV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"index\",e,t,n),s=k(\"tensor\",e,t,n),i=n.getTensorArray(a.id);return i.write(r,s),[i.idTensor]}case\"TensorArrayReadV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"index\",e,t,n);return[n.getTensorArray(a.id).read(r)]}case\"TensorArrayGatherV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"indices\",e,t,n),s=k(\"dtype\",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case\"TensorArrayScatterV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"indices\",e,t,n),s=k(\"tensor\",e,t,n),i=n.getTensorArray(a.id);return i.scatter(r,s),[i.idTensor]}case\"TensorArrayConcatV3\":{let a=k(\"tensorArrayId\",e,t,n),r=n.getTensorArray(a.id),s=k(\"dtype\",e,t,n);return[r.concat(s)]}case\"TensorArraySplitV3\":{let a=k(\"tensorArrayId\",e,t,n),r=k(\"tensor\",e,t,n),s=k(\"lengths\",e,t,n),i=n.getTensorArray(a.id);return i.split(s,r),[i.idTensor]}case\"TensorArraySizeV3\":{let a=k(\"tensorArrayId\",e,t,n),r=n.getTensorArray(a.id);return[xe(r.size(),\"int32\")]}case\"TensorArrayCloseV3\":{let a=k(\"tensorArrayId\",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case\"TensorListSetItem\":{let a=k(\"tensorListId\",e,t,n),r=k(\"index\",e,t,n),s=k(\"tensor\",e,t,n),i=n.getTensorList(a.id);return i.setItem(r,s),[i.idTensor]}case\"TensorListGetItem\":{let a=k(\"tensorListId\",e,t,n),r=k(\"index\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"elementDType\",e,t,n);return[n.getTensorList(a.id).getItem(r,s,i)]}case\"TensorListScatterV2\":case\"TensorListScatter\":{let a=k(\"indices\",e,t,n),r=k(\"tensor\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"numElements\",e,t,n),o=Vq(r,a,s,i);return n.addTensorList(o),[o.idTensor]}case\"TensorListReserve\":case\"EmptyTensorList\":{let a=k(\"elementShape\",e,t,n),r=k(\"elementDType\",e,t,n),s;e.op===\"TensorListReserve\"?s=\"numElements\":s=\"maxNumElements\";let i=k(s,e,t,n),o=e.op===\"TensorListReserve\"?-1:i,l=Bq(a,r,i,o);return n.addTensorList(l),[l.idTensor]}case\"TensorListGather\":{let a=k(\"tensorListId\",e,t,n),r=k(\"indices\",e,t,n),s=k(\"elementShape\",e,t,n),i=k(\"elementDType\",e,t,n);return[n.getTensorList(a.id).gather(r,i,s)]}case\"TensorListStack\":{let a=k(\"tensorListId\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"elementDType\",e,t,n),i=k(\"numElements\",e,t,n);return[n.getTensorList(a.id).stack(r,s,i)]}case\"TensorListFromTensor\":{let a=k(\"tensor\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"elementDType\",e,t,n),i=Wq(a,r,s);return n.addTensorList(i),[i.idTensor]}case\"TensorListConcat\":case\"TensorListConcatV2\":{let a=k(\"tensorListId\",e,t,n),r=n.getTensorList(a.id),s=k(\"dtype\",e,t,n),i=k(\"elementShape\",e,t,n);return[r.concat(s,i)]}case\"TensorListPushBack\":{let a=k(\"tensorListId\",e,t,n),r=k(\"tensor\",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case\"TensorListPopBack\":{let a=k(\"tensorListId\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"elementDType\",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case\"TensorListSplit\":{let a=k(\"tensor\",e,t,n),r=k(\"elementShape\",e,t,n),s=k(\"lengths\",e,t,n),i=Uq(a,s,r);return n.addTensorList(i),[i.idTensor]}case\"TensorListLength\":{let a=k(\"tensorListId\",e,t,n),r=n.getTensorList(a.id);return[xe(r.size(),\"int32\")]}case\"TensorListResize\":{let a=k(\"tensorListId\",e,t,n),r=k(\"size\",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function VI(e,t,n){let[a,r]=k(\"fusedOps\",e,t,n),s=a===\"biasadd\",i=!s,o=r===\"prelu\",l=a===\"fusedbatchnorm\",u=k(\"numArgs\",e,t,n);if(s){if(o&&u!==2)throw new Error(\"FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.\");if(!o&&s&&u!==1)throw new Error(\"FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.\")}if(l)throw new Error(\"FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported\");let p=k(\"strides\",e,t,n),d=Mh(e,t,n),c=k(\"dataFormat\",e,t,n).toUpperCase(),h=k(\"dilations\",e,t,n),[m,f]=k(\"args\",e,t,n);i&&(f=m,m=void 0);let g=k(\"leakyreluAlpha\",e,t,n);return{stride:p,pad:d,dataFormat:c,dilations:h,biasArg:m,preluArg:f,activationFunc:r,leakyreluAlpha:g}}var Hq=(e,t,n,a=on)=>{switch(e.op){case\"Conv1D\":{let r=k(\"stride\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"dataFormat\",e,t,n).toUpperCase(),o=k(\"dilation\",e,t,n);return[a.conv1d(k(\"x\",e,t,n),k(\"filter\",e,t,n),r,s,i,o)]}case\"Conv2D\":{let r=k(\"strides\",e,t,n),s=Mh(e,t,n),i=k(\"dataFormat\",e,t,n).toUpperCase(),o=k(\"dilations\",e,t,n);return[a.conv2d(k(\"x\",e,t,n),k(\"filter\",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case\"_FusedConv2D\":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:d}=VI(e,t,n);return[a.fused.conv2d({x:k(\"x\",e,t,n),filter:k(\"filter\",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:d})]}case\"FusedDepthwiseConv2dNative\":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:p,leakyreluAlpha:d}=VI(e,t,n);return[a.fused.depthwiseConv2d({x:k(\"x\",e,t,n),filter:k(\"filter\",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:p,preluActivationWeights:u,leakyreluAlpha:d})]}case\"Conv2DBackpropInput\":case\"Conv2dTranspose\":{let r=k(\"outputShape\",e,t,n),s=k(\"strides\",e,t,n),i=Mh(e,t,n);return[a.conv2dTranspose(k(\"x\",e,t,n),k(\"filter\",e,t,n),r,[s[1],s[2]],i)]}case\"DepthwiseConv2dNative\":case\"DepthwiseConv2d\":{let r=k(\"strides\",e,t,n),s=Mh(e,t,n),i=k(\"dilations\",e,t,n),o=k(\"dataFormat\",e,t,n).toUpperCase();return[a.depthwiseConv2d(k(\"input\",e,t,n),k(\"filter\",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case\"Conv3D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"dataFormat\",e,t,n).toUpperCase(),o=k(\"dilations\",e,t,n);return[a.conv3d(k(\"x\",e,t,n),k(\"filter\",e,t,n),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case\"AvgPool\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.avgPool(k(\"x\",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case\"MaxPool\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.maxPool(k(\"x\",e,t,n),[i[1],i[2]],[r[1],r[2]],s)]}case\"MaxPoolWithArgmax\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n),o=k(\"includeBatchInIndex\",e,t,n),{result:l,indexes:u}=a.maxPoolWithArgmax(k(\"x\",e,t,n),[i[1],i[2]],[r[1],r[2]],s,o);return[l,u]}case\"AvgPool3D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.avgPool3d(k(\"x\",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case\"MaxPool3D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"kernelSize\",e,t,n);return[a.maxPool3d(k(\"x\",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case\"Dilation2D\":{let r=k(\"strides\",e,t,n),s=k(\"pad\",e,t,n),i=k(\"dilations\",e,t,n),o=r[1],l=r[2],u=i[1],p=i[2];return[a.dilation2d(k(\"x\",e,t,n),k(\"filter\",e,t,n),[o,l],s,[u,p],\"NHWC\")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},jq=(e,t,n,a=on)=>{switch(e.op){case\"Fill\":{let r=k(\"shape\",e,t,n),s=k(\"dtype\",e,t,n),i=k(\"value\",e,t,n);return[a.fill(r,i,s)]}case\"LinSpace\":{let r=k(\"start\",e,t,n),s=k(\"stop\",e,t,n),i=k(\"num\",e,t,n);return[a.linspace(r,s,i)]}case\"Multinomial\":{let r=k(\"logits\",e,t,n),s=k(\"numSamples\",e,t,n),i=k(\"seed\",e,t,n);return[a.multinomial(r,s,i)]}case\"OneHot\":{let r=k(\"indices\",e,t,n),s=k(\"depth\",e,t,n),i=k(\"onValue\",e,t,n),o=k(\"offValue\",e,t,n),l=k(\"dtype\",e,t,n);return[a.oneHot(r,s,i,o,l)]}case\"Ones\":return[a.ones(k(\"shape\",e,t,n),k(\"dtype\",e,t,n))];case\"OnesLike\":return[a.onesLike(k(\"x\",e,t,n))];case\"RandomStandardNormal\":return[a.randomStandardNormal(k(\"shape\",e,t,n),k(\"dtype\",e,t,n),k(\"seed\",e,t,n))];case\"RandomUniform\":return[a.randomUniform(k(\"shape\",e,t,n),k(\"minval\",e,t,n),k(\"maxval\",e,t,n),k(\"dtype\",e,t,n))];case\"RandomUniformInt\":return[a.randomUniformInt(k(\"shape\",e,t,n),k(\"minval\",e,t,n),k(\"maxval\",e,t,n),k(\"seed\",e,t,n))];case\"Range\":{let r=k(\"start\",e,t,n),s=k(\"stop\",e,t,n),i=k(\"step\",e,t,n);return[a.range(r,s,i,k(\"dtype\",e,t,n))]}case\"TruncatedNormal\":{let r=k(\"shape\",e,t,n),s=k(\"mean\",e,t,n),i=k(\"stdDev\",e,t,n),o=k(\"seed\",e,t,n);return[a.truncatedNormal(r,s,i,k(\"dtype\",e,t,n),o)]}case\"Zeros\":return[a.zeros(k(\"shape\",e,t,n),k(\"dtype\",e,t,n))];case\"ZerosLike\":return[a.zerosLike(k(\"x\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function gx(e,t,n){let a=k(\"boxes\",e,t,n),r=k(\"scores\",e,t,n),s=k(\"maxOutputSize\",e,t,n),i=k(\"iouThreshold\",e,t,n),o=k(\"scoreThreshold\",e,t,n),l=k(\"softNmsSigma\",e,t,n);return{boxes:a,scores:r,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var qq=async(e,t,n,a,r=on)=>{switch(e.op){case\"NonMaxSuppressionV5\":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:p}=gx(e,t,n),d=await r.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,u,p);return[d.selectedIndices,d.selectedScores]}case\"NonMaxSuppressionV4\":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=gx(e,t,n),p=k(\"padToMaxOutputSize\",e,t,n),d=await r.image.nonMaxSuppressionPaddedAsync(s,i,o,l,u,p);return[d.selectedIndices,d.validOutputs]}case\"NonMaxSuppressionV3\":case\"NonMaxSuppressionV2\":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=gx(e,t,n);return[await r.image.nonMaxSuppressionAsync(s,i,o,l,u)]}case\"Where\":{let s=r.cast(k(\"condition\",e,t,n),\"bool\"),i=[await r.whereAsync(s)];return s.dispose(),i}case\"ListDiff\":return r.setdiff1dAsync(k(\"x\",e,t,n),k(\"y\",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Kq=(e,t,n,a=on)=>{switch(e.op){case\"LowerBound\":{let r=k(\"sortedSequence\",e,t,n),s=k(\"values\",e,t,n);return[a.lowerBound(r,s)]}case\"TopKV2\":{let r=k(\"x\",e,t,n),s=k(\"k\",e,t,n),i=k(\"sorted\",e,t,n),o=a.topk(r,s,i);return[o.values,o.indices]}case\"UpperBound\":{let r=k(\"sortedSequence\",e,t,n),s=k(\"values\",e,t,n);return[a.upperBound(r,s)]}case\"Unique\":{let r=k(\"x\",e,t,n),s=a.unique(r);return[s.values,s.indices]}case\"UniqueV2\":{let r=k(\"x\",e,t,n),s=k(\"axis\",e,t,n),i=a.unique(r,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Xq=(e,t,n,a=on)=>{switch(e.op){case\"Const\":return t[e.name];case\"PlaceholderWithDefault\":let r=k(\"default\",e,t,n);return[pn(e.name,t,n)||r];case\"Placeholder\":return[pn(e.name,t,n)];case\"Identity\":case\"StopGradient\":case\"FakeQuantWithMinMaxVars\":{let p=k(\"x\",e,t,n);return[Nr(p)]}case\"IdentityN\":return k(\"x\",e,t,n).map(p=>Nr(p));case\"Snapshot\":let s=k(\"x\",e,t,n);return[Nr(s)];case\"Shape\":return[a.tensor1d(k(\"x\",e,t,n).shape,\"int32\")];case\"ShapeN\":return k(\"x\",e,t,n).map(p=>a.tensor1d(p.shape));case\"Size\":return[a.scalar(k(\"x\",e,t,n).size,\"int32\")];case\"Rank\":return[a.scalar(k(\"x\",e,t,n).rank,\"int32\")];case\"NoOp\":return[a.scalar(1)];case\"Print\":let i=k(\"x\",e,t,n),o=k(\"data\",e,t,n),l=k(\"message\",e,t,n),u=k(\"summarize\",e,t,n);console.warn(\"The graph has a tf.print() operation,usually used for debugging, which slows down performance.\"),console.log(l);for(let p=0;p<o.length;p++)console.log(Array.prototype.slice.call(o[p].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Yq=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=xe(0),this.tensorMap=new Map,Ht(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return xe(this.size(),\"int32\")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),O(()=>{let a=dt(t),r=n.length,s=a.length;w.assert(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let i=0;i<r;i++){let o=n[i],l=a[i];Ht(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return O(()=>{let a=[];for(let r=0;r<n.length;r++){let s=n[r],i=this.findWithDefault(s,t);a.push(i)}return At(a)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Zq=async(e,t,n,a)=>{switch(e.op){case\"HashTable\":case\"HashTableV2\":{let r=a.getHashTableHandleByName(e.name);if(r!=null)return[r];{let s=k(\"keyDType\",e,t,n),i=k(\"valueDType\",e,t,n),o=new Yq(s,i);return a.addHashTable(e.name,o),[o.handle]}}case\"InitializeTable\":case\"InitializeTableV2\":case\"LookupTableImport\":case\"LookupTableImportV2\":{let r=k(\"tableHandle\",e,t,n,a),s=k(\"keys\",e,t,n),i=k(\"values\",e,t,n);return[await a.getHashTableById(r.id).import(s,i)]}case\"LookupTableFind\":case\"LookupTableFindV2\":{let r=k(\"tableHandle\",e,t,n,a),s=k(\"keys\",e,t,n),i=k(\"defaultValue\",e,t,n);return[await a.getHashTableById(r.id).find(s,i)]}case\"LookupTableSize\":case\"LookupTableSizeV2\":{let r=k(\"tableHandle\",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Jq=(e,t,n,a=on)=>{switch(e.op){case\"ResizeBilinear\":{let r=k(\"images\",e,t,n),s=k(\"size\",e,t,n),i=k(\"alignCorners\",e,t,n),o=k(\"halfPixelCenters\",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case\"ResizeNearestNeighbor\":{let r=k(\"images\",e,t,n),s=k(\"size\",e,t,n),i=k(\"alignCorners\",e,t,n),o=k(\"halfPixelCenters\",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case\"CropAndResize\":{let r=k(\"image\",e,t,n),s=k(\"boxes\",e,t,n),i=k(\"boxInd\",e,t,n),o=k(\"cropSize\",e,t,n),l=k(\"method\",e,t,n),u=k(\"extrapolationValue\",e,t,n);return[a.image.cropAndResize(r,s,i,o,l,u)]}case\"ImageProjectiveTransformV3\":{let r=k(\"images\",e,t,n),s=k(\"transforms\",e,t,n),i=k(\"outputShape\",e,t,n),o=k(\"fillValue\",e,t,n),l=k(\"interpolation\",e,t,n),u=k(\"fillMode\",e,t,n);return[a.image.transform(r,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Qq=(e,t,n,a=on)=>{switch(e.op){case\"Equal\":return[a.equal(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"NotEqual\":return[a.notEqual(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Greater\":return[a.greater(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"GreaterEqual\":return[a.greaterEqual(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Less\":return[a.less(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"LessEqual\":return[a.lessEqual(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"LogicalAnd\":return[a.logicalAnd(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"LogicalNot\":return[a.logicalNot(k(\"a\",e,t,n))];case\"LogicalOr\":return[a.logicalOr(k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"Select\":case\"SelectV2\":return[a.where(k(\"condition\",e,t,n),k(\"a\",e,t,n),k(\"b\",e,t,n))];case\"BitwiseAnd\":return[a.bitwiseAnd(k(\"a\",e,t,n),k(\"b\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},e5=(e,t,n,a=on)=>{switch(e.op){case\"BatchMatMul\":case\"BatchMatMulV2\":case\"MatMul\":return[a.matMul(k(\"a\",e,t,n),k(\"b\",e,t,n),k(\"transposeA\",e,t,n),k(\"transposeB\",e,t,n))];case\"Einsum\":return[a.einsum(k(\"equation\",e,t,n),...k(\"tensors\",e,t,n))];case\"Transpose\":return[a.transpose(k(\"x\",e,t,n),k(\"perm\",e,t,n))];case\"_FusedMatMul\":let[r,s]=k(\"fusedOps\",e,t,n),i=r===\"biasadd\",o=s===\"prelu\",l=k(\"numArgs\",e,t,n),u=k(\"leakyreluAlpha\",e,t,n);if(i){if(o&&l!==2)throw new Error(\"Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.\");if(!o&&l!==1)throw new Error(\"Fused MatMul with BiasAdd must have one extra argument: bias.\")}let[p,d]=k(\"args\",e,t,n);return[a.fused.matMul({a:k(\"a\",e,t,n),b:k(\"b\",e,t,n),transposeA:k(\"transposeA\",e,t,n),transposeB:k(\"transposeB\",e,t,n),bias:p,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case\"MatrixBandPart\":return[a.linalg.bandPart(k(\"a\",e,t,n),k(\"numLower\",e,t,n),k(\"numUpper\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},t5=(e,t,n,a=on)=>{switch(e.op){case\"EuclideanNorm\":return[a.euclideanNorm(k(\"x\",e,t,n),k(\"axis\",e,t,n),k(\"keepDims\",e,t,n))];case\"FusedBatchNorm\":case\"FusedBatchNormV2\":return[a.batchNorm(k(\"x\",e,t,n),k(\"mean\",e,t,n),k(\"variance\",e,t,n),k(\"offset\",e,t,n),k(\"scale\",e,t,n),k(\"epsilon\",e,t,n))];case\"FusedBatchNormV3\":return[a.batchNorm(k(\"x\",e,t,n),k(\"mean\",e,t,n),k(\"variance\",e,t,n),k(\"offset\",e,t,n),k(\"scale\",e,t,n),k(\"epsilon\",e,t,n))];case\"LRN\":return[a.localResponseNormalization(k(\"x\",e,t,n),k(\"radius\",e,t,n),k(\"bias\",e,t,n),k(\"alpha\",e,t,n),k(\"beta\",e,t,n))];case\"Softmax\":return[a.softmax(k(\"x\",e,t,n))];case\"LogSoftmax\":return[a.logSoftmax(k(\"x\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},n5=(e,t,n,a=on)=>{switch(e.op){case\"RaggedGather\":{let{outputNestedSplits:r,outputDenseValues:s}=a.raggedGather(k(\"paramsNestedSplits\",e,t,n),k(\"paramsDenseValues\",e,t,n),k(\"indices\",e,t,n),k(\"outputRaggedRank\",e,t,n));return r.concat(s)}case\"RaggedRange\":{let{rtNestedSplits:r,rtDenseValues:s}=a.raggedRange(k(\"starts\",e,t,n),k(\"limits\",e,t,n),k(\"splits\",e,t,n));return[r,s]}case\"RaggedTensorToTensor\":return[a.raggedTensorToTensor(k(\"shape\",e,t,n),k(\"values\",e,t,n),k(\"defaultValue\",e,t,n),k(\"rowPartitionTensors\",e,t,n),k(\"rowPartitionTypes\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},a5=(e,t,n,a=on)=>{switch(e.op){case\"Max\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.max(k(\"x\",e,t,n),o,l)]}case\"Mean\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.mean(k(\"x\",e,t,n),o,l)]}case\"Min\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.min(k(\"x\",e,t,n),o,l)]}case\"Sum\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.sum(k(\"x\",e,t,n),o,l)]}case\"All\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.all(k(\"x\",e,t,n),o,l)]}case\"Any\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.any(k(\"x\",e,t,n),o,l)]}case\"ArgMax\":{let o=k(\"axis\",e,t,n);return[a.argMax(k(\"x\",e,t,n),o)]}case\"ArgMin\":{let o=k(\"axis\",e,t,n);return[a.argMin(k(\"x\",e,t,n),o)]}case\"Prod\":{let o=k(\"axis\",e,t,n),l=k(\"keepDims\",e,t,n);return[a.prod(k(\"x\",e,t,n),o,l)]}case\"Cumprod\":{let o=k(\"axis\",e,t,n),l=k(\"exclusive\",e,t,n),u=k(\"reverse\",e,t,n);return[a.cumprod(k(\"x\",e,t,n),o,l,u)]}case\"Cumsum\":{let o=k(\"axis\",e,t,n),l=k(\"exclusive\",e,t,n),u=k(\"reverse\",e,t,n);return[a.cumsum(k(\"x\",e,t,n),o,l,u)]}case\"Bincount\":let r=k(\"x\",e,t,n),s=k(\"weights\",e,t,n),i=k(\"size\",e,t,n);return[a.bincount(r,s,i)];case\"DenseBincount\":{let o=k(\"x\",e,t,n),l=k(\"weights\",e,t,n),u=k(\"size\",e,t,n),p=k(\"binaryOutput\",e,t,n);return[a.denseBincount(o,l,u,p)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},r5=(e,t,n,a=on)=>{switch(e.op){case\"ConcatV2\":case\"Concat\":{let r=k(\"n\",e,t,n),s=k(\"axis\",e,t,n),i=k(\"tensors\",e,t,n);return i=i.slice(0,r),[a.concat(i,s)]}case\"Gather\":{let r=k(\"x\",e,t,n),s=k(\"indices\",e,t,n);return[a.gather(r,a.cast(s,\"int32\"),0)]}case\"GatherV2\":{let r=k(\"axis\",e,t,n),s=k(\"batchDims\",e,t,n),i=k(\"x\",e,t,n),o=k(\"indices\",e,t,n);return[a.gather(i,a.cast(o,\"int32\"),r,s)]}case\"Reverse\":{let r=k(\"dims\",e,t,n),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);let i=k(\"x\",e,t,n);return[a.reverse(i,s)]}case\"ReverseV2\":{let r=k(\"axis\",e,t,n),s=k(\"x\",e,t,n);return[a.reverse(s,r)]}case\"Slice\":{let r=k(\"begin\",e,t,n),s=k(\"size\",e,t,n);return[a.slice(k(\"x\",e,t,n),r,s)]}case\"StridedSlice\":{let r=k(\"begin\",e,t,n),s=k(\"end\",e,t,n),i=k(\"strides\",e,t,n),o=k(\"beginMask\",e,t,n),l=k(\"endMask\",e,t,n),u=k(\"ellipsisMask\",e,t,n),p=k(\"newAxisMask\",e,t,n),d=k(\"shrinkAxisMask\",e,t,n),c=k(\"x\",e,t,n);return[a.stridedSlice(c,r,s,i,o,l,u,p,d)]}case\"Pack\":return O(()=>{let r=k(\"axis\",e,t,n),s=k(\"tensors\",e,t,n),i=s[0].shape,o=a.squeeze(s[0]).shape,l=s.map(u=>{let p=w.arraysEqual(u.shape,i);if(!p&&!w.arraysEqual(a.squeeze(u).shape,o))throw new Error(\"the input tensors shape does not match\");return p?u:a.reshape(u,i)});return[a.stack(l,r)]});case\"Unpack\":{let r=k(\"axis\",e,t,n),s=k(\"tensor\",e,t,n);return a.unstack(s,r)}case\"Tile\":{let r=k(\"reps\",e,t,n);return[a.tile(k(\"x\",e,t,n),r)]}case\"Split\":case\"SplitV\":{let r=k(\"axis\",e,t,n),s=k(\"numOrSizeSplits\",e,t,n),i=k(\"x\",e,t,n);return a.split(i,s,r)}case\"ScatterNd\":{let r=k(\"indices\",e,t,n),s=k(\"values\",e,t,n),i=k(\"shape\",e,t,n);return[a.scatterND(r,s,i)]}case\"GatherNd\":{let r=k(\"x\",e,t,n),s=k(\"indices\",e,t,n);return[a.gatherND(r,s)]}case\"SparseToDense\":{let r=k(\"sparseIndices\",e,t,n),s=k(\"outputShape\",e,t,n),i=k(\"sparseValues\",e,t,n),o=k(\"defaultValue\",e,t,n);return[a.sparseToDense(r,i,s,i.dtype===o.dtype?o:a.cast(o,i.dtype))]}case\"TensorScatterUpdate\":{let r=k(\"indices\",e,t,n),s=k(\"values\",e,t,n),i=k(\"tensor\",e,t,n);return[a.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},s5=(e,t,n,a=on)=>{switch(e.op){case\"SparseFillEmptyRows\":{let{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows(k(\"indices\",e,t,n),k(\"values\",e,t,n),k(\"denseShape\",e,t,n),k(\"defaultValue\",e,t,n));return[r,s,i,o]}case\"SparseReshape\":{let{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(k(\"inputIndices\",e,t,n),k(\"inputShape\",e,t,n),k(\"newShape\",e,t,n));return[r,s]}case\"SparseSegmentMean\":return[a.sparse.sparseSegmentMean(k(\"data\",e,t,n),k(\"indices\",e,t,n),k(\"segmentIds\",e,t,n))];case\"SparseSegmentSum\":return[a.sparse.sparseSegmentSum(k(\"data\",e,t,n),k(\"indices\",e,t,n),k(\"segmentIds\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},i5=(e,t,n,a=on)=>{switch(e.op){case\"FFT\":return[a.fft(k(\"x\",e,t,n))];case\"IFFT\":return[a.ifft(k(\"x\",e,t,n))];case\"RFFT\":return[a.rfft(k(\"x\",e,t,n))];case\"IRFFT\":return[a.irfft(k(\"x\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},o5=(e,t,n,a=on)=>{switch(e.op){case\"StaticRegexReplace\":return[a.string.staticRegexReplace(k(\"input\",e,t,n),k(\"pattern\",e,t,n),k(\"rewrite\",e,t,n),k(\"replaceGlobal\",e,t,n))];case\"StringNGrams\":{let{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(k(\"data\",e,t,n),k(\"dataSplits\",e,t,n),k(\"separator\",e,t,n),k(\"nGramWidths\",e,t,n),k(\"leftPad\",e,t,n),k(\"rightPad\",e,t,n),k(\"padWidth\",e,t,n),k(\"preserveShortSequences\",e,t,n));return[r,s]}case\"StringSplit\":{let{indices:r,values:s,shape:i}=a.string.stringSplit(k(\"input\",e,t,n),k(\"delimiter\",e,t,n),k(\"skipEmpty\",e,t,n));return[r,s,i]}case\"StringToHashBucketFast\":return[a.string.stringToHashBucketFast(k(\"input\",e,t,n),k(\"numBuckets\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},l5=(e,t,n,a=on)=>{switch(e.op){case\"Cast\":return[a.cast(k(\"x\",e,t,n),k(\"dtype\",e,t,n))];case\"ExpandDims\":{let r=k(\"axis\",e,t,n);return[a.expandDims(k(\"x\",e,t,n),r)]}case\"Squeeze\":{let r=k(\"axis\",e,t,n);return[a.squeeze(k(\"x\",e,t,n),r)]}case\"Reshape\":return[a.reshape(k(\"x\",e,t,n),k(\"shape\",e,t,n))];case\"EnsureShape\":return[a.ensureShape(k(\"x\",e,t,n),k(\"shape\",e,t,n))];case\"MirrorPad\":return[a.mirrorPad(k(\"x\",e,t,n),k(\"padding\",e,t,n),k(\"mode\",e,t,n))];case\"PadV2\":case\"Pad\":return[a.pad(k(\"x\",e,t,n),k(\"padding\",e,t,n),k(\"constantValue\",e,t,n))];case\"SpaceToBatchND\":{let r=k(\"blockShape\",e,t,n),s=k(\"paddings\",e,t,n);return[a.spaceToBatchND(k(\"x\",e,t,n),r,s)]}case\"BatchToSpaceND\":{let r=k(\"blockShape\",e,t,n),s=k(\"crops\",e,t,n);return[a.batchToSpaceND(k(\"x\",e,t,n),r,s)]}case\"DepthToSpace\":{let r=k(\"blockSize\",e,t,n),s=k(\"dataFormat\",e,t,n).toUpperCase();return[a.depthToSpace(k(\"x\",e,t,n),r,s)]}case\"BroadcastTo\":return[a.broadcastTo(k(\"x\",e,t,n),k(\"shape\",e,t,n))];case\"BroadcastArgs\":return[a.broadcastArgs(k(\"s0\",e,t,n),k(\"s1\",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function UI(e,t,n,a,r=O){let s=((i,o,l)=>{switch(i.category){case\"arithmetic\":return r(()=>Pq(i,o,l));case\"basic_math\":return r(()=>Lq(i,o,l));case\"control\":return Gq(i,o,l);case\"convolution\":return r(()=>Hq(i,o,l));case\"creation\":return r(()=>jq(i,o,l));case\"dynamic\":return qq(i,o,l);case\"evaluation\":return r(()=>Kq(i,o,l));case\"image\":return r(()=>Jq(i,o,l));case\"graph\":return r(()=>Xq(i,o,l));case\"logical\":return r(()=>Qq(i,o,l));case\"matrices\":return r(()=>e5(i,o,l));case\"normalization\":return r(()=>t5(i,o,l));case\"ragged\":return r(()=>n5(i,o,l));case\"reduction\":return r(()=>a5(i,o,l));case\"slice_join\":return r(()=>r5(i,o,l));case\"sparse\":return r(()=>s5(i,o,l));case\"spectral\":return r(()=>i5(i,o,l));case\"string\":return r(()=>o5(i,o,l));case\"transformation\":return r(()=>l5(i,o,l));case\"hash_table\":return Zq(i,o,l,a);case\"custom\":let u=zC(i.op);if(u&&u.customExecutor)return u.customExecutor(new Oq(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return w.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var GI=class{constructor(e={},t={},n={},a={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:\"\",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(\"\"),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?\"\":`${t.frameName}-${t.iterationId}`).join(\"/\"):\"\"}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error(\"Cannot exit frame, the context is empty\")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error(\"Cannot increase frame iteration, the context is empty\")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function HI(e,t,n,a){let r=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(c=>Xn(c)[0]));a=a||[];let p=new Set(a.map(c=>Xn(c.name)[0])),d=[...t];for(;d.length>0;){let c=d.pop();if((Qs(c)||g5(c)||b5(c))&&i==null&&(i=c,o=i.children.map(h=>h.name).filter(h=>r.has(h))),r.add(c.name),n[c.name]==null&&!u.has(c.name)&&!p.has(c.name)){if(c.inputs.length===0){s.push(c.name);continue}c.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),d.push(h))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function u5(e,t){let{usedNodes:n,inputs:a}=t,r=Object.keys(a).map(g=>Xn(g)[0]).map(g=>e.nodes[g]),s=e.initNodes||[],i=g=>n.has(typeof g==\"string\"?g:g.name);function o(g){return[...new Map(g.map(b=>[b.name,b])).values()]}let l=o([...r,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),p=new Map(u.map(g=>[g.name,g])),d={};for(let g of u){d[g.name]=d[g.name]||0;for(let b of g.children)i(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}let c=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),h=[...c];for(;c.length>0;){let g=c.pop(),b=p.get(g);for(let y of b.children.filter(i))--d[y.name]===0&&(h.push(y.name),c.push(y.name))}let m=h.map(g=>p.get(g)),f=p5(m,l);return c5(f,l),f}function p5(e,t){let n=new Map(e.map(s=>[s.name,s])),a=t.map(s=>s.name),r=new Set(a);for(;a.length>0;){let s=a.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||r.has(o.name)||(r.add(o.name),a.push(o.name))}return e.filter(s=>r.has(s.name))}var Th=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function c5(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),a=new Set(t.map(o=>o.name)),r=o=>a.has(typeof o==\"string\"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o==\"string\"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new Th(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Th(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(let l of o.inputs){if(!n.has(l.name))throw new Th(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Th(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function d5(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,a=e.map((o,l)=>Qs(o)?n:l),r=o=>{let l=a[t.get(o.name)];return l==null?-1:l},s=e.map((o,l)=>o.children.map(r).reduce((u,p)=>Math.max(u,p),a[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let u=e[o],p=e[l];i.has(p.name)||i.set(p.name,[]),i.get(p.name).push(u)}return i}var h5=new Set([\"Switch\",\"Merge\",\"Enter\",\"Exit\",\"NextIteration\",\"StatelessIf\",\"StatelessWhile\",\"if\",\"While\"]),m5=new Set([\"NonMaxSuppressionV2\",\"NonMaxSuppressionV3\",\"NonMaxSuppressionV5\",\"Where\"]),f5=new Set([\"HashTable\",\"HashTableV2\",\"LookupTableImport\",\"LookupTableImportV2\",\"LookupTableFind\",\"LookupTableFindV2\",\"LookupTableSize\",\"LookupTableSizeV2\"]);function Qs(e){return h5.has(e.op)}function g5(e){return m5.has(e.op)}function b5(e){return f5.has(e.op)}var jI=class oE{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(a=>t[a].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=\",\",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(a=>{this._functionExecutorMap[a]=new oE(t.functions[a],this)})}getCompilationKey(t,n){let a=t.map(s=>s.name).sort(),r=n.map(s=>s.name).sort();return a.join(this.SEPARATOR)+\"--\"+r.join(this.SEPARATOR)}compile(t,n){let a=HI(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:i}=a;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let u=n.map(d=>d.name),p=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${p}]. Missing the following inputs: [${r}]`)}let o=u5(this.graph,a),l=d5(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return Ht(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,a])=>[n,this.cloneTensorList(a)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let r=a.map(c=>this.graph.nodes[Xn(c)[0]]),s=n.map(c=>Xn(c)[0]),i=new Set(s),o=s.map(c=>this.graph.nodes[c]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(r,o),u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=G().getBool(\"KEEP_INTERMEDIATE_TENSORS\")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let p={},d={};return O(()=>{let c=new GI(this.weightMap,p,d,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(b=>{let[y,x]=Xn(b,c),v=[];v[x]=t[b],h[y]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(v))});let m=this.getFrozenTensorIds(h),{orderedNodes:f,nodeLiveUntilMap:g}=u;for(let b of f){if(h[b.name])continue;let y=UI(b,h,c,this._resourceManager);if(w.isPromise(y))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);h[b.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(y)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,h,c,m,i,g.get(b.name))}return this.parent==null&&c.dispose(m),n.map(b=>pn(b,h,c))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(a=>t[a]).map(a=>a.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,a,r,s,i,o){if(!(Qs(n)||i.has(t))){for(let l of a[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(Qs(l))continue;let u=LI(l.name,a,r);if(u!=null)for(let p of u){if(!p||p.kept||s.has(p.id))continue;let d=o[p.id];d===1?(p.dispose(),delete o[p.id]):d!=null&&o[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,a,r,s,i){function o(l){return Qs(l)||s.has(l.name)}if(!(Qs(t)||i==null))for(let l of i){if(o(l))continue;let u=LI(l.name,n,a);for(let p of u)!p||p.kept||r.has(p.id)||p.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,a=!1,r={},s={}){this.disposeIntermediateTensors(),a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=G().getBool(\"KEEP_INTERMEDIATE_TENSORS\")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let i=new GI(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,a),l=n.map(c=>pn(c,o,i)),u=l.map(c=>c.id),p=Object.keys(t).map(c=>t[c].id),d=new Set([...u,...p,...this.weightIds]);return Object.values(o).forEach(c=>{c.forEach(h=>{h&&!h.isDisposed&&!d.has(h.id)&&h.dispose()})}),this.parent==null&&i.dispose(d),l}async executeFunctionAsync(t,n,a){let r=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(r,this.outputNodes,!0,n,a)}async executeWithControlFlow(t,n,a,r){let s=Object.keys(t),i=s.map(v=>this.graph.nodes[Xn(v)[0]]),o=a.map(v=>Xn(v)[0]),l=new Set(o),u=o.map(v=>this.graph.nodes[v]);u.length===0&&(u=this._outputs);let{usedNodes:p,missingInputs:d,dynamicNode:c,syncInputs:h}=HI(t,u,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),f=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{let[I,N]=Xn(v),C=[];C[N]=t[v],f[I]=C});let g={},b=this.getFrozenTensorIds(f),y={};for(;m.length>0;){let v=this.processStack(i,m,n,f,y,b,l,g,p);await Promise.all(v)}c==null&&!r&&console.warn(\"This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.\");let x=u.filter(v=>!Qs(v)&&!pn(v.name,f,n)).map(v=>v.name);if(x.length>0){let v=\"\";throw c!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${d}]. ${v}`)}return f}processStack(t,n,a,r,s,i,o,l,u){let p=[];for(;n.length>0;){let d=n.pop();a.currentContext=d.contexts;let c=\"\";if(d.node.op===\"Enter\"&&k(\"isConstant\",d.node,r,a)&&([c]=Sr(d.node.name,a)),r[d.node.name]==null){let h=UI(d.node,r,a,this._resourceManager);c||([c]=Sr(d.node.name,a));let m=a.currentContext;w.isPromise(h)?p.push(h.then(f=>(r[c]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(f)),a.currentContext=m,this.checkTensorForDisposal(c,d.node,r,a,i,o,l),this.processChildNodes(d.node,n,a,r,s,u),f))):(r[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),this.checkTensorForDisposal(c,d.node,r,a,i,o,l),this.processChildNodes(d.node,n,a,r,s,u))}else this.processChildNodes(d.node,n,a,r,s,u)}return p}processChildNodes(t,n,a,r,s,i){t.children.forEach(o=>{let[l]=Sr(o.name,a);s[l]||!i.has(o.name)||(o.op===\"Merge\"?o.inputNames.some(u=>!!pn(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})):o.inputNames.every(u=>!!pn(u,r,a))&&(s[l]=!0,n.push({contexts:a.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let a=t[n],[r]=Xn(n),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===a.shape.length&&a.shape.every((l,u)=>i[u]===-1||i[u]===l);w.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${a.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&w.assert(a.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(t){var n,a;let r={};for(let s in t){let i=(a=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||a===void 0?void 0:a[s];i!=null?r[i.name]=t[s]:r[s]=t[s]}return r}checkInputs(t){let n=Object.keys(t).filter(a=>{let[r]=Xn(a);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var a,r;let s=(r=(a=this._signature)===null||a===void 0?void 0:a.outputs)===null||r===void 0?void 0:r[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[a]=Xn(n);if(!this.graph.nodes[a])throw new Error(`The output '${n}' is not found in the graph`)})}},y5=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},x5=\"?tfjs-format=file\",v5=\"model.json\",F1=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=jt){this.modelUrl=e,this.loadOptions=t,this.version=\"n/a\",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new y5}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error(\"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.\");let e=this.handler.load();return w.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error(\"Model artifacts missing streamWeights function\");let t=await pN(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let r=this.artifacts.userDefinedMetadata;r.signature!=null&&(a=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=a,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new jI(zI.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let r=zI.Instance.transformGraph(e.modelInitializer);this.initializer=new jI(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e==\"string\"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error(\"GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.\");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Ce?[e]:e,n={};return t.forEach((a,r)=>n[this.structuredOutputKeys[r]]=a),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Ce)&&!Array.isArray(e)){let r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(let s in r){let i=r[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((r,s)=>{var i,o,l;let u=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return u!=null?r[s]=this.resourceIdToCapturedInput[u]:r[s]=e[a++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let a=0;a<n.length;a++){let r=n[a],s=t[r];this.resourceIdToCapturedInput[s.resourceId]=e[a]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ee(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function w5(e,t={},n=jt){if(e==null)throw new Error(\"modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model\");t==null&&(t={}),t.fromTFHub&&typeof e==\"string\"&&(e=I5(e));let a=new F1(e,t,n);return await a.load(),a}function k5(e){if(e==null)throw new Error(\"modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model\");let t;if(e instanceof Array){let[a,r]=e;if(!a)throw new Error(\"modelJSON must be the first element of the array\");if(!r||!(r instanceof ArrayBuffer))throw new Error(\"An ArrayBuffer of weights must be the second element of the array\");if(!(\"modelTopology\"in a))throw new Error(\"Model JSON is missing 'modelTopology'\");if(!(\"weightsManifest\"in a))throw new Error(\"Model JSON is missing 'weightsManifest'\");let s=jt.getWeightSpecs(a.weightsManifest),i=jt.getModelArtifactsForJSONSync(a,s,r);t=jt.fromMemorySync(i)}else if(\"load\"in e)t=e;else if(\"modelTopology\"in e&&\"weightSpecs\"in e&&\"weightData\"in e)t=jt.fromMemorySync(e);else throw new Error(\"Unknown model format\");let n=new F1(t);return n.load(),n}function I5(e){return e.endsWith(\"/\")||(e=e+\"/\"),`${e}${v5}${x5}`}var S5=\"4.22.0\",lE={};_e(lE,{CSVDataset:()=>xE,Dataset:()=>ip,FileDataSource:()=>TE,TextLineDataset:()=>yE,URLDataSource:()=>CE,array:()=>q5,csv:()=>i8,func:()=>o8,generator:()=>l8,microphone:()=>p8,version_data:()=>c8,webcam:()=>u8,zip:()=>K5});var N5=xs(bm()),T5=xs(bm());function C5(e,t){return om(e,t)}function om(e,t,n=new Map,a=new Set){if(e==null)return null;if(typeof Blob==\"function\"&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error(\"Circular references are not supported.\");if(n.has(e))return n.get(e);let r=t(e);if(r.recurse&&r.value!==null)throw new Error(\"A deep map function may not return both a value and recurse=true.\");if(r.recurse)if(Hl(e)){let s=Array.isArray(e)?[]:{};a.add(e);for(let i in e){let o=e[i],l=om(o,t,n,a);s[i]=l}return a.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,r.value),r.value}function E5(e,t=pE){return uE(e,t)}function uE(e,t,n=new Set){let a=e[0];if(n.has(a))throw new Error(\"Circular references are not supported.\");let r=t(e);if(r.recurse&&r.value!==null)throw new Error(\"A deep zip function may not return both a value and recurse=true.\");if(r.recurse)if(Hl(a)){let s=Array.isArray(a)?[]:{};n.add(a);for(let i in a){let o=e.map(u=>u[i]),l=uE(o,t,n);s[i]=l}return n.delete(a),s}else throw new Error(`Can't recurse into non-iterable type: ${a}`);else return r.value}function pE(e){return e===null?null:Hl(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function cE(e,t){let n=new Map;om(e,t,n);for(let a of Array.from(n.keys())){let r=n.get(a);if(w.isPromise(r)){let s=await r;n.set(a,s)}}return om(e,t,n)}function Hl(e){let t=!1;if(G().get(\"IS_BROWSER\"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=FS();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e==\"object\"&&!(e instanceof Ce)&&!(e instanceof Promise)&&!t)}function _5(e){return e==null||A5(e)||Array.isArray(e)||typeof e==\"object\"&&e instanceof Ce||w.isTypedArray(e)}function A5(e){return e===null||typeof e!=\"object\"&&typeof e!=\"function\"}function F5(e){return C5(e,$5)}function $5(e){return e instanceof Ce?{value:e.clone(),recurse:!1}:Hl(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var dE=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError(\"Can't create a ring buffer of unknown capacity.\");if(e<1)throw new RangeError(\"Can't create ring buffer of capacity < 1.\");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError(\"Can't get item at a negative index.\");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError(\"Can't set item at a negative index.\");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError(\"Ring buffer is full.\");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError(\"Ring buffer is empty.\");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError(\"Ring buffer is full.\");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError(\"Ring buffer is empty.\");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError(\"Ring buffer is empty.\");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},hE=class mE extends dE{constructor(){super(mE.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),a=this.length();for(let r=0;r<a;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=a}};hE.INITIAL_CAPACITY=32;function fE(e){return new M5(e)}function $1(e){return new O5(e)}function D5(e,t){return new gE(e,t)}function R5(e,t=es.FAIL){return new H5(e,t)}var sn=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new U5(this,e)}filter(e){return new B5(this,e)}map(e){return new V5(this,e)}mapAsync(e){return new qI(this,e)}serialMapAsync(e){return new qI(this,e).serial()}flatmap(e){return new G5(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new W5(this,e,t)}columnMajorBatch(e,t=!0,n=pE){return this.rowMajorBatch(e,t).map(a=>E5(a,n))}concatenate(e,t){return new gE(fE([this,e]),t)}take(e){return e<0||e==null?this:new z5(this,e)}skip(e){return e<0||e==null?this:new L5(this,e)}prefetch(e){return new bE(this,e)}shuffle(e,t){return new j5(this,e,t)}serial(){return new P5(this)}},M5=class extends sn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:F5(e),done:!1}}},O5=class extends sn{constructor(e){super(),this.nextFn=e}summary(){return\"Function call\"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},P5=class extends sn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},L5=class extends sn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Ee(e.value)}return this.upstream.next()}},z5=class extends sn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},W5=class extends sn{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},B5=class extends sn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ee(e.value)}}},V5=class extends sn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Wa.getTensorsInContainer(e.value),n=this.transform(e.value),a=Wa.getTensorsInContainer(n);for(let r of t)Wa.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},U5=class extends sn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},qI=class extends sn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Wa.getTensorsInContainer(e.value),n=await this.transform(e.value),a=Wa.getTensorsInContainer(n);for(let r of t)Wa.isTensorInList(r,a)||r.dispose();return{value:n,done:!1}}},D1=class extends sn{constructor(){super(),this.outputQueue=new hE,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},G5=class extends D1{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Wa.getTensorsInContainer(e.value),n=this.transform(e.value),a=Wa.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let r of t)Wa.isTensorInList(r,a)||r.dispose();return!0}},gE=class extends sn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return\"TODO: fill in upstream of chained summaries -> Chained\"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},es;(function(e){e[e.FAIL=0]=\"FAIL\",e[e.SHORTEST=1]=\"SHORTEST\",e[e.LONGEST=2]=\"LONGEST\"})(es||(es={}));var H5=class extends sn{constructor(e,t=es.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return\"{TODO: fill in upstream of zip summaries} -> Zip\"}async nextState(e){await e;let t=0,n=0;function a(s){return s instanceof sn?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let r=await cE(this.iterators,a);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case es.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case es.SHORTEST:return{value:null,done:!0};case es.LONGEST:default:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},bE=class extends sn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new dE(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},j5=class extends bE{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=T5.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},ip=class{constructor(){this.size=null}batch(e,t=!0){let n=this;w.assert(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`);let a;return this.size===1/0||this.size==null?a=this.size:t?a=Math.ceil(this.size/e):a=Math.floor(this.size/e),Kn(async()=>(await n.iterator()).columnMajorBatch(e,t,X5),a)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Kn(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Kn(async()=>(await t.iterator()).filter(a=>O(()=>e(a))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Kn(async()=>(await t.iterator()).map(n=>O(()=>e(n))),this.size)}mapAsync(e){let t=this;return Kn(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError(\"`Dataset.prefetch()` requires bufferSize to be specified.\");let t=this;return Kn(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Kn(async()=>{let a=$1(async()=>({value:await t.iterator(),done:!1}));return D5(a.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Kn(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError(\"`Dataset.shuffle()` requires bufferSize to be specified.\"):new RangeError(`\\`Dataset.shuffle()\\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \\`tf.Tensor\\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let a=this,r=N5.alea(t||w.now().toString());return Kn(async()=>{let s=r.int32();return n&&(s+=r.int32()),(await a.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Kn(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error(\"Can not convert infinite data stream to array.\");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error(\"Can not convert infinite data stream to array.\");return(await this.iterator()).toArrayForTest()}};ip.MAX_BUFFER_SIZE=1e4;function Kn(e,t=null){return new class extends ip{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function q5(e){return Kn(async()=>fE(e),e.length)}function K5(e){if(!Hl(e))throw new Error(\"The argument to zip() must be an object or array.\");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Kn(async()=>{let n=await cE(e,a=>{if(a instanceof ip)return{value:a.iterator(),recurse:!1};if(Hl(a))return{value:null,recurse:!0};throw new Error(\"Leaves of the structure passed to zip() must be Datasets, not primitives.\")});return R5(n,es.SHORTEST)},t)}function X5(e){if(e===null)return null;let t=e[0];return _5(t)?{value:Y5(e),recurse:!1}:{value:null,recurse:!0}}function Y5(e){if(e.length===0)throw new Error(\"Can't make a batch of zero elements.\");return e[0]instanceof Ce?At(e):bn(e)}var yE=class extends ip{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`\n`).map(e=>(e.endsWith(\"\\r\")&&(e=e.slice(0,-1)),e))}},Ch='\"',Jp=Symbol(\"out\"),KI=Symbol(\"field\"),Eh=Symbol(\"quote\"),bx=Symbol(\"quoteafterquote\"),XI=Symbol(\"quoteinquote\"),xE=class extends ip{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error(\"Column names must be provided if there is no header line.\");this.fullColumnNames&&e&&w.assert(e.length===this.fullColumnNames.length,()=>\"The length of provided columnNames (\"+this.fullColumnNames.length.toString()+\") does not match the length of the header line read from file (\"+e.length.toString()+\").\"),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((a,r)=>(a[r]=a[r]+1||1,a),{}),n=Object.keys(t).filter(a=>t[a]>1);if(w.assert(n.length===0,()=>\"Duplicate column names found: \"+n.toString()),this.columnConfigs){for(let a of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(a)===-1)throw new Error('The key \"'+a+'\" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+\").\")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error(\"No data was found for CSV parsing.\");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=\",\",this.delimWhitespace=!1,this.base=new yE(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w.assert(t.delimiter==null,()=>\"Delimiter should not be provided when delimWhitespace is true.\"),this.delimWhitespace=!0,this.delimiter=\" \"):this.delimiter=t.delimiter?t.delimiter:\",\"}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},a={};for(let r=0;r<this.fullColumnNames.length;r++){let s=this.fullColumnNames[r],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[r],l=null;if(o===\"\")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))i&&i.dtype===\"bool\"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=u;else switch(i.dtype){case\"float32\":l=u;break;case\"int32\":l=Math.floor(u);break;case\"bool\":l=this.getBoolean(o);break;default:l=u}}i&&i.isLabel?a[s]=l:n[s]=l}}return Object.keys(a).length===0?n:{xs:n,ys:a}}getBoolean(e){return e===\"1\"||e.toLowerCase()===\"true\"?1:0}parseRow(e,t=!0){let n=[],a=0,r=e.length,s=Jp;for(let i=0;i<r;i++)switch(s){case Jp:switch(e.charAt(i)){case Ch:a=i+1,s=Eh;break;case this.delimiter:if(a=i+1,this.delimiter===\" \"&&this.delimWhitespace)break;n.push(\"\"),s=Jp;break;default:s=KI,a=i;break}break;case KI:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i)),s=Jp,a=i+1;break;default:}break;case Eh:switch(e.charAt(i)){case Ch:s=bx;break;default:}break;case bx:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(a,i-1)),s=Jp,a=i+1;break;case Ch:s=Eh;break;default:s=XI;break}break;case XI:switch(e.charAt(i)){case Ch:s=Eh;break;default:}break;default:}if(s===bx?n.push(e.substring(a,r-1)):n.push(e.substring(a)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},Z5=class vE extends sn{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error(\"Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.\")}summary(){return\"microphone\"}static async create(t={}){if(!G().get(\"IS_BROWSER\"))throw new Error(\"microphone API is only supported in browser environment.\");let n=new vE(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw new Error(\"Could not obtain audio from microphone.\");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,a=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(a.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(a.timeDataQueue);n=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],a=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++a===this.numFrames&&(clearInterval(s),r({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error(\"Can not convert infinite audio stream to array.\")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,a=new Float32Array(t.length*n);return t.forEach((r,s)=>a.set(r,s*n)),a}getTensorFromAudioDataArray(t,n){let a=new Float32Array(w.sizeFromShape(n));return a.set(t,a.length-t.length),bn(a,n)}},J5=class wE extends sn{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=je([0],\"int32\"),this.webcamConfig.centerCrop){let a=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-a)/2,i=(1-r)/2,o=s+a,l=r+i;this.cropBox=Ea([i,s,l,o],[1,4])}else this.cropBox=Ea([0,0,1,1],[1,4])}summary(){return\"webcam\"}static async create(t,n={}){if(!G().get(\"IS_BROWSER\"))throw new Error(\"tf.data.webcam is only supported in browser environment.\");if(!t){if(t=document.createElement(\"video\"),!n.resizeWidth||!n.resizeHeight)throw new Error(\"Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.\");t.width=n.resizeWidth,t.height=n.resizeHeight}let a=new wE(t,n);return await a.start(),a}async start(){this.webcamConfig.facingMode&&w.assert(this.webcamConfig.facingMode===\"user\"||this.webcamConfig.facingMode===\"environment\",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:\"user\",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error(\"Could not obtain video from webcam.\");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=qo.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return O(()=>{let n=Gt(re(t,\"float32\"),0),a;a=Zn.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,\"bilinear\");let r=a.shape;return W(a,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error(\"Can not convert infinite video stream to array.\")}},kE=class{},IE=class extends sn{split(e){return new Q5(this,e)}},Q5=class extends IE{constructor(e,t){super(),this.upstream=e,this.impl=new e8(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},e8=class extends D1{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=\"\"}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===\"\"?!1:(this.outputQueue.push(this.carryover),this.carryover=\"\",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},t8=class extends sn{decodeUTF8(){return new n8(this)}},n8=class extends IE{constructor(e){super(),this.upstream=e,this.impl=new a8(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},a8=class extends D1{constructor(e){if(super(),this.upstream=e,G().get(\"IS_BROWSER\"))this.decoder=new TextDecoder(\"utf-8\");else{let{StringDecoder:t}=FS();this.decoder=new t(\"utf8\")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return G().get(\"IS_BROWSER\")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},SE=class extends t8{constructor(e,t={}){super(),this.file=e,this.options=t,w.assert(e instanceof Uint8Array||(G().get(\"IS_BROWSER\")?e instanceof File||e instanceof Blob:!1),()=>\"FileChunkIterator only supports File, Blob and Uint8Array right now.\"),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let a=new FileReader;a.onload=s=>{let i=a.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError(\"FileReader returned unknown type.\"));e(i)},a.onabort=s=>t(new Error(\"Aborted\")),a.onerror=s=>t(new Error(s.type));let r=this.file.slice(this.offset,n);a.readAsArrayBuffer(r)}this.offset=n}),done:!1}}};async function r8(e,t={},n){let a,r;typeof e==\"string\"?a=e:(a=e.url,r=s8(e));let s=await(n||w.fetch)(a,r);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new SE(i,t)}else throw new Error(s.statusText)}var s8=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function NE(e){return typeof e==\"string\"&&e.slice(0,7)===\"file://\"}var TE=class extends kE{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(NE(this.input)&&G().get(\"IS_NODE\")){let e=Iv();this.input=e.readFileSync(this.input.slice(7))}return new SE(this.input,this.options)}},CE=class extends kE{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return NE(this.url)?new TE(this.url,this.fileOptions).iterator():r8(this.url,this.fileOptions)}};function i8(e,t={}){return new xE(new CE(e),t)}function o8(e){let t=$1(e);return Kn(async()=>t)}function l8(e){return Kn(async()=>{let t=await e();return $1(()=>t.next())})}async function u8(e,t){return J5.create(e,t)}async function p8(e){return Z5.create(e)}var c8=\"4.22.0\";function ge(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!==\"complex64\",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var d8=mr.whereImpl,R1=class EE extends Fc{nextDataId(){return EE.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ym(this,Ta())}write(t,n,a){this.firstUse&&(this.firstUse=!1,G().get(\"IS_NODE\")&&T.warn(`\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:a,refCount:1}),r}makeTensorInfo(t,n,a){let r;if(n===\"string\"&&a!=null&&a.length>0&&w.isString(a[0])){let s=a.map(i=>w.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return{dataId:r,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,a,r,s){this.data.set(t,{values:n,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:a}=this.data.get(t);if(n===\"complex64\"){let r=this.readSync(a.real.dataId),s=this.readSync(a.imag.dataId);return T.mergeRealAndImagArrays(r,s)}return w.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype===\"string\")try{let a=n.map(r=>w.decodeString(r));return Oe(t.shape,t.dtype,a)}catch(a){throw new Error(\"Failed to decode encoded string bytes into utf-8\")}return Oe(t.shape,t.dtype,n)}makeOutput(t,n,a){return Ta().makeTensorFromTensorInfo(this.makeTensorInfo(n,a,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:a}=this.data.get(t);a!=null&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=w.now();return t(),{kernelMs:w.now()-n}}memory(){return{unreliable:!0,reasons:[\"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"]}}where(t){ge([t],\"where\");let n=this.readSync(t.dataId);return d8(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};R1.nextDataId=0;var M1={};_e(M1,{addImpl:()=>FE,bincountImpl:()=>P1,bincountReduceImpl:()=>$E,bitwiseAndImpl:()=>DE,castImpl:()=>AE,ceilImpl:()=>RE,concatImpl:()=>L1,equalImpl:()=>ME,expImpl:()=>PE,expm1Impl:()=>zE,floorDivImpl:()=>BE,floorImpl:()=>WE,gatherNdImpl:()=>VE,gatherV2Impl:()=>UE,greaterEqualImpl:()=>HE,greaterImpl:()=>GE,lessEqualImpl:()=>qE,lessImpl:()=>jE,linSpaceImpl:()=>KE,logImpl:()=>XE,maxImpl:()=>YE,maximumImpl:()=>ZE,minimumImpl:()=>JE,multiplyImpl:()=>z1,negImpl:()=>QE,notEqualImpl:()=>e_,prodImpl:()=>t_,raggedGatherImpl:()=>n_,raggedRangeImpl:()=>a_,raggedTensorToTensorImpl:()=>r_,rangeImpl:()=>B1,rsqrtImpl:()=>s_,scatterImpl:()=>ni,sigmoidImpl:()=>cK,simpleAbsImpl:()=>_E,sliceImpl:()=>um,sparseFillEmptyRowsImpl:()=>o_,sparseReshapeImpl:()=>l_,sparseSegmentReductionImpl:()=>V1,sqrtImpl:()=>mK,squaredDifferenceImpl:()=>u_,staticRegexReplaceImpl:()=>p_,stridedSliceImpl:()=>c_,stringNGramsImpl:()=>U1,stringSplitImpl:()=>G1,stringToHashBucketFastImpl:()=>H1,subImpl:()=>d_,tileImpl:()=>h_,topKImpl:()=>f_,transposeImpl:()=>W1,uniqueImpl:()=>q1});function _E(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var h8=e=>{let{x:t}=e.inputs,n=e.backend;ge(t,\"abs\");let a=new Float32Array(w.sizeFromShape(t.shape)),r=n.data.get(t.dataId).values;return a=_E(r),n.makeOutput(a,t.shape,t.dtype)},m8={kernelName:Yl,backendName:\"cpu\",kernelFunc:h8};function Mt(e){return(t,n,a,r,s)=>{let i=T.assertAndGetBroadcastShape(t,n),o=i.length,l=w.computeStrides(i),u=w.sizeFromShape(i),p=w.getTypedArrayFromDType(s,u),d=t.length,c=n.length,h=w.computeStrides(t),m=w.computeStrides(n),f=T.getBroadcastDims(t,i),g=T.getBroadcastDims(n,i);if(f.length+g.length===0)for(let b=0;b<p.length;++b)p[b]=e(a[b%a.length],r[b%r.length]);else for(let b=0;b<p.length;++b){let y=w.indexToLoc(b,o,l),x=y.slice(-d);f.forEach(C=>x[C]=0);let v=w.locToIndex(x,d,h),I=y.slice(-c);g.forEach(C=>I[C]=0);let N=w.locToIndex(I,c,m);p[b]=e(a[v],r[N])}return[p,i]}}function Yn(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=n.makeTensorInfo(a.shape,\"complex64\"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(a.shape,\"float32\",s),imag:n.makeTensorInfo(r.shape,\"float32\",i)},o}var f8={kernelName:wm,backendName:\"cpu\",kernelFunc:Yn};function lm(e,t,n=\"float32\"){if(n===\"complex64\"){let r=lm(e,t,\"float32\"),s=lm(e,t,\"float32\");return Yn({inputs:{real:r,imag:s},backend:e})}let a=w.makeZerosTypedArray(w.sizeFromShape(t),n);return e.makeTensorInfo(t,n,a)}function cr(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var g8={kernelName:eo,backendName:\"cpu\",kernelFunc:cr};function yi(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var b8={kernelName:Dm,backendName:\"cpu\",kernelFunc:yi};function AE(e,t,n,a){if(a===\"int32\"){let r=Int32Array.from(e);return[t,\"int32\",r]}if(a===\"bool\"){let r=w.toTypedArray([0],n),[s,i]=Mt((o,l)=>o!==l?1:0)(t,[],e,r,\"bool\");return[i,\"bool\",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${a}`)}function bs(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s===\"complex64\"){if(r.dtype===\"complex64\")return cr({inputs:{x:r},backend:n});let p=lm(n,r.shape,r.dtype),d=bs({inputs:{x:r},backend:n,attrs:{dtype:\"float32\"}}),c=Yn({inputs:{real:d,imag:p},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),c}if(r.dtype===\"complex64\"){let p=yi({inputs:{input:r},backend:n}),d=bs({inputs:{x:p},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(p),d}if(!w.hasEncodingLoss(r.dtype,s)){let p=cr({inputs:{x:r},backend:n});return{dataId:p.dataId,shape:p.shape,dtype:s}}let i=n.data.get(r.dataId).values,[o,l,u]=AE(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}var y8={kernelName:Mi,backendName:\"cpu\",kernelFunc:bs};function Zt(e,t,n,a){return n==null?({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;ge([i,o],e);let u=l.data.get(i.dataId).values,p=l.data.get(o.dataId).values,d=i.dtype===\"string\"?T.fromUint8ToStringArray(u):u,c=i.dtype===\"string\"?T.fromUint8ToStringArray(p):p,h=a||i.dtype,[m,f]=t(i.shape,o.shape,d,c,h);return l.makeTensorInfo(f,h,m)}:({inputs:r,backend:s})=>{let{a:i,b:o}=r,l=s;if(i.dtype===\"complex64\"||o.dtype===\"complex64\"){let u=bs({inputs:{x:i},backend:l,attrs:{dtype:\"complex64\"}}),p=l.data.get(u.dataId),d=p.complexTensorInfos.real,c=p.complexTensorInfos.imag,h=l.data.get(d.dataId).values,m=l.data.get(c.dataId).values,f=bs({inputs:{x:o},backend:l,attrs:{dtype:\"complex64\"}}),g=l.data.get(f.dataId),b=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,x=l.data.get(b.dataId).values,v=l.data.get(y.dataId).values,[I,N,C]=n(i.shape,o.shape,h,m,x,v),_=l.makeTensorInfo(C,\"float32\",I),F=l.makeTensorInfo(C,\"float32\",N),D=Yn({inputs:{real:_,imag:F},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(f),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(F),D}else{let u=l.data.get(i.dataId).values,p=l.data.get(o.dataId).values,d=a||i.dtype,[c,h]=t(i.shape,o.shape,u,p,d);return l.makeTensorInfo(h,d,c)}}}function O1(e){return(t,n,a,r,s,i)=>{let o=T.assertAndGetBroadcastShape(t,n),l=w.sizeFromShape(o),u=o.length,p=w.computeStrides(o),d=w.getTypedArrayFromDType(\"float32\",l),c=w.getTypedArrayFromDType(\"float32\",l),h=T.getBroadcastDims(t,o),m=T.getBroadcastDims(n,o),f=T.mergeRealAndImagArrays(a,r),g=T.mergeRealAndImagArrays(s,i),b=t.length,y=w.computeStrides(t),x=n.length,v=w.computeStrides(n);if(h.length+m.length===0)for(let I=0;I<d.length;I++){let N=I%f.length,C=I%g.length,_=e(f[N*2],f[N*2+1],g[C*2],g[C*2+1]);d[I]=_.real,c[I]=_.imag}else for(let I=0;I<d.length;I++){let N=w.indexToLoc(I,u,p),C=N.slice(-b);h.forEach(S=>C[S]=0);let _=w.locToIndex(C,b,y),F=N.slice(-x);m.forEach(S=>F[S]=0);let D=w.locToIndex(F,x,v),$=e(f[_*2],f[_*2+1],g[D*2],g[D*2+1]);d[I]=$.real,c[I]=$.imag}return[d,c,o]}}var FE=Mt((e,t)=>e+t),x8=O1((e,t,n,a)=>({real:e+n,imag:t+a})),jl=Zt(vs,FE,x8),v8={kernelName:vs,backendName:\"cpu\",kernelFunc:jl};function P1(e,t,n,a,r){let s=w.sizeFromShape(a),i=w.makeZerosTypedArray(r,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error(\"Input x must be non-negative!\");l>=r||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function $E(e,t,n,a=!1){let r=e.shape[0],s=e.shape[1],i=Oe([r,n],t.dtype);for(let o=0;o<r;o++)for(let l=0;l<s;l++){let u=e.get(o,l);if(u<0)throw new Error(\"Input x must be non-negative!\");u>=n||(a?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}var DE=Mt((e,t)=>e&t),w8=Zt(ru,DE),k8={kernelName:ru,backendName:\"cpu\",kernelFunc:w8};function fr(e){return(t,n,a)=>{let r=w.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function lt(e,t,n){let a=fr(t);return Fs(e,a,n)}function Fs(e,t,n){return({inputs:a,attrs:r,backend:s})=>{let{x:i}=a;ge(i,e);let o=s,l=o.data.get(i.dataId).values,u;if(i.dtype===\"string\"){if(!Array.isArray(l))throw new Error(\"String tensor's value was not an instance of Array\");u=T.fromUint8ToStringArray(l)}else u=l;let p=n||i.dtype,d=t(u,p,r);return o.makeTensorInfo(i.shape,p,d)}}var RE=fr(e=>Math.ceil(e)),I8=Fs(Oi,RE),S8={kernelName:Oi,backendName:\"cpu\",kernelFunc:I8};function L1(e,t,n,a){let r=w.getArrayFromDType(n,w.sizeFromShape(t));if(a&&n!==\"string\"){let s=0;e.forEach(i=>{let o=w.sizeFromShape(i.shape);r.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n===\"string\"?T.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let p=u*t[1]+s;for(let d=0;d<i.shape[1];++d)r[p+d]=o[l++]}s+=i.shape[1]})}return r}var ME=Mt((e,t)=>e===t?1:0),OE=Zt(du,ME,null,\"bool\"),N8={kernelName:du,backendName:\"cpu\",kernelFunc:OE},PE=fr(e=>Math.exp(e)),LE=Fs(Ki,PE,\"float32\"),T8={kernelName:Ki,backendName:\"cpu\",kernelFunc:LE},zE=fr(e=>Math.expm1(e)),C8=Fs(Xi,zE),E8={kernelName:Xi,backendName:\"cpu\",kernelFunc:C8},WE=fr(e=>Math.floor(e)),_8=Fs(Yi,WE),A8={kernelName:Yi,backendName:\"cpu\",kernelFunc:_8},BE=Mt((e,t)=>Math.floor(e/t)),F8=Zt(Zi,BE,null,\"int32\"),$8={kernelName:Zi,backendName:\"cpu\",kernelFunc:F8};function VE(e,t,n,a,r,s,i,o,l){let u=Oe([a,s],n);for(let p=0;p<a;p++){let d=[],c=0;for(let h=0;h<r;h++){let m=e[p*r+h];c+=m*i[h],d.push(m)}if(c<0||c>=l/s)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let h=0;h<s;h++)u.values[p*s+h]=t.get(...t.indexToLoc(c*s+h))}return u}function UE(e,t,n){let a=Oe(n,e.dtype);for(let r=0;r<a.size;++r){let s=a.indexToLoc(r).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let u=e.locToIndex(s);0<=u&&u<e.values.length&&(a.values[r]=e.values[u])}return a}var GE=Mt((e,t)=>e>t?1:0),D8=Zt(bu,GE,null,\"bool\"),R8={kernelName:bu,backendName:\"cpu\",kernelFunc:D8},HE=Mt((e,t)=>e>=t?1:0),M8=Zt(Qi,HE,null,\"bool\"),O8={kernelName:Qi,backendName:\"cpu\",kernelFunc:M8},jE=Mt((e,t)=>e<t?1:0),P8=Zt(yu,jE,null,\"bool\"),L8={kernelName:yu,backendName:\"cpu\",kernelFunc:P8},qE=Mt((e,t)=>e<=t?1:0),z8=Zt(xu,qE,null,\"bool\"),W8={kernelName:xu,backendName:\"cpu\",kernelFunc:z8};function KE(e,t,n){let a=(t-e)/(n-1),r=w.makeZerosTypedArray(n,\"float32\");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}var XE=fr(e=>Math.log(e)),B8=Fs(so,XE),V8={kernelName:so,backendName:\"cpu\",kernelFunc:B8};function YE(e,t,n,a){let r=w.getTypedArrayFromDType(a,w.sizeFromShape(n));for(let s=0;s<r.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}r[s]=o}return r}var ZE=Mt((e,t)=>Math.max(e,t)),U8=Zt(uo,ZE),G8={kernelName:uo,backendName:\"cpu\",kernelFunc:U8},JE=Mt((e,t)=>Math.min(e,t)),H8=Zt(mo,JE),j8={kernelName:mo,backendName:\"cpu\",kernelFunc:H8},z1=Mt((e,t)=>e*t),q8=O1((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n})),zf=Zt(bo,z1,q8),K8={kernelName:bo,backendName:\"cpu\",kernelFunc:zf};function QE(e,t,n){let a=w.createScalarValue(-1,n);return z1([],t,a,e,n)}function X8(e){let{inputs:t,backend:n}=e,{x:a}=t;ge(a,\"neg\");let r=n.data.get(a.dataId).values,[s,i]=QE(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,s)}var Y8={kernelName:Cu,backendName:\"cpu\",kernelFunc:X8},e_=Mt((e,t)=>e!==t?1:0),Z8=Zt(Eu,e_,null,\"bool\"),J8={kernelName:Eu,backendName:\"cpu\",kernelFunc:Z8};function W1(e,t,n,a,r){let s=t.length,i=w.sizeFromShape(t),o=w.computeStrides(t),l=w.computeStrides(r),u=w.getTypedArrayFromDType(n,w.sizeFromShape(r));for(let p=0;p<i;++p){let d=w.indexToLoc(p,s,o),c=new Array(d.length);for(let m=0;m<c.length;m++)c[m]=d[a[m]];let h=w.locToIndex(c,s,l);u[h]=e[p]}return u}function Vn(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;ge(r,\"transpose\");let i=r.shape.length,o=new Array(i);for(let p=0;p<o.length;p++)o[p]=r.shape[s[p]];let l=a.data.get(r.dataId).values,u=W1(l,r.shape,r.dtype,s,o);return{dataId:a.write(u,o,r.dtype),shape:o,dtype:r.dtype}}var Q8={kernelName:Cr,backendName:\"cpu\",kernelFunc:Vn};function t_(e,t,n,a){let[r,s]=T.computeOutAndReduceShapes(e,a),i=fa(t,\"int32\"),o=w.makeZerosTypedArray(w.sizeFromShape(r),i),l=w.sizeFromShape(s);for(let u=0;u<o.length;++u){let p=u*l,d=1;for(let c=0;c<l;++c)d*=n[p+c];o[u]=d}return{outVals:o,outShape:r,outDtype:i}}function eK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"prod\");let o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=T.getAxesPermutation(l,o),p=l,d=r,c=[];u!=null&&(d=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(d),p=T.getInnerMostAxes(p.length,o));let h=n.data.get(d.dataId).values,{outVals:m,outShape:f,outDtype:g}=t_(d.shape,d.dtype,h,p),b=f;return i&&(b=T.expandShapeToKeepDim(f,l)),c.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.makeTensorInfo(b,g,m)}var tK={kernelName:ko,backendName:\"cpu\",kernelFunc:eK};function nK(e,t,n){e.forEach((a,r)=>{if(a<0||a>=n){let s=w.indexToLoc(r,t.length,w.computeStrides(t)).join(\",\");throw new Error(`indices[${s}] = ${a} is not in [0, ${n})`)}})}function aK(e,t){for(let n=0;n<e.length;++n){let a=e[n],r=n===e.length-1?t:e[n+1].length;if(a.length===0)throw new Error(\"Ragged splits may not be empty\");if(a[0]<0)throw new Error(\"Ragged splits must be non-negative\");if(a[a.length-1]>r)throw new Error(\"Ragged splits must not point past values\");for(let s=1;s<a.length;++s)if(a[s-1]>a[s])throw new Error(\"Ragged splits must be sorted in ascending order\")}}function rK(e,t,n,a){let r=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);aK(n,a);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let p=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*p)}for(let u=0;u<e.length;++u){let p=e[u],d=e[u]+1;for(let c=0;c<n.length;++c){let h=n[c],m=c+t.length-1;if(m>=0){let f=o[m],g=f[f.length-1]-h[p];for(let b=p;b<d;++b)o[m].push(h[b+1]+g)}p=h[p],d=h[d]}d!==p&&(r.push([p,d]),s+=d-p)}return{outSplits:o,valueSlices:r,numValues:s}}function sK(e){let t=[];for(let n=0;n<e.length;++n){let a=e[n].length,r=w.getArrayFromDType(\"int32\",a);t.push(r),e[n].forEach((s,i)=>r[i]=s)}return t}function YI(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function iK(e,t,n,a,r,s){let i=YI(t,2)[1],o=YI(s,2)[1],l=0;for(let u of n)for(let p=u[0];p<u[1];++p){for(let d=0;d<a;++d)r[l*o+d]=e[p*i+d];++l}}function oK(e,t,n,a,r){let s=t.slice();s[0]=r;let i=w.getArrayFromDType(n,w.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return iK(e,t,a,l,i,s),[i,s]}function n_(e,t,n,a,r,s,i,o){if(e.length===0)throw new Error(\"paramsNestedSplits must be non empty\");if(t[0].length===0)throw new Error(\"Split tensors must not be scalars\");let l=t[0][0]-1;if(nK(s,i,l),a.length===0)throw new Error(\"params.rank must be nonzero\");let u=a[0],{outSplits:p,valueSlices:d,numValues:c}=rK(s,i,e,u),h=sK(p),m=oK(n,a,r,d,c);return[h,m[0],m[1]]}var ZI=2147483647;function a_(e,t,n,a,r,s,i){if(t.length>1)throw new Error(\"starts must be a scalar or vector\");if(r.length>1)throw new Error(\"limits must be a scalar or vector\");if(i.length>1)throw new Error(\"deltas must be a scalar or vector\");let o=t.length===0,l=r.length===0,u=i.length===0,p=[];o||p.push(t[0]),l||p.push(r[0]),u||p.push(i[0]);for(let g=1;g<p.length;++g)if(p[g]!==p[g-1])throw new Error(\"starts, limits, and deltas must have the same shape\");let d=p.length===0?1:p[0],c=w.getArrayFromDType(\"int32\",d+1);c[0]=0;for(let g=0;g<d;++g){let b=o?e[0]:e[g],y=l?a[0]:a[g],x=u?s[0]:s[g];if(x===0)throw new Error(\"Requires delta != 0\");let v;if(x>0&&y<b||x<0&&y>b)v=0;else if(v=Math.ceil(Math.abs((y-b)/x)),v>ZI)throw new Error(`Requires ((limit - start) / delta) <= ${ZI}`);c[g+1]=c[g]+v}let h=c[d],m=w.getArrayFromDType(n,h),f=0;for(let g=0;g<d;++g){let b=c[g+1]-c[g],y=o?e[0]:e[g],x=u?s[0]:s[g];for(let v=0;v<b;++v)m[f++]=y,y+=x}return[c,m]}var Na=T.RowPartitionType,lK=class ov{constructor(t,n,a,r,s,i,o,l,u,p){this.shape=t,this.shapeShape=n,this.values=a,this.valuesShape=r,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=T.getRowPartitionTypesHelper(p),this.raggedRank=T.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Na.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Na.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Na.VALUE_ROWIDS:return ov.getMaxWidthValueRowID(n);case Na.ROW_SPLITS:return ov.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Na[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let a=0;for(let r=0;r<n-1;++r){let s=t[r+1]-t[r];s>a&&(a=s)}return a}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let a=0,r=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==r&&(r=o,s=Math.max(i-a,s),a=i)}return Math.max(n-a,s)}tensorShapeFromTensor(t,n,a=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error(\"The only valid scalar shape tensor is the fully unknown shape specified as -1.\")}return QI(t,a)}calculateOutputSize(t){let n=this.valuesShape,a=this.defaultValueShape;T.validateDefaultValueShape(a,n);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=T.combineRaggedTensorToTensorShapes(this.raggedRank,r,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,a){let r=Math.min(t,a),s=[],i=0;for(let o=0;o<r;++o,i+=n)s.push(i);for(let o=r;o<t;++o)s.push(-1);return w.assert(s.length===t,()=>\"Final length of result must be equal to firstDimension.\"),s}calculateOutputIndexRowSplit(t,n,a,r){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],u=Math.min(r,l),p=n[o];p===-1&&(u=0);for(let d=0;d<u;++d)i.push(p),p+=a;for(let d=0;d<l-u;++d)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error(\"Invalid row split size.\");return i}calculateOutputIndexValueRowID(t,n,a,r){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let p=1;p<s;++p){let d=t[p];if(d===l)u>=0&&(++o,o<r?u+=a:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}i.push(u)}if(i.length!==t.length)throw new Error(\"Invalid row ids.\");return i}calculateOutputIndex(t,n,a,r){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Na.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,a,r);case Na.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,a,r);default:throw new Error(`Unsupported partition type: ${Na[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error(\"No row_partition_types given.\");let n=this.rowPartitionTypes[0];switch(n){case Na.FIRST_DIM_SIZE:return t[0];case Na.VALUE_ROWIDS:throw new Error(\"Cannot handle VALUE_ROWIDS in first dimension.\");case Na.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Na[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error(\"Invalid first partition input. Tensor requires at least one element.\");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),a=new Array(this.raggedRank+1);a[a.length-1]=1;for(let i=a.length-2;i>=0;--i)a[i]=a[i+1]*n[i+1];let r=QI(n,!1),s=w.getArrayFromDType(this.valuesDType,w.sizeFromShape(r));if(a[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,a[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,a[o],n[o]);this.setOutput(this.raggedRank,i,s,r)}return[r,s]}setOutput(t,n,a,r){if(a.length===0)return;let s=this.values,i=a,o=r.slice();o=o.slice(t+1);let l=w.sizeFromShape(o),u=n.length,p=this.defaultValue;if(p.length!==l&&p.length!==1){let m=this.defaultValueShape;O(()=>{let f=W(p,m);p=ai(f,o).dataSync()})}let d=0,c=0,h=0;for(let m=0;m<=u;++m){let f=m<u?n[m]:-1;if(f===h){++h;continue}if(c<h){let g=s.subarray(d*l),b=i.subarray(c*l),y=(h-c)*l;JI(b,g,y)}if(m>=u){let g=a.length;f=Math.floor(g/l)}if(f>h)if(this.defaultValue.length===1)i.subarray(h*l,f*l).fill(this.defaultValue[0]),h=f;else for(;f>h;){let g=i.slice(h*l);JI(g,p,l),++h}f<0?(d=m+1,c=h):(d=m,c=h,h=c+1)}}};function JI(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function QI(e,t){let n=[];for(let a of e){if(a<0){if(!t)throw new Error(`Dimension ${a} must be >= 0`);if(a<-1)throw new Error(`Dimension ${a} must be >= -1`);a=-1}n.push(a)}return n}function r_(e,t,n,a,r,s,i,o,l,u){return new lK(e,t,n,a,r,s,i,o,l,u).compute()}function B1(e,t,n,a){let r=e===t,s=e<t&&n<0,i=t<e&&n>1;if(r||s||i)return w.makeZerosTypedArray(0,a);let o=Math.abs(Math.ceil((t-e)/n)),l=w.makeZerosTypedArray(o,a);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var s_=fr(e=>1/Math.sqrt(e)),uK=Fs(Ao,s_),pK={kernelName:Ao,backendName:\"cpu\",kernelFunc:uK};function ni(e,t,n,a,r,s,i,o,l,u){let p=[a/r,r],d=e.values,c=t.values;if(a===0)return Oe(n,t.dtype);let h=l instanceof Wt?l:Oe(p,t.dtype);typeof l==\"string\"||typeof l==\"number\"?h.values.fill(l):typeof l==\"boolean\"&&h.values.fill(+l);for(let m=0;m<s;m++){let f=[],g=0;for(let b=0;b<i;b++){let y=d[m*i+b];f.push(y),g+=y*o[b]}if(g<0||g>=a/r)throw new Error(`Invalid indices: ${f} does not index into ${n}`);for(let b=0;b<r;b++)u?h.values[g*r+b]+=c[m*r+b]:h.values[g*r+b]=t.rank===0?c[0]:c[m*r+b]}return h}var cK=fr(e=>1/(1+Math.exp(-e))),i_=lt(Mo,e=>1/(1+Math.exp(-e))),dK={kernelName:Mo,backendName:\"cpu\",kernelFunc:i_};function um(e,t,n,a,r){let s=Kt.isSliceContinous(a,t,n),i=w.sizeFromShape(n),o=w.computeStrides(a);if(s){let d=Kt.computeFlatOffset(t,o);return r===\"string\"?e.slice(d,d+i):e.subarray(d,d+i)}let l=r===\"string\"?T.fromUint8ToStringArray(e):e,u=Oe(a,r,l),p=Oe(n,r);for(let d=0;d<p.size;++d){let c=p.indexToLoc(d),h=c.map((m,f)=>m+t[f]);p.set(u.get(...h),...c)}return r===\"string\"?T.fromStringArrayToUint8(p.values):p.values}function xi(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a;ge(r,\"slice\");let[o,l]=Kt.parseSliceParams(r,s,i);Kt.assertParamsValid(r,o,l);let u=n.data.get(r.dataId).values,p=um(u,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,p)}var hK={kernelName:Bu,backendName:\"cpu\",kernelFunc:xi};function o_(e,t,n,a,r,s,i){let o=t[0],l=s[0],u=new Array(l),p=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=w.getArrayFromDType(n,0),b=w.getArrayFromDType(r,0);return[g,[0,d],b,u,p]}let c=!0,h=0,m=new Array(l).fill(0);for(let g=0;g<o;++g){let b=e[g*d];if(b<0)throw new Error(T.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,b));if(b>=l)throw new Error(T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,b,l));++m[b],c=c&&b>=h,h=b}let f=!0;for(let g=0;g<l;++g){let b=m[g]===0;u[g]=b,f=f&&!b,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(f&&c){let g=e,b=a;for(let y=0;y<o;++y)p[y]=y;return[g,[o,d],b,u,p]}else{let g=m[l-1],b=w.getArrayFromDType(n,g*d),y=w.getArrayFromDType(r,g),x=new Array(l).fill(0);for(let v=0;v<o;++v){let I=e[v*d],N=x[I],C=(I===0?0:m[I-1])+N;x[I]++;for(let _=0;_<d;++_)b[C*d+_]=e[v*d+_];y[C]=a[v],p[v]=C}for(let v=0;v<l;++v)if(x[v]===0){let I=v===0?0:m[v-1];b[I*d+0]=v;for(let N=1;N<d;++N)b[I*d+N]=0;y[I]=i}return[b,[g,d],y,u,p]}}function l_(e,t,n,a,r){let s=w.sizeFromShape(a),i=t[0],o=r.length,l=[],u=1,p=-1;for(let f=0;f<o;++f){let g=r[f];if(g===-1){if(p!==-1)throw new Error(T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,f));p=f,l.push(1)}else{if(g<0)throw new Error(T.getSparseReshapeNegativeOutputDimErrorMessage(f,g));u*=g,l.push(g)}}if(p!==-1){if(u<=0)throw new Error(T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let f=Math.trunc(s/u);if(u*f!==s)throw new Error(T.getSparseReshapeInputOutputMultipleErrorMessage(a,l));l[p]=f}if(w.sizeFromShape(l)!==s)throw new Error(T.getSparseReshapeInputOutputMismatchErrorMessage(a,l));let d=a.length,c=[];if(d>0){c[d-1]=1;for(let f=d-2;f>=0;--f)c[f]=c[f+1]*a[f+1]}let h=[];if(o>0){h[o-1]=1;for(let f=o-2;f>=0;--f)h[f]=h[f+1]*l[f+1]}let m=w.getArrayFromDType(n,i*o);for(let f=0;f<i;++f){let g=0;for(let b=0;b<d;++b)g+=e[f*d+b]*c[b];for(let b=0;b<o;++b)m[f*o+b]=Math.trunc(g/h[b]),g%=h[b]}return[m,[i,o],l]}function V1(e,t,n,a,r,s=!1,i=0){let o=a.length,l=[t[0],e.length/t[0]],u=l[1],p=o>0?r[o-1]+1:0;if(p<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=p;let c=d.reduce((y,x)=>y*x,1),h=w.getArrayFromDType(n,c);if(o===0)return p>0&&h.fill(i),[h,d];if(p<=0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,f=1,g=0,b=r[m];for(;;){let y=0;if(f<o){if(y=r[f],b===y){++f;continue}if(b>=y)throw new Error(T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>g&&h.fill(i,g*u,b*u);for(let x=m;x<f;++x){let v=a[x];if(v<0||v>=l[0])throw new Error(T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,a[x],l[0]));for(let I=0;I<u;I++)h[b*u+I]+=e[v*u+I]}if(s)for(let x=0;x<u;x++)h[b*u+x]/=f-m;if(m=f,++f,g=b+1,b=y,f>o)break}return g<p&&h.fill(i,g*u,p*u),[h,d]}var mK=fr(e=>Math.sqrt(e)),fK=lt(Po,e=>Math.sqrt(e)),gK={kernelName:Po,backendName:\"cpu\",kernelFunc:fK},u_=Mt((e,t)=>{let n=e-t;return n*n}),bK=Zt(Wo,u_),yK={kernelName:Wo,backendName:\"cpu\",kernelFunc:bK},p_=fr((e,t)=>{let{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?\"g\":\"\"),r)}),xK=Fs(Kc,p_),vK={kernelName:Kc,backendName:\"cpu\",kernelFunc:xK};function c_(e,t,n,a){let r=Oe(e,t.dtype);for(let s=0;s<r.size;s++){let i=r.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+a[l];r.set(t.get(...o),...i)}return r}var wK=class{constructor(e,t,n,a,r,s){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let i=0;i<r;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(r-(i+1))),p=s-(l+u),d=t+(l>0?0:i-o),c=0;c+=l*this.leftPad.length;for(let b=0;b<p;++b)c+=e[d+b].length;c+=u*this.rightPad.length;let h=l+u+p-1;c+=h*this.separator.length,n[a+i]=new Uint8Array(c);let m=n[a+i],f=0,g=b=>b.forEach(y=>m[f++]=y);for(let b=0;b<l;++b)g(this.leftPad),g(this.separator);for(let b=0;b<p-1;++b)g(e[d+b]),g(this.separator);if(p>0){g(e[d+p-1]);for(let b=0;b<u;++b)g(this.separator),g(this.rightPad)}else{for(let b=0;b<u-1;++b)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,a=t.length;if(a>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<a;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let r=a-1,s=w.getArrayFromDType(\"int32\",a);if(n===0||a===0){let o=new Array(n);for(let l=0;l<=r;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=r;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(p=>{u+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&u===0&&(u=1),s[o]=s[o-1]+u}let i=new Array(s[r]);for(let o=0;o<r;++o){let l=t[o],u=s[o];if(this.nGramWidths.forEach(p=>{let d=t[o+1]-t[o],c=this.getNumNGrams(d,p);this.createNGrams(e,l,i,u,c,p),u+=c}),this.preserveShort&&u===s[o]){let p=t[o+1]-t[o];if(p===0)continue;let d=p+2*this.padWidth;this.createNGrams(e,l,i,u,1,d)}}return[i,s]}};function U1(e,t,n,a,r,s,i,o){return new wK(n,a,r,s,i,o).compute(e,t)}function kK(e,t,n,a){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)a.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&a.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&a.push(e);return}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(r,s);(!n||i.length!==0)&&a.push(i),r=s+1}}function G1(e,t,n){let a=e.length,r=[],s=0,i=0,o=new Array(a);for(let c=0;c<a;++c){let h=r.length;kK(e[c],t,n,r);let m=r.length-h;o[c]=m,s+=m,i=Math.max(i,m)}let l=w.getArrayFromDType(\"int32\",s*2),u=new Array(s),p=[a,i],d=0;for(let c=0;c<a;++c)for(let h=0;h<o[c];++h)l[d*2]=c,l[d*2+1]=h,u[d]=r[d],++d;return[l,u,p]}function H1(e,t){let n=w.getArrayFromDType(\"int32\",e.length);for(let a=0;a<e.length;++a)n[a]=w.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return n}var d_=Mt((e,t)=>e-t),IK=O1((e,t,n,a)=>({real:e-n,imag:t-a})),j1=Zt(Bo,d_,IK),SK={kernelName:Bo,backendName:\"cpu\",kernelFunc:j1};function h_(e,t){let n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let a=Oe(n,e.dtype);for(let r=0;r<a.values.length;++r){let s=a.indexToLoc(r),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);a.values[r]=e.values[o]}return a}var nc=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function m_(e,t,n=0,a=e.length-1){for(;a>n;){if(a-n>600){let o=a-n+1,l=t-n+1,u=Math.log(o),p=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*p*(o-p)/o)*Math.sign(l-o/2),c=Math.max(n,Math.floor(t-l*p/o+d)),h=Math.min(a,Math.floor(t+(o-l)*p/o+d));m_(e,t,c,h)}let r=e[t],s=n,i=a;for(w.swap(e,n,t),nc(e[a],r)>0&&w.swap(e,n,a);s<i;){for(w.swap(e,s,i),s++,i--;nc(e[s],r)<0;)s=s+1;for(;nc(e[i],r)>0;)i=i-1}nc(e[n],r)===0?w.swap(e,n,i):(i=i+1,w.swap(e,i,a)),i<=t&&(n=i+1),t<=i&&(a=i-1)}}function f_(e,t,n,a,r){let s=t[t.length-1],[i,o]=[e.length/s,s],l=w.getTypedArrayFromDType(n,i*a),u=w.getTypedArrayFromDType(\"int32\",i*a);for(let d=0;d<i;d++){let c=d*o,h=e.subarray(c,c+o),m=new Array(h.length);h.forEach((y,x)=>m[x]={value:y,index:x}),a<m.length&&(m_(m,a),m=m.slice(0,a)),r&&m.sort(nc);let f=d*a,g=l.subarray(f,f+a),b=u.subarray(f,f+a);for(let y=0;y<a;y++)g[y]=m[y].value,b[y]=m[y].index}let p=t.slice();return p[p.length-1]=a,[Oe(p,n,l),Oe(p,\"int32\",u)]}function q1(e,t,n,a){let r=w.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let m=0;m<r;m++)s[0]*=n[m];s[1]=n[r];for(let m=r+1;m<n.length;m++)s[2]*=n[m];let i=new Map,o=new Int32Array(n[r]),l=new Wt(s,a,e),u=[],p=s[0]===1&&s[2]===1;for(let m=0;m<n[r];m++){let f;if(p)f=e[m].toString();else{let b=[];for(let y=0;y<s[0];y++)for(let x=0;x<s[2];x++)b.push(l.get(y,m,x));f=b.join(\",\")}let g=i.get(f);if(g!=null)o[m]=g;else{let b=i.size;i.set(f,b),o[m]=b,u.push(m)}}let d=s.slice();d[1]=i.size;let c=new Wt(d,a);u.forEach((m,f)=>{for(let g=0;g<s[0];g++)for(let b=0;b<s[2];b++)c.set(l.get(g,m,b),g,f,b)});let h=n.slice();return h[r]=d[1],{outputValues:c.values,outputShape:h,indices:o}}var NK=\"4.22.0\";Om(\"cpu\",()=>new R1,1);var g_=lt(ji,e=>e>=0?e:Math.exp(e)-1),TK={kernelName:ji,backendName:\"cpu\",kernelFunc:g_};function b_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;ge([r],\"leakyRelu\");let i=w.sizeFromShape(r.shape),o=n.data.get(r.dataId).values,l=w.getTypedArrayFromDType(\"float32\",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(r.shape,\"float32\",l)}var CK={kernelName:ro,backendName:\"cpu\",kernelFunc:b_},EK=Mt((e,t)=>e<0?t*e:e);function y_(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t;ge([a,r],\"prelu\");let s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,[o,l]=EK(a.shape,r.shape,s,i,\"float32\");return n.makeTensorInfo(l,\"float32\",o)}var _K={kernelName:wo,backendName:\"cpu\",kernelFunc:y_},x_=lt(So,e=>Math.max(0,e)),AK={kernelName:So,backendName:\"cpu\",kernelFunc:x_},v_=lt(Co,e=>Math.min(Math.max(0,e),6)),FK={kernelName:Co,backendName:\"cpu\",kernelFunc:v_};function pm(e,t,n,a,r){if(n===\"linear\")return cr({inputs:{x:t},backend:e});if(n===\"relu\")return x_({inputs:{x:t},backend:e});if(n===\"elu\")return g_({inputs:{x:t},backend:e});if(n===\"relu6\")return v_({inputs:{x:t},backend:e});if(n===\"prelu\")return y_({inputs:{x:t,alpha:a},backend:e});if(n===\"leakyrelu\")return b_({inputs:{x:t},backend:e,attrs:{alpha:r}});if(n===\"sigmoid\")return i_({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function xt(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=w.sizeFromShape(r.shape),o=w.inferFromImplicitShape(s,i),l=w.sizeFromShape(o);w.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);let u=n.data.get(r.dataId);if(u.complexTensorInfos!=null){let p=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;p.shape=o,d.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var $K={kernelName:Ru,backendName:\"cpu\",kernelFunc:xt};function w_(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;ge([r,s],\"matMul\");let l=r.shape.length,u=s.shape.length,p=i?r.shape[l-2]:r.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],c=i?r.shape[l-1]:r.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],m=r.shape.slice(0,-2),f=s.shape.slice(0,-2),g=w.sizeFromShape(m),b=w.sizeFromShape(f),y=Ju.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,h]);w.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,p,c]:[g,c,p],v=o?[b,h,d]:[b,d,h],I=xt({inputs:{x:r},backend:n,attrs:{shape:x}}),N=xt({inputs:{x:s},backend:n,attrs:{shape:v}}),C=i?I.shape[1]:I.shape[2],_=i?I.shape[2]:I.shape[1],F=o?N.shape[1]:N.shape[2],D=Math.max(g,b),$=n.data.get(I.dataId).values,S=n.data.get(N.dataId).values,M=w.computeStrides(I.shape),B=w.computeStrides(N.shape),[U,H,q]=i?[M[0],1,M[1]]:[M[0],M[1],1],[K,Z,J]=o?[1,B[1],B[0]]:[B[1],1,B[0]],ee=_*F,ae=Oe([D,_,F],I.dtype),te=ae.values,se=n.blockSize;for(let ie=0;ie<D;ie++){let ve=ie%g,ue=ie%b;for(let ye=0;ye<_;ye+=se){let ke=Math.min(ye+se,_);for(let Se=0;Se<F;Se+=se){let Le=Math.min(Se+se,F);for(let Ue=0;Ue<C;Ue+=se){let mt=Math.min(Ue+se,C);for(let st=ye;st<ke;st++)for(let tt=Se;tt<Le;tt++){let nt=0;for(let Re=Ue;Re<mt;Re++){let gt=$[ve*U+st*H+Re*q],Gn=S[Re*K+tt*Z+ue*J];nt+=gt*Gn}te[ie*ee+(st*F+tt)]+=nt}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(N),n.makeTensorInfo(y,ae.dtype,ae.values)}var DK={kernelName:Ri,backendName:\"cpu\",kernelFunc:w_};function RK(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=a,c,h,m,f=[];c=w_({inputs:{a:r,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(h=jl({inputs:{a:c,b:i},backend:n}),f.push(c),c=h),p&&(m=pm(n,c,p,o,d),f.push(c),c=m);for(let g of f)n.disposeIntermediateTensorInfo(g);return c}var MK={kernelName:ii,backendName:\"cpu\",kernelFunc:RK},OK=lt(Ni,e=>Math.acos(e)),PK={kernelName:Ni,backendName:\"cpu\",kernelFunc:OK},LK=lt(Ti,e=>Math.acosh(e)),zK={kernelName:Ti,backendName:\"cpu\",kernelFunc:LK};function WK(e){let{inputs:t,backend:n}=e,a=t;ge(t,\"addN\");let r=a.map(o=>n.data.get(o.dataId).values),s=Oe(a[0].shape,a[0].dtype),i=s.values;for(let o=0;o<a.length;o++){let l=r[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var BK={kernelName:Ci,backendName:\"cpu\",kernelFunc:WK};function VK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"all\");let o=w.parseAxisParam(s,r.shape),l=o,u=T.getAxesPermutation(l,r.shape.length),p=r;u!=null&&(p=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"all\",l,p.shape.length);let[d,c]=T.computeOutAndReduceShapes(p.shape,l),h=w.sizeFromShape(c),m=w.makeZerosTypedArray(w.sizeFromShape(d),p.dtype),f=n.data.get(p.dataId).values;for(let b=0;b<m.length;++b){let y=b*h,x=f[y];for(let v=0;v<h;++v){let I=f[y+v];x=x&&I}m[b]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,m);if(i){let b=T.expandShapeToKeepDim(d,o),y=xt({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var UK={kernelName:Zl,backendName:\"cpu\",kernelFunc:VK};function GK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"any\");let o=w.parseAxisParam(s,r.shape),l=o,u=T.getAxesPermutation(l,r.shape.length),p=r;u!=null&&(p=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"any\",l,p.shape.length);let[d,c]=T.computeOutAndReduceShapes(p.shape,l),h=w.sizeFromShape(c),m=w.makeZerosTypedArray(w.sizeFromShape(d),p.dtype),f=n.data.get(p.dataId).values;for(let b=0;b<m.length;++b){let y=b*h,x=f[y];for(let v=0;v<h;++v){let I=f[y+v];x=x||I}m[b]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,m);if(i){let b=T.expandShapeToKeepDim(d,o),y=xt({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var HK={kernelName:Jl,backendName:\"cpu\",kernelFunc:GK};function jK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;ge(r,\"argMax\");let i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Vn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims(\"argMax\",i,l.shape.length);let[p,d]=T.computeOutAndReduceShapes(l.shape,i),c=w.sizeFromShape(p),h=w.makeZerosTypedArray(c,\"int32\"),m=w.sizeFromShape(d),f=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let b=g*m,y=f[b],x=0;for(let v=0;v<m;++v){let I=f[b+v];I>y&&(y=I,x=v)}h[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(p,\"int32\",h)}var qK={kernelName:Ql,backendName:\"cpu\",kernelFunc:jK};function KK(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;ge(r,\"argMin\");let i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Vn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],T.assertAxesAreInnerMostDims(\"argMin\",i,l.shape.length);let[p,d]=T.computeOutAndReduceShapes(l.shape,i),c=w.sizeFromShape(p),h=w.makeZerosTypedArray(c,\"int32\"),m=w.sizeFromShape(d),f=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let b=g*m,y=f[b],x=0;for(let v=0;v<m;++v){let I=f[b+v];I<y&&(y=I,x=v)}h[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(p,\"int32\",h)}var XK={kernelName:eu,backendName:\"cpu\",kernelFunc:KK},YK=lt(Ei,e=>Math.asin(e)),ZK={kernelName:Ei,backendName:\"cpu\",kernelFunc:YK},JK=lt(_i,e=>Math.asinh(e)),QK={kernelName:_i,backendName:\"cpu\",kernelFunc:JK},eX=lt(Ai,e=>Math.atan(e)),tX={kernelName:Ai,backendName:\"cpu\",kernelFunc:eX},nX=Mt((e,t)=>Math.atan2(e,t)),aX=Zt($i,nX),rX={kernelName:$i,backendName:\"cpu\",kernelFunc:aX},sX=lt(Fi,e=>Math.atanh(e)),iX={kernelName:Fi,backendName:\"cpu\",kernelFunc:sX};function K1(e,t,n,a,r,s){let i=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,c=r.padInfo.top,h=r.padInfo.left,m=s===\"max\"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,f=Oe(r.outShape,n),g=f.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],y=r.outShape[2]*r.outShape[3],x=r.outShape[3];for(let v=0;v<r.batchSize;++v){let I=v*b,N=v*a[0];for(let C=0;C<r.inChannels;++C)for(let _=0;_<r.outHeight;++_){let F=_*i-c,D=Math.max(0,F),$=Math.min(r.inHeight,p+F),S=I+_*y;for(let M=0;M<r.outWidth;++M){let B=M*o-h,U=Math.max(0,B),H=Math.min(r.inWidth,d+B),q=m,K=0,Z=0;for(let ee=D;ee<$;ee+=l){let ae=N+ee*a[1];for(let te=U;te<H;te+=u){let se=ae+te*a[2],ie=e[se+C];s===\"max\"&&ie>q?q=ie:s===\"avg\"&&(K+=ie,Z++)}if(isNaN(q))break}let J=S+M*x+C;g[J]=s===\"avg\"?K/Z:q}}}return f}function k_(e,t,n,a,r=!1,s=!1){let i=Oe(a.outShape,\"int32\"),o=a.strideHeight,l=a.strideWidth,u=a.dilationHeight,p=a.dilationWidth,d=a.effectiveFilterHeight,c=a.effectiveFilterWidth,h=a.padInfo.top,m=a.padInfo.left,f=Oe(t,n,e);for(let g=0;g<a.batchSize;++g)for(let b=0;b<a.inChannels;++b)for(let y=0;y<a.outHeight;++y){let x=y*o-h,v=x;for(;v<0;)v+=u;let I=Math.min(a.inHeight,d+x);for(let N=0;N<a.outWidth;++N){let C=N*l-m,_=C;for(;_<0;)_+=p;let F=Math.min(a.inWidth,c+C),D=Number.NEGATIVE_INFINITY,$=-1;for(let S=v;S<I;S+=u){let M=S-x;for(let B=_;B<F;B+=p){let U=B-C,H=f.get(g,S,B,b);H>D&&(D=H,r?$=s?((g*a.inHeight+S)*a.inWidth+B)*a.inChannels+b:(S*a.inWidth+B)*a.inChannels+b:$=M*c+U)}}i.set($,g,y,N,b)}}return i}function I_(e,t,n,a,r,s){let i=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,p=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterDepth,h=r.effectiveFilterHeight,m=r.effectiveFilterWidth,f=r.padInfo.front,g=r.padInfo.top,b=r.padInfo.left,y=s===\"max\"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Oe(r.outShape,n),v=x.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[2]*r.outShape[3]*r.outShape[4],C=r.outShape[3]*r.outShape[4],_=r.outShape[4];for(let F=0;F<r.batchSize;++F){let D=F*I,$=F*a[0];for(let S=0;S<r.inChannels;++S)for(let M=0;M<r.outDepth;++M){let B=M*i-f,U=B;for(;U<0;)U+=u;let H=Math.min(r.inDepth,c+B),q=D+M*N;for(let K=0;K<r.outHeight;++K){let Z=K*o-g,J=Z;for(;J<0;)J+=p;let ee=Math.min(r.inHeight,h+Z),ae=q+K*C;for(let te=0;te<r.outWidth;++te){let se=te*l-b,ie=se;for(;ie<0;)ie+=d;let ve=Math.min(r.inWidth,m+se),ue=ae+te*_,ye=y,ke=0,Se=0;for(let Ue=U;Ue<H;Ue+=u){let mt=$+Ue*a[1];for(let st=J;st<ee;st+=p){let tt=mt+st*a[2];for(let nt=ie;nt<ve;nt+=d){let Re=tt+nt*a[3],gt=e[Re+S];if(s===\"max\"&&gt>ye?ye=gt:s===\"avg\"&&(ke+=gt,Se++),isNaN(ye))break}if(isNaN(ye))break}if(isNaN(ye))break}let Le=ue+S;v[Le]=s===\"avg\"?ke/Math.max(Se,1):ye}}}}return x}function oX(e,t){let n=Oe(t.outShape,\"int32\"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,d=t.effectiveFilterWidth,c=t.padInfo.front,h=t.padInfo.top,m=t.padInfo.left;for(let f=0;f<t.batchSize;++f)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){let y=b*a-c,x=y;for(;x<0;)x+=i;let v=Math.min(t.inDepth,u+y);for(let I=0;I<t.outHeight;++I){let N=I*r-h,C=N;for(;C<0;)C+=o;let _=Math.min(t.inHeight,p+N);for(let F=0;F<t.outWidth;++F){let D=F*s-m,$=D;for(;$<0;)$+=l;let S=Math.min(t.inWidth,d+D),M=Number.NEGATIVE_INFINITY,B=-1;for(let U=x;U<v;U+=i){let H=U-y;for(let q=C;q<_;q+=o){let K=q-N;for(let Z=$;Z<S;Z+=l){let J=Z-D,ee=e.get(f,U,q,Z,g);ee>=M&&(M=ee,B=H*p*d+K*p+J)}}}n.set(B,f,b,I,F,g)}}}return n}function lX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ge(r,\"avgPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l),d;if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))d=cr({inputs:{x:r},backend:n});else{let c=n.data.get(r.dataId).values,h=w.computeStrides(r.shape),m=K1(c,r.shape,r.dtype,h,p,\"avg\");d=n.makeTensorInfo(p.outShape,r.dtype,m.values)}return d}var uX={kernelName:Di,backendName:\"cpu\",kernelFunc:lX};function pX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;ge(r,\"avgPool3d\");let p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.data.get(r.dataId).values,c=I_(d,r.shape,r.dtype,w.computeStrides(r.shape),p,\"avg\");return n.makeTensorInfo(c.shape,\"float32\",c.values)}var cX={kernelName:tu,backendName:\"cpu\",kernelFunc:pX};function dX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;ge([r,s],\"avgPool3DGrad\");let p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=p.strideDepth,c=p.strideHeight,h=p.strideWidth,m=p.filterDepth,f=p.filterHeight,g=p.filterWidth,b=p.dilationDepth,y=p.dilationHeight,x=p.dilationWidth,v=p.effectiveFilterDepth,I=p.effectiveFilterHeight,N=p.effectiveFilterWidth,C=v-1-p.padInfo.front,_=N-1-p.padInfo.left,F=I-1-p.padInfo.top,D=Oe(s.shape,\"float32\"),$=1/(m*f*g),S=n.bufferSync(r);for(let M=0;M<p.batchSize;++M)for(let B=0;B<p.inChannels;++B)for(let U=0;U<p.inDepth;++U)for(let H=0;H<p.inHeight;++H)for(let q=0;q<p.inWidth;++q){let K=U-C,Z=H-F,J=q-_,ee=0;for(let ae=0;ae<v;ae+=b){let te=(K+ae)/d;if(!(te<0||te>=p.outDepth||Math.floor(te)!==te))for(let se=0;se<I;se+=y){let ie=(Z+se)/c;if(!(ie<0||ie>=p.outHeight||Math.floor(ie)!==ie))for(let ve=0;ve<N;ve+=x){let ue=(J+ve)/h;if(ue<0||ue>=p.outWidth||Math.floor(ue)!==ue)continue;let ye=S.get(M,te,ie,ue,B);ee+=ye}}}D.set(ee*$,M,U,H,q,B)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}var hX={kernelName:Rc,backendName:\"cpu\",kernelFunc:dX};function mX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;ge([r,s],\"avgPoolGrad\");let{filterSize:o,strides:l,pad:u}=a,p=T.computePool2DInfo(i.shape,o,l,1,u),d=p.strideHeight,c=p.strideWidth,h=p.filterHeight,m=p.filterWidth,f=p.dilationHeight,g=p.dilationWidth,b=p.effectiveFilterHeight,y=p.effectiveFilterWidth,x=y-1-p.padInfo.left,v=b-1-p.padInfo.top,I=Oe(i.shape,\"float32\"),N=1/(h*m),C=n.data.get(r.dataId).values,_=Oe(r.shape,\"float32\",C);for(let F=0;F<p.batchSize;++F)for(let D=0;D<p.inChannels;++D)for(let $=0;$<p.inHeight;++$)for(let S=0;S<p.inWidth;++S){let M=$-v,B=S-x,U=0;for(let H=0;H<b;H+=f){let q=(M+H)/d;if(!(q<0||q>=p.outHeight||Math.floor(q)!==q))for(let K=0;K<y;K+=g){let Z=(B+K)/c;if(Z<0||Z>=p.outWidth||Math.floor(Z)!==Z)continue;let J=_.get(F,q,Z,D);U+=J}}I.set(U*N,F,$,S,D)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var fX={kernelName:Dc,backendName:\"cpu\",kernelFunc:mX};function gX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:i,mean:o,variance:l}=t;w.assert(o.shape.length===l.shape.length,()=>\"Batch normalization gradient requires mean and variance to have equal ranks.\"),w.assert(i==null||o.shape.length===i.shape.length,()=>\"Batch normalization gradient requires mean and offset to have equal ranks.\"),w.assert(s==null||o.shape.length===s.shape.length,()=>\"Batch normalization gradient requires mean and scale to have equal ranks.\"),ge([r,o,l,s,i],\"batchNorm\");let{varianceEpsilon:u}=a;u==null&&(u=.001);let p=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values,c=n.data.get(l.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),m=i?n.data.get(i.dataId).values:new Float32Array([0]),f=new Float32Array(p.length),g=m.length,b=h.length,y=c.length,x=d.length,v=0,I=0,N=0,C=0;for(let _=0;_<p.length;++_)f[_]=m[v++]+(p[_]-d[I++])*h[N++]/Math.sqrt(c[C++]+u),v>=g&&(v=0),I>=x&&(I=0),N>=b&&(N=0),C>=y&&(C=0);return n.makeTensorInfo(r.shape,r.dtype,f)}var bX={kernelName:Ji,backendName:\"cpu\",kernelFunc:gX};function yX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;ge([r],\"batchToSpaceND\");let o=s.reduce((b,y)=>b*y),l=T.getReshaped(r.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(r.shape,s,o),d=T.getSliceBeginCoords(i,s.length),c=T.getSliceSize(p,i,s.length),h=xt({inputs:{x:r},backend:n,attrs:{shape:l}}),m=Vn({inputs:{x:h},backend:n,attrs:{perm:u}}),f=xt({inputs:{x:m},backend:n,attrs:{shape:p}}),g=xi({inputs:{x:f},backend:n,attrs:{begin:d,size:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var xX={kernelName:nu,backendName:\"cpu\",kernelFunc:yX};function vX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=P1(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var wX={kernelName:au,backendName:\"cpu\",kernelFunc:vX};function kX(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],\"int32\",Int32Array.from(o))}var IX={kernelName:Mc,backendName:\"cpu\",kernelFunc:kX},SX=lt(ws,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),NX={kernelName:ws,backendName:\"cpu\",kernelFunc:SX},TX=e=>{let{x:t}=e.inputs,n=e.backend,a=new Float32Array(w.sizeFromShape(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let p=o[u],d=l[u];a[u]=Math.hypot(p,d)}return n.makeOutput(a,t.shape,\"float32\")},CX={kernelName:Oc,backendName:\"cpu\",kernelFunc:TX};function ql(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}var EX={kernelName:_m,backendName:\"cpu\",kernelFunc:ql};function Kl(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=w.parseAxisParam(r,t[0].shape)[0],i=t.map(f=>f.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(f=>f.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(f=>w.sizeFromShape(f.shape)>0);if(l.length===1)return cr({inputs:{x:l[0]},backend:n});if(l[0].dtype===\"complex64\"){let f=l.map(v=>yi({inputs:{input:v},backend:n})),g=l.map(v=>ql({inputs:{input:v},backend:n})),b=Kl({inputs:f,backend:n,attrs:{axis:s}}),y=Kl({inputs:g,backend:n,attrs:{axis:s}}),x=Yn({inputs:{real:b,imag:y},backend:n});return f.forEach(v=>n.disposeIntermediateTensorInfo(v)),g.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),x}let u=l.map(f=>{let g=[-1,w.sizeFromShape(f.shape.slice(s))];return xt({inputs:{x:f},backend:n,attrs:{shape:g}})}),p=u.map(f=>({vals:n.data.get(f.dataId).values,shape:f.shape}));o=T.computeOutShape(u.map(f=>f.shape),1);let d=u[0].shape[0]===1,c=L1(p,o,t[0].dtype,d),h=T.computeOutShape(l.map(f=>f.shape),s),m=n.makeTensorInfo(h,t[0].dtype,c);return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var _X={kernelName:su,backendName:\"cpu\",kernelFunc:Kl};function S_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=a;ge([r,s],\"conv2d\");let d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,s.shape,i,u,o,p,!1,d),h=c.filterHeight,m=c.filterWidth,f=c.dilationHeight,g=c.dilationWidth,b=c.padInfo.left,y=c.padInfo.top,x=c.dataFormat===\"channelsLast\",v=new Wt(c.outShape,r.dtype),I=w.computeStrides(r.shape),N=w.computeStrides(s.shape),C=I[0],_=x?I[1]:I[2],F=x?I[2]:1,D=x?1:I[1],$=v.strides[0],S=x?v.strides[1]:v.strides[2],M=x?v.strides[2]:1,B=x?1:v.strides[1],U=n.data.get(r.dataId).values,H=n.data.get(s.dataId).values,q=v.values;for(let K=0;K<c.batchSize;++K){let Z=K*C,J=K*$;for(let ee=0;ee<c.outHeight;++ee){let ae=J+ee*S,te=ee*c.strideHeight-y;for(let se=0;se<h;++se){let ie=te+se*f;if(ie<0||ie>=c.inHeight)continue;let ve=se*N[0],ue=Z+ie*_;for(let ye=0;ye<c.outWidth;++ye){let ke=ae+ye*M,Se=ye*c.strideWidth-b;for(let Le=0;Le<m;++Le){let Ue=Se+Le*g;if(Ue<0||Ue>=c.inWidth)continue;let mt=ve+Le*N[1],st=ue+Ue*F,tt=mt;for(let nt=0;nt<c.inChannels;++nt){let Re=U[st+nt*D];for(let gt=0;gt<c.outChannels;++gt)q[ke+gt*B]+=Re*H[tt+gt];tt+=c.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,q)}var AX={kernelName:Pi,backendName:\"cpu\",kernelFunc:S_};function FX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=a;ge([r,s],\"conv2dBackpropFilter\");let d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,p,i,1,o,u,!1,d),{strideHeight:h,strideWidth:m,filterHeight:f,filterWidth:g}=c,b=c.dataFormat===\"channelsLast\",y=new Wt(c.filterShape,\"float32\"),x=c.padInfo.left,v=c.padInfo.top,I=n.data.get(r.dataId).values,N=n.data.get(s.dataId).values,C=new Wt(r.shape,r.dtype,I),_=new Wt(s.shape,s.dtype,N);for(let F=0;F<f;++F){let D=Math.max(0,Math.ceil((v-F)/h)),$=Math.min(c.outHeight,(c.inHeight+v-F)/h);for(let S=0;S<g;++S){let M=Math.max(0,Math.ceil((x-S)/m)),B=Math.min(c.outWidth,(c.inWidth+x-S)/m);for(let U=0;U<c.inChannels;++U)for(let H=0;H<c.outChannels;++H){let q=0;for(let K=0;K<c.batchSize;++K)for(let Z=D;Z<$;++Z){let J=F+Z*h-v;for(let ee=M;ee<B;++ee){let ae=S+ee*m-x;b?q+=C.get(K,J,ae,U)*_.get(K,Z,ee,H):q+=C.get(K,U,J,ae)*_.get(K,H,Z,ee)}}y.set(q,F,S,U,H)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var $X={kernelName:km,backendName:\"cpu\",kernelFunc:FX};function DX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=a;ge([r,s],\"conv2dBackpropInput\");let d=w.computeStrides(s.shape),c=w.computeStrides(r.shape),h=T.convertConv2DDataFormat(u),m=T.computeConv2DInfo(i,s.shape,o,1,l,p,!1,h),f=new Wt(m.inShape,\"float32\"),g=f.values,b=n.data.get(r.dataId).values,y=n.data.get(s.dataId).values,[x,v,I]=d,{batchSize:N,filterHeight:C,filterWidth:_,inChannels:F,inHeight:D,inWidth:$,outChannels:S,outHeight:M,outWidth:B,strideHeight:U,strideWidth:H}=m;h=m.dataFormat;let q=C-1-m.padInfo.top,K=_-1-m.padInfo.left,Z=h===\"channelsLast\",J=f.strides[0],ee=Z?f.strides[1]:f.strides[2],ae=Z?f.strides[2]:1,te=Z?1:f.strides[1],se=c[0],ie=Z?c[1]:c[2],ve=Z?c[2]:1,ue=Z?1:c[1];for(let ye=0;ye<N;++ye)for(let ke=0;ke<F;++ke)for(let Se=0;Se<D;++Se){let Le=Se-q,Ue=Math.max(0,Math.ceil(Le/U)),mt=Math.min(M,(C+Le)/U);for(let st=0;st<$;++st){let tt=st-K,nt=Math.max(0,Math.ceil(tt/H)),Re=Math.min(B,(_+tt)/H),gt=0;for(let Ot=Ue;Ot<mt;++Ot){let ia=Ot*U-Le;for(let un=nt;un<Re;++un){let Fn=un*H-tt,oa=se*ye+ie*Ot+ve*un,$n=x*(C-1-ia)+v*(_-1-Fn)+I*ke;for(let ut=0;ut<S;++ut){let Dn=b[oa+ue*ut],Hn=y[$n+ut];gt+=Dn*Hn}}}let Gn=J*ye+ee*Se+ae*st+te*ke;g[Gn]=gt}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var RX={kernelName:Li,backendName:\"cpu\",kernelFunc:DX};function MX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;ge([r,s],\"conv3d\");let u=T.computeConv3DInfo(r.shape,s.shape,i,l,o),{filterDepth:p,filterHeight:d,filterWidth:c,dilationDepth:h,dilationHeight:m,dilationWidth:f,padInfo:g}=u,b=g.front,y=g.left,x=g.top,v=new Wt(u.outShape,r.dtype),I=n.data.get(r.dataId).values,N=n.data.get(s.dataId).values,C=v.values,_=w.computeStrides(r.shape),F=w.computeStrides(s.shape);for(let D=0;D<u.batchSize;++D){let $=D*_[0],S=D*v.strides[0];for(let M=0;M<u.outDepth;++M){let B=S+M*v.strides[1],U=M*u.strideDepth-b;for(let H=0;H<p;++H){let q=U+H*h;if(q<0||q>=u.inDepth)continue;let K=H*F[0],Z=$+q*_[1];for(let J=0;J<u.outHeight;++J){let ee=B+J*v.strides[2],ae=J*u.strideHeight-x;for(let te=0;te<d;++te){let se=ae+te*m;if(se<0||se>=u.inHeight)continue;let ie=K+te*F[1],ve=Z+se*_[2];for(let ue=0;ue<u.outWidth;++ue){let ye=ee+ue*u.outChannels,ke=ue*u.strideWidth-y;for(let Se=0;Se<c;++Se){let Le=ke+Se*f;if(Le<0||Le>=u.inWidth)continue;let Ue=ie+Se*F[2],mt=ve+Le*u.inChannels,st=Ue;for(let tt=0;tt<u.inChannels;++tt){let nt=I[mt+tt];for(let Re=0;Re<u.outChannels;++Re)C[ye+Re]+=nt*N[st+Re];st+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var OX={kernelName:zi,backendName:\"cpu\",kernelFunc:MX};function PX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;ge([r,s],\"conv3dBackpropFilterV2\");let u=w.computeStrides(r.shape),p=w.computeStrides(s.shape),d=T.computeConv3DInfo(r.shape,l,i,1,o),c=d.strideDepth,h=d.strideHeight,m=d.strideWidth,f=d.filterDepth,g=d.filterHeight,b=d.filterWidth,y=new Wt(d.filterShape,\"float32\"),x=y.values,[v,I,N,C]=y.strides,_=n.data.get(s.dataId).values,[F,D,$,S]=p,M=n.data.get(r.dataId).values,[B,U,H,q]=u,K=d.padInfo.front,Z=d.padInfo.left,J=d.padInfo.top;for(let ee=0;ee<f;++ee){let ae=Math.max(0,Math.ceil((K-ee)/c)),te=Math.min(d.outDepth,(d.inDepth+K-ee)/c),se=ee*v;for(let ie=0;ie<g;++ie){let ve=Math.max(0,Math.ceil((J-ie)/h)),ue=Math.min(d.outHeight,(d.inHeight+J-ie)/h),ye=ie*I+se;for(let ke=0;ke<b;++ke){let Se=Math.max(0,Math.ceil((Z-ke)/m)),Le=Math.min(d.outWidth,(d.inWidth+Z-ke)/m),Ue=ke*N+ye;for(let mt=0;mt<d.inChannels;++mt){let st=mt*C+Ue;for(let tt=0;tt<d.outChannels;++tt){let nt=0;for(let Re=0;Re<d.batchSize;++Re){let gt=Re*B,Gn=Re*F;for(let Ot=ae;Ot<te;++Ot){let ia=(ee+Ot*c-K)*U+gt,un=Ot*D+Gn;for(let Fn=ve;Fn<ue;++Fn){let oa=(ie+Fn*h-J)*H+ia,$n=Fn*$+un;for(let ut=Se;ut<Le;++ut){let Dn=(ke+ut*m-Z)*q+oa,Hn=ut*S+$n;nt+=M[Dn+mt]*_[Hn+tt]}}}}x[st+tt]=nt}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var LX={kernelName:iu,backendName:\"cpu\",kernelFunc:PX};function zX(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;ge([r],\"conv3dBackpropInputV2\");let u=w.computeStrides(r.shape),p=w.computeStrides(s.shape),d=T.computeConv3DInfo(l,s.shape,o,1,i),c=new Wt(d.inShape,\"float32\"),h=c.values,[m,f,g,b]=c.strides,y=n.data.get(r.dataId).values,[x,v,I,N]=u,C=n.data.get(s.dataId).values,[_,F,D,$]=p,{batchSize:S,filterDepth:M,filterHeight:B,filterWidth:U,inChannels:H,inDepth:q,inHeight:K,inWidth:Z,outChannels:J,outDepth:ee,outHeight:ae,outWidth:te,strideDepth:se,strideHeight:ie,strideWidth:ve}=d,ue=M-1-d.padInfo.front,ye=B-1-d.padInfo.top,ke=U-1-d.padInfo.left;for(let Se=0;Se<S;++Se)for(let Le=0;Le<H;++Le)for(let Ue=0;Ue<q;++Ue){let mt=Ue-ue,st=Math.max(0,Math.ceil(mt/se)),tt=Math.min(ee,(M+mt)/se);for(let nt=0;nt<K;++nt){let Re=nt-ye,gt=Math.max(0,Math.ceil(Re/ie)),Gn=Math.min(ae,(B+Re)/ie);for(let Ot=0;Ot<Z;++Ot){let ia=Ot-ke,un=Math.max(0,Math.ceil(ia/ve)),Fn=Math.min(te,(U+ia)/ve),oa=0;for(let $n=st;$n<tt;++$n){let ut=$n*se-mt;for(let Dn=gt;Dn<Gn;++Dn){let Hn=Dn*ie-Re;for(let xr=un;xr<Fn;++xr){let ml=xr*ve-ia,Za=x*Se+v*$n+I*Dn+N*xr,Wp=_*(M-1-ut)+F*(B-1-Hn)+D*(U-1-ml)+$*Le;for(let Ia=0;Ia<J;++Ia){let Ur=y[Za+Ia],Jt=C[Wp+Ia];oa+=Ur*Jt}}}}h[m*Se+f*Ue+g*nt+b*Ot+Le]=oa}}}return n.makeTensorInfo(c.shape,c.dtype,c.values)}var WX={kernelName:ou,backendName:\"cpu\",kernelFunc:zX},BX=lt(Wi,e=>Math.cos(e)),VX={kernelName:Wi,backendName:\"cpu\",kernelFunc:BX},UX=lt(Bi,e=>Math.cosh(e)),GX={kernelName:Bi,backendName:\"cpu\",kernelFunc:UX};function HX(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,[p,d,c,h]=r.shape,m=s.shape[0],[f,g]=o,b=Oe([m,f,g,h],\"float32\"),y=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(r.dataId).values,I=w.computeStrides(r.shape),N=w.computeStrides(b.shape);for(let C=0;C<m;C++){let _=C*4,F=y[_],D=y[_+1],$=y[_+2],S=y[_+3],M=x[C];if(M>=p)continue;let B=f>1?($-F)*(d-1)/(f-1):0,U=g>1?(S-D)*(c-1)/(g-1):0;for(let H=0;H<f;H++){let q=f>1?F*(d-1)+H*B:.5*(F+$)*(d-1);if(q<0||q>d-1){for(let K=0;K<g;K++)for(let Z=0;Z<h;Z++){let J=Z+K*N[2]+H*N[1]+C*N[0];b.values[J]=u}continue}if(l===\"bilinear\"){let K=Math.floor(q),Z=Math.ceil(q),J=q-K;for(let ee=0;ee<g;ee++){let ae=g>1?D*(c-1)+ee*U:.5*(D+S)*(c-1);if(ae<0||ae>c-1){for(let ve=0;ve<h;ve++){let ue=ve+ee*N[2]+H*N[1]+C*N[0];b.values[ue]=u}continue}let te=Math.floor(ae),se=Math.ceil(ae),ie=ae-te;for(let ve=0;ve<h;ve++){let ue=ve+te*I[2]+K*I[1]+M*I[0],ye=v[ue];ue=ve+se*I[2]+K*I[1]+M*I[0];let ke=v[ue];ue=ve+te*I[2]+Z*I[1]+M*I[0];let Se=v[ue];ue=ve+se*I[2]+Z*I[1]+M*I[0];let Le=v[ue],Ue=ye+(ke-ye)*ie,mt=Se+(Le-Se)*ie;ue=ve+ee*N[2]+H*N[1]+C*N[0],b.values[ue]=Ue+(mt-Ue)*J}}}else for(let K=0;K<g;++K){let Z=g>1?D*(c-1)+K*U:.5*(D+S)*(c-1);if(Z<0||Z>c-1){for(let ae=0;ae<h;ae++){let te=ae+K*N[2]+H*N[1]+C*N[0];b.values[te]=u}continue}let J=Math.round(Z),ee=Math.round(q);for(let ae=0;ae<h;ae++){let te=ae+J*I[2]+ee*I[1]+M*I[0],se=ae+K*N[2]+H*N[1]+C*N[0];b.values[se]=v[te]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var jX={kernelName:uu,backendName:\"cpu\",kernelFunc:HX};function qX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;ge(r,\"cumprod\");let l=T.getAxesPermutation([s],r.shape.length),u=r;l!=null&&(u=Vn({inputs:{x:r},backend:n,attrs:{perm:l}}));let p=T.getInnerMostAxes(1,r.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=fa(u.dtype,\"int32\"),c=w.makeOnesTypedArray(w.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],f=o?(b,y)=>b+m-y-1:(b,y)=>b+y;for(let b=0;b<h.length;b+=m)for(let y=0;y<m;y++){let x=f(b,y);if(y===0)c[x]=i?1:h[x];else{let v=f(b,y-1);c[x]=i?h[v]*c[v]:h[x]*c[v]}}let g=n.makeTensorInfo(u.shape,d,c);if(l!=null){let b=T.getUndoAxesPermutation(l),y=Vn({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),y}return g}var KX={kernelName:lu,backendName:\"cpu\",kernelFunc:qX};function XX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;ge(r,\"cumsum\");let l=T.getAxesPermutation([s],r.shape.length),u=r;l!=null&&(u=Vn({inputs:{x:r},backend:n,attrs:{perm:l}}));let p=T.getInnerMostAxes(1,r.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=fa(u.dtype,\"int32\"),c=w.makeZerosTypedArray(w.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,m=u.shape[u.shape.length-1],f=o?(b,y)=>b+m-y-1:(b,y)=>b+y;for(let b=0;b<h.length;b+=m)for(let y=0;y<m;y++){let x=f(b,y);if(y===0)c[x]=i?0:h[x];else{let v=f(b,y-1);c[x]=i?h[v]+c[v]:h[x]+c[v]}}let g=n.makeTensorInfo(u.shape,d,c);if(l!=null){let b=T.getUndoAxesPermutation(l),y=Vn({inputs:{x:g},backend:n,attrs:{perm:b}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),y}return g}var YX={kernelName:Vi,backendName:\"cpu\",kernelFunc:XX};function ZX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,p=P1(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}else if(r.shape.length===2){let l=n.bufferSync(r),u=n.bufferSync(s),p=$E(l,u,i,o);return n.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var JX={kernelName:Pc,backendName:\"cpu\",kernelFunc:ZX};function QX(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a;w.assert(i===\"NHWC\",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=r.shape[0],l=r.shape[1],u=r.shape[2],p=r.shape[3],d=l*s,c=u*s,h=p/(s*s),m=n.data.get(r.dataId).values,f=new Float32Array(o*d*c*h),g=0;for(let b=0;b<o;++b)for(let y=0;y<d;++y){let x=Math.floor(y/s),v=y%s;for(let I=0;I<c;++I){let N=Math.floor(I/s),C=I%s,_=(v*s+C)*h;for(let F=0;F<h;++F){let D=F+_+p*(N+u*(x+l*b));f[g++]=m[D]}}}return n.makeTensorInfo([o,d,c,h],r.dtype,f)}var eY={kernelName:pu,backendName:\"cpu\",kernelFunc:QX};function N_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a;ge([r,s],\"depthwiseConv2DNative\");let p=w.computeStrides(r.shape),d=w.computeStrides(s.shape),c=l;c==null&&(c=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let h=T.computeConv2DInfo(r.shape,s.shape,i,c,o,u,!0),{filterHeight:m,filterWidth:f,dilationHeight:g,dilationWidth:b,padInfo:y}=h,x=y.left,v=y.top,I=h.outChannels/h.inChannels,N=new Wt(h.outShape,r.dtype),C=n.data.get(r.dataId).values,_=n.data.get(s.dataId).values,F=N.values;for(let D=0;D<h.batchSize;++D){let $=D*p[0],S=D*N.strides[0];for(let M=0;M<h.outHeight;++M){let B=S+M*N.strides[1],U=M*h.strideHeight-v;for(let H=0;H<m;++H){let q=U+H*g;if(q<0||q>=h.inHeight)continue;let K=H*d[0],Z=$+q*p[1];for(let J=0;J<h.outWidth;++J){let ee=B+J*N.strides[2],ae=J*h.strideWidth-x;for(let te=0;te<f;++te){let se=ae+te*b;if(se<0||se>=h.inWidth)continue;let ie=K+te*d[1],ve=Z+se*h.inChannels,ue=ee,ye=ie;for(let ke=0;ke<h.inChannels;++ke){let Se=C[ve+ke];for(let Le=0;Le<I;++Le)F[ue+Le]+=Se*_[ye+Le];ue+=I,ye+=I}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var tY={kernelName:Ui,backendName:\"cpu\",kernelFunc:N_};function nY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=a;ge([r,s],\"depthwiseConv2dNativeBackpropFilter\");let d=T.computeConv2DInfo(r.shape,p,i,o,l,u,!0),{strideHeight:c,strideWidth:h,filterHeight:m,filterWidth:f}=d,g=new Wt(d.filterShape,\"float32\"),b=d.padInfo.left,y=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(r.dataId).values,I=new Wt(r.shape,r.dtype,v),N=n.data.get(s.dataId).values,C=new Wt(s.shape,s.dtype,N);for(let _=0;_<m;++_){let F=Math.max(0,Math.ceil((y-_)/c)),D=Math.min(d.outHeight,(d.inHeight+y-_)/c);for(let $=0;$<f;++$){let S=Math.max(0,Math.ceil((b-$)/h)),M=Math.min(d.outWidth,(d.inWidth+b-$)/h);for(let B=0;B<d.outChannels;++B){let U=Math.trunc(B/x),H=B%x,q=0;for(let K=0;K<d.batchSize;++K)for(let Z=F;Z<D;++Z){let J=_+Z*c-y;for(let ee=S;ee<M;++ee){let ae=$+ee*h-b;q+=I.get(K,J,ae,U)*C.get(K,Z,ee,B)}}g.set(q,_,$,U,H)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var aY={kernelName:Im,backendName:\"cpu\",kernelFunc:nY};function rY(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=a;ge([r,s],\"depthwiseConv2DNativeBackpropInput\");let d=w.computeStrides(r.shape),c=w.computeStrides(s.shape),h=T.computeConv2DInfo(p,s.shape,i,o,l,u,!0),m=new Wt(h.inShape,\"float32\"),f=m.values,[g,b,y]=m.strides,x=n.data.get(r.dataId).values,[v,I,N]=d,C=n.data.get(s.dataId).values,[_,F,D]=c,{batchSize:$,filterHeight:S,filterWidth:M,inChannels:B,inHeight:U,inWidth:H,outChannels:q,outHeight:K,outWidth:Z,strideHeight:J,strideWidth:ee}=h,ae=S-1-h.padInfo.top,te=M-1-h.padInfo.left,se=q/B;for(let ie=0;ie<$;++ie)for(let ve=0;ve<B;++ve)for(let ue=0;ue<U;++ue){let ye=ue-ae,ke=Math.max(0,Math.ceil(ye/J)),Se=Math.min(K,(S+ye)/J);for(let Le=0;Le<H;++Le){let Ue=Le-te,mt=Math.max(0,Math.ceil(Ue/ee)),st=Math.min(Z,(M+Ue)/ee),tt=0;for(let nt=ke;nt<Se;++nt){let Re=nt*J-ye;for(let gt=mt;gt<st;++gt){let Gn=gt*ee-Ue,Ot=v*ie+I*nt+N*gt,ia=_*(S-1-Re)+F*(M-1-Gn)+D*ve;for(let un=0;un<se;++un){let Fn=ve*se+un,oa=x[Ot+Fn],$n=C[ia+un];tt+=oa*$n}}}f[g*ie+b*ue+y*Le+ve]=tt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var sY={kernelName:Sm,backendName:\"cpu\",kernelFunc:rY};function iY(e){let{inputs:t,backend:n}=e,{x:a}=t,r=w.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,i=Oe([r,r],a.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*r+u]=s[u];let l=[...a.shape,...a.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var oY={kernelName:Lc,backendName:\"cpu\",kernelFunc:iY},lY={kernelName:Gi,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(a.dataId).values,p=a.shape.length,d=l.data.get(r.dataId).values,c=r.shape.length,{batchSize:h,inHeight:m,inWidth:f,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:I,filterHeight:N,filterWidth:C,dilationHeight:_,dilationWidth:F,outShape:D}=T.computeDilation2DInfo(a.shape,r.shape,s,i,\"NHWC\",o),$=w.sizeFromShape(D),S=D.length,M=w.getArrayFromDType(a.dtype,$);for(let B=0;B<h;++B)for(let U=0;U<b;++U){let H=U*v-x.top;for(let q=0;q<y;++q){let K=q*I-x.left;for(let Z=0;Z<g;++Z){let J=Number.MIN_SAFE_INTEGER;for(let ae=0;ae<N;++ae){let te=H+ae*_;if(te>=0&&te<m)for(let se=0;se<C;++se){let ie=K+se*F;if(ie>=0&&ie<f){let ve=w.locToIndex([B,te,ie,Z],p,w.computeStrides(a.shape)),ue=w.locToIndex([ae,se,Z],c,w.computeStrides(r.shape)),ye=u[ve]+d[ue];ye>J&&(J=ye)}}}let ee=w.locToIndex([B,U,q,Z],S,w.computeStrides(D));M[ee]=J}}}return{dataId:l.write(w.toTypedArray(M,a.dtype),D,a.dtype),shape:D,dtype:a.dtype}}},uY={kernelName:Rl,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=w.toNestedArray(a.shape,u.data.get(a.dataId).values),d=w.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:c,inHeight:h,inWidth:m,inChannels:f,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:_,outShape:F}=T.computeDilation2DInfo(a.shape,r.shape,i,o,\"NHWC\",l);w.assert(s.rank===F.length,()=>`Error in ${Rl}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let D=w.toNestedArray(F,u.data.get(s.dataId).values),$=w.makeZerosNestedTypedArray(r.shape,r.dtype);for(let S=0;S<c;++S)for(let M=0;M<g;++M){let B=M*x-y.top;for(let U=0;U<b;++U){let H=U*v-y.left;for(let q=0;q<f;++q){let K=Number.MIN_SAFE_INTEGER,Z=0,J=0;for(let ee=0;ee<I;++ee){let ae=B+ee*C;if(ae>=0&&ae<h)for(let te=0;te<N;++te){let se=H+te*_;if(se>=0&&se<m){let ie=p[S][ae][se][q]+d[ee][te][q];ie>K&&(K=ie,Z=ee,J=te)}}}$[Z][J][q]+=D[S][M][U][q]}}}return{dataId:u.write(w.toTypedArray($,a.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},pY={kernelName:Dl,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:a,filter:r,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=w.toNestedArray(a.shape,u.data.get(a.dataId).values),d=w.toNestedArray(r.shape,u.data.get(r.dataId).values),{batchSize:c,inHeight:h,inWidth:m,inChannels:f,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:N,dilationHeight:C,dilationWidth:_,outShape:F}=T.computeDilation2DInfo(a.shape,r.shape,i,o,\"NHWC\",l);w.assert(s.rank===F.length,()=>`Error in ${Dl}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let D=w.toNestedArray(F,u.data.get(s.dataId).values),$=w.makeZerosNestedTypedArray(a.shape,a.dtype);for(let S=0;S<c;++S)for(let M=0;M<g;++M){let B=M*x-y.top;for(let U=0;U<b;++U){let H=U*v-y.left;for(let q=0;q<f;++q){let K=Number.MIN_SAFE_INTEGER,Z=B<0?0:B,J=H<0?0:H;for(let ee=0;ee<I;++ee){let ae=B+ee*C;if(ae>=0&&ae<h)for(let te=0;te<N;++te){let se=H+te*_;if(se>=0&&se<m){let ie=p[S][ae][se][q]+d[ee][te][q];ie>K&&(K=ie,Z=ae,J=se)}}}$[S][Z][J][q]+=D[S][M][U][q]}}}return{dataId:u.write(w.toTypedArray($,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function cY(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:i}=a,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,p=(o==null?void 0:o.contextType)||\"2d\";if(p!==\"2d\")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(p,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${p} type.`);let[c,h]=r.shape.slice(0,2),m=r.shape.length===2?1:r.shape[2],f=n.data.get(r.dataId).values,g=r.dtype===\"float32\"?255:1,b=new Uint8ClampedArray(h*c*4);for(let x=0;x<c*h;++x){let v=[0,0,0,255*u];for(let N=0;N<m;N++){let C=f[x*m+N];if(r.dtype===\"float32\"){if(C<0||C>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${C}.`)}else if(r.dtype===\"int32\"&&(C<0||C>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${C}.`);m===1?(v[0]=C*g,v[1]=C*g,v[2]=C*g):v[N]=C*g}let I=x*4;b[I+0]=Math.round(v[0]),b[I+1]=Math.round(v[1]),b[I+2]=Math.round(v[2]),b[I+3]=Math.round(v[3])}s.width=h,s.height=c;let y=new ImageData(b,h,c);return d.putImageData(y,0,0),r}var dY={kernelName:Nm,backendName:\"cpu\",kernelFunc:cY};function Ed(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"sum\");let o;r.dtype===\"bool\"?o=bs({inputs:{x:r},backend:n,attrs:{dtype:\"int32\"}}):o=cr({inputs:{x:r},backend:n});let l=o.shape.length,u=w.parseAxisParam(s,o.shape),p=T.getAxesPermutation(u,l),d=u,c=o;p!=null&&(c=Vn({inputs:{x:o},backend:n,attrs:{perm:p}}),d=T.getInnerMostAxes(d.length,l)),T.assertAxesAreInnerMostDims(\"sum\",d,c.shape.length);let[h,m]=T.computeOutAndReduceShapes(c.shape,d),f=T.upcastType(c.dtype,\"int32\"),g=lm(n,h,f),b=w.sizeFromShape(m),y=n.data.get(g.dataId).values,x=n.data.get(c.dataId).values;for(let v=0;v<y.length;++v){let I=v*b,N=0;for(let C=0;C<b;++C)N+=x[I+C];y[v]=N}if(i){let v=T.expandShapeToKeepDim(g.shape,u),I=g;g=xt({inputs:{x:g},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),p!=null&&n.disposeIntermediateTensorInfo(c),g}var hY={kernelName:Lo,backendName:\"cpu\",kernelFunc:Ed};function mY(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(r,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=T.getEinsumComputePath(o,l),d=p.length,c=null,h=i.length,m=[];for(let f=0;f<d;++f){for(let g of p[f]){let{permutationIndices:b,expandDims:y}=T.getEinsumPermutation(h,l[g]),x;T.isIdentityPermutation(b)?x=s[g]:(x=Vn({inputs:{x:s[g]},backend:n,attrs:{perm:b}}),m.push(x));let v=x.shape.slice();for(let I=0;I<y.length;++I)v.splice(y[I],0,1);w.arraysEqual(x.shape,v)||(x=xt({inputs:{x},backend:n,attrs:{shape:v}}),m.push(x)),c===null?c=x:(c=zf({inputs:{a:x,b:c},backend:n}),m.push(c))}f<d-1&&(u[f]>=0&&(c=Ed({inputs:{x:c},backend:n,attrs:{axis:u[f]-(i.length-h),keepDims:!1}}),m.push(c)),h--)}for(let f of m)f!==c&&n.disposeIntermediateTensorInfo(f);return c}var fY={kernelName:Tm,backendName:\"cpu\",kernelFunc:mY};function gY(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t;ge([a,r],\"eluGrad\");let s=new Float32Array(w.sizeFromShape(r.shape)),i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?s[l]=o[l]:s[l]=o[l]*(u+1)}return n.makeTensorInfo(r.shape,\"float32\",s)}var bY={kernelName:cu,backendName:\"cpu\",kernelFunc:gY},yY=T.ERF_P,xY=T.ERF_A1,vY=T.ERF_A2,wY=T.ERF_A3,kY=T.ERF_A4,IY=T.ERF_A5,SY=lt(qi,e=>{let t=Math.sign(e),n=Math.abs(e),a=1/(1+yY*n);return t*(1-((((IY*a+kY)*a+wY)*a+vY)*a+xY)*a*Math.exp(-n*n))}),NY={kernelName:qi,backendName:\"cpu\",kernelFunc:SY};function cm(e){let{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),xt({inputs:{x:r},backend:n,attrs:{shape:o}})}var TY={kernelName:hu,backendName:\"cpu\",kernelFunc:cm},CY=Mt((e,t)=>e/t),X1=Zt(Hi,CY),lv={kernelName:Hi,backendName:\"cpu\",kernelFunc:X1};function T_(e,t,n){let a=e.shape,r=a[0],s=a[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[r,s],p=w.sizeFromShape(u),d=w.getTypedArrayFromDType(\"float32\",p),c=w.getTypedArrayFromDType(\"float32\",p);for(let g=0;g<r;g++){let b=xi({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),y=xi({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),x=Yn({inputs:{real:b,imag:y},backend:n}),{real:v,imag:I}=EY(x,t,n),N=T.mergeRealAndImagArrays(v,I);for(let C=0;C<s;C++){let _=T.getComplexWithIndex(N,C);d[g*s+C]=_.real,c[g*s+C]=_.imag}n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x)}let h=n.makeTensorInfo(u,\"float32\",d),m=n.makeTensorInfo(u,\"float32\",c),f=Yn({inputs:{real:h,imag:m},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),f}function EY(e,t,n){let a=w.sizeFromShape(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(_Y(a)){let o=uv(s,i,a,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,\"float32\",o.real),p=n.makeTensorInfo(l,\"float32\",o.imag),d=n.makeTensorInfo([],\"float32\",w.createScalarValue(a,\"float32\")),c=cr({inputs:{x:d},backend:n}),h=lv.kernelFunc({inputs:{a:u,b:d},backend:n}),m=lv.kernelFunc({inputs:{a:p,b:c},backend:n}),f=n.data.get(h.dataId).values,g=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),{real:f,imag:g}}return o}else{let o=T.mergeRealAndImagArrays(s,i),l=AY(o,a,t);return T.splitRealAndImagArrays(l)}}function _Y(e){return(e&e-1)===0}function uv(e,t,n,a,r){if(n===1)return{real:e,imag:t};let s=T.mergeRealAndImagArrays(e,t),i=n/2,o=T.complexWithEvenIndex(s),l=o.real,u=o.imag,p=[l.length],d=r.makeTensorInfo(p,\"float32\",l),c=r.makeTensorInfo(p,\"float32\",u),h=Yn({inputs:{real:d,imag:c},backend:r}),m=T.complexWithOddIndex(s),f=m.real,g=m.imag,b=[f.length],y=r.makeTensorInfo(b,\"float32\",f),x=r.makeTensorInfo(b,\"float32\",g),v=Yn({inputs:{real:y,imag:x},backend:r}),I=uv(l,u,i,a,r),N=I.real,C=I.imag,_=[N.length],F=r.makeTensorInfo(_,\"float32\",N),D=r.makeTensorInfo(_,\"float32\",C),$=Yn({inputs:{real:F,imag:D},backend:r}),S=uv(f,g,i,a,r),M=S.real,B=S.imag,U=[M.length],H=r.makeTensorInfo(U,\"float32\",M),q=r.makeTensorInfo(U,\"float32\",B),K=Yn({inputs:{real:H,imag:q},backend:r}),Z=T.exponents(n,a),J=[Z.real.length],ee=r.makeTensorInfo(J,\"float32\",Z.real),ae=r.makeTensorInfo(J,\"float32\",Z.imag),te=Yn({inputs:{real:ee,imag:ae},backend:r}),se=zf({inputs:{a:te,b:K},backend:r}),ie=jl({inputs:{a:$,b:se},backend:r}),ve=j1({inputs:{a:$,b:se},backend:r}),ue=yi({inputs:{input:ie},backend:r}),ye=yi({inputs:{input:ve},backend:r}),ke=ql({inputs:{input:ie},backend:r}),Se=ql({inputs:{input:ve},backend:r}),Le=Kl({inputs:[ue,ye],backend:r,attrs:{axis:0}}),Ue=Kl({inputs:[ke,Se],backend:r,attrs:{axis:0}}),mt=r.data.get(Le.dataId).values,st=r.data.get(Ue.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(ve),r.disposeIntermediateTensorInfo(ue),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(ye),r.disposeIntermediateTensorInfo(Se),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(Ue),{real:mt,imag:st}}function AY(e,t,n){let a=new Float32Array(t*2);for(let r=0;r<t;r++){let s=0,i=0;for(let o=0;o<t;o++){let l=T.exponent(r*o,t,n),u=T.getComplexWithIndex(e,o);s+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(s/=t,i/=t),T.assignToTypedArray(a,s,i,r)}return a}function FY(e){let{inputs:t,backend:n}=e,{input:a}=t,r=w.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=xt({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=T_(o,!1,n),u=xt({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var $Y={kernelName:Cm,backendName:\"cpu\",kernelFunc:FY};function Y1(e){let{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,i=s||w.inferDtype(r),o=w.getArrayFromDType(i,w.sizeFromShape(a));return RY(o,r,i),t.makeTensorInfo(a,i,o)}var DY={kernelName:zc,backendName:\"cpu\",kernelFunc:Y1};function RY(e,t,n){e.fill(t)}var MY={kernelName:mu,backendName:\"cpu\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,r=n,s=w.getTypedArrayFromDType(a.dtype,w.sizeFromShape(a.shape)),[i,o,l,u]=a.shape,p=r.data.get(a.dataId).values;for(let d=0;d<i;d++){let c=d*l*o*u;for(let h=0;h<o;h++){let m=h*(l*u);for(let f=0;f<l;f++){let g=f*u;for(let b=0;b<u;b++){let y=Math.round(l-f-1),x=c+m+g+b,v=p[x];if(y>=0&&y<l){let I=y*u,N=c+m+I+b;v=p[N]}s[x]=v}}}}return{dataId:r.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};function OY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=a,f=S_({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c}});if(i){let g=f;if(p===\"NCHW\"&&i.shape.length===1&&i.shape[0]!==1){let b=xt({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});f=jl({inputs:{a:f,b},backend:n}),n.disposeIntermediateTensorInfo(b)}else f=jl({inputs:{a:f,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(h){let g=f;if(p===\"NCHW\"&&h===\"prelu\"&&o.shape.length===1&&o.shape[0]!==1){let b=xt({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});f=pm(n,f,h,b,m),n.disposeIntermediateTensorInfo(b)}else f=pm(n,f,h,o,m);n.disposeIntermediateTensorInfo(g)}return f}var PY={kernelName:oi,backendName:\"cpu\",kernelFunc:OY};function LY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=a,f=N_({inputs:{x:r,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c}});if(i){let g=f;f=jl({inputs:{a:f,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(h){let g=f;f=pm(n,f,h,o,m),n.disposeIntermediateTensorInfo(g)}return f}var zY={kernelName:li,backendName:\"cpu\",kernelFunc:LY};function WY(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=w.sizeFromShape(a.shape),i=r.shape,o=i[i.length-1],[l,u,p,d]=T.prepareAndValidate(a,r);if(u===0)return n.makeTensorInfo(l,a.dtype,[]);let c=n.data.get(r.dataId).values,h=n.bufferSync(a),m=VE(c,h,a.dtype,u,o,p,d,a.shape,s);return n.makeTensorInfo(l,a.dtype,m.values)}var BY={kernelName:gu,backendName:\"cpu\",kernelFunc:WY};function VY(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a;ge([r,s],\"gatherV2\");let l=w.parseAxisParam(i,r.shape)[0],u=n.data.get(s.dataId).values,p=r.shape[l];for(let v=0;v<u.length;++v){let I=u[v];w.assert(I<=p-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${p-1}]`)}let d=o;o==null&&(d=0);let c=w.sizeFromShape(s.shape),h=T.segment_util.collectGatherOpShapeInfo(r,s,l,d),m=xt({inputs:{x:r},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),f=xt({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,c/h.batchSize]}}),g=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize],b=n.bufferSync(f),y=n.bufferSync(m),x=UE(y,b,g);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.makeTensorInfo(h.outputShape,x.dtype,x.values)}var UY={kernelName:fu,backendName:\"cpu\",kernelFunc:VY};function GY(e){let{inputs:t,backend:n}=e,{input:a}=t,r=w.sizeFromShape(a.shape),s=a.shape[a.shape.length-1],i=r/s,o=xt({inputs:{x:a},backend:n,attrs:{shape:[i,s]}}),l=T_(o,!0,n),u=xt({inputs:{x:l},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var HY={kernelName:Em,backendName:\"cpu\",kernelFunc:GY},jY=lt(to,e=>Number.isFinite(e)?1:0,\"bool\"),qY={kernelName:to,backendName:\"cpu\",kernelFunc:jY},KY=lt(no,e=>Math.abs(e)===1/0?1:0,\"bool\"),XY={kernelName:no,backendName:\"cpu\",kernelFunc:KY},YY=lt(ao,e=>Number.isNaN(e)?1:0,\"bool\"),ZY={kernelName:ao,backendName:\"cpu\",kernelFunc:YY};function JY(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=KE(a,r,s);return t.makeTensorInfo([i.length],\"float32\",i)}var QY={kernelName:vu,backendName:\"cpu\",kernelFunc:JY},e7=lt(io,e=>Math.log1p(e)),t7={kernelName:io,backendName:\"cpu\",kernelFunc:e7},n7=Mt((e,t)=>e&&t),a7=Zt(wu,n7,null,\"bool\"),r7={kernelName:wu,backendName:\"cpu\",kernelFunc:a7},s7=lt(ku,e=>e?0:1,\"bool\"),i7={kernelName:ku,backendName:\"cpu\",kernelFunc:s7},o7=Mt((e,t)=>e||t),l7=Zt(Iu,o7,null,\"bool\"),u7={kernelName:Iu,backendName:\"cpu\",kernelFunc:l7};function p7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;ge(r,\"LRN\");let u=r.shape[3],p=u-1,d=n.data.get(r.dataId).values,c=w.sizeFromShape(r.shape),h=new Float32Array(c);function m(f){let g=f%u,b=f-g+Math.max(0,g-s),y=f-g+Math.min(g+s,p),x=0;for(;b<=y;b++){let v=d[b];x+=v*v}return x}for(let f=0;f<c;f++){let g=m(f),b=d[f]*Math.pow(i+o*g,-l);h[f]=b}return n.makeTensorInfo(r.shape,r.dtype,h)}var c7={kernelName:oo,backendName:\"cpu\",kernelFunc:p7};function d7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=a;ge(i,\"LRNGrad\");let d=w.sizeFromShape(i.shape),c=i.shape[3],h=n.data.get(i.dataId).values,m=n.data.get(r.dataId).values,f=n.data.get(s.dataId).values,g=new Float32Array(d),b=d;for(let y=0;y<b;y++){let x=y%c,v=y-x+Math.max(0,x-o),I=y-x+Math.min(c,x+o+1),N=0;for(let C=v;C<I;C++)N+=Math.pow(m[C],2);N=u*N+l;for(let C=v;C<I;C++){let _=-2*u*p*m[C]*f[y]/N;y===C&&(_+=Math.pow(N,-p)),_*=h[y],g[C]+=_}}return n.makeTensorInfo(i.shape,r.dtype,g)}var h7={kernelName:Su,backendName:\"cpu\",kernelFunc:d7};function C_(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=n,l=r.shape,u=l.length,p=w.parseAxisParam(s,l),d=p,c=T.getAxesPermutation(d,u),h=o.data.get(r.dataId).values;if(c!=null){let v=new Array(u);for(let I=0;I<v.length;I++)v[I]=l[c[I]];h=W1(h,l,r.dtype,c,v),d=T.getInnerMostAxes(d.length,u),l=v}ge(r,\"max\"),T.assertAxesAreInnerMostDims(\"max\",d,u);let[m,f]=T.computeOutAndReduceShapes(l,d),g=w.sizeFromShape(f),b=YE(h,g,m,r.dtype),y=o.write(b,m,r.dtype),x=m;return i&&(x=T.expandShapeToKeepDim(m,p)),{dataId:y,shape:x,dtype:r.dtype}}var m7={kernelName:lo,backendName:\"cpu\",kernelFunc:C_};function f7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;ge(r,\"maxPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l),d;if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))d=cr({inputs:{x:r},backend:n});else{let c=n.data.get(r.dataId).values,h=w.computeStrides(r.shape),m=K1(c,r.shape,r.dtype,h,p,\"max\");d=n.makeTensorInfo(p.outShape,r.dtype,m.values)}return d}var g7={kernelName:po,backendName:\"cpu\",kernelFunc:f7};function b7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a;ge(r,\"maxPool3d\");let p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.data.get(r.dataId).values,c=I_(d,r.shape,r.dtype,w.computeStrides(r.shape),p,\"max\");return n.makeTensorInfo(c.shape,\"float32\",c.values)}var y7={kernelName:Nu,backendName:\"cpu\",kernelFunc:b7};function x7(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a;ge([r,s],\"maxPool3DGrad\");let p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=n.bufferSync(s),c=oX(d,p),h=p.strideDepth,m=p.strideHeight,f=p.strideWidth,g=p.dilationDepth,b=p.dilationHeight,y=p.dilationWidth,x=p.effectiveFilterDepth,v=p.effectiveFilterHeight,I=p.effectiveFilterWidth,N=x-1-p.padInfo.front,C=I-1-p.padInfo.left,_=v-1-p.padInfo.top,F=Oe(s.shape,\"float32\"),D=n.bufferSync(r);for(let $=0;$<p.batchSize;++$)for(let S=0;S<p.inChannels;++S)for(let M=0;M<p.inDepth;++M)for(let B=0;B<p.inHeight;++B)for(let U=0;U<p.inWidth;++U){let H=M-N,q=B-_,K=U-C,Z=0;for(let J=0;J<x;J+=g){let ee=(H+J)/h;if(!(ee<0||ee>=p.outDepth||Math.floor(ee)!==ee))for(let ae=0;ae<v;ae+=b){let te=(q+ae)/m;if(!(te<0||te>=p.outHeight||Math.floor(te)!==te))for(let se=0;se<I;se+=y){let ie=(K+se)/f;if(ie<0||ie>=p.outWidth||Math.floor(ie)!==ie)continue;let ve=x*v*I-1-c.get($,ee,te,ie,S),ue=J*v*I+ae*I+se,ye=ve===ue?1:0;if(ye===0)continue;let ke=D.get($,ee,te,ie,S);Z+=ke*ye}}}F.set(Z,$,M,B,U,S)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}var v7={kernelName:Bc,backendName:\"cpu\",kernelFunc:x7};function w7(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;ge([s,i],\"maxPoolGrad\");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=a,c=T.computePool2DInfo(o.shape,l,u,1,p,d),h=n.data.get(o.dataId).values,m=Oe(c.outShape,o.dtype,k_(h,o.shape,o.dtype,c).values),f=c.strideHeight,g=c.strideWidth,b=c.dilationHeight,y=c.dilationWidth,x=c.effectiveFilterHeight,v=c.effectiveFilterWidth,I=v-1-c.padInfo.left,N=x-1-c.padInfo.top,C=Oe(o.shape,\"float32\"),_=n.data.get(r.dataId).values,F=Oe(r.shape,\"float32\",_);for(let D=0;D<c.batchSize;++D)for(let $=0;$<c.inChannels;++$)for(let S=0;S<c.inHeight;++S)for(let M=0;M<c.inWidth;++M){let B=S-N,U=M-I,H=0;for(let q=0;q<x;q+=b){let K=(B+q)/f;if(!(K<0||K>=c.outHeight||Math.floor(K)!==K))for(let Z=0;Z<v;Z+=y){let J=(U+Z)/g;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;let ee=x*v-1-m.get(D,K,J,$),ae=q*v+Z,te=ee===ae?1:0;if(te===0)continue;let se=F.get(D,K,J,$);H+=se*te}}C.set(H,D,S,M,$)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var k7={kernelName:Wc,backendName:\"cpu\",kernelFunc:w7};function I7(e,t,n,a,r){let s=w.computeStrides(t),i=K1(e,t,n,s,r,\"max\"),o=k_(e,t,n,r,!0,a);return[i.values,o.values]}var S7={kernelName:Vc,backendName:\"cpu\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;ge(a,\"MaxPoolWithArgmax\");let u=l.data.get(a.dataId).values,p=T.computePool2DInfo(a.shape,r,s,[1,1],i),[d,c]=I7(u,a.shape,a.dtype,o,p),h=l.write(d,p.outShape,a.dtype),m=l.write(c,p.outShape,a.dtype);return[{dataId:h,shape:p.outShape,dtype:a.dtype},{dataId:m,shape:p.outShape,dtype:\"int32\"}]}};function N7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=w.parseAxisParam(s,r.shape),l=T.computeOutAndReduceShapes(r.shape,o)[1],u=w.sizeFromShape(l),p=[],d=n.makeTensorInfo([],\"float32\",new Float32Array([u]));p.push(d);let c=bs({inputs:{x:r},backend:n,attrs:{dtype:\"float32\"}});p.push(c);let h=X1({inputs:{a:c,b:d},backend:n});p.push(h);let m=Ed({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return p.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var T7={kernelName:co,backendName:\"cpu\",kernelFunc:N7};function C7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;ge(r,\"min\");let o=w.parseAxisParam(s,r.shape),l=o,u=T.getAxesPermutation(l,r.shape.length),p=r;u!=null&&(p=Vn({inputs:{x:r},backend:n,attrs:{perm:u}}),l=T.getInnerMostAxes(l.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"min\",l,p.shape.length);let[d,c]=T.computeOutAndReduceShapes(p.shape,l),h=w.sizeFromShape(c),m=w.makeZerosTypedArray(w.sizeFromShape(d),p.dtype),f=n.data.get(p.dataId).values;for(let b=0;b<m.length;++b){let y=b*h,x=f[y];for(let v=0;v<h;++v){let I=f[y+v];(Number.isNaN(I)||I<x)&&(x=I)}m[b]=x}u!=null&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,m);if(i){let b=T.expandShapeToKeepDim(d,o),y=xt({inputs:{x:g},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(g),y}return g}var E7={kernelName:ho,backendName:\"cpu\",kernelFunc:C7};function _7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:i}=a;ge(r,\"mirrorPad\");let o=s.map((y,x)=>y[0]+r.shape[x]+y[1]),l=s.map(y=>y[0]),u=s.map((y,x)=>y[0]+r.shape[x]),p=i===\"reflect\"?0:1,d=n.data.get(r.dataId).values,c=r.shape.length,h=w.computeStrides(r.shape),m=w.sizeFromShape(o),f=o.length,g=w.computeStrides(o),b=w.getTypedArrayFromDType(r.dtype,m);for(let y=0;y<m;y++){let x=w.indexToLoc(y,f,g);for(let I=0;I<f;I++)x[I]<l[I]?x[I]=l[I]*2-x[I]-p:x[I]>=u[I]&&(x[I]=(u[I]-1)*2-x[I]+p);x=x.map((I,N)=>I-l[N]);let v=w.locToIndex(x,c,h);b[y]=d[v]}return{dataId:n.write(b,o,r.dtype),shape:o,dtype:r.dtype}}var A7={kernelName:fo,backendName:\"cpu\",kernelFunc:_7},F7=Mt((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),$7=Zt(go,F7),D7={kernelName:go,backendName:\"cpu\",kernelFunc:$7},R7=xs(bm());function E_(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=r.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=w.parseAxisParam([o],r.shape),u=C_({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),p=T.expandShapeToKeepDim(u.shape,l),d=xt({inputs:{x:u},backend:n,attrs:{shape:p}}),c=j1({inputs:{a:r,b:d},backend:n}),h=LE({inputs:{x:c},backend:n}),m=Ed({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),f=xt({inputs:{x:m},backend:n,attrs:{shape:p}}),g=X1({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),g}var M7={kernelName:zo,backendName:\"cpu\",kernelFunc:E_};function O7(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;ge(r,\"multinomial\");let l=o?r:E_({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],p=l.shape[1],d=n.data.get(l.dataId).values,c=[u,s],h=w.makeZerosTypedArray(w.sizeFromShape(c),\"int32\");for(let m=0;m<u;++m){let f=m*p,g=new Float32Array(p-1);g[0]=d[f];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[f+x];let b=R7.alea(i.toString()),y=m*s;for(let x=0;x<s;++x){let v=b();h[y+x]=g.length;for(let I=0;I<g.length;I++)if(v<g[I]){h[y+x]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(c,\"int32\",h)}var P7={kernelName:Tu,backendName:\"cpu\",kernelFunc:O7},L7=mr.nonMaxSuppressionV3Impl;function z7(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a;ge(r,\"NonMaxSuppression\");let u=n.data.get(r.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:d}=L7(u,p,i,o,l);return n.makeTensorInfo([d.length],\"int32\",new Int32Array(d))}var W7={kernelName:_u,backendName:\"cpu\",kernelFunc:z7},B7=mr.nonMaxSuppressionV4Impl;function V7(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a;ge(r,\"NonMaxSuppressionPadded\");let p=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:c,validOutputs:h}=B7(p,d,i,o,l,u);return[n.makeTensorInfo([c.length],\"int32\",new Int32Array(c)),n.makeTensorInfo([],\"int32\",new Int32Array([h]))]}var U7={kernelName:Au,backendName:\"cpu\",kernelFunc:V7},G7=mr.nonMaxSuppressionV5Impl;function H7(e){let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a;ge(r,\"NonMaxSuppressionWithScore\");let p=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,c=i,h=o,m=l,f=u,{selectedIndices:g,selectedScores:b}=G7(p,d,c,h,m,f);return[n.makeTensorInfo([g.length],\"int32\",new Int32Array(g)),n.makeTensorInfo([b.length],\"float32\",new Float32Array(b))]}var j7={kernelName:Fu,backendName:\"cpu\",kernelFunc:H7};function q7(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a;ge(r,\"oneHot\");let u=w.sizeFromShape(r.shape),p=new Float32Array(u*i);p.fill(l);let d=n.data.get(r.dataId).values;for(let c=0;c<u;++c)d[c]>=0&&d[c]<i&&(p[c*i+d[c]]=o);return n.makeTensorInfo([...r.shape,i],s,p)}var K7={kernelName:yo,backendName:\"cpu\",kernelFunc:q7};function dm(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"string\")throw new Error(\"zerosLike is not supported for string tensors\");if(a.dtype===\"complex64\"){let r=yi({inputs:{input:a},backend:n}),s=dm({inputs:{x:r},backend:n}),i=ql({inputs:{input:a},backend:n}),o=dm({inputs:{x:i},backend:n}),l=Yn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Y1({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var X7={kernelName:Yu,backendName:\"cpu\",kernelFunc:dm};function __(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"string\")throw new Error(\"onesLike is not supported for string tensors\");if(a.dtype===\"complex64\"){let r=yi({inputs:{input:a},backend:n}),s=__({inputs:{x:r},backend:n}),i=ql({inputs:{input:a},backend:n}),o=dm({inputs:{x:i},backend:n}),l=Yn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Y1({backend:n,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}var Y7={kernelName:$u,backendName:\"cpu\",kernelFunc:__};function A_(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return cm({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,\"All tensors passed to stack must have matching shapes\"),w.assert(i===p.dtype,()=>\"All tensors passed to stack must have matching dtypes\")});let o=[],l=t.map(p=>{let d=cm({inputs:{input:p},backend:n,attrs:{dim:r}});return o.push(d),d}),u=Kl({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(p=>n.disposeIntermediateTensorInfo(p)),u}var Z7={kernelName:Du,backendName:\"cpu\",kernelFunc:A_};function J7(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;ge(r,\"pad\");let o=s.map((b,y)=>b[0]+r.shape[y]+b[1]),l=s.map(b=>b[0]),u=n.data.get(r.dataId).values,p=w.sizeFromShape(r.shape),d=r.shape.length,c=w.computeStrides(r.shape),h=w.sizeFromShape(o),m=o.length,f=w.computeStrides(o),g=w.getTypedArrayFromDType(r.dtype,h);i!==0&&g.fill(i);for(let b=0;b<p;b++){let y=w.indexToLoc(b,d,c).map((v,I)=>v+l[I]),x=w.locToIndex(y,m,f);g[x]=u[b]}return{dataId:n.write(g,o,r.dtype),shape:o,dtype:r.dtype}}var F_={kernelName:xo,backendName:\"cpu\",kernelFunc:J7},Q7=Mt((e,t)=>Math.pow(e,t)),eZ=Zt(vo,Q7),tZ={kernelName:vo,backendName:\"cpu\",kernelFunc:eZ};function nZ(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(b=>n.data.get(b.dataId).values),u=r.map(b=>b.shape),p=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[c,h,m]=n_(l,u,p,s.shape,s.dtype,d,i.shape,o),f=c.map(b=>n.makeTensorInfo([b.length],\"int32\",b)),g=n.makeTensorInfo(m,s.dtype,h);return f.concat([g])}var aZ={kernelName:Am,backendName:\"cpu\",kernelFunc:nZ};function rZ(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,p]=a_(i,a.shape,a.dtype,o,r.shape,l,s.shape),d=n.makeTensorInfo([u.length],\"int32\",u),c=n.makeTensorInfo([p.length],a.dtype,p);return[d,c]}var sZ={kernelName:Fm,backendName:\"cpu\",kernelFunc:rZ};function iZ(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.data.get(r.dataId).values,p=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,c=o.map(g=>n.data.get(g.dataId).values),h=o.map(g=>g.shape),[m,f]=r_(u,r.shape,p,s.shape,s.dtype,d,i.shape,c,h,l);return n.makeTensorInfo(m,s.dtype,f)}var oZ={kernelName:$m,backendName:\"cpu\",kernelFunc:iZ};function lZ(e){let{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:i}=n,o=B1(a,r,i,s);return t.makeTensorInfo([o.length],s,o)}var uZ={kernelName:Uc,backendName:\"cpu\",kernelFunc:lZ},pZ=lt(Io,e=>1/e),cZ={kernelName:Io,backendName:\"cpu\",kernelFunc:pZ};function dZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;ge(r,\"resizeBilinear\");let l=w.computeStrides(r.shape),[u,p]=o,[d,c,h,m]=r.shape,f=n.data.get(r.dataId).values,g=new Float32Array(w.sizeFromShape([d,u,p,m])),b=[s&&u>1?c-1:c,s&&p>1?h-1:h],y=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=0,v=b[0]/y[0],I=b[1]/y[1];for(let N=0;N<d;N++)for(let C=0;C<u;C++){let _;i?_=v*(C+.5)-.5:_=v*C;let F=Math.max(0,Math.floor(_)),D=_-F,$=Math.min(c-1,Math.ceil(_)),S=N*l[0]+F*l[1],M=N*l[0]+$*l[1];for(let B=0;B<p;B++){let U;i?U=I*(B+.5)-.5:U=I*B;let H=Math.max(0,Math.floor(U)),q=U-H,K=Math.min(h-1,Math.ceil(U)),Z=S+H*l[2],J=M+H*l[2],ee=S+K*l[2],ae=M+K*l[2];for(let te=0;te<m;te++){let se=f[Z+te],ie=f[J+te],ve=f[ee+te],ue=f[ae+te],ye=se+(ve-se)*q,ke=ie+(ue-ie)*q,Se=ye+(ke-ye)*D;g[x++]=Se}}}return n.makeTensorInfo([d,u,p,m],\"float32\",g)}var hZ={kernelName:To,backendName:\"cpu\",kernelFunc:dZ};function mZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;ge([s,r],\"resizeBilinearGrad\");let o=w.computeStrides(r.shape),[l,u,p,d]=r.shape,[,c,h]=s.shape,m=new Float32Array(l*u*p*d),f=[i&&c>1?u-1:u,i&&h>1?p-1:p],g=[i&&c>1?c-1:c,i&&h>1?h-1:h],b=f[0]/g[0],y=f[1]/g[1],x=n.data.get(s.dataId).values,v=0;for(let I=0;I<l;I++){let N=I*o[0];for(let C=0;C<c;C++){let _=C*b,F=Math.floor(_),D=Math.min(Math.ceil(_),u-1),$=N+F*o[1],S=N+D*o[1],M=_-F,B=1-M;for(let U=0;U<h;U++){let H=U*y,q=Math.floor(H),K=Math.min(Math.ceil(H),p-1),Z=H-q,J=1-Z,ee=$+q*o[2],ae=$+K*o[2],te=S+q*o[2],se=S+K*o[2],ie=B*J,ve=B*Z,ue=M*J,ye=M*Z;for(let ke=0;ke<d;ke++){let Se=x[v++];m[ee+ke]+=Se*ie,m[ae+ke]+=Se*ve,m[te+ke]+=Se*ue,m[se+ke]+=Se*ye}}}}return n.makeTensorInfo([l,p,u,d],\"float32\",m)}var fZ={kernelName:Ou,backendName:\"cpu\",kernelFunc:mZ};function gZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a;ge(r,\"resizeNearestNeighbor\");let l=w.computeStrides(r.shape),[u,p]=o,[d,c,h,m]=r.shape,f=n.data.get(r.dataId).values,g=new Float32Array(d*u*p*m),b=[s&&u>1?c-1:c,s&&p>1?h-1:h],y=[s&&u>1?u-1:u,s&&p>1?p-1:p],x=b[0]/y[0],v=b[1]/y[1],I=0;for(let N=0;N<d;N++){let C=N*l[0];for(let _=0;_<u;_++){let F=i?x*(_+.5):x*_,D=Math.min(c-1,s?Math.round(F):Math.floor(F));i&&(D=Math.max(0,D));let $=C+D*l[1];for(let S=0;S<p;S++){let M=i?v*(S+.5):v*S,B=Math.min(h-1,s?Math.round(M):Math.floor(M));i&&(B=Math.max(0,B));let U=$+B*l[2];for(let H=0;H<m;H++){let q=f[U+H];g[I++]=q}}}}return n.makeTensorInfo([d,u,p,m],r.dtype,g)}var bZ={kernelName:No,backendName:\"cpu\",kernelFunc:gZ};function yZ(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a;ge([s,r],\"resizeNearestNeighborGrad\");let o=w.computeStrides(r.shape),l=w.computeStrides(s.shape),[u,p,d,c]=r.shape,[,h,m]=s.shape,f=new Float32Array(u*p*d*c),g=n.data.get(s.dataId).values,b=[i&&h>1?p-1:p,i&&m>1?d-1:d],y=[i&&h>1?h-1:h,i&&m>1?m-1:m],x=b[0]/y[0],v=b[1]/y[1],I=1/x,N=1/v,C=Math.ceil(I)*2+2,_=Math.ceil(N)*2+2;for(let F=0;F<u;F++){let D=F*o[0];for(let $=0;$<p;$++){let S=D+$*o[1],M=Math.floor($*I),B=Math.floor(M-C/2);for(let U=0;U<d;U++){let H=S+U*o[2],q=Math.floor(U*N),K=Math.floor(q-_/2);for(let Z=0;Z<c;Z++){let J=0;for(let ee=0;ee<C;ee++){let ae=ee+B;if(ae<0||ae>=h)continue;let te=D+ae*l[1],se=ae*x,ie=Math.min(p-1,i?Math.round(se):Math.floor(se));if($===ie)for(let ve=0;ve<_;ve++){let ue=ve+K;if(ue<0||ue>=m)continue;let ye=te+ue*l[2],ke=ue*v,Se=Math.min(d-1,i?Math.round(ke):Math.floor(ke));U===Se&&(J+=g[ye+Z])}}f[H+Z]=J}}}}return n.makeTensorInfo(r.shape,r.dtype,f)}var xZ={kernelName:Mu,backendName:\"cpu\",kernelFunc:yZ};function vZ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;ge(r,\"reverse\");let i=r.shape.length,o=w.parseAxisParam(s,r.shape);if(i===0)return cr({inputs:{x:r},backend:n});let l=new Wt(r.shape,r.dtype),u=n.bufferSync(r);for(let p=0;p<l.size;p++){let d=l.indexToLoc(p),c=d.slice();o.forEach(h=>c[h]=r.shape[h]-1-c[h]),l.set(u.get(...c),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var wZ={kernelName:Eo,backendName:\"cpu\",kernelFunc:vZ},kZ={kernelName:Zu,backendName:\"cpu\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=w.getTypedArrayFromDType(a.dtype,w.sizeFromShape(a.shape)),[u,p,d,c]=a.shape,[h,m]=T.getImageCenter(i,p,d),f=255,g=Math.sin(r),b=Math.cos(r),y=o.data.get(a.dataId).values;for(let x=0;x<u;x++){let v=x*d*p*c;for(let I=0;I<p;I++){let N=I*(d*c);for(let C=0;C<d;C++){let _=C*c;for(let F=0;F<c;F++){let D=[u,I,C,F],$=D[2],S=D[1],M=($-h)*b-(S-m)*g,B=($-h)*g+(S-m)*b;M=Math.round(M+h),B=Math.round(B+m);let U=s;if(typeof s!=\"number\"&&(F===3?U=f:U=s[F]),M>=0&&M<d&&B>=0&&B<p){let q=B*(d*c),K=M*c,Z=v+q+K+F;U=y[Z]}let H=v+N+_+F;l[H]=U}}}}return{dataId:o.write(l,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},IZ=lt(_o,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),SZ={kernelName:_o,backendName:\"cpu\",kernelFunc:IZ};function NZ(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=T.calculateShapes(s,r,i),c=!0,h=n.bufferSync(r),m=n.bufferSync(s),f=ni(h,m,i,d,u,l,o,p,0,c);return n.makeTensorInfo(i,f.dtype,f.values)}var TZ={kernelName:Pu,backendName:\"cpu\",kernelFunc:NZ};function CZ(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function EZ(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}function _Z(e,t,n,a,r,s){let i=w.getArrayFromDType(\"int32\",n*r);for(let o=0;o<n;++o){let l=e.slice(o*a,(o+1)*a),u=o*r;for(let p=0;p<r;++p)i[u+p]=s===\"left\"?CZ(l,t[p+u]):EZ(l,t[p+u])}return i}function AZ(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=_Z(o,l,r.shape[0],r.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,\"int32\",u)}var FZ={kernelName:zu,backendName:\"cpu\",kernelFunc:AZ};function $Z(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;ge([a,r,s],\"select\");let i=a.shape.length,o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,p=fa(r.dtype,s.dtype),d=w.makeZerosTypedArray(w.sizeFromShape(r.shape),p),c=0,h=i===0||i>1||r.shape.length===1?1:w.sizeFromShape(r.shape.slice(1));for(let m=0;m<o.length;m++)for(let f=0;f<h;f++)o[m]===1?d[c++]=l[m]:d[c++]=u[m];return n.makeTensorInfo(r.shape,p,d)}var DZ={kernelName:Wu,backendName:\"cpu\",kernelFunc:$Z},RZ=T.SELU_SCALEALPHA,MZ=T.SELU_SCALE,OZ=lt(Fo,e=>e>=0?MZ*e:RZ*(Math.exp(e)-1)),PZ={kernelName:Fo,backendName:\"cpu\",kernelFunc:OZ},LZ=lt(Ro,e=>e<0?-1:e>0?1:0),zZ={kernelName:Ro,backendName:\"cpu\",kernelFunc:LZ},WZ=lt($o,e=>Math.sin(e)),BZ={kernelName:$o,backendName:\"cpu\",kernelFunc:WZ},VZ=lt(Do,e=>Math.sinh(e)),UZ={kernelName:Do,backendName:\"cpu\",kernelFunc:VZ},GZ=11920928955078125e-23,eS=Math.log(GZ)+2,HZ=lt(Oo,e=>{let t=e>-eS,n=e<eS,a=Math.exp(e),r;return n?r=a:t?r=e:r=Math.log(1+a),r}),jZ={kernelName:Oo,backendName:\"cpu\",kernelFunc:HZ};function qZ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;ge([r],\"spaceToBatchND\");let o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<r.shape.length;++g)l.push([0,0]);let u=F_.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),p=T.getReshaped(u.shape,s,o,!1),d=T.getPermuted(p.length,s.length,!1),c=T.getReshapedPermuted(u.shape,s,o,!1),h=xt({inputs:{x:u},backend:n,attrs:{shape:p}}),m=Vn({inputs:{x:h},backend:n,attrs:{perm:d}}),f=xt({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),f}var KZ={kernelName:Vu,backendName:\"cpu\",kernelFunc:qZ};function XZ(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:\n        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(a.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values[0],[d,c,h,m,f]=o_(o,a.shape,a.dtype,l,r.dtype,u,p);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([c[0]],r.dtype,h),n.makeTensorInfo([m.length],\"bool\",new Uint8Array(m.map(g=>Number(g)))),n.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}var YZ={kernelName:Gc,backendName:\"cpu\",kernelFunc:XZ};function ZZ(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape\n        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(r.dataId).values),o=n.data.get(a.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,p,d]=l_(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(p,a.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var JZ={kernelName:Gu,backendName:\"cpu\",kernelFunc:ZZ};function QZ(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error(\"segmentIds and indices should have same size.\");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,p]=V1(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(p,a.dtype,u)}var eJ={kernelName:Hc,backendName:\"cpu\",kernelFunc:QZ};function tJ(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error(\"segmentIds and indices should have same size.\");let i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[u,p]=V1(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(p,a.dtype,u)}var nJ={kernelName:jc,backendName:\"cpu\",kernelFunc:tJ};function aJ(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=T.calculateShapes(s,r,o),h=!1,m=n.bufferSync(r),f;switch(s.dtype){case\"bool\":{let g=n.bufferSync(s),b=!!n.data.get(i.dataId).values[0];f=ni(m,g,o,c,p,u,l,d,b,h);break}case\"float32\":{let g=n.bufferSync(s),b=n.data.get(i.dataId).values[0];f=ni(m,g,o,c,p,u,l,d,b,h);break}case\"int32\":{let g=n.bufferSync(s),b=n.data.get(i.dataId).values[0];f=ni(m,g,o,c,p,u,l,d,b,h);break}case\"string\":{let g=n.bufferSync(s),b=w.decodeString(n.data.get(i.dataId).values[0]);f=ni(m,g,o,c,p,u,l,d,b,h);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,f.dtype,f.values)}var rJ={kernelName:Hu,backendName:\"cpu\",kernelFunc:aJ};function sJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=w.parseAxisParam(i,r.shape)[0],l=T.prepareSplitSize(r,s,o),u=new Array(r.shape.length).fill(0),p=r.shape.slice();return l.map(d=>{let c=[...p];c[o]=d;let h=xi({inputs:{x:r},backend:n,attrs:{begin:u,size:c}});return u[o]+=d,h})}var iJ={kernelName:Uu,backendName:\"cpu\",kernelFunc:sJ},oJ={kernelName:qc,backendName:\"cpu\",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,a=t;ge(n,\"square\");let r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let i=0;i<r.length;++i){let o=r[i];s[i]=o*o}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},lJ=lt(Is,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),uJ={kernelName:Is,backendName:\"cpu\",kernelFunc:lJ};function pJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a;ge(r,\"stridedSlice\");let{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=Kt.sliceInfo(r.shape,s,i,o,l,u,p,d,c),I;if(f)I=xt({inputs:{x:r},backend:n,attrs:{shape:m}});else if(g||b){w.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let N=Kt.computeOutShape(y,x,v),C=xi({inputs:{x:r},backend:n,attrs:{begin:y,size:N}});I=xt({inputs:{x:C},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(C)}else{let N=n.bufferSync(r),C=c_(h,N,v,y);I=n.makeTensorInfo(m,C.dtype,C.values)}return I}var cJ={kernelName:ju,backendName:\"cpu\",kernelFunc:pJ};function dJ(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:p,dataSplits:d}=t,c=n.data.get(p.dataId).values,h=n.data.get(d.dataId).values,[m,f]=U1(c,h,r,s,i,o,l,u);return[n.makeTensorInfo([m.length],\"string\",m),n.makeTensorInfo(d.shape,\"int32\",f)]}var hJ={kernelName:Xc,backendName:\"cpu\",kernelFunc:dJ};function mJ(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,p,d]=G1(o,l,r),c=p.length;return[n.makeTensorInfo([c,2],\"int32\",u),n.makeTensorInfo([c],\"string\",p),n.makeTensorInfo([2],\"int32\",new Int32Array(d))]}var fJ={kernelName:Yc,backendName:\"cpu\",kernelFunc:mJ};function gJ(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(r<=0)throw new Error(\"Number of buckets must be at least 1\");let i=n.data.get(s.dataId).values,o=H1(i,r);return n.makeTensorInfo(s.shape,\"int32\",o)}var bJ={kernelName:Zc,backendName:\"cpu\",kernelFunc:gJ},yJ=lt(Vo,e=>Math.tan(e)),xJ={kernelName:Vo,backendName:\"cpu\",kernelFunc:yJ},vJ=lt(Uo,e=>Math.tanh(e)),wJ={kernelName:Uo,backendName:\"cpu\",kernelFunc:vJ};function kJ(e){let{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:p}=T.calculateShapes(s,r,a.shape),d=!1,c=n.bufferSync(r),h=n.bufferSync(s),m=n.bufferSync(a),f=ni(c,h,a.shape,p,l,o,i,u,m,d);return n.makeTensorInfo(a.shape,f.dtype,f.values)}var IJ={kernelName:Lu,backendName:\"cpu\",kernelFunc:kJ};function SJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;ge(r,\"tile\");let i=h_(n.bufferSync(r),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var NJ={kernelName:ks,backendName:\"cpu\",kernelFunc:SJ};function TJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a;ge(r,\"topk\");let o=n.data.get(r.dataId).values,[l,u]=f_(o,r.shape,r.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var CJ={kernelName:qu,backendName:\"cpu\",kernelFunc:TJ};function EJ(e){let{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[p,d,c,h]=r.shape,[m,f]=u!=null?u:[d,c],g=[p,m,f,h],b=w.computeStrides(r.shape),y=b[0],x=b[1],v=b[2],I=w.computeStrides(g),N=I[0],C=I[1],_=I[2],F=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(g));F.fill(l);let D=a.data.get(r.dataId).values,$=a.data.get(s.dataId).values;for(let S=0;S<p;++S){let M=s.shape[0]===1?$:$.subarray(S*8,S*8+8);for(let B=0;B<m;++B)for(let U=0;U<f;++U)for(let H=0;H<h;++H){let q,K=M[6]*U+M[7]*B+1;if(K===0)continue;let Z=(M[0]*U+M[1]*B+M[2])/K,J=(M[3]*U+M[4]*B+M[5])/K,ee=tS(Z,c,o),ae=tS(J,d,o);switch(i){case\"nearest\":q=RJ(D,d,c,y,x,v,S,ae,ee,H,l);break;case\"bilinear\":q=MJ(D,d,c,y,x,v,S,ae,ee,H,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let te=S*N+B*C+U*_+H;F[te]=q}return a.makeTensorInfo(g,r.dtype,F)}return{dataId:a.write(F,g,r.dtype),shape:r.shape,dtype:r.dtype}}var _J={kernelName:Ku,backendName:\"cpu\",kernelFunc:EJ};function tS(e,t,n){switch(n){case\"reflect\":return AJ(e,t);case\"wrap\":return FJ(e,t);case\"nearest\":return DJ(e,t);case\"constant\":default:return $J(e,t)}}function AJ(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=2*t;n<a&&(n=a*Math.trunc(-n/a)+n),n=n<-t?n+a:-n-1}else if(n>t-1)if(t<=1)n=0;else{let a=2*t;n-=a*Math.trunc(n/a),n>=t&&(n=a-n-1)}return w.clamp(0,n,t-1)}function FJ(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let a=t-1;n+=t*(Math.trunc(-n/a)+1)}else if(n>t-1)if(t<=1)n=0;else{let a=t-1;n-=t*Math.trunc(n/a)}return w.clamp(0,n,t-1)}function $J(e,t){return e}function DJ(e,t){return w.clamp(0,e,t-1)}function ac(e,t,n,a,r,s,i,o,l,u,p){let d=i*a+o*r+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:p}function RJ(e,t,n,a,r,s,i,o,l,u,p){let d=Math.round(o),c=Math.round(l);return ac(e,t,n,a,r,s,i,d,c,u,p)}function MJ(e,t,n,a,r,s,i,o,l,u,p){let d=Math.floor(o),c=Math.floor(l),h=d+1,m=c+1,f=(m-l)*ac(e,t,n,a,r,s,i,d,c,u,p)+(l-c)*ac(e,t,n,a,r,s,i,d,m,u,p),g=(m-l)*ac(e,t,n,a,r,s,i,h,c,u,p)+(l-c)*ac(e,t,n,a,r,s,i,h,m,u,p);return(h-o)*f+(o-d)*g}function OJ(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;ge(s,\"unique\");let i=a.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=q1(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],\"int32\",u)]}var PJ={kernelName:Jc,backendName:\"cpu\",kernelFunc:OJ};function LJ(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape.length,o=r.shape[s],l=new Array(i-1),u=0;for(let h=0;h<i;h++)h!==s&&(l[u++]=r.shape[h]);let p=new Array(i).fill(0),d=r.shape.slice();d[s]=1;let c=new Array(o);for(let h=0;h<c.length;h++){p[s]=h;let m=xi({inputs:{x:r},backend:n,attrs:{begin:p,size:d}});c[h]=xt({inputs:{x:m},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(m)}return c}var zJ={kernelName:Xu,backendName:\"cpu\",kernelFunc:LJ};function WJ(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a;ge(r,\"unsortedSegmentSum\");let o=r.shape.length,l=s.shape.length,u=[],p=[],d=o-l,c=s;for(let m=0;m<d;++m){let f=cm({inputs:{input:c},backend:n,attrs:{dim:m+1}});c=f,p.push(f)}for(let m=0;m<i;++m){let f=w.createScalarValue(m,\"int32\"),g=n.makeTensorInfo([],\"int32\",f),b=OE({inputs:{a:g,b:c},backend:n}),y=bs({inputs:{x:b},backend:n,attrs:{dtype:\"float32\"}}),x=zf({inputs:{a:y,b:r},backend:n}),v=Ed({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});u.push(v),p.push(g),p.push(b),p.push(y),p.push(x),p.push(v)}let h=A_({inputs:u,backend:n,attrs:{axis:0}});return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var BJ={kernelName:Qc,backendName:\"cpu\",kernelFunc:WJ},VJ=[MK,m8,PK,zK,v8,BK,UK,HK,qK,XK,ZK,QK,tX,rX,iX,uX,cX,hX,fX,DK,bX,xX,wX,k8,IX,y8,S8,NX,f8,CX,_X,AX,$X,RX,OX,LX,WX,VX,GX,jX,KX,YX,JX,eY,tY,aY,sY,oY,lY,uY,pY,dY,fY,TK,bY,N8,NY,T8,TY,E8,$Y,DY,MY,A8,$8,PY,zY,BY,UY,R8,O8,g8,HY,EX,qY,XY,ZY,CK,L8,W8,QY,V8,t7,r7,i7,u7,c7,h7,m7,G8,g7,y7,v7,k7,S7,T7,E7,j8,A7,D7,P7,K8,Y8,W7,U7,j7,J8,K7,Y7,Z7,F_,tZ,_K,tK,aZ,sZ,oZ,uZ,b8,lv,cZ,AK,FK,$K,hZ,fZ,bZ,xZ,wZ,kZ,SZ,pK,TZ,FZ,DZ,PZ,dK,zZ,BZ,UZ,hK,M7,jZ,KZ,YZ,JZ,eJ,nJ,rJ,iJ,gK,oJ,yK,vK,uJ,cJ,hJ,fJ,bJ,SK,hY,xJ,wJ,IJ,NJ,CJ,_J,Q8,PJ,zJ,BJ,X7];for(let e of VJ)ed(e);var $_={};_e($_,{assertNotComplex:()=>lp,bindCanvasToFramebuffer:()=>QJ,bindColorTextureToFramebuffer:()=>Ph,bindTextureToProgramUniformSampler:()=>K_,bindTextureUnit:()=>H_,bindVertexBufferToProgramAttribute:()=>pv,callAndCheck:()=>de,canBeRepresented:()=>R_,createFragmentShader:()=>P_,createFramebuffer:()=>G_,createProgram:()=>L_,createStaticIndexBuffer:()=>B_,createStaticVertexBuffer:()=>W_,createTexture:()=>V_,createVertexShader:()=>O_,getBatchDim:()=>vi,getExtensionOrThrow:()=>rc,getFramebufferErrorMessage:()=>X_,getMaxTexturesInShader:()=>Q_,getNumChannels:()=>ZJ,getProgramUniformLocation:()=>q_,getProgramUniformLocationOrThrow:()=>j_,getRowsCols:()=>wi,getShapeAs3D:()=>ic,getTextureShapeFromLogicalShape:()=>Z_,getWebGLDisjointQueryTimerVersion:()=>eA,getWebGLErrorMessage:()=>M_,getWebGLMaxTextureSize:()=>J_,hasExtension:()=>da,isCapableOfRenderingToFloatTexture:()=>tA,isDownloadFloatTextureEnabled:()=>nA,isReshapeFree:()=>Tc,isWebGLFenceEnabled:()=>aA,isWebGLVersionEnabled:()=>dv,linkProgram:()=>z_,logShaderSourceAndInfoLog:()=>J1,resetMaxTextureSize:()=>e9,resetMaxTexturesInShader:()=>t9,unbindColorTextureFromFramebuffer:()=>cv,unbindTextureUnit:()=>JJ,validateFramebuffer:()=>sc,validateProgram:()=>Oh,validateTextureSize:()=>U_});var ei={},_h={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function D_(e,t){ei[e]=t}function ja(e,t){if(!(e in ei)||t!=null){let a=GJ(e,t);if(a!==null)ei[e]=a;else return console.log(\"Could not get context for WebGL version\",e),null}let n=ei[e];return n==null||n.isContextLost()?(delete ei[e],ja(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),ei[e])}function UJ(e){if(!G().getBool(\"IS_SAFARI\")&&typeof OffscreenCanvas!=\"undefined\"&&e===2)return new OffscreenCanvas(300,150);if(typeof document!=\"undefined\")return document.createElement(\"canvas\");throw new Error(\"Cannot create a canvas in this context\")}function GJ(e,t){if(e!==1&&e!==2)throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");let n=t==null?UJ(e):t;return n.addEventListener(\"webglcontextlost\",a=>{a.preventDefault(),delete ei[e]},!1),G().getBool(\"SOFTWARE_WEBGL_ENABLED\")&&(_h.failIfMajorPerformanceCaveat=!1),e===1?n.getContext(\"webgl\",_h)||n.getContext(\"experimental-webgl\",_h):n.getContext(\"webgl2\",_h)}var Nc;(function(e){e[e.DENSE=0]=\"DENSE\",e[e.SHARED_BATCH=1]=\"SHARED_BATCH\"})(Nc||(Nc={}));var ca;(function(e){e[e.RENDER=0]=\"RENDER\",e[e.UPLOAD=1]=\"UPLOAD\",e[e.PIXELS=2]=\"PIXELS\",e[e.DOWNLOAD=3]=\"DOWNLOAD\"})(ca||(ca={}));var cn;(function(e){e[e.UNPACKED_FLOAT16=0]=\"UNPACKED_FLOAT16\",e[e.UNPACKED_FLOAT32=1]=\"UNPACKED_FLOAT32\",e[e.PACKED_4X1_UNSIGNED_BYTE=2]=\"PACKED_4X1_UNSIGNED_BYTE\",e[e.PACKED_2X2_FLOAT32=3]=\"PACKED_2X2_FLOAT32\",e[e.PACKED_2X2_FLOAT16=4]=\"PACKED_2X2_FLOAT16\"})(cn||(cn={}));function _d(e,t){return[t,e]}function HJ(e,t){return e*t}function Ah(e){let t=w.sizeFromShape(e),n=Math.ceil(t/4);return w.sizeToSquarishShape(n)}function op(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function jJ(e,t){let[n,a]=op(e,t);return n*a*4}function Z1(e,t){let n=e,a,r,s,i,o,l,u,p,d,c;return G().getNumber(\"WEBGL_VERSION\")===2?(a=n.R32F,r=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,p=1,d=n.HALF_FLOAT,c=n.FLOAT,l=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,p=4,d=t!=null?t.HALF_FLOAT_OES:null,c=e.FLOAT,l=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:p,textureTypeHalfFloat:d,textureTypeFloat:c}}function de(e,t){let n=t();return G().getBool(\"DEBUG\")&&qJ(e),n}function qJ(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error(\"WebGL Error: \"+M_(e,t))}var KJ=596e-10,XJ=65504;function R_(e){return!!(G().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\")||e===0||KJ<Math.abs(e)&&Math.abs(e)<XJ)}function M_(e,t){switch(t){case e.NO_ERROR:return\"NO_ERROR\";case e.INVALID_ENUM:return\"INVALID_ENUM\";case e.INVALID_VALUE:return\"INVALID_VALUE\";case e.INVALID_OPERATION:return\"INVALID_OPERATION\";case e.INVALID_FRAMEBUFFER_OPERATION:return\"INVALID_FRAMEBUFFER_OPERATION\";case e.OUT_OF_MEMORY:return\"OUT_OF_MEMORY\";case e.CONTEXT_LOST_WEBGL:return\"CONTEXT_LOST_WEBGL\";default:return`Unknown error code ${t}`}}function rc(e,t){return Or(e,()=>e.getExtension(t),'Extension \"'+t+'\" not supported on this browser.')}function O_(e,t){let n=Or(e,()=>e.createShader(e.VERTEX_SHADER),\"Unable to create vertex WebGLShader.\");if(de(e,()=>e.shaderSource(n,t)),de(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error(\"Failed to compile vertex shader.\");return n}function P_(e,t){let n=Or(e,()=>e.createShader(e.FRAGMENT_SHADER),\"Unable to create fragment WebGLShader.\");if(de(e,()=>e.shaderSource(n,t)),de(e,()=>e.compileShader(n)),G().get(\"ENGINE_COMPILE_ONLY\"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw J1(t,e.getShaderInfoLog(n)),new Error(\"Failed to compile fragment shader.\");return n}var YJ=/ERROR: [0-9]+:([0-9]+):/g;function J1(e,t){let n=YJ.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let a=+n[1],r=e.split(`\n`),s=r.length.toString().length+2,i=r.map((d,c)=>w.rightPad((c+1).toString(),s)+d),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,a-1),u=i.slice(a-1,a),p=i.slice(a);console.log(l.join(`\n`)),console.log(t.split(`\n`)[0]),console.log(`%c ${w.rightPad(u[0],o)}`,\"border:1px solid red; background-color:#e3d2d2; color:#a61717\"),console.log(p.join(`\n`))}function L_(e){return Or(e,()=>e.createProgram(),\"Unable to create WebGLProgram.\")}function z_(e,t){if(de(e,()=>e.linkProgram(t)),!G().get(\"ENGINE_COMPILE_ONLY\")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error(\"Failed to link vertex and fragment shaders.\")}function Oh(e,t){if(de(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error(\"Shader program validation failed.\")}function W_(e,t){let n=Or(e,()=>e.createBuffer(),\"Unable to create WebGLBuffer\");return de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),de(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function B_(e,t){let n=Or(e,()=>e.createBuffer(),\"Unable to create WebGLBuffer\");return de(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),de(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function ZJ(){return G().getNumber(\"WEBGL_VERSION\")===2?1:4}function V_(e){return Or(e,()=>e.createTexture(),\"Unable to create WebGLTexture.\")}function U_(e,t){let n=G().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");if(e<=0||t<=0){let a=`[${e}x${t}]`;throw new Error(\"Requested texture size \"+a+\" is invalid.\")}if(e>n||t>n){let a=`[${e}x${t}]`,r=`[${n}x${n}]`;throw new Error(\"Requested texture size \"+a+\" greater than WebGL maximum on this browser / GPU \"+r+\".\")}}function G_(e){return Or(e,()=>e.createFramebuffer(),\"Unable to create WebGLFramebuffer.\")}function pv(e,t,n,a,r,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),de(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),de(e,()=>e.enableVertexAttribArray(o)),!0)}function H_(e,t,n){Y_(e,n),de(e,()=>e.activeTexture(e.TEXTURE0+n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function JJ(e,t){Y_(e,t),de(e,()=>e.activeTexture(e.TEXTURE0+t)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function j_(e,t,n){return Or(e,()=>e.getUniformLocation(t,n),'uniform \"'+n+'\" not present in program.')}function q_(e,t,n){return e.getUniformLocation(t,n)}function K_(e,t,n,a){de(e,()=>H_(e,t,a)),de(e,()=>e.uniform1i(n,a))}function QJ(e){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),de(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),de(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function Ph(e,t,n){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),de(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function cv(e,t){de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),de(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function sc(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error(\"Error binding framebuffer: \"+X_(e,t))}function X_(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return\"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return\"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return\"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";case e.FRAMEBUFFER_UNSUPPORTED:return\"FRAMEBUFFER_UNSUPPORTED\";default:return`unknown error ${t}`}}function Or(e,t,n){let a=de(e,()=>t());if(a==null)throw new Error(n);return a}function Y_(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){let r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function vi(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function wi(e){if(e.length===0)throw Error(\"Cannot get rows and columns of an empty shape array.\");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function ic(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[vi(e),...wi(e)]),t}function Z_(e,t=!1){let n=G().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\"),a=G().getNumber(\"WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE\");a===1/0&&G().getBool(\"WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE\")&&(a=n/2),t&&(n=n*2,a=a*2,e=e.map((o,l)=>l>=e.length-2?w.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let r=w.sizeFromShape(e),s=null;e.length<=1&&r<=n?s=[1,r]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=vi(e),l=2,u=2;e.length&&([l,u]=wi(e)),r=o*(l/2)*(u/2),s=w.sizeToSquarishShape(r).map(p=>p*2)}else s=w.sizeToSquarishShape(r);return s}function Fh(e){return e%2===0}function Tc(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],a=t[t.length-1];if(n===a||Fh(n)&&Fh(a)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Fh(e[0])&&Fh(t[0])}var Lh,zh;function J_(e){if(Lh==null){let t=ja(e);Lh=t.getParameter(t.MAX_TEXTURE_SIZE)}return Lh}function e9(){Lh=null}function t9(){zh=null}function Q_(e){if(zh==null){let t=ja(e);zh=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,zh)}function eA(e){if(e===0)return 0;let t,n=ja(e);return da(n,\"EXT_disjoint_timer_query_webgl2\")&&e===2?t=2:da(n,\"EXT_disjoint_timer_query\")?t=1:t=0,t}function da(e,t){return e.getExtension(t)!=null}function dv(e){try{if(ja(e)!=null)return!0}catch(t){return console.log(\"Error when getting WebGL context: \",t),!1}return!1}function tA(e){if(e===0)return!1;let t=ja(e);if(e===1){if(!da(t,\"OES_texture_float\"))return!1}else if(!da(t,\"EXT_color_buffer_float\"))return!1;return hv(t)}function nA(e){if(e===0)return!1;let t=ja(e);if(e===1){if(!da(t,\"OES_texture_float\")||!da(t,\"WEBGL_color_buffer_float\"))return!1}else{if(da(t,\"EXT_color_buffer_float\"))return hv(t);let n=\"EXT_color_buffer_half_float\";if(da(t,n)){let a=t.getExtension(n);return n9(t,a)}return!1}return hv(t)}function hv(e){let t=Z1(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function n9(e,t){let n=Z1(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(r),s}function aA(e){return e!==2?!1:ja(e).fenceSync!=null}function lp(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!==\"complex64\",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var be=G();be.registerFlag(\"HAS_WEBGL\",()=>be.getNumber(\"WEBGL_VERSION\")>0);be.registerFlag(\"WEBGL_VERSION\",()=>dv(2)?2:dv(1)?1:0);be.registerFlag(\"WEBGL_CHECK_NUMERICAL_PROBLEMS\",()=>!1);be.registerFlag(\"WEBGL_BUFFER_SUPPORTED\",()=>be.get(\"WEBGL_VERSION\")===2);be.registerFlag(\"WEBGL_CPU_FORWARD\",()=>!0);be.registerFlag(\"WEBGL_FORCE_F16_TEXTURES\",()=>!1);be.registerFlag(\"WEBGL_PACK\",()=>be.getBool(\"HAS_WEBGL\"));be.registerFlag(\"WEBGL_PACK_NORMALIZATION\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_CLIP\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_DEPTHWISECONV\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_BINARY_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_UNARY_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_ARRAY_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_IMAGE_OPERATIONS\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_REDUCE\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_LAZILY_UNPACK\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_CONV_IM2COL\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_PACK_CONV2DTRANSPOSE\",()=>be.getBool(\"WEBGL_PACK\"));be.registerFlag(\"WEBGL_MAX_TEXTURE_SIZE\",()=>J_(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_MAX_TEXTURES_IN_SHADER\",()=>Q_(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\",()=>{let e=be.getNumber(\"WEBGL_VERSION\");return e===0?0:eA(e)});be.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\",()=>be.getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0&&!ad.isMobile());be.registerFlag(\"WEBGL_RENDER_FLOAT32_CAPABLE\",()=>tA(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_RENDER_FLOAT32_ENABLED\",()=>be.getBool(\"WEBGL_FORCE_F16_TEXTURES\")?!1:be.getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\"));be.registerFlag(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\",()=>nA(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_FENCE_API_ENABLED\",()=>aA(be.getNumber(\"WEBGL_VERSION\")));be.registerFlag(\"WEBGL_SIZE_UPLOAD_UNIFORM\",()=>be.getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\")?4:0);be.registerFlag(\"WEBGL_DELETE_TEXTURE_THRESHOLD\",()=>-1,e=>{if(typeof e!=\"number\")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});be.registerFlag(\"WEBGL_FLUSH_THRESHOLD\",()=>ad.isMobile()?1:-1,e=>{if(typeof e!=\"number\")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});be.registerFlag(\"CPU_HANDOFF_SIZE_THRESHOLD\",()=>128);be.registerFlag(\"WEBGL_USE_SHAPES_UNIFORMS\",()=>!1);be.registerFlag(\"TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD\",()=>1e5);be.registerFlag(\"TOPK_K_CPU_HANDOFF_THRESHOLD\",()=>128);be.registerFlag(\"WEBGL_EXP_CONV\",()=>!1);be.registerFlag(\"SOFTWARE_WEBGL_ENABLED\",()=>be.getBool(\"IS_TEST\"));be.registerFlag(\"WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE\",()=>1/0);be.registerFlag(\"WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE\",()=>!1);be.registerFlag(\"WEBGL2_ISNAN_CUSTOM\",()=>!1);be.registerFlag(\"ENGINE_COMPILE_ONLY\",()=>!1);function En(){let e,t,n,a,r,s,i,o,l,u;return G().getNumber(\"WEBGL_VERSION\")===2?(e=\"#version 300 es\",t=\"in\",n=\"out\",a=\"in\",r=\"texture\",s=\"outputColor\",i=\"out vec4 outputColor;\",o=G().getBool(\"WEBGL2_ISNAN_CUSTOM\")?`\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `:\"\",l=\"\",u=`\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `):(e=\"\",t=\"attribute\",n=\"varying\",a=\"varying\",r=\"texture2D\",s=\"gl_FragColor\",i=\"\",o=`\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `,l=`\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `,u=`\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function Zo(e,t,n=\"index\"){let a=w.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / ${r}`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r}`:`index -= ${e[s]} * ${r}`;return`${i}; ${o};`}).join(\"\")}function Wf(e,t,n=\"index\"){let a=w.computeStrides(t);return a.map((r,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===a.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join(\"\")}function a9(e,t){let n=e.length,a=e.map(s=>`${t}[${s}]`),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]=`(${r[s+1]} * ${a[s+1]})`;return r}function r9(e,t,n=\"index\"){let a=e.map((s,i)=>i),r=a9(a,t);return r.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${r[i]}`,l=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${l};`}).join(\"\")}function Q1(e){let t=w.computeStrides(e).map(n=>n.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function ek(){return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`}var rA=`\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`,{getBroadcastDims:sA}=T;function s9(e,t,n){let a=[];if(e.forEach(c=>{let h=w.sizeFromShape(c.shapeInfo.logicalShape);if(c.shapeInfo.isUniform?a.push(`uniform float ${c.name}${h>1?`[${h}]`:\"\"};`):(a.push(`uniform sampler2D ${c.name};`),a.push(`uniform int offset${c.name};`)),n.enableShapeUniforms){let{uniformShape:m}=tk(n.packedInputs,c.shapeInfo.logicalShape,c.shapeInfo.texShape);switch(m.length){case 1:a.push(`uniform int ${c.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${c.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${c.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${c.name}Shape;`);break;default:break}a.push(`uniform ivec2 ${c.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push(\"uniform int outShape;\");break;case 2:a.push(\"uniform ivec2 outShape;\"),a.push(\"uniform int outShapeStrides;\");break;case 3:a.push(\"uniform ivec3 outShape;\"),a.push(\"uniform ivec2 outShapeStrides;\");break;case 4:a.push(\"uniform ivec4 outShape;\"),a.push(\"uniform ivec3 outShapeStrides;\");break;default:break}a.push(\"uniform ivec2 outTexShape;\")}n.customUniforms&&n.customUniforms.forEach(c=>{a.push(`uniform ${c.type} ${c.name}${c.arrayIndex?`[${c.arrayIndex}]`:\"\"};`)});let r=a.join(`\n`),s=e.map(c=>i9(c,t,n.packedInputs,n.enableShapeUniforms)).join(`\n`),i=t.texShape,o=En(),l=u9(o),u,p,d=d9(o);return t.isPacked?(u=o9(t.logicalShape,i,n.enableShapeUniforms),p=c9(o)):(u=l9(t.logicalShape,i,n.enableShapeUniforms),p=p9(o)),n.packedInputs&&(d+=g9),[d,l,p,r,u,s,n.userCode].join(`\n`)}function up(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return E9(e,t);case 1:return A9(e,t);case 2:return $9(e,t);case 3:return R9(e,t);case 4:return O9(e,t);case 5:return P9(e);case 6:return L9(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function iA(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return C9(e);case 1:return _9(e,t);case 2:return F9(e,t);case 3:return D9(e,t);default:return M9(e,t)}}function i9(e,t,n=!1,a){let r=\"\";n?r+=iA(e,a):r+=up(e,a);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?r+=z9(e,t):r+=W9(e,t)),r}function o9(e,t,n){switch(e.length){case 0:return oA();case 1:return b9(e,t,n);case 2:return N9(e,t,n);case 3:return x9(e,t,n);default:return w9(e,t,n)}}function l9(e,t,n){switch(e.length){case 0:return oA();case 1:return y9(e,t,n);case 2:return T9(e,t,n);case 3:return v9(e,t,n);case 4:return k9(e,t,n);case 5:return I9(e,t);case 6:return S9(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function u9(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function p9(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function c9(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function d9(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${h9}\n    ${m9}\n    ${f9}\n  `}var h9=`\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`,m9=`\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`,f9=`\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`,g9=`\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;function oA(){return`\n    int getOutputCoords() {\n      return 0;\n    }\n  `}function b9(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return a[0]===1?n?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    `:`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${a[1]}.0);\n      }\n    `:a[1]===1?n?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    `:`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${a[0]}.0);\n      }\n    `:n?`\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      return 2 * (resTexRC.x * ${a[1]} + resTexRC.y);\n    }\n  `}function y9(e,t,n){return t[0]===1?n?`\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    `:`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:t[1]===1?n?`\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    `:`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function x9(e,t,n){if(n)return`\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function v9(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Wf([\"r\",\"c\",\"d\"],e)}\n    return ivec3(r, c, d);\n  }\n`;let a=Zo([\"r\",\"c\",\"d\"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec3(r, c, d);\n    }\n  `}function w9(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `;let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2),i=s,o=\"\",l=\"b, r, c\";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}function k9(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Wf([\"r\",\"c\",\"d\",\"d2\"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let a=Zo([\"r\",\"c\",\"d\",\"d2\"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${a}\n      return ivec4(r, c, d, d2);\n    }\n  `}function I9(e,t){let n=Zo([\"r\",\"c\",\"d\",\"d2\",\"d3\"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function S9(e,t){let n=Zo([\"r\",\"c\",\"d\",\"d2\",\"d3\",\"d4\"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function N9(e,t,n){let a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return n?`\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${a[0]}, ${a[1]}));\n      }\n    `;let r=Math.ceil(e[1]/2);return n?`\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${a[0]}, ${a[1]}));\n\n      int index = resTexRC.x * ${a[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function T9(e,t,n){return w.arraysEqual(e,t)?n?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:e[1]===1?n?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:e[0]===1?n?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function Jo(e){return`offset${e}`}function C9(e){let t=e.name,n=\"get\"+t.charAt(0).toUpperCase()+t.slice(1),a=En();return`\n    vec4 ${n}() {\n      return ${a.texture2D}(${t}, halfCR);\n    }\n  `}function E9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${a}() {return ${n};}`;let[r,s]=e.shapeInfo.texShape;if(r===1&&s===1)return`\n      float ${a}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=Jo(n);if(t)return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${a}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function _9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=En();if(t)return`\n    vec4 ${a}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${a}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function A9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${a}(int index) {\n        ${pp(e)}\n      }\n    `;let r=e.shapeInfo.texShape,s=r[0],i=r[1];if(i===1&&s===1)return`\n      float ${a}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=Jo(n);return i===1?t?`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:s===1?t?`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${a}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${a}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function F9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=En();if(s!=null&&w.arraysEqual(n,s))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n\n        return ${l.texture2D}(${a}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${a}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${a}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(n[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${a}, uv);\n    }\n  `}function $9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(s!=null&&w.arraysEqual(n,s)){if(t)return`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `;let c=s[0],h=s[1];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${c}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=w.squeezeShape(n),l=i;if(l.length<n.length){let c=cp(e,l),h=[\"row\",\"col\"];return`\n      ${up(c,t)}\n      float ${r}(int row, int col) {\n        return ${r}(${dp(h,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${pp(e)}\n      }\n    `;let u=s[0],p=s[1],d=Jo(a);return p===1?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${a}TexShape[0]));\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `:u===1?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${a}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${a}TexShape[1]), 0.5);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${a}, uv);\n    }\n  `:t?`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${p}, index);\n    return sampleTexture(${a}, uv);\n  }\n`}function D9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let c=n.slice(1),h=[1,2],m=cp(e,c),f=[\"b\",\"row\",\"col\"];return`\n        ${iA(m,t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${dp(f,h)});\n        }\n      `}let o=En();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${a}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${a}, uv);\n    }\n  `;let l=i[0],u=i[1],p=Math.ceil(n[2]/2),d=p*Math.ceil(n[1]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${p}, b, row, col);\n      return ${o.texture2D}(${a}, uv);\n    }\n  `}function R9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=w.squeezeShape(n),u=o;if(u.length<n.length){let f=cp(e,u),g=[\"row\",\"col\",\"depth\"];return`\n        ${up(f,t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${dp(g,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${pp(e)}\n      }\n    `;let p=e.shapeInfo.texShape,d=p[0],c=p[1],h=e.shapeInfo.flatOffset;if(c===s&&h==null)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${a}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${d}.0);\n          return sampleTexture(${a}, uv);\n        }\n      `;if(c===i&&h==null)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${a}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${d}.0);\n      return sampleTexture(${a}, uv);\n    }\n  `;let m=Jo(a);return t?`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${a}Shape[1] * ${a}Shape[2];\n      int stride1 = ${a}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${m};\n      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index);\n      return sampleTexture(${a}, uv);\n    }\n    `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${m};\n        vec2 uv = uvFromFlat(${d}, ${c}, index);\n        return sampleTexture(${a}, uv);\n      }\n  `}function M9(e,t){let n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),r=En();if(t)return`\n    vec4 ${a}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],p=l[1],d=Math.ceil(s[i-1]/2),c=d*Math.ceil(s[i-2]/2),h=\"int b, int row, int col\",m=`b * ${c} + (row / 2) * ${d} + (col / 2)`;for(let f=2;f<i-1;f++)h=`int b${f}, `+h,c*=s[i-f-1],m=`b${f} * ${c} + `+m;return`\n    vec4 ${a}(${h}) {\n      int index = ${m};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `}function O9(e,t){let n=e.shapeInfo.logicalShape,a=e.name,r=\"get\"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(n);if(l.length<n.length){let y=cp(e,l),x=[\"row\",\"col\",\"depth\",\"depth2\"];return`\n      ${up(y,t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${dp(x,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${pp(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],h=d[1],m=`int stride2 = ${a}Shape[3];`,f=`int stride1 = ${a}Shape[2] * stride2;`,g=`int stride0 = ${a}Shape[1] * stride1;`;if(h===o&&p==null)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${f}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${c}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;if(h===s&&p==null)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${a}Shape[1] * ${a}Shape[2], ${a}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${a}TexShape[1], ${a}TexShape[0]);\n        return sampleTexture(${a}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${c}.0);\n        return sampleTexture(${a}, uv);\n      }\n    `;let b=Jo(a);return t?`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${f}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${b});\n      return sampleTexture(${a}, uv);\n    }\n  `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${c}, ${h}, index + ${b});\n      return sampleTexture(${a}, uv);\n    }\n  `}function P9(e){let t=e.shapeInfo.logicalShape,n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=w.squeezeShape(t);if(l.length<t.length){let f=cp(e,l),g=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\"];return`\n      ${up(f)}\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        return ${a}(${dp(g,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${r})) +\n          depth3;\n        ${pp(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],h=d[1];if(h===o&&p==null)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===r&&p==null)return`\n      float ${a}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=Jo(n);return`\n    float ${a}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${r} + depth3 + ${m};\n      vec2 uv = uvFromFlat(${c}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function L9(e){let t=e.shapeInfo.logicalShape,n=e.name,a=\"get\"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=w.squeezeShape(t);if(r.length<t.length){let g=cp(e,r),b=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\",\"depth4\"];return`\n      ${up(g)}\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${a}(${dp(b,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,p=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${pp(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],m=c[1];if(m===p&&d==null)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(m===i&&d==null)return`\n      float ${a}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=Jo(n);return`\n    float ${a}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${m}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function pp(e){let t=e.name,n=w.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function z9(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r=\"get\"+a+\"AtOutCoords\",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=sA(e.shapeInfo.logicalShape,t.logicalShape),l=ht(i),u=i-s,p,d=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];s===0?p=\"\":i<2&&o.length>=1?p=\"coords = 0;\":p=o.map(g=>`coords.${d[g+u]} = 0;`).join(`\n`);let c=\"\";i<2&&s>0?c=\"coords\":c=e.shapeInfo.logicalShape.map((g,b)=>`coords.${d[b+u]}`).join(\", \");let h=\"return outputValue;\",m=w.sizeFromShape(e.shapeInfo.logicalShape)===1,f=w.sizeFromShape(t.logicalShape)===1;if(s===1&&!m&&!f)h=`\n      return vec4(outputValue.xy, outputValue.xy);\n    `;else if(m&&!f)i===1?h=`\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `:h=`\n        return vec4(outputValue.x);\n      `;else if(o.length){let g=s-2,b=s-1;o.indexOf(g)>-1&&o.indexOf(b)>-1?h=\"return vec4(outputValue.x);\":o.indexOf(g)>-1?h=\"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\":o.indexOf(b)>-1&&(h=\"return vec4(outputValue.xx, outputValue.zz);\")}return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${p}\n      vec4 outputValue = get${a}(${c});\n      ${h}\n    }\n  `}function W9(e,t){let n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r=\"get\"+a+\"AtOutCoords\",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&w.arraysEqual(i,s))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u=ht(l),p=sA(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,c,h=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];o===0?c=\"\":l<2&&p.length>=1?c=\"coords = 0;\":c=p.map(f=>`coords.${h[f+d]} = 0;`).join(`\n`);let m=\"\";return l<2&&o>0?m=\"coords\":m=e.shapeInfo.logicalShape.map((f,g)=>`coords.${h[g+d]}`).join(\", \"),`\n    float ${r}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      return get${a}(${m});\n    }\n  `}function ht(e){if(e<=1)return\"int\";if(e===2)return\"ivec2\";if(e===3)return\"ivec3\";if(e===4)return\"ivec4\";if(e===5)return\"ivec5\";if(e===6)return\"ivec6\";throw Error(`GPU for rank ${e} is not yet supported`)}function tk(e,t,n){let{newShape:a,keptDims:r}=w.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):a,l=!e&&s>1&&!w.arraysEqual(t,n)&&a.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:r}}function cp(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function dp(e,t){return t.map(n=>e[n]).join(\", \")}function B9(e,t,n,a){let r=n.map((p,d)=>{let c={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:p.isUniform?!1:p.texData.isPacked,flatOffset:null};return p.texData!=null&&p.texData.slice!=null&&p.texData.slice.flatOffset>0&&(c.flatOffset=p.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:c}}),s=r.map(p=>p.shapeInfo),i={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},o=s9(r,i,t),l=P_(e.gl,o),u=e.createProgram(l);return G().get(\"ENGINE_COMPILE_ONLY\")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},lA(e,t,u)))}function lA(e,t,n){let a=[],r=[],s,i,o,l=null,u=null;u=e.getUniformLocation(n,\"NAN\",!1),G().getNumber(\"WEBGL_VERSION\")===1&&(l=e.getUniformLocation(n,\"INFINITY\",!1));let p=!1;for(let d of t.variableNames){let c={name:d,uniform:e.getUniformLocation(n,d,p),offset:e.getUniformLocation(n,`offset${d}`,p)};t.enableShapeUniforms&&(c.shape=e.getUniformLocation(n,`${d}Shape`,p),c.texShape=e.getUniformLocation(n,`${d}TexShape`,p)),a.push(c)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,\"outShape\",p),o=e.getUniformLocation(n,\"outShapeStrides\",p),i=e.getUniformLocation(n,\"outTexShape\",p)),t.customUniforms)for(let d of t.customUniforms)r.push(e.getUniformLocation(n,d.name,p));return{variablesLocations:a,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function nS(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,a)=>{let r=n.logicalShape,s=t[a],i=s.shape;if(!w.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!w.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function V9(e,t,n,a,r){t.program.enableShapeUniforms||(nS(t.inShapeInfos,n),nS([t.outShapeInfo],[a]));let s=a.texData.texture,i=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),G().getNumber(\"WEBGL_VERSION\")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:p,offset:d,shape:c,texShape:h}=t.variablesLocations[l];if(c){let{uniformShape:m}=tk(t.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:e.gl.uniform1iv(c,new Int32Array(m));break;case 2:e.gl.uniform2iv(c,new Int32Array(m));break;case 3:e.gl.uniform3iv(c,new Int32Array(m));break;case 4:e.gl.uniform4iv(c,new Int32Array(m));break;default:break}}if(h&&e.gl.uniform2i(h,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(w.sizeFromShape(u.shape)<2)e.gl.uniform1f(p,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),e.gl.uniform1fv(p,m)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,p,l)}}let o=t.outShapeLocation;if(o)switch(a.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(a.shape));break;default:break}if(t.outShapeStridesLocation){let l=w.computeStrides(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],p=t.customUniformLocations[l],d=r[l];if(u.type===\"float\")e.gl.uniform1fv(p,d);else if(u.type===\"vec2\")e.gl.uniform2fv(p,d);else if(u.type===\"vec3\")e.gl.uniform3fv(p,d);else if(u.type===\"vec4\")e.gl.uniform4fv(p,d);else if(u.type===\"int\")e.gl.uniform1iv(p,d);else if(u.type===\"ivec2\")e.gl.uniform2iv(p,d);else if(u.type===\"ivec3\")e.gl.uniform3iv(p,d);else if(u.type===\"ivec4\")e.gl.uniform4iv(p,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function U9(e,t,n){let a=\"\";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:p,keptDims:d}=tk(e.packedInputs,i.shape,l),c=\"\",h=\"\",m=\"\";if(p.length===1&&e.packedInputs){let I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];c=`${I[0]>1}_${I[1]>1}`}else if(p.length===2&&!e.packedInputs)h=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!e.packedInputs){let I=w.computeStrides(p);m=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}let f=i.shape.length,g=p.length===2&&w.arraysEqual(i.shape,l),b=w.sizeFromShape(i.shape)===1,y=T.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&f===n.shape.length&&w.arraysEqual(l,n.texData.texShape),v=e.packedInputs||p.length>2?\"\":`${l[0]>1}_${l[1]>1}`;a+=`${f}_${x}_${u?d:\"\"}_${p.length}_${b}_${y}_${g}_${c}_${h}_${m}_${v}_${o}`}else{let l=i.isUniform?\"uniform\":i.texData.texShape;a+=`${i.shape}_${l}_${o}`}});let r=e.userCode,s=e.constructor.name;return s+=\"_\"+a+\"_\"+r+`${G().getNumber(\"WEBGL_VERSION\")}`,s}function vn(e){return G().getBool(\"WEBGL_USE_SHAPES_UNIFORMS\")&&e<=4}var G9=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Nc.DENSE,this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let t=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Wf([\"r\",\"c\",\"d\"],e):Zo([\"r\",\"c\",\"d\"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},H9=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Nc.DENSE,this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let t=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Wf([\"r\",\"c\",\"d\"],e):Zo([\"r\",\"c\",\"d\"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},j9=class{constructor(e){this.variableNames=[\"A\"],this.outTexUsage=ca.DOWNLOAD;let t=En();this.outputShape=e,this.userCode=`\n      ${rA}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},q9=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ca.DOWNLOAD;let t=En();this.outputShape=e,this.userCode=`\n      ${rA}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},K9={R:0,G:1,B:2,A:3},aS=class{constructor(e,t=!1,n=\"RGBA\"){this.variableNames=[\"A\"],this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let a=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let r=\"result\";t&&(r=\"floor(result * 255. + 0.5)\");let s=\"\";for(let i=0;i<n.length;i++){let o=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${K9[o]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?ek():Q1(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${a.texture2D}(A, uv);\n          ${s}\n        }\n        ${a.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}},X9=class{constructor(e,t=!1){this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:\"texShape\",type:\"ivec2\"}];let n=En();this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let a=\"\",r=\"result\";t&&(r=\"floor(result * 255. + 0.5)\");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?\"outShape[2]\":`${e[2]}`}) {\n          localCoords[2] += ${i};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?\"outShape[1]\":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?ek():Q1(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${n.output} = ${r};\n        }\n    `}},uA={};_e(uA,{bindVertexProgramAttributeStreams:()=>yA,createBufferFromOutputTexture:()=>wA,createFloat16MatrixTexture:()=>mA,createFloat16PackedMatrixTexture:()=>bA,createFloat32MatrixTexture:()=>hA,createIndexBuffer:()=>dA,createPackedMatrixTexture:()=>gA,createUnsignedBytesMatrixTexture:()=>fA,createVertexBuffer:()=>cA,createVertexShader:()=>pA,downloadByteEncodedFloatMatrixFromOutputTexture:()=>IA,downloadFloat32MatrixFromBuffer:()=>kA,downloadMatrixFromPackedOutputTexture:()=>NA,downloadPackedMatrixFromBuffer:()=>SA,getInternalFormatForFloat16MatrixTexture:()=>ak,getInternalFormatForFloat16PackedMatrixTexture:()=>ik,getInternalFormatForFloat32MatrixTexture:()=>nk,getInternalFormatForPackedMatrixTexture:()=>sk,getInternalFormatForUnsignedBytesMatrixTexture:()=>rk,uploadDenseMatrixToTexture:()=>xA,uploadPixelDataToTexture:()=>vA});function pA(e){let t=En(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return O_(e,n)}function cA(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return W_(e,t)}function dA(e){let t=new Uint16Array([0,1,2,2,1,3]);return B_(e,t)}function Ad(e,t,n,a,r,s){U_(t,n);let i=V_(e),o=e.TEXTURE_2D;return de(e,()=>e.bindTexture(o,i)),de(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),de(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),de(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),de(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),G().getNumber(\"WEBGL_VERSION\")===1?de(e,()=>e.texImage2D(o,0,a,t,n,0,r,s,null)):de(e,()=>e.texStorage2D(o,1,a,t,n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function nk(e){return e.internalFormatFloat}function hA(e,t,n,a){let[r,s]=_d(t,n);return Ad(e,r,s,nk(a),a.textureFormatFloat,e.FLOAT)}function ak(e){return e.internalFormatHalfFloat}function mA(e,t,n,a){let[r,s]=_d(t,n);return Ad(e,r,s,ak(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function rk(e){return e.downloadTextureFormat}function fA(e,t,n,a){let[r,s]=_d(t,n);return Ad(e,r,s,rk(a),e.RGBA,e.UNSIGNED_BYTE)}function sk(e){return e.internalFormatPackedFloat}function gA(e,t,n,a){let[r,s]=op(t,n);return Ad(e,r,s,sk(a),e.RGBA,e.FLOAT)}function ik(e){return e.internalFormatPackedHalfFloat}function bA(e,t,n,a){let[r,s]=op(t,n);return Ad(e,r,s,ik(a),e.RGBA,a.textureTypeHalfFloat)}function yA(e,t,n){return de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),pv(e,t,\"clipSpacePos\",n,3,20,0)&&pv(e,t,\"uv\",n,2,20,12)}function xA(e,t,n,a,r,s){de(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;r instanceof Uint8Array?(i=new Uint8Array(n*a*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*a*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(r),G().getNumber(\"WEBGL_VERSION\")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,o,i)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,a,0,e.RGBA,o,i)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function vA(e,t,n){de(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?G().getNumber(\"WEBGL_VERSION\")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):G().getNumber(\"WEBGL_VERSION\")===2?de(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):de(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),de(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function wA(e,t,n,a){let r=e.createBuffer();de(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let s=4*4*t*n;return de(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),de(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),de(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function kA(e,t,n){let a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}function IA(e,t,n,a){let[r,s]=_d(t,n),i=4,o=new Uint8Array(HJ(t*n,i));return de(e,()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function SA(e,t,n,a,r,s,i,o){let l=e,u=new Float32Array(jJ(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function NA(e,t,n){let a=new Float32Array(t*n*4);return de(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a)),a}var Wh=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=G().getNumber(\"WEBGL_VERSION\");if(e!=null?(this.gl=e,D_(t,e)):this.gl=ja(t),e=this.gl,G().getNumber(\"WEBGL_VERSION\")===2){let r=e;this.createVertexArray=()=>de(r,()=>r.createVertexArray()),this.bindVertexArray=s=>de(r,()=>r.bindVertexArray(s)),this.deleteVertexArray=s=>de(r,()=>r.deleteVertexArray(s)),this.getVertexArray=()=>de(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){let r=e.getExtension(\"OES_vertex_array_object\");if(r==null)throw new Error(\"All WebGL1 implementations are expected to offer OES_vertex_array_object.\");this.createVertexArray=()=>de(e,()=>r.createVertexArrayOES()),this.bindVertexArray=s=>de(e,()=>r.bindVertexArrayOES(s)),this.deleteVertexArray=s=>de(e,()=>r.deleteVertexArrayOES(s)),this.getVertexArray=()=>de(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n=\"WEBGL_color_buffer_float\",a=\"EXT_color_buffer_half_float\";if(this.parallelCompilationExtension=this.gl.getExtension(\"KHR_parallel_shader_compile\"),G().getNumber(\"WEBGL_VERSION\")===1){let r=\"OES_texture_float\",s=\"OES_texture_half_float\";if(this.textureFloatExtension=rc(this.gl,r),da(this.gl,s))this.textureHalfFloatExtension=rc(this.gl,s);else if(G().get(\"WEBGL_FORCE_F16_TEXTURES\"))throw new Error(\"GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\");if(this.colorBufferFloatExtension=this.gl.getExtension(n),da(this.gl,a))this.colorBufferHalfFloatExtension=rc(this.gl,a);else if(G().get(\"WEBGL_FORCE_F16_TEXTURES\"))throw new Error(\"GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\")}else if(n=\"EXT_color_buffer_float\",da(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(da(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error(\"GL context does not support color renderable floats\");this.vertexBuffer=cA(this.gl),this.indexBuffer=dA(this.gl),this.framebuffer=G_(this.gl),this.textureConfig=Z1(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool(\"DEBUG\")}dispose(){if(this.disposed)return;this.program!=null&&console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"),this.outputTexture!=null&&console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");let e=this.gl;de(e,()=>e.finish()),de(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),de(e,()=>e.deleteFramebuffer(this.framebuffer)),de(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),de(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),de(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),hA(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),mA(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),fA(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),vA(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),xA(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),bA(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),gA(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(cv(this.gl,this.framebuffer),this.outputTexture=null),de(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>IA(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return SA(this.gl,e,t,n,a,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return kA(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let a=wA(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(G().getBool(\"WEBGL_FENCE_API_ENABLED\")){let a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=a.clientWaitSync(r,0,0);return s===a.ALREADY_SIGNALED||s===a.CONDITION_SATISFIED},t=r}else G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>NA(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=pA(t));let n=L_(t);de(t,()=>t.attachShader(n,this.vertexShader)),de(t,()=>t.attachShader(n,e)),z_(t,n);let a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Oh(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;de(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),yA(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(de(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Oh(this.gl,this.program),de(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?j_(this.gl,e,t):q_(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),de(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),K_(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[a,r]=op(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\")}debugValidate(){this.program!=null&&Oh(this.gl,this.program),sc(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,\"VAO changed between setProgram and executeProgram!\"),this.debugValidate()}de(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),de(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=rc(this.gl,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")===2?\"EXT_disjoint_timer_query_webgl2\":\"EXT_disjoint_timer_query\")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(a.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))),this.getQueryTime(e,G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),a=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Y9(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;\"setTimeoutCustom\"in G().platform&&(n=G().platform.setTimeoutCustom.bind(G().platform)),w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ph(this.gl,e,this.framebuffer),this.debug&&sc(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ph(this.gl,this.outputTexture,this.framebuffer),this.debug&&sc(this.gl)):cv(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let a=this.gl;Ph(a,e,this.framebuffer),this.debug&&sc(a),this.outputTexture=e,de(a,()=>a.viewport(0,0,t,n)),de(a,()=>a.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),de(this.gl,()=>this.gl.scissor(e,t,n,a))}throwIfDisposed(){if(this.disposed)throw new Error(\"Attempted to use disposed GPGPUContext.\")}throwIfNoProgram(){if(this.program==null)throw new Error(\"No GPU program is currently set.\")}};function Y9(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Z9,bincountImpl:TA,bincountReduceImpl:J9,bitwiseAndImpl:Q9,castImpl:eQ,ceilImpl:tQ,concatImpl:nQ,equalImpl:aQ,expImpl:rQ,expm1Impl:sQ,floorImpl:iQ,gatherNdImpl:oQ,gatherV2Impl:lQ,greaterImpl:uQ,greaterEqualImpl:pQ,lessImpl:cQ,lessEqualImpl:dQ,linSpaceImpl:hQ,logImpl:mQ,maxImpl:fQ,maximumImpl:gQ,minimumImpl:bQ,multiplyImpl:yQ,negImpl:xQ,notEqualImpl:vQ,prodImpl:wQ,raggedGatherImpl:kQ,raggedRangeImpl:IQ,raggedTensorToTensorImpl:SQ,rangeImpl:NQ,rsqrtImpl:TQ,scatterImpl:CQ,sigmoidImpl:EQ,simpleAbsImpl:CA,sliceImpl:_Q,sparseFillEmptyRowsImpl:AQ,sparseReshapeImpl:FQ,sparseSegmentReductionImpl:EA,sqrtImpl:$Q,staticRegexReplaceImpl:DQ,stridedSliceImpl:RQ,stringNGramsImpl:MQ,stringSplitImpl:OQ,stringToHashBucketFastImpl:PQ,subImpl:LQ,tileImpl:zQ,topKImpl:WQ,transposeImpl:ok,uniqueImpl:BQ}=M1;function _A(e,t){return[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,t).map(n=>`${e}.${n}`)}function In(e,t){return t===1?[e]:_A(e,t)}function VQ(e,t){if(e===1)return\"rc\";let n=\"\";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=\",\");return n}var UQ=class{constructor(e){if(this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=vn(this.outputShape.length),this.rank===0)this.userCode=`\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;else{let t=In(\"rc\",this.rank),n=ht(this.rank),a=this.getOutOfBoundsCondition(t),r=this.getSetup(t),s=this.getOutput(t);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${a}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r=`${n===0?\"r\":\"rp1\"}, ${a===0?\"c\":\"cp1\"}`;for(let s=2;s<this.rank;s++)r=`${e[e.length-1-s]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?\"outShape\":this.outputShape[0]}`;let t=\"\";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+=\"||\");return t}getSetup(e){if(this.rank===1)return\"\";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${a};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?\"outShape\":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},AA=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"inputShape\",type:\"ivec3\"}],this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let n=\"\";for(let a=0;a<4;a++){let r=\"thisRC = rc;\";a%2===1&&(r+=\"thisRC.z += 1;\"),a>1&&(r+=\"thisRC.y += 1;\"),n+=`\n        ${r}\n        ${a>0?\"if(thisRC.y < rows && thisRC.z < cols){\":\"\"}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${a}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${a>0?\"}\":\"\"}\n      `}this.userCode=`\n      ${GQ(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?ek():Q1(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?\"outShape[1]\":e[1]};\n        int cols = ${this.enableShapeUniforms?\"outShape[2]\":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function GQ(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?r9([\"r\",\"c\",\"d\"],\"inputShape\"):Zo([\"r\",\"c\",\"d\"],e)}\n      return ivec3(r, c, d);\n    }\n  `}var HQ=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let a=sS(t,n),r=iS(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let s=rS(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[r].pop();return this.usedTextures[r].push(o),o}let i;return a===cn.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===cn.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===cn.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===cn.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===cn.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,a){if(this.freeTextures==null)return;let r=sS(n,a),s=iS(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);let i=rS(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),o=G().getNumber(\"WEBGL_DELETE_TEXTURE_THRESHOLD\");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error(\"Cannot release a texture that was never provided by this texture manager\");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log(\"Free/Used\",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function jQ(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function rS(e,t,n,a,r){let s=qQ(t,a),i;if(r){let[l,u]=op(e[0],e[1]);i=l*u}else{let[l,u]=_d(e[0],e[1]);i=l*u}let o=jQ(n,s);return i*o}function qQ(e,t){switch(e){case cn.PACKED_2X2_FLOAT32:return sk(t);case cn.PACKED_2X2_FLOAT16:return ik(t);case cn.UNPACKED_FLOAT32:return nk(t);case cn.UNPACKED_FLOAT16:return ak(t);case cn.PACKED_4X1_UNSIGNED_BYTE:return rk(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function KQ(e){return G().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\")?e?cn.PACKED_2X2_FLOAT32:cn.UNPACKED_FLOAT32:e?cn.PACKED_2X2_FLOAT16:cn.UNPACKED_FLOAT16}function sS(e,t){if(e===ca.UPLOAD)return cn.PACKED_2X2_FLOAT32;if(e===ca.RENDER||e==null)return KQ(t);if(e===ca.DOWNLOAD||e===ca.PIXELS)return cn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function iS(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var rr=class{constructor(e,t){this.variableNames=[\"A\"],this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Da=\"if (isnan(x)) return x;\",XQ=\"return x;\",oS=\"return abs(x);\",YQ=\"return (x >= 0.0) ? x : (exp(x) - 1.0);\",ZQ=Da+`\n  return (x < 0.0) ? 0.0 : x;\n`,JQ=Da+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`,Yr=\"return x;\",QQ=\"return 1.0 / (1.0 + exp(-1.0 * x));\",eee=\"return x;\",tee=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`,nee=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,aee=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,ree=\"return 1.0 / (1.0 + exp(-1.0 * x));\",ts=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},see=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let t=e.length,n=In(\"rc\",t),a=ht(t),r=VQ(t,n),s=n.slice(-2),i=t<=1?\"rc\":`vec2(${s.join(\",\")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},iee=mr.whereImpl,oee=1e-7,lee=1e-4,yx={};function uee(e){return e in yx||(yx[e]={}),yx[e]}var pee=G().getNumber(\"CPU_HANDOFF_SIZE_THRESHOLD\"),cee=600;function dee(){return G().global.screen==null?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*cee/1024/1024}var lk=class FA extends Fc{nextDataId(){return FA.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool(\"HAS_WEBGL\"))throw new Error(\"WebGL is not supported on this device\");let n;if(t!=null){if(t instanceof Wh)n=t;else{let a=ja(G().getNumber(\"WEBGL_VERSION\"),t);n=new Wh(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let a=ja(G().getNumber(\"WEBGL_VERSION\"));n=new Wh(a),this.binaryCache=uee(G().getNumber(\"WEBGL_VERSION\")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new HQ(this.gpgpu),this.numMBBeforeWarning=dee(),this.texData=new ym(this,Ta())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,a,r,s,i){let o=this.makeTensorInfo(n,a),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[r,s]},l.texShape=[r,s];let u=ic(n),p=new aS(u,!1,i),d=this.runWebGLProgram(p,[o],a,[[r,s]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,a){if((G().getBool(\"WEBGL_CHECK_NUMERICAL_PROBLEMS\")||G().getBool(\"DEBUG\"))&&this.checkNumericalProblems(t),a===\"complex64\"&&t!=null)throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");let r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:a,values:t,usage:ca.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,a,r,s){if(G().getBool(\"DEBUG\")&&this.checkNumericalProblems(n),r===\"complex64\")throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");this.texData.set(t,{shape:a,dtype:r,values:n,usage:ca.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:a,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let c;l?c=new ts(o,Yr):c=new rr(o,Yr);let h=this.runWebGLProgram(c,[{dataId:t,shape:o,dtype:r}],r),m=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),m}if(a!=null)return this.convertAndCacheOnCPU(t);if(r===\"string\")return a;let u=this.activeTimers!=null,p;u&&(p=w.now());let d;if(r===\"complex64\"){let c=this.readSync(s.real.dataId),h=this.readSync(s.imag.dataId);d=T.mergeRealAndImagArrays(c,h)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=w.now()-p),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let m=this.pendingRead.get(t);return new Promise(f=>m.push(f))}let n=this.texData.get(t),{values:a,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let m;l?m=new ts(r,Yr):m=new rr(r,Yr);let f=this.runWebGLProgram(m,[{dataId:t,shape:r,dtype:i}],i),g=this.read(f.dataId);return this.disposeIntermediateTensorInfo(f),g}if(a!=null)return this.convertAndCacheOnCPU(t);if(G().getBool(\"DEBUG\")&&!G().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")&&G().getNumber(\"WEBGL_VERSION\")===2)throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");let u=null,p;if(i!==\"complex64\"&&G().get(\"WEBGL_BUFFER_SUPPORTED\")){p=this.decode(t);let m=this.texData.get(p.dataId);u=this.gpgpu.createBufferFromTexture(m.texture.texture,...Ah(r))}this.pendingRead.set(t,[]),i!==\"complex64\"&&await this.gpgpu.createAndWaitForFence();let d;if(i===\"complex64\"){let m=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),f=m[0],g=m[1];d=T.mergeRealAndImagArrays(f,g)}else if(u==null)d=this.getValuesFromTexture(t);else{let m=w.sizeFromShape(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,m)}if(p!=null&&this.disposeIntermediateTensorInfo(p),u!=null){let m=this.gpgpu.gl;de(m,()=>m.deleteBuffer(u))}let c=this.convertAndCacheOnCPU(t,d),h=this.pendingRead.get(t);return this.pendingRead.delete(t),h.forEach(m=>m(c)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Ta().removeDataId(t,this),this.pendingDeletes--),c}readToGPU(t,n={}){let a=this.texData.get(t),{values:r,shape:s,slice:i,dtype:o,isPacked:l,texture:u}=a;if(o===\"complex64\")throw new Error(\"Does not support reading texture for complex64 dtype.\");if(i!=null){let h;l?h=new ts(s,Yr):h=new rr(s,Yr);let m=this.runWebGLProgram(h,[{dataId:t,shape:s,dtype:o}],o),f=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),f}if(u==null)throw r!=null?new Error(\"Data is not on GPU but on CPU.\"):new Error(\"There is no data on GPU or CPU.\");let p=this.decode(t,n.customTexShape),d=Ta().makeTensorFromTensorInfo(p),c=this.texData.get(p.dataId);return Object.assign({tensorRef:d},c.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype===\"string\")try{let a=n.map(r=>w.decodeString(r));return Oe(t.shape,t.dtype,a)}catch(a){throw new Error(\"Failed to decode encoded string bytes into utf-8\")}return Oe(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let a=t[n];if(!R_(a))throw G().getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\")?Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${a} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:a,isPacked:r}=this.texData.get(t),s=w.sizeFromShape(n);if(G().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")){let c=this.decode(t),h=this.texData.get(c.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...Ah(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(c),m}let i=G().getBool(\"WEBGL_PACK\")&&r===!0,o=i?ic(n):n,l=i?new q9(o):new j9(o),u=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:t}],\"float32\"),p=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0}time(t){let n=this.activeTimers,a=[],r=!1;this.programTimersStack==null?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,t();let s=w.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=w.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0){let l=await Promise.all(s);o.kernelMs=w.sum(l),o.getExtraProfileInfo=()=>l.map((u,p)=>({name:i[p],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(\", \")}else o.kernelMs={error:\"WebGL query timers are not supported in this environment.\"};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(t){return G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0?(this.gpgpu.endQuery(),t):(t.endMs=w.now(),t)}async getQueryTime(t){if(G().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:a}=this.texData.get(t);return a!=null&&(this.disposeData(a.real.dataId,n),this.disposeData(a.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:a,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(n,r,s,i)));let p=this.texData.get(t);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=pee){return G().getBool(\"WEBGL_CPU_FORWARD\")&&t.every(a=>this.texData.get(a.dataId).texture==null&&w.sizeFromShape(a.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){T.warn(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");let n=t.dataSync();return iee(t.shape,n)}packedUnaryOp(t,n,a){let r=new ts(t.shape,n),s=this.compileAndRun(r,[t],a);return Ta().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!==\"complex64\"){let r=CA(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\"))return this.packedUnaryOp(t,oS,t.dtype);let n=new rr(t.shape,oS),a=this.compileAndRun(n,[t]);return Ta().makeTensorFromTensorInfo(a)}makeTensorInfo(t,n,a){let r;if(n===\"string\"&&a!=null&&a.length>0&&w.isString(a[0])){let s=a.map(i=>w.encodeString(i));r=this.write(s,t,n)}else r=this.write(a,t,n);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:n}}makeOutput(t,n,a){return Ta().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,a),this)}unpackTensor(t){let n=new see(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new UQ(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let a=[vi(t.shape),...wi(t.shape)],r={dtype:t.dtype,shape:a,dataId:t.dataId},s=[vi(n),...wi(n)],i=new AA(s,a),o=!0,l=[a],u=this.runWebGLProgram(i,[r],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){let a=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=a;if(n!=null){let c=w.sizeFromShape(s),h=n[0]*n[1]*4;w.assert(c<=h,()=>\"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.\")}let o=ic(s),l;r?l=new H9(o):l=new G9(o);let u=!0,p=[n!=null?n:Ah(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,p,u,n);return{dtype:i,shape:s,dataId:d.dataId}}runWebGLProgram(t,n,a,r,s=!1,i){let o=this.makeTensorInfo(t.outputShape,a),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Nc.DENSE){let b=i!=null?i:Ah(t.outputShape);l.texShape=b.map(y=>y*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),w.sizeFromShape(o.shape)===0)return l.values=w.getTypedArrayFromDType(o.dtype,0),o;let u=[],p=n.map(b=>{if(b.dtype===\"complex64\")throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");let y=this.texData.get(b.dataId);if(y.texture==null){if(!t.packedInputs&&w.sizeFromShape(b.shape)<=G().getNumber(\"WEBGL_SIZE_UPLOAD_UNIFORM\"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:y.values};t.packedInputs&&(y.isPacked=!0,y.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!y.isPacked!=!!t.packedInputs)b=y.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),y=this.texData.get(b.dataId);else if(y.isPacked&&!Tc(y.shape,b.shape)){let x=b,v=b.shape;b.shape=y.shape,b=this.packedReshape(b,v),u.push(b),y=this.texData.get(b.dataId),x.shape=v}return{shape:b.shape,texData:y,isUniform:!1}});this.uploadToGPU(o.dataId);let d={shape:o.shape,texData:l,isUniform:!1},c=U9(t,p,d),h=this.getAndSaveBinary(c,()=>B9(this.gpgpu,t,p,d)),m=this.activeTimers!=null,f;m&&(f=this.startTimer()),G().get(\"ENGINE_COMPILE_ONLY\")||V9(this.gpgpu,h,p,d,r),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));let g=G().getNumber(\"WEBGL_FLUSH_THRESHOLD\");if(g>0){let b=w.now();b-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!G().getBool(\"WEBGL_LAZILY_UNPACK\")&&l.isPacked&&s===!1){let b=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),b}return o}compileAndRun(t,n,a,r,s=!1){return a=a||n[0].dtype,this.runWebGLProgram(t,n,a,r,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool(\"IS_TEST\")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!=\"undefined\"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=O(()=>{if(!G().get(\"WEBGL_RENDER_FLOAT32_ENABLED\")){let t=G().getBool(\"DEBUG\");G().set(\"DEBUG\",!1);let n=this.abs(xe(1e-8)).dataSync()[0];if(G().set(\"DEBUG\",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?oee:lee}uploadToGPU(t){let n=this.texData.get(t),{shape:a,dtype:r,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let u=this.activeTimers!=null,p;u&&(p=w.now());let d=n.texShape;if(d==null&&(d=Z_(a,l),n.texShape=d),s!=null){let c=ic(a),h,m=d[1],f=d[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([m,f]=op(d[0],d[1])),l?h=new X9(c,g):h=new aS(c,g);let b=g?[f,m]:d,y=this.makeTensorInfo(b,r),x=this.texData.get(y.dataId);g?x.usage=ca.PIXELS:x.usage=ca.UPLOAD,x.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),m,f,s);let v=[[f,m]],I=this.runWebGLProgram(h,[y],r,v,!0),N=this.texData.get(I.dataId);n.texShape=N.texShape,n.isPacked=N.isPacked,n.usage=N.usage,G().get(\"ENGINE_COMPILE_ONLY\")?this.disposeData(I.dataId):(n.texture=N.texture,n.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(y),u&&(this.uploadWaitMs+=w.now()-p)}else{let c=this.acquireTexture(d,o,r,l);n.texture=c}}convertAndCacheOnCPU(t,n){let a=this.texData.get(t),{dtype:r}=a;return n!=null&&(a.values=hee(n,r)),a.values}acquireTexture(t,n,a,r){if(this.numBytesInGPU+=this.computeBytes(t,a),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,r)}computeBytes(t,n){return t[0]*t[1]*w.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let a=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(s){throw s}});t.push(a)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Zw(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(J1(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error(\"Failed to compile fragment shader.\")):new Error(\"Failed to link vertex and fragment shaders.\");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:a,infLoc:r,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=lA(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=a,t.infLoc=r,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,a){t.channels=t.channels||\"RGBA\";let{texture:r,height:s,width:i,channels:o}=t,l=Ta().backend;if(!l.gpgpu.gl.isTexture(r))throw new Error(\"The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.\");let u=l.writeTexture(r,n,a,s,i,o);return Ta().makeTensorFromDataId(u,n,a,l)}};lk.nextDataId=0;function hee(e,t){if(t===\"float32\"||t===\"complex64\")return e;if(t===\"int32\"||t===\"bool\"){let n=t===\"int32\"?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<n.length;++a)n[a]=Math.round(e[a]);return n}else throw new Error(`Unknown dtype ${t}`)}var mee=\"4.22.0\";function $A(){G().set(\"WEBGL_FORCE_F16_TEXTURES\",!0)}ad.isBrowser()&&Om(\"webgl\",()=>new lk,2);var fee={forceHalfFloat:$A},uk=`\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`,ki=class{constructor(e,t,n){this.variableNames=[\"A\",\"B\"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=vn(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},Qo=`\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n`,hp=class{constructor(e,t,n,a=!1){this.variableNames=[\"A\",\"B\"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=T.assertAndGetBroadcastShape(t,n);let r=this.outputShape.length;this.enableShapeUniforms=vn(r);let s=\"\";if(a)if(r===0||w.sizeFromShape(this.outputShape)===1)s=`\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;else if(s=`\n          ${ht(r)} coords = getOutputCoords();\n        `,r===1)this.enableShapeUniforms?s+=`\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `:s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let i=In(\"coords\",r);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${i[r-2]} + 1) >= outShape[${r} - 2];\n            bool nextColOutOfBounds =\n              (${i[r-1]} + 1) >= outShape[${r} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${i[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${i[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function ta(e){let{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var gee={kernelName:eo,backendName:\"webgl\",kernelFunc:ta};function $s(e){let{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,\"complex64\"),i=n.texData.get(s.dataId),o=ta({inputs:{x:a},backend:n}),l=ta({inputs:{x:r},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var bee={kernelName:wm,backendName:\"webgl\",kernelFunc:$s},DA=\"return (a < 0.) ? b * a : a;\",RA=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function yee(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,i=n.makeTensorInfo([],\"float32\",w.createScalarValue(s,\"float32\")),o=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?new hp(RA,r.shape,i.shape):new ki(DA,r.shape,i.shape),l=n.runWebGLProgram(o,[r,i],\"float32\");return n.disposeIntermediateTensorInfo(i),l}var xee={kernelName:ro,backendName:\"webgl\",kernelFunc:yee},MA=\"return (a < 0.) ? b * a : a;\",OA=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;function vee(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?new hp(OA,a.shape,r.shape):new ki(MA,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],\"float32\")}var wee={kernelName:wo,backendName:\"webgl\",kernelFunc:vee},mp=\"if (isnan(x)) return x;\";function Ze({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:r,backend:s})=>{let{x:i}=r,o=s,l=a||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let d=o.texData.get(i.dataId),c=n(d.values,l);return o.makeTensorInfo(i.shape,l,c)}let u=G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")&&t!=null,p;return u?p=new ts(i.shape,t):p=new rr(i.shape,e),o.runWebGLProgram(p,[i],l)}}function hn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:a=!1,cpuKernelImpl:r,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,p=o;if(a&&l.dtype===\"complex64\"){let m=p.texData.get(l.dataId),f=p.texData.get(u.dataId),[g,b]=[[m.complexTensorInfos.real,f.complexTensorInfos.real],[m.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(x=>{let[v,I]=x,N={dataId:v.dataId,dtype:v.dtype,shape:l.shape},C={dataId:I.dataId,dtype:I.dtype,shape:u.shape},_=new ki(e,l.shape,u.shape);return p.runWebGLProgram(_,[N,C],fa(v.dtype,I.dtype))}),y=$s({inputs:{real:g,imag:b},backend:p});return p.disposeIntermediateTensorInfo(g),p.disposeIntermediateTensorInfo(b),y}let d=s||fa(l.dtype,u.dtype);if((l.dtype===\"string\"||u.dtype===\"string\"||p.shouldExecuteOnCPU([l,u]))&&r!=null){let m=p.texData.get(l.dataId).values,f=p.texData.get(u.dataId).values,g=l.dtype===\"string\"?T.fromUint8ToStringArray(m):m,b=l.dtype===\"string\"?T.fromUint8ToStringArray(f):f,[y,x]=r(l.shape,u.shape,g,b,d),v=p.makeTensorInfo(x,d),I=p.texData.get(v.dataId);return I.values=y,v}let c=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")&&t!=null,h;return c?h=new hp(t,l.shape,u.shape,n):h=new ki(e,l.shape,u.shape),p.runWebGLProgram(h,[l,u],d)}}function Cc(e,t=!1){if(e===\"linear\")return t?eee:XQ;if(e===\"relu\")return t?nee:ZQ;if(e===\"elu\")return t?tee:YQ;if(e===\"relu6\")return t?aee:JQ;if(e===\"prelu\")return t?OA:MA;if(e===\"leakyrelu\")return t?RA:DA;if(e===\"sigmoid\")return t?ree:QQ;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var PA=class{constructor(e,t,n,a=!1,r=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=[\"matrixA\",\"matrixB\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=vn(this.outputShape.length);let u=a?e[1]:e[2],p=Math.ceil(u/2),d=a?\"i * 2, rc.y\":\"rc.y, i * 2\",c=r?\"rc.z, i * 2\":\"i * 2, rc.z\",h=a?[\"a.xxyy\",\"a.zzww\"]:[\"a.xxzz\",\"a.yyww\"],m=r?[\"b.xzxz\",\"b.ywyw\"]:[\"b.xyxy\",\"b.zwzw\"],f=\"\",g=\"\";i&&(o?f=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?f=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:f=`vec4 activation(vec4 x) {\n          ${i}\n        }`,g=\"result = activation(result);\");let b=s?\"result += getBiasAtOutCoords();\":\"\";s&&this.variableNames.push(\"bias\"),o&&this.variableNames.push(\"preluActivationWeights\"),l&&this.variableNames.push(\"leakyreluAlpha\");let y=\"rc.x\",x=\"rc.x\";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${f}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${x};\n        for (int i = 0; i < ${p}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${m[0]});\n          result += (${h[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},lS={REAL:\"return areal * breal - aimag * bimag;\",IMAG:\"return areal * bimag + aimag * breal;\"},uS=class{constructor(e,t,n){this.variableNames=[\"AReal\",\"AImag\",\"BReal\",\"BImag\"],this.outputShape=T.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},pS=\"return a * b;\";function pk(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=T.upcastType(a.dtype,r.dtype);if(a.dtype===\"complex64\"){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),u=new uS(lS.REAL,a.shape,r.shape),p=new uS(lS.IMAG,a.shape,r.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:a.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(u,d,\"float32\"),h=n.runWebGLProgram(p,d,\"float32\"),m=$s({inputs:{real:c,imag:h},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),m}if(n.shouldExecuteOnCPU([a,r])){let o=n.texData.get(a.dataId),l=n.texData.get(r.dataId),[u,p]=yQ(a.shape,r.shape,o.values,l.values,s),d=n.makeTensorInfo(p,s),c=n.texData.get(d.dataId);return c.values=u,d}let i;return G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?i=new hp(pS,a.shape,r.shape):i=new ki(pS,a.shape,r.shape),n.runWebGLProgram(i,[a,r],s)}var kee={kernelName:bo,backendName:\"webgl\",kernelFunc:pk};function Iee(e,t,n){let a=[vi(e.shape),...wi(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[vi(t),...wi(t)],i=new AA(s,a),o=!0,l=[a],u=n.runWebGLProgram(i,[r],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function ce(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,i=n,o=w.sizeFromShape(r.shape),l=w.inferFromImplicitShape(s,o),u=w.sizeFromShape(l);w.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let p=i.texData.get(r.dataId);return p.isPacked&&!Tc(r.shape,l)&&!(p.texture!==null&&Tc(p.shape,l))?Iee(r,l,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}var See={kernelName:Ru,backendName:\"webgl\",kernelFunc:ce},cS=class{constructor(e,t){this.variableNames=[\"x\"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=Math.floor(n/4)*4,o=n%4,l=\"sumValue += dot(values, ones);\";if(t!=null){let p=1/t;l=`sumValue += dot(values * ${w.isInt(p)?p.toPrecision(2):p}, ones);`}let u=\"\";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${o===1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${o===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${o===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},Nee=class{constructor(e,t){this.variableNames=[\"x\"];let{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let i=\"0.0\",o=\"\";t===\"prod\"?i=\"1.0\":t===\"min\"?(i=\"1.0 / 1e-20\",o=\"min\"):t===\"max\"&&(i=\"-1.0 / 1e-20\",o=\"max\");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===\"sum\"?l=\"sumValue\":t===\"prod\"?l=\"prodValue\":t===\"all\"?l=\"allValue\":t===\"any\"&&(l=\"anyValue\");let u=Math.floor(n/4)*4,p=n%4,d=`\n      if (${t===\"sum\"}) {\n        sumValue += dot(values, ones);\n      } else if (${t===\"prod\"}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${t===\"min\"} || ${t===\"max\"}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,c=\"vec4\";t===\"all\"?(i=\"1.0\",d=`\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `,c=\"bvec4\"):t===\"any\"&&(i=\"0.0\",d=`\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `,c=\"bvec4\");let h=\"\";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${p===1}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${p===2}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${p===3}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function Tee(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],a=T.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}function el(e,t,n,a){let r=Tee(e.shape),s=e;for(let i=0;i<r.length;i++){let{inSize:o,windowSize:l,outSize:u}=r[i],p,d;n===\"mean\"?p=i===0?new cS({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new cS({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):p=new Nee({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=s,s=a.runWebGLProgram(p,[s],t),d.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(d)}return s}var Cee=class{constructor(e,t){this.variableNames=[\"A\"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let a=ht(this.rank),r=Eee(t);this.userCode=`\n    void main() {\n      ${a} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}};function Eee(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\",\"resRC.u\",\"resRC.v\"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}var _ee=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let a=ht(this.rank),r=_A(\"rc\",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=r[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function Bf(e,t,n){let a=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new _ee(e.shape,t):new Cee(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function Aee(e,t,n,a){let r=t,s=e.shape.length,i=w.parseAxisParam(r,e.shape),o=i,l=T.getAxesPermutation(o,s),u=l!=null,p=e;u&&(p=Bf(e,l,a),o=T.getInnerMostAxes(o.length,s)),T.assertAxesAreInnerMostDims(\"sum\",o,s);let[d,c]=T.computeOutAndReduceShapes(p.shape,o),h=d;n&&(h=T.expandShapeToKeepDim(d,i));let m=w.sizeFromShape(c),f=w.sizeFromShape(e.shape)/m,g=ce({inputs:{x:p},attrs:{shape:[f,m]},backend:a}),b=Mm(e.dtype),y=el(g,b,\"sum\",a),x=ce({inputs:{x:y},attrs:{shape:h},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(y),u&&a.disposeIntermediateTensorInfo(p),x}function Vf(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a;return Aee(r,s,i,n)}var Fee={kernelName:Lo,backendName:\"webgl\",kernelFunc:Vf};function Sn(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,i=n,o=r.shape.length,l=new Array(o);for(let p=0;p<l.length;p++)l[p]=r.shape[s[p]];let u;if(i.shouldExecuteOnCPU([r])){let p=i.texData.get(r.dataId).values,d=ok(p,r.shape,r.dtype,s,l);u=i.makeTensorInfo(l,r.dtype);let c=i.texData.get(u.dataId);c.values=d}else u=Bf(r,s,i);return u}var $ee={kernelName:Cr,backendName:\"webgl\",kernelFunc:Sn},LA=1e3;function hm({a:e,b:t,transposeA:n,transposeB:a,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,p=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],c=a?t.shape[p-1]:t.shape[p-2],h=n?e.shape[u-1]:e.shape[u-2],m=a?t.shape[p-2]:t.shape[p-1],f=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=w.sizeFromShape(f),y=w.sizeFromShape(g),x=Ju.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,m]);w.assert(d===c,()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);let v=n?[b,d,h]:[b,h,d],I=a?[y,m,c]:[y,c,m],N=ce({inputs:{x:e},backend:r,attrs:{shape:v}}),C=ce({inputs:{x:t},backend:r,attrs:{shape:I}}),_=[N,C],F=Math.max(b,y),D=n?N.shape[1]:N.shape[2],$=s!=null,S=i!=null,M=l===\"leakyrelu\",B=l!=null?Cc(l,!0):null,U=$||S||M||B!=null,H;if((h===1||m===1)&&D>LA&&U===!1){let K=N,Z=C;n&&(K=Sn({inputs:{x:N},backend:r,attrs:{perm:[0,2,1]}}),_.push(K)),a&&(Z=Sn({inputs:{x:C},backend:r,attrs:{perm:[0,2,1]}}),_.push(Z));let J=m!==1,ee=m===1,ae=K;J&&(ae=ce({inputs:{x:K},backend:r,attrs:{shape:[F,D,1]}}),_.push(ae));let te=m===1?2:1,se=Z;ee&&(se=ce({inputs:{x:Z},backend:r,attrs:{shape:[F,1,D]}}),_.push(se));let ie=pk({inputs:{a:ae,b:se},backend:r});H=Vf({inputs:{x:ie},backend:r,attrs:{axis:te,keepDims:!0}}),_.push(ie)}else{let K=fa(e.dtype,t.dtype),Z=new PA(v,I,[F,h,m],n,a,$,B,S,M),J=[N,C];if(s!=null&&J.push(s),S&&J.push(i),M){let ee=r.makeTensorInfo([],\"float32\",w.createScalarValue(o,\"float32\"));J.push(ee),_.push(ee)}H=r.runWebGLProgram(Z,J,K)}let q=ce({inputs:{x:H},backend:r,attrs:{shape:x}});_.push(H);for(let K of _)r.disposeIntermediateTensorInfo(K);return q}function Dee(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=a;return hm({a:r,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:p})}var Ree={kernelName:ii,backendName:\"webgl\",kernelFunc:Dee},dS=\"return abs(x);\";function Mee(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&a.dtype!==\"complex64\"){let s=n.texData.get(a.dataId),i=CA(s.values);return n.makeTensorInfo(a.shape,a.dtype,i)}let r;return G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")?r=new ts(a.shape,dS):r=new rr(a.shape,dS),n.runWebGLProgram(r,[a],a.dtype)}var Oee={kernelName:Yl,backendName:\"webgl\",kernelFunc:Mee},Pee=Da+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n`,Lee=Ze({opSnippet:Pee}),zee={kernelName:Ni,backendName:\"webgl\",kernelFunc:Lee},Wee=Da+`\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));`,Bee=Ze({opSnippet:Wee}),Vee={kernelName:Ti,backendName:\"webgl\",kernelFunc:Bee},hS=\"return a + b;\",Uee=hn({opSnippet:hS,packedOpSnippet:hS,supportsComplex:!0,cpuKernelImpl:Z9}),Gee={kernelName:vs,backendName:\"webgl\",kernelFunc:Uee},Hee=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`float v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(\" + \");this.userCode=`\n      void main() {\n        ${n.join(`\n        `)}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}},jee=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let n=[];this.variableNames.forEach(r=>{n.push(`vec4 v${r} = get${r}AtOutCoords();`)});let a=this.variableNames.map(r=>`v${r}`).join(\" + \");this.userCode=`\n      void main() {\n        ${n.join(`\n        `)}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}};function Bh(e){let{inputs:t,backend:n}=e,a=t;if(a.length===1)return ta({inputs:{x:a[0]},backend:n});if(a.length>G().getNumber(\"WEBGL_MAX_TEXTURES_IN_SHADER\")){let o=Math.floor(a.length/2),l=Bh({inputs:a.slice(0,o),backend:n}),u=Bh({inputs:a.slice(o),backend:n});return Bh({inputs:[l,u],backend:n})}let r=a.map(o=>o.dtype).reduce((o,l)=>fa(o,l)),s=a.map(o=>o.shape),i=G().getBool(\"WEBGL_PACK\")?new jee(a[0].shape,s):new Hee(a[0].shape,s);return n.runWebGLProgram(i,a,r)}var qee={kernelName:Ci,backendName:\"webgl\",kernelFunc:Bh};function Kee(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,o)),T.assertAxesAreInnerMostDims(\"all\",u,o);let[c,h]=T.computeOutAndReduceShapes(d.shape,u),m=w.sizeFromShape(h),f=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=el(f,f.dtype,\"all\",n),b;if(i){let y=T.expandShapeToKeepDim(c,l);b=ce({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=ce({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(d),b}var Xee={kernelName:Zl,backendName:\"webgl\",kernelFunc:Kee};function Yee(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,o)),T.assertAxesAreInnerMostDims(\"any\",u,o);let[c,h]=T.computeOutAndReduceShapes(d.shape,u),m=w.sizeFromShape(h),f=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=el(f,f.dtype,\"any\",n),b;if(i){let y=T.expandShapeToKeepDim(c,l);b=ce({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=ce({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(d),b}var Zee={kernelName:Jl,backendName:\"webgl\",kernelFunc:Yee},Jee=class{constructor(e,t,n){this.variableNames=[\"A\"];let{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push(\"bestIndicesA\"),this.outputShape=[r,s];let i=t===\"max\"?\">\":\"<\",o=n?\"inOffset + i;\":\"round(getBestIndicesA(batch, inOffset + i));\";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},Qee=class{constructor(e,t,n,a){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push(\"bestIndicesA\");let i=this.outputShape,o=i.length,l=ht(o),u=In(\"coords\",o),p,d;if(s===1){d=o+1;let C=ht(d);p=`\n        ${C} sourceLocR = ${C}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${C} sourceLocG = ${C}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${C} sourceLocA = ${C}(${u.join()}, 0);\n        --${u[o-1]};\n        ${C} sourceLocB = ${C}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,p=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;let c=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,d),h=\".\"+c[d-1],m=c.map(C=>\"int \"+C),f=In(\"sourceLocR\",d-1).concat(\"inIdx.r\"),g=In(\"sourceLocG\",d-1).concat(\"inIdx.g\"),b=In(\"sourceLocB\",d-1).concat(\"inIdx.b\"),y=In(\"sourceLocA\",d-1).concat(\"inIdx.a\"),x=n===\"max\"?\"greaterThan\":\"lessThan\",v=a?\"\":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,I=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,N=a?\"\":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${c.join()}),\n                                          vec2(${c.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${c.join()}),\n                               vec2(${c.slice(-2).join()}));\n      }\n      ${N}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function zA(e,t,n,a=null){let r=t.shape[0],s=t.shape[1];a!=null&&(r=a.shape[0],s=a.shape[1]);let i=T.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:r,outSize:Math.ceil(s/i)},l=new Jee(o,n,a==null),u=[t];a!=null&&u.push(a);let p=e.runWebGLProgram(l,u,\"int32\");if(p.shape[1]===1)return p;let d=zA(e,t,n,p);return e.disposeIntermediateTensorInfo(p),d}function WA(e,t,n,a=null){let r=a!=null?a.shape:t.shape,s=r[r.length-1],i=T.computeOptimalWindowSize(s),o=new Qee(r,i,n,a==null),l=a==null?[t]:[t,a],u=e.runWebGLProgram(o,l,\"int32\");if(u.shape.length===t.shape.length){let p=WA(e,t,n,u);return e.disposeIntermediateTensorInfo(u),p}return u}function BA(e,t,n,a){let r=[n];if(T.assertAxesAreInnerMostDims(\"arg\"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!G().getBool(\"WEBGL_PACK_REDUCE\")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[u,p]=T.computeOutAndReduceShapes(l.shape,r),d=w.sizeFromShape(p),c=ce({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});s.push(c);let h=zA(e,c,a);s.push(h);let m=ce({inputs:{x:h},backend:e,attrs:{shape:u}});return s.forEach(f=>e.disposeIntermediateTensorInfo(f)),m}return WA(e,t,a)}function ete(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Sn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims(\"argMax\",[i[0]],l.shape.length);let p=BA(n,l,i[0],\"max\");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),p}var tte={kernelName:Ql,backendName:\"webgl\",kernelFunc:ete};function nte(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a,i=w.parseAxisParam(s,r.shape),o=T.getAxesPermutation(i,r.shape.length),l=r,u=[];o!=null&&(l=Sn({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),i=T.getInnerMostAxes(i.length,l.shape.length)),T.assertAxesAreInnerMostDims(\"argMin\",[i[0]],l.shape.length);let p=BA(n,l,i[0],\"min\");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),p}var ate={kernelName:eu,backendName:\"webgl\",kernelFunc:nte},rte=Da+`\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n`,ste=Ze({opSnippet:rte}),ite={kernelName:Ei,backendName:\"webgl\",kernelFunc:ste},ote=Da+\"return log(x + sqrt(x * x + 1.0));\",lte=Ze({opSnippet:ote}),ute={kernelName:_i,backendName:\"webgl\",kernelFunc:lte},pte=Da+`\n  return atan(x);\n`,cte=Ze({opSnippet:pte}),dte={kernelName:Ai,backendName:\"webgl\",kernelFunc:cte},hte=uk+`\n  return atan(a, b);\n`,mte=`\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+Qo+`\n  return result;\n`,fte=hn({opSnippet:hte,packedOpSnippet:mte}),gte={kernelName:$i,backendName:\"webgl\",kernelFunc:fte},bte=Da+`\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;`,yte=Ze({opSnippet:bte}),xte={kernelName:Fi,backendName:\"webgl\",kernelFunc:yte},Ec=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=[\"x\"],t===\"avg\"&&n)throw new Error(\"Cannot compute positions for average pool.\");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let m=t===\"avg\",f=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=\"0.0\";if(m||(b=\"-1.0 / 1e-20\"),n){let C=\">=\";this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${c}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${C} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${a?r?f:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}let y=\"max\",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===\"avg\"&&(x=\"avgValue / max(count, 1.0)\");let v=Math.floor(s/4)*4,I=s%4,N=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${y}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${N}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${I===1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${N}\n          } else if (${I===2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${N}\n          } else if (${I===3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${N}\n          }\n        }\n        setOutput(${x});\n      }\n    `}},ck=class{constructor(e,t,n,a=!1,r=!1){if(this.variableNames=[\"x\"],t===\"avg\"&&n)throw new Error(\"Cannot compute positions for average pool.\");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,p=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let y=t===\"avg\",x=\"0.0\";if(y||(x=\"-1.0 / 1e-20\"),n){let F=\">=\";this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${f}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${c};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${F} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${a?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;return}let v=\"max\",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===\"avg\"&&(I=\"avgValue / max(count, 1.0)\");let N=Math.floor(s/4)*4,C=s%4,_=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${v}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${f}, ${g}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${N}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${N};\n            if (${C===1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${C===2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${C===3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n        }\n        setOutput(${I});\n      }\n    `}};function vte(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;lp(r,\"avgPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l);if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))return ta({inputs:{x:r},backend:n});let d=new Ec(p,\"avg\",!1);return n.runWebGLProgram(d,[r],\"float32\")}var wte={kernelName:Di,backendName:\"webgl\",kernelFunc:vte};function kte(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,p=[1,1,1],d=T.computePool3DInfo(r.shape,s,i,p,o,l,u),c=new ck(d,\"avg\",!1);return n.runWebGLProgram(c,[r],\"float32\")}var Ite={kernelName:tu,backendName:\"webgl\",kernelFunc:kte},Ste=class{constructor(e){this.variableNames=[\"dy\"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,p=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${p});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Nte=class{constructor(e){this.variableNames=[\"dy\"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=p-1-e.padInfo.front,m=d-1-e.padInfo.top,f=c-1-e.padInfo.left,g=1/(t*n*a);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${m}, ${f});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function Tte(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=a,d=[1,1,1],c=T.computePool3DInfo(i.shape,o,l,d,u,p),h=new Nte(c);return n.runWebGLProgram(h,[r],i.dtype)}var Cte={kernelName:Rc,backendName:\"webgl\",kernelFunc:Tte};function Ete(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s;lp([r,s],\"avgPoolGrad\");let{filterSize:o,strides:l,pad:u}=a,p=T.computePool2DInfo(i.shape,o,l,1,u),d=new Ste(p);return n.runWebGLProgram(d,[r],i.dtype)}var _te={kernelName:Dc,backendName:\"webgl\",kernelFunc:Ete};function Ate(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;return hm({a:r,b:s,transposeA:i,transposeB:o,backend:n})}var Fte={kernelName:Ri,backendName:\"webgl\",kernelFunc:Ate},$te=class{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=[\"x\",\"mean\",\"variance\"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i=\"0.0\";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push(\"offset\"),i=\"getOffsetAtOutCoords()\");let o=\"1.0\";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push(\"scale\"),o=\"getScaleAtOutCoords()\"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},Dte=class{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=[\"x\",\"mean\",\"variance\"],T.assertAndGetBroadcastShape(e,t),T.assertAndGetBroadcastShape(e,n);let i=\"vec4(0.0)\";a!=null&&(T.assertAndGetBroadcastShape(e,a),this.variableNames.push(\"offset\"),i=\"getOffsetAtOutCoords()\");let o=\"vec4(1.0)\";r!=null&&(T.assertAndGetBroadcastShape(e,r),this.variableNames.push(\"scale\"),o=\"getScaleAtOutCoords()\"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},Rte=({inputs:e,backend:t,attrs:n})=>{let{x:a,mean:r,variance:s,offset:i,scale:o}=e;w.assert(r.shape.length===s.shape.length,()=>\"Batch normalization gradient requires mean and variance to have equal ranks.\"),w.assert(i==null||r.shape.length===i.shape.length,()=>\"Batch normalization gradient requires mean and offset to have equal ranks.\"),w.assert(o==null||r.shape.length===o.shape.length,()=>\"Batch normalization gradient requires mean and scale to have equal ranks.\");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[a,r,s],p=null;i!=null&&(p=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));let c=G().getBool(\"WEBGL_PACK_NORMALIZATION\")?new Dte(a.shape,r.shape,s.shape,p,d,l):new $te(a.shape,r.shape,s.shape,p,d,l);return t.runWebGLProgram(c,u,u[0].dtype)},Mte={kernelName:Ji,backendName:\"webgl\",kernelFunc:Rte},Ote=class{constructor(e){this.variableNames=[\"source\"],this.outputShape=e,this.rank=e.length;let t=ht(this.rank);this.customUniforms=[{name:\"start\",arrayIndex:this.rank,type:\"int\"}];let n=Pte(this.rank),a,r=e.map((s,i)=>`sourceLoc.${mv[i]} = start[${i}] + coords.${mv[i]};`);a=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${r.join(`\n`)}\n      `,this.userCode=`\n      void main() {\n        ${a}\n        setOutput(getSource(${n}));\n      }\n    `}},mv=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];function Pte(e){if(e===1)return\"sourceLoc\";if(e<=6)return mv.slice(0,e).map(t=>\"sourceLoc.\"+t).join(\",\");throw Error(`Slicing for rank ${e} is not yet supported`)}var Lte=class{constructor(e){this.variableNames=[\"source\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:\"start\",arrayIndex:this.rank,type:\"int\"}];let t=ht(this.rank),n=In(\"coords\",this.rank),a=In(\"sourceLoc\",this.rank),r=this.rank===1?\"sourceLoc\":`vec2(${a.slice(-2).join()})`,s=`getChannel(getSource(${a.join()}), ${r})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${s};\n        --${a[this.rank-1]};\n      }\n    `,o=this.rank===1?\"\":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((u,p)=>`start[${p}]`).join()});`:e.map((u,p)=>`${a[p]} = ${n[p]} + start[${p}];`).join(`\n`);this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function zte(e,t,n,a){let r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),i=a.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Kt.computeFlatOffset(t,w.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let l=a.dataRefCount.get(i.slice.origDataId)||1;return a.dataRefCount.set(i.slice.origDataId,l+1),s}function fp(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:i}=a,[o,l]=Kt.parseSliceParams(r,s,i);if(Kt.assertParamsValid(r,o,l),w.sizeFromShape(l)===0)return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype===\"string\"){let d=n.texData.get(r.dataId),c=_Q(d.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,c)}let{isPacked:u}=n.texData.get(r.dataId),p=Kt.isSliceContinous(r.shape,o,l);if(u||!p){let d=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new Lte(l):new Ote(l),c=[o];return n.runWebGLProgram(d,[r],r.dtype,c)}return n.uploadToGPU(r.dataId),zte(r,o,l,n)}var Wte={kernelName:Bu,backendName:\"webgl\",kernelFunc:fp},Bte=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a;w.assert(r.shape.length<=4,()=>\"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\");let o=s.reduce((y,x)=>y*x),l=T.getReshaped(r.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(r.shape,s,o),d=T.getSliceBeginCoords(i,s.length),c=T.getSliceSize(p,i,s.length),h=[],m=ce({inputs:{x:r},backend:n,attrs:{shape:l}}),f=Sn({inputs:{x:m},backend:n,attrs:{perm:u}}),g=ce({inputs:{x:f},backend:n,attrs:{shape:p}}),b=fp({inputs:{x:g},backend:n,attrs:{begin:d,size:c}});return h.push(m),h.push(f),h.push(g),h.forEach(y=>n.disposeIntermediateTensorInfo(y)),b},Vte={kernelName:nu,backendName:\"webgl\",kernelFunc:Bte};function Ute(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i}=a,o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=TA(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var Gte={kernelName:au,backendName:\"webgl\",kernelFunc:Ute},Hte=`\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n`,jte=`\n  return float(int(a.r) & int(b.r));\n`;function qte(e){let{inputs:t,backend:n}=e,{a,b:r}=t,s=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\"),i=G().getNumber(\"WEBGL_VERSION\");if(n.shouldExecuteOnCPU([a,r])||i===1){let l=n.texData.get(a.dataId).values,u=n.texData.get(r.dataId).values,[p,d]=Q9(a.shape,r.shape,l,u,a.dtype),c=n.makeTensorInfo(d,a.dtype),h=n.texData.get(c.dataId);return h.values=p,c}let o;return s?o=new hp(Hte,a.shape,r.shape,!1):o=new ki(jte,a.shape,r.shape),n.runWebGLProgram(o,[a,r],a.dtype)}var Kte={kernelName:ru,backendName:\"webgl\",kernelFunc:qte};function Xte(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),i=n.readSync(r.dataId),o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],\"int32\",Int32Array.from(o))}var Yte={kernelName:Mc,backendName:\"webgl\",kernelFunc:Xte},Zte=\"return float(a != b);\",VA=hn({opSnippet:Zte,cpuKernelImpl:vQ,dtype:\"bool\"}),Jte={kernelName:Eu,backendName:\"webgl\",kernelFunc:VA};function Fd(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return ta({inputs:{x:r.complexTensorInfos.real},backend:n})}var Qte={kernelName:Dm,backendName:\"webgl\",kernelFunc:Fd},ene=\"return float(int(x));\";function tne(e,t){let n=new rr(e.shape,ene),a=t.runWebGLProgram(n,[e],\"int32\");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}function fv(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if(s===\"complex64\"){if(r.dtype===\"complex64\")return ta({inputs:{x:r},backend:n});let i=It(r.shape),o=fv({inputs:{x:r},backend:n,attrs:{dtype:\"float32\"}}),l=$s({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(r.dtype===\"complex64\"){let i=Fd({inputs:{input:r},backend:n}),o=fv({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!w.hasEncodingLoss(r.dtype,s)){let i=ta({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([r])){let i=n.texData.get(r.dataId).values,[o,l,u]=eQ(i,r.shape,r.dtype,s);return n.makeTensorInfo(o,l,u)}if(s===\"int32\")return tne(r,n);if(s===\"bool\"){let i=n.makeTensorInfo([],\"bool\",w.getTypedArrayFromDType(\"bool\",1)),o=VA({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var nne={kernelName:Mi,backendName:\"webgl\",kernelFunc:fv},mS=\"return ceil(x);\",ane=Ze({opSnippet:mS,packedOpSnippet:mS,cpuKernelImpl:tQ}),rne={kernelName:Oi,backendName:\"webgl\",kernelFunc:ane},sne=class{constructor(e){this.variableNames=[\"A\"],this.customUniforms=[{name:\"minVal\",type:\"float\"},{name:\"maxVal\",type:\"float\"}],this.outputShape=e,this.userCode=`\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `}},ine=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"minVal\",type:\"float\"},{name:\"maxVal\",type:\"float\"}],this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `}};function one(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o;G().getBool(\"WEBGL_PACK_CLIP\")?o=new ine(r.shape):o=new sne(r.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[r],r.dtype,l)}var lne={kernelName:ws,backendName:\"webgl\",kernelFunc:one},une=class{constructor(e){this.variableNames=[\"real\",\"imag\"],this.outputShape=e,this.userCode=`\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `}};function fS(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function pne(e){let{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new une(a.shape),i=[fS(a,r.complexTensorInfos.real),fS(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var cne={kernelName:Oc,backendName:\"webgl\",kernelFunc:pne},dne=class{constructor(e){this.outputShape=[],this.outputShape=T.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let a=t.length,r=t[t.length-1];n.push(`else setOutput(getT${a}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join(`\n        `)}\n      }\n    `}},hne=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=T.computeOutShape(e,t);let n=this.outputShape,a=n.length,r=ht(a),s=In(\"coords\",a),i=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,a);this.variableNames=e.map((m,f)=>`T${f}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let m=1;m<o.length;m++)o[m]=o[m-1]+e[m][t];let l=i[t],u=i.slice(-2),p=i.join(),d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${u.join()}));\n        }`;for(let m=1;m<o.length;m++){let f=o[m-1];d+=`\n        if (${l} < ${o[m]}  && ${l} >= ${o[m-1]}) {\n          return getChannel(\n            getT${m}(${$h(i,l,f)}),\n            vec2(${$h(u,l,f)}));\n        }`}let c=o.length,h=o[o.length-1];d+=`\n        return getChannel(\n          getT${c}(${$h(i,l,h)}),\n          vec2(${$h(u,l,h)}));`,this.userCode=`\n      float getValue(${i.map(m=>\"int \"+m)}) {\n        ${d}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[a-1]} = ${s[a-1]} + 1;\n        if (${s[a-1]} < ${n[a-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[a-2]} = ${s[a-2]} + 1;\n        if (${s[a-2]} < ${n[a-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[a-1]} = ${s[a-1]} - 1;\n        if (${s[a-2]} < ${n[a-2]} &&\n            ${s[a-1]} < ${n[a-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function $h(e,t,n){let a=e.indexOf(t);return e.map((r,s)=>s===a?`${r} - ${n}`:r).join()}function Uf(e){let{inputs:t,backend:n}=e,{input:a}=t,r=n.texData.get(a.dataId);return ta({inputs:{x:r.complexTensorInfos.imag},backend:n})}var mne={kernelName:_m,backendName:\"webgl\",kernelFunc:Uf};function oc(e,t,n){let a=e[0].dtype;if(a===\"complex64\"){let h=e.map(y=>Fd({inputs:{input:y},backend:n})),m=e.map(y=>Uf({inputs:{input:y},backend:n})),f=oc(h,t,n),g=oc(m,t,n),b=$s({inputs:{real:f,imag:g},backend:n});return h.forEach(y=>n.disposeIntermediateTensorInfo(y)),m.forEach(y=>n.disposeIntermediateTensorInfo(y)),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),b}let r=n.shouldExecuteOnCPU(e);if(a===\"string\"&&(r=!0),r){let h=e.map(v=>{let I=[-1,w.sizeFromShape(v.shape.slice(t))];return ce({inputs:{x:v},backend:n,attrs:{shape:I}})}),m=h.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),f=T.computeOutShape(h.map(v=>v.shape),1),g=h[0].shape[0]===1,b=nQ(m,f,a,g),y=T.computeOutShape(e.map(v=>v.shape),t),x=n.makeTensorInfo(y,a,b);return h.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}let s=e.filter(h=>w.sizeFromShape(h.shape)>0),i=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")&&s[0].shape.length>1;if(s.length===1){let h=i?new rr(e[0].shape,Yr):new ts(e[0].shape,Yr);return n.runWebGLProgram(h,e,a)}let o=G().getNumber(\"WEBGL_MAX_TEXTURES_IN_SHADER\");if(s.length>o){let h=[];for(let f=0;f<s.length;f+=o){let g=s.slice(f,f+o);h.push(oc(g,t,n))}let m=oc(h,t,n);for(let f of h)n.disposeIntermediateTensorInfo(f);return m}if(i){let h=new hne(s.map(m=>m.shape),t);return n.runWebGLProgram(h,s,a)}let{tensors2D:l,outShape:u}=fne(s,t,n),p=new dne(l.map(h=>h.shape)),d=n.runWebGLProgram(p,l,a);l.forEach(h=>n.disposeIntermediateTensorInfo(h));let c=ce({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),c}function fne(e,t,n){let a=T.computeOutShape(e.map(r=>r.shape),t);return{tensors2D:e.map(r=>ce({inputs:{x:r},attrs:{shape:[-1,w.sizeFromShape(r.shape.slice(t))]},backend:n})),outShape:a}}function UA(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=w.parseAxisParam(r,t[0].shape)[0],i=t.map(u=>u.shape);T.assertParamsConsistent(i,s);let o=T.computeOutShape(t.map(u=>u.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>w.sizeFromShape(u.shape)>0);return l.length===1?ta({inputs:{x:l[0]},backend:n}):oc(l,s,n)}var gne={kernelName:su,backendName:\"webgl\",kernelFunc:UA},GA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,c=e.filterWidth,h=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,f=e.dataFormat===\"channelsLast\",g=f?1:2,b=f?2:3,y=f?3:1,x=\"\",v=\"\";n&&(a?x=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?x=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:x=`\n          float activation(float x) {\n            ${n}\n          }\n        `,v=\"result = activation(result);\");let I=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${c}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${f}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${m===1}) {\n\n              if (${f}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${m===2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${m===3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${I}\n        ${v}\n        setOutput(result);\n      }\n    `}},bne=class{constructor(e){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.filterDepth,d=e.filterHeight,c=e.filterWidth,h=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${m===1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${m===2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${m===3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},HA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"pads\",type:\"ivec2\"},{name:\"strides\",type:\"ivec2\"},{name:\"dilations\",type:\"ivec2\"},{name:\"inDims\",type:\"ivec2\"}],this.outputShape=e.outShape,this.enableShapeUniforms=vn(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,p=u,d=`\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;`;for(let f=0;f<u;f++)d+=`\n           vec4 xTexelC${f*2};\n           int xTexelC${f*2}Ready;\n           vec4 xTexelC${f*2+1};\n           int xTexelC${f*2+1}Ready;\n           vec4 xC${f};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let f=0;f<u;f++)d+=`\n           xTexelC${f*2} = vec4(0.0);\n           xTexelC${f*2}Ready = 0;\n           xTexelC${f*2+1} = vec4(0.0);\n           xTexelC${f*2+1}Ready = 0;\n           xC${f} = vec4(0.0);`;d+=`\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       `;for(let f=0;f<(p+1)/2;f++){let g=f*2;if(d+=`\n           xC = xCCorner + ${g*o};\n           `,i===1){if(g<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n               `,o===1&&g>0?d+=`\n                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);\n                 `:d+=`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);\n                   } else {\n                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 xC${g} = xTexelC${g};\n                 `,g+1<u)){let b=s%2===0?w.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${g+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${g+1}Ready = 1;\n                   }\n                   `,o>1?d+=`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);\n                     } else {\n                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);\n                     }\n                     `:d+=`\n                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);\n                     `):b===1?d+=`\n                     xC${g+1} = xTexelC${g};\n                     `:d+=`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${g+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${g+1}Ready = 1;\n                     }\n\n                     xC${g+1} = xTexelC${g+1};\n                     `}}else g<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {\n                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${g+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${g+1}Ready = 1;\n                 }\n\n                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n               `,g+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {\n                   xTexelC${g} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${g}.zw = vec2(0.0);\n                   }\n                   xTexelC${g}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {\n                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${g+1}.zw = vec2(0.);\n                   }\n                   xTexelC${g+1}Ready = 1;\n                 }\n\n                 xC${g} = vec4(\n                   xTexelC${g}.xy, xTexelC${g+1}.xy);\n               `,g+1<u&&(d+=`\n                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);\n                 `)));g<u&&(d+=`\n             wTexel = getW(r, ${g}, d1, d2);\n             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,g+1<u&&(d+=`\n               wTexel = getW(r, ${g+1}, d1, d2);\n               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+=`\n     }\n   `,d+=`\n     }\n   `,d+=`\n     }\n   `;let c=\"\",h=\"\";n&&(a?c=`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:r?c=`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:c=`vec4 activation(vec4 x) {\n           ${n}\n         }`,h=\"result = activation(result);\");let m=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n       ${c}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${h}\n         setOutput(result);\n       }\n     `}},yne=class{constructor(e,t){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"inputShape\",type:\"ivec4\"},{name:\"pad\",type:\"ivec2\"},{name:\"stride\",type:\"ivec2\"},{name:\"dilation\",type:\"ivec2\"},{name:\"inChannels\",type:\"int\"},{name:\"itemsPerBlockRow\",type:\"int\"},{name:\"outWidth\",type:\"int\"}],this.outputShape=e,this.enableShapeUniforms=vn(this.outputShape.length);let{dataFormat:n}=t,a=En(),r=n===\"channelsLast\",s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?\"if(blockIndex < outShape[2] && pos < outShape[1]) {\":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l=\"\";for(let u=0;u<=1;u++)for(let p=0;p<=1;p++)l+=`\n          blockIndex = rc.z + ${p};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${u*2+p}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${u*2+p}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${a.output} = result;\n      }\n    `}};function mm(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function jA({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,u=a.texData.get(e.dataId),p=n.inChannels,d=l[0]*l[1]*l[2],c=n.outChannels,h=n.dataFormat===\"channelsLast\",m=!1,f=!1,g,b=[];if(s!=null){let y=mm(s.shape,h);y!=null&&(s=ce({inputs:{x:s},backend:a,attrs:{shape:y}}),b.push(s))}if(r!=null){let y=mm(r.shape,h);y!=null&&(r=ce({inputs:{x:r},backend:a,attrs:{shape:y}}),b.push(r))}if(!((d===1||c===1)&&p>LA)&&u.isPacked&&h&&u.texture!=null&&l[2]%2!==0&&w.arraysEqual(u.shape.slice(-3),l.slice(-3))){let y=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,y,n.inChannels],dtype:e.dtype},v=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,w.assert(Tc(u.shape,x.shape),()=>`packed reshape ${u.shape} to ${x.shape} isn't free`);let I=ce({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}});b.push(I);let N=hm({a:x,b:I,backend:a,transposeA:m,transposeB:f,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),C=a.texData.get(N.dataId);w.assert(C.isPacked,()=>\"batchMatMul result is expected to be packed\"),u.shape=v,C.shape=n.outShape,g=ta({inputs:{x:N},backend:a}),g.shape=n.outShape,b.push(N)}else{let y=n.outHeight*n.outWidth,x=ce({inputs:{x:e},backend:a,attrs:{shape:h?[n.batchSize,y,n.inChannels]:[n.batchSize,n.inChannels,y]}}),v=ce({inputs:{x:t},backend:a,attrs:{shape:[1,n.inChannels,n.outChannels]}}),I=hm({a:h?x:v,b:h?v:x,transposeA:!h,transposeB:f,backend:a,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i});g=ce({inputs:{x:I},backend:a,attrs:{shape:n.outShape}}),b.push(x),b.push(v),b.push(I)}for(let y of b)a.disposeIntermediateTensorInfo(y);return g}function qA({x:e,filter:t,convInfo:n,backend:a,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:p,outWidth:d,outHeight:c,dataFormat:h}=n,m=h===\"channelsLast\",f=l*u*p,g=c*d,b=[n.batchSize,f,g],y=!0,x=!1,v=[];if(s!=null){let K=mm(s.shape,m);K!=null&&(s=ce({inputs:{x:s},backend:a,attrs:{shape:K}}),v.push(s))}if(r!=null){let K=mm(r.shape,m);K!=null&&(r=ce({inputs:{x:r},backend:a,attrs:{shape:K}}),v.push(r))}let I=ce({inputs:{x:t},backend:a,attrs:{shape:[1,f,w.sizeFromShape(t.shape)/f]}});v.push(I);let N=new yne(b,n),C=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],_=a.runWebGLProgram(N,[e],\"float32\",C),F=ce({inputs:{x:_},backend:a,attrs:{shape:b}});v.push(_),v.push(F);let D=r!=null,$=s!=null,S=o===\"leakyrelu\",M=o?Cc(o,!0):null,B=new PA(m?F.shape:I.shape,m?I.shape:F.shape,m?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],y,x,D,M,$,S),U=m?[F,I]:[I,F];if(r&&U.push(r),$&&U.push(s),S){let K=a.makeTensorInfo([],\"float32\",w.createScalarValue(i,\"float32\"));U.push(K),v.push(K)}let H=a.runWebGLProgram(B,U,\"float32\"),q=ce({inputs:{x:H},backend:a,attrs:{shape:n.outShape}});v.push(H);for(let K of v)a.disposeIntermediateTensorInfo(K);return q}function xne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=a,d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,s.shape,i,u,o,p,!1,d),h;if(c.filterHeight===1&&c.filterWidth===1&&c.dilationHeight===1&&c.dilationWidth===1&&c.strideHeight===1&&c.strideWidth===1&&(c.padInfo.type===\"SAME\"||c.padInfo.type===\"VALID\"))h=jA({x:r,filter:s,convInfo:c,backend:n});else if(c.strideWidth<=2&&d===\"channelsLast\"&&G().getBool(\"WEBGL_EXP_CONV\")){let f=new HA(c),g=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];h=n.runWebGLProgram(f,[r,s],\"float32\",g)}else if(G().getBool(\"WEBGL_CONV_IM2COL\"))h=qA({x:r,filter:s,convInfo:c,backend:n});else{let f=new GA(c);h=n.runWebGLProgram(f,[r,s],\"float32\")}let m=ce({inputs:{x:h},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(h),m}var vne={kernelName:Pi,backendName:\"webgl\",kernelFunc:xne},wne=class{constructor(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.dataFormat===\"channelsLast\";this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?`float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);`}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},kne=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dataFormat===\"channelsLast\",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,p=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${p}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Ine=class{constructor(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${a} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Sne=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=a-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function Nne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=a,d=T.convertConv2DDataFormat(l),c=T.computeConv2DInfo(r.shape,p,i,1,o,u,!1,d),h=new wne(c);return n.runWebGLProgram(h,[r,s],\"float32\")}var Tne={kernelName:km,backendName:\"webgl\",kernelFunc:Nne},Cne=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"strides\",type:\"vec2\"}],this.outputShape=e.inShape,this.enableShapeUniforms=vn(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};function Ene(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=a,d=T.convertConv2DDataFormat(u),c=T.computeConv2DInfo(i,s.shape,o,1,l,p,!1,d);if(G().getBool(\"WEBGL_PACK_CONV2DTRANSPOSE\")&&d===\"channelsLast\"){let h=[[c.strideHeight,c.strideWidth]],m=new Cne(c);return n.runWebGLProgram(m,[r,s],\"float32\",h)}else{let h=new kne(c);return n.runWebGLProgram(h,[r,s],\"float32\")}}var _ne={kernelName:Li,backendName:\"webgl\",kernelFunc:Ene};function Ane(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=T.computeConv3DInfo(r.shape,s.shape,i,l,o),p=new bne(u);return n.runWebGLProgram(p,[r,s],\"float32\")}var Fne={kernelName:zi,backendName:\"webgl\",kernelFunc:Ane};function $ne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a,u=T.computeConv3DInfo(r.shape,l,i,1,o),p=new Ine(u);return n.runWebGLProgram(p,[r,s],\"float32\")}var Dne={kernelName:iu,backendName:\"webgl\",kernelFunc:$ne};function Rne(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a,u=T.computeConv3DInfo(l,s.shape,o,1,i),p=new Sne(u);return n.runWebGLProgram(p,[r,s],\"float32\")}var Mne={kernelName:ou,backendName:\"webgl\",kernelFunc:Rne},One=mp+`\n  return cos(x);\n`,Pne=`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Qo}\n  return result;\n`,Lne=Ze({opSnippet:One,packedOpSnippet:Pne}),zne={kernelName:Wi,backendName:\"webgl\",kernelFunc:Lne},Wne=`\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n`,Bne=Ze({opSnippet:Wne}),Vne={kernelName:Bi,backendName:\"webgl\",kernelFunc:Bne},Une=class{constructor(e,t,n,a,r){this.variableNames=[\"Image\",\"Boxes\",\"BoxInd\"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[p,d]=n;this.outputShape=[u,p,d,l];let c=a===\"bilinear\"?1:0,[h,m]=[`${i-1}.0`,`${o-1}.0`],[f,g,b]=p>1?[`${(i-1)/(p-1)}`,\"(y2-y1) * height_ratio\",`y1*${h} + float(y)*(height_scale)`]:[\"0.0\",\"0.0\",`0.5 * (y1+y2) * ${h}`],[y,x,v]=d>1?[`${(o-1)/(d-1)}`,\"(x2-x1) * width_ratio\",`x1*${m} + float(x)*(width_scale)`]:[\"0.0\",\"0.0\",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${f});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${c} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},Gne=e=>{let{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=a,p=new Une(r.shape,s.shape,o,l,u);return n.runWebGLProgram(p,[r,s,i],\"float32\")},Hne={kernelName:uu,backendName:\"webgl\",kernelFunc:Gne},_c;(function(e){e.Prod=\"*\",e.Sum=\"+\"})(_c||(_c={}));var gS=class{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=[\"x\"],this.customUniforms=[{name:\"index\",type:\"float\"}];let r=this.outputShape.length,s=this.op===_c.Prod?\"1.0\":\"0.0\",i=n?s:`getX(${bS(r,\"coords\",this.op)})`,o=this.outputShape[this.outputShape.length-1],l=\"\",u=\"\";n?(l=a?`end != ${o-1}`:\"end != 0\",u=a?\"end + 1\":\"end - 1\"):(l=a?`end + pow2 < ${o}`:\"end >= pow2\",u=a?\"end + pow2\":\"end - pow2\"),this.userCode=`\n      void main() {\n        ${ht(r)} coords = getOutputCoords();\n        int end = ${yS(r,\"coords\",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${yS(r,\"coords\",this.op)} = idx;\n          val ${this.op}= getX(${bS(r,\"coords\",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function bS(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function yS(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function KA(e,t,n,a,r,s){let i=t.shape.length,o=T.getAxesPermutation([a],i),l=t;o!=null&&(l=Sn({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=T.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${a}`);let p=l.shape[u],d=ta({inputs:{x:l},backend:n});for(let c=0;c<=Math.ceil(Math.log2(p))-1;c++){let h=new gS(e,l.shape,!1,s),m=[[c]],f=d;d=n.runWebGLProgram(h,[d],d.dtype,m),n.disposeIntermediateTensorInfo(f)}if(r){let c=new gS(e,l.shape,r,s),h=d;d=n.runWebGLProgram(c,[d],d.dtype),n.disposeIntermediateTensorInfo(h)}if(o!=null){let c=T.getUndoAxesPermutation(o),h=Sn({inputs:{x:d},backend:n,attrs:{perm:c}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),h}return d}function jne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return KA(_c.Prod,r,n,s,i,o)}var qne={kernelName:lu,backendName:\"webgl\",kernelFunc:jne};function Kne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a;return KA(_c.Sum,r,n,s,i,o)}var Xne={kernelName:Vi,backendName:\"webgl\",kernelFunc:Kne};function Yne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=a;if(r.shape.length===1){let l=n.readSync(r.dataId),u=n.readSync(s.dataId),p=TA(l,u,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}else if(r.shape.length===2){let l=n.bufferSync(r),u=n.bufferSync(s),p=J9(l,u,i,o);return n.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var Zne={kernelName:Pc,backendName:\"webgl\",kernelFunc:Yne},Jne=class{constructor(e,t,n){this.variableNames=[\"x\"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return this.dataFormat===\"NHWC\"?\"coords[1]\":\"coords[2]\"}getWidthCoordString(){return this.dataFormat===\"NHWC\"?\"coords[2]\":\"coords[3]\"}getDepthCoordString(){return this.dataFormat===\"NHWC\"?\"coords[3]\":\"coords[1]\"}getOutputDepthSize(){return this.dataFormat===\"NHWC\"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat===\"NHWC\"?\"getX(b, in_h, in_w, in_d)\":\"getX(b, in_d, in_h, in_w)\"}};function Qne(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i===\"NHWC\"?r.shape[1]:r.shape[2],u=i===\"NHWC\"?r.shape[2]:r.shape[3],p=i===\"NHWC\"?r.shape[3]:r.shape[1],d=l*s,c=u*s,h=p/(s*s),m=i===\"NHWC\"?[o,d,c,h]:[o,h,d,c],f=new Jne(m,s,i);return n.runWebGLProgram(f,[r],r.dtype)}var eae={kernelName:pu,backendName:\"webgl\",kernelFunc:Qne},XA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.customUniforms=[{name:\"pads\",type:\"ivec2\"},{name:\"strides\",type:\"ivec2\"},{name:\"dilations\",type:\"ivec2\"},{name:\"inDims\",type:\"ivec2\"}],this.outputShape=e.outShape,this.enableShapeUniforms=vn(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l=\"\",u=\"\";n&&(a?l=`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?l=`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:l=`\n          float activation(float x) {\n            ${n}\n          }\n        `,u=\"result = activation(result);\");let p=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${u}\n        setOutput(result);\n      }\n    `}},YA=class{constructor(e,t=!1,n=null,a=!1,r=!1){this.variableNames=[\"x\",\"W\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"pads\",type:\"ivec2\"},{name:\"strides\",type:\"ivec2\"},{name:\"dilations\",type:\"ivec2\"},{name:\"inDims\",type:\"ivec2\"}],this.outputShape=e.outShape,this.enableShapeUniforms=vn(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,p=e.filterWidth,d=p,c=`\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<p;g++)c+=`\n          vec4 xTexelC${g*2};\n          int xTexelC${g*2}Ready;\n          vec4 xTexelC${g*2+1};\n          int xTexelC${g*2+1}Ready;\n          vec4 xC${g};`;c+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<p;g++)c+=`\n          xTexelC${g*2} = vec4(0.0);\n          xTexelC${g*2}Ready = 0;\n          xTexelC${g*2+1} = vec4(0.0);\n          xTexelC${g*2+1}Ready = 0;\n          xC${g} = vec4(0.0);`;c+=`\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;for(let g=0;g<(d+1)/2;g++){let b=g*2;if(c+=`\n          xC = xCCorner + ${b*l};\n          `,o===1){if(b<p&&(i%2===1?(c+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,l===1&&b>0?c+=`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:c+=`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):c+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<p)){let y=i%2===0?w.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(c+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${y};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,l>1?c+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:c+=`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):y===1?c+=`\n                    xC${b+1} = xTexelC${b};\n                    `:c+=`\n                    xCOffset = xC + ${y};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<p&&(i%2===1?(c+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<p&&(c+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(c+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<p&&(c+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<p&&(c+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<p&&(c+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}c+=`\n    }\n  `,c+=`\n      }\n    `;let h=\"\",m=\"\";n&&(a?h=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?h=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:h=`vec4 activation(vec4 x) {\n          ${n}\n        }`,m=\"result = activation(result);\");let f=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),a&&this.variableNames.push(\"preluActivationWeights\"),r&&this.variableNames.push(\"leakyreluAlpha\"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${c}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${f}\n        ${m}\n        setOutput(result);\n      }\n    `}};function tae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=a,p=l;p==null&&(p=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let d=T.computeConv2DInfo(r.shape,s.shape,i,p,o,u,!0),c;G().getBool(\"WEBGL_PACK_DEPTHWISECONV\")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?c=new YA(d):c=new XA(d);let h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(c,[r,s],\"float32\",h)}var nae={kernelName:Ui,backendName:\"webgl\",kernelFunc:tae},aae=class{constructor(e){this.variableNames=[\"x\",\"dy\"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${a};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},rae=class{constructor(e){this.variableNames=[\"dy\",\"W\"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${a}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function sae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=a,d=T.computeConv2DInfo(r.shape,p,i,o,l,u,!0),c=new aae(d);return n.runWebGLProgram(c,[r,s],\"float32\")}var iae={kernelName:Im,backendName:\"webgl\",kernelFunc:sae};function oae(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=a,d=T.computeConv2DInfo(p,s.shape,i,o,l,u,!0),c=new rae(d);return n.runWebGLProgram(c,[r,s],\"float32\")}var lae={kernelName:Sm,backendName:\"webgl\",kernelFunc:oae},uae=class{constructor(e){this.variableNames=[\"X\"],this.outputShape=[e,e],this.userCode=`\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `}};function pae(e){let{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=w.sizeFromShape(a.shape),i=ce({inputs:{x:a},backend:n,attrs:{shape:[s]}}),o=new uae(s),l=n.runWebGLProgram(o,[i],i.dtype),u=ce({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var cae={kernelName:Lc,backendName:\"webgl\",kernelFunc:pae},dae=class{constructor(e){this.variableNames=[\"x\",\"W\"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:p,left:d}=a;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${s});\n      const ivec2 pads = ivec2(${p}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};function hae(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a,u=T.computeDilation2DInfo(r.shape,s.shape,i,o,\"NHWC\",l),p,d=new dae(u);p=n.runWebGLProgram(d,[r,s],\"float32\");let c=ce({inputs:{x:p},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(p),c}var mae={kernelName:Gi,backendName:\"webgl\",kernelFunc:hae};function fae(e){let{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:i,summedDims:o,idDims:l}=T.decodeEinsumEquation(r,s.length);T.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=T.getEinsumComputePath(o,l),d=p.length,c=null,h=i.length,m=[];for(let f=0;f<d;++f){for(let g of p[f]){let{permutationIndices:b,expandDims:y}=T.getEinsumPermutation(h,l[g]),x;T.isIdentityPermutation(b)?x=s[g]:(x=Sn({inputs:{x:s[g]},backend:n,attrs:{perm:b}}),m.push(x));let v=x.shape.slice();for(let I=0;I<y.length;++I)v.splice(y[I],0,1);w.arraysEqual(x.shape,v)||(x=ce({inputs:{x},backend:n,attrs:{shape:v}}),m.push(x)),c===null?c=x:(c=pk({inputs:{a:x,b:c},backend:n}),m.push(c))}f<d-1&&(u[f]>=0&&(c=Vf({inputs:{x:c},backend:n,attrs:{axis:u[f]-(i.length-h),keepDims:!1}}),m.push(c)),h--)}for(let f of m)f!==c&&n.disposeIntermediateTensorInfo(f);return c}var gae={kernelName:Tm,backendName:\"webgl\",kernelFunc:fae},bae=\"return (x >= 0.0) ? x : (exp(x) - 1.0);\",yae=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`,xae=Ze({opSnippet:bae,packedOpSnippet:yae}),vae={kernelName:ji,backendName:\"webgl\",kernelFunc:xae},wae=\"return (b >= 0.0) ? a : a * (b + 1.0);\",kae=`\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`,Iae=e=>{let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=G().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")?new hp(kae,a.shape,r.shape):new ki(wae,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)},Sae={kernelName:cu,backendName:\"webgl\",kernelFunc:Iae},Nae=`\n  return vec4(equal(a, b));\n`,Tae=\"return float(a == b);\",Cae=hn({opSnippet:Tae,packedOpSnippet:Nae,dtype:\"bool\",cpuKernelImpl:aQ}),Eae={kernelName:du,backendName:\"webgl\",kernelFunc:Cae},_ae=`\n  // Error function is calculated approximately with elementary function.\n  // See \"Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\n  float p = ${T.ERF_P};\n  float a1 = ${T.ERF_A1};\n  float a2 = ${T.ERF_A2};\n  float a3 = ${T.ERF_A3};\n  float a4 = ${T.ERF_A4};\n  float a5 = ${T.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,Aae=Ze({opSnippet:_ae}),Fae={kernelName:qi,backendName:\"webgl\",kernelFunc:Aae},$ae=mp+`\n  return exp(x);\n`,Dae=`\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,ZA=Ze({opSnippet:$ae,packedOpSnippet:Dae,cpuKernelImpl:rQ,dtype:\"float32\"}),Rae={kernelName:Ki,backendName:\"webgl\",kernelFunc:ZA};function gv(e){let{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=r;return r<0&&(w.assert(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+r+1),o.splice(l,0,1),ce({inputs:{x:s},backend:a,attrs:{shape:o}})}var Mae={kernelName:hu,backendName:\"webgl\",kernelFunc:gv},xS=\"return exp(x) - 1.0;\",Oae=Ze({opSnippet:xS,packedOpSnippet:xS,cpuKernelImpl:sQ}),Pae={kernelName:Xi,backendName:\"webgl\",kernelFunc:Oae},vS=class{constructor(e,t,n){this.variableNames=[\"real\",\"imag\"];let a=t[1];this.outputShape=t;let r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${a}.0`:\"1.0\",i;if(e===\"real\")i=\"return real * expR - imag * expI;\";else if(e===\"imag\")i=\"return real * expI + imag * expR;\";else throw new Error(`FFT component must be either \"real\" or \"imag\", got ${e}.`);this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function JA(e,t,n){let a=n.texData.get(e.dataId),r=w.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=r/s,o=ce({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new vS(\"real\",l,t),p=new vS(\"imag\",l,t),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:l},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:l}],c=n.runWebGLProgram(u,d,\"float32\"),h=n.runWebGLProgram(p,d,\"float32\"),m=$s({inputs:{real:c,imag:h},backend:n});n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h);let f=ce({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(m),f}function Lae(e){let{inputs:t,backend:n}=e,{input:a}=t;return JA(a,!1,n)}var zae={kernelName:Cm,backendName:\"webgl\",kernelFunc:Lae},Wae=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:\"value\",type:\"float\"}],this.variableNames=[\"x\"],this.outputShape=e,this.userCode=`\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `}};function $d(e){let{backend:t,attrs:n}=e,{shape:a,value:r}=n,{dtype:s}=n;if(s=s||w.inferDtype(r),s===\"string\"){let i=w.getArrayFromDType(s,w.sizeFromShape(a));return i.fill(r),t.makeTensorInfo(a,s,i)}else{let i=new Wae(a,r),o=[[r]];return t.runWebGLProgram(i,[],s,o)}}var Bae={kernelName:zc,backendName:\"webgl\",kernelFunc:$d},Vae=class{constructor(e){this.variableNames=[\"Image\"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},Uae={kernelName:mu,backendName:\"webgl\",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,a=t,r=new Vae(n.shape);return a.runWebGLProgram(r,[n],n.dtype)}},wS=\"return floor(x);\",Gae=Ze({opSnippet:wS,packedOpSnippet:wS,cpuKernelImpl:iQ}),Hae={kernelName:Yi,backendName:\"webgl\",kernelFunc:Gae},jae=`\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n`,qae=`\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n`,Kae=hn({opSnippet:jae,packedOpSnippet:qae,dtype:\"int32\"}),Xae={kernelName:Zi,backendName:\"webgl\",kernelFunc:Kae},Yae=class{constructor(e){this.variableNames=[\"A\"];let t=En(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},Zae=class{constructor(e){this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0;let t=En(),[n,a]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},Jae={kernelName:Hh,backendName:\"webgl\",kernelFunc:Qae},Il,xx=G().getBool(\"CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU\");function Qae(e){let{inputs:t,backend:n,attrs:a}=e,{pixels:r}=t,{numChannels:s}=a,i=typeof HTMLVideoElement!=\"undefined\"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement!=\"undefined\"&&r instanceof HTMLImageElement,[l,u]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],p=[u,l],d=[u,l,s];if(o||i){let f=G().getBool(\"CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU\");(Il==null||f!==xx)&&(xx=f,Il=document.createElement(\"canvas\").getContext(\"2d\",{willReadFrequently:xx})),Il.canvas.width=l,Il.canvas.height=u,Il.drawImage(r,0,0,l,u),r=Il.canvas}let c=n.makeTensorInfo(p,\"int32\");n.texData.get(c.dataId).usage=ca.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(c.dataId),r);let h=G().getBool(\"WEBGL_PACK\")?new Zae(d):new Yae(d),m=n.runWebGLProgram(h,[c],\"int32\");return n.disposeData(c.dataId),m}function ere(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=a,f=T.convertConv2DDataFormat(p),g=T.computeConv2DInfo(r.shape,s.shape,l,d,u,c,!1,f),b,y=[],x=i!=null,v=o!=null,I=h===\"leakyrelu\",N=()=>{let _=[r,s],F=(D,$)=>{if($===\"NCHW\"&&D.shape.length===1&&D.shape[0]!==1){let S=ce({inputs:{x:D},backend:n,attrs:{shape:[D.shape[0],1,1]}});return y.push(S),S}return D};if(x&&_.push(F(i,p)),v&&_.push(F(o,p)),I){let D=n.makeTensorInfo([],\"float32\",w.createScalarValue(m,\"float32\"));_.push(D),y.push(D)}return _};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type===\"SAME\"||g.padInfo.type===\"VALID\"))b=jA({x:r,filter:s,convInfo:g,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else if(g.strideWidth<=2&&f===\"channelsLast\"&&G().getBool(\"WEBGL_EXP_CONV\")){let _=h?Cc(h,!0):null,F=new HA(g,x,_,v,I),D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=N();b=n.runWebGLProgram(F,$,\"float32\",D)}else if(G().getBool(\"WEBGL_CONV_IM2COL\"))b=qA({x:r,filter:s,convInfo:g,backend:n,bias:i,activation:h,preluActivationWeights:o,leakyreluAlpha:m});else{let _=h?Cc(h,!1):null,F=new GA(g,x,_,v,I),D=N();b=n.runWebGLProgram(F,D,\"float32\")}let C=ce({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(_=>n.disposeIntermediateTensorInfo(_)),C}var tre={kernelName:oi,backendName:\"webgl\",kernelFunc:ere};function nre(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:h}=a,m=[],f=p;f==null&&(f=[1,1]),w.assert(T.eitherStridesOrDilationsAreOne(l,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${f}'`);let g=T.computeConv2DInfo(r.shape,s.shape,l,f,u,d,!0),b=G().getBool(\"WEBGL_PACK_DEPTHWISECONV\")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=c?Cc(c,b):null,x=[r,s],v=i!=null,I=o!=null,N=c===\"leakyrelu\";if(v&&x.push(i),I&&x.push(o),N){let D=n.makeTensorInfo([],\"float32\",w.createScalarValue(h,\"float32\"));x.push(D),m.push(D)}let C;b?C=new YA(g,v,y,I,N):C=new XA(g,v,y,I,N);let _=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=n.runWebGLProgram(C,x,\"float32\",_);return m.forEach(D=>n.disposeIntermediateTensorInfo(D)),F}var are={kernelName:li,backendName:\"webgl\",kernelFunc:nre},rre=class{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=[\"x\",\"indices\"],this.outputShape=n;let r=ht(n.length),s=`\n    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};function sre(e){let{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,i=s[s.length-1],o=w.sizeFromShape(a.shape),[l,u,p,d]=T.prepareAndValidate(a,r),c=ce({inputs:{x:r},backend:n,attrs:{shape:[u,i]}}),h=ce({inputs:{x:a},backend:n,attrs:{shape:[w.sizeFromShape(a.shape)/p,p]}});if(n.shouldExecuteOnCPU([a,r])||a.dtype===\"string\"){let b=n.readSync(r.dataId),y=n.bufferSync(a),x=oQ(b,y,a.dtype,u,i,p,d,a.shape,o);return n.makeTensorInfo(l,a.dtype,x.values)}let m=new rre(i,d,[u,p],a.shape),f=n.runWebGLProgram(m,[h,c],h.dtype),g=ce({inputs:{x:f},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),g}var ire={kernelName:gu,backendName:\"webgl\",kernelFunc:sre},ore=class{constructor(e,t){this.variableNames=[\"A\",\"indices\"],this.outputShape=t,this.rank=t.length;let n=ht(this.rank),a=lre(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${a}));\n      }\n    `}};function lre(e,t){let n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\"],a=[];for(let r=0;r<e.length;r++)r===2?a.push(\"index\"):a.push(`${n[r]}`);return a.join()}function QA(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=a,l=w.parseAxisParam(i,r.shape)[0];if(G().get(\"DEBUG\")){let y=n.readSync(s.dataId),x=r.shape[l];for(let v=0;v<y.length;++v){let I=y[v];w.assert(I<=x-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${x-1}]`)}}let u=T.segment_util.collectGatherOpShapeInfo(r,s,l,o),p=w.sizeFromShape(s.shape),d=[],c=ce({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=ce({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,p/u.batchSize]}});d.push(c),d.push(h);let m=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,s])||r.dtype===\"string\"){let y=n.bufferSync(h),x=n.bufferSync(c),v=lQ(x,y,m);return d.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(u.outputShape,v.dtype,v.values)}let f=new ore(c.shape,m),g=n.runWebGLProgram(f,[c,h],c.dtype);d.push(g);let b=ce({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(y=>n.disposeIntermediateTensorInfo(y)),b}var ure={kernelName:fu,backendName:\"webgl\",kernelFunc:QA},pre=\"return float(a > b);\",cre=`\n  return vec4(greaterThan(a, b));\n`,dre=hn({opSnippet:pre,packedOpSnippet:cre,cpuKernelImpl:uQ,dtype:\"bool\"}),hre={kernelName:bu,backendName:\"webgl\",kernelFunc:dre},mre=\"return float(a >= b);\",fre=`\n  return vec4(greaterThanEqual(a, b));\n`,gre=hn({opSnippet:mre,packedOpSnippet:fre,dtype:\"bool\",cpuKernelImpl:pQ}),bre={kernelName:Qi,backendName:\"webgl\",kernelFunc:gre};function yre(e){let{inputs:t,backend:n}=e,{input:a}=t;return JA(a,!0,n)}var xre={kernelName:Em,backendName:\"webgl\",kernelFunc:yre},vre=\"return float(!isnan(x) && !isinf(x));\",wre=Ze({opSnippet:vre,dtype:\"bool\"}),kre={kernelName:to,backendName:\"webgl\",kernelFunc:wre},Ire=\"return float(isinf(x));\",Sre=Ze({opSnippet:Ire,dtype:\"bool\"}),Nre={kernelName:no,backendName:\"webgl\",kernelFunc:Sre},Tre=\"return float(isnan(x));\",Cre=Ze({opSnippet:Tre,dtype:\"bool\"}),Ere={kernelName:ao,backendName:\"webgl\",kernelFunc:Cre},_re=\"return float(a < b);\",Are=`\n  return vec4(lessThan(a, b));\n`,Fre=hn({opSnippet:_re,packedOpSnippet:Are,cpuKernelImpl:cQ,dtype:\"bool\"}),$re={kernelName:yu,backendName:\"webgl\",kernelFunc:Fre},Dre=\"return float(a <= b);\",Rre=`\n  return vec4(lessThanEqual(a, b));\n`,Mre=hn({opSnippet:Dre,packedOpSnippet:Rre,cpuKernelImpl:dQ,dtype:\"bool\"}),Ore={kernelName:xu,backendName:\"webgl\",kernelFunc:Mre};function Pre(e){let{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,i=hQ(a,r,s);return t.makeTensorInfo([i.length],\"float32\",i)}var Lre={kernelName:vu,backendName:\"webgl\",kernelFunc:Pre},zre=mp+`\n  return x < 0.0 ? 0./0. : log(x);\n`,Wre=`\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n`,Bre=Ze({opSnippet:zre,packedOpSnippet:Wre,cpuKernelImpl:mQ}),Vre={kernelName:so,backendName:\"webgl\",kernelFunc:Bre},Ure=mp+`\n  return log(1.0 + x);\n`,Gre=Ze({opSnippet:Ure}),Hre={kernelName:io,backendName:\"webgl\",kernelFunc:Gre},jre=\"return float(a >= 1.0 && b >= 1.0);\",qre=`\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n`,Kre=hn({opSnippet:jre,packedOpSnippet:qre,dtype:\"bool\"}),Xre={kernelName:wu,backendName:\"webgl\",kernelFunc:Kre},Yre=\"return float(!(x >= 1.0));\",Zre=Ze({opSnippet:Yre}),Jre={kernelName:ku,backendName:\"webgl\",kernelFunc:Zre},Qre=\"return float(a >= 1.0 || b >= 1.0);\",ese=`\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n`,tse=hn({opSnippet:Qre,packedOpSnippet:ese,dtype:\"bool\"}),nse={kernelName:Iu,backendName:\"webgl\",kernelFunc:tse},ase=class{constructor(e,t,n,a,r){this.variableNames=[\"x\"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},rse=class{constructor(e,t,n,a,r){this.variableNames=[\"x\"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${a}) * sum`;r===.5?o=`inversesqrt(${l})`:r===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},sse=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a,u=G().getBool(\"WEBGL_PACK_NORMALIZATION\")?new rse(r.shape,s,i,o,l):new ase(r.shape,s,i,o,l);return n.runWebGLProgram(u,[r],r.dtype)},ise={kernelName:oo,backendName:\"webgl\",kernelFunc:sse},ose=class{constructor(e,t,n,a,r){this.variableNames=[\"inputImage\",\"outputImage\",\"dy\"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${r})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},lse=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=a,d=new ose(r.shape,o,l,u,p);return n.runWebGLProgram(d,[r,s,i],r.dtype)},use={kernelName:Su,backendName:\"webgl\",kernelFunc:lse};function pse(e,t,n,a){let r=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/r,i=ce({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=el(i,e.dtype,\"max\",a),l=ce({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}function eF(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=p!=null,c=n.shouldExecuteOnCPU([r]),h=r;if(d){if(c){let y=n.texData.get(h.dataId).values,x=new Array(o);for(let N=0;N<x.length;N++)x[N]=r.shape[p[N]];let v=ok(y,r.shape,r.dtype,p,x);h=n.makeTensorInfo(x,r.dtype);let I=n.texData.get(h.dataId);I.values=v}else h=Bf(r,p,n);u=T.getInnerMostAxes(u.length,o)}T.assertAxesAreInnerMostDims(\"max\",u,o);let[m,f]=T.computeOutAndReduceShapes(h.shape,u),g=m;i&&(g=T.expandShapeToKeepDim(m,l));let b;if(c){let y=n.texData.get(h.dataId).values,x=fQ(y,w.sizeFromShape(f),g,r.dtype);b=n.makeTensorInfo(g,r.dtype);let v=n.texData.get(b.dataId);v.values=x}else b=pse(h,f,g,n);return d&&n.disposeIntermediateTensorInfo(h),b}var cse={kernelName:lo,backendName:\"webgl\",kernelFunc:eF},dse=uk+`\n  return max(a, b);\n`,hse=`\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+Qo+`\n  return result;\n`,mse=hn({opSnippet:dse,packedOpSnippet:hse,cpuKernelImpl:gQ}),fse={kernelName:uo,backendName:\"webgl\",kernelFunc:mse};function gse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;lp(r,\"maxPool\");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=a,u=1;w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,u,o,l);if(p.filterWidth===1&&p.filterHeight===1&&w.arraysEqual(p.inShape,p.outShape))return ta({inputs:{x:r},backend:n});let d=new Ec(p,\"max\",!1);return n.runWebGLProgram(d,[r],r.dtype)}var bse={kernelName:po,backendName:\"webgl\",kernelFunc:gse};function yse(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=a,p=[1,1,1],d=T.computePool3DInfo(r.shape,s,i,p,o,u,l),c=new ck(d,\"max\",!1);return n.runWebGLProgram(c,[r],r.dtype)}var xse={kernelName:Nu,backendName:\"webgl\",kernelFunc:yse},vse=class{constructor(e){this.variableNames=[\"dy\",\"maxPos\"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,l=r*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},wse=class{constructor(e){this.variableNames=[\"dy\",\"maxPos\"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,p=o-1-e.padInfo.front,d=l-1-e.padInfo.top,c=u-1-e.padInfo.left,h=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${d}, ${c});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function kse(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=a,d=[1,1,1],c=T.computePool3DInfo(i.shape,o,l,d,u,p),h=new ck(c,\"max\",!0),m=n.runWebGLProgram(h,[i],i.dtype),f=new wse(c),g=n.runWebGLProgram(f,[r,m],i.dtype);return n.disposeIntermediateTensorInfo(m),g}var Ise={kernelName:Bc,backendName:\"webgl\",kernelFunc:kse};function Sse(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:i}=t,o=s;lp([s,i],\"maxPoolGrad\");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=a,c=T.computePool2DInfo(o.shape,l,u,1,p,d),h=!0,m=new Ec(c,\"max\",h),f=n.runWebGLProgram(m,[o],o.dtype),g=new vse(c),b=n.runWebGLProgram(g,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),b}var Nse={kernelName:Wc,backendName:\"webgl\",kernelFunc:Sse};function Tse(e,t,n,a){let r=new Ec(n,\"max\",!1),s=a.runWebGLProgram(r,[e],\"float32\");r=new Ec(n,\"max\",!0,!0,t);let i=a.runWebGLProgram(r,[e],\"float32\");return[s,i]}var Cse={kernelName:Vc,backendName:\"webgl\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;w.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let u=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let p=T.computePool2DInfo(a.shape,r,s,u,i),[d,c]=Tse(a,o,p,l);return[d,c]}};function Ese(e,t,n,a){let r=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/r,i=ce({inputs:{x:e},attrs:{shape:[s,r]},backend:a}),o=el(i,\"float32\",\"mean\",a),l=ce({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),l}var _se={kernelName:co,backendName:\"webgl\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:a}=e,{keepDims:r,axis:s}=t,i=n,o=a.shape.length,l=w.parseAxisParam(s,a.shape),u=l,p=T.getAxesPermutation(u,o),d=p!=null,c=i.shouldExecuteOnCPU([a]),h=[],m=a;if(d){if(c){let x=i.texData.get(m.dataId).values,v=new Array(o);for(let C=0;C<v.length;C++)v[C]=a.shape[p[C]];let I=ok(x,a.shape,a.dtype,p,v);m=i.makeTensorInfo(v,a.dtype);let N=i.texData.get(m.dataId);N.values=I}else m=Bf(a,p,i);h.push(m),u=T.getInnerMostAxes(u.length,o)}T.assertAxesAreInnerMostDims(\"sum\",u,o);let[f,g]=T.computeOutAndReduceShapes(m.shape,u),b=f;r&&(b=T.expandShapeToKeepDim(f,l));let y=Ese(m,g,b,i);for(let x of h)i.disposeIntermediateTensorInfo(x);return y}};function Ase(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=w.parseAxisParam(s,r.shape),u=l,p=T.getAxesPermutation(u,o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),u=T.getInnerMostAxes(u.length,r.shape.length)),T.assertAxesAreInnerMostDims(\"min\",u,o);let[c,h]=T.computeOutAndReduceShapes(d.shape,u),m=w.sizeFromShape(h),f=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=el(f,f.dtype,\"min\",n),b;if(i){let y=T.expandShapeToKeepDim(c,l);b=ce({inputs:{x:g},backend:n,attrs:{shape:y}})}else b=ce({inputs:{x:g},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),p!=null&&n.disposeIntermediateTensorInfo(d),b}var Fse={kernelName:ho,backendName:\"webgl\",kernelFunc:Ase},$se=uk+`\n  return min(a, b);\n`,Dse=`\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  `+Qo+`\n  return result;\n`,Rse=hn({opSnippet:$se,packedOpSnippet:Dse,cpuKernelImpl:bQ}),Mse={kernelName:mo,backendName:\"webgl\",kernelFunc:Rse},Ose=class{constructor(e,t,n){this.variableNames=[\"x\"],this.outputShape=t.map((u,p)=>u[0]+e[p]+u[1]);let a=e.length,r=ht(a),s=t.map(u=>u[0]).join(\",\"),i=t.map((u,p)=>u[0]+e[p]).join(\",\"),o=[\"coords[0]\",\"coords[1]\",\"coords[2]\",\"coords[3]\"].slice(0,a),l=n===\"reflect\"?0:1;if(a===1){this.userCode=`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;return}this.userCode=`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${a}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `}},Pse=class{constructor(e,t,n){this.variableNames=[\"x\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((h,m)=>h[0]+e[m]+h[1]);let a=e.length,r=ht(a),s=t.map(h=>h[0]).join(\",\"),i=t.map((h,m)=>h[0]+e[m]).join(\",\"),o=In(\"rc\",a),l=In(\"source\",a),u=`${o[a-1]} < ${this.outputShape[a-1]}`,p=a===1?\"source\":`vec2(${l.slice(-2).join()})`,d=n===\"reflect\"?0:1,c=\"\";if(a===1){let h=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;c=`\n        ${r} rc = outputLoc;\n        ${h}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[a-1]} += 1;\n        if(${u}) {\n          ${h}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n      `}else{let h=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;c=`\n        ${r} rc = outputLoc;\n        ${h}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[a-1]} += 1;\n        if(${u}) {\n          ${h}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${o[a-2]} += 1;\n        if(${o[a-2]} < ${this.outputShape[a-2]}) {\n          ${h}\n          result[2] = getChannel(getX(${l.join()}), ${p});\n          ${o[a-1]} += 1;\n          if(${u}) {\n            ${h}\n            result[3] = getChannel(getX(${l.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${c}\n        setOutput(result);\n      }\n    `}},Lse=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{paddings:r,mode:s}=n,i=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new Pse(a.shape,r,s):new Ose(a.shape,r,s);return t.runWebGLProgram(i,[a],a.dtype)},zse={kernelName:fo,backendName:\"webgl\",kernelFunc:Lse},Wse=`if (b == 0.0) return NAN;\n  return mod(a, b);`,Bse=`\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  `+Qo+`\n  return result;\n`,Vse=hn({opSnippet:Wse,packedOpSnippet:Bse}),Use={kernelName:go,backendName:\"webgl\",kernelFunc:Vse},Gse=class{constructor(e,t,n){this.variableNames=[\"probs\"],this.customUniforms=[{name:\"seed\",type:\"float\"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},Hse=`\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;`,jse=`\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n`,tF=hn({opSnippet:Hse,packedOpSnippet:jse,checkOutOfBounds:!0}),qse={kernelName:Hi,backendName:\"webgl\",kernelFunc:tF},kS=\"return a - b;\",nF=hn({opSnippet:kS,packedOpSnippet:kS,supportsComplex:!0,cpuKernelImpl:LQ}),Kse={kernelName:Bo,backendName:\"webgl\",kernelFunc:nF};function aF(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,i=w.parseAxisParam([s],r.shape),o=eF({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=T.expandShapeToKeepDim(o.shape,i),u=ce({inputs:{x:o},backend:n,attrs:{shape:l}}),p=nF({inputs:{a:r,b:u},backend:n}),d=ZA({inputs:{x:p},backend:n}),c=Vf({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),h=ce({inputs:{x:c},backend:n,attrs:{shape:l}}),m=tF({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),m}var Xse={kernelName:zo,backendName:\"webgl\",kernelFunc:aF};function Yse(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a,l=o?r:aF({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],p=l.shape[1],d=new Gse(u,p,s),c=[[i]],h=n.runWebGLProgram(d,[l],\"int32\",c);return o||n.disposeIntermediateTensorInfo(l),h}var Zse={kernelName:Tu,backendName:\"webgl\",kernelFunc:Yse},Jse=Da+`\n  return -x;\n`,Qse=`\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;function eie(e){let{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){let s=n.texData.get(a.dataId),[i,o]=xQ(s.values,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,i)}let r;return G().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")?r=new ts(a.shape,Qse):r=new rr(a.shape,Jse),n.runWebGLProgram(r,[a],a.dtype)}var tie={kernelName:Cu,backendName:\"webgl\",kernelFunc:eie},nie=mr.nonMaxSuppressionV3Impl;function aie(e){T.warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=a,u=n.readSync(r.dataId),p=n.readSync(s.dataId),{selectedIndices:d}=nie(u,p,i,o,l);return n.makeTensorInfo([d.length],\"int32\",new Int32Array(d))}var rie={kernelName:_u,backendName:\"webgl\",kernelFunc:aie},sie=mr.nonMaxSuppressionV4Impl;function iie(e){T.warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=a,p=n.readSync(r.dataId),d=n.readSync(s.dataId),{selectedIndices:c,validOutputs:h}=sie(p,d,i,o,l,u);return[n.makeTensorInfo([c.length],\"int32\",new Int32Array(c)),n.makeTensorInfo([],\"int32\",new Int32Array([h]))]}var oie={kernelName:Au,backendName:\"webgl\",kernelFunc:iie},lie=mr.nonMaxSuppressionV5Impl;function uie(e){T.warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");let{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=a,p=n.readSync(r.dataId),d=n.readSync(s.dataId),c=i,h=o,m=l,f=u,{selectedIndices:g,selectedScores:b}=lie(p,d,c,h,m,f);return[n.makeTensorInfo([g.length],\"int32\",new Int32Array(g)),n.makeTensorInfo([b.length],\"float32\",new Float32Array(b))]}var pie={kernelName:Fu,backendName:\"webgl\",kernelFunc:uie},cie=class{constructor(e,t,n,a){this.variableNames=[\"indices\"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${a}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},die=e=>{let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,u=w.sizeFromShape(r.shape),p=new cie(u,i,o,l),d=ce({inputs:{x:r},backend:n,attrs:{shape:[u]}}),c=n.runWebGLProgram(p,[d],s);n.disposeIntermediateTensorInfo(d);let h=[...r.shape,i],m=ce({inputs:{x:c},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(c),m},hie={kernelName:yo,backendName:\"webgl\",kernelFunc:die};function fm(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"complex64\"){let r=Fd({inputs:{input:a},backend:n}),s=fm({inputs:{x:r},backend:n}),i=Uf({inputs:{input:a},backend:n}),o=fm({inputs:{x:i},backend:n}),l=$s({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $d({attrs:{shape:a.shape,dtype:a.dtype,value:a.dtype===\"string\"?\"\":0},backend:n})}var mie={kernelName:Yu,backendName:\"webgl\",kernelFunc:fm};function rF(e){let{inputs:t,backend:n}=e,{x:a}=t;if(a.dtype===\"string\")throw new Error(\"onesLike is not supported under string dtype\");if(a.dtype===\"complex64\"){let r=Fd({inputs:{input:a},backend:n}),s=rF({inputs:{x:r},backend:n}),i=Uf({inputs:{input:a},backend:n}),o=fm({inputs:{x:i},backend:n}),l=$s({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return $d({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:n})}var fie={kernelName:$u,backendName:\"webgl\",kernelFunc:rF};function gie(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return gv({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,\"All tensors passed to stack must have matching shapes\"),w.assert(i===p.dtype,()=>\"All tensors passed to stack must have matching dtypes\")});let o=[],l=t.map(p=>{let d=gv({inputs:{input:p},backend:n,attrs:{dim:r}});return o.push(d),d}),u=UA({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(p=>n.disposeIntermediateTensorInfo(p)),u}var bie={kernelName:Du,backendName:\"webgl\",kernelFunc:gie},yie=class{constructor(e,t,n){this.variableNames=[\"x\"],this.customUniforms=[{name:\"value\",type:\"float\"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let a=e.length,r=ht(a),s=t.map(l=>l[0]).join(\",\"),i=t.map((l,u)=>l[0]+e[u]).join(\",\"),o=[\"coords[0]\",\"coords[1]\",\"coords[2]\",\"coords[3]\"].slice(0,a);if(a===1){this.userCode=`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;return}this.userCode=`\n      ${r} start = ${r}(${s});\n      ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `}},xie=class{constructor(e,t,n){this.variableNames=[\"x\"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:\"value\",type:\"float\"}],this.outputShape=t.map((m,f)=>m[0]+e[f]+m[1]);let a=e.length,r=ht(a),s=t.map(m=>m[0]).join(\",\"),i=t.map((m,f)=>m[0]+e[f]).join(\",\"),o=In(\"rc\",a),l=In(\"source\",a),u=`${o[a-1]} < ${this.outputShape[a-1]}`,p=a===1?\"source\":`vec2(${l.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${o[a-1]} += 1;\n       if(${u}) {\n      `,a===1?\"\":`}\n       rc = outputLoc;\n       ${o[a-2]} += 1;\n       if(${o[a-2]} < ${this.outputShape[a-2]}) {`,a===1?\"\":`  ${o[a-1]} += 1;\n         if(${u}) {`],c=a===1?\"rc < start || rc >= end\":\"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))\",h=\"\";for(let m=0,f=a===1?2:4;m<f;m++)h+=`\n        ${d[m]}\n        if (${c}) {\n          result[${m}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${m}] = getChannel(getX(${l.join()}), ${p});\n        }\n      `;h+=a===1?\"} \":\"}}\",this.userCode=`\n      const ${r} start = ${r}(${s});\n      const ${r} end = ${r}(${i});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},sF=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:i}=a;if(w.sizeFromShape(r.shape)===0){let u=s.map((p,d)=>p[0]+r.shape[d]+p[1]);return $d({backend:n,attrs:{shape:u,value:i,dtype:r.dtype}})}let o=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new xie(r.shape,s,i):new yie(r.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[r],r.dtype,l)},vie={kernelName:xo,backendName:\"webgl\",kernelFunc:sF},wie=`\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`,kie=`\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  `+Qo+`\n  return result;\n`,Iie=hn({opSnippet:wie,packedOpSnippet:kie}),Sie={kernelName:vo,backendName:\"webgl\",kernelFunc:Iie};function Nie(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:i}=a,o=r.shape.length,l=[],u=w.parseAxisParam(s,r.shape),p=u,d=T.getAxesPermutation(p,o),c=r;d!=null&&(c=Sn({inputs:{x:r},backend:n,attrs:{perm:d}}),p=T.getInnerMostAxes(p.length,o),l.push(c)),T.assertAxesAreInnerMostDims(\"prod\",p,o);let h;if(n.shouldExecuteOnCPU([c])){let m=n.texData.get(c.dataId).values,{outVals:f,outShape:g,outDtype:b}=wQ(c.shape,c.dtype,m,p);h=n.makeTensorInfo(g,b,f)}else{let[m,f]=T.computeOutAndReduceShapes(c.shape,p),g=w.sizeFromShape(f),b=ce({inputs:{x:c},backend:n,attrs:{shape:[-1,g]}}),y=Mm(r.dtype),x=el(b,y,\"prod\",n);h=ce({inputs:{x},backend:n,attrs:{shape:m}}),l.push(b),l.push(x)}if(i){l.push(h);let m=T.expandShapeToKeepDim(h.shape,u);h=ce({inputs:{x:h},backend:n,attrs:{shape:m}})}return l.forEach(m=>n.disposeIntermediateTensorInfo(m)),h}var Tie={kernelName:ko,backendName:\"webgl\",kernelFunc:Nie};function Cie(e){let{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=a,l=r.map(b=>n.readSync(b.dataId)),u=r.map(b=>b.shape),p=n.readSync(s.dataId),d=n.readSync(i.dataId),[c,h,m]=kQ(l,u,p,s.shape,s.dtype,d,i.shape,o),f=c.map(b=>n.makeTensorInfo([b.length],\"int32\",b)),g=n.makeTensorInfo(m,s.dtype,h);return f.concat([g])}var Eie={kernelName:Am,backendName:\"webgl\",kernelFunc:Cie};function _ie(e){let{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,p]=IQ(i,a.shape,a.dtype,o,r.shape,l,s.shape),d=n.makeTensorInfo([u.length],\"int32\",u),c=n.makeTensorInfo([p.length],a.dtype,p);return[d,c]}var Aie={kernelName:Fm,backendName:\"webgl\",kernelFunc:_ie};function Fie(e){let{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=a,u=n.readSync(r.dataId),p=n.readSync(s.dataId),d=n.readSync(i.dataId),c=o.map(g=>n.readSync(g.dataId)),h=o.map(g=>g.shape),[m,f]=SQ(u,r.shape,p,s.shape,s.dtype,d,i.shape,c,h,l);return n.makeTensorInfo(m,s.dtype,f)}var $ie={kernelName:$m,backendName:\"webgl\",kernelFunc:Fie},iF=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=NQ(a,r,s,i);return t.makeTensorInfo([o.length],i,o)},Die={kernelName:Uc,backendName:\"webgl\",kernelFunc:iF},Rie=\"return 1.0 / x;\",Mie=Ze({opSnippet:Rie}),Oie={kernelName:Io,backendName:\"webgl\",kernelFunc:Mie},Pie=Da+`\n  return (x < 0.0) ? 0.0 : x;\n`,Lie=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,zie=Ze({opSnippet:Pie,packedOpSnippet:Lie}),Wie={kernelName:So,backendName:\"webgl\",kernelFunc:zie},Bie=Da+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`,Vie=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,Uie=Ze({opSnippet:Bie,packedOpSnippet:Vie}),Gie={kernelName:Co,backendName:\"webgl\",kernelFunc:Uie},Hie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d;r?d=\"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)\":d=\"vec2(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},jie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d;r?d=\"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)\":d=\"vec3(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]},\n          ${u[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};function qie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,p=G().getBool(\"WEBGL_PACK_IMAGE_OPERATIONS\")?new jie(r.shape,l,u,s,i):new Hie(r.shape,l,u,s,i);return n.runWebGLProgram(p,[r],\"float32\")}var Kie={kernelName:To,backendName:\"webgl\",kernelFunc:qie},Xie=class{constructor(e,t,n){this.variableNames=[\"dy\"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,c=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(c)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function Yie(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new Xie(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Zie={kernelName:Ou,backendName:\"webgl\",kernelFunc:Yie},Jie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?\"0.5\":\"0.0\",c;r?c=\"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))\":c=\"vec2(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${c};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},Qie=class{constructor(e,t,n,a,r){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u=[a&&t>1?i-1:i,a&&n>1?o-1:o],p=[a&&t>1?t-1:t,a&&n>1?n-1:n],d=a?\"0.5\":\"0.0\",c;r?c=\"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))\":c=\"vec3(yRC) * effectiveInputOverOutputRatioRC\",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/p[0]},\n          ${u[1]/p[1]},\n          ${u[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${c};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};function eoe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,p=G().getBool(\"WEBGL_PACK_IMAGE_OPERATIONS\")?new Qie(r.shape,l,u,s,i):new Jie(r.shape,l,u,s,i);return n.runWebGLProgram(p,[r],r.dtype)}var toe={kernelName:No,backendName:\"webgl\",kernelFunc:eoe},noe=class{constructor(e,t,n){this.variableNames=[\"dy\"],this.outputShape=[],this.outputShape=t;let[,a,r]=t,[,s,i]=e,o=[n&&s>1?a-1:a,n&&i>1?r-1:r],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,c=1/p,h=Math.ceil(d)*2+2,m=Math.ceil(c)*2+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function aoe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=new noe(s.shape,r.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var roe={kernelName:Mu,backendName:\"webgl\",kernelFunc:aoe},soe=class{constructor(e,t){this.variableNames=[\"x\"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `;return}let a=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,r=e.map((i,o)=>a(o)).join(\",\"),s=ht(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}},ioe=class{constructor(e,t){this.variableNames=[\"x\"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let a=In(\"rc\",n),r=`${a[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${a[n-2]} + 1 < ${this.outputShape[n-2]}`,i=ht(n);n===1?this.userCode=`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:this.userCode=`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o(a.slice())};\n          if(${r}){\n            result.g = ${l(a.slice())};\n          }\n          if(${s}) {\n            result.b = ${u(a.slice())};\n            if(${r}) {\n              result.a = ${p(a.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;function o(h){return d(h)}function l(h){return h[n-1]=\"(\"+h[n-1]+\" + 1)\",d(h)}function u(h){return h[n-2]=\"(\"+h[n-2]+\" + 1)\",d(h)}function p(h){return h[n-1]=\"(\"+h[n-1]+\" + 1)\",h[n-2]=\"(\"+h[n-2]+\" + 1)\",d(h)}function d(h){let m=e.map((b,y)=>c(y,h)),f=m.join(\",\"),g=m.slice(-2).join(\",\");return`getChannel(getX(${f}), vec2(${g}))`}function c(h,m){return t.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - ${m[h]} - 1`:`${m[h]}`}}};function ooe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=r.shape.length,o=w.parseAxisParam(s,r.shape);if(i===0)return ta({inputs:{x:r},backend:n});let l=G().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\")?new ioe(r.shape,o):new soe(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}var loe={kernelName:Eo,backendName:\"webgl\",kernelFunc:ooe},uoe=class{constructor(e,t){this.variableNames=[\"Image\"],this.outputShape=[],this.customUniforms=[{name:\"params\",type:\"vec4\"}];let n=e[1],a=e[2];this.outputShape=e;let r=\"\";typeof t==\"number\"?r=`float outputValue = ${t.toFixed(2)};`:r=`\n        vec3 fill = vec3(${t.join(\",\")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},poe={kernelName:Zu,backendName:\"webgl\",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:a}=e,{radians:r,fillValue:s,center:i}=t,o=n,l=new uoe(a.shape,s),[u,p]=T.getImageCenter(i,a.shape[1],a.shape[2]),d=[[u,p,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(l,[a],a.dtype,d)}},coe=`\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n`,doe=Ze({opSnippet:coe}),hoe={kernelName:_o,backendName:\"webgl\",kernelFunc:doe},moe=\"return inversesqrt(x);\",foe=Ze({opSnippet:moe,cpuKernelImpl:TQ}),goe={kernelName:Ao,backendName:\"webgl\",kernelFunc:foe},dk=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=[\"updates\",\"indices\",\"defaultValue\"],this.outputShape=s;let l=ht(r.length),u=ht(s.length),p=\"\";n===1?p=\"i\":n===2&&(p=\"i, j\");let d=`getIndices(${p})`,c=\"\";a===1?c=\"i\":a===2&&(c=\"i, coords[1]\");let h=`getUpdates(${c})`,m=\"\";o&&(m=\"coords[0], coords[1]\");let f=`getDefaultValue(${m})`,g=t>1?\"strides[j]\":\"strides\";this.userCode=`\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}},boe=class{constructor(e,t,n,a,r,s,i=!0,o=!1){this.variableNames=[\"updates\",\"indices\",\"defaultValue\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=ht(r.length),u=ht(s.length),p=\"\";n===1?p=\"i\":n===2&&(p=\"i, j\");let d=`getIndices(${p})`,c=\"\";a===1?c=\"i\":a===2&&(c=\"i, coords[1]\");let h=`getUpdates(${c})`,m=\"\";o&&(m=\"coords[0], coords[1]\");let f=`getDefaultValue(${m})`,g=t>1?\"strides[j]\":\"strides\",b=t>1?\"strides[j + 1]\":\"strides\";this.userCode=`\n        ${l} strides = ${l}(${r});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}};function yoe(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:i}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=T.calculateShapes(s,r,i),c=[d/u,u];if(d===0)return n.makeTensorInfo(i,r.dtype);let h=ce({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),m=ce({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),f=n.makeTensorInfo([],\"float32\",new Float32Array([0])),g;G().getBool(\"WEBGL_PACK\")?g=new boe(l,o,h.shape.length,m.shape.length,p,c):g=new dk(l,o,h.shape.length,m.shape.length,p,c);let b=n.runWebGLProgram(g,[m,h,f],m.dtype),y=ce({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(f),y}var xoe={kernelName:Pu,backendName:\"webgl\",kernelFunc:yoe},voe=class{constructor(e,t,n,a){this.variableNames=[\"sortedSequence\",\"values\"],this.customUniforms=[{name:\"numInputs\",type:\"int\"}],this.outputShape=[e,n];let r=\"while (left < right) {\",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=G().getNumber(\"WEBGL_VERSION\")===2?r:s,o=a===\"left\"?\"<\":\"<=\";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};function woe(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a,o=new voe(r.shape[0],r.shape[1],s.shape[1],i),l=[[r.shape[1]]];return n.runWebGLProgram(o,[r,s],\"int32\",l)}var koe={kernelName:zu,backendName:\"webgl\",kernelFunc:woe},Ioe=class{constructor(e,t,n){this.variableNames=[\"c\",\"a\",\"b\"],this.outputShape=t;let a,r;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)r=\"resRC\",a=\"resRC\";else{let i=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&o.push(`${i[u]}`);a=o.join(),r=l.join()}let s=ht(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${a});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}};function Soe(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=new Ioe(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[a,r,s],fa(r.dtype,s.dtype))}var Noe={kernelName:Wu,backendName:\"webgl\",kernelFunc:Soe},Toe=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${T.SELU_SCALEALPHA};\n  float scale = ${T.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,Coe=Ze({opSnippet:Toe}),Eoe={kernelName:Fo,backendName:\"webgl\",kernelFunc:Coe},_oe=mp+`\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`,Aoe=`\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`,Foe=Ze({opSnippet:_oe,packedOpSnippet:Aoe,cpuKernelImpl:EQ}),$oe={kernelName:Mo,backendName:\"webgl\",kernelFunc:Foe},Doe=`\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n`,Roe=Ze({opSnippet:Doe}),Moe={kernelName:Ro,backendName:\"webgl\",kernelFunc:Roe},Ooe=mp+`\n  return sin(x);\n`,Poe=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Qo}\n  return result;\n`,Loe=Ze({opSnippet:Ooe,packedOpSnippet:Poe}),zoe={kernelName:$o,backendName:\"webgl\",kernelFunc:Loe},Woe=`\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n`,Boe=Ze({opSnippet:Woe}),Voe={kernelName:Do,backendName:\"webgl\",kernelFunc:Boe},Uoe=`\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n`,Goe=Ze({opSnippet:Uoe}),Hoe={kernelName:Oo,backendName:\"webgl\",kernelFunc:Goe},joe=e=>{let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a;w.assert(r.shape.length<=4,()=>\"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\");let o=s.reduce((b,y)=>b*y),l=[[0,0]];l.push(...i);for(let b=1+s.length;b<r.shape.length;++b)l.push([0,0]);let u=[],p=sF({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),d=T.getReshaped(p.shape,s,o,!1),c=T.getPermuted(d.length,s.length,!1),h=T.getReshapedPermuted(p.shape,s,o,!1),m=ce({inputs:{x:p},backend:n,attrs:{shape:d}}),f=Sn({inputs:{x:m},backend:n,attrs:{perm:c}}),g=ce({inputs:{x:f},backend:n,attrs:{shape:h}});return u.push(p),u.push(m),u.push(f),u.forEach(b=>n.disposeIntermediateTensorInfo(b)),g},qoe={kernelName:Vu,backendName:\"webgl\",kernelFunc:joe};function Koe(e){let{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(a.shape.length!==2)throw new Error(`Indices must be a matrix, saw:\n         ${a.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(a.dataId),l=n.readSync(r.dataId),u=n.readSync(s.dataId),p=n.readSync(i.dataId)[0],[d,c,h,m,f]=AQ(o,a.shape,a.dtype,l,r.dtype,u,p);return[n.makeTensorInfo(c,a.dtype,d),n.makeTensorInfo([c[0]],r.dtype,h),n.makeTensorInfo([m.length],\"bool\",new Uint8Array(m.map(g=>Number(g)))),n.makeTensorInfo([f.length],a.dtype,new Int32Array(f))]}var Xoe={kernelName:Gc,backendName:\"webgl\",kernelFunc:Koe};function Yoe(e){let{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(r.dataId)),o=n.readSync(a.dataId),l=Array.from(n.readSync(s.dataId)),[u,p,d]=FQ(o,a.shape,a.dtype,i,l);return[n.makeTensorInfo(p,a.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var Zoe={kernelName:Gu,backendName:\"webgl\",kernelFunc:Yoe};function Joe(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,p]=EA(i,a.shape,a.dtype,o,l,!0);return n.makeTensorInfo(p,a.dtype,u)}var Qoe={kernelName:Hc,backendName:\"webgl\",kernelFunc:Joe};function ele(e){let{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error(\"Data should be at least 1 dimensional but received scalar\");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(a.dataId),o=n.readSync(r.dataId),l=n.readSync(s.dataId),[u,p]=EA(i,a.shape,a.dtype,o,l);return n.makeTensorInfo(p,a.dtype,u)}var tle={kernelName:jc,backendName:\"webgl\",kernelFunc:ele};function nle(e){let{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=a,{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=T.calculateShapes(s,r,o),h=!1;if(s.dtype===\"string\"){let b=n.bufferSync(r),y=n.bufferSync(s),x=w.decodeString(n.readSync(i.dataId)[0]),v=CQ(b,y,o,c,p,u,l,d,x,h);return n.makeTensorInfo(o,v.dtype,v.values)}let m=new dk(u,l,r.shape.length,s.shape.length,d,[c,1],h),f=n.runWebGLProgram(m,[s,r,i],s.dtype),g=ce({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),g}var ale={kernelName:Hu,backendName:\"webgl\",kernelFunc:nle};function rle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=w.parseAxisParam(i,r.shape)[0],l=T.prepareSplitSize(r,s,o),u=r.shape.length,p=new Array(u).fill(0),d=r.shape.slice();return l.map(c=>{let h=[...d];h[o]=c;let m=fp({inputs:{x:r},backend:n,attrs:{begin:p,size:h}});return p[o]+=c,m})}var sle={kernelName:Uu,backendName:\"webgl\",kernelFunc:rle},IS=\"return sqrt(x);\",ile=Ze({opSnippet:IS,packedOpSnippet:IS,cpuKernelImpl:$Q}),ole={kernelName:Po,backendName:\"webgl\",kernelFunc:ile},lle=\"return x * x;\",ule=Ze({opSnippet:lle}),ple={kernelName:qc,backendName:\"webgl\",kernelFunc:ule},SS=\"return (a - b) * (a - b);\",cle=hn({opSnippet:SS,packedOpSnippet:SS}),dle={kernelName:Wo,backendName:\"webgl\",kernelFunc:cle};function hle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if(r.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");let s=n.readSync(r.dataId),i=T.fromUint8ToStringArray(s),o=DQ(i,\"string\",a);return n.makeTensorInfo(r.shape,\"string\",o)}var mle={kernelName:Kc,backendName:\"webgl\",kernelFunc:hle};function fle({inputs:e,attrs:t,backend:n}){let{x:a}=e,r=Da+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new rr(a.shape,r);return n.runWebGLProgram(s,[a],a.dtype)}var gle={kernelName:Is,backendName:\"webgl\",kernelFunc:fle},ble=class{constructor(e,t,n){this.variableNames=[\"x\"],this.outputShape=n;let a=n.length,r=ht(n.length),s=ht(n.length),i=\"\";if(a===1)i=\"coords * strides + begin\";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(\",\")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};function yle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a,{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=Kt.sliceInfo(r.shape,s,i,o,l,u,p,d,c),I;if(f)I=ce({inputs:{x:r},backend:n,attrs:{shape:m}});else if(g||b){w.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let C=Kt.computeOutShape(y,x,v),_=fp({inputs:{x:r},backend:n,attrs:{begin:y,size:C}});I=ce({inputs:{x:_},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(_)}else if(n.shouldExecuteOnCPU([r])){let C=n.readSync(r.dataId),_=Oe(r.shape,r.dtype,C),F=RQ(h,_,v,y);I=n.makeTensorInfo(m,r.dtype,F.values)}else{let C=new ble(y,v,h);I=n.runWebGLProgram(C,[r],r.dtype)}let N=ce({inputs:{x:I},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(I),N}var xle={kernelName:ju,backendName:\"webgl\",kernelFunc:yle};function vle(e){let{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=a,{data:p,dataSplits:d}=t,c=n.readSync(p.dataId),h=n.readSync(d.dataId),[m,f]=MQ(c,h,r,s,i,o,l,u);return[n.makeTensorInfo([m.length],\"string\",m),n.makeTensorInfo(d.shape,\"int32\",f)]}var wle={kernelName:Xc,backendName:\"webgl\",kernelFunc:vle};function kle(e){let{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:i}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,p,d]=OQ(o,l,r),c=p.length;return[n.makeTensorInfo([c,2],\"int32\",u),n.makeTensorInfo([c],\"string\",p),n.makeTensorInfo([2],\"int32\",new Int32Array(d))]}var Ile={kernelName:Yc,backendName:\"webgl\",kernelFunc:kle};function Sle(e){let{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if(s.dtype!==\"string\")throw new Error(\"Input must be of datatype string\");if(r<=0)throw new Error(\"Number of buckets must be at least 1\");let i=n.readSync(s.dataId),o=PQ(i,r);return n.makeTensorInfo(s.shape,\"int32\",o)}var Nle={kernelName:Zc,backendName:\"webgl\",kernelFunc:Sle},Tle=\"return tan(x);\",Cle=Ze({opSnippet:Tle}),Ele={kernelName:Vo,backendName:\"webgl\",kernelFunc:Cle},_le=`\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n`,Ale=Ze({opSnippet:_le}),Fle={kernelName:Uo,backendName:\"webgl\",kernelFunc:Ale};function $le(e){let{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=t,{}=a,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=T.calculateShapes(i,s,r.shape),c=[d/u,u];if(d===0)return n.makeTensorInfo(r.shape,s.dtype);let h=ce({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),m=ce({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),f=ce({inputs:{x:r},backend:n,attrs:{shape:c}}),g=new dk(l,o,h.shape.length,m.shape.length,p,c,!1,!0),b=n.runWebGLProgram(g,[m,h,f],f.dtype),y=ce({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),y}var Dle={kernelName:Lu,backendName:\"webgl\",kernelFunc:$le},Rle=class{constructor(e,t){this.variableNames=[\"A\"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let a=ht(this.rank),r=Mle(e);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}};function Mle(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=[\"resRC.x\",\"resRC.y\",\"resRC.z\",\"resRC.w\",\"resRC.u\"],a=[];for(let r=0;r<e.length;r++)a.push(`imod(${n[r]}, ${e[r]})`);return a.join()}function oF(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if(r.dtype===\"string\"||r.shape.length>5){let o=n.readSync(r.dataId),l=r.dtype===\"string\"?o.map(d=>w.decodeString(d)):o,u=Oe(r.shape,r.dtype,l),p=zQ(u,s);return n.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new Rle(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}var Ole={kernelName:ks,backendName:\"webgl\",kernelFunc:oF},Ple=class{constructor(e){this.variableNames=[\"x\",\"indices\"],this.customUniforms=[{name:\"n\",type:\"int\"},{name:\"firstPass\",type:\"int\"},{name:\"negativeInf\",type:\"float\"},{name:\"dir\",type:\"int\"},{name:\"inc\",type:\"int\"}],this.outputShape=e,this.userCode=`\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     `}},Lle=class{constructor(e){this.variableNames=[\"x\",\"indices\"],this.customUniforms=[{name:\"n\",type:\"int\"},{name:\"firstPass\",type:\"int\"},{name:\"k\",type:\"int\"}],this.outputShape=e,this.userCode=`\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     `}};function qs(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function NS(e){let t=1;for(;t<e;)t*=2;return t}function zle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:i}=a,o=G().getNumber(\"TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD\"),l=G().getNumber(\"TOPK_K_CPU_HANDOFF_THRESHOLD\"),u=r.shape,p=u[u.length-1];if(n.shouldExecuteOnCPU([r])||p<o||s>l){let F=n.readSync(r.dataId),[D,$]=WQ(F,u,r.dtype,s,i);return[n.makeTensorInfo(D.shape,D.dtype,D.values),n.makeTensorInfo($.shape,$.dtype,$.values)]}if(s===0)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,\"int32\",[])];if(p===1)return[r,$d({attrs:{shape:u,dtype:\"int32\",value:0},backend:n})];let d=n.texData.get(r.dataId),c=d!==null&&d.isPacked,h=c?n.unpackTensor(r):r,m=w.sizeFromShape(u)/p,f=ce({inputs:{x:h},attrs:{shape:[m,p]},backend:n});c&&qs(n,h);let g=NS(s),b=NS(p),y=null,x=()=>y===null?[f,f]:[f,y],v=(F,D,$)=>{let S=x(),M=new Ple($),B=[[p],[y===null?1:0],[Number.NEGATIVE_INFINITY],[F],[D]],U=y;y=n.runWebGLProgram(M,S,\"int32\",B),qs(n,U)};for(let F=1;F<g;F*=2){let D=F*2;for(let $=F;$>=1;$/=2)v(D,$,[m,b])}for(let F=b;F>g;F/=2){let D=x(),$=new Lle([m,F/2]),S=[[p],[y===null?1:0],[g]],M=y;y=n.runWebGLProgram($,D,\"int32\",S),qs(n,M);let B=g/2,U=B*2;for(let H=B;H>=1;H/=2)v(U,H,y.shape)}let I=y;y=fp({inputs:{x:y},backend:n,attrs:{begin:0,size:[m,s]}}),qs(n,I);let N=QA({inputs:{x:f,indices:y},backend:n,attrs:{axis:1,batchDims:1}});qs(n,f);let C=u.slice(0,-1);C.push(s),I=y,y=ce({inputs:{x:y},attrs:{shape:C},backend:n}),qs(n,I);let _=N;return N=ce({inputs:{x:N},attrs:{shape:C},backend:n}),qs(n,_),[N,y]}var Wle={kernelName:qu,backendName:\"webgl\",kernelFunc:zle},Ble=class{constructor(e,t,n,a,r,s){this.variableNames=[\"Image\",\"Transforms\"],this.outputShape=s;let i=n===\"nearest\"?1:2,o;switch(a){case\"constant\":o=1;break;case\"reflect\":o=2;break;case\"wrap\":o=3;break;case\"nearest\":o=4;break;default:o=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};function Vle(e){let{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=a,[p,d,c,h]=r.shape,[m,f]=u!=null?u:[d,c],g=[p,m,f,h],b=new Ble(d,c,i,o,l,g);return n.runWebGLProgram(b,[r,s],\"float32\")}var Ule={kernelName:Ku,backendName:\"webgl\",kernelFunc:Vle};function Gle(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;lp(s,\"unique\"),console.warn(\"WARNING: \",\"UI might be locked temporarily as data is being downloaded\");let i=a.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=BQ(i,r,s.shape,s.dtype);return[a.makeTensorInfo(l,s.dtype,o),a.makeTensorInfo([u.length],\"int32\",u)]}var Hle={kernelName:Jc,backendName:\"webgl\",kernelFunc:Gle};function jle(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r,o=i.shape.length,l=r.shape[s],u=new Array(o-1),p=0;for(let f=0;f<o;f++)f!==s&&(u[p++]=i.shape[f]);let d=[],c=new Array(o).fill(0),h=i.shape.slice();h[s]=1;let m=new Array(l);for(let f=0;f<m.length;f++){c[s]=f;let g=fp({inputs:{x:i},backend:n,attrs:{begin:c,size:h}}),b=ce({inputs:{x:g},backend:n,attrs:{shape:u}});m[f]=b,d.push(g)}return d.forEach(f=>n.disposeIntermediateTensorInfo(f)),m}var qle={kernelName:Xu,backendName:\"webgl\",kernelFunc:jle},Kle=class{constructor(e,t){this.variableNames=[\"x\",\"segmentIds\"];let n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/n);this.outputShape=[a,i];let o=\"0.0\",l=\"sumValue\",u=Math.floor(n/4)*4,p=n%4,d=`\n        sumValue += dot(values, segFilter);\n    `,c=\"\";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h=\"\";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${p===1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${d}\n        } else if (${p===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${d}\n        } else if (${p===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function Xle(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:i}=a,o=r.shape.length,l=[],u=0,p=T.getAxesPermutation([u],o),d=r;p!=null&&(d=Sn({inputs:{x:r},backend:n,attrs:{perm:p}}),l.push(d),u=T.getInnerMostAxes(1,o)[0]);let c=T.segment_util.computeOutShape(d.shape,u,i),h=w.sizeFromShape([d.shape[u]]),m=ce({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(m);let f=Mm(r.dtype),g=(v,I,N,C,_)=>{let F=v.shape[0],D=v.shape[1],$=T.segment_util.segOpComputeOptimalWindowSize(D,_),S={windowSize:$,inSize:D,batchSize:F,numSegments:_},M=new Kle(S,I),B=n.compileAndRun(M,[v,N],C);if(l.push(B),B.shape[1]===_)return B;let U=iF({backend:n,attrs:{start:0,stop:_,step:1,dtype:\"float32\"}}),H=oF({inputs:{x:U},backend:n,attrs:{reps:[D/$]}});return l.push(U),l.push(H),g(B,I,H,C,_)},b=g(m,\"unsortedSegmentSum\",s,f,i),y=ce({inputs:{x:b},backend:n,attrs:{shape:c}}),x=y;if(p!=null){l.push(y);let v=T.getUndoAxesPermutation(p);x=Sn({inputs:{x},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var Yle={kernelName:Qc,backendName:\"webgl\",kernelFunc:Xle},Zle=[Ree,Oee,zee,Vee,Gee,qee,Xee,Zee,tte,ate,ite,ute,dte,gte,xte,wte,Ite,Cte,_te,Fte,Mte,Vte,Gte,Kte,Yte,nne,rne,lne,bee,cne,gne,vne,Tne,_ne,Fne,Dne,Mne,zne,Vne,Hne,qne,Xne,Zne,eae,nae,iae,lae,cae,mae,gae,vae,Sae,Eae,Fae,Rae,Mae,Pae,zae,Bae,Uae,Hae,Xae,Jae,tre,are,ire,ure,hre,bre,gee,xre,mne,kre,Nre,Ere,xee,$re,Ore,Lre,Vre,Hre,Xre,Jre,nse,ise,use,cse,fse,bse,xse,Ise,Nse,Cse,_se,Fse,Mse,zse,Use,Zse,kee,tie,rie,oie,pie,Jte,hie,fie,bie,vie,Sie,wee,Tie,Eie,Aie,$ie,Die,Qte,qse,Oie,Wie,Gie,See,Kie,Zie,toe,roe,loe,poe,hoe,goe,xoe,koe,Noe,Eoe,$oe,Moe,zoe,Voe,Wte,Xse,Hoe,qoe,Xoe,Zoe,Qoe,tle,ale,sle,ole,ple,dle,mle,gle,xle,wle,Ile,Nle,Kse,Fee,Ele,Fle,Dle,Ole,Wle,Ule,$ee,Hle,qle,Yle,mie];for(let e of Zle)ed(e);var Qe;(function(e){e[e.float32=0]=\"float32\",e[e.int32=1]=\"int32\",e[e.bool=2]=\"bool\",e[e.string=3]=\"string\",e[e.complex64=4]=\"complex64\"})(Qe||(Qe={}));var Ac;(function(e){e[e.linear=0]=\"linear\",e[e.relu=1]=\"relu\",e[e.relu6=2]=\"relu6\",e[e.prelu=3]=\"prelu\",e[e.leakyrelu=4]=\"leakyrelu\",e[e.sigmoid=5]=\"sigmoid\",e[e.elu=6]=\"elu\"})(Ac||(Ac={}));var lF;function Jle(e){lF=e.wasm.cwrap(ii,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Qle(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t;if(r.dtype!==\"float32\"||s.dtype!==\"float32\")throw new Error(\"_FusedMatMul for non non-float32 tensors not yet supported.\");let{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=a,c=n.dataIdMap.get(r.dataId).id,h=n.dataIdMap.get(s.dataId).id,m=0;if(i!=null){let _=n.dataIdMap.get(i.dataId);if(_.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${_.shape.length}.`);m=_.id}let f=o==null?0:n.dataIdMap.get(o.dataId).id,g=Ac[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let b=l?r.shape[2]:r.shape[1],y=u?s.shape[1]:s.shape[2],x=Ju.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),v=n.makeOutput([...x,b,y],r.dtype),I=n.dataIdMap.get(v.dataId).id,N=new Uint8Array(new Int32Array(r.shape).buffer),C=new Uint8Array(new Int32Array(s.shape).buffer);return lF(c,N,r.shape.length,h,C,s.shape.length,l,u,g,m,f,d||0,I),v}var eue={kernelName:ii,backendName:\"wasm\",setupFunc:Jle,kernelFunc:Qle};function Xe(e,t){let n;function a(s){n=s.wasm.cwrap(e,null,[\"number\",\"number\",\"number\"])}function r(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,u=i.makeOutput(o.shape,t||o.dtype),p=i.dataIdMap.get(u.dataId).id;return w.sizeFromShape(u.shape)===0||n(l,Qe[o.dtype],p),u}return{kernelName:e,backendName:\"wasm\",setupFunc:a,kernelFunc:r}}var tue=Xe(Yl),nue=Xe(Ni),aue=Xe(Ti);function Ut(e,t,n){let a;function r(i){a=i.wasm.cwrap(e,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\"])}function s(i){let{backend:o,inputs:l}=i,{a:u,b:p}=l,d=o.dataIdMap.get(u.dataId).id,c=o.dataIdMap.get(p.dataId).id,h=n!=null?n:u.dtype,m=T.assertAndGetBroadcastShape(u.shape,p.shape),f=o.makeOutput(m,h);if(w.sizeFromShape(m)===0)return f;let g=new Uint8Array(new Int32Array(u.shape).buffer),b=new Uint8Array(new Int32Array(p.shape).buffer),y=o.dataIdMap.get(f.dataId).id;return a(d,g,u.shape.length,c,b,p.shape.length,Qe[u.dtype],y),f}return{kernelName:e,backendName:\"wasm\",setupFunc:r,kernelFunc:s}}var rue=!0,sue=Ut(vs,rue),uF;function iue(e){uF=e.wasm.cwrap(Ci,null,[\"array\",\"number\",\"number\",\"number\"])}function oue(e){let{inputs:t,backend:n}=e,a=n.makeOutput(t[0].shape,t[0].dtype);if(w.sizeFromShape(a.shape)===0)return a;let r=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(r).buffer),i=n.dataIdMap.get(a.dataId).id;return uF(s,r.length,Qe[a.dtype],i),a}var lue={kernelName:Ci,backendName:\"wasm\",setupFunc:iue,kernelFunc:oue};function Gf(e){let{inputs:{x:t},backend:n}=e;if(t.dtype===\"string\")return bn(n.readSync(t.dataId),t.shape,t.dtype);let a=n.makeOutput(t.shape,t.dtype),r=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(a).set(r),a}var uue={kernelName:eo,backendName:\"wasm\",kernelFunc:Gf},pF;function pue(e){pF=e.wasm.cwrap(Cr,null,[\"number\",\"array\",\"number\",\"number\",\"number\",\"array\",\"number\"])}function ys(e){let{inputs:t,backend:n,attrs:a}=e,[r,s]=due(t.x.shape,a.perm),i=!0;for(let m=0;m<s.length;m++)s[m]!==m&&(i=!1);let o=cue(t.x.shape,a.perm),l={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){let m=Gf({inputs:t,backend:n});return m.shape=o,m}let u=n.makeOutput(o,l.dtype),p=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return pF(p,h,l.shape.length,Qe[l.dtype],d,c,s.length),u}function cue(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];return n}function due(e,t){let n=[],a=[];for(let r=0;r<e.length;++r)e[r]!==1&&n.push(e[r]),e[t[r]]!==1&&a.push(t[r]);for(let r=0;r<a.length;++r){let s=-1;for(let i=0;i<a.length;++i)a[i]>=r&&(s===-1||a[s]>a[i])&&(s=i);a[s]=r}return[n,a]}var hue={kernelName:Cr,backendName:\"wasm\",kernelFunc:ys,setupFunc:pue};function Ds(e,t,n){let a=e.shape,r=e.shape.length,s=w.parseAxisParam(t,a),i=s,o=T.getAxesPermutation(i,r),l=null,u=!1;if(o!=null){let p=new Array(r);for(let c=0;c<p.length;c++)p[c]=a[o[c]];i=T.getInnerMostAxes(i.length,r),l=ys({inputs:{x:e},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var cF;function mue(e){cF=e.wasm.cwrap(Zl,null,[\"number, number, number\"])}function fue(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=Ds(i,r,t);if(c){let y=t.dataIdMap.get(u.dataId).id;l=u,o=y}let h=l.shape.length;T.assertAxesAreInnerMostDims(\"all\",p,h);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),b=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;cF(o,g,y)}if(c&&t.disposeData(u.dataId),s){let y=T.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var gue={kernelName:Zl,backendName:\"wasm\",setupFunc:mue,kernelFunc:fue},dF;function bue(e){dF=e.wasm.cwrap(Jl,null,[\"number, number, number\"])}function yue(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=Ds(i,r,t);if(c){let y=t.dataIdMap.get(u.dataId).id;l=u,o=y}let h=l.shape.length;T.assertAxesAreInnerMostDims(\"any\",p,h);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),b=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;dF(o,g,y)}if(c&&t.disposeData(u.dataId),s){let y=T.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var xue={kernelName:Jl,backendName:\"wasm\",setupFunc:bue,kernelFunc:yue};function hF(e){let t;function n(r){t=r.wasm.cwrap(e,null,[\"number\",\"number\",\"number\",\"number\",\"number\"])}function a(r){let{backend:s,inputs:i,attrs:o}=r,{axis:l}=o,{x:u}=i,p=s.dataIdMap.get(u.dataId).id,d=p,c=u,{transposed:h,axes:m,inputWasTransposed:f}=Ds(u,l,s);if(f){let I=s.dataIdMap.get(h.dataId).id;I!==p&&(c=h,d=I)}let g=c.shape.slice(0,-1),b=s.makeOutput(g,\"int32\"),y=s.dataIdMap.get(b.dataId).id,x=w.sizeFromShape(b.shape),v=c.shape[m[0]];return t(d,Qe[c.dtype],x,v,y),f&&s.disposeData(h.dataId),b}return{kernelName:e,backendName:\"wasm\",setupFunc:n,kernelFunc:a}}var vue=hF(Ql),wue=hF(eu),kue=Xe(Ei),Iue=Xe(_i),Sue=Xe(Ai),Nue=Ut($i,!1),Tue=Xe(Fi),mF;function Cue(e){mF=e.wasm.cwrap(Di,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Eue(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=T.computePool2DInfo(r.shape,i,o,1,l,u),d=p.filterHeight,c=p.filterWidth,h=p.padInfo.top,m=p.padInfo.right,f=p.padInfo.bottom,g=p.padInfo.left,b=p.strideHeight,y=p.strideWidth,x=p.inChannels;if(p.dataFormat!==\"channelsLast\")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(p.dilationWidth!==1||p.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let v=a.makeOutput(p.outShape,\"float32\"),I=a.dataIdMap.get(v.dataId).id;return mF(s,r.shape[0],r.shape[1],r.shape[2],d,c,h,m,f,g,b,y,x,I),v}var _ue={kernelName:Di,backendName:\"wasm\",setupFunc:Cue,kernelFunc:Eue},fF;function Aue(e){fF=e.wasm.cwrap(\"AvgPool3D\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Fue(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.makeOutput(p.outShape,r.dtype);return fF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}var $ue={kernelName:tu,backendName:\"wasm\",setupFunc:Aue,kernelFunc:Fue},gF;function Due(e){gF=e.wasm.cwrap(\"AvgPool3DGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Rue(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return gF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left,p.filterDepth,p.filterHeight,p.filterWidth),d}var Mue={kernelName:Rc,backendName:\"wasm\",setupFunc:Due,kernelFunc:Rue},bF;function Oue(e){bF=e.wasm.cwrap(\"AvgPoolGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Pue(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l}=a,u=T.computePool2DInfo(s.shape,i,o,1,l),p=n.makeOutput(s.shape,s.dtype);return bF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),p}var Lue={kernelName:Dc,backendName:\"wasm\",setupFunc:Oue,kernelFunc:Pue};function zn(e){let{inputs:t,attrs:n}=e,{x:a}=t,{shape:r}=n,s=w.sizeFromShape(a.shape),i=w.inferFromImplicitShape(r,s);return w.assert(s===w.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(a.dataId),{dataId:a.dataId,shape:i,dtype:a.dtype}}var zue={kernelName:Ru,backendName:\"wasm\",kernelFunc:zn},yF;function Wue(e){yF=e.wasm.cwrap(Ri,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\"])}function Bue(e){let{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=a;if(r.dtype!==\"float32\"||s.dtype!==\"float32\")throw new Error(\"BatchMatMul for non non-float32 tensors not yet supported.\");let l=r.shape.length,u=s.shape.length,p=i?r.shape[l-2]:r.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],c=i?r.shape[l-1]:r.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],m=r.shape.slice(0,-2),f=s.shape.slice(0,-2),g=w.sizeFromShape(m),b=w.sizeFromShape(f),y=Ju.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,h]);w.assert(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,p,c]:[g,c,p],v=o?[b,h,d]:[b,d,h],I=zn({inputs:{x:r},backend:n,attrs:{shape:x}}),N=zn({inputs:{x:s},backend:n,attrs:{shape:v}}),C=n.dataIdMap.get(I.dataId).id,_=n.dataIdMap.get(N.dataId).id,F=i?I.shape[2]:I.shape[1],D=o?N.shape[1]:N.shape[2],$=Math.max(g,b),S=n.makeOutput([$,F,D],I.dtype),M=n.dataIdMap.get(S.dataId).id,B=new Uint8Array(new Int32Array(I.shape).buffer),U=new Uint8Array(new Int32Array(N.shape).buffer);return yF(C,B,I.shape.length,_,U,N.shape.length,i,o,M),n.disposeData(I.dataId),n.disposeData(N.dataId),S.shape=y,S}var Vue={kernelName:Ri,backendName:\"wasm\",setupFunc:Wue,kernelFunc:Bue};function Ii(e){let{inputs:{x:t},attrs:{begin:n,size:a},backend:r}=e,[s,i]=Kt.parseSliceParams(t,n,a),o=Kt.isSliceContinous(t.shape,s,i),l=r.readSync(t.dataId),u=r.makeOutput(i,t.dtype),p=w.computeStrides(t.shape),d=r.dataIdMap.get(u.dataId);if(o){let m=Kt.computeFlatOffset(s,p);return t.dtype===\"string\"?d.stringBytes=l.slice(m,m+w.sizeFromShape(i)):r.typedArrayFromHeap(u).set(l.subarray(m,m+w.sizeFromShape(i))),u}if(t.dtype===\"string\"){let m=um(l,s,i,t.shape,t.dtype);return d.stringBytes=m,u}let c=r.typedArrayFromHeap(u),h=t.shape.length;if(h===2)Uue(l,p[0],c,s,i);else if(h===3)Gue(l,p[0],p[1],c,s,i);else if(h===4)Hue(l,p[0],p[1],p[2],c,s,i);else{let m=um(l,s,i,t.shape,t.dtype);c.set(m)}return u}function Uue(e,t,n,a,r){let s=0,i=a[0],o=a[1],l=i+r[0];for(let u=i;u<l;u++){let p=u*t+o;n.set(e.subarray(p,p+r[1]),s),s+=r[1]}}function Gue(e,t,n,a,r,s){let i=0,o=r[0],l=r[1],u=r[2],p=o+s[0],d=l+s[1];for(let c=o;c<p;c++)for(let h=l;h<d;h++){let m=c*t+h*n+u;a.set(e.subarray(m,m+s[2]),i),i+=s[2]}}function Hue(e,t,n,a,r,s,i){let o=0,l=s[0],u=s[1],p=s[2],d=l+i[0],c=u+i[1],h=p+i[2],m=s[3];for(let f=l;f<d;f++)for(let g=u;g<c;g++)for(let b=p;b<h;b++){let y=f*t+g*n+b*a+m;r.set(e.subarray(y,y+i[3]),o),o+=i[3]}}var jue={kernelName:Bu,backendName:\"wasm\",kernelFunc:Ii};function que(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:i}=a,o=s.reduce((b,y)=>b*y),l=T.getReshaped(r.shape,s,o),u=T.getPermuted(l.length,s.length),p=T.getReshapedPermuted(r.shape,s,o),d=T.getSliceBeginCoords(i,s.length),c=T.getSliceSize(p,i,s.length),h=zn({inputs:{x:r},backend:n,attrs:{shape:l}}),m=ys({inputs:{x:h},backend:n,attrs:{perm:u}}),f=zn({inputs:{x:m},backend:n,attrs:{shape:p}}),g=Ii({inputs:{x:f},backend:n,attrs:{begin:d,size:c}});return n.disposeData(h.dataId),n.disposeData(m.dataId),n.disposeData(f.dataId),g}var Kue={kernelName:nu,backendName:\"wasm\",kernelFunc:que},xF;function Xue(e){xF=e.wasm.cwrap(au,null,[\"number\",\"number\",\"boolean\",\"number\",\"number\",\"number\"])}function Yue(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i}=a,o=s.shape.reduce((d,c)=>d*c,1)!==0,l=r.shape.length===1?[i]:[r.shape[0],i],u=t.makeOutput(l,s.dtype);function p(d){return t.dataIdMap.get(d.dataId).id}return xF(p(r),i,o,p(s),Qe[s.dtype],p(u)),u}var Zue={kernelName:au,backendName:\"wasm\",setupFunc:Xue,kernelFunc:Yue},Jue=!0,Que=Ut(ru,Jue);function epe(e){let{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.typedArrayFromHeap(a),i=n.typedArrayFromHeap(r),o=T.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],\"int32\",void 0,new Int32Array(o))}var tpe={kernelName:Mc,backendName:\"wasm\",kernelFunc:epe};function Rs(e){let{inputs:{x:t},attrs:{dtype:n},backend:a}=e,r=a.makeOutput(t.shape,n),s=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(r).set(s),r}var npe={kernelName:Mi,backendName:\"wasm\",kernelFunc:Rs},ape=Xe(Oi),vF;function rpe(e){vF=e.wasm.cwrap(ws,null,[\"number\",\"number\",\"number\",\"number\"])}function spe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=a,o=n.dataIdMap.get(r.dataId).id,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(l.dataId).id;return vF(o,s,i,u),l}var ipe={kernelName:ws,backendName:\"wasm\",setupFunc:rpe,kernelFunc:spe};function wF(e){let{inputs:t,backend:n}=e,a=w.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(h=>h.shape);T.assertParamsConsistent(r,a);let s=T.computeOutShape(t.map(h=>h.shape),a),i=t.filter(h=>w.sizeFromShape(h.shape)>0);if(i.length===1)return Gf({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(w.sizeFromShape(s)===0)return o;if(i[0].dtype===\"string\"){let h=i.map(x=>{let v=[-1,w.sizeFromShape(x.shape.slice(a))];return zn({inputs:{x},backend:n,attrs:{shape:v}})}),m=h.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));s=T.computeOutShape(h.map(x=>x.shape),1);let f=h[0].shape[0]===1,g=L1(m,s,t[0].dtype,f),b=T.computeOutShape(i.map(x=>x.shape),a);o.shape=b;let y=n.dataIdMap.get(o.dataId);return y.stringBytes=T.fromStringArrayToUint8(g),h.forEach(x=>n.disposeData(x.dataId)),o}let l=w.sizeFromShape(i[0].shape.slice(0,a)),u=0,p=i.map(h=>{let m=w.sizeFromShape(h.shape.slice(a));return u+=m,m}),d=i.map(h=>n.typedArrayFromHeap(h)),c=n.typedArrayFromHeap(o);for(let h=0;h<l;h++){let m=h*u;for(let f=0;f<d.length;f++){let g=p[f],b=h*g,y=d[f].subarray(b,b+g);c.set(y,m),m+=g}}return o}var ope={kernelName:su,backendName:\"wasm\",kernelFunc:wF},kF;function lpe(e){kF=e.wasm.cwrap(Pi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function upe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d,dataFormat:c}=n,h=T.convertConv2DDataFormat(c),m=T.computeConv2DInfo(r.shape,s.shape,l,u,p,d,!1,h),f=m.filterHeight,g=m.filterWidth,b=m.padInfo.top,y=m.padInfo.right,x=m.padInfo.bottom,v=m.padInfo.left,I=m.dilationHeight,N=m.dilationWidth,C=m.strideHeight,_=m.strideWidth,F=m.inChannels,D=m.outChannels,$=m.padInfo.type===\"SAME\"?1:0;if(m.dataFormat!==\"channelsLast\")throw new Error(`wasm backend Conv2D does not support dataFormat:'${m.dataFormat}'. Please use 'channelsLast'.`);let S=a.makeOutput(m.outShape,\"float32\"),M=a.dataIdMap.get(S.dataId).id;return kF(i,r.shape[0],r.shape[1],r.shape[2],o,f,g,b,y,x,v,$,I,N,C,_,F,D,M),S}var ppe={kernelName:Pi,backendName:\"wasm\",setupFunc:lpe,kernelFunc:upe},IF;function cpe(e){IF=e.wasm.cwrap(Li,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function dpe(e){let{backend:t,inputs:n,attrs:a}=e,{dy:r,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:p}=a,d=1,c=T.convertConv2DDataFormat(l),h=T.computeConv2DInfo(p,s.shape,i,d,o,u,!1,c),{batchSize:m,filterHeight:f,filterWidth:g,inChannels:b,inHeight:y,inWidth:x,outChannels:v,outHeight:I,outWidth:N,strideHeight:C,strideWidth:_}=h,F=f-1-h.padInfo.top,D=g-1-h.padInfo.left,$=h.dataFormat===\"channelsLast\",S=w.computeStrides(h.inShape),M=w.computeStrides(r.shape),[B,U,H]=w.computeStrides(s.shape),q=S[0],K=$?S[1]:S[2],Z=$?S[2]:1,J=$?1:S[1],ee=M[0],ae=$?M[1]:M[2],te=$?M[2]:1,se=$?1:M[1],ie=t.makeOutput(h.inShape,\"float32\"),ve=t.dataIdMap.get(ie.dataId).id,ue=t.dataIdMap.get(r.dataId).id,ye=t.dataIdMap.get(s.dataId).id;return IF(ue,ye,m,f,g,y,x,b,I,N,v,C,_,F,D,B,U,H,q,K,Z,J,ee,ae,te,se,ve),ie}var hpe={kernelName:Li,backendName:\"wasm\",setupFunc:cpe,kernelFunc:dpe},SF;function mpe(e){SF=e.wasm.cwrap(zi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function fpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if(s.dtype!==\"float32\")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(r.shape,s.shape,i,l,o),p=n.makeOutput(u.outShape,r.dtype);return SF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var gpe={kernelName:zi,backendName:\"wasm\",setupFunc:mpe,kernelFunc:fpe},NF;function bpe(e){NF=e.wasm.cwrap(iu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function ype(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:l}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!==\"float32\")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(r.shape,l,i,1,o),p=n.makeOutput(u.filterShape,s.dtype);return NF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var xpe={kernelName:iu,backendName:\"wasm\",setupFunc:bpe,kernelFunc:ype},TF;function vpe(e){TF=e.wasm.cwrap(ou,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function wpe(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:l}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!==\"float32\")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=T.computeConv3DInfo(l,s.shape,o,1,i),p=n.makeOutput(u.inShape,r.dtype);return TF(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(p.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),p}var kpe={kernelName:ou,backendName:\"wasm\",setupFunc:vpe,kernelFunc:wpe},Ipe=Xe(Wi),Spe=Xe(Bi),bv;(function(e){e[e.bilinear=0]=\"bilinear\",e[e.nearest=1]=\"nearest\"})(bv||(bv={}));var CF;function Npe(e){CF=e.wasm.cwrap(uu,null,[\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Tpe(e){let{backend:t,inputs:n,attrs:a}=e,{method:r,extrapolationValue:s,cropSize:i}=a,{image:o,boxes:l,boxInd:u}=n,p=l.shape[0],[d,c]=i,h=[p,d,c,o.shape[3]],m=t.dataIdMap.get(o.dataId),f;o.dtype!==\"float32\"&&(f=Rs({backend:t,inputs:{x:o},attrs:{dtype:\"float32\"}}),m=t.dataIdMap.get(f.dataId));let g=m.id,b=t.dataIdMap.get(l.dataId).id,y=t.dataIdMap.get(u.dataId).id,x=t.makeOutput(h,\"float32\"),v=t.dataIdMap.get(x.dataId).id,I=new Uint8Array(new Int32Array(o.shape).buffer);return CF(g,b,y,p,I,d,c,bv[r],s,v),f!=null&&t.disposeData(f.dataId),x}var Cpe={kernelName:uu,backendName:\"wasm\",setupFunc:Npe,kernelFunc:Tpe},EF;function Epe(e){EF=e.wasm.cwrap(lu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function _pe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;w.assert(r.dtype===\"float32\"||r.dtype===\"int32\",()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`);let u=T.getAxesPermutation([s],l),p=r;u!==null&&(p=ys({inputs:{x:r},attrs:{perm:u},backend:n}));let d=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims(\"cumprod\",[d],l);let c=n.makeOutput(p.shape,p.dtype),h=p.shape[d],m=n.dataIdMap.get(p.dataId).id,f=n.dataIdMap.get(c.dataId).id;EF(m,i?1:0,o?1:0,h,f,Qe[r.dtype]);let g=c;if(u!==null){let b=T.getUndoAxesPermutation(u);g=ys({inputs:{x:c},attrs:{perm:b},backend:n}),n.disposeData(p.dataId),n.disposeData(c.dataId)}return g}var Ape={kernelName:lu,backendName:\"wasm\",setupFunc:Epe,kernelFunc:_pe},_F;function Fpe(e){_F=e.wasm.cwrap(Vi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function $pe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=a,l=r.shape.length;w.assert(r.dtype===\"float32\"||r.dtype===\"int32\",()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`);let u=T.getAxesPermutation([s],l),p=r;u!==null&&(p=ys({inputs:{x:r},attrs:{perm:u},backend:n}));let d=T.getInnerMostAxes(1,l)[0];T.assertAxesAreInnerMostDims(\"cumsum\",[d],l);let c=n.makeOutput(p.shape,p.dtype),h=p.shape[d],m=n.dataIdMap.get(p.dataId).id,f=n.dataIdMap.get(c.dataId).id;_F(m,i?1:0,o?1:0,h,f,Qe[r.dtype]);let g=c;if(u!==null){let b=T.getUndoAxesPermutation(u);g=ys({inputs:{x:c},attrs:{perm:b},backend:n}),n.disposeData(p.dataId),n.disposeData(c.dataId)}return g}var Dpe={kernelName:Vi,backendName:\"wasm\",setupFunc:Fpe,kernelFunc:$pe},AF;function Rpe(e){AF=e.wasm.cwrap(\"DenseBincount\",null,[\"number\",\"array\",\"number\",\"number\",\"boolean\",\"number\",\"number\",\"boolean\",\"number\"])}function Mpe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,weights:s}=n,{size:i,binaryOutput:o}=a,l=s.shape.reduce((c,h)=>c*h,1)!==0,u=r.shape.length===1?[i]:[r.shape[0],i],p=t.makeOutput(u,s.dtype);function d(c){return t.dataIdMap.get(c.dataId).id}return AF(d(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,l,d(s),Qe[s.dtype],o,d(p)),p}var Ope={kernelName:Pc,backendName:\"wasm\",setupFunc:Rpe,kernelFunc:Mpe},FF;function Ppe(e){FF=e.wasm.cwrap(pu,null,[\"number\",\"number\",\"number\",\"array\",\"number\",\"array\",\"array\",\"number\",\"number\"])}function Lpe(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{blockSize:s,dataFormat:i}=a,o=r.shape[0],l=i===\"NHWC\"?r.shape[1]:r.shape[2],u=i===\"NHWC\"?r.shape[2]:r.shape[3],p=i===\"NHWC\"?r.shape[3]:r.shape[1],d=l*s,c=u*s,h=p/(s*s),m=i===\"NHWC\"?[o,d,c,h]:[o,h,d,c],f=t.makeOutput(m,\"float32\"),g=t.dataIdMap.get(r.dataId).id,b=new Uint8Array(new Int32Array(w.computeStrides(r.shape)).buffer),y=new Uint8Array(new Int32Array(m).buffer),x=new Uint8Array(new Int32Array(w.computeStrides(m)).buffer),v=t.dataIdMap.get(f.dataId).id;return FF(g,s,i===\"NHWC\"?1:0,b,r.shape.length-1,y,x,m.length,v),f}var zpe={kernelName:pu,backendName:\"wasm\",setupFunc:Ppe,kernelFunc:Lpe},$F;function Wpe(e){$F=e.wasm.cwrap(Ui,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Bpe(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s}=t,i=a.dataIdMap.get(r.dataId).id,o=a.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d}=n,c=u==null?[1,1]:u,h=T.computeConv2DInfo(r.shape,s.shape,l,c,p,d,!0),m=h.filterHeight,f=h.filterWidth,g=h.padInfo.top,b=h.padInfo.right,y=h.padInfo.bottom,x=h.padInfo.left,v=h.dilationHeight,I=h.dilationWidth,N=h.strideHeight,C=h.strideWidth,_=h.inChannels,F=h.outChannels,D=h.padInfo.type===\"SAME\"?1:0;if(h.dataFormat!==\"channelsLast\")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let $=a.makeOutput(h.outShape,\"float32\"),S=a.dataIdMap.get($.dataId).id;return $F(i,r.shape[0],r.shape[1],r.shape[2],o,m,f,g,b,y,x,D,v,I,N,C,_,F,S),$}var Vpe={kernelName:Ui,backendName:\"wasm\",setupFunc:Wpe,kernelFunc:Bpe},DF;function Upe(e){DF=e.wasm.cwrap(\"Diag\",null,[\"number\",\"number\",\"number\",\"number\"])}function Gpe(e){let{inputs:t,backend:n}=e,{x:a}=t,r=w.sizeFromShape(a.shape),s=n.makeOutput([...a.shape,...a.shape],a.dtype);return DF(n.dataIdMap.get(a.dataId).id,Qe[a.dtype],r,n.dataIdMap.get(s.dataId).id),s}var Hpe={kernelName:Lc,backendName:\"wasm\",setupFunc:Upe,kernelFunc:Gpe},RF;function jpe(e){RF=e.wasm.cwrap(Gi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function qpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:l}=a;if(r.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);let u=T.computeDilation2DInfo(r.shape,s.shape,i,o,\"NHWC\",l),p=n.makeOutput(u.outShape,r.dtype);return RF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(p.dataId).id,Qe[r.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),p}var Kpe={kernelName:Gi,backendName:\"wasm\",setupFunc:jpe,kernelFunc:qpe},MF;function Xpe(e){MF=e.wasm.cwrap(Rl,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Ype(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let p=T.computeDilation2DInfo(r.shape,s.shape,o,l,\"NHWC\",u),d=n.makeOutput(s.shape,s.dtype);return MF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Qe[r.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),d}var Zpe={kernelName:Rl,backendName:\"wasm\",setupFunc:Xpe,kernelFunc:Ype},OF;function Jpe(e){OF=e.wasm.cwrap(Dl,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Qpe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=a;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let p=T.computeDilation2DInfo(r.shape,s.shape,o,l,\"NHWC\",u),d=n.makeOutput(r.shape,r.dtype);return OF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Qe[r.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),d}var ece={kernelName:Dl,backendName:\"wasm\",setupFunc:Jpe,kernelFunc:Qpe},tce=Xe(ji),PF;function nce(e){PF=e.wasm.cwrap(cu,null,[\"number\",\"number\",\"number\"])}function ace(e){let{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=n.makeOutput(r.shape,\"float32\"),i=o=>n.dataIdMap.get(o.dataId).id;return PF(i(r),i(a),i(s)),s}var rce={kernelName:cu,backendName:\"wasm\",setupFunc:nce,kernelFunc:ace},sce=!1,ice=Ut(du,sce,\"bool\"),oce=Xe(qi),lce=Xe(Ki,\"float32\");function yv(e){let{inputs:t,attrs:n,backend:a}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,o=r.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),zn({inputs:{x:r},backend:a,attrs:{shape:o}})}var uce={kernelName:hu,backendName:\"wasm\",kernelFunc:yv},pce=Xe(Xi,\"float32\");function LF(e){let{attrs:{shape:t,value:n},backend:a}=e,{attrs:{dtype:r}}=e;r=r||w.inferDtype(n);let s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var cce={kernelName:zc,backendName:\"wasm\",kernelFunc:LF},zF;function dce(e){zF=e.wasm.cwrap(mu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function hce(e){let{inputs:t,backend:n}=e,{image:a}=t,r=n.makeOutput(a.shape,a.dtype),s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,[o,l,u,p]=a.shape;return zF(s,o,l,u,p,i),r}var mce={kernelName:mu,backendName:\"wasm\",kernelFunc:hce,setupFunc:dce},fce=Xe(Yi),gce=!1,bce=Ut(Zi,gce),WF;function yce(e){WF=e.wasm.cwrap(Ji,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function xce(e){let{backend:t,inputs:n,attrs:a}=e,{varianceEpsilon:r}=a,{x:s,mean:i,variance:o,offset:l,scale:u}=n,p=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(o.dataId).id,h=l!=null?t.dataIdMap.get(l.dataId).id:0,m=u!=null?t.dataIdMap.get(u.dataId).id:0,f=t.makeOutput(s.shape,s.dtype);if(w.sizeFromShape(s.shape)===0)return f;let g=t.dataIdMap.get(f.dataId).id;return WF(p,d,c,h,m,r,g),f}var vce={kernelName:Ji,backendName:\"wasm\",setupFunc:yce,kernelFunc:xce},BF;function wce(e){BF=e.wasm.cwrap(oi,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function kce(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=n,f=T.computeConv2DInfo(r.shape,s.shape,l,p,u,c),g=Ac[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,x=f.outChannels,v=0;if(i!=null){let te=a.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=f.filterHeight,N=f.filterWidth,C=f.padInfo.top,_=f.padInfo.right,F=f.padInfo.bottom,D=f.padInfo.left,$=f.dilationHeight,S=f.dilationWidth,M=f.strideHeight,B=f.strideWidth,U=f.inChannels,H=f.padInfo.type===\"SAME\"?1:0,q=f.batchSize,K=f.inHeight,Z=f.inWidth;if(d!==\"NHWC\")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let J=a.makeOutput(f.outShape,\"float32\"),ee=a.dataIdMap.get(J.dataId).id,ae=o==null?0:a.dataIdMap.get(o.dataId).id;return BF(b,q,K,Z,y,I,N,v,C,_,F,D,H,$,S,M,B,U,x,g,ae,m||0,ee),J}var Ice={kernelName:oi,backendName:\"wasm\",setupFunc:wce,kernelFunc:kce},VF;function Sce(e){VF=e.wasm.cwrap(li,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Nce(e){let{inputs:t,attrs:n,backend:a}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:c,activation:h,leakyreluAlpha:m}=n,f=T.computeConv2DInfo(r.shape,s.shape,l,p,u,c,!0),g=Ac[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=a.dataIdMap.get(r.dataId).id,y=a.dataIdMap.get(s.dataId).id,x=f.outChannels,v=0;if(i!=null){let te=a.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=f.filterHeight,N=f.filterWidth,C=f.padInfo.top,_=f.padInfo.right,F=f.padInfo.bottom,D=f.padInfo.left,$=f.dilationHeight,S=f.dilationWidth,M=f.strideHeight,B=f.strideWidth,U=f.inChannels,H=f.padInfo.type===\"SAME\"?1:0,q=f.batchSize,K=f.inHeight,Z=f.inWidth;if(d!==\"NHWC\")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let J=a.makeOutput(f.outShape,\"float32\"),ee=a.dataIdMap.get(J.dataId).id,ae=o==null?0:a.dataIdMap.get(o.dataId).id;return VF(b,q,K,Z,y,I,N,v,C,_,F,D,H,$,S,M,B,U,x,g,ae,m||0,ee),J}var Tce={kernelName:li,backendName:\"wasm\",setupFunc:Sce,kernelFunc:Nce},UF;function Cce(e){UF=e.wasm.cwrap(gu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\"])}function Ece(e){let{backend:t,inputs:n}=e,{params:a,indices:r}=n,[s,i,o,l]=Yw.prepareAndValidate(a,r),u=t.makeOutput(s,a.dtype);if(i===0)return u;let p=r.shape,d=p[p.length-1],c=t.dataIdMap.get(a.dataId).id,h=t.dataIdMap.get(r.dataId).id,m=new Uint8Array(new Int32Array(l).buffer),f=t.dataIdMap.get(u.dataId).id;return UF(c,Qe[a.dtype],h,i,d,o,m,f),u}var _ce={kernelName:gu,backendName:\"wasm\",setupFunc:Cce,kernelFunc:Ece},GF;function Ace(e){GF=e.wasm.cwrap(\"Gather\",null,[\"number\",\"number\",\"array\",\"number\",\"number\",\"number\",\"array\",\"number\"])}function Fce(e){let{backend:t,inputs:n,attrs:a}=e,{x:r,indices:s}=n,{axis:i,batchDims:o}=a,l=w.parseAxisParam(i,r.shape)[0],u=t.readSync(s.dataId),p=r.shape[l];for(let C=0;C<u.length;++C){let _=u[C];w.assert(_<=p-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${p-1}]`)}let d=T.segment_util.collectGatherOpShapeInfo(r,s,l,o),c=zn({inputs:{x:r},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),h=w.sizeFromShape(s.shape),m=zn({inputs:{x:s},attrs:{shape:[d.batchSize,h/d.batchSize]},backend:t}),f=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize],g=t.makeOutput(f,r.dtype);if(w.sizeFromShape(r.shape)===0)return g;let b=c.shape.length-1,y=t.dataIdMap.get(c.dataId).id,x=t.dataIdMap.get(m.dataId).id,v=t.dataIdMap.get(g.dataId).id,I=new Uint8Array(new Int32Array(w.computeStrides(c.shape)).buffer),N=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer);return GF(y,Qe[r.dtype],I,b,x,d.batchSize,N,v),t.disposeData(c.dataId),t.disposeData(m.dataId),g.shape=d.outputShape,g}var $ce={kernelName:fu,backendName:\"wasm\",setupFunc:Ace,kernelFunc:Fce},Dce=!1,Rce=Ut(bu,Dce,\"bool\"),Mce=!1,Oce=Ut(Qi,Mce,\"bool\"),Pce=Xe(to,\"bool\"),Lce=Xe(no,\"bool\"),zce=Xe(ao,\"bool\"),HF;function Wce(e){HF=e.wasm.cwrap(ro,null,[\"number\",\"number\",\"number\",\"number\"])}function Bce(e){let{inputs:{x:t},attrs:{alpha:n},backend:a}=e,r=a.dataIdMap.get(t.dataId).id,s=a.makeOutput(t.shape,\"float32\");if(w.sizeFromShape(t.shape)!==0){let i=a.dataIdMap.get(s.dataId).id;HF(r,Qe[t.dtype],n,i)}return s}var Vce={kernelName:ro,backendName:\"wasm\",setupFunc:Wce,kernelFunc:Bce},Uce=!1,Gce=Ut(yu,Uce,\"bool\"),Hce=!1,jce=Ut(xu,Hce,\"bool\"),jF;function qce(e){jF=e.wasm.cwrap(vu,null,[\"number\",\"number\",\"number\",\"number\"])}function Kce(e){let{attrs:t,backend:n}=e,{start:a,stop:r,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],\"float32\");return jF(n.dataIdMap.get(o.dataId).id,a,r,i),o}var Xce={kernelName:vu,backendName:\"wasm\",setupFunc:qce,kernelFunc:Kce},Yce=Xe(so),Zce=Xe(io),Jce=!1,Qce=Ut(wu,Jce,\"bool\"),ede=Xe(ku),tde=!1,nde=Ut(Iu,tde,\"bool\"),ade=!1,rde=Ut(jS,ade,\"bool\"),qF;function sde(e){qF=e.wasm.cwrap(oo,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function ide(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=a;if(r.dtype!==\"float32\")throw new Error(\"LRN error: x must have dtype float32\");let u=n.makeOutput(r.shape,r.dtype);return qF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(u.dataId).id,r.shape[3],s,i,o,l),u}var ode={kernelName:oo,backendName:\"wasm\",setupFunc:sde,kernelFunc:ide},KF;function lde(e){KF=e.wasm.cwrap(Su,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function ude(e){let{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=a;if(r.dtype!==\"float32\"||s.dtype!==\"float32\"||i.dtype!==\"float32\")throw new Error(\"LRNGrad error: x, y, and dy must have dtype float32\");let d=n.makeOutput(r.shape,r.dtype);return KF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,p),d}var pde={kernelName:Su,backendName:\"wasm\",setupFunc:lde,kernelFunc:ude},XF;function cde(e){XF=e.wasm.cwrap(lo,null,[\"number\",\"number\",\"number\",\"number\"])}function dde(e){let{backend:t,inputs:n,attrs:a}=e,{reductionIndices:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=Ds(i,r,t);if(c){let y=t.dataIdMap.get(u.dataId).id;l=u,o=y}let h=l.shape.length;T.assertAxesAreInnerMostDims(\"max\",p,h);let[m,f]=T.computeOutAndReduceShapes(l.shape,p),g=w.sizeFromShape(f),b=t.makeOutput(m,i.dtype);if(w.sizeFromShape(l.shape)!==0){let y=t.dataIdMap.get(b.dataId).id;XF(o,Qe[i.dtype],g,y)}if(c&&t.disposeData(u.dataId),s){let y=T.expandShapeToKeepDim(b.shape,d);b.shape=y}return b}var hde={kernelName:lo,backendName:\"wasm\",setupFunc:cde,kernelFunc:dde},mde=!1,fde=Ut(uo,mde),YF;function gde(e){YF=e.wasm.cwrap(po,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function bde(e){let{inputs:t,attrs:n,backend:a}=e,r=t.x,s=a.dataIdMap.get(r.dataId).id;w.assert(r.dtype===\"float32\",()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=T.computePool2DInfo(r.shape,i,o,1,l,u),d=p.filterHeight,c=p.filterWidth,h=p.padInfo.top,m=p.padInfo.right,f=p.padInfo.bottom,g=p.padInfo.left,b=p.dilationHeight,y=p.dilationWidth,x=p.strideHeight,v=p.strideWidth,I=p.inChannels,N=p.outChannels;if(p.dataFormat!==\"channelsLast\")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let C=a.makeOutput(p.outShape,\"float32\"),_=a.dataIdMap.get(C.dataId).id;return YF(s,r.shape[0],r.shape[1],r.shape[2],d,c,h,m,f,g,b,y,x,v,I,N,_),C}var yde={kernelName:po,backendName:\"wasm\",setupFunc:gde,kernelFunc:bde},ZF;function xde(e){ZF=e.wasm.cwrap(\"MaxPool3D\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function vde(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=a,p=T.computePool3DInfo(r.shape,s,i,1,o,l,u),d=n.makeOutput(p.outShape,r.dtype);return ZF(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}var wde={kernelName:Nu,backendName:\"wasm\",setupFunc:xde,kernelFunc:vde},JF;function kde(e){JF=e.wasm.cwrap(\"MaxPool3DGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Ide(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,p=T.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return JF(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inDepth,p.inHeight,p.inWidth,p.outDepth,p.outHeight,p.outWidth,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),d}var Sde={kernelName:Bc,backendName:\"wasm\",setupFunc:kde,kernelFunc:Ide},QF;function Nde(e){QF=e.wasm.cwrap(\"MaxPoolGrad\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Tde(e){let{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=a,p=T.computePool2DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return QF(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),d}var Cde={kernelName:Wc,backendName:\"wasm\",setupFunc:Nde,kernelFunc:Tde},e$;function Ede(e){e$=e.wasm.cwrap(\"MaxPoolWithArgmax\",null,[\"number\",\"number\",\"number\",\"number\",\"boolean\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function _de(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=a;w.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];w.assert(T.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=T.computePool2DInfo(r.shape,s,i,[1,1],o),d=n.makeOutput(p.outShape,r.dtype),c=n.makeOutput(p.outShape,\"int32\");return e$(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(c.dataId).id,Qe[r.dtype],l,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left),[d,c]}var Ade={kernelName:Vc,backendName:\"wasm\",setupFunc:Ede,kernelFunc:_de},t$;function Fde(e){t$=e.wasm.cwrap(co,null,[\"number, number, number\"])}function $de(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t),m=d;if(h){let v=t.dataIdMap.get(p.dataId).id;v!==o&&(u=p,l=v,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims(\"mean\",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),b=w.sizeFromShape(g),y=u;u.dtype!==\"float32\"&&(y=Rs({backend:t,inputs:{x:u},attrs:{dtype:\"float32\"}}),l=t.dataIdMap.get(y.dataId).id);let x=t.makeOutput(f,\"float32\");if(w.sizeFromShape(u.shape)!==0){let v=t.dataIdMap.get(x.dataId).id;t$(l,b,v)}if(h&&t.disposeData(p.dataId),s){let v=T.expandShapeToKeepDim(x.shape,c);x.shape=v}return u.dtype!==\"float32\"&&t.disposeData(y.dataId),x}var Dde={kernelName:co,backendName:\"wasm\",setupFunc:Fde,kernelFunc:$de},n$;function Rde(e){n$=e.wasm.cwrap(ho,null,[\"number\",\"number\",\"number\",\"number\"])}function Mde(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t);if(h){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x)}let m=u.shape.length;T.assertAxesAreInnerMostDims(\"min\",d,m);let[f,g]=T.computeOutAndReduceShapes(u.shape,d),b=w.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;n$(l,Qe[i.dtype],b,x)}if(h&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(y.shape,c);y.shape=x}return y}var Ode={kernelName:ho,backendName:\"wasm\",setupFunc:Rde,kernelFunc:Mde},Pde=!1,Lde=Ut(mo,Pde),xv;(function(e){e[e.reflect=0]=\"reflect\",e[e.symmetric=1]=\"symmetric\"})(xv||(xv={}));var a$;function zde(e){a$=e.wasm.cwrap(fo,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"array\",\"number\",\"number\"])}function Wde(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,mode:r}}=e,s=a.map((m,f)=>m[0]+t.shape[f]+m[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=a.map(m=>m[0]),d=a.map(m=>m[1]),c=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(d).buffer);return a$(i,u,t.shape.length,Qe[t.dtype],c,h,xv[r],l),o}var Bde={kernelName:fo,backendName:\"wasm\",kernelFunc:Wde,setupFunc:zde},r$;function Vde(e){r$=e.wasm.cwrap(zo,null,[\"number\",\"number\",\"number\",\"number\"])}function s$(e){let{backend:t,inputs:{logits:n},attrs:{dim:a}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[a],l=w.sizeFromShape(n.shape)/o;return w.sizeFromShape(s.shape)===0||r$(r,i,o,l),s}var Ude={kernelName:zo,backendName:\"wasm\",setupFunc:Vde,kernelFunc:s$},i$;function Gde(e){i$=e.wasm.cwrap(Tu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Hde(e){let{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=a;if(r.dtype!==\"float32\")throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);let l=o?r:s$({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),[u,p]=l.shape,d=n.makeOutput([u,s],\"int32\");return i$(n.dataIdMap.get(l.dataId).id,u,p,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}var jde={kernelName:Tu,backendName:\"wasm\",setupFunc:Gde,kernelFunc:Hde},qde=Ut(go,!0),Kde=!0,Xde=Ut(bo,Kde),Yde=Xe(Cu);function hk(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),a=n[0],r=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:a,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}var o$;function Zde(e){o$=e.wasm.cwrap(_u,\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\"])}function Jde(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=a,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(l.dataId).id,d=o$(u,p,s,r,i),{pSelectedIndices:c,selectedSize:h,pSelectedScores:m,pValidOutputs:f}=hk(t,d);return t.wasm._free(m),t.wasm._free(f),t.makeOutput([h],\"int32\",c)}var Qde={kernelName:_u,backendName:\"wasm\",setupFunc:Zde,kernelFunc:Jde},l$;function ehe(e){l$=e.wasm.cwrap(Au,\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\",\"bool\"])}function the(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=a,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,c=l$(p,d,s,r,i,o),{pSelectedIndices:h,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=hk(t,c);t.wasm._free(f);let b=t.makeOutput([m],\"int32\",h),y=t.makeOutput([],\"int32\",g);return[b,y]}var nhe={kernelName:Au,backendName:\"wasm\",setupFunc:ehe,kernelFunc:the},u$;function ahe(e){u$=e.wasm.cwrap(Fu,\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function rhe(e){let{backend:t,inputs:n,attrs:a}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=a,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,c=u$(p,d,s,r,i,o),{pSelectedIndices:h,selectedSize:m,pSelectedScores:f,pValidOutputs:g}=hk(t,c);t.wasm._free(g);let b=t.makeOutput([m],\"int32\",h),y=t.makeOutput([m],\"float32\",f);return[b,y]}var she={kernelName:Fu,backendName:\"wasm\",setupFunc:ahe,kernelFunc:rhe},ihe=!1,ohe=Ut(Eu,ihe,\"bool\"),p$;function lhe(e){p$=e.wasm.cwrap(yo,null,[\"number\",\"number\",\"number\",\"number\",\"number\"])}function uhe(e){let{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:l}=a,u=n.makeOutput([...r.shape,i],s),p=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(r.dataId).id;return p$(d,i,o,l,p),u}var phe={kernelName:yo,backendName:\"wasm\",setupFunc:lhe,kernelFunc:uhe};function che(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(1),a}var dhe={kernelName:$u,backendName:\"wasm\",kernelFunc:che};function hhe(e){let{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(t.length===1)return yv({inputs:{input:t[0]},backend:n,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(p=>{w.assertShapesMatch(s,p.shape,\"All tensors passed to stack must have matching shapes\"),w.assert(i===p.dtype,()=>\"All tensors passed to stack must have matching dtypes\")});let o=[],l=t.map(p=>{let d=yv({inputs:{input:p},backend:n,attrs:{dim:r}});return o.push(d),d}),u=wF({inputs:l,backend:n,attrs:{axis:r}});return o.forEach(p=>n.disposeData(p.dataId)),u}var mhe={kernelName:Du,backendName:\"wasm\",kernelFunc:hhe},c$;function fhe(e){c$=e.wasm.cwrap(xo,null,[\"number\",\"array\",\"number\",\"number\",\"array\",\"array\",\"number\",\"number\"])}function ghe(e){let{inputs:{x:t},backend:n,attrs:{paddings:a,constantValue:r}}=e,s=a.map((m,f)=>m[0]+t.shape[f]+m[1]);if(w.sizeFromShape(t.shape)===0)return LF({backend:n,attrs:{shape:s,value:r,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=a.map(m=>m[0]),d=a.map(m=>m[1]),c=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(d).buffer);return c$(i,u,t.shape.length,Qe[t.dtype],c,h,r,l),o}var d$={kernelName:xo,backendName:\"wasm\",kernelFunc:ghe,setupFunc:fhe},bhe=!1,yhe=Ut(vo,bhe),h$;function xhe(e){h$=e.wasm.cwrap(wo,null,[\"number\",\"number\",\"number\"])}function vhe(e){let{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=n.dataIdMap.get(a.dataId).id,i=n.dataIdMap.get(r.dataId).id,o=s,l=a,u=l;l.dtype!==\"float32\"&&(u=Rs({backend:n,inputs:{x:a},attrs:{dtype:\"float32\"}}),o=n.dataIdMap.get(u.dataId).id);let p=n.makeOutput(a.shape,\"float32\"),d=n.dataIdMap.get(p.dataId).id;return h$(o,i,d),l.dtype!==\"float32\"&&n.disposeData(u.dataId),p}var whe={kernelName:wo,backendName:\"wasm\",setupFunc:xhe,kernelFunc:vhe},m$;function khe(e){m$=e.wasm.cwrap(ko,null,[\"number\",\"number\",\"number\",\"number\"])}function Ihe(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t),m=d;if(h){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims(\"prod\",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),b=w.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;m$(l,b,Qe[y.dtype],x)}if(h&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(y.shape,c);y.shape=x}return y}var She={kernelName:ko,backendName:\"wasm\",setupFunc:khe,kernelFunc:Ihe},Nhe=e=>{let{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:i}=n,o=B1(a,r,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},The={kernelName:Uc,backendName:\"wasm\",kernelFunc:Nhe},Che=!0,Ehe=Ut(Hi,Che),_he=Xe(Io),Ahe=Xe(So),Fhe=Xe(Co),f$;function $he(e){f$=e.wasm.cwrap(To,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function Dhe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,[p,d,c,h]=r.shape,m=[p,l,u,h],f=t.dataIdMap.get(r.dataId),g;f.dtype!==\"float32\"&&(g=Rs({backend:t,inputs:{x:r},attrs:{dtype:\"float32\"}}),f=t.dataIdMap.get(g.dataId));let b=f.id,y=t.makeOutput(m,\"float32\");if(w.sizeFromShape(r.shape)===0)return y;let x=t.dataIdMap.get(y.dataId).id;return f$(b,p,d,c,h,l,u,s?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),y}var Rhe={kernelName:To,backendName:\"wasm\",setupFunc:$he,kernelFunc:Dhe},g$;function Mhe(e){g$=e.wasm.cwrap(Ou,null,[\"number\",\"number\",\"number\",\"array\",\"array\",\"boolean\"])}function Ohe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,\"float32\"),l=n.dataIdMap.get(r.dataId),u;return l.dtype!==\"float32\"&&(u=Rs({backend:n,inputs:{x:r},attrs:{dtype:\"float32\"}}),l=n.dataIdMap.get(u.dataId)),g$(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var Phe={kernelName:Ou,backendName:\"wasm\",setupFunc:Mhe,kernelFunc:Ohe},b$;function Lhe(e){b$=e.wasm.cwrap(No,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function zhe(e){let{backend:t,inputs:n,attrs:a}=e,{images:r}=n,{alignCorners:s,halfPixelCenters:i,size:o}=a,[l,u]=o,[p,d,c,h]=r.shape,m=[p,l,u,h],f=t.makeOutput(m,\"float32\");if(w.sizeFromShape(r.shape)===0)return f;let g=t.dataIdMap.get(r.dataId),b;g.dtype!==\"float32\"&&(b=Rs({backend:t,inputs:{x:r},attrs:{dtype:\"float32\"}}),g=t.dataIdMap.get(b.dataId));let y=g.id,x=t.dataIdMap.get(f.dataId).id;return b$(y,p,d,c,h,l,u,s?1:0,i?1:0,x),b!=null&&t.disposeData(b.dataId),f}var Whe={kernelName:No,backendName:\"wasm\",setupFunc:Lhe,kernelFunc:zhe},y$;function Bhe(e){y$=e.wasm.cwrap(Mu,null,[\"number\",\"number\",\"number\",\"array\",\"array\",\"boolean\"])}function Vhe(e){let{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:i}=a,o=n.makeOutput(r.shape,\"float32\"),l=n.dataIdMap.get(r.dataId),u;return l.dtype!==\"float32\"&&(u=Rs({backend:n,inputs:{x:r},attrs:{dtype:\"float32\"}}),l=n.dataIdMap.get(u.dataId)),y$(n.dataIdMap.get(r.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var Uhe={kernelName:Mu,backendName:\"wasm\",setupFunc:Bhe,kernelFunc:Vhe},x$;function Ghe(e){x$=e.wasm.cwrap(Eo,null,[\"number\",\"array\",\"number\",\"array\",\"number\",\"number\"])}function Hhe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,i=w.parseAxisParam(s,r.shape);if(r.shape.length===0)return Gf({inputs:{x:r},backend:n});let o=n.makeOutput(r.shape,r.dtype),l=n.dataIdMap.get(r.dataId).id,u=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(r.shape).buffer);x$(l,p,i.length,d,r.shape.length,u);let c=zn({inputs:{x:o},attrs:{shape:r.shape},backend:n});return n.disposeData(o.dataId),c}var jhe={kernelName:Eo,backendName:\"wasm\",kernelFunc:Hhe,setupFunc:Ghe},v$;function qhe(e){v$=e.wasm.cwrap(Zu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\"])}function Khe(e){let{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=a,l=n.makeOutput(r.shape,r.dtype),u=n.dataIdMap.get(r.dataId).id,p=n.dataIdMap.get(l.dataId).id,[d,c,h,m]=r.shape,[f,g]=T.getImageCenter(o,c,h),b=i===0,y=255,x=typeof i==\"number\"?[i,i,i,b?0:y]:[...i,y],v=new Uint8Array(new Int32Array(x).buffer);return v$(u,d,c,h,m,s,f,g,v,x.length,p),l}var Xhe={kernelName:Zu,backendName:\"wasm\",kernelFunc:Khe,setupFunc:qhe},Yhe=Xe(_o),Zhe=Xe(Ao),w$;function Jhe(e){w$=e.wasm.cwrap(Pu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\"])}function Qhe(e){let{backend:t,inputs:n,attrs:a}=e,{indices:r,updates:s}=n,{shape:i}=a,o=t.makeOutput(i,s.dtype);if(w.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=sf.calculateShapes(s,r,i),h=t.dataIdMap.get(r.dataId).id,m=t.dataIdMap.get(s.dataId).id,f=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return w$(h,m,Qe[s.dtype],l,u,p,f,c,g),o}var eme={kernelName:Pu,backendName:\"wasm\",setupFunc:Jhe,kernelFunc:Qhe},k$;function tme(e){k$=e.wasm.cwrap(zu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"bool\",\"number\"])}function nme(e){let{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:i}=a;if(r.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,\"int32\");function l(u){return n.dataIdMap.get(u.dataId).id}return k$(l(r),l(s),r.shape[0],r.shape[1],s.shape[1],Qe[r.dtype],i===\"left\",l(o)),o}var ame={kernelName:zu,backendName:\"wasm\",setupFunc:tme,kernelFunc:nme},I$;function rme(e){I$=e.wasm.cwrap(\"SelectV2\",null,[\"number\",\"number\",\"number\",\"number\",\"number\"])}function sme(e){let{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,i=n.dataIdMap.get(a.dataId).id,o=n.dataIdMap.get(r.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(r.shape,r.dtype),p=n.dataIdMap.get(u.dataId).id,d=a.shape.length,c=r.shape.length,h=d===0||d>1||c===1?1:w.sizeFromShape(r.shape.slice(1));return I$(i,o,l,h,p),u}var ime={kernelName:Wu,backendName:\"wasm\",kernelFunc:sme,setupFunc:rme},ome=Xe(Fo),S$;function lme(e){S$=e.wasm.cwrap(Mo,null,[\"number\",\"number\"])}function ume(e){let{backend:t,inputs:{x:n}}=e,a=t.dataIdMap.get(n.dataId).id,r=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(r.dataId).id;return w.sizeFromShape(r.shape)===0||S$(a,s),r}var pme={kernelName:\"Sigmoid\",backendName:\"wasm\",setupFunc:lme,kernelFunc:ume},cme=Xe(Ro),dme=Xe($o),hme=Xe(Do),mme=Xe(Oo);function fme(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:i}=a,o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<r.shape.length;++g)l.push([0,0]);let u=d$.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),p=T.getReshaped(u.shape,s,o,!1),d=T.getPermuted(p.length,s.length,!1),c=T.getReshapedPermuted(u.shape,s,o,!1),h=zn({inputs:{x:u},backend:n,attrs:{shape:p}}),m=ys({inputs:{x:h},backend:n,attrs:{perm:d}}),f=zn({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(m.dataId),f}var gme={kernelName:Vu,backendName:\"wasm\",kernelFunc:fme},N$;function bme(e){N$=e.wasm.cwrap(\"SparseFillEmptyRows\",\"number\",[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function yme(e){let{backend:t,inputs:n}=e,{indices:a,values:r,denseShape:s,defaultValue:i}=n,o=a.shape[0],l=a.shape[1],u=t.readSync(s.dataId)[0],p=[o+u,l],d=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(i.dataId).id,m=t.makeOutput(p,a.dtype),f=t.dataIdMap.get(m.dataId).id,g=t.makeOutput(p.slice(0,1),r.dtype),b=t.dataIdMap.get(g.dataId).id,y=t.makeOutput([u],\"bool\"),x=t.dataIdMap.get(y.dataId).id,v=t.makeOutput([o],a.dtype),I=t.dataIdMap.get(v.dataId).id,N=t.makeOutput([4],\"int32\"),C=t.dataIdMap.get(N.dataId).id,_=N$(d,c,Qe[r.dtype],o,u,l,h,f,b,x,I,C),F=t.readSync(N.dataId),D;switch(F[0]){case 1:{D=T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(F[1]);break}case 2:{D=T.getSparseFillEmptyRowsNegativeIndexErrorMessage(F[1],F[2]);break}case 3:D=T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(F[1],F[2],F[3]);break;default:D=\"\"}if(t.disposeData(N.dataId),D)throw t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(y.dataId),t.disposeData(v.dataId),new Error(D);let $=m,S=g;return _!==p[0]&&($=Ii({inputs:{x:m},attrs:{begin:0,size:[_,l]},backend:t}),S=Ii({inputs:{x:g},attrs:{begin:0,size:_},backend:t}),t.disposeData(m.dataId),t.disposeData(g.dataId)),[$,S,y,v]}var xme={kernelName:Gc,backendName:\"wasm\",setupFunc:bme,kernelFunc:yme},T$;function vme(e){T$=e.wasm.cwrap(Gu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function wme(e){let{backend:t,inputs:n}=e,{inputIndices:a,inputShape:r,newShape:s}=n;if(a.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape\n        ${a.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(a.dataId).id,o=t.dataIdMap.get(r.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=a.shape[0],p=w.sizeFromShape(s.shape),d=t.makeOutput([u,p],a.dtype),c=t.dataIdMap.get(d.dataId).id,h=t.makeOutput([p],s.dtype),m=t.dataIdMap.get(h.dataId).id,f=t.makeOutput([3],\"int32\"),g=t.dataIdMap.get(f.dataId).id;T$(i,o,l,u,c,m,g);let b=t.readSync(f.dataId),y;switch(b[0]){case 0:{y=T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{y=T.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:y=T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(r.dataId)),v=Array.from(t.readSync(h.dataId));y=T.getSparseReshapeInputOutputMultipleErrorMessage(x,v);break}case 4:{let x=Array.from(t.readSync(r.dataId)),v=Array.from(t.readSync(h.dataId));y=T.getSparseReshapeInputOutputMismatchErrorMessage(x,v);break}default:y=\"\"}if(t.disposeData(f.dataId),y)throw t.disposeData(d.dataId),t.disposeData(h.dataId),new Error(y);return[d,h]}var kme={kernelName:Gu,backendName:\"wasm\",setupFunc:vme,kernelFunc:wme},C$;function E$(e){C$=e.wasm.cwrap(\"SparseSegmentReduction\",null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function _$(e,t){let{backend:n,inputs:a}=e,{data:r,indices:s,segmentIds:i}=a,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=r.shape.slice();p[0]=u;let d=n.dataIdMap.get(r.dataId).id,c=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(i.dataId).id,m=n.makeOutput(p,r.dtype),f=n.dataIdMap.get(m.dataId).id,g=n.makeOutput([4],\"int32\"),b=n.dataIdMap.get(g.dataId).id;C$(d,Qe[r.dtype],r.shape[0],c,h,f,b,t,0);let y=n.readSync(g.dataId),x;switch(y[0]){case 0:{x=T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y[1],y[2]);break;case 3:x=T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(y[1],y[2],y[3]);break;default:x=\"\"}if(n.disposeData(g.dataId),x)throw n.disposeData(m.dataId),new Error(x);return m}function Ime(e){return _$(e,!0)}var Sme={kernelName:Hc,backendName:\"wasm\",setupFunc:E$,kernelFunc:Ime};function Nme(e){return _$(e,!1)}var Tme={kernelName:jc,backendName:\"wasm\",setupFunc:E$,kernelFunc:Nme},A$;function Cme(e){A$=e.wasm.cwrap(Hu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\"])}function Eme(e){let{backend:t,inputs:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=n,{outputShape:o}=a,l=t.makeOutput(o,i.dtype);if(w.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:p,sliceSize:d,strides:c,outputSize:h}=T.calculateShapes(s,r,o),m=t.dataIdMap.get(r.dataId).id,f=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=new Uint8Array(new Int32Array(c).buffer),y=t.dataIdMap.get(l.dataId).id;return A$(m,f,s.shape.length,g,Qe[i.dtype],u,p,d,b,h,y),l}var _me={kernelName:Hu,backendName:\"wasm\",setupFunc:Cme,kernelFunc:Eme};function Ame(e){let{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=w.parseAxisParam(i,r.shape)[0],l=T.prepareSplitSize(r,s,o),u=new Array(r.shape.length).fill(0),p=r.shape.slice();return l.map(d=>{let c=[...p];c[o]=d;let h=Ii({inputs:{x:r},attrs:{begin:u,size:c},backend:a});return u[o]+=d,h})}var Fme={kernelName:Uu,backendName:\"wasm\",kernelFunc:Ame},$me=Xe(Po),Dme=Xe(qc),Rme=!0,Mme=Ut(Wo,Rme),F$;function Ome(e){F$=e.wasm.cwrap(Is,null,[\"number\",\"number\",\"number\",\"number\"])}function Pme(e){let{backend:t,inputs:n,attrs:a}=e,{alpha:r}=a,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return F$(i,r,Qe[s.dtype],l),o}var Lme={kernelName:Is,backendName:\"wasm\",setupFunc:Ome,kernelFunc:Pme},$$;function zme(e){$$=e.wasm.cwrap(ju,null,[\"number\",\"array\",\"number\",\"array\",\"array\",\"array\",\"array\",\"array\",\"number\",\"number\"])}function Wme(e){let{backend:t,inputs:n,attrs:a}=e,{x:r}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=a,{finalShapeSparse:h,finalShape:m,isIdentity:f,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:v}=Kt.sliceInfo(r.shape,s,i,o,l,u,p,d,c),I;if(f)I=zn({inputs:{x:r},backend:t,attrs:{shape:m}});else if(g||b){w.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let N=Kt.computeOutShape(y,x,v),C=Ii({inputs:{x:r},backend:t,attrs:{begin:y,size:N}});I=zn({inputs:{x:C},backend:t,attrs:{shape:m}}),t.disposeData(C.dataId)}else{let N=t.makeOutput(h,\"float32\"),C=t.dataIdMap.get(r.dataId).id,_=new Uint8Array(new Int32Array(w.computeStrides(r.shape)).buffer),F=new Uint8Array(new Int32Array(y).buffer),D=new Uint8Array(new Int32Array(x).buffer),$=new Uint8Array(new Int32Array(v).buffer),S=new Uint8Array(new Int32Array(h).buffer),M=new Uint8Array(new Int32Array(w.computeStrides(h)).buffer),B=t.dataIdMap.get(N.dataId).id;$$(C,_,r.shape.length,F,D,$,S,M,h.length,B),I=zn({inputs:{x:N},backend:t,attrs:{shape:m}}),t.disposeData(N.dataId)}return I}var Bme={kernelName:ju,backendName:\"wasm\",setupFunc:zme,kernelFunc:Wme};function Vme(e){let{backend:t,inputs:n,attrs:a}=e,{data:r,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:p,preserveShortSequences:d}=a,c=t.readSync(r.dataId),h=t.readSync(s.dataId),[m,f]=U1(c,h,i,o,l,u,p,d),g=t.makeOutput([m.length],\"string\"),b=t.dataIdMap.get(g.dataId);b.stringBytes=m;let y=t.makeOutput(s.shape,\"int32\");return t.typedArrayFromHeap(y).set(f),[g,y]}var Ume={kernelName:Xc,backendName:\"wasm\",kernelFunc:Vme};function Gme(e){let{backend:t,inputs:n,attrs:a}=e,{input:r,delimiter:s}=n,{skipEmpty:i}=a,o=t.readSync(r.dataId),l=t.readSync(s.dataId),[u,p,d]=G1(o,l[0],i),c=p.length,h=t.makeOutput([c,2],\"int32\");t.typedArrayFromHeap(h).set(u);let m=t.makeOutput([c],\"string\"),f=t.dataIdMap.get(m.dataId);f.stringBytes=p;let g=t.makeOutput([2],\"int32\");return t.typedArrayFromHeap(g).set(d),[h,m,g]}var Hme={kernelName:Yc,backendName:\"wasm\",kernelFunc:Gme};function jme(e){let{backend:t,inputs:n,attrs:a}=e,{input:r}=n,{numBuckets:s}=a,i=t.readSync(r.dataId),o=H1(i,s),l=t.makeOutput(r.shape,\"int32\");return t.typedArrayFromHeap(l).set(o),l}var qme={kernelName:Zc,backendName:\"wasm\",kernelFunc:jme},Kme=!0,Xme=Ut(Bo,Kme),D$;function Yme(e){D$=e.wasm.cwrap(Lo,null,[\"number\",\"number\",\"number\",\"number\"])}function Zme(e){let{backend:t,inputs:n,attrs:a}=e,{axis:r,keepDims:s}=a,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=Ds(i,r,t),m=d;if(h){let x=t.dataIdMap.get(p.dataId).id;x!==o&&(u=p,l=x,m=T.getInnerMostAxes(m.length,u.shape.length))}T.assertAxesAreInnerMostDims(\"sum\",m,u.shape.length);let[f,g]=T.computeOutAndReduceShapes(u.shape,m),b=w.sizeFromShape(g),y=t.makeOutput(f,u.dtype);if(w.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(y.dataId).id;D$(l,b,Qe[y.dtype],x)}if(h&&t.disposeData(p.dataId),s){let x=T.expandShapeToKeepDim(y.shape,c);y.shape=x}return y}var Jme={kernelName:Lo,backendName:\"wasm\",setupFunc:Yme,kernelFunc:Zme},Qme=Xe(Vo),efe=Xe(Uo),R$;function tfe(e){R$=e.wasm.cwrap(Lu,null,[\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"number\",\"number\"])}function nfe(e){let{backend:t,inputs:n,attrs:a}=e,{tensor:r,indices:s,updates:i}=n,{}=a,o=t.makeOutput(r.shape,r.dtype);if(w.sizeFromShape(r.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=sf.calculateShapes(i,s,r.shape),h=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(r.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),b=t.dataIdMap.get(o.dataId).id;return R$(h,m,Qe[i.dtype],l,u,p,g,c,b,f),o}var afe={kernelName:Lu,backendName:\"wasm\",setupFunc:tfe,kernelFunc:nfe},M$;function rfe(e){M$=e.wasm.cwrap(ks,null,[\"number\",\"array\",\"number\",\"array\",\"number\",\"number\"])}function sfe(e){let{inputs:t,backend:n,attrs:a}=e,{x:r}=t,s=n.dataIdMap.get(r.dataId).id,{reps:i}=a,o=new Array(r.shape.length);for(let c=0;c<o.length;c++)o[c]=r.shape[c]*i[c];let l=new Uint8Array(new Int32Array(r.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),p=n.makeOutput(o,r.dtype),d=n.dataIdMap.get(p.dataId).id;return M$(s,l,r.shape.length,u,o.length,Qe[p.dtype],d),p}var ife={kernelName:ks,backendName:\"wasm\",setupFunc:rfe,kernelFunc:sfe},O$;function ofe(e){O$=e.wasm.cwrap(qu,null,[\"number\",\"array\",\"number\",\"number\",\"number\",\"bool\",\"number\",\"number\"])}var lfe=({inputs:e,backend:t,attrs:n})=>{let{x:a}=e,{k:r,sorted:s}=n,i=t.dataIdMap.get(a.dataId).id,o=new Uint8Array(new Int32Array(a.shape).buffer),l=a.shape.slice();l[l.length-1]=r;let u=t.makeOutput(l,a.dtype),p=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,\"int32\"),c=t.dataIdMap.get(d.dataId).id;return O$(i,o,a.shape.length,Qe[a.dtype],r,s,p,c),[u,d]},ufe={kernelName:qu,backendName:\"wasm\",setupFunc:ofe,kernelFunc:lfe},P$;function pfe(e){P$=e.wasm.cwrap(Ku,null,[\"number\",\"number\",\"bool\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\",\"array\",\"number\",\"array\",\"number\",\"number\",\"number\",\"number\",\"number\"])}function cfe(e){let{backend:t,inputs:n,attrs:a}=e,{image:r,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=a,[p,d,c,h]=r.shape,[m,f]=u!=null?u:[d,c],g=[p,m,f,h],b=new Uint8Array(new Int32Array(w.computeStrides(r.shape)).buffer),y=new Uint8Array(new Int32Array(w.computeStrides(g)).buffer),x=t.makeOutput(g,r.dtype),v=t.dataIdMap.get(x.dataId).id,I=t.dataIdMap.get(r.dataId).id,N=t.dataIdMap.get(s.dataId).id,C=i===\"nearest\"?1:2,_;switch(o){case\"constant\":_=1;break;case\"reflect\":_=2;break;case\"wrap\":_=3;break;case\"nearest\":_=4;break;default:_=1;break}return P$(I,N,s.shape[0]>1,p,m,f,h,c,d,b,r.shape.length-1,y,g.length-1,C,_,l,v),x}var dfe={kernelName:Ku,backendName:\"wasm\",setupFunc:pfe,kernelFunc:cfe};function hfe(e){let{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=q1(a.readSync(s.dataId),r,s.shape,s.dtype);return[a.makeOutput(o,s.dtype,void 0,i),a.makeOutput([l.length],\"int32\",void 0,l)]}var mfe={kernelName:Jc,backendName:\"wasm\",kernelFunc:hfe};function ffe(e){let{inputs:t,backend:n,attrs:a}=e,{value:r}=t,{axis:s}=a;s<0&&(s+=r.shape.length);let i=r.shape[s],o=r.shape.length,l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==s&&(l[u++]=r.shape[h]);let p=new Array(i),d=new Array(o).fill(0),c=r.shape.slice();c[s]=1;for(let h=0;h<p.length;h++)d[s]=h,p[h]=Ii({inputs:{x:r},attrs:{begin:d,size:c},backend:n});return p.map(({dataId:h,dtype:m})=>({dataId:h,dtype:m,shape:l}))}var gfe={kernelName:Xu,backendName:\"wasm\",kernelFunc:ffe};function bfe(e){let{inputs:{x:t},backend:n}=e,a=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(a).fill(0),a}var yfe={kernelName:Yu,backendName:\"wasm\",kernelFunc:bfe},xfe=[eue,tue,nue,aue,sue,lue,gue,xue,vue,wue,kue,Iue,Sue,Nue,Tue,_ue,Lue,$ue,Mue,Vue,Kue,Zue,Que,tpe,npe,ape,ipe,ope,ppe,hpe,gpe,xpe,kpe,Ipe,Spe,Cpe,Ape,Dpe,Ope,zpe,Vpe,Hpe,Kpe,Zpe,ece,tce,rce,ice,oce,lce,uce,pce,cce,mce,fce,bce,vce,Ice,Tce,_ce,$ce,Rce,Oce,uue,Pce,Lce,zce,Vce,Gce,jce,Xce,Zce,Yce,Qce,ede,nde,rde,ode,pde,hde,fde,yde,wde,Sde,Cde,Ade,Dde,Ode,Lde,Bde,jde,qde,Xde,Yde,Qde,nhe,she,ohe,phe,dhe,mhe,d$,yhe,whe,She,The,Ehe,_he,Ahe,Fhe,zue,Rhe,Phe,Whe,Uhe,jhe,Xhe,Yhe,Zhe,eme,ame,ime,ome,pme,cme,dme,hme,jue,Ude,mme,gme,xme,kme,Sme,Tme,_me,Fme,$me,Dme,Mme,Lme,Bme,Ume,Hme,qme,Xme,Jme,Qme,efe,afe,ife,ufe,dfe,hue,mfe,gfe,yfe];for(let e of xfe)ed(e);var vv=G();vv.registerFlag(\"WASM_HAS_SIMD_SUPPORT\",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(e){return!1}});vv.registerFlag(\"WASM_HAS_MULTITHREAD_SUPPORT\",async()=>{if(vv.get(\"IS_NODE\"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}});var TS=xs(VR()),vfe=xs(UR()),CS=xs(GR()),ES=TS.default||TS,wfe=CS.default||CS,L$=class extends Fc{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(z$),wv=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new ym(this,Ta())}write(e,t,n){let a={id:this.dataIdNextNumber++};return this.move(a,e,t,n,1),a}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,a,r){let s=this.dataIdNextNumber++;if(a===\"string\"){let u=t;this.dataIdMap.set(e,{id:s,stringBytes:u,shape:n,dtype:a,memoryOffset:null,refCount:r});return}let i=w.sizeFromShape(n),o=i*w.bytesPerElement(a),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:a,refCount:r}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:a,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(r===\"string\")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||w.sizeFromShape(s);let o=w.bytesPerElement(r),l=this.wasm.HEAPU8.slice(a+t*o,a+n*o);return Sfe(l.buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),\"PThread\"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,a){let r;if(n==null)r=this.write(a!=null?a:null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let a=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(n),s=w.sizeFromShape(e);switch(t){case\"float32\":return new Float32Array(a,r,s);case\"int32\":return new Int32Array(a,r,s);case\"bool\":return new Uint8Array(a,r,s);default:throw new Error(`Unknown dtype ${t}`)}}};function kfe(e){return(t,n)=>(w.fetch(e,{credentials:\"same-origin\"}).then(a=>{a.ok||t.env.a(`failed to load wasm binary file at '${e}'`),a.arrayBuffer().then(r=>{WebAssembly.instantiate(r,t).then(s=>{n(s.instance,s.module)})})}),{})}function _S(e,t,n){if(gm!=null)return gm;let a=\"tfjs-backend-wasm.wasm\";return e&&t?a=\"tfjs-backend-wasm-threaded-simd.wasm\":e&&(a=\"tfjs-backend-wasm-simd.wasm\"),cc!=null&&cc[a]!=null?cc[a]:n+a}async function Ife(){let[e,t]=await Promise.all([G().getAsync(\"WASM_HAS_SIMD_SUPPORT\"),G().getAsync(\"WASM_HAS_MULTITHREAD_SUPPORT\")]);return new Promise((n,a)=>{let r={};r.locateFile=(o,l)=>{if(o.endsWith(\".worker.js\")){let u=vfe.wasmWorkerContents.replace(/\\n/g,\"\\\\n\"),p=new Blob([u],{type:\"application/javascript\"});return URL.createObjectURL(p)}return o.endsWith(\".wasm\")?_S(e,t,lc!=null?lc:l):l+o},mk&&(r.instantiateWasm=kfe(_S(e,t,lc!=null?lc:\"\")));let s=!1;r.onAbort=()=>{s||dc||(dc=!0,a({message:\"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers\"}))};let i;t&&e&&gm==null?(r.mainScriptUrlOrBlob=new Blob([\"var WasmBackendModuleThreadedSimd = \"+ES.toString()],{type:\"text/javascript\"}),i=ES(r)):i=wfe(r),i.then(o=>{s=!0,dc=!1;let l=null;o.tfjs={init:o.cwrap(\"init\",null,[]),initWithThreadsCount:o.cwrap(\"init_with_threads_count\",null,[\"number\"]),getThreadsCount:o.cwrap(\"get_threads_count\",\"number\",[]),registerTensor:o.cwrap(\"register_tensor\",null,[\"number\",\"number\",\"number\"]),disposeData:o.cwrap(\"dispose_data\",l,[\"number\"]),dispose:o.cwrap(\"dispose\",l,[])},n({wasm:o})}).catch(a)})}function Sfe(e,t){switch(t){case\"float32\":return new Float32Array(e);case\"int32\":return new Int32Array(e);case\"bool\":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var Nfe=[\"tfjs-backend-wasm.wasm\",\"tfjs-backend-wasm-simd.wasm\",\"tfjs-backend-wasm-threaded-simd.wasm\"],gm=null,lc=null,cc={},dc=!1,mk=!1;function Tfe(e,t=!1){if($v(\"setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release.\"),dc)throw new Error(\"The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`\");gm=e,mk=t}function Cfe(e,t=!1){if(dc)throw new Error(\"The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`\");if(typeof e==\"string\")lc=e;else{cc=e;let n=Nfe.filter(a=>cc[a]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(\",\")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}mk=t}var z$=-1,wv=-1;function Efe(e){z$=e}function _fe(){if(wv===-1)throw new Error(\"WASM backend not initialized.\");return wv}var Afe=\"4.22.0\",Ffe=2;Om(\"wasm\",async()=>{let{wasm:e}=await Ife();return new L$(e)},Ffe);var AS=\"4.22.0\",$fe=\"4.22.0\",Dfe=\"4.22.0\",Rfe=\"4.22.0\",Mfe=\"4.22.0\",Ofe={tfjs:AS,\"tfjs-core\":AS,\"tfjs-converter\":$fe,\"tfjs-backend-cpu\":Dfe,\"tfjs-backend-webgl\":Rfe,\"tfjs-backend-wasm\":Mfe};var iD={};ax(iD,{AnchorPosition:()=>Ik,DrawBox:()=>Od,DrawBoxOptions:()=>Xf,DrawFaceLandmarks:()=>og,DrawFaceLandmarksOptions:()=>ig,DrawTextField:()=>sl,DrawTextFieldOptions:()=>Ip,drawContour:()=>Pr,drawDetections:()=>Ufe,drawFaceExpressions:()=>Gfe,drawFaceLandmarks:()=>jfe});function Pr(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:a,y:r},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(a,r)}),n){let a=t[t.length-1],r=t[0];if(!a||!r)return;e.moveTo(a.x,a.y),e.lineTo(r.x,r.y)}e.stroke()}var W$={};ax(W$,{computeReshapedDimensions:()=>bk,getCenterPoint:()=>al,isDimensions:()=>jf,isEven:()=>Hf,isFloat:()=>gk,isTensor:()=>tl,isTensor1D:()=>Pfe,isTensor2D:()=>fk,isTensor3D:()=>Lr,isTensor4D:()=>wa,isValidNumber:()=>Xa,isValidProbablitiy:()=>gp,range:()=>gr,round:()=>nl});var aa=class e{constructor(t,n){if(!Xa(t)||!Xa(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new e(1/this.width,1/this.height)}};function tl(e,t){return e instanceof Ce&&e.shape.length===t}function Pfe(e){return tl(e,1)}function fk(e){return tl(e,2)}function Lr(e){return tl(e,3)}function wa(e){return tl(e,4)}function gk(e){return e%1!==0}function Hf(e){return e%2===0}function nl(e,t=2){let n=10**t;return Math.floor(e*n)/n}function jf(e){return e&&e.width&&e.height}function bk({width:e,height:t},n){let a=n/Math.max(t,e);return new aa(Math.round(e*a),Math.round(t*a))}function al(e){return e.reduce((t,n)=>t.add(n),new He(0,0)).div(new He(e.length,e.length))}function gr(e,t,n){return Array(e).fill(0).map((a,r)=>t+r*n)}function Xa(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function gp(e){return Xa(e)&&e>=0&&e<=1}var He=class e{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mul(t){return new e(this.x*t.x,this.y*t.y)}div(t){return new e(this.x/t.x,this.y/t.y)}abs(){return new e(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}};var mn=class e{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Xa)}static assertIsValidBox(t,n,a=!1){if(!e.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!a&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let a=t||{},r=[a.left,a.top,a.right,a.bottom].every(Xa),s=[a.x,a.y,a.width,a.height].every(Xa);if(!s&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(a)}`);let[i,o,l,u]=s?[a.x,a.y,a.width,a.height]:[a.left,a.top,a.right-a.left,a.bottom-a.top];e.assertIsValidBox({x:i,y:o,width:l,height:u},\"Box.constructor\",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new He(this.left,this.top)}get topRight(){return new He(this.right,this.top)}get bottomLeft(){return new He(this.left,this.bottom)}get bottomRight(){return new He(this.right,this.bottom)}round(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new e({x:t,y:n,width:a,height:r})}floor(){let[t,n,a,r]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new e({x:t,y:n,width:a,height:r})}toSquare(){let{x:t,y:n,width:a,height:r}=this,s=Math.abs(a-r);return a<r&&(t-=s/2,a+=s),r<a&&(n-=s/2,r+=s),new e({x:t,y:n,width:a,height:r})}rescale(t){let n=jf(t)?t.width:t,a=jf(t)?t.height:t;return new e({x:this.x*n,y:this.y*a,width:this.width*n,height:this.height*a})}pad(t,n){let[a,r,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new e({x:a,y:r,width:s,height:i})}clipAtImageBorders(t,n){let{x:a,y:r,right:s,bottom:i}=this,o=Math.max(a,0),l=Math.max(r,0),u=s-o,p=i-l,d=Math.min(u,t-o),c=Math.min(p,n-l);return new e({x:o,y:l,width:d,height:c}).floor()}shift(t,n){let{width:a,height:r}=this,s=this.x+t,i=this.y+n;return new e({x:s,y:i,width:a,height:r})}padAtBorders(t,n){let a=this.width+1,r=this.height+1,s=1,i=1,o=a,l=r,u=this.left,p=this.top,d=this.right,c=this.bottom;return d>n&&(o=-d+n+a,d=n),c>t&&(l=-c+t+r,c=t),u<1&&(l=2-u,u=1),p<1&&(l=2-p,p=1),{dy:i,edy:l,dx:s,edx:o,y:p,ey:c,x:u,ex:d,w:a,h:r}}calibrate(t){return new e({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}};var bp=class extends mn{constructor(t,n,a,r,s=!1){super({left:t,top:n,right:a,bottom:r},s)}};var yp=class e{constructor(t,n,a,r,s){this._imageDims=new aa(s.width,s.height),this._score=t,this._classScore=n,this._className=a,this._box=new mn(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new mn(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new e(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}};var Ft=class e extends yp{constructor(t,n,a){super(t,t,\"\",n,a)}forSize(t,n){let{score:a,relativeBox:r,imageDims:s}=super.forSize(t,n);return new e(a,r,s)}};function B$(e,t,n=!0){let a=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=a*r;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function V$(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),a=t.reduce((o,l)=>l<o?l:o,1/0),r=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new bp(a,r,s,i)}function U$(e,t,n,a=!0){let r=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;r.length>0;){let i=r.pop();s.push(i);let o=r,l=[];for(let u=0;u<o.length;u++){let p=o[u],d=e[i],c=e[p];l.push(B$(d,c,a))}r=r.filter((u,p)=>l[p]<=n)}return s}function br(e,t){return O(()=>{let[n,a,r]=t,s=yn([...e.shape.slice(0,3),1],n,\"float32\"),i=yn([...e.shape.slice(0,3),1],a,\"float32\"),o=yn([...e.shape.slice(0,3),1],r,\"float32\"),l=et([s,i,o],3);return pe(e,l)})}function G$(e,t=!1){return O(()=>{let[n,a]=e.shape.slice(1);if(n===a)return e;let r=Math.abs(n-a),s=Math.round(r*(t?.5:1)),i=n>a?2:1,o=c=>{let h=e.shape.slice();return h[i]=c,yn(h,0,\"float32\")},l=o(s),u=r-l.shape[i],d=[t&&u?o(u):null,e,l].filter(c=>!!c).map(c=>re(c,\"float32\"));return et(d,i)})}function y0e(e){let t=e.slice();for(let n=t.length-1;n>0;n--){let a=Math.floor(Math.random()*(n+1)),r=t[n];t[n]=t[a],t[a]=r}return t}function qf(e){return 1/(1+Math.exp(-e))}function v0e(e){return Math.log(e/(1-e))}var xp=class extends mn{constructor(t,n,a,r,s=!1){super({x:t,y:n,width:a,height:r},s)}};var Lfe=.5,zfe=.43,Wfe=.45,ka=class{constructor(t,n,a=new He(0,0)){let{width:r,height:s}=n;this._imgDims=new aa(r,s),this._shift=a,this._positions=t.map(i=>i.mul(new He(r,s)).add(a))}get shift(){return new He(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(t=>t.sub(this._shift).div(new He(this.imageWidth,this.imageHeight)))}forSize(t,n){return new this.constructor(this.relativePositions,{width:t,height:n})}shiftBy(t,n){return new this.constructor(this.relativePositions,this._imgDims,new He(t,n))}shiftByPoint(t){return this.shiftBy(t.x,t.y)}align(t,n={}){if(t){let s=t instanceof Ft?t.box.floor():new mn(t);return this.shiftBy(s.x,s.y).align(null,n)}let{useDlibAlignment:a,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...n};return a?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let t=this.getRefPointsForAlignment(),[n,a,r]=t,s=d=>r.sub(d).magnitude(),i=(s(n)+s(a))/2,o=Math.floor(i/Wfe),l=al(t),u=Math.floor(Math.max(0,l.x-Lfe*o)),p=Math.floor(Math.max(0,l.y-zfe*o));return new xp(u,p,Math.min(o,this.imageWidth+u),Math.min(o,this.imageHeight+p))}alignMinBbox(t){let n=V$(this.positions);return n.pad(n.width*t,n.height*t)}getRefPointsForAlignment(){throw new Error(\"getRefPointsForAlignment not implemented by base class\")}};var H$=class extends ka{getRefPointsForAlignment(){let t=this.positions;return[t[0],t[1],al([t[3],t[4]])]}};var vp=class extends ka{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(al)}};var Dd=class{constructor(t,n){this._label=t,this._distance=n}get label(){return this._label}get distance(){return this._distance}toString(t=!0){return`${this.label}${t?` (${nl(this.distance)})`:\"\"}`}};var Rd=class extends mn{static assertIsValidLabeledBox(t,n){if(mn.assertIsValidBox(t,n),!Xa(t.label))throw new Error(`${n} - expected property label (${t.label}) to be a number`)}constructor(t,n){super(t),this._label=n}get label(){return this._label}};var rl=class e{constructor(t,n){if(typeof t!=\"string\")throw new Error(\"LabeledFaceDescriptors - constructor expected label to be a string\");if(!Array.isArray(n)||n.some(a=>!(a instanceof Float32Array)))throw new Error(\"LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array\");this._label=t,this._descriptors=n}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(t=>Array.from(t))}}static fromJSON(t){let n=t.descriptors.map(a=>new Float32Array(a));return new e(t.label,n)}};var j$=class extends Rd{static assertIsValidPredictedBox(t,n){if(Rd.assertIsValidLabeledBox(t,n),!gp(t.score)||!gp(t.classScore))throw new Error(`${n} - expected properties score (${t.score}) and (${t.classScore}) to be a number between [0, 1]`)}constructor(t,n,a,r){super(t,n),this._score=a,this._classScore=r}get score(){return this._score}get classScore(){return this._classScore}};function zr(e){return e.detection instanceof Ft}function wp(e,t){return{...e,...{detection:t}}}function yk(){let e=window.fetch;if(!e)throw new Error(\"fetch - missing fetch implementation for browser environment\");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement(\"canvas\"),createImageElement:()=>document.createElement(\"img\"),createVideoElement:()=>document.createElement(\"video\"),fetch:e,readFile:()=>{throw new Error(\"readFile - filesystem not available for browser environment\")}}}function Md(){return typeof global==\"object\"&&typeof process!=\"undefined\"&&process.versions!=null&&process.versions.node!=null}function Kf(e){let t=\"\";if(!e&&Md())try{e=wR(\"fs\")}catch(a){t=a.toString()}return{readFile:e?a=>new Promise((r,s)=>{e.readFile(a,(i,o)=>i?s(i):r(o))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function xk(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error(\"createCanvasElement - missing Canvas implementation for nodejs environment\")},r=()=>{if(t)return new t;throw new Error(\"createImageElement - missing Image implementation for nodejs environment\")},s=()=>{if(n)return new n;throw new Error(\"createVideoElement - missing Video implementation for nodejs environment\")},i=global.fetch,o=Kf();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:r,createVideoElement:s,fetch:i,...o}}function vk(){return typeof window==\"object\"&&typeof document!=\"undefined\"&&typeof HTMLImageElement!=\"undefined\"&&typeof HTMLCanvasElement!=\"undefined\"&&typeof HTMLVideoElement!=\"undefined\"&&typeof ImageData!=\"undefined\"&&typeof CanvasRenderingContext2D!=\"undefined\"}var ln;function Bfe(){if(!ln)throw new Error(\"getEnv - environment is not defined, check isNodejs() and isBrowser()\");return ln}function wk(e){ln=e}function kk(){return vk()?wk(yk()):Md()?wk(xk()):null}function Vfe(e){if(ln||kk(),!ln)throw new Error(\"monkeyPatch - environment is not defined, check isNodejs() and isBrowser()\");let{Canvas:t=ln.Canvas,Image:n=ln.Image}=e;ln.Canvas=t,ln.Image=n,ln.createCanvasElement=e.createCanvasElement||(()=>new t),ln.createImageElement=e.createImageElement||(()=>new n),ln.ImageData=e.ImageData||ln.ImageData,ln.Video=e.Video||ln.Video,ln.fetch=e.fetch||ln.fetch,ln.readFile=e.readFile||ln.readFile}var at={getEnv:Bfe,setEnv:wk,initialize:kk,createBrowserEnv:yk,createFileSystem:Kf,createNodejsEnv:xk,monkeyPatch:Vfe,isBrowser:vk,isNodejs:Md};kk();function kp(e){return!at.isNodejs()&&typeof e==\"string\"?document.getElementById(e):e}function ra(e){let{Canvas:t,CanvasRenderingContext2D:n}=at.getEnv();if(e instanceof n)return e;let a=kp(e);if(!(a instanceof t))throw new Error(\"resolveContext2d - expected canvas to be of instance of Canvas\");let r=a.getContext(\"2d\",{willReadFrequently:!0});if(!r)throw new Error(\"resolveContext2d - canvas 2d context is null\");return r}var Ik=(r=>(r.TOP_LEFT=\"TOP_LEFT\",r.TOP_RIGHT=\"TOP_RIGHT\",r.BOTTOM_LEFT=\"BOTTOM_LEFT\",r.BOTTOM_RIGHT=\"BOTTOM_RIGHT\",r))(Ik||{}),Ip=class{constructor(t={}){let{anchorPosition:n,backgroundColor:a,fontColor:r,fontSize:s,fontStyle:i,padding:o}=t;this.anchorPosition=n||\"TOP_LEFT\",this.backgroundColor=a||\"rgba(0, 0, 0, 0.5)\",this.fontColor=r||\"rgba(255, 255, 255, 1)\",this.fontSize=s||14,this.fontStyle=i||\"Georgia\",this.padding=o||4}},sl=class e{constructor(t,n,a={}){this.text=typeof t==\"string\"?[t]:t instanceof e?t.text:t,this.anchor=n,this.options=new Ip(a)}measureWidth(t){let{padding:n}=this.options;return this.text.map(a=>t.measureText(a).width).reduce((a,r)=>a<r?r:a,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:a}=this.options,r=a===\"BOTTOM_RIGHT\"||a===\"TOP_RIGHT\",s=a===\"BOTTOM_LEFT\"||a===\"BOTTOM_RIGHT\",i=this.measureWidth(t),o=this.measureHeight(),l=r?this.anchor.x-i:this.anchor.x,u=s?this.anchor.y-o:this.anchor.y;if(n){let{width:p,height:d}=n,c=Math.max(Math.min(l,p-i),0),h=Math.max(Math.min(u,d-o),0);return{x:c,y:h}}return{x:l,y:u}}draw(t){let n=kp(t),a=ra(n),{backgroundColor:r,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;a.font=`${i}px ${o}`;let u=this.measureWidth(a),p=this.measureHeight();a.fillStyle=r;let d=this.getUpperLeft(a,n);a.fillRect(d.x,d.y,u,p),a.fillStyle=s,this.text.forEach((c,h)=>{let m=l+d.x,f=l+d.y+(h+1)*i;a.fillText(c,m,f)})}};var Xf=class{constructor(t={}){let{boxColor:n,lineWidth:a,label:r,drawLabelOptions:s}=t;this.boxColor=n||\"rgba(0, 0, 255, 1)\",this.lineWidth=a||2,this.label=r;let i={anchorPosition:\"BOTTOM_LEFT\",backgroundColor:this.boxColor};this.drawLabelOptions=new Ip({...i,...s})}},Od=class{constructor(t,n={}){this.box=new mn(t),this.options=new Xf(n)}draw(t){let n=ra(t),{boxColor:a,lineWidth:r}=this.options,{x:s,y:i,width:o,height:l}=this.box;n.strokeStyle=a,n.lineWidth=r,n.strokeRect(s,i,o,l);let{label:u}=this.options;u&&new sl([u],{x:s-r/2,y:i},this.options.drawLabelOptions).draw(t)}};function Ufe(e,t){(Array.isArray(t)?t:[t]).forEach(a=>{let r=a instanceof Ft?a.score:zr(a)?a.detection.score:void 0,s=a instanceof Ft?a.box:zr(a)?a.detection.box:new mn(a),i=r?`${nl(r)}`:void 0;new Od(s,{label:i}).draw(e)})}function Yf(e){let{Image:t,Video:n}=at.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function q$(e){return new Promise((t,n)=>{if(e instanceof at.getEnv().Canvas||Yf(e)){t(null);return}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener(\"load\",r),s.currentTarget.removeEventListener(\"error\",a),n(s))}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener(\"load\",r),s.currentTarget.removeEventListener(\"error\",a),t(s))}e.addEventListener(\"load\",r),e.addEventListener(\"error\",a)})}function K$(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error(\"bufferToImage - expected buf to be of type: Blob\"));let a=new FileReader;a.onload=()=>{typeof a.result!=\"string\"&&n(new Error(\"bufferToImage - expected reader.result to be a string, in onload\"));let r=at.getEnv().createImageElement();r.onload=()=>t(r),r.onerror=n,r.src=a.result},a.onerror=n,a.readAsDataURL(e)})}function Sp(e){let{Image:t,Video:n}=at.getEnv();return e instanceof t?new aa(e.naturalWidth,e.naturalHeight):e instanceof n?new aa(e.videoWidth,e.videoHeight):new aa(e.width,e.height)}function Np({width:e,height:t}){let{createCanvasElement:n}=at.getEnv(),a=n();return a.width=e,a.height=t,a}function Zf(e,t){let{ImageData:n}=at.getEnv();if(!(e instanceof n)&&!Yf(e))throw new Error(\"createCanvasFromMedia - media has not finished loading yet\");let{width:a,height:r}=t||Sp(e),s=Np({width:a,height:r});return e instanceof n?ra(s).putImageData(e,0,0):ra(s).drawImage(e,0,0,a,r),s}async function X$(e,t){let n=t||at.getEnv().createCanvasElement(),[a,r,s]=e.shape.slice(wa(e)?1:0),i=O(()=>e.as3D(a,r,s).toInt());return await qo.toPixels(i,n),i.dispose(),n}function Sk(e){let{Image:t,Canvas:n,Video:a}=at.getEnv();return e instanceof t||e instanceof n||e instanceof a}function Y$(e,t,n=!1){let{Image:a,Canvas:r}=at.getEnv();if(!(e instanceof a||e instanceof r))throw new Error(\"imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement\");if(t<=0)return Np({width:1,height:1});let s=Sp(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=Np({width:t,height:t}),p=e instanceof r?e:Zf(e),d=Math.abs(o-l)/2,c=n&&o<l?d:0,h=n&&l<o?d:0;return p.width>0&&p.height>0&&ra(u).drawImage(p,c,h,o,l),u}var Wr=class{constructor(t,n=!1){this._imageTensors=[];this._canvases=[];this._treatAsBatchInput=!1;this._inputDimensions=[];this._inputSize=0;if(!Array.isArray(t))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${t}`);this._treatAsBatchInput=n,this._batchSize=t.length,t.forEach((a,r)=>{if(Lr(a)){this._imageTensors[r]=a,this._inputDimensions[r]=a.shape;return}if(wa(a)){let i=a.shape[0];if(i!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${i} passed, but not supported in input array`);this._imageTensors[r]=a,this._inputDimensions[r]=a.shape.slice(1);return}let s=a instanceof at.getEnv().Canvas?a:Zf(a);this._canvases[r]=s,this._inputDimensions[r]=[s.height,s.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return gr(this.batchSize,0,1).map((t,n)=>this.getReshapedInputDimensions(n))}getInput(t){return this.canvases[t]||this.imageTensors[t]}getInputDimensions(t){return this._inputDimensions[t]}getInputHeight(t){return this._inputDimensions[t][0]}getInputWidth(t){return this._inputDimensions[t][1]}getReshapedInputDimensions(t){if(typeof this.inputSize!=\"number\")throw new Error(\"getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet\");let n=this.getInputWidth(t),a=this.getInputHeight(t);return bk({width:n,height:a},this.inputSize)}toBatchTensor(t,n=!0){return this._inputSize=t,O(()=>{let a=gr(this.batchSize,0,1).map(s=>{let i=this.getInput(s);if(i instanceof Ce){let o=wa(i)?i:Gt(i);return o=G$(o,n),(o.shape[1]!==t||o.shape[2]!==t)&&(o=Zn.resizeBilinear(o,[t,t],!1,!1)),o.as3D(t,t,3)}if(i instanceof at.getEnv().Canvas)return qo.fromPixels(Y$(i,t,n));throw new Error(`toBatchTensor - at batchIdx ${s}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${i}`)});return At(a.map(s=>re(s,\"float32\"))).as4D(this.batchSize,t,t,3)})}};async function vt(e){if(e instanceof Wr)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error(\"toNetInput - empty array passed as input\");let n=r=>Array.isArray(e)?` at input index ${r}:`:\"\",a=t.map(kp);return a.forEach((r,s)=>{if(!Sk(r)&&!Lr(r)&&!wa(r))throw typeof t[s]==\"string\"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(wa(r)){let i=r.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(a.map(r=>Sk(r)&&q$(r))),new Wr(a,Array.isArray(e))}async function Pd(e,t){let{Canvas:n}=at.getEnv(),a=e;if(!(e instanceof n)){let i=await vt(e);if(i.batchSize>1)throw new Error(\"extractFaces - batchSize > 1 not supported\");let o=i.getInput(0);a=o instanceof n?o:await X$(o)}let r=ra(a);return t.map(i=>i instanceof Ft?i.forSize(a.width,a.height).box.floor():i).map(i=>i.clipAtImageBorders(a.width,a.height)).map(({x:i,y:o,width:l,height:u})=>{let p=Np({width:l,height:u});return l>0&&u>0&&ra(p).putImageData(r.getImageData(i,o,l,u),0,0),p})}async function Ld(e,t){if(!Lr(e)&&!wa(e))throw new Error(\"extractFaceTensors - expected image tensor to be 3D or 4D\");if(wa(e)&&e.shape[0]>1)throw new Error(\"extractFaceTensors - batchSize > 1 not supported\");return O(()=>{let[n,a,r]=e.shape.slice(wa(e)?1:0);return t.map(o=>o instanceof Ft?o.forSize(a,n).box:o).map(o=>o.clipAtImageBorders(a,n)).filter(o=>o.width>0&&o.height>0).map(({x:o,y:l,width:u,height:p})=>Ho(e.as3D(n,a,r),[l,o,0],[p,u,r]))})}async function Ms(e,t){let{fetch:n}=at.getEnv(),a=await n(e,t);if(!(a.status<400))throw new Error(`failed to fetch: (${a.status}) ${a.statusText}, from url: ${a.url}`);return a}async function sIe(e){let t=await Ms(e),n=await t.blob();if(!n.type.startsWith(\"image/\"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return K$(n)}async function Z$(e){return(await Ms(e)).json()}async function pIe(e){return new Float32Array(await(await Ms(e)).arrayBuffer())}function J$(e){return new Promise((t,n)=>{e instanceof Blob||n(new Error(\"bufferToVideo - expected buf to be of type: Blob\"));let a=at.getEnv().createVideoElement();a.oncanplay=()=>t(a),a.onerror=n,a.playsInline=!0,a.muted=!0,a.src=URL.createObjectURL(e),a.play()})}async function gIe(e){let t=await Ms(e),n=await t.blob();if(!n.type.startsWith(\"video/\"))throw new Error(`fetchVideo - expected blob type to be of type video/*, instead have: ${n.type}, for url: ${t.url}`);return J$(n)}function Jf(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:\"\",manifestUri:n};if(e===\"/\")return{modelBaseUri:\"/\",manifestUri:`/${n}`};let a=e.startsWith(\"http://\")?\"http://\":e.startsWith(\"https://\")?\"https://\":\"\";e=e.replace(a,\"\");let r=e.split(\"/\").filter(o=>o),s=e.endsWith(\".json\")?r[r.length-1]:n,i=a+(e.endsWith(\".json\")?r.slice(0,r.length-1):r).join(\"/\");return i=e.startsWith(\"/\")?`/${i}`:i,{modelBaseUri:i,manifestUri:i===\"/\"?`/${s}`:`${i}/${s}`}}async function Q$(e,t){let{manifestUri:n,modelBaseUri:a}=Jf(e,t),r=await Z$(n);return jt.loadWeights(r,a)}function IIe(e,t,n=!1){let{width:a,height:r}=n?Sp(t):t;return e.width=a,e.height=r,{width:a,height:r}}var fn=class{constructor(t){this._params=void 0;this._paramMappings=[];this._name=t}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(t){let{obj:n,objProp:a}=this.traversePropertyPath(t);return n[a]}reassignParamFromPath(t,n){let{obj:a,objProp:r}=this.traversePropertyPath(t);a[r].dispose(),a[r]=n}getParamList(){return this._paramMappings.map(({paramPath:t})=>({path:t,tensor:this.getParamFromPath(t)}))}getTrainableParams(){return this.getParamList().filter(t=>t.tensor instanceof os)}getFrozenParams(){return this.getParamList().filter(t=>!(t.tensor instanceof os))}variable(){this.getFrozenParams().forEach(({path:t,tensor:n})=>{this.reassignParamFromPath(t,n.variable())})}freeze(){this.getTrainableParams().forEach(({path:t,tensor:n})=>{let a=bn(n.dataSync());n.dispose(),this.reassignParamFromPath(t,a)})}dispose(t=!0){this.getParamList().forEach(n=>{if(t&&n.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${n.path}`);n.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:t})=>Array.from(t.dataSync())).reduce((t,n)=>t.concat(n)))}async load(t){if(t instanceof Float32Array){this.extractWeights(t);return}await this.loadFromUri(t)}async loadFromUri(t){if(t&&typeof t!=\"string\")throw new Error(`${this._name}.loadFromUri - expected model uri`);let n=await Q$(t,this.getDefaultModelName());this.loadFromWeightMap(n)}async loadFromDisk(t){if(t&&typeof t!=\"string\")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:n}=at.getEnv(),{manifestUri:a,modelBaseUri:r}=Jf(t,this.getDefaultModelName()),s=u=>Promise.all(u.map(p=>n(p).then(d=>typeof d==\"string\"?Buffer.from(d):d.buffer))),i=jt.weightsLoaderFactory(s),o=JSON.parse((await n(a)).toString()),l=await i(o,r);this.loadFromWeightMap(l)}loadFromWeightMap(t){let{paramMappings:n,params:a}=this.extractParamsFromWeightMap(t);this._paramMappings=n,this._params=a}extractWeights(t){let{paramMappings:n,params:a}=this.extractParams(t);this._paramMappings=n,this._params=a}traversePropertyPath(t){if(!this.params)throw new Error(\"traversePropertyPath - model has no loaded params\");let n=t.split(\"/\").reduce((s,i)=>{if(!s.nextObj.hasOwnProperty(i))throw new Error(`traversePropertyPath - object does not have property ${i}, for path ${t}`);return{obj:s.nextObj,objProp:i,nextObj:s.nextObj[i]}},{nextObj:this.params}),{obj:a,objProp:r}=n;if(!a||!r||!(a[r]instanceof Ce))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${t}`);return{obj:a,objProp:r}}};function Un(e,t,n){return O(()=>{let a=_s(e,t.depthwise_filter,t.pointwise_filter,n,\"same\");return a=X(a,t.bias),a})}function Qf(e,t,n=!1){return O(()=>{let a=Ke(n?X($t(e,t.conv0.filters,[2,2],\"same\"),t.conv0.bias):Un(e,t.conv0,[2,2])),r=Un(a,t.conv1,[1,1]),s=Ke(X(a,r)),i=Un(s,t.conv2,[1,1]);return Ke(X(a,X(r,i)))})}function zd(e,t,n=!1,a=!0){return O(()=>{let r=Ke(n?X($t(e,t.conv0.filters,a?[2,2]:[1,1],\"same\"),t.conv0.bias):Un(e,t.conv0,a?[2,2]:[1,1])),s=Un(r,t.conv1,[1,1]),i=Ke(X(r,s)),o=Un(i,t.conv2,[1,1]),l=Ke(X(r,X(s,o))),u=Un(l,t.conv3,[1,1]);return Ke(X(r,X(s,X(o,u))))})}function il(e,t,n=\"same\",a=!1){return O(()=>{let r=X($t(e,t.filters,[1,1],n),t.bias);return a?Ke(r):r})}function _n(e,t){Object.keys(e).forEach(n=>{t.some(a=>a.originalPath===n)||e[n].dispose()})}function Tp(e,t){return(n,a,r,s)=>{let i=Fa(e(n*a*r*r),[r,r,n,a]),o=je(e(a));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function eg(e,t){return(n,a,r)=>{let s=Ea(e(n*a),[n,a]),i=je(e(a));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/bias`}),{weights:s,bias:i}}}var Wd=class{constructor(t,n,a){this.depthwise_filter=t;this.pointwise_filter=n;this.bias=a}};function Cp(e,t){return(n,a,r)=>{let s=Fa(e(9*n),[3,3,n,1]),i=Fa(e(n*a),[1,1,n,a]),o=je(e(a));return t.push({paramPath:`${r}/depthwise_filter`},{paramPath:`${r}/pointwise_filter`},{paramPath:`${r}/bias`}),new Wd(s,i,o)}}function Ep(e){return t=>{let n=e(`${t}/depthwise_filter`,4),a=e(`${t}/pointwise_filter`,4),r=e(`${t}/bias`,1);return new Wd(n,a,r)}}function sa(e,t){return(n,a,r)=>{let s=e[n];if(!tl(s,a))throw new Error(`expected weightMap[${n}] to be a Tensor${a}D, instead have ${s}`);return t.push({originalPath:n,paramPath:r||n}),s}}function An(e){let t=e;function n(r){let s=t.slice(0,r);return t=t.slice(r),s}function a(){return t}return{extractWeights:n,getRemainingWeights:a}}function tg(e,t){let n=Tp(e,t),a=Cp(e,t);function r(i,o,l,u=!1){let p=u?n(i,o,3,`${l}/conv0`):a(i,o,`${l}/conv0`),d=a(o,o,`${l}/conv1`),c=a(o,o,`${l}/conv2`);return{conv0:p,conv1:d,conv2:c}}function s(i,o,l,u=!1){let{conv0:p,conv1:d,conv2:c}=r(i,o,l,u),h=a(o,o,`${l}/conv3`);return{conv0:p,conv1:d,conv2:c,conv3:h}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:s}}function eD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),{extractDenseBlock4Params:r}=tg(n,t),s=r(3,32,\"dense0\",!0),i=r(32,64,\"dense1\"),o=r(64,128,\"dense2\"),l=r(128,256,\"dense3\");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function ng(e){return t=>{let n=e(`${t}/filters`,4),a=e(`${t}/bias`,1);return{filters:n,bias:a}}}function ag(e,t){let n=sa(e,t),a=ng(n),r=Ep(n);function s(o,l=!1){let u=l?a(`${o}/conv0`):r(`${o}/conv0`),p=r(`${o}/conv1`),d=r(`${o}/conv2`);return{conv0:u,conv1:p,conv2:d}}function i(o,l=!1){let u=l?a(`${o}/conv0`):r(`${o}/conv0`),p=r(`${o}/conv1`),d=r(`${o}/conv2`),c=r(`${o}/conv3`);return{conv0:u,conv1:p,conv2:d,conv3:c}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function tD(e){let t=[],{extractDenseBlock4Params:n}=ag(e,t),a={dense0:n(\"dense0\",!0),dense1:n(\"dense1\"),dense2:n(\"dense2\"),dense3:n(\"dense3\")};return _n(e,t),{params:a,paramMappings:t}}var _p=class extends fn{constructor(){super(\"FaceFeatureExtractor\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"FaceFeatureExtractor - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(112,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=zd(s,n.dense0,!0);return i=zd(i,n.dense1),i=zd(i,n.dense2),i=zd(i,n.dense3),i=ya(i,[7,7],[2,2],\"valid\"),i})}async forward(t){return this.forwardInput(await vt(t))}getDefaultModelName(){return\"face_feature_extractor_model\"}extractParamsFromWeightMap(t){return tD(t)}extractParams(t){return eD(t)}};function Bd(e,t){return O(()=>X($e(e,t.weights),t.bias))}function nD(e,t,n){let a=[],{extractWeights:r,getRemainingWeights:s}=An(e),o=eg(r,a)(t,n,\"fc\");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:a,params:{fc:o}}}function aD(e){let t=[],n=sa(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:a(\"fc\")};return _n(e,t),{params:r,paramMappings:t}}function rg(e){let t={},n={};return Object.keys(e).forEach(a=>{let r=a.startsWith(\"fc\")?n:t;r[a]=e[a]}),{featureExtractorMap:t,classifierMap:n}}var Ap=class extends fn{constructor(t,n){super(t),this._faceFeatureExtractor=n}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return O(()=>{let a=t instanceof Wr?this.faceFeatureExtractor.forwardInput(t):t;return Bd(a.as2D(a.shape[0],-1),n.fc)})}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:a}=this.extractClassifierParams(t);this._params=n,this._paramMappings=a}extractClassifierParams(t){return nD(t,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:a}=rg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),aD(a)}extractParams(t){let n=this.getClassifierChannelsIn(),a=this.getClassifierChannelsOut(),r=a*n+a,s=t.slice(0,t.length-r),i=t.slice(t.length-r);return this.faceFeatureExtractor.extractWeights(s),this.extractClassifierParams(i)}};var rD=[\"neutral\",\"happy\",\"sad\",\"angry\",\"fearful\",\"disgusted\",\"surprised\"],Os=class{constructor(t){this.neutral=0;this.happy=0;this.sad=0;this.angry=0;this.fearful=0;this.disgusted=0;this.surprised=0;if(t.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${t.length}`);rD.forEach((n,a)=>{this[n]=t[a]})}asSortedArray(){return rD.map(t=>({expression:t,probability:this[t]})).sort((t,n)=>n.probability-t.probability)}};var sg=class extends Ap{constructor(t=new _p){super(\"FaceExpressionNet\",t)}forwardInput(t){return O(()=>qa(this.runNet(t)))}async forward(t){return this.forwardInput(await vt(t))}async predictExpressions(t){let n=await vt(t),a=await this.forwardInput(n),r=await Promise.all(dt(a).map(async i=>{let o=i.dataSync();return i.dispose(),o}));a.dispose();let s=r.map(i=>new Os(i));return n.isBatchInput?s:s[0]}getDefaultModelName(){return\"face_expression_model\"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function sD(e){return e.expressions instanceof Os}function Nk(e,t){return{...e,...{expressions:t}}}function Gfe(e,t,n=.1,a){(Array.isArray(t)?t:[t]).forEach(s=>{let i=s instanceof Os?s:sD(s)?s.expressions:void 0;if(!i)throw new Error(\"drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof\");let l=i.asSortedArray().filter(d=>d.probability>n),u=zr(s)?s.detection.box.bottomLeft:a||new He(0,0);new sl(l.map(d=>`${d.expression} (${nl(d.probability)})`),u).draw(e)})}function Fp(e){return zr(e)&&e.landmarks instanceof ka&&e.unshiftedLandmarks instanceof ka&&e.alignedRect instanceof Ft}function Hfe(e){let t=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),a={roll:void 0,pitch:void 0,yaw:void 0},r=(l,u,p)=>{let d=Math.floor(l.x-u.x),c=Math.floor(u.x-p.x);return d-c},s=(l,u)=>{let p=Math.hypot(u.x-l.x,u.y-l.y),d=u.y-l.y,c=Math.asin(d/p),h=t(c),m=Math.floor(90-h),f=u.x-l.x<0?-1:1;return m*f},i=(l,u,p)=>{let d=n(l,p),c=new He((l.x+p.x)/2,(l.y+p.y)/2),h=n(u,c),m=Math.atan(h/d),f=Math.floor(t(m)),g=c.y-u.y<0?-1:1;return f*g};if(!e||!e.positions||e.positions.length!==68)return a;let o=e.positions;return a.roll=s(o[27],o[66]),a.pitch=i(o[14],o[30],o[2]),a.yaw=r(o[14],o[33],o[2]),a}function Vd(e,t){let{box:n}=e.detection,a=t.shiftBy(n.x,n.y),r=a.align(),{imageDims:s}=e.detection,i=new Ft(e.detection.score,r.rescale(s.reverse()),s),o=Hfe(t);return{...e,...{landmarks:a,unshiftedLandmarks:t,alignedRect:i,angle:o}}}var ig=class{constructor(t={}){let{drawLines:n=!0,drawPoints:a=!0,lineWidth:r,lineColor:s,pointSize:i,pointColor:o}=t;this.drawLines=n,this.drawPoints=a,this.lineWidth=r||1,this.pointSize=i||2,this.lineColor=s||\"rgba(0, 255, 255, 1)\",this.pointColor=o||\"rgba(255, 0, 255, 1)\"}},og=class{constructor(t,n={}){this.faceLandmarks=t,this.options=new ig(n)}draw(t){let n=ra(t),{drawLines:a,drawPoints:r,lineWidth:s,lineColor:i,pointSize:o,pointColor:l}=this.options;if(a&&this.faceLandmarks instanceof vp&&(n.strokeStyle=i,n.lineWidth=s,Pr(n,this.faceLandmarks.getJawOutline()),Pr(n,this.faceLandmarks.getLeftEyeBrow()),Pr(n,this.faceLandmarks.getRightEyeBrow()),Pr(n,this.faceLandmarks.getNose()),Pr(n,this.faceLandmarks.getLeftEye(),!0),Pr(n,this.faceLandmarks.getRightEye(),!0),Pr(n,this.faceLandmarks.getMouth(),!0)),r){n.strokeStyle=l,n.fillStyle=l;let u=p=>{n.beginPath(),n.arc(p.x,p.y,o,0,2*Math.PI),n.fill()};this.faceLandmarks.positions.forEach(u)}}};function jfe(e,t){(Array.isArray(t)?t:[t]).forEach(a=>{let r=a instanceof ka?a:Fp(a)?a.landmarks:void 0;if(!r)throw new Error(\"drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof\");new og(r).draw(e)})}var oD=\"1.7.15\";function Xfe(e,t){let n=Tp(e,t),a=Cp(e,t);function r(i,o,l){let u=a(i,o,`${l}/separable_conv0`),p=a(o,o,`${l}/separable_conv1`),d=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:p,expansion_conv:d}}function s(i,o){let l=a(i,i,`${o}/separable_conv0`),u=a(i,i,`${o}/separable_conv1`),p=a(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:p}}return{extractConvParams:n,extractSeparableConvParams:a,extractReductionBlockParams:r,extractMainBlockParams:s}}function lD(e,t){let n=[],{extractWeights:a,getRemainingWeights:r}=An(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=Xfe(a,n),u=s(3,32,3,\"entry_flow/conv_in\"),p=o(32,64,\"entry_flow/reduction_block_0\"),d=o(64,128,\"entry_flow/reduction_block_1\"),c={conv_in:u,reduction_block_0:p,reduction_block_1:d},h={};gr(t,0,1).forEach(b=>{h[`main_block_${b}`]=l(128,`middle_flow/main_block_${b}`)});let m=o(128,256,\"exit_flow/reduction_block\"),f=i(256,512,\"exit_flow/separable_conv\"),g={reduction_block:m,separable_conv:f};if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:n,params:{entry_flow:c,middle_flow:h,exit_flow:g}}}function Yfe(e,t){let n=sa(e,t),a=ng(n),r=Ep(n);function s(o){let l=r(`${o}/separable_conv0`),u=r(`${o}/separable_conv1`),p=a(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:p}}function i(o){let l=r(`${o}/separable_conv0`),u=r(`${o}/separable_conv1`),p=r(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:p}}return{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}}function uD(e,t){let n=[],{extractConvParams:a,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}=Yfe(e,n),o=a(\"entry_flow/conv_in\"),l=s(\"entry_flow/reduction_block_0\"),u=s(\"entry_flow/reduction_block_1\"),p={conv_in:o,reduction_block_0:l,reduction_block_1:u},d={};gr(t,0,1).forEach(f=>{d[`main_block_${f}`]=i(`middle_flow/main_block_${f}`)});let c=s(\"exit_flow/reduction_block\"),h=r(\"exit_flow/separable_conv\"),m={reduction_block:c,separable_conv:h};return _n(e,n),{params:{entry_flow:p,middle_flow:d,exit_flow:m},paramMappings:n}}function pD(e,t,n){return X($t(e,t.filters,n,\"same\"),t.bias)}function Tk(e,t,n=!0){let a=n?Ke(e):e;return a=Un(a,t.separable_conv0,[1,1]),a=Un(Ke(a),t.separable_conv1,[1,1]),a=Dt(a,[3,3],[2,2],\"same\"),a=X(a,pD(e,t.expansion_conv,[2,2])),a}function Zfe(e,t){let n=Un(Ke(e),t.separable_conv0,[1,1]);return n=Un(Ke(n),t.separable_conv1,[1,1]),n=Un(Ke(n),t.separable_conv2,[1,1]),n=X(n,e),n}var lg=class extends fn{constructor(t){super(\"TinyXception\"),this._numMainBlocks=t}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"TinyXception - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(112,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=Ke(pD(s,n.entry_flow.conv_in,[2,2]));return i=Tk(i,n.entry_flow.reduction_block_0,!1),i=Tk(i,n.entry_flow.reduction_block_1),gr(this._numMainBlocks,0,1).forEach(o=>{i=Zfe(i,n.middle_flow[`main_block_${o}`])}),i=Tk(i,n.exit_flow.reduction_block),i=Ke(Un(i,n.exit_flow.separable_conv,[1,1])),i})}async forward(t){return this.forwardInput(await vt(t))}getDefaultModelName(){return\"tiny_xception_model\"}extractParamsFromWeightMap(t){return uD(t,this._numMainBlocks)}extractParams(t){return lD(t,this._numMainBlocks)}};function cD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),r=eg(n,t),s=r(512,1,\"fc/age\"),i=r(512,2,\"fc/gender\");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function dD(e){let t=[],n=sa(e,t);function a(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:{age:a(\"fc/age\"),gender:a(\"fc/gender\")}};return _n(e,t),{params:r,paramMappings:t}}var Ck=(n=>(n.FEMALE=\"female\",n.MALE=\"male\",n))(Ck||{});var ug=class extends fn{constructor(t=new lg(2)){super(\"AgeGenderNet\"),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(t){let{params:n}=this;if(!n)throw new Error(`${this._name} - load model before inference`);return O(()=>{let a=t instanceof Wr?this.faceFeatureExtractor.forwardInput(t):t,r=ya(a,[7,7],[2,2],\"valid\").as2D(a.shape[0],-1),s=Bd(r,n.fc.age).as1D(),i=Bd(r,n.fc.gender);return{age:s,gender:i}})}forwardInput(t){return O(()=>{let{age:n,gender:a}=this.runNet(t);return{age:n,gender:qa(a)}})}async forward(t){return this.forwardInput(await vt(t))}async predictAgeAndGender(t){let n=await vt(t),a=await this.forwardInput(n),r=dt(a.age),s=dt(a.gender),i=r.map((l,u)=>({ageTensor:l,genderTensor:s[u]})),o=await Promise.all(i.map(async({ageTensor:l,genderTensor:u})=>{let p=l.dataSync()[0],d=u.dataSync()[0],c=d>.5,h=c?\"male\":\"female\",m=c?d:1-d;return l.dispose(),u.dispose(),{age:p,gender:h,genderProbability:m}}));return a.age.dispose(),a.gender.dispose(),n.isBatchInput?o:o[0]}getDefaultModelName(){return\"age_gender_model\"}dispose(t=!0){this.faceFeatureExtractor.dispose(t),super.dispose(t)}loadClassifierParams(t){let{params:n,paramMappings:a}=this.extractClassifierParams(t);this._params=n,this._paramMappings=a}extractClassifierParams(t){return cD(t)}extractParamsFromWeightMap(t){let{featureExtractorMap:n,classifierMap:a}=rg(t);return this.faceFeatureExtractor.loadFromWeightMap(n),dD(a)}extractParams(t){let a=t.slice(0,t.length-1539),r=t.slice(t.length-1539);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(r)}};var $p=class extends Ap{postProcess(t,n,a){let r=a.map(({width:i,height:o})=>{let l=n/Math.max(o,i);return{width:i*l,height:o*l}}),s=r.length;return O(()=>{let i=(d,c)=>At([yn([68],d,\"float32\"),yn([68],c,\"float32\")],1).as2D(1,136).as1D(),o=(d,c)=>{let{width:h,height:m}=r[d];return c(h,m)?Math.abs(h-m)/2:0},l=d=>o(d,(c,h)=>c<h),u=d=>o(d,(c,h)=>h<c);return t.mul(yn([s,136],n,\"float32\")).sub(At(Array.from(Array(s),(d,c)=>i(l(c),u(c))))).div(At(Array.from(Array(s),(d,c)=>i(r[c].width,r[c].height))))})}forwardInput(t){return O(()=>{let n=this.runNet(t);return this.postProcess(n,t.inputSize,t.inputDimensions.map(([a,r])=>({height:a,width:r})))})}async forward(t){return this.forwardInput(await vt(t))}async detectLandmarks(t){let n=await vt(t),a=O(()=>dt(this.forwardInput(n))),r=await Promise.all(a.map(async(s,i)=>{let o=Array.from(s.dataSync()),l=o.filter((p,d)=>Hf(d)),u=o.filter((p,d)=>!Hf(d));return new vp(Array(68).fill(0).map((p,d)=>new He(l[d],u[d])),{height:n.getInputHeight(i),width:n.getInputWidth(i)})}));return a.forEach(s=>s.dispose()),n.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}};var Dp=class extends $p{constructor(t=new _p){super(\"FaceLandmark68Net\",t)}getDefaultModelName(){return\"face_landmark_68_model\"}getClassifierChannelsIn(){return 256}};function hD(e){let t=[],{extractDenseBlock3Params:n}=ag(e,t),a={dense0:n(\"dense0\",!0),dense1:n(\"dense1\"),dense2:n(\"dense2\")};return _n(e,t),{params:a,paramMappings:t}}function mD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),{extractDenseBlock3Params:r}=tg(n,t),s=r(3,32,\"dense0\",!0),i=r(32,64,\"dense1\"),o=r(64,128,\"dense2\");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var pg=class extends fn{constructor(){super(\"TinyFaceFeatureExtractor\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"TinyFaceFeatureExtractor - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(112,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=Qf(s,n.dense0,!0);return i=Qf(i,n.dense1),i=Qf(i,n.dense2),i=ya(i,[14,14],[2,2],\"valid\"),i})}async forward(t){return this.forwardInput(await vt(t))}getDefaultModelName(){return\"face_feature_extractor_tiny_model\"}extractParamsFromWeightMap(t){return hD(t)}extractParams(t){return mD(t)}};var cg=class extends $p{constructor(t=new pg){super(\"FaceLandmark68TinyNet\",t)}getDefaultModelName(){return\"face_landmark_68_tiny_model\"}getClassifierChannelsIn(){return 128}};var fD=class extends Dp{};function gD(e,t){return X(z(e,t.weights),t.biases)}function Ek(e,t,n,a,r=\"same\"){let{filters:s,bias:i}=t.conv,o=$t(e,s,n,r);return o=X(o,i),o=gD(o,t.scale),a?Ke(o):o}function bD(e,t){return Ek(e,t,[1,1],!0)}function _k(e,t){return Ek(e,t,[1,1],!1)}function dg(e,t){return Ek(e,t,[2,2],!0,\"valid\")}function Jfe(e,t){function n(o,l,u){let p=e(o),d=p.length/(l*u*u);if(gk(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${p.length}, numFilters: ${l}, filterSize: ${u}`);return O(()=>De(Fa(p,[l,d,u,u]),[2,3,1,0]))}function a(o,l,u,p){let d=n(o,l,u),c=je(e(l));return t.push({paramPath:`${p}/filters`},{paramPath:`${p}/bias`}),{filters:d,bias:c}}function r(o,l){let u=je(e(o)),p=je(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:p}}function s(o,l,u,p){let d=a(o,l,u,`${p}/conv`),c=r(l,`${p}/scale`);return{conv:d,scale:c}}function i(o,l,u,p,d=!1){let c=s((d?.5:1)*o,l,u,`${p}/conv1`),h=s(o,l,u,`${p}/conv2`);return{conv1:c,conv2:h}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function yD(e){let{extractWeights:t,getRemainingWeights:n}=An(e),a=[],{extractConvLayerParams:r,extractResidualLayerParams:s}=Jfe(t,a),i=r(4704,32,7,\"conv32_down\"),o=s(9216,32,3,\"conv32_1\"),l=s(9216,32,3,\"conv32_2\"),u=s(9216,32,3,\"conv32_3\"),p=s(36864,64,3,\"conv64_down\",!0),d=s(36864,64,3,\"conv64_1\"),c=s(36864,64,3,\"conv64_2\"),h=s(36864,64,3,\"conv64_3\"),m=s(147456,128,3,\"conv128_down\",!0),f=s(147456,128,3,\"conv128_1\"),g=s(147456,128,3,\"conv128_2\"),b=s(589824,256,3,\"conv256_down\",!0),y=s(589824,256,3,\"conv256_1\"),x=s(589824,256,3,\"conv256_2\"),v=s(589824,256,3,\"conv256_down_out\"),I=O(()=>De(Ea(t(256*128),[128,256]),[1,0]));if(a.push({paramPath:\"fc\"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:p,conv64_1:d,conv64_2:c,conv64_3:h,conv128_down:m,conv128_1:f,conv128_2:g,conv256_down:b,conv256_1:y,conv256_2:x,conv256_down_out:v,fc:I},paramMappings:a}}function Qfe(e,t){let n=sa(e,t);function a(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function r(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),u=a(i);return{conv:{filters:o,bias:l},scale:u}}function s(i){return{conv1:r(`${i}/conv1`),conv2:r(`${i}/conv2`)}}return{extractConvLayerParams:r,extractResidualLayerParams:s}}function xD(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:a}=Qfe(e,t),r=n(\"conv32_down\"),s=a(\"conv32_1\"),i=a(\"conv32_2\"),o=a(\"conv32_3\"),l=a(\"conv64_down\"),u=a(\"conv64_1\"),p=a(\"conv64_2\"),d=a(\"conv64_3\"),c=a(\"conv128_down\"),h=a(\"conv128_1\"),m=a(\"conv128_2\"),f=a(\"conv256_down\"),g=a(\"conv256_1\"),b=a(\"conv256_2\"),y=a(\"conv256_down_out\"),{fc:x}=e;if(t.push({originalPath:\"fc\",paramPath:\"fc\"}),!fk(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let v={conv32_down:r,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:p,conv64_3:d,conv128_down:c,conv128_1:h,conv128_2:m,conv256_down:f,conv256_1:g,conv256_2:b,conv256_down_out:y,fc:x};return _n(e,t),{params:v,paramMappings:t}}function Ya(e,t){let n=bD(e,t.conv1);return n=_k(n,t.conv2),n=X(n,e),n=Ke(n),n}function Ud(e,t){let n=dg(e,t.conv1);n=_k(n,t.conv2);let a=ya(e,2,2,\"valid\"),r=It(a.shape),s=a.shape[3]!==n.shape[3];if(a.shape[1]!==n.shape[1]||a.shape[2]!==n.shape[2]){let o=[...n.shape];o[1]=1;let l=It(o);n=et([n,l],1);let u=[...n.shape];u[2]=1;let p=It(u);n=et([n,p],2)}return a=s?et([a,r],3):a,n=X(a,n),n=Ke(n),n}var Rp=class extends fn{constructor(){super(\"FaceRecognitionNet\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"FaceRecognitionNet - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(150,!0),\"float32\"),s=br(a,[122.782,117.001,104.298]).div(255),i=dg(s,n.conv32_down);i=Dt(i,3,2,\"valid\"),i=Ya(i,n.conv32_1),i=Ya(i,n.conv32_2),i=Ya(i,n.conv32_3),i=Ud(i,n.conv64_down),i=Ya(i,n.conv64_1),i=Ya(i,n.conv64_2),i=Ya(i,n.conv64_3),i=Ud(i,n.conv128_down),i=Ya(i,n.conv128_1),i=Ya(i,n.conv128_2),i=Ud(i,n.conv256_down),i=Ya(i,n.conv256_1),i=Ya(i,n.conv256_2),i=Ud(i,n.conv256_down_out);let o=i.mean([1,2]);return $e(o,n.fc)})}async forward(t){return this.forwardInput(await vt(t))}async computeFaceDescriptor(t){var s;if((s=t==null?void 0:t.shape)!=null&&s.some(i=>i<=0))return new Float32Array(128);let n=await vt(t),a=O(()=>dt(this.forwardInput(n))),r=await Promise.all(a.map(i=>i.data()));return a.forEach(i=>i.dispose()),n.isBatchInput?r:r[0]}getDefaultModelName(){return\"face_recognition_model\"}extractParamsFromWeightMap(t){return xD(t)}extractParams(t){return yD(t)}};function Y2e(e){let t=new Rp;return t.extractWeights(e),t}function Ak(e,t){return{...e,...{descriptor:t}}}function eCe(e){return typeof e.age==\"number\"}function Fk(e,t){return{...e,...{age:t}}}function rCe(e){return(e.gender===\"male\"||e.gender===\"female\")&&gp(e.genderProbability)}function $k(e,t,n){return{...e,...{gender:t,genderProbability:n}}}function ege(e,t){function n(l,u){let p=Fa(e(9*l),[3,3,l,1]),d=je(e(l)),c=je(e(l)),h=je(e(l)),m=je(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:p,batch_norm_scale:d,batch_norm_offset:c,batch_norm_mean:h,batch_norm_variance:m}}function a(l,u,p,d,c){let h=Fa(e(l*u*p*p),[p,p,l,u]),m=je(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${c?\"batch_norm_offset\":\"bias\"}`}),{filters:h,bias:m}}function r(l,u,p,d){let{filters:c,bias:h}=a(l,u,p,d,!0);return{filters:c,batch_norm_offset:h}}function s(l,u,p){let d=n(l,`${p}/depthwise_conv`),c=r(l,u,1,`${p}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:c}}function i(){let l=r(3,32,3,\"mobilenetv1/conv_0\"),u=s(32,64,\"mobilenetv1/conv_1\"),p=s(64,128,\"mobilenetv1/conv_2\"),d=s(128,128,\"mobilenetv1/conv_3\"),c=s(128,256,\"mobilenetv1/conv_4\"),h=s(256,256,\"mobilenetv1/conv_5\"),m=s(256,512,\"mobilenetv1/conv_6\"),f=s(512,512,\"mobilenetv1/conv_7\"),g=s(512,512,\"mobilenetv1/conv_8\"),b=s(512,512,\"mobilenetv1/conv_9\"),y=s(512,512,\"mobilenetv1/conv_10\"),x=s(512,512,\"mobilenetv1/conv_11\"),v=s(512,1024,\"mobilenetv1/conv_12\"),I=s(1024,1024,\"mobilenetv1/conv_13\");return{conv_0:l,conv_1:u,conv_2:p,conv_3:d,conv_4:c,conv_5:h,conv_6:m,conv_7:f,conv_8:g,conv_9:b,conv_10:y,conv_11:x,conv_12:v,conv_13:I}}function o(){let l=r(1024,256,1,\"prediction_layer/conv_0\"),u=r(256,512,3,\"prediction_layer/conv_1\"),p=r(512,128,1,\"prediction_layer/conv_2\"),d=r(128,256,3,\"prediction_layer/conv_3\"),c=r(256,128,1,\"prediction_layer/conv_4\"),h=r(128,256,3,\"prediction_layer/conv_5\"),m=r(256,64,1,\"prediction_layer/conv_6\"),f=r(64,128,3,\"prediction_layer/conv_7\"),g=a(512,12,1,\"prediction_layer/box_predictor_0/box_encoding_predictor\"),b=a(512,9,1,\"prediction_layer/box_predictor_0/class_predictor\"),y=a(1024,24,1,\"prediction_layer/box_predictor_1/box_encoding_predictor\"),x=a(1024,18,1,\"prediction_layer/box_predictor_1/class_predictor\"),v=a(512,24,1,\"prediction_layer/box_predictor_2/box_encoding_predictor\"),I=a(512,18,1,\"prediction_layer/box_predictor_2/class_predictor\"),N=a(256,24,1,\"prediction_layer/box_predictor_3/box_encoding_predictor\"),C=a(256,18,1,\"prediction_layer/box_predictor_3/class_predictor\"),_=a(256,24,1,\"prediction_layer/box_predictor_4/box_encoding_predictor\"),F=a(256,18,1,\"prediction_layer/box_predictor_4/class_predictor\"),D=a(128,24,1,\"prediction_layer/box_predictor_5/box_encoding_predictor\"),$=a(128,18,1,\"prediction_layer/box_predictor_5/class_predictor\");return{conv_0:l,conv_1:u,conv_2:p,conv_3:d,conv_4:c,conv_5:h,conv_6:m,conv_7:f,box_predictor_0:{box_encoding_predictor:g,class_predictor:b},box_predictor_1:{box_encoding_predictor:y,class_predictor:x},box_predictor_2:{box_encoding_predictor:v,class_predictor:I},box_predictor_3:{box_encoding_predictor:N,class_predictor:C},box_predictor_4:{box_encoding_predictor:_,class_predictor:F},box_predictor_5:{box_encoding_predictor:D,class_predictor:$}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function vD(e){let t=[],{extractWeights:n,getRemainingWeights:a}=An(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:s}=ege(n,t),i=r(),o=s(),u={extra_dim:xd(n(5118*4),[1,5118,4])};if(t.push({paramPath:\"output_layer/extra_dim\"}),a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:u},paramMappings:t}}function tge(e,t){let n=sa(e,t);function a(u,p,d){let c=n(`${u}/Conv2d_${p}_pointwise/weights`,4,`${d}/filters`),h=n(`${u}/Conv2d_${p}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:c,batch_norm_offset:h}}function r(u){let p=`mobilenetv1/conv_${u}`,d=`MobilenetV1/Conv2d_${u}_depthwise`,c=`${p}/depthwise_conv`,h=`${p}/pointwise_conv`,m=n(`${d}/depthwise_weights`,4,`${c}/filters`),f=n(`${d}/BatchNorm/gamma`,1,`${c}/batch_norm_scale`),g=n(`${d}/BatchNorm/beta`,1,`${c}/batch_norm_offset`),b=n(`${d}/BatchNorm/moving_mean`,1,`${c}/batch_norm_mean`),y=n(`${d}/BatchNorm/moving_variance`,1,`${c}/batch_norm_variance`);return{depthwise_conv:{filters:m,batch_norm_scale:f,batch_norm_offset:g,batch_norm_mean:b,batch_norm_variance:y},pointwise_conv:a(\"MobilenetV1\",u,h)}}function s(){return{conv_0:a(\"MobilenetV1\",0,\"mobilenetv1/conv_0\"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}}function i(u,p){let d=n(`${u}/weights`,4,`${p}/filters`),c=n(`${u}/biases`,1,`${p}/bias`);return{filters:d,bias:c}}function o(u){let p=i(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),d=i(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:p,class_predictor:d}}function l(){return{conv_0:a(\"Prediction\",0,\"prediction_layer/conv_0\"),conv_1:a(\"Prediction\",1,\"prediction_layer/conv_1\"),conv_2:a(\"Prediction\",2,\"prediction_layer/conv_2\"),conv_3:a(\"Prediction\",3,\"prediction_layer/conv_3\"),conv_4:a(\"Prediction\",4,\"prediction_layer/conv_4\"),conv_5:a(\"Prediction\",5,\"prediction_layer/conv_5\"),conv_6:a(\"Prediction\",6,\"prediction_layer/conv_6\"),conv_7:a(\"Prediction\",7,\"prediction_layer/conv_7\"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function wD(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:a}=tge(e,t),r=e[\"Output/extra_dim\"];if(t.push({originalPath:\"Output/extra_dim\",paramPath:\"output_layer/extra_dim\"}),!Lr(r))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${r}`);let s={mobilenetv1:n(),prediction_layer:a(),output_layer:{extra_dim:r}};return _n(e,t),{params:s,paramMappings:t}}function Ra(e,t,n){return O(()=>{let a=$t(e,t.filters,n,\"same\");return a=X(a,t.batch_norm_offset),an(a,0,6)})}var nge=.0010000000474974513;function age(e,t,n){return O(()=>{let a=Ts(e,t.filters,n,\"same\");return a=Ns(a,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,nge),an(a,0,6)})}function rge(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function kD(e,t){return O(()=>{let n,a=Ra(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((s,i)=>{let o=i+1,l=rge(o);a=age(a,s.depthwise_conv,l),a=Ra(a,s.pointwise_conv,[1,1]),o===11&&(n=a)}),n===null)throw new Error(\"mobileNetV1 - output of conv layer 11 is null\");return{out:a,conv11:n}})}function sge(e,t,n){let a=e.arraySync(),r=Math.min(a[t][0],a[t][2]),s=Math.min(a[t][1],a[t][3]),i=Math.max(a[t][0],a[t][2]),o=Math.max(a[t][1],a[t][3]),l=Math.min(a[n][0],a[n][2]),u=Math.min(a[n][1],a[n][3]),p=Math.max(a[n][0],a[n][2]),d=Math.max(a[n][1],a[n][3]),c=(i-r)*(o-s),h=(p-l)*(d-u);if(c<=0||h<=0)return 0;let m=Math.max(r,l),f=Math.max(s,u),g=Math.min(i,p),b=Math.min(o,d),y=Math.max(g-m,0)*Math.max(b-f,0);return y/(c+h-y)}function ID(e,t,n,a,r){let s=e.shape[0],i=Math.min(n,s),o=t.map((p,d)=>({score:p,boxIndex:d})).filter(p=>p.score>r).sort((p,d)=>d.score-p.score),l=p=>p<=a?1:0,u=[];return o.forEach(p=>{if(u.length>=i)return;let d=p.score;for(let c=u.length-1;c>=0;--c){let h=sge(e,p.boxIndex,u[c]);if(h!==0&&(p.score*=l(h),p.score<=r))break}d===p.score&&u.push(p.boxIndex)}),u}function ige(e){let t=dt(De(e,[1,0])),n=[pe(t[2],t[0]),pe(t[3],t[1])],a=[X(t[0],he(n[0],2)),X(t[1],he(n[1],2))];return{sizes:n,centers:a}}function oge(e,t){let{sizes:n,centers:a}=ige(e),r=dt(De(t,[1,0])),s=he(z(dn(he(r[2],5)),n[0]),2),i=X(z(he(r[0],10),n[0]),a[0]),o=he(z(dn(he(r[3],5)),n[1]),2),l=X(z(he(r[1],10),n[1]),a[1]);return De(At([pe(i,s),pe(l,o),X(i,s),X(l,o)]),[1,0])}function SD(e,t,n){return O(()=>{let a=e.shape[0],r=oge(W(On(n.extra_dim,[a,1,1]),[-1,4]),W(e,[-1,4]));r=W(r,[a,r.shape[0]/a,4]);let s=ha(Ve(t,[0,0,1],[-1,-1,-1])),i=Ve(s,[0,0,0],[-1,-1,1]);i=W(i,[a,i.shape[1]]);let o=dt(r),l=dt(i);return{boxes:o,scores:l}})}function ol(e,t){return O(()=>{let n=e.shape[0],a=W(il(e,t.box_encoding_predictor),[n,-1,1,4]),r=W(il(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:a,classPrediction:r}})}function ND(e,t,n){return O(()=>{let a=Ra(e,n.conv_0,[1,1]),r=Ra(a,n.conv_1,[2,2]),s=Ra(r,n.conv_2,[1,1]),i=Ra(s,n.conv_3,[2,2]),o=Ra(i,n.conv_4,[1,1]),l=Ra(o,n.conv_5,[2,2]),u=Ra(l,n.conv_6,[1,1]),p=Ra(u,n.conv_7,[2,2]),d=ol(t,n.box_predictor_0),c=ol(e,n.box_predictor_1),h=ol(r,n.box_predictor_2),m=ol(i,n.box_predictor_3),f=ol(l,n.box_predictor_4),g=ol(p,n.box_predictor_5),b=et([d.boxPredictionEncoding,c.boxPredictionEncoding,h.boxPredictionEncoding,m.boxPredictionEncoding,f.boxPredictionEncoding,g.boxPredictionEncoding],1),y=et([d.classPrediction,c.classPrediction,h.classPrediction,m.classPrediction,f.classPrediction,g.classPrediction],1);return{boxPredictions:b,classPredictions:y}})}var Ma=class{constructor({minConfidence:t,maxResults:n}={}){this._name=\"SsdMobilenetv1Options\";if(this._minConfidence=t||.5,this._maxResults=n||100,typeof this._minConfidence!=\"number\"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!=\"number\")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}};var ll=class extends fn{constructor(){super(\"SsdMobilenetv1\")}forwardInput(t){let{params:n}=this;if(!n)throw new Error(\"SsdMobilenetv1 - load model before inference\");return O(()=>{let a=re(t.toBatchTensor(512,!1),\"float32\"),r=pe(he(a,127.5),1),s=kD(r,n.mobilenetv1),{boxPredictions:i,classPredictions:o}=ND(s.out,s.conv11,n.prediction_layer);return SD(i,o,n.output_layer)})}async forward(t){return this.forwardInput(await vt(t))}async locateFaces(t,n={}){let{maxResults:a,minConfidence:r}=new Ma(n),s=await vt(t),{boxes:i,scores:o}=this.forwardInput(s),l=i[0],u=o[0];for(let x=1;x<i.length;x++)i[x].dispose(),o[x].dispose();let p=Array.from(u.dataSync()),c=ID(l,p,a,.5,r),h=s.getReshapedInputDimensions(0),m=s.inputSize,f=m/h.width,g=m/h.height,b=l.arraySync(),y=c.map(x=>{let[v,I]=[Math.max(0,b[x][0]),Math.min(1,b[x][2])].map(_=>_*g),[N,C]=[Math.max(0,b[x][1]),Math.min(1,b[x][3])].map(_=>_*f);return new Ft(p[x],new xp(N,v,C-N,I-v),{height:s.getInputHeight(0),width:s.getInputWidth(0)})});return l.dispose(),u.dispose(),y}getDefaultModelName(){return\"ssd_mobilenetv1_model\"}extractParamsFromWeightMap(t){return wD(t)}extractParams(t){return vD(t)}};function lge(e){let t=new ll;return t.extractWeights(e),t}function YCe(e){return lge(e)}var TD=class extends ll{};var CD=.4,ED=[new He(.738768,.874946),new He(2.42204,2.65704),new He(4.30971,7.04493),new He(10.246,4.59428),new He(12.6868,11.8741)],_D=[new He(1.603231,2.094468),new He(6.041143,7.080126),new He(2.882459,3.518061),new He(4.266906,5.178857),new He(9.041765,10.66308)],AD=[117.001,114.697,97.404],FD=\"tiny_yolov2_model\",$D=\"tiny_yolov2_separable_conv_model\";var hg=e=>typeof e==\"number\";function DD(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!=\"boolean\")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!hg(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t==\"string\"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>hg(t.x)&&hg(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(hg)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function Mp(e){return O(()=>{let t=z(e,xe(.10000000149011612));return X(Ke(pe(e,t)),t)})}function Br(e,t){return O(()=>{let n=xa(e,[[0,0],[1,1],[1,1],[0,0]]);return n=$t(n,t.conv.filters,[1,1],\"valid\"),n=pe(n,t.bn.sub),n=z(n,t.bn.truediv),n=X(n,t.conv.bias),Mp(n)})}function Vr(e,t){return O(()=>{let n=xa(e,[[0,0],[1,1],[1,1],[0,0]]);return n=_s(n,t.depthwise_filter,t.pointwise_filter,[1,1],\"valid\"),n=X(n,t.bias),Mp(n)})}function uge(e,t){let n=Tp(e,t);function a(i,o){let l=je(e(i)),u=je(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function r(i,o,l){let u=n(i,o,3,`${l}/conv`),p=a(o,`${l}/bn`);return{conv:u,bn:p}}let s=Cp(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}}function RD(e,t,n,a){let{extractWeights:r,getRemainingWeights:s}=An(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=uge(r,i),p;if(t.withSeparableConvs){let[d,c,h,m,f,g,b,y,x]=a,v=t.isFirstLayerConv2d?o(d,c,3,\"conv0\"):u(d,c,\"conv0\"),I=u(c,h,\"conv1\"),N=u(h,m,\"conv2\"),C=u(m,f,\"conv3\"),_=u(f,g,\"conv4\"),F=u(g,b,\"conv5\"),D=y?u(b,y,\"conv6\"):void 0,$=x?u(y,x,\"conv7\"):void 0,S=o(x||y||b,5*n,1,\"conv8\");p={conv0:v,conv1:I,conv2:N,conv3:C,conv4:_,conv5:F,conv6:D,conv7:$,conv8:S}}else{let[d,c,h,m,f,g,b,y,x]=a,v=l(d,c,\"conv0\"),I=l(c,h,\"conv1\"),N=l(h,m,\"conv2\"),C=l(m,f,\"conv3\"),_=l(f,g,\"conv4\"),F=l(g,b,\"conv5\"),D=l(b,y,\"conv6\"),$=l(y,x,\"conv7\"),S=o(x,5*n,1,\"conv8\");p={conv0:v,conv1:I,conv2:N,conv3:C,conv4:_,conv5:F,conv6:D,conv7:$,conv8:S}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:p,paramMappings:i}}function pge(e,t){let n=sa(e,t);function a(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function r(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function s(o){let l=r(`${o}/conv`),u=a(`${o}/bn`);return{conv:l,bn:u}}let i=Ep(n);return{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function MD(e,t){let n=[],{extractConvParams:a,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}=pge(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?a(\"conv0\"):s(\"conv0\"),conv1:s(\"conv1\"),conv2:s(\"conv2\"),conv3:s(\"conv3\"),conv4:s(\"conv4\"),conv5:s(\"conv5\"),conv6:o>7?s(\"conv6\"):void 0,conv7:o>8?s(\"conv7\"):void 0,conv8:a(\"conv8\")}}else i={conv0:r(\"conv0\"),conv1:r(\"conv1\"),conv2:r(\"conv2\"),conv3:r(\"conv3\"),conv4:r(\"conv4\"),conv5:r(\"conv5\"),conv6:r(\"conv6\"),conv7:r(\"conv7\"),conv8:a(\"conv8\")};return _n(e,n),{params:i,paramMappings:n}}var yr=class{constructor({inputSize:t,scoreThreshold:n}={}){this._name=\"TinyYolov2Options\";if(this._inputSize=t||416,this._scoreThreshold=n||.5,typeof this._inputSize!=\"number\"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!=\"number\"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}};var mg=class mg extends fn{constructor(t){super(\"TinyYolov2\"),DD(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let a=Br(t,n.conv0);return a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv1),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv2),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv3),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv4),a=Dt(a,[2,2],[2,2],\"same\"),a=Br(a,n.conv5),a=Dt(a,[2,2],[1,1],\"same\"),a=Br(a,n.conv6),a=Br(a,n.conv7),il(a,n.conv8,\"valid\",!1)}runMobilenet(t,n){let a=this.config.isFirstLayerConv2d?Mp(il(t,n.conv0,\"valid\",!1)):Vr(t,n.conv0);return a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv1),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv2),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv3),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv4),a=Dt(a,[2,2],[2,2],\"same\"),a=Vr(a,n.conv5),a=Dt(a,[2,2],[1,1],\"same\"),a=n.conv6?Vr(a,n.conv6):a,a=n.conv7?Vr(a,n.conv7):a,il(a,n.conv8,\"valid\",!1)}forwardInput(t,n){let{params:a}=this;if(!a)throw new Error(\"TinyYolov2 - load model before inference\");return O(()=>{let r=re(t.toBatchTensor(n,!1),\"float32\");return r=this.config.meanRgb?br(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,a):this.runTinyYolov2(r,a)})}async forward(t,n){return this.forwardInput(await vt(t),n)}async detect(t,n={}){let{inputSize:a,scoreThreshold:r}=new yr(n),s=await vt(t),i=await this.forwardInput(s,a),o=O(()=>dt(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},u=await this.extractBoxes(o,s.getReshapedInputDimensions(0),r);i.dispose(),o.dispose();let p=u.map(g=>g.box),d=u.map(g=>g.score),c=u.map(g=>g.classScore),h=u.map(g=>this.config.classes[g.label]);return U$(p.map(g=>g.rescale(a)),d,this.config.iouThreshold,!0).map(g=>new yp(d[g],c[g],h[g],p[g],l))}getDefaultModelName(){return\"\"}extractParamsFromWeightMap(t){return MD(t,this.config)}extractParams(t){let n=this.config.filterSizes||mg.DEFAULT_FILTER_SIZES,a=n?n.length:void 0;if(a!==7&&a!==8&&a!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${a} filterSizes in config`);return RD(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,a){let{width:r,height:s}=n,i=Math.max(r,s),o=i/r,l=i/s,u=t.shape[1],p=this.config.anchors.length,[d,c,h]=O(()=>{let b=t.reshape([u,u,p,this.boxEncodingSize]),y=b.slice([0,0,0,0],[u,u,p,4]),x=b.slice([0,0,0,4],[u,u,p,1]),v=this.withClassScores?qa(b.slice([0,0,0,5],[u,u,p,this.config.classes.length]),3):xe(0);return[y,x,v]}),m=[],f=await c.array(),g=await d.array();for(let b=0;b<u;b++)for(let y=0;y<u;y++)for(let x=0;x<p;x++){let v=qf(f[b][y][x][0]);if(!a||v>a){let I=(y+qf(g[b][y][x][0]))/u*o,N=(b+qf(g[b][y][x][1]))/u*l,C=Math.exp(g[b][y][x][2])*this.config.anchors[x].x/u*o,_=Math.exp(g[b][y][x][3])*this.config.anchors[x].y/u*l,F=I-C/2,D=N-_/2,$={row:b,col:y,anchor:x},{classScore:S,label:M}=this.withClassScores?await this.extractPredictedClass(h,$):{classScore:1,label:0};m.push({box:new bp(F,D,F+C,D+_),score:v,classScore:v*S,label:M,...$})}}return d.dispose(),c.dispose(),h.dispose(),m}async extractPredictedClass(t,n){let{row:a,col:r,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[a][r][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};mg.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Op=mg;var Pp=class extends Op{constructor(t=!0){let n={withSeparableConvs:t,iouThreshold:CD,classes:[\"face\"],...t?{anchors:_D,meanRgb:AD}:{anchors:ED,withClassScores:!0}};super(n)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(r=>new Ft(r.score,r.relativeBox,{width:r.imageWidth,height:r.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?$D:FD}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};function BEe(e,t=!0){let n=new Pp(t);return n.extractWeights(e),n}var fg=class extends yr{constructor(){super(...arguments);this._name=\"TinyFaceDetectorOptions\"}};var Oa=class{async then(t){return t(await this.run())}async run(){throw new Error(\"ComposableTask - run is not implemented\")}};async function ul(e,t,n,a,r=({alignedRect:s})=>s){let s=e.map(l=>Fp(l)?r(l):l.detection),i=a||(t instanceof Ce?await Ld(t,s):await Pd(t,s)),o=await n(i);return i.forEach(l=>l instanceof Ce&&l.dispose()),o}async function Lp(e,t,n,a,r){return ul([e],t,async s=>n(s[0]),a,r)}var OD=.4,PD=[new He(1.603231,2.094468),new He(6.041143,7.080126),new He(2.882459,3.518061),new He(4.266906,5.178857),new He(9.041765,10.66308)],LD=[117.001,114.697,97.404];var zp=class extends Op{constructor(){let t={withSeparableConvs:!0,iouThreshold:OD,classes:[\"face\"],anchors:PD,meanRgb:LD,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(t)}get anchors(){return this.config.anchors}async locateFaces(t,n){return(await this.detect(t,n)).map(r=>new Ft(r.score,r.relativeBox,{width:r.imageWidth,height:r.imageHeight}))}getDefaultModelName(){return\"tiny_face_detector_model\"}extractParamsFromWeightMap(t){return super.extractParamsFromWeightMap(t)}};var rt={ssdMobilenetv1:new ll,tinyFaceDetector:new zp,tinyYolov2:new Pp,faceLandmark68Net:new Dp,faceLandmark68TinyNet:new cg,faceRecognitionNet:new Rp,faceExpressionNet:new sg,ageGenderNet:new ug},cge=(e,t)=>rt.ssdMobilenetv1.locateFaces(e,t),b_e=(e,t)=>rt.tinyFaceDetector.locateFaces(e,t),y_e=(e,t)=>rt.tinyYolov2.locateFaces(e,t),dge=e=>rt.faceLandmark68Net.detectLandmarks(e),x_e=e=>rt.faceLandmark68TinyNet.detectLandmarks(e),v_e=e=>rt.faceRecognitionNet.computeFaceDescriptor(e),w_e=e=>rt.faceExpressionNet.predictExpressions(e),k_e=e=>rt.ageGenderNet.predictAgeAndGender(e),hge=e=>rt.ssdMobilenetv1.load(e),I_e=e=>rt.tinyFaceDetector.load(e),S_e=e=>rt.tinyYolov2.load(e),N_e=e=>rt.faceLandmark68Net.load(e),T_e=e=>rt.faceLandmark68TinyNet.load(e),C_e=e=>rt.faceRecognitionNet.load(e),E_e=e=>rt.faceExpressionNet.load(e),__e=e=>rt.ageGenderNet.load(e),A_e=hge,F_e=cge,$_e=dge;var gg=class extends Oa{constructor(n,a,r){super();this.parentTask=n;this.input=a;this.extractedFaces=r}},pl=class extends gg{async run(){let t=await this.parentTask,n=await ul(t,this.input,async a=>Promise.all(a.map(r=>rt.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return t.map((a,r)=>Nk(a,n[r]))}withAgeAndGender(){return new dl(this,this.input)}},cl=class extends gg{async run(){let t=await this.parentTask;if(!t)return;let n=await Lp(t,this.input,a=>rt.faceExpressionNet.predictExpressions(a),this.extractedFaces);return Nk(t,n)}withAgeAndGender(){return new hl(this,this.input)}},Ps=class extends pl{withAgeAndGender(){return new zs(this,this.input)}withFaceDescriptors(){return new Bs(this,this.input)}},Ls=class extends cl{withAgeAndGender(){return new Ws(this,this.input)}withFaceDescriptor(){return new Vs(this,this.input)}};var bg=class extends Oa{constructor(n,a,r){super();this.parentTask=n;this.input=a;this.extractedFaces=r}},dl=class extends bg{async run(){let t=await this.parentTask,n=await ul(t,this.input,async a=>Promise.all(a.map(r=>rt.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return t.map((a,r)=>{let{age:s,gender:i,genderProbability:o}=n[r];return Fk($k(a,i,o),s)})}withFaceExpressions(){return new pl(this,this.input)}},hl=class extends bg{async run(){let t=await this.parentTask;if(!t)return;let{age:n,gender:a,genderProbability:r}=await Lp(t,this.input,s=>rt.ageGenderNet.predictAgeAndGender(s),this.extractedFaces);return Fk($k(t,a,r),n)}withFaceExpressions(){return new cl(this,this.input)}},zs=class extends dl{withFaceExpressions(){return new Ps(this,this.input)}withFaceDescriptors(){return new Bs(this,this.input)}},Ws=class extends hl{withFaceExpressions(){return new Ls(this,this.input)}withFaceDescriptor(){return new Vs(this,this.input)}};var yg=class extends Oa{constructor(n,a){super();this.parentTask=n;this.input=a}},Bs=class extends yg{async run(){let t=await this.parentTask;return(await ul(t,this.input,a=>Promise.all(a.map(r=>rt.faceRecognitionNet.computeFaceDescriptor(r))),null,a=>a.landmarks.align(null,{useDlibAlignment:!0}))).map((a,r)=>Ak(t[r],a))}withFaceExpressions(){return new Ps(this,this.input)}withAgeAndGender(){return new zs(this,this.input)}},Vs=class extends yg{async run(){let t=await this.parentTask;if(!t)return;let n=await Lp(t,this.input,a=>rt.faceRecognitionNet.computeFaceDescriptor(a),null,a=>a.landmarks.align(null,{useDlibAlignment:!0}));return Ak(t,n)}withFaceExpressions(){return new Ls(this,this.input)}withAgeAndGender(){return new Ws(this,this.input)}};var xg=class extends Oa{constructor(n,a,r){super();this.parentTask=n;this.input=a;this.useTinyLandmarkNet=r}get landmarkNet(){return this.useTinyLandmarkNet?rt.faceLandmark68TinyNet:rt.faceLandmark68Net}},vg=class extends xg{async run(){let t=await this.parentTask,n=t.map(i=>i.detection),a=this.input instanceof Ce?await Ld(this.input,n):await Pd(this.input,n),r=await Promise.all(a.map(i=>this.landmarkNet.detectLandmarks(i)));return a.forEach(i=>i instanceof Ce&&i.dispose()),t.filter((i,o)=>r[o]).map((i,o)=>Vd(i,r[o]))}withFaceExpressions(){return new Ps(this,this.input)}withAgeAndGender(){return new zs(this,this.input)}withFaceDescriptors(){return new Bs(this,this.input)}},wg=class extends xg{async run(){let t=await this.parentTask;if(!t)return;let{detection:n}=t,a=this.input instanceof Ce?await Ld(this.input,[n]):await Pd(this.input,[n]),r=await this.landmarkNet.detectLandmarks(a[0]);return a.forEach(s=>s instanceof Ce&&s.dispose()),Vd(t,r)}withFaceExpressions(){return new Ls(this,this.input)}withAgeAndGender(){return new Ws(this,this.input)}withFaceDescriptor(){return new Vs(this,this.input)}};var kg=class extends Oa{constructor(n,a=new Ma){super();this.input=n;this.options=a}},Gd=class extends kg{async run(){let{input:t,options:n}=this,a;if(n instanceof fg)a=rt.tinyFaceDetector.locateFaces(t,n);else if(n instanceof Ma)a=rt.ssdMobilenetv1.locateFaces(t,n);else if(n instanceof yr)a=rt.tinyYolov2.locateFaces(t,n);else throw new Error(\"detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options\");return a}runAndExtendWithFaceDetections(){return new Promise((t,n)=>{this.run().then(a=>t(a.map(r=>wp({},r)))).catch(a=>n(a))})}withFaceLandmarks(t=!1){return new vg(this.runAndExtendWithFaceDetections(),this.input,t)}withFaceExpressions(){return new pl(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new dl(this.runAndExtendWithFaceDetections(),this.input)}},Ig=class extends kg{async run(){let t=await new Gd(this.input,this.options),n=t[0];return t.forEach(a=>{a.score>n.score&&(n=a)}),n}runAndExtendWithFaceDetection(){return new Promise(async t=>{let n=await this.run();t(n?wp({},n):void 0)})}withFaceLandmarks(t=!1){return new wg(this.runAndExtendWithFaceDetection(),this.input,t)}withFaceExpressions(){return new cl(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new hl(this.runAndExtendWithFaceDetection(),this.input)}};function _Ae(e,t=new Ma){return new Ig(e,t)}function Dk(e,t=new Ma){return new Gd(e,t)}async function mge(e,t){return Dk(e,new Ma(t?{minConfidence:t}:{})).withFaceLandmarks().withFaceDescriptors()}async function MAe(e,t={}){return Dk(e,new yr(t)).withFaceLandmarks().withFaceDescriptors()}var OAe=mge;function zD(e,t){if(e.length!==t.length)throw new Error(\"euclideanDistance: arr1.length !== arr2.length\");let n=Array.from(e),a=Array.from(t);return Math.sqrt(n.map((r,s)=>r-a[s]).reduce((r,s)=>r+s*s,0))}var WD=class e{constructor(t,n=.6){this._distanceThreshold=n;let a=Array.isArray(t)?t:[t];if(!a.length)throw new Error(\"FaceRecognizer.constructor - expected atleast one input\");let r=1,s=()=>`person ${r++}`;this._labeledDescriptors=a.map(i=>{if(i instanceof rl)return i;if(i instanceof Float32Array)return new rl(s(),[i]);if(i.descriptor&&i.descriptor instanceof Float32Array)return new rl(s(),[i.descriptor]);throw new Error(\"FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>\")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(t,n){return n.map(a=>zD(a,t)).reduce((a,r)=>a+r,0)/(n.length||1)}matchDescriptor(t){return this.labeledDescriptors.map(({descriptors:n,label:a})=>new Dd(a,this.computeMeanDistance(t,n))).reduce((n,a)=>n.distance<a.distance?n:a)}findBestMatch(t){let n=this.matchDescriptor(t);return n.distance<this._distanceThreshold?n:new Dd(\"unknown\",n.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map(t=>t.toJSON())}}static fromJSON(t){let n=t.labeledDescriptors.map(a=>rl.fromJSON(a));return new e(n,t.distanceThreshold)}};function eFe(e){let t=new zp;return t.extractWeights(e),t}function fge(e,t){let{width:n,height:a}=new aa(t.width,t.height);if(n<=0||a<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:a})}`);if(Array.isArray(e))return e.map(r=>fge(r,{width:n,height:a}));if(Fp(e)){let r=e.detection.forSize(n,a),s=e.unshiftedLandmarks.forSize(r.box.width,r.box.height);return Vd(wp(e,r),s)}return zr(e)?wp(e,e.detection.forSize(n,a)):e instanceof ka||e instanceof Ft?e.forSize(n,a):e}var cFe=oD;\n//# sourceMappingURL=face-api.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZsYWRtYW5kaWMvZmFjZS1hcGkvZGlzdC9mYWNlLWFwaS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFdBQVcsS0FBMkIsQ0FBQyxvRkFBTyxDQUFDLENBQWdHLGNBQWMsR0FBRyxJQUEyQixRQUFRLG9GQUFPLHVCQUF1QiwyREFBMkQsRUFBRSxlQUFlLHVCQUF1Qix1QkFBdUIsR0FBRyxVQUFVLE9BQU8sNGxSQUE0bFIsRUFBRSxtTUFBbU0sV0FBVyxtQ0FBbUMsdUJBQXVCLHVCQUF1QixFQUFFLGdCQUFnQixnR0FBZ0csbURBQW1ELEVBQUUsU0FBUyxvQ0FBb0MseUNBQXlDLHNCQUFzQixzQkFBc0IsWUFBWSxXQUFXLElBQUksdTZCQUF1NkIsVUFBVSxVQUFVLGtCQUFrQiw2Q0FBNkMsdUVBQXVFLFNBQVMsRUFBRSxjQUFjLDZCQUE2QixXQUFXLFFBQVEsTUFBTSxnQkFBZ0IsVUFBVSxrS0FBa0ssWUFBWSxnQkFBZ0IseUJBQXlCLE1BQU0sZ0JBQWdCLGlCQUFpQixLQUFLLGtCQUFrQixtQkFBbUIsMENBQTBDLGVBQWUsa0JBQWtCLG9CQUFvQixhQUFhLGVBQWUsa0JBQWtCLDRDQUE0Qyx3RUFBd0UsbUZBQW1GLE1BQU0sdURBQXVELDRDQUE0Qyw0QkFBNEIsV0FBVyxNQUFNLDhEQUE4RCxRQUFRLGlCQUFpQixzQkFBc0IsOEJBQThCLHNCQUFzQixlQUFlLGdCQUFnQiw0R0FBNEcsY0FBYyxvREFBb0QsU0FBUyxjQUFjLFVBQVUsV0FBVyxRQUFRLGNBQWMsU0FBUyxZQUFZLFlBQVksMEJBQTBCLGNBQWMsa0JBQWtCLHVCQUF1QiwwQkFBMEIs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RSxxRUFBcUUsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGtEQUFrRCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLG1EQUFtRCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLG1EQUFtRCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGtEQUFrRCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLGtEQUFrRCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDREQUE0RCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLDhDQUE4QywrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxFQUFFLG1EQUFtRCwrQkFBK0IsRUFBRSwrQkFBK0IsVUFBVSxxREFBcUQsRUFBRSxRQUFRLE9BQU8sWUFBWSxFQUFFLFNBQVMsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsc0RBQXNELCtCQUErQixFQUFFLDBDQUEwQyxFQUFFLDBDQUEwQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELGtDQUFrQyxFQUFFLGtDQUFrQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLDZEQUE2RCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLDZEQUE2RCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixFQUFFLG1DQUFtQyxVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsa0RBQWtELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsaURBQWlELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsK0NBQStDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUscURBQXFELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsOENBQThDLCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsb0RBQW9ELCtCQUErQixVQUFVLDBEQUEwRCxFQUFFLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsbURBQW1ELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLEVBQUUsZ0RBQWdELCtCQUErQixVQUFVLHFEQUFxRCxFQUFFLFFBQVEsT0FBTyxZQUFZLEVBQUUsU0FBUyx1REFBdUQseUNBQXlDLEVBQUUsNENBQTRDLFVBQVUsd0RBQXdELEVBQUUsRUFBRSxnREFBZ0Qsa0NBQWtDLEVBQUUsRUFBRSw4Q0FBOEMsa0NBQWtDLEVBQUUsa0NBQWtDLEVBQUUsRUFBRSw2Q0FBNkMsNENBQTRDLEVBQUUsRUFBRSw2Q0FBNkMsb0NBQW9DLFVBQVUscURBQXFELEVBQUUsbURBQW1ELEVBQUUsbURBQW1ELEVBQUUsRUFBRSw0Q0FBNEMsb0NBQW9DLFVBQVUscURBQXFELEVBQUUsRUFBRSxxREFBcUQsb0NBQW9DLFVBQVUscURBQXFELEVBQUUsRUFBRSxxREFBcUQsa0NBQWtDLFVBQVUseUNBQXlDLEVBQUUsd0RBQXdELEVBQUUscURBQXFELEVBQUUsNERBQTRELEVBQUUsNEVBQTRFLEVBQUUscURBQXFELEVBQUUsRUFBRSwwREFBMEQsMkNBQTJDLEVBQUUsbUNBQW1DLEVBQUUsb0NBQW9DLEVBQUUsb0NBQW9DLFVBQVUscURBQXFELEVBQUUsRUFBRSx5REFBeUQsMkNBQTJDLEVBQUUsbUNBQW1DLEVBQUUsb0NBQW9DLFVBQVUseURBQXlELEVBQUUsRUFBRSwyREFBMkQsMkNBQTJDLEVBQUUsdUNBQXVDLEVBQUUsb0NBQW9DLFVBQVUseUNBQXlDLEVBQUUsd0RBQXdELEVBQUUsRUFBRSw0REFBNEQsMkNBQTJDLEVBQUUsdUNBQXVDLEVBQUUsb0NBQW9DLEVBQUUsb0NBQW9DLFVBQVUscUNBQXFDLEVBQUUsRUFBRSwyREFBMkQsMkNBQTJDLEVBQUUsb0NBQW9DLFVBQVUseUNBQXlDLEVBQUUsdUZBQXVGLEVBQUUsRUFBRSwwREFBMEQsMkNBQTJDLEVBQUUsb0NBQW9DLEVBQUUsdUNBQXVDLEVBQUUsb0NBQW9DLFVBQVUscUNBQXFDLEVBQUUsRUFBRSx5REFBeUQsMkNBQTJDLEVBQUUsb0NBQW9DLEVBQUUsRUFBRSwwREFBMEQsMkNBQTJDLEVBQUUsRUFBRSxtREFBbUQsa0NBQWtDLEVBQUUseUNBQXlDLFVBQVUsbURBQW1ELEVBQUUsbURBQW1ELEVBQUUsRUFBRSwwQ0FBMEMsa0NBQWtDLEVBQUUseUNBQXlDLFVBQVUsbURBQW1ELEVBQUUsbURBQW1ELEVBQUUsRUFBRSxzREFBc0QseUNBQXlDLFVBQVUsc0NBQXNDLEVBQUUsc0NBQXNDLEVBQUUsRUFBRSw2Q0FBNkMseUNBQXlDLFVBQVUsc0NBQXNDLEVBQUUsc0NBQXNDLEVBQUUsRUFBRSx5REFBeUQsb0NBQW9DLEVBQUUsdUNBQXVDLEVBQUUseUNBQXlDLFVBQVUsd0RBQXdELEVBQUUsRUFBRSwyREFBMkQsb0NBQW9DLEVBQUUsdUNBQXVDLEVBQUUseUNBQXlDLEVBQUUseUNBQXlDLFVBQVUsd0RBQXdELEVBQUUsRUFBRSx3REFBd0QsMENBQTBDLEVBQUUsdUNBQXVDLEVBQUUseUNBQXlDLFVBQVUsd0RBQXdELEVBQUUsRUFBRSx5REFBeUQsMENBQTBDLEVBQUUsbUNBQW1DLEVBQUUseUNBQXlDLFVBQVUsd0RBQXdE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b2R0dW5lLy4vbm9kZV9tb2R1bGVzL0B2bGFkbWFuZGljL2ZhY2UtYXBpL2Rpc3QvZmFjZS1hcGkuZXNtLmpzP2E2YzEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgRmFjZS1BUElcbiAgaG9tZXBhZ2U6IDxodHRwczovL2dpdGh1Yi5jb20vdmxhZG1hbmRpYy9mYWNlLWFwaT5cbiAgYXV0aG9yOiA8aHR0cHM6Ly9naXRodWIuY29tL3ZsYWRtYW5kaWM+J1xuKi9cblxudmFyIHZSPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgd1I9KGU9PnR5cGVvZiByZXF1aXJlIT1cInVuZGVmaW5lZFwiP3JlcXVpcmU6dHlwZW9mIFByb3h5IT1cInVuZGVmaW5lZFwiP25ldyBQcm94eShlLHtnZXQ6KHQsbik9Pih0eXBlb2YgcmVxdWlyZSE9XCJ1bmRlZmluZWRcIj9yZXF1aXJlOnQpW25dfSk6ZSkoZnVuY3Rpb24oZSl7aWYodHlwZW9mIHJlcXVpcmUhPVwidW5kZWZpbmVkXCIpcmV0dXJuIHJlcXVpcmUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3Rocm93IEVycm9yKCdEeW5hbWljIHJlcXVpcmUgb2YgXCInK2UrJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnKX0pO3ZhciBheD0oZSx0KT0+e2Zvcih2YXIgbiBpbiB0KXZSKGUsbix7Z2V0OnRbbl0sZW51bWVyYWJsZTohMH0pfTt2YXIgUGU9e307YXgoUGUse0FiczooKT0+WWwsQWNvczooKT0+TmksQWNvc2g6KCk9PlRpLEFkYWRlbHRhT3B0aW1pemVyOigpPT5WdyxBZGFncmFkT3B0aW1pemVyOigpPT5VdyxBZGFtT3B0aW1pemVyOigpPT5HdyxBZGFtYXhPcHRpbWl6ZXI6KCk9Pkh3LEFkZDooKT0+dnMsQWRkTjooKT0+Q2ksQWxsOigpPT5abCxBbnk6KCk9PkpsLEFyZ01heDooKT0+UWwsQXJnTWluOigpPT5ldSxBc2luOigpPT5FaSxBc2luaDooKT0+X2ksQXRhbjooKT0+QWksQXRhbjI6KCk9PiRpLEF0YW5oOigpPT5GaSxBdmdQb29sOigpPT5EaSxBdmdQb29sM0Q6KCk9PnR1LEF2Z1Bvb2wzREdyYWQ6KCk9PlJjLEF2Z1Bvb2xHcmFkOigpPT5EYyxCYWNrZW5kV2FzbTooKT0+TCQsQmF0Y2hNYXRNdWw6KCk9PlJpLEJhdGNoVG9TcGFjZU5EOigpPT5udSxCaW5jb3VudDooKT0+YXUsQml0d2lzZUFuZDooKT0+cnUsQnJvYWRjYXN0QXJnczooKT0+TWMsQnJvYWRjYXN0VG86KCk9PkhTLENhbGxiYWNrOigpPT5QQyxDYWxsYmFja0xpc3Q6KCk9PkEyLENhc3Q6KCk9Pk1pLENlaWw6KCk9Pk9pLENsaXBCeVZhbHVlOigpPT53cyxDb21wbGV4OigpPT53bSxDb21wbGV4QWJzOigpPT5PYyxDb25jYXQ6KCk9PnN1LENvbnYyRDooKT0+UGksQ29udjJEQmFja3Byb3BGaWx0ZXI6KCk9PmttLENvbnYyREJhY2twcm9wSW5wdXQ6KCk9PkxpLENvbnYzRDooKT0+emksQ29udjNEQmFja3Byb3BGaWx0ZXJWMjooKT0+aXUsQ29udjNEQmFja3Byb3BJbnB1dFYyOigpPT5vdSxDb3M6KCk9PldpLENvc2g6KCk9PkJpLENyb3BBbmRSZXNpemU6KCk9PnV1LEN1bXByb2Q6KCk9Pmx1LEN1bXN1bTooKT0+VmksQ3VzdG9tQ2FsbGJhY2s6KCk9PiQyLERhdGFTdG9yYWdlOigpPT55bSxEZW5zZUJpbmNvdW50OigpPT5QYyxEZXB0aFRvU3BhY2U6KCk9PnB1LERlcHRod2lzZUNvbnYyZE5hdGl2ZTooKT0+VWksRGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXI6KCk9PkltLERlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXQ6KCk9PlNtLERpYWc6KCk9PkxjLERpbGF0aW9uMkQ6KCk9PkdpLERpbGF0aW9uMkRCYWNrcHJvcEZpbHRlcjooKT0+UmwsRGlsYXRpb24yREJhY2twcm9wSW5wdXQ6KCk9PkRsLERyYXc6KCk9Pk5tLEVOVjooKT0+VHYsRWFybHlTdG9wcGluZzooKT0+TEMsRWluc3VtOigpPT5UbSxFbHU6KCk9PmppLEVsdUdyYWQ6KCk9PmN1LEVudmlyb25tZW50OigpPT5VUyxFcXVhbDooKT0+ZHUsRXJmOigpPT5xaSxFeHA6KCk9PktpLEV4cGFuZERpbXM6KCk9Pmh1LEV4cG0xOigpPT5YaSxGRlQ6KCk9PkNtLEZpbGw6KCk9PnpjLEZsaXBMZWZ0UmlnaHQ6KCk9Pm11LEZsb29yOigpPT5ZaSxGbG9vckRpdjooKT0+WmksRnJvbVBpeGVsczooKT0+SGgsRnVzZWRCYXRjaE5vcm06KCk9PkppLEZ1c2VkQ29udjJEOigpPT5vaSxGdXNlZERlcHRod2lzZUNvbnYyRDooKT0+bGksR1BHUFVDb250ZXh0OigpPT5XaCxHYXRoZXJOZDooKT0+Z3UsR2F0aGVyVjI6KCk9PmZ1LEdyYXBoTW9kZWw6KCk9PkYxLEdyZWF0ZXI6KCk9PmJ1LEdyZWF0ZXJFcXVhbDooKT0+UWksSGlzdG9yeTooKT0+RjIsSUZGVDooKT0+RW0sSWRlbnRpdHk6KCk9PmVvLEltYWc6KCk9Pl9tLElucHV0U3BlYzooKT0+enQsSXNGaW5pdGU6KCk9PnRvLElzSW5mOigpPT5ubyxJc05hbjooKT0+YW8sS2VybmVsQmFja2VuZDooKT0+RmMsTFJOOigpPT5vbyxMUk5HcmFkOigpPT5TdSxMYXllclZhcmlhYmxlOigpPT5rMixMYXllcnNNb2RlbDooKT0+RXIsTGVha3lSZWx1OigpPT5ybyxMZXNzOigpPT55dSxMZXNzRXF1YWw6KCk9Pnh1LExpblNwYWNlOigpPT52dSxMb2c6KCk9PnNvLExvZzFwOigpPT5pbyxMb2dTb2Z0bWF4OigpPT5xUyxMb2dpY2FsQW5kOigpPT53dSxMb2dpY2FsTm90OigpPT5rdSxMb2dpY2FsT3I6KCk9Pkl1LExvZ2ljYWxYb3I6KCk9PmpTLExvd2VyQm91bmQ6KCk9PmRNLE1hdGhCYWNrZW5kQ1BVOigpPT5SMSxNYXRoQmFja2VuZFdlYkdMOigpPT5sayxNYXRyaXhCYW5kUGFydDooKT0+aE0sTWF4OigpPT5sbyxNYXhQb29sOigpPT5wbyxNYXhQb29sM0Q6KCk9Pk51LE1heFBvb2wzREdyYWQ6KCk9PkJjLE1heFBvb2xHcmFkOigpPT5XYyxNYXhQb29sV2l0aEFyZ21heDooKT0+VmMsTWF4aW11bTooKT0+dW8sTWVhbjooKT0+Y28sTWluOigpPT5obyxNaW5pbXVtOigpPT5tbyxNaXJyb3JQYWQ6KCk9PmZvLE1vZDooKT0+Z28sTW9tZW50dW1PcHRpbWl6ZXI6KCk9Pmp3LE11bHRpbm9taWFsOigpPT5UdSxNdWx0aXBseTooKT0+Ym8sTmVnOigpPT5DdSxOb25NYXhTdXBwcmVzc2lvblYzOigpPT5fdSxOb25NYXhTdXBwcmVzc2lvblY0OigpPT5BdSxOb25NYXhTdXBwcmVzc2lvblY1OigpPT5GdSxOb3RFcXVhbDooKT0+RXUsT1BfU0NPUEVfU1VGRklYOigpPT5GdixPbmVIb3Q6KCk9PnlvLE9uZXNMaWtlOigpPT4kdSxPcHRpbWl6ZXI6KCk9PlJyLE9wdGltaXplckNvbnN0cnVjdG9yczooKT0+dDIsUGFjazooKT0+RHUsUGFkVjI6KCk9PnhvLFBvb2w6KCk9Pm1NLFBvdzooKT0+dm8sUHJlbHU6KCk9PndvLFByb2Q6KCk9PmtvLFJNU1Byb3BPcHRpbWl6ZXI6KCk9PnF3LFJOTjooKT0+TXIsUmFnZ2VkR2F0aGVyOigpPT5BbSxSYWdnZWRSYW5nZTooKT0+Rm0sUmFnZ2VkVGVuc29yVG9UZW5zb3I6KCk9PiRtLFJhbmdlOigpPT5VYyxSYW5rOigpPT5reCxSZWFsOigpPT5EbSxSZWFsRGl2OigpPT5IaSxSZWNpcHJvY2FsOigpPT5JbyxSZWR1Y3Rpb246KCk9PmtuLFJlbHU6KCk9PlNvLFJlbHU2OigpPT5DbyxSZXNoYXBlOigpPT5SdSxSZXNpemVCaWxpbmVhcjooKT0+VG8sUmVzaXplQmlsaW5lYXJHcmFkOigpPT5PdSxSZXNpemVOZWFyZXN0TmVpZ2hib3I6KCk9Pk5vLFJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQ6KCk9Pk11LFJldmVyc2U6KCk9PkVvLFJvdGF0ZVdpdGhPZmZzZXQ6KCk9Plp1LFJvdW5kOigpPT5fbyxSc3FydDooKT0+QW8sU0dET3B0aW1pemVyOigpPT5mZixTY2F0dGVyTmQ6KCk9PlB1LFNlYXJjaFNvcnRlZDooKT0+enUsU2VsZWN0OigpPT5XdSxTZWx1OigpPT5GbyxTZXF1ZW50aWFsOigpPT5FZixTaWdtb2lkOigpPT5NbyxTaWduOigpPT5SbyxTaW46KCk9PiRvLFNpbmg6KCk9PkRvLFNsaWNlOigpPT5CdSxTb2Z0bWF4OigpPT56byxTb2Z0cGx1czooKT0+T28sU3BhY2VUb0JhdGNoTkQ6KCk9PlZ1LFNwYXJzZUZpbGxFbXB0eVJvd3M6KCk9PkdjLFNwYXJzZVJlc2hhcGU6KCk9Pkd1LFNwYXJzZVNlZ21lbnRNZWFuOigpPT5IYyxTcGFyc2VTZWdtZW50U3VtOigpPT5qYyxTcGFyc2VUb0RlbnNlOigpPT5IdSxTcGxpdFY6KCk9PlV1LFNxcnQ6KCk9PlBvLFNxdWFyZTooKT0+cWMsU3F1YXJlZERpZmZlcmVuY2U6KCk9PldvLFN0YXRpY1JlZ2V4UmVwbGFjZTooKT0+S2MsU3RlcDooKT0+SXMsU3RyaWRlZFNsaWNlOigpPT5qdSxTdHJpbmdOR3JhbXM6KCk9PlhjLFN0cmluZ1NwbGl0OigpPT5ZYyxTdHJpbmdUb0hhc2hCdWNrZXRGYXN0OigpPT5aYyxTdWI6KCk9PkJvLFN1bTooKT0+TG8sU3ltYm9saWNUZW5zb3I6KCk9PkhhLFRhbjooKT0+Vm8sVGFuaDooKT0+VW8sVGVuc29yOigpPT5DZSxUZW5zb3JCdWZmZXI6KCk9Pld0LFRlbnNvclNjYXR0ZXJVcGRhdGU6KCk9Pkx1LFRpbGU6KCk9PmtzLFRvcEs6KCk9PnF1LFRyYW5zZm9ybTooKT0+S3UsVHJhbnNwb3NlOigpPT5DcixVbmlxdWU6KCk9PkpjLFVucGFjazooKT0+WHUsVW5zb3J0ZWRTZWdtZW50U3VtOigpPT5RYyxVcHBlckJvdW5kOigpPT5mTSxWYXJpYWJsZTooKT0+b3MsWmVyb3NMaWtlOigpPT5ZdSxfRnVzZWRNYXRNdWw6KCk9PmlpLGFiczooKT0+THQsYWNvczooKT0+UHYsYWNvc2g6KCk9Pkx2LGFkZDooKT0+WCxhZGROOigpPT52TixhbGw6KCk9PkxtLGFueTooKT0+eWMsYXJnTWF4OigpPT5kaSxhcmdNaW46KCk9Pnp2LGFzaW46KCk9Pld2LGFzaW5oOigpPT5CdixhdGFuOigpPT5WdixhdGFuMjooKT0+VXYsYXRhbmg6KCk9Pkd2LGF2Z1Bvb2w6KCk9PnlhLGF2Z1Bvb2wzZDooKT0+anYsYmFja2VuZDooKT0+RHYsYmFja2VuZF91dGlsOigpPT5ULGJhc2ljTFNUTUNlbGw6KCk9PlNOLGJhdGNoTm9ybTooKT0+TnMsYmF0Y2hOb3JtMmQ6KCk9PnF2LGJhdGNoTm9ybTNkOigpPT5LdixiYXRjaE5vcm00ZDooKT0+WHYsYmF0Y2hUb1NwYWNlTkQ6KCk9PmlkLGJpbmNvdW50OigpPT5ZdixiaXR3aXNlQW5kOigpPT5OTixib29sZWFuTWFza0FzeW5jOigpPT5tVCxicm9hZGNhc3RBcmdzOigpPT5UTixicm9hZGNhc3RUbzooKT0+YWksYnJvYWRjYXN0X3V0aWw6KCk9Pkp1LGJyb3dzZXI6KCk9PnFvLGJ1ZmZlcjooKT0+T2UsY2FsbGJhY2tzOigpPT5kcSxjYXN0OigpPT5yZSxjZWlsOigpPT5adixjbGlwQnlWYWx1ZTooKT0+YW4sY2xvbmU6KCk9PnNyLGNvbXBsZXg6KCk9Pl9yLGNvbmNhdDooKT0+ZXQsY29uY2F0MWQ6KCk9Pkp2LGNvbmNhdDJkOigpPT5Rdixjb25jYXQzZDooKT0+ZXcsY29uY2F0NGQ6KCk9PnR3LGNvbnN0cmFpbnRzOigpPT5UMixjb252MWQ6KCk9PnptLGNvbnYyZDooKT0+JHQsY29udjJkVHJhbnNwb3NlOigpPT5XbSxjb252M2Q6KCk9PmF3LGNvbnYzZFRyYW5zcG9zZTooKT0+cncsY29weVJlZ2lzdGVyZWRLZXJuZWxzOigpPT54TSxjb3M6KCk9Pm9kLGNvc2g6KCk9PkJtLGNvc2luZVdpbmRvdzooKT0+cGYsY3VtcHJvZDooKT0+d2MsY3Vtc3VtOigpPT5WbSxjdXN0b21HcmFkOigpPT5wcixkYXRhOigpPT5sRSxkZW5zZUJpbmNvdW50OigpPT5YaCxkZXByZWNhdGlvbldhcm46KCk9PiR2LGRlcHRoVG9TcGFjZTooKT0+c3csZGVwdGh3aXNlQ29udjJkOigpPT5UcyxkZXJlZ2lzdGVyT3A6KCk9PmZxLGRldmljZV91dGlsOigpPT5hZCxkaWFnOigpPT5FTixkaWxhdGlvbjJkOigpPT5pdyxkaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5nczooKT0+Wk0sZGlzcG9zZTooKT0+RWUsZGlzcG9zZVZhcmlhYmxlczooKT0+Sk0sZGl2OigpPT5oZSxkaXZOb05hbjooKT0+b3csZG90OigpPT5sdyxkcm9wb3V0OigpPT5QdyxlaW5zdW06KCk9PlpzLGVsdTooKT0+UXUsZW5hYmxlRGVidWdNb2RlOigpPT5ZTSxlbmFibGVQcm9kTW9kZTooKT0+WE0sZW5jbG9zaW5nUG93ZXJPZlR3bzooKT0+THcsZW5naW5lOigpPT5UYSxlbnN1cmVTaGFwZTooKT0+QU4sZW52OigpPT5HLGVxdWFsOigpPT5KbixlcmY6KCk9PlVtLGV1Y2xpZGVhbk5vcm06KCk9PmN3LGV4cDooKT0+ZG4sZXhwYW5kRGltczooKT0+R3QsZXhwbTE6KCk9PmR3LGV5ZTooKT0+R20sZmZ0OigpPT5iZCxmaWxsOigpPT55bixmaW5kQmFja2VuZDooKT0+ck8sZmluZEJhY2tlbmRGYWN0b3J5OigpPT5zTyxmbG9vcjooKT0+dHAsZmxvb3JEaXY6KCk9PlBtLGZvcmNlSGFsZkZsb2F0OigpPT4kQSxmdXNlZDooKT0+VmwsZ2F0aGVyOigpPT5ucCxnYXRoZXJORDooKT0+eVQsZ2F0aGVyX3V0aWw6KCk9Pll3LGdldEJhY2tlbmQ6KCk9Pm9OLGdldEdyYWRpZW50OigpPT52eCxnZXRLZXJuZWw6KCk9PmZjLGdldEtlcm5lbHNGb3JCYWNrZW5kOigpPT5qaCxnZXRUaHJlYWRzQ291bnQ6KCk9Pl9mZSxncGdwdV91dGlsOigpPT51QSxncmFkOigpPT5QMyxncmFkczooKT0+TDMsZ3JlYXRlcjooKT0+Q24sZ3JlYXRlckVxdWFsOigpPT4kcixpZmZ0OigpPT5CbCxpbWFnOigpPT5sZCxpbWFnZTooKT0+Wm4saW5Ub3BLQXN5bmM6KCk9PnhULGluaXRpYWxpemVyczooKT0+QzIsaW5wdXQ6KCk9PmoyLGlvOigpPT5qdCxpcmZmdDooKT0+YWYsaXNGaW5pdGU6KCk9Pmh3LGlzSW5mOigpPT5tdyxpc05hTjooKT0+Zncsa2VlcDooKT0+SHQsa2VybmVsX2ltcGxzOigpPT5tcixsYXllcnM6KCk9PkUyLGxlYWt5UmVsdTooKT0+dWQsbGVzczooKT0+UGwsbGVzc0VxdWFsOigpPT5DcyxsaW5hbGc6KCk9PkJ3LGxpbnNwYWNlOigpPT5NTixsb2FkR3JhcGhNb2RlbDooKT0+dzUsbG9hZEdyYXBoTW9kZWxTeW5jOigpPT5rNSxsb2FkTGF5ZXJzTW9kZWw6KCk9Pm9qLGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOigpPT5ndyxsb2c6KCk9PlFuLGxvZzFwOigpPT5wZCxsb2dTaWdtb2lkOigpPT5idyxsb2dTb2Z0bWF4OigpPT5qbSxsb2dTdW1FeHA6KCk9PmNkLGxvZ2ljYWxBbmQ6KCk9Pl9hLGxvZ2ljYWxOb3Q6KCk9PmRkLGxvZ2ljYWxPcjooKT0+cW0sbG9naWNhbFhvcjooKT0+eXcsbG9zc2VzOigpPT5GVCxsb3dlckJvdW5kOigpPT5QTixtYXRNdWw6KCk9PiRlLG1hdGg6KCk9PlZULG1heDooKT0+bWEsbWF4UG9vbDooKT0+RHQsbWF4UG9vbDNkOigpPT54dyxtYXhQb29sV2l0aEFyZ21heDooKT0+TE4sbWF4aW11bTooKT0+aHIsbWVhbjooKT0+Q3QsbWVtb3J5OigpPT5LaCxtZXNoZ3JpZDooKT0+ek4sbWV0cmljczooKT0+UkMsbWluOigpPT5PbCxtaW5pbXVtOigpPT5kcyxtaXJyb3JQYWQ6KCk9PnZ3LG1vZDooKT0+d3csbW9kZWw6KCk9PnBqLG1vZGVsczooKT0+TUMsbW9tZW50czooKT0+aGQsbW92aW5nQXZlcmFnZTooKT0+ZlQsbXVsOigpPT56LG11bHRpUk5OQ2VsbDooKT0+V04sbXVsdGlub21pYWw6KCk9PkJOLG5lZzooKT0+eXQsbmV4dEZyYW1lOigpPT5adyxub3JtOigpPT5lcCxub3RFcXVhbDooKT0+Zmksb25lSG90OigpPT5MbCxvbmVzOigpPT5QbixvbmVzTGlrZTooKT0+ZWEsb3A6KCk9Pkwsb3V0ZXJQcm9kdWN0OigpPT5WTixwYWQ6KCk9PnhhLHBhZDFkOigpPT5VTixwYWQyZDooKT0+R04scGFkM2Q6KCk9PkhOLHBhZDRkOigpPT5qTixwb29sOigpPT5rdyxwb3c6KCk9PnVyLHByZWx1OigpPT5mZCxwcmludDooKT0+T3YscHJvZDooKT0+SXcscHJvZmlsZTooKT0+UU0scmFnZ2VkR2F0aGVyOigpPT5xTixyYWdnZWRSYW5nZTooKT0+S04scmFnZ2VkVGVuc29yVG9UZW5zb3I6KCk9PlhOLHJhbmQ6KCk9PllOLHJhbmRvbUdhbW1hOigpPT5lVCxyYW5kb21Ob3JtYWw6KCk9PlhtLHJhbmRvbVN0YW5kYXJkTm9ybWFsOigpPT50VCxyYW5kb21Vbmlmb3JtOigpPT5FcyxyYW5kb21Vbmlmb3JtSW50OigpPT5uVCxyYW5nZTooKT0+Z2kscmVhZHk6KCk9Pm5PLHJlYWw6KCk9PnpsLHJlY2lwcm9jYWw6KCk9PkV3LHJlZ2lzdGVyQmFja2VuZDooKT0+T20scmVnaXN0ZXJDYWxsYmFja0NvbnN0cnVjdG9yOigpPT5kaixyZWdpc3RlckdyYWRpZW50OigpPT5LUyxyZWdpc3Rlcktlcm5lbDooKT0+ZWQscmVnaXN0ZXJPcDooKT0+bXEscmVndWxhcml6ZXJzOigpPT5PQyxyZWx1OigpPT5LZSxyZWx1NjooKT0+WW0scmVtb3ZlQmFja2VuZDooKT0+YU8scmVzaGFwZTooKT0+VyxyZXZlcnNlOigpPT5iYSxyZXZlcnNlMWQ6KCk9PmFULHJldmVyc2UyZDooKT0+clQscmV2ZXJzZTNkOigpPT5zVCxyZXZlcnNlNGQ6KCk9PmlULHJmZnQ6KCk9PnlkLHJvdW5kOigpPT5abSxyc3FydDooKT0+Sm0sc2NhbGFyOigpPT54ZSxzY2F0dGVyTkQ6KCk9PmdULHNjYXR0ZXJfdXRpbDooKT0+c2Ysc2VhcmNoU29ydGVkOigpPT5LbSxzZWx1OigpPT5RbSxzZXBhcmFibGVDb252MmQ6KCk9Pl9zLHNlcXVlbnRpYWw6KCk9PmNqLHNlcmlhbGl6YXRpb246KCk9Pm5lLHNldEJhY2tlbmQ6KCk9PnRPLHNldFBsYXRmb3JtOigpPT5pTyxzZXRUaHJlYWRzQ291bnQ6KCk9PkVmZSxzZXRXYXNtUGF0aDooKT0+VGZlLHNldFdhc21QYXRoczooKT0+Q2ZlLHNldFdlYkdMQ29udGV4dDooKT0+RF8sc2V0ZGlmZjFkQXN5bmM6KCk9Pm9ULHNoYXJlZDooKT0+TTEsc2lnbW9pZDooKT0+aGEsc2lnbjooKT0+X3csc2lnbmFsOigpPT5BVCxzaW46KCk9PmVmLHNpbmg6KCk9PnRmLHNsaWNlOigpPT5WZSxzbGljZTFkOigpPT5nZCxzbGljZTJkOigpPT5uZixzbGljZTNkOigpPT5IbyxzbGljZTRkOigpPT5XbCxzbGljZV91dGlsOigpPT5LdCxzb2Z0bWF4OigpPT5xYSxzb2Z0cGx1czooKT0+R28sc3BhY2VUb0JhdGNoTkQ6KCk9Pm1kLHNwYXJzZTooKT0+JFQsc3BhcnNlVG9EZW5zZTooKT0+YlQsc3BlY3RyYWw6KCk9Pl9ULHNwbGl0OigpPT5MbixzcXJ0OigpPT5ybixzcXVhcmU6KCk9PnB0LHNxdWFyZWREaWZmZXJlbmNlOigpPT5yZixzcXVlZXplOigpPT5BcyxzdGFjazooKT0+QXQsc3RlcDooKT0+am8sc3RyaWRlZFNsaWNlOigpPT5BdyxzdHJpbmc6KCk9PkRULHN1YjooKT0+cGUsc3VtOigpPT5mZSxzdW1PdXRUeXBlOigpPT5NbSx0YW46KCk9PkZ3LHRhbmg6KCk9PmNzLHRlbnNvcjooKT0+Ym4sdGVuc29yMWQ6KCk9PmplLHRlbnNvcjJkOigpPT5FYSx0ZW5zb3IzZDooKT0+eGQsdGVuc29yNGQ6KCk9PkZhLHRlbnNvcjVkOigpPT5sVCx0ZW5zb3I2ZDooKT0+dVQsdGVuc29yU2NhdHRlclVwZGF0ZTooKT0+Y1QsdGVuc29yX3V0aWw6KCk9PldhLHRlc3RfdXRpbDooKT0+Wk4sdGlkeTooKT0+Tyx0aWxlOigpPT5Pbix0aW1lOigpPT5lTyx0b3BrOigpPT5Edyx0cmFpbjooKT0+WHMsdHJhbnNwb3NlOigpPT5EZSx0cnVuY2F0ZWROb3JtYWw6KCk9PmxmLHVuaXF1ZTooKT0+UncsdW5yZWdpc3RlckdyYWRpZW50OigpPT55TSx1bnJlZ2lzdGVyS2VybmVsOigpPT5iTSx1bnNvcnRlZFNlZ21lbnRTdW06KCk9PnVmLHVuc3RhY2s6KCk9PmR0LHVwY2FzdFR5cGU6KCk9PmZhLHVwcGVyQm91bmQ6KCk9PmRULHV0aWw6KCk9PncsdmFsdWVBbmRHcmFkOigpPT56Myx2YWx1ZUFuZEdyYWRzOigpPT5XMyx2YXJpYWJsZTooKT0+TXcsdmFyaWFibGVHcmFkczooKT0+T04sdmVyc2lvbjooKT0+T2ZlLHZlcnNpb25fY29udmVydGVyOigpPT5TNSx2ZXJzaW9uX2NvcmU6KCk9PnA0LHZlcnNpb25fY3B1OigpPT5OSyx2ZXJzaW9uX2xheWVyczooKT0+djAsdmVyc2lvbl93YXNtOigpPT5BZmUsdmVyc2lvbl93ZWJnbDooKT0+bWVlLHdlYmdsOigpPT5mZWUsd2ViZ2xfdXRpbDooKT0+JF8sd2hlcmU6KCk9Pm5uLHdoZXJlQXN5bmM6KCk9Pk93LHplcm9zOigpPT5JdCx6ZXJvc0xpa2U6KCk9PnFlfSk7dmFyIGtSPU9iamVjdC5jcmVhdGUsa3Y9T2JqZWN0LmRlZmluZVByb3BlcnR5LElSPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsU1I9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsTlI9T2JqZWN0LmdldFByb3RvdHlwZU9mLFRSPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksVnQ9KGUsdCk9PigpPT4odHx8ZSgodD17ZXhwb3J0czp7fX0pLmV4cG9ydHMsdCksdC5leHBvcnRzKSxfZT0oZSx0KT0+e2Zvcih2YXIgbiBpbiB0KWt2KGUsbix7Z2V0OnRbbl0sZW51bWVyYWJsZTohMH0pfSxDUj0oZSx0LG4sYSk9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IHIgb2YgU1IodCkpIVRSLmNhbGwoZSxyKSYmciE9PW4mJmt2KGUscix7Z2V0OigpPT50W3JdLGVudW1lcmFibGU6IShhPUlSKHQscikpfHxhLmVudW1lcmFibGV9KTtyZXR1cm4gZX0seHM9KGUsdCxuKT0+KG49ZSE9bnVsbD9rUihOUihlKSk6e30sQ1IodHx8IWV8fCFlLl9fZXNNb2R1bGU/a3YobixcImRlZmF1bHRcIix7dmFsdWU6ZSxlbnVtZXJhYmxlOiEwfSk6bixlKSksRVI9VnQoKGUsdCk9Pnt0LmV4cG9ydHM9YTt2YXIgbj1udWxsO3RyeXtuPW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEzLDIsOTYsMCwxLDEyNyw5Niw0LDEyNywxMjcsMTI3LDEyNywxLDEyNywzLDcsNiwwLDEsMSwxLDEsMSw2LDYsMSwxMjcsMSw2NSwwLDExLDcsNTAsNiwzLDEwOSwxMTcsMTA4LDAsMSw1LDEwMCwxMDUsMTE4LDk1LDExNSwwLDIsNSwxMDAsMTA1LDExOCw5NSwxMTcsMCwzLDUsMTE0LDEwMSwxMDksOTUsMTE1LDAsNCw1LDExNCwxMDEsMTA5LDk1LDExNywwLDUsOCwxMDMsMTAxLDExNiw5NSwxMDQsMTA1LDEwMywxMDQsMCwwLDEwLDE5MSwxLDYsNCwwLDM1LDAsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI2LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNywzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjgsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI5LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEzMCwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMV0pKSx7fSkuZXhwb3J0c31jYXRjaChTKXt9ZnVuY3Rpb24gYShTLE0sQil7dGhpcy5sb3c9U3wwLHRoaXMuaGlnaD1NfDAsdGhpcy51bnNpZ25lZD0hIUJ9YS5wcm90b3R5cGUuX19pc0xvbmdfXyxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJfX2lzTG9uZ19fXCIse3ZhbHVlOiEwfSk7ZnVuY3Rpb24gcihTKXtyZXR1cm4oUyYmUy5fX2lzTG9uZ19fKT09PSEwfWEuaXNMb25nPXI7dmFyIHM9e30saT17fTtmdW5jdGlvbiBvKFMsTSl7dmFyIEIsVSxIO3JldHVybiBNPyhTPj4+PTAsKEg9MDw9UyYmUzwyNTYpJiYoVT1pW1NdLFUpP1U6KEI9dShTLChTfDApPDA/LTE6MCwhMCksSCYmKGlbU109QiksQikpOihTfD0wLChIPS0xMjg8PVMmJlM8MTI4KSYmKFU9c1tTXSxVKT9VOihCPXUoUyxTPDA/LTE6MCwhMSksSCYmKHNbU109QiksQikpfWEuZnJvbUludD1vO2Z1bmN0aW9uIGwoUyxNKXtpZihpc05hTihTKSlyZXR1cm4gTT92Ong7aWYoTSl7aWYoUzwwKXJldHVybiB2O2lmKFM+PWcpcmV0dXJuIEZ9ZWxzZXtpZihTPD0tYilyZXR1cm4gRDtpZihTKzE+PWIpcmV0dXJuIF99cmV0dXJuIFM8MD9sKC1TLE0pLm5lZygpOnUoUyVmfDAsUy9mfDAsTSl9YS5mcm9tTnVtYmVyPWw7ZnVuY3Rpb24gdShTLE0sQil7cmV0dXJuIG5ldyBhKFMsTSxCKX1hLmZyb21CaXRzPXU7dmFyIHA9TWF0aC5wb3c7ZnVuY3Rpb24gZChTLE0sQil7aWYoUy5sZW5ndGg9PT0wKXRocm93IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO2lmKFM9PT1cIk5hTlwifHxTPT09XCJJbmZpbml0eVwifHxTPT09XCIrSW5maW5pdHlcInx8Uz09PVwiLUluZmluaXR5XCIpcmV0dXJuIHg7aWYodHlwZW9mIE09PVwibnVtYmVyXCI/KEI9TSxNPSExKTpNPSEhTSxCPUJ8fDEwLEI8Mnx8MzY8Qil0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7dmFyIFU7aWYoKFU9Uy5pbmRleE9mKFwiLVwiKSk+MCl0aHJvdyBFcnJvcihcImludGVyaW9yIGh5cGhlblwiKTtpZihVPT09MClyZXR1cm4gZChTLnN1YnN0cmluZygxKSxNLEIpLm5lZygpO2Zvcih2YXIgSD1sKHAoQiw4KSkscT14LEs9MDtLPFMubGVuZ3RoO0srPTgpe3ZhciBaPU1hdGgubWluKDgsUy5sZW5ndGgtSyksSj1wYXJzZUludChTLnN1YnN0cmluZyhLLEsrWiksQik7aWYoWjw4KXt2YXIgZWU9bChwKEIsWikpO3E9cS5tdWwoZWUpLmFkZChsKEopKX1lbHNlIHE9cS5tdWwoSCkscT1xLmFkZChsKEopKX1yZXR1cm4gcS51bnNpZ25lZD1NLHF9YS5mcm9tU3RyaW5nPWQ7ZnVuY3Rpb24gYyhTLE0pe3JldHVybiB0eXBlb2YgUz09XCJudW1iZXJcIj9sKFMsTSk6dHlwZW9mIFM9PVwic3RyaW5nXCI/ZChTLE0pOnUoUy5sb3csUy5oaWdoLHR5cGVvZiBNPT1cImJvb2xlYW5cIj9NOlMudW5zaWduZWQpfWEuZnJvbVZhbHVlPWM7dmFyIGg9NjU1MzYsbT0xPDwyNCxmPWgqaCxnPWYqZixiPWcvMix5PW8obSkseD1vKDApO2EuWkVSTz14O3ZhciB2PW8oMCwhMCk7YS5VWkVSTz12O3ZhciBJPW8oMSk7YS5PTkU9STt2YXIgTj1vKDEsITApO2EuVU9ORT1OO3ZhciBDPW8oLTEpO2EuTkVHX09ORT1DO3ZhciBfPXUoLTEsMjE0NzQ4MzY0NywhMSk7YS5NQVhfVkFMVUU9Xzt2YXIgRj11KC0xLC0xLCEwKTthLk1BWF9VTlNJR05FRF9WQUxVRT1GO3ZhciBEPXUoMCwtMjE0NzQ4MzY0OCwhMSk7YS5NSU5fVkFMVUU9RDt2YXIgJD1hLnByb3RvdHlwZTskLnRvSW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpcy5sb3c+Pj4wOnRoaXMubG93fSwkLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/KHRoaXMuaGlnaD4+PjApKmYrKHRoaXMubG93Pj4+MCk6dGhpcy5oaWdoKmYrKHRoaXMubG93Pj4+MCl9LCQudG9TdHJpbmc9ZnVuY3Rpb24oUyl7aWYoUz1TfHwxMCxTPDJ8fDM2PFMpdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuXCIwXCI7aWYodGhpcy5pc05lZ2F0aXZlKCkpaWYodGhpcy5lcShEKSl7dmFyIE09bChTKSxCPXRoaXMuZGl2KE0pLFU9Qi5tdWwoTSkuc3ViKHRoaXMpO3JldHVybiBCLnRvU3RyaW5nKFMpK1UudG9JbnQoKS50b1N0cmluZyhTKX1lbHNlIHJldHVyblwiLVwiK3RoaXMubmVnKCkudG9TdHJpbmcoUyk7Zm9yKHZhciBIPWwocChTLDYpLHRoaXMudW5zaWduZWQpLHE9dGhpcyxLPVwiXCI7Oyl7dmFyIFo9cS5kaXYoSCksSj1xLnN1YihaLm11bChIKSkudG9JbnQoKT4+PjAsZWU9Si50b1N0cmluZyhTKTtpZihxPVoscS5pc1plcm8oKSlyZXR1cm4gZWUrSztmb3IoO2VlLmxlbmd0aDw2OyllZT1cIjBcIitlZTtLPVwiXCIrZWUrS319LCQuZ2V0SGlnaEJpdHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaWdofSwkLmdldEhpZ2hCaXRzVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaWdoPj4+MH0sJC5nZXRMb3dCaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93fSwkLmdldExvd0JpdHNVbnNpZ25lZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvdz4+PjB9LCQuZ2V0TnVtQml0c0Ficz1mdW5jdGlvbigpe2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiB0aGlzLmVxKEQpPzY0OnRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO2Zvcih2YXIgUz10aGlzLmhpZ2ghPTA/dGhpcy5oaWdoOnRoaXMubG93LE09MzE7TT4wJiYhKFMmMTw8TSk7TS0tKTtyZXR1cm4gdGhpcy5oaWdoIT0wP00rMzM6TSsxfSwkLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g9PT0wJiZ0aGlzLmxvdz09PTB9LCQuZXF6PSQuaXNaZXJvLCQuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnVuc2lnbmVkJiZ0aGlzLmhpZ2g8MH0sJC5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWR8fHRoaXMuaGlnaD49MH0sJC5pc09kZD1mdW5jdGlvbigpe3JldHVybih0aGlzLmxvdyYxKT09PTF9LCQuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubG93JjEpPT09MH0sJC5lcXVhbHM9ZnVuY3Rpb24oUyl7cmV0dXJuIHIoUyl8fChTPWMoUykpLHRoaXMudW5zaWduZWQhPT1TLnVuc2lnbmVkJiZ0aGlzLmhpZ2g+Pj4zMT09PTEmJlMuaGlnaD4+PjMxPT09MT8hMTp0aGlzLmhpZ2g9PT1TLmhpZ2gmJnRoaXMubG93PT09Uy5sb3d9LCQuZXE9JC5lcXVhbHMsJC5ub3RFcXVhbHM9ZnVuY3Rpb24oUyl7cmV0dXJuIXRoaXMuZXEoUyl9LCQubmVxPSQubm90RXF1YWxzLCQubmU9JC5ub3RFcXVhbHMsJC5sZXNzVGhhbj1mdW5jdGlvbihTKXtyZXR1cm4gdGhpcy5jb21wKFMpPDB9LCQubHQ9JC5sZXNzVGhhbiwkLmxlc3NUaGFuT3JFcXVhbD1mdW5jdGlvbihTKXtyZXR1cm4gdGhpcy5jb21wKFMpPD0wfSwkLmx0ZT0kLmxlc3NUaGFuT3JFcXVhbCwkLmxlPSQubGVzc1RoYW5PckVxdWFsLCQuZ3JlYXRlclRoYW49ZnVuY3Rpb24oUyl7cmV0dXJuIHRoaXMuY29tcChTKT4wfSwkLmd0PSQuZ3JlYXRlclRoYW4sJC5ncmVhdGVyVGhhbk9yRXF1YWw9ZnVuY3Rpb24oUyl7cmV0dXJuIHRoaXMuY29tcChTKT49MH0sJC5ndGU9JC5ncmVhdGVyVGhhbk9yRXF1YWwsJC5nZT0kLmdyZWF0ZXJUaGFuT3JFcXVhbCwkLmNvbXBhcmU9ZnVuY3Rpb24oUyl7aWYocihTKXx8KFM9YyhTKSksdGhpcy5lcShTKSlyZXR1cm4gMDt2YXIgTT10aGlzLmlzTmVnYXRpdmUoKSxCPVMuaXNOZWdhdGl2ZSgpO3JldHVybiBNJiYhQj8tMTohTSYmQj8xOnRoaXMudW5zaWduZWQ/Uy5oaWdoPj4+MD50aGlzLmhpZ2g+Pj4wfHxTLmhpZ2g9PT10aGlzLmhpZ2gmJlMubG93Pj4+MD50aGlzLmxvdz4+PjA/LTE6MTp0aGlzLnN1YihTKS5pc05lZ2F0aXZlKCk/LTE6MX0sJC5jb21wPSQuY29tcGFyZSwkLm5lZ2F0ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnVuc2lnbmVkJiZ0aGlzLmVxKEQpP0Q6dGhpcy5ub3QoKS5hZGQoSSl9LCQubmVnPSQubmVnYXRlLCQuYWRkPWZ1bmN0aW9uKFMpe3IoUyl8fChTPWMoUykpO3ZhciBNPXRoaXMuaGlnaD4+PjE2LEI9dGhpcy5oaWdoJjY1NTM1LFU9dGhpcy5sb3c+Pj4xNixIPXRoaXMubG93JjY1NTM1LHE9Uy5oaWdoPj4+MTYsSz1TLmhpZ2gmNjU1MzUsWj1TLmxvdz4+PjE2LEo9Uy5sb3cmNjU1MzUsZWU9MCxhZT0wLHRlPTAsc2U9MDtyZXR1cm4gc2UrPUgrSix0ZSs9c2U+Pj4xNixzZSY9NjU1MzUsdGUrPVUrWixhZSs9dGU+Pj4xNix0ZSY9NjU1MzUsYWUrPUIrSyxlZSs9YWU+Pj4xNixhZSY9NjU1MzUsZWUrPU0rcSxlZSY9NjU1MzUsdSh0ZTw8MTZ8c2UsZWU8PDE2fGFlLHRoaXMudW5zaWduZWQpfSwkLnN1YnRyYWN0PWZ1bmN0aW9uKFMpe3JldHVybiByKFMpfHwoUz1jKFMpKSx0aGlzLmFkZChTLm5lZygpKX0sJC5zdWI9JC5zdWJ0cmFjdCwkLm11bHRpcGx5PWZ1bmN0aW9uKFMpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHg7aWYocihTKXx8KFM9YyhTKSksbil7dmFyIE09bi5tdWwodGhpcy5sb3csdGhpcy5oaWdoLFMubG93LFMuaGlnaCk7cmV0dXJuIHUoTSxuLmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCl9aWYoUy5pc1plcm8oKSlyZXR1cm4geDtpZih0aGlzLmVxKEQpKXJldHVybiBTLmlzT2RkKCk/RDp4O2lmKFMuZXEoRCkpcmV0dXJuIHRoaXMuaXNPZGQoKT9EOng7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIFMuaXNOZWdhdGl2ZSgpP3RoaXMubmVnKCkubXVsKFMubmVnKCkpOnRoaXMubmVnKCkubXVsKFMpLm5lZygpO2lmKFMuaXNOZWdhdGl2ZSgpKXJldHVybiB0aGlzLm11bChTLm5lZygpKS5uZWcoKTtpZih0aGlzLmx0KHkpJiZTLmx0KHkpKXJldHVybiBsKHRoaXMudG9OdW1iZXIoKSpTLnRvTnVtYmVyKCksdGhpcy51bnNpZ25lZCk7dmFyIEI9dGhpcy5oaWdoPj4+MTYsVT10aGlzLmhpZ2gmNjU1MzUsSD10aGlzLmxvdz4+PjE2LHE9dGhpcy5sb3cmNjU1MzUsSz1TLmhpZ2g+Pj4xNixaPVMuaGlnaCY2NTUzNSxKPVMubG93Pj4+MTYsZWU9Uy5sb3cmNjU1MzUsYWU9MCx0ZT0wLHNlPTAsaWU9MDtyZXR1cm4gaWUrPXEqZWUsc2UrPWllPj4+MTYsaWUmPTY1NTM1LHNlKz1IKmVlLHRlKz1zZT4+PjE2LHNlJj02NTUzNSxzZSs9cSpKLHRlKz1zZT4+PjE2LHNlJj02NTUzNSx0ZSs9VSplZSxhZSs9dGU+Pj4xNix0ZSY9NjU1MzUsdGUrPUgqSixhZSs9dGU+Pj4xNix0ZSY9NjU1MzUsdGUrPXEqWixhZSs9dGU+Pj4xNix0ZSY9NjU1MzUsYWUrPUIqZWUrVSpKK0gqWitxKkssYWUmPTY1NTM1LHUoc2U8PDE2fGllLGFlPDwxNnx0ZSx0aGlzLnVuc2lnbmVkKX0sJC5tdWw9JC5tdWx0aXBseSwkLmRpdmlkZT1mdW5jdGlvbihTKXtpZihyKFMpfHwoUz1jKFMpKSxTLmlzWmVybygpKXRocm93IEVycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiKTtpZihuKXtpZighdGhpcy51bnNpZ25lZCYmdGhpcy5oaWdoPT09LTIxNDc0ODM2NDgmJlMubG93PT09LTEmJlMuaGlnaD09PS0xKXJldHVybiB0aGlzO3ZhciBNPSh0aGlzLnVuc2lnbmVkP24uZGl2X3U6bi5kaXZfcykodGhpcy5sb3csdGhpcy5oaWdoLFMubG93LFMuaGlnaCk7cmV0dXJuIHUoTSxuLmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCl9aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gdGhpcy51bnNpZ25lZD92Ong7dmFyIEIsVSxIO2lmKHRoaXMudW5zaWduZWQpe2lmKFMudW5zaWduZWR8fChTPVMudG9VbnNpZ25lZCgpKSxTLmd0KHRoaXMpKXJldHVybiB2O2lmKFMuZ3QodGhpcy5zaHJ1KDEpKSlyZXR1cm4gTjtIPXZ9ZWxzZXtpZih0aGlzLmVxKEQpKXtpZihTLmVxKEkpfHxTLmVxKEMpKXJldHVybiBEO2lmKFMuZXEoRCkpcmV0dXJuIEk7dmFyIHE9dGhpcy5zaHIoMSk7cmV0dXJuIEI9cS5kaXYoUykuc2hsKDEpLEIuZXEoeCk/Uy5pc05lZ2F0aXZlKCk/STpDOihVPXRoaXMuc3ViKFMubXVsKEIpKSxIPUIuYWRkKFUuZGl2KFMpKSxIKX1lbHNlIGlmKFMuZXEoRCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/djp4O2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBTLmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLmRpdihTLm5lZygpKTp0aGlzLm5lZygpLmRpdihTKS5uZWcoKTtpZihTLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5kaXYoUy5uZWcoKSkubmVnKCk7SD14fWZvcihVPXRoaXM7VS5ndGUoUyk7KXtCPU1hdGgubWF4KDEsTWF0aC5mbG9vcihVLnRvTnVtYmVyKCkvUy50b051bWJlcigpKSk7Zm9yKHZhciBLPU1hdGguY2VpbChNYXRoLmxvZyhCKS9NYXRoLkxOMiksWj1LPD00OD8xOnAoMixLLTQ4KSxKPWwoQiksZWU9Si5tdWwoUyk7ZWUuaXNOZWdhdGl2ZSgpfHxlZS5ndChVKTspQi09WixKPWwoQix0aGlzLnVuc2lnbmVkKSxlZT1KLm11bChTKTtKLmlzWmVybygpJiYoSj1JKSxIPUguYWRkKEopLFU9VS5zdWIoZWUpfXJldHVybiBIfSwkLmRpdj0kLmRpdmlkZSwkLm1vZHVsbz1mdW5jdGlvbihTKXtpZihyKFMpfHwoUz1jKFMpKSxuKXt2YXIgTT0odGhpcy51bnNpZ25lZD9uLnJlbV91Om4ucmVtX3MpKHRoaXMubG93LHRoaXMuaGlnaCxTLmxvdyxTLmhpZ2gpO3JldHVybiB1KE0sbi5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpfXJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihTKS5tdWwoUykpfSwkLm1vZD0kLm1vZHVsbywkLnJlbT0kLm1vZHVsbywkLm5vdD1mdW5jdGlvbigpe3JldHVybiB1KH50aGlzLmxvdyx+dGhpcy5oaWdoLHRoaXMudW5zaWduZWQpfSwkLmFuZD1mdW5jdGlvbihTKXtyZXR1cm4gcihTKXx8KFM9YyhTKSksdSh0aGlzLmxvdyZTLmxvdyx0aGlzLmhpZ2gmUy5oaWdoLHRoaXMudW5zaWduZWQpfSwkLm9yPWZ1bmN0aW9uKFMpe3JldHVybiByKFMpfHwoUz1jKFMpKSx1KHRoaXMubG93fFMubG93LHRoaXMuaGlnaHxTLmhpZ2gsdGhpcy51bnNpZ25lZCl9LCQueG9yPWZ1bmN0aW9uKFMpe3JldHVybiByKFMpfHwoUz1jKFMpKSx1KHRoaXMubG93XlMubG93LHRoaXMuaGlnaF5TLmhpZ2gsdGhpcy51bnNpZ25lZCl9LCQuc2hpZnRMZWZ0PWZ1bmN0aW9uKFMpe3JldHVybiByKFMpJiYoUz1TLnRvSW50KCkpLChTJj02Myk9PT0wP3RoaXM6UzwzMj91KHRoaXMubG93PDxTLHRoaXMuaGlnaDw8U3x0aGlzLmxvdz4+PjMyLVMsdGhpcy51bnNpZ25lZCk6dSgwLHRoaXMubG93PDxTLTMyLHRoaXMudW5zaWduZWQpfSwkLnNobD0kLnNoaWZ0TGVmdCwkLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24oUyl7cmV0dXJuIHIoUykmJihTPVMudG9JbnQoKSksKFMmPTYzKT09PTA/dGhpczpTPDMyP3UodGhpcy5sb3c+Pj5TfHRoaXMuaGlnaDw8MzItUyx0aGlzLmhpZ2g+PlMsdGhpcy51bnNpZ25lZCk6dSh0aGlzLmhpZ2g+PlMtMzIsdGhpcy5oaWdoPj0wPzA6LTEsdGhpcy51bnNpZ25lZCl9LCQuc2hyPSQuc2hpZnRSaWdodCwkLnNoaWZ0UmlnaHRVbnNpZ25lZD1mdW5jdGlvbihTKXtpZihyKFMpJiYoUz1TLnRvSW50KCkpLFMmPTYzLFM9PT0wKXJldHVybiB0aGlzO3ZhciBNPXRoaXMuaGlnaDtpZihTPDMyKXt2YXIgQj10aGlzLmxvdztyZXR1cm4gdShCPj4+U3xNPDwzMi1TLE0+Pj5TLHRoaXMudW5zaWduZWQpfWVsc2UgcmV0dXJuIFM9PT0zMj91KE0sMCx0aGlzLnVuc2lnbmVkKTp1KE0+Pj5TLTMyLDAsdGhpcy51bnNpZ25lZCl9LCQuc2hydT0kLnNoaWZ0UmlnaHRVbnNpZ25lZCwkLnNocl91PSQuc2hpZnRSaWdodFVuc2lnbmVkLCQudG9TaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD91KHRoaXMubG93LHRoaXMuaGlnaCwhMSk6dGhpc30sJC50b1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpczp1KHRoaXMubG93LHRoaXMuaGlnaCwhMCl9LCQudG9CeXRlcz1mdW5jdGlvbihTKXtyZXR1cm4gUz90aGlzLnRvQnl0ZXNMRSgpOnRoaXMudG9CeXRlc0JFKCl9LCQudG9CeXRlc0xFPWZ1bmN0aW9uKCl7dmFyIFM9dGhpcy5oaWdoLE09dGhpcy5sb3c7cmV0dXJuW00mMjU1LE0+Pj44JjI1NSxNPj4+MTYmMjU1LE0+Pj4yNCxTJjI1NSxTPj4+OCYyNTUsUz4+PjE2JjI1NSxTPj4+MjRdfSwkLnRvQnl0ZXNCRT1mdW5jdGlvbigpe3ZhciBTPXRoaXMuaGlnaCxNPXRoaXMubG93O3JldHVybltTPj4+MjQsUz4+PjE2JjI1NSxTPj4+OCYyNTUsUyYyNTUsTT4+PjI0LE0+Pj4xNiYyNTUsTT4+PjgmMjU1LE0mMjU1XX0sYS5mcm9tQnl0ZXM9ZnVuY3Rpb24oUyxNLEIpe3JldHVybiBCP2EuZnJvbUJ5dGVzTEUoUyxNKTphLmZyb21CeXRlc0JFKFMsTSl9LGEuZnJvbUJ5dGVzTEU9ZnVuY3Rpb24oUyxNKXtyZXR1cm4gbmV3IGEoU1swXXxTWzFdPDw4fFNbMl08PDE2fFNbM108PDI0LFNbNF18U1s1XTw8OHxTWzZdPDwxNnxTWzddPDwyNCxNKX0sYS5mcm9tQnl0ZXNCRT1mdW5jdGlvbihTLE0pe3JldHVybiBuZXcgYShTWzRdPDwyNHxTWzVdPDwxNnxTWzZdPDw4fFNbN10sU1swXTw8MjR8U1sxXTw8MTZ8U1syXTw8OHxTWzNdLE0pfX0pLF9SPVZ0KCgpPT57fSksQVI9VnQoKCk9Pnt9KSxGUj1WdCgoZSx0KT0+eyhmdW5jdGlvbihuLGEscil7ZnVuY3Rpb24gcyh1KXt2YXIgcD10aGlzLGQ9bCgpO3AubmV4dD1mdW5jdGlvbigpe3ZhciBjPTIwOTE2MzkqcC5zMCtwLmMqMjMyODMwNjQzNjUzODY5NjNlLTI2O3JldHVybiBwLnMwPXAuczEscC5zMT1wLnMyLHAuczI9Yy0ocC5jPWN8MCl9LHAuYz0xLHAuczA9ZChcIiBcIikscC5zMT1kKFwiIFwiKSxwLnMyPWQoXCIgXCIpLHAuczAtPWQodSkscC5zMDwwJiYocC5zMCs9MSkscC5zMS09ZCh1KSxwLnMxPDAmJihwLnMxKz0xKSxwLnMyLT1kKHUpLHAuczI8MCYmKHAuczIrPTEpLGQ9bnVsbH1mdW5jdGlvbiBpKHUscCl7cmV0dXJuIHAuYz11LmMscC5zMD11LnMwLHAuczE9dS5zMSxwLnMyPXUuczIscH1mdW5jdGlvbiBvKHUscCl7dmFyIGQ9bmV3IHModSksYz1wJiZwLnN0YXRlLGg9ZC5uZXh0O3JldHVybiBoLmludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIGQubmV4dCgpKjQyOTQ5NjcyOTZ8MH0saC5kb3VibGU9ZnVuY3Rpb24oKXtyZXR1cm4gaCgpKyhoKCkqMjA5NzE1MnwwKSoxMTEwMjIzMDI0NjI1MTU2NWUtMzJ9LGgucXVpY2s9aCxjJiYodHlwZW9mIGM9PVwib2JqZWN0XCImJmkoYyxkKSxoLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGkoZCx7fSl9KSxofWZ1bmN0aW9uIGwoKXt2YXIgdT00MDIyODcxMTk3LHA9ZnVuY3Rpb24oZCl7ZD1TdHJpbmcoZCk7Zm9yKHZhciBjPTA7YzxkLmxlbmd0aDtjKyspe3UrPWQuY2hhckNvZGVBdChjKTt2YXIgaD0uMDI1MTk2MDMyODI0MTY5MzgqdTt1PWg+Pj4wLGgtPXUsaCo9dSx1PWg+Pj4wLGgtPXUsdSs9aCo0Mjk0OTY3Mjk2fXJldHVybih1Pj4+MCkqMjMyODMwNjQzNjUzODY5NjNlLTI2fTtyZXR1cm4gcH1hJiZhLmV4cG9ydHM/YS5leHBvcnRzPW86ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBvfSk6dGhpcy5hbGVhPW99KShlLHR5cGVvZiB0PT1cIm9iamVjdFwiJiZ0LHR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lKX0pLCRSPVZ0KChlLHQpPT57KGZ1bmN0aW9uKG4sYSxyKXtmdW5jdGlvbiBzKGwpe3ZhciB1PXRoaXMscD1cIlwiO3UueD0wLHUueT0wLHUuej0wLHUudz0wLHUubmV4dD1mdW5jdGlvbigpe3ZhciBjPXUueF51Lng8PDExO3JldHVybiB1Lng9dS55LHUueT11LnosdS56PXUudyx1LndePXUudz4+PjE5XmNeYz4+Pjh9LGw9PT0obHwwKT91Lng9bDpwKz1sO2Zvcih2YXIgZD0wO2Q8cC5sZW5ndGgrNjQ7ZCsrKXUueF49cC5jaGFyQ29kZUF0KGQpfDAsdS5uZXh0KCl9ZnVuY3Rpb24gaShsLHUpe3JldHVybiB1Lng9bC54LHUueT1sLnksdS56PWwueix1Lnc9bC53LHV9ZnVuY3Rpb24gbyhsLHUpe3ZhciBwPW5ldyBzKGwpLGQ9dSYmdS5zdGF0ZSxjPWZ1bmN0aW9uKCl7cmV0dXJuKHAubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGMuZG91YmxlPWZ1bmN0aW9uKCl7ZG8gdmFyIGg9cC5uZXh0KCk+Pj4xMSxtPShwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYsZj0oaCttKS8oMTw8MjEpO3doaWxlKGY9PT0wKTtyZXR1cm4gZn0sYy5pbnQzMj1wLm5leHQsYy5xdWljaz1jLGQmJih0eXBlb2YgZD09XCJvYmplY3RcIiYmaShkLHApLGMuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gaShwLHt9KX0pLGN9YSYmYS5leHBvcnRzP2EuZXhwb3J0cz1vOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gb30pOnRoaXMueG9yMTI4PW99KShlLHR5cGVvZiB0PT1cIm9iamVjdFwiJiZ0LHR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lKX0pLERSPVZ0KChlLHQpPT57KGZ1bmN0aW9uKG4sYSxyKXtmdW5jdGlvbiBzKGwpe3ZhciB1PXRoaXMscD1cIlwiO3UubmV4dD1mdW5jdGlvbigpe3ZhciBjPXUueF51Lng+Pj4yO3JldHVybiB1Lng9dS55LHUueT11LnosdS56PXUudyx1Lnc9dS52LCh1LmQ9dS5kKzM2MjQzN3wwKSsodS52PXUudl51LnY8PDReKGNeYzw8MSkpfDB9LHUueD0wLHUueT0wLHUuej0wLHUudz0wLHUudj0wLGw9PT0obHwwKT91Lng9bDpwKz1sO2Zvcih2YXIgZD0wO2Q8cC5sZW5ndGgrNjQ7ZCsrKXUueF49cC5jaGFyQ29kZUF0KGQpfDAsZD09cC5sZW5ndGgmJih1LmQ9dS54PDwxMF51Lng+Pj40KSx1Lm5leHQoKX1mdW5jdGlvbiBpKGwsdSl7cmV0dXJuIHUueD1sLngsdS55PWwueSx1Lno9bC56LHUudz1sLncsdS52PWwudix1LmQ9bC5kLHV9ZnVuY3Rpb24gbyhsLHUpe3ZhciBwPW5ldyBzKGwpLGQ9dSYmdS5zdGF0ZSxjPWZ1bmN0aW9uKCl7cmV0dXJuKHAubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGMuZG91YmxlPWZ1bmN0aW9uKCl7ZG8gdmFyIGg9cC5uZXh0KCk+Pj4xMSxtPShwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYsZj0oaCttKS8oMTw8MjEpO3doaWxlKGY9PT0wKTtyZXR1cm4gZn0sYy5pbnQzMj1wLm5leHQsYy5xdWljaz1jLGQmJih0eXBlb2YgZD09XCJvYmplY3RcIiYmaShkLHApLGMuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gaShwLHt9KX0pLGN9YSYmYS5leHBvcnRzP2EuZXhwb3J0cz1vOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gb30pOnRoaXMueG9yd293PW99KShlLHR5cGVvZiB0PT1cIm9iamVjdFwiJiZ0LHR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lKX0pLFJSPVZ0KChlLHQpPT57KGZ1bmN0aW9uKG4sYSxyKXtmdW5jdGlvbiBzKGwpe3ZhciB1PXRoaXM7dS5uZXh0PWZ1bmN0aW9uKCl7dmFyIGQ9dS54LGM9dS5pLGgsbSxmO3JldHVybiBoPWRbY10saF49aD4+PjcsbT1oXmg8PDI0LGg9ZFtjKzEmN10sbV49aF5oPj4+MTAsaD1kW2MrMyY3XSxtXj1oXmg+Pj4zLGg9ZFtjKzQmN10sbV49aF5oPDw3LGg9ZFtjKzcmN10saD1oXmg8PDEzLG1ePWheaDw8OSxkW2NdPW0sdS5pPWMrMSY3LG19O2Z1bmN0aW9uIHAoZCxjKXt2YXIgaCxtLGY9W107aWYoYz09PShjfDApKW09ZlswXT1jO2Vsc2UgZm9yKGM9XCJcIitjLGg9MDtoPGMubGVuZ3RoOysraClmW2gmN109ZltoJjddPDwxNV5jLmNoYXJDb2RlQXQoaCkrZltoKzEmN108PDEzO2Zvcig7Zi5sZW5ndGg8ODspZi5wdXNoKDApO2ZvcihoPTA7aDw4JiZmW2hdPT09MDsrK2gpO2ZvcihoPT04P209Zls3XT0tMTptPWZbaF0sZC54PWYsZC5pPTAsaD0yNTY7aD4wOy0taClkLm5leHQoKX1wKHUsbCl9ZnVuY3Rpb24gaShsLHUpe3JldHVybiB1Lng9bC54LnNsaWNlKCksdS5pPWwuaSx1fWZ1bmN0aW9uIG8obCx1KXtsPT1udWxsJiYobD0rbmV3IERhdGUpO3ZhciBwPW5ldyBzKGwpLGQ9dSYmdS5zdGF0ZSxjPWZ1bmN0aW9uKCl7cmV0dXJuKHAubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGMuZG91YmxlPWZ1bmN0aW9uKCl7ZG8gdmFyIGg9cC5uZXh0KCk+Pj4xMSxtPShwLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYsZj0oaCttKS8oMTw8MjEpO3doaWxlKGY9PT0wKTtyZXR1cm4gZn0sYy5pbnQzMj1wLm5leHQsYy5xdWljaz1jLGQmJihkLngmJmkoZCxwKSxjLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGkocCx7fSl9KSxjfWEmJmEuZXhwb3J0cz9hLmV4cG9ydHM9bzpyJiZyLmFtZD9yKGZ1bmN0aW9uKCl7cmV0dXJuIG99KTp0aGlzLnhvcnNoaWZ0Nz1vfSkoZSx0eXBlb2YgdD09XCJvYmplY3RcIiYmdCx0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZSl9KSxNUj1WdCgoZSx0KT0+eyhmdW5jdGlvbihuLGEscil7ZnVuY3Rpb24gcyhsKXt2YXIgdT10aGlzO3UubmV4dD1mdW5jdGlvbigpe3ZhciBkPXUudyxjPXUuWCxoPXUuaSxtLGY7cmV0dXJuIHUudz1kPWQrMTY0MDUzMTUyN3wwLGY9Y1toKzM0JjEyN10sbT1jW2g9aCsxJjEyN10sZl49Zjw8MTMsbV49bTw8MTcsZl49Zj4+PjE1LG1ePW0+Pj4xMixmPWNbaF09Zl5tLHUuaT1oLGYrKGReZD4+PjE2KXwwfTtmdW5jdGlvbiBwKGQsYyl7dmFyIGgsbSxmLGcsYix5PVtdLHg9MTI4O2ZvcihjPT09KGN8MCk/KG09YyxjPW51bGwpOihjPWMrXCJcXDBcIixtPTAseD1NYXRoLm1heCh4LGMubGVuZ3RoKSksZj0wLGc9LTMyO2c8eDsrK2cpYyYmKG1ePWMuY2hhckNvZGVBdCgoZyszMiklYy5sZW5ndGgpKSxnPT09MCYmKGI9bSksbV49bTw8MTAsbV49bT4+PjE1LG1ePW08PDQsbV49bT4+PjEzLGc+PTAmJihiPWIrMTY0MDUzMTUyN3wwLGg9eVtnJjEyN11ePW0rYixmPWg9PTA/ZisxOjApO2ZvcihmPj0xMjgmJih5WyhjJiZjLmxlbmd0aHx8MCkmMTI3XT0tMSksZj0xMjcsZz00KjEyODtnPjA7LS1nKW09eVtmKzM0JjEyN10saD15W2Y9ZisxJjEyN10sbV49bTw8MTMsaF49aDw8MTcsbV49bT4+PjE1LGhePWg+Pj4xMix5W2ZdPW1eaDtkLnc9YixkLlg9eSxkLmk9Zn1wKHUsbCl9ZnVuY3Rpb24gaShsLHUpe3JldHVybiB1Lmk9bC5pLHUudz1sLncsdS5YPWwuWC5zbGljZSgpLHV9ZnVuY3Rpb24gbyhsLHUpe2w9PW51bGwmJihsPStuZXcgRGF0ZSk7dmFyIHA9bmV3IHMobCksZD11JiZ1LnN0YXRlLGM9ZnVuY3Rpb24oKXtyZXR1cm4ocC5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gYy5kb3VibGU9ZnVuY3Rpb24oKXtkbyB2YXIgaD1wLm5leHQoKT4+PjExLG09KHAubmV4dCgpPj4+MCkvNDI5NDk2NzI5NixmPShoK20pLygxPDwyMSk7d2hpbGUoZj09PTApO3JldHVybiBmfSxjLmludDMyPXAubmV4dCxjLnF1aWNrPWMsZCYmKGQuWCYmaShkLHApLGMuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gaShwLHt9KX0pLGN9YSYmYS5leHBvcnRzP2EuZXhwb3J0cz1vOnImJnIuYW1kP3IoZnVuY3Rpb24oKXtyZXR1cm4gb30pOnRoaXMueG9yNDA5Nj1vfSkoZSx0eXBlb2YgdD09XCJvYmplY3RcIiYmdCx0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZSl9KSxPUj1WdCgoZSx0KT0+eyhmdW5jdGlvbihuLGEscil7ZnVuY3Rpb24gcyhsKXt2YXIgdT10aGlzLHA9XCJcIjt1Lm5leHQ9ZnVuY3Rpb24oKXt2YXIgYz11LmIsaD11LmMsbT11LmQsZj11LmE7cmV0dXJuIGM9Yzw8MjVeYz4+PjdeaCxoPWgtbXwwLG09bTw8MjRebT4+PjheZixmPWYtY3wwLHUuYj1jPWM8PDIwXmM+Pj4xMl5oLHUuYz1oPWgtbXwwLHUuZD1tPDwxNl5oPj4+MTZeZix1LmE9Zi1jfDB9LHUuYT0wLHUuYj0wLHUuYz0tMTY0MDUzMTUyNyx1LmQ9MTM2NzEzMDU1MSxsPT09TWF0aC5mbG9vcihsKT8odS5hPWwvNDI5NDk2NzI5NnwwLHUuYj1sfDApOnArPWw7Zm9yKHZhciBkPTA7ZDxwLmxlbmd0aCsyMDtkKyspdS5iXj1wLmNoYXJDb2RlQXQoZCl8MCx1Lm5leHQoKX1mdW5jdGlvbiBpKGwsdSl7cmV0dXJuIHUuYT1sLmEsdS5iPWwuYix1LmM9bC5jLHUuZD1sLmQsdX1mdW5jdGlvbiBvKGwsdSl7dmFyIHA9bmV3IHMobCksZD11JiZ1LnN0YXRlLGM9ZnVuY3Rpb24oKXtyZXR1cm4ocC5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gYy5kb3VibGU9ZnVuY3Rpb24oKXtkbyB2YXIgaD1wLm5leHQoKT4+PjExLG09KHAubmV4dCgpPj4+MCkvNDI5NDk2NzI5NixmPShoK20pLygxPDwyMSk7d2hpbGUoZj09PTApO3JldHVybiBmfSxjLmludDMyPXAubmV4dCxjLnF1aWNrPWMsZCYmKHR5cGVvZiBkPT1cIm9iamVjdFwiJiZpKGQscCksYy5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBpKHAse30pfSksY31hJiZhLmV4cG9ydHM/YS5leHBvcnRzPW86ciYmci5hbWQ/cihmdW5jdGlvbigpe3JldHVybiBvfSk6dGhpcy50eWNoZWk9b30pKGUsdHlwZW9mIHQ9PVwib2JqZWN0XCImJnQsdHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUpfSksUFI9VnQoKCk9Pnt9KSxMUj1WdCgoZSx0KT0+eyhmdW5jdGlvbihuLGEscil7dmFyIHM9MjU2LGk9NixvPTUyLGw9XCJyYW5kb21cIix1PXIucG93KHMsaSkscD1yLnBvdygyLG8pLGQ9cCoyLGM9cy0xLGg7ZnVuY3Rpb24gbShJLE4sQyl7dmFyIF89W107Tj1OPT0hMD97ZW50cm9weTohMH06Tnx8e307dmFyIEY9eShiKE4uZW50cm9weT9bSSx2KGEpXTpJPT1udWxsP3goKTpJLDMpLF8pLEQ9bmV3IGYoXyksJD1mdW5jdGlvbigpe2Zvcih2YXIgUz1ELmcoaSksTT11LEI9MDtTPHA7KVM9KFMrQikqcyxNKj1zLEI9RC5nKDEpO2Zvcig7Uz49ZDspUy89MixNLz0yLEI+Pj49MTtyZXR1cm4oUytCKS9NfTtyZXR1cm4gJC5pbnQzMj1mdW5jdGlvbigpe3JldHVybiBELmcoNCl8MH0sJC5xdWljaz1mdW5jdGlvbigpe3JldHVybiBELmcoNCkvNDI5NDk2NzI5Nn0sJC5kb3VibGU9JCx5KHYoRC5TKSxhKSwoTi5wYXNzfHxDfHxmdW5jdGlvbihTLE0sQixVKXtyZXR1cm4gVSYmKFUuUyYmZyhVLEQpLFMuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gZyhELHt9KX0pLEI/KHJbbF09UyxNKTpTfSkoJCxGLFwiZ2xvYmFsXCJpbiBOP04uZ2xvYmFsOnRoaXM9PXIsTi5zdGF0ZSl9ZnVuY3Rpb24gZihJKXt2YXIgTixDPUkubGVuZ3RoLF89dGhpcyxGPTAsRD1fLmk9Xy5qPTAsJD1fLlM9W107Zm9yKEN8fChJPVtDKytdKTtGPHM7KSRbRl09RisrO2ZvcihGPTA7RjxzO0YrKykkW0ZdPSRbRD1jJkQrSVtGJUNdKyhOPSRbRl0pXSwkW0RdPU47KF8uZz1mdW5jdGlvbihTKXtmb3IodmFyIE0sQj0wLFU9Xy5pLEg9Xy5qLHE9Xy5TO1MtLTspTT1xW1U9YyZVKzFdLEI9QipzK3FbYyYocVtVXT1xW0g9YyZIK01dKSsocVtIXT1NKV07cmV0dXJuIF8uaT1VLF8uaj1ILEJ9KShzKX1mdW5jdGlvbiBnKEksTil7cmV0dXJuIE4uaT1JLmksTi5qPUkuaixOLlM9SS5TLnNsaWNlKCksTn1mdW5jdGlvbiBiKEksTil7dmFyIEM9W10sXz10eXBlb2YgSSxGO2lmKE4mJl89PVwib2JqZWN0XCIpZm9yKEYgaW4gSSl0cnl7Qy5wdXNoKGIoSVtGXSxOLTEpKX1jYXRjaChEKXt9cmV0dXJuIEMubGVuZ3RoP0M6Xz09XCJzdHJpbmdcIj9JOkkrXCJcXDBcIn1mdW5jdGlvbiB5KEksTil7Zm9yKHZhciBDPUkrXCJcIixfLEY9MDtGPEMubGVuZ3RoOylOW2MmRl09YyYoX149TltjJkZdKjE5KStDLmNoYXJDb2RlQXQoRisrKTtyZXR1cm4gdihOKX1mdW5jdGlvbiB4KCl7dHJ5e3ZhciBJO3JldHVybiBoJiYoST1oLnJhbmRvbUJ5dGVzKT9JPUkocyk6KEk9bmV3IFVpbnQ4QXJyYXkocyksKG4uY3J5cHRvfHxuLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMoSSkpLHYoSSl9Y2F0Y2goXyl7dmFyIE49bi5uYXZpZ2F0b3IsQz1OJiZOLnBsdWdpbnM7cmV0dXJuWytuZXcgRGF0ZSxuLEMsbi5zY3JlZW4sdihhKV19fWZ1bmN0aW9uIHYoSSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoMCxJKX1pZih5KHIucmFuZG9tKCksYSksdHlwZW9mIHQ9PVwib2JqZWN0XCImJnQuZXhwb3J0cyl7dC5leHBvcnRzPW07dHJ5e2g9UFIoKX1jYXRjaChJKXt9fWVsc2UgdHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kP2RlZmluZShmdW5jdGlvbigpe3JldHVybiBtfSk6cltcInNlZWRcIitsXT1tfSkodHlwZW9mIHNlbGYhPVwidW5kZWZpbmVkXCI/c2VsZjplLFtdLE1hdGgpfSksYm09VnQoKGUsdCk9Pnt2YXIgbj1GUigpLGE9JFIoKSxyPURSKCkscz1SUigpLGk9TVIoKSxvPU9SKCksbD1MUigpO2wuYWxlYT1uLGwueG9yMTI4PWEsbC54b3J3b3c9cixsLnhvcnNoaWZ0Nz1zLGwueG9yNDA5Nj1pLGwudHljaGVpPW8sdC5leHBvcnRzPWx9KSxGUz1WdCgoKT0+e30pLEl2PVZ0KCgpPT57fSksJFM9VnQoKCk9Pnt9KSx6Uj1WdCgoKT0+e30pLFdSPVZ0KCgpPT57fSksQlI9VnQoKCk9Pnt9KSxWUj1WdCgoZSx0KT0+e3ZhciBuPSgoKT0+e3ZhciBhPXR5cGVvZiBkb2N1bWVudCE9XCJ1bmRlZmluZWRcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDA7cmV0dXJuIHR5cGVvZiBfX2ZpbGVuYW1lIT1cInVuZGVmaW5lZFwiJiYoYT1hfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbihyKXtyPXJ8fHt9O2Z1bmN0aW9uIHMoKXtyZXR1cm4gdWUuYnVmZmVyIT1SZSYmdXQodWUuYnVmZmVyKSxndH1mdW5jdGlvbiBpKCl7cmV0dXJuIHVlLmJ1ZmZlciE9UmUmJnV0KHVlLmJ1ZmZlciksR259ZnVuY3Rpb24gbygpe3JldHVybiB1ZS5idWZmZXIhPVJlJiZ1dCh1ZS5idWZmZXIpLE90fWZ1bmN0aW9uIGwoKXtyZXR1cm4gdWUuYnVmZmVyIT1SZSYmdXQodWUuYnVmZmVyKSx1bn1mdW5jdGlvbiB1KCl7cmV0dXJuIHVlLmJ1ZmZlciE9UmUmJnV0KHVlLmJ1ZmZlciksRm59ZnVuY3Rpb24gcCgpe3JldHVybiB1ZS5idWZmZXIhPVJlJiZ1dCh1ZS5idWZmZXIpLG9hfWZ1bmN0aW9uIGQoKXtyZXR1cm4gdWUuYnVmZmVyIT1SZSYmdXQodWUuYnVmZmVyKSwkbn12YXIgYz10eXBlb2YgciE9XCJ1bmRlZmluZWRcIj9yOnt9LGgsbTtjLnJlYWR5PW5ldyBQcm9taXNlKGZ1bmN0aW9uKFIsail7aD1SLG09an0pO3ZhciBmO3R5cGVvZiBwcm9jZXNzIT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLmxpc3RlbmVycyYmKGY9e3VuY2F1Z2h0RXhjZXB0aW9uOnByb2Nlc3MubGlzdGVuZXJzKFwidW5jYXVnaHRFeGNlcHRpb25cIiksdW5oYW5kbGVkUmVqZWN0aW9uOnByb2Nlc3MubGlzdGVuZXJzKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpfSk7dmFyIGc9T2JqZWN0LmFzc2lnbih7fSxjKSxiPVtdLHk9XCIuL3RoaXMucHJvZ3JhbVwiLHg9KFIsaik9Pnt0aHJvdyBqfSx2PXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIsST10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLE49dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiLEM9Yy5FTlZJUk9OTUVOVF9JU19QVEhSRUFEfHwhMSxfPVwiXCI7ZnVuY3Rpb24gRihSKXtyZXR1cm4gYy5sb2NhdGVGaWxlP2MubG9jYXRlRmlsZShSLF8pOl8rUn12YXIgRCwkLFMsTTtmdW5jdGlvbiBCKFIpe1IgaW5zdGFuY2VvZiBHc3x8SihcImV4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogXCIrUil9aWYoTil7dmFyIFU9SXYoKSxIPSRTKCk7ST9fPUguZGlybmFtZShfKStcIi9cIjpfPV9fZGlybmFtZStcIi9cIixEPShqLGxlKT0+KGo9Z2woaik/bmV3IFVSTChqKTpILm5vcm1hbGl6ZShqKSxVLnJlYWRGaWxlU3luYyhqLGxlP3ZvaWQgMDpcInV0ZjhcIikpLFM9aj0+e3ZhciBsZT1EKGosITApO3JldHVybiBsZS5idWZmZXJ8fChsZT1uZXcgVWludDhBcnJheShsZSkpLGxlfSwkPShqLGxlLE5lKT0+e2o9Z2woaik/bmV3IFVSTChqKTpILm5vcm1hbGl6ZShqKSxVLnJlYWRGaWxlKGosZnVuY3Rpb24oTWUsRmUpe01lP05lKE1lKTpsZShGZS5idWZmZXIpfSl9LHByb2Nlc3MuYXJndi5sZW5ndGg+MSYmKHk9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLGI9cHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLGZ1bmN0aW9uKGope2lmKCEoaiBpbnN0YW5jZW9mIEdzKSl0aHJvdyBqfSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLGZ1bmN0aW9uKGope3Rocm93IGp9KSx4PShqLGxlKT0+e2lmKElhKCkpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1qLGxlO0IobGUpLHByb2Nlc3MuZXhpdChqKX0sYy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTtsZXQgUjt0cnl7Uj16UigpfWNhdGNoKGope3Rocm93IGNvbnNvbGUuZXJyb3IoJ1RoZSBcIndvcmtlcl90aHJlYWRzXCIgbW9kdWxlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBub2RlLmpzIGJ1aWxkIC0gcGVyaGFwcyBhIG5ld2VyIHZlcnNpb24gaXMgbmVlZGVkPycpLGp9Z2xvYmFsLldvcmtlcj1SLldvcmtlcn1lbHNlKHZ8fEkpJiYoST9fPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQhPVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihfPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSx0eXBlb2YgYSE9XCJ1bmRlZmluZWRcIiYmYSYmKF89YSksXy5pbmRleE9mKFwiYmxvYjpcIikhPT0wP189Xy5zdWJzdHIoMCxfLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOl89XCJcIixOfHwoRD1SPT57dmFyIGo9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBqLm9wZW4oXCJHRVRcIixSLCExKSxqLnNlbmQobnVsbCksai5yZXNwb25zZVRleHR9LEkmJihTPVI9Pnt2YXIgaj1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGoub3BlbihcIkdFVFwiLFIsITEpLGoucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixqLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoai5yZXNwb25zZSl9KSwkPShSLGosbGUpPT57dmFyIE5lPW5ldyBYTUxIdHRwUmVxdWVzdDtOZS5vcGVuKFwiR0VUXCIsUiwhMCksTmUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixOZS5vbmxvYWQ9KCk9PntpZihOZS5zdGF0dXM9PTIwMHx8TmUuc3RhdHVzPT0wJiZOZS5yZXNwb25zZSl7aihOZS5yZXNwb25zZSk7cmV0dXJufWxlKCl9LE5lLm9uZXJyb3I9bGUsTmUuc2VuZChudWxsKX0pLE09Uj0+ZG9jdW1lbnQudGl0bGU9Uik7TiYmdHlwZW9mIHBlcmZvcm1hbmNlPT1cInVuZGVmaW5lZFwiJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPVdSKCkucGVyZm9ybWFuY2UpO3ZhciBxPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksSz1jb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtOJiYocT1SPT5VLndyaXRlU3luYygxLFIrYFxuYCksSz1SPT5VLndyaXRlU3luYygyLFIrYFxuYCkpO3ZhciBaPWMucHJpbnR8fHEsSj1jLnByaW50RXJyfHxLO09iamVjdC5hc3NpZ24oYyxnKSxnPW51bGwsYy5hcmd1bWVudHMmJihiPWMuYXJndW1lbnRzKSxjLnRoaXNQcm9ncmFtJiYoeT1jLnRoaXNQcm9ncmFtKSxjLnF1aXQmJih4PWMucXVpdCk7dmFyIGVlPTQsYWU9QXRvbWljcy5sb2FkLHRlPUF0b21pY3Muc3RvcmUsc2U9QXRvbWljcy5jb21wYXJlRXhjaGFuZ2UsaWU7Yy53YXNtQmluYXJ5JiYoaWU9Yy53YXNtQmluYXJ5KTt2YXIgdmU9Yy5ub0V4aXRSdW50aW1lfHwhMDt0eXBlb2YgV2ViQXNzZW1ibHkhPVwib2JqZWN0XCImJlVzKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgdWUseWUsa2U9ITEsU2U7ZnVuY3Rpb24gTGUoUixqKXtSfHxVcyhqKX12YXIgVWU9dHlwZW9mIFRleHREZWNvZGVyIT1cInVuZGVmaW5lZFwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIG10KFIsaixsZSl7aj4+Pj0wO2Zvcih2YXIgTmU9aitsZSxNZT1qO1JbTWVdJiYhKE1lPj1OZSk7KSsrTWU7aWYoTWUtaj4xNiYmUi5idWZmZXImJlVlKXJldHVybiBVZS5kZWNvZGUoUi5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcj9SLnNsaWNlKGosTWUpOlIuc3ViYXJyYXkoaixNZSkpO2Zvcih2YXIgRmU9XCJcIjtqPE1lOyl7dmFyIG1lPVJbaisrXTtpZighKG1lJjEyOCkpe0ZlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG1lKTtjb250aW51ZX12YXIgd2U9UltqKytdJjYzO2lmKChtZSYyMjQpPT0xOTIpe0ZlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKChtZSYzMSk8PDZ8d2UpO2NvbnRpbnVlfXZhciBUdD1SW2orK10mNjM7aWYoKG1lJjI0MCk9PTIyND9tZT0obWUmMTUpPDwxMnx3ZTw8NnxUdDptZT0obWUmNyk8PDE4fHdlPDwxMnxUdDw8NnxSW2orK10mNjMsbWU8NjU1MzYpRmUrPVN0cmluZy5mcm9tQ2hhckNvZGUobWUpO2Vsc2V7dmFyIHVhPW1lLTY1NTM2O0ZlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fHVhPj4xMCw1NjMyMHx1YSYxMDIzKX19cmV0dXJuIEZlfWZ1bmN0aW9uIHN0KFIsail7cmV0dXJuIFI+Pj49MCxSP210KGkoKSxSLGopOlwiXCJ9ZnVuY3Rpb24gdHQoUixqLGxlLE5lKXtpZihsZT4+Pj0wLCEoTmU+MCkpcmV0dXJuIDA7Zm9yKHZhciBNZT1sZSxGZT1sZStOZS0xLG1lPTA7bWU8Ui5sZW5ndGg7KyttZSl7dmFyIHdlPVIuY2hhckNvZGVBdChtZSk7aWYod2U+PTU1Mjk2JiZ3ZTw9NTczNDMpe3ZhciBUdD1SLmNoYXJDb2RlQXQoKyttZSk7d2U9NjU1MzYrKCh3ZSYxMDIzKTw8MTApfFR0JjEwMjN9aWYod2U8PTEyNyl7aWYobGU+PUZlKWJyZWFrO2pbbGUrKz4+PjBdPXdlfWVsc2UgaWYod2U8PTIwNDcpe2lmKGxlKzE+PUZlKWJyZWFrO2pbbGUrKz4+PjBdPTE5Mnx3ZT4+NixqW2xlKys+Pj4wXT0xMjh8d2UmNjN9ZWxzZSBpZih3ZTw9NjU1MzUpe2lmKGxlKzI+PUZlKWJyZWFrO2pbbGUrKz4+PjBdPTIyNHx3ZT4+MTIsaltsZSsrPj4+MF09MTI4fHdlPj42JjYzLGpbbGUrKz4+PjBdPTEyOHx3ZSY2M31lbHNle2lmKGxlKzM+PUZlKWJyZWFrO2pbbGUrKz4+PjBdPTI0MHx3ZT4+MTgsaltsZSsrPj4+MF09MTI4fHdlPj4xMiY2MyxqW2xlKys+Pj4wXT0xMjh8d2U+PjYmNjMsaltsZSsrPj4+MF09MTI4fHdlJjYzfX1yZXR1cm4galtsZT4+PjBdPTAsbGUtTWV9ZnVuY3Rpb24gbnQoUixqLGxlKXtyZXR1cm4gdHQoUixpKCksaixsZSl9dmFyIFJlLGd0LEduLE90LGlhLHVuLEZuLG9hLCRuO0MmJihSZT1jLmJ1ZmZlcik7ZnVuY3Rpb24gdXQoUil7UmU9UixjLkhFQVA4PWd0PW5ldyBJbnQ4QXJyYXkoUiksYy5IRUFQMTY9T3Q9bmV3IEludDE2QXJyYXkoUiksYy5IRUFQMzI9dW49bmV3IEludDMyQXJyYXkoUiksYy5IRUFQVTg9R249bmV3IFVpbnQ4QXJyYXkoUiksYy5IRUFQVTE2PWlhPW5ldyBVaW50MTZBcnJheShSKSxjLkhFQVBVMzI9Rm49bmV3IFVpbnQzMkFycmF5KFIpLGMuSEVBUEYzMj1vYT1uZXcgRmxvYXQzMkFycmF5KFIpLGMuSEVBUEY2ND0kbj1uZXcgRmxvYXQ2NEFycmF5KFIpfXZhciBEbj1jLklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZihDKXVlPWMud2FzbU1lbW9yeSxSZT1jLmJ1ZmZlcjtlbHNlIGlmKGMud2FzbU1lbW9yeSl1ZT1jLndhc21NZW1vcnk7ZWxzZSBpZih1ZT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOkRuLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSksISh1ZS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpdGhyb3cgSihcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKSxOJiZKKFwiKG9uIG5vZGUgeW91IG1heSBuZWVkOiAtLWV4cGVyaW1lbnRhbC13YXNtLXRocmVhZHMgLS1leHBlcmltZW50YWwtd2FzbS1idWxrLW1lbW9yeSBhbmQvb3IgcmVjZW50IHZlcnNpb24pXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTt1ZSYmKFJlPXVlLmJ1ZmZlciksRG49UmUuYnl0ZUxlbmd0aCx1dChSZSk7dmFyIEhuLHhyPVtdLG1sPVtdLFphPVtdLFdwPSExO2Z1bmN0aW9uIElhKCl7cmV0dXJuIHZlfWZ1bmN0aW9uIFVyKCl7aWYoYy5wcmVSdW4pZm9yKHR5cGVvZiBjLnByZVJ1bj09XCJmdW5jdGlvblwiJiYoYy5wcmVSdW49W2MucHJlUnVuXSk7Yy5wcmVSdW4ubGVuZ3RoOylTZyhjLnByZVJ1bi5zaGlmdCgpKTtWcCh4cil9ZnVuY3Rpb24gSnQoKXtXcD0hMCwhQyYmVnAobWwpfWZ1bmN0aW9uIEhkKCl7aWYoIUMpe2lmKGMucG9zdFJ1bilmb3IodHlwZW9mIGMucG9zdFJ1bj09XCJmdW5jdGlvblwiJiYoYy5wb3N0UnVuPVtjLnBvc3RSdW5dKTtjLnBvc3RSdW4ubGVuZ3RoOylSayhjLnBvc3RSdW4uc2hpZnQoKSk7VnAoWmEpfX1mdW5jdGlvbiBTZyhSKXt4ci51bnNoaWZ0KFIpfWZ1bmN0aW9uIE5nKFIpe21sLnVuc2hpZnQoUil9ZnVuY3Rpb24gUmsoUil7WmEudW5zaGlmdChSKX12YXIgR3I9MCxmbD1udWxsLHZyPW51bGw7ZnVuY3Rpb24gVGcoUil7R3IrKyxjLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhHcil9ZnVuY3Rpb24gamQoUil7aWYoR3ItLSxjLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhHciksR3I9PTAmJihmbCE9PW51bGwmJihjbGVhckludGVydmFsKGZsKSxmbD1udWxsKSx2cikpe3ZhciBqPXZyO3ZyPW51bGwsaigpfX1mdW5jdGlvbiBVcyhSKXtjLm9uQWJvcnQmJmMub25BYm9ydChSKSxSPVwiQWJvcnRlZChcIitSK1wiKVwiLEooUiksa2U9ITAsU2U9MSxSKz1cIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIjt2YXIgaj1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKFIpO3Rocm93IG0oaiksan12YXIgQ2c9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7ZnVuY3Rpb24gcWQoUil7cmV0dXJuIFIuc3RhcnRzV2l0aChDZyl9ZnVuY3Rpb24gZ2woUil7cmV0dXJuIFIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil9dmFyIGduO2duPVwidGZqcy1iYWNrZW5kLXdhc20tdGhyZWFkZWQtc2ltZC53YXNtXCIscWQoZ24pfHwoZ249RihnbikpO2Z1bmN0aW9uIEtkKFIpe3RyeXtpZihSPT1nbiYmaWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KGllKTtpZihTKXJldHVybiBTKFIpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKGope1VzKGopfX1mdW5jdGlvbiBFZygpe2lmKCFpZSYmKHZ8fEkpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIWdsKGduKSlyZXR1cm4gZmV0Y2goZ24se2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24oUil7aWYoIVIub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2duK1wiJ1wiO3JldHVybiBSLmFycmF5QnVmZmVyKCl9KS5jYXRjaChmdW5jdGlvbigpe3JldHVybiBLZChnbil9KTtpZigkKXJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihSLGopeyQoZ24sZnVuY3Rpb24obGUpe1IobmV3IFVpbnQ4QXJyYXkobGUpKX0sail9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBLZChnbil9KX1mdW5jdGlvbiBfZygpe3ZhciBSPXtlbnY6b2gsd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTpvaH07ZnVuY3Rpb24gaihtZSx3ZSl7dmFyIFR0PW1lLmV4cG9ydHM7aWYoYy5hc209VHQsTGcoYy5hc20uX2Vtc2NyaXB0ZW5fdGxzX2luaXQpLEhuPWMuYXNtLl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUsTmcoYy5hc20uX193YXNtX2NhbGxfY3RvcnMpLHllPXdlLCFDKXt2YXIgdWE9QWUudW51c2VkV29ya2Vycy5sZW5ndGg7QWUudW51c2VkV29ya2Vycy5mb3JFYWNoKGZ1bmN0aW9uKGtyKXtBZS5sb2FkV2FzbU1vZHVsZVRvV29ya2VyKGtyLGZ1bmN0aW9uKCl7LS11YXx8amQoXCJ3YXNtLWluc3RhbnRpYXRlXCIpfSl9KX19Q3x8VGcoXCJ3YXNtLWluc3RhbnRpYXRlXCIpO2Z1bmN0aW9uIGxlKG1lKXtqKG1lLmluc3RhbmNlLG1lLm1vZHVsZSl9ZnVuY3Rpb24gTmUobWUpe3JldHVybiBFZygpLnRoZW4oZnVuY3Rpb24od2Upe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3ZSxSKX0pLnRoZW4oZnVuY3Rpb24od2Upe3JldHVybiB3ZX0pLnRoZW4obWUsZnVuY3Rpb24od2Upe0ooXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIit3ZSksVXMod2UpfSl9ZnVuY3Rpb24gTWUoKXtyZXR1cm4haWUmJnR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZz09XCJmdW5jdGlvblwiJiYhcWQoZ24pJiYhZ2woZ24pJiYhTiYmdHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCI/ZmV0Y2goZ24se2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24obWUpe3ZhciB3ZT1XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhtZSxSKTtyZXR1cm4gd2UudGhlbihsZSxmdW5jdGlvbihUdCl7cmV0dXJuIEooXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrVHQpLEooXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxOZShsZSl9KX0pOk5lKGxlKX1pZihjLmluc3RhbnRpYXRlV2FzbSl0cnl7dmFyIEZlPWMuaW5zdGFudGlhdGVXYXNtKFIsaik7cmV0dXJuIEZlfWNhdGNoKG1lKXtKKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrbWUpLG0obWUpfXJldHVybiBNZSgpLmNhdGNoKG0pLHt9fXZhciBNayxPayxYZD17fTtmdW5jdGlvbiBHcyhSKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitSK1wiKVwiLHRoaXMuc3RhdHVzPVJ9ZnVuY3Rpb24gQWcoUil7dmFyIGo9QWUucHRocmVhZHNbUl07ZGVsZXRlIEFlLnB0aHJlYWRzW1JdLGoudGVybWluYXRlKCksZXgoUiksQWUucnVubmluZ1dvcmtlcnMuc3BsaWNlKEFlLnJ1bm5pbmdXb3JrZXJzLmluZGV4T2YoaiksMSksai5wdGhyZWFkX3B0cj0wfWZ1bmN0aW9uIEZnKFIpe3ZhciBqPUFlLnB0aHJlYWRzW1JdO2oucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSl9ZnVuY3Rpb24gQnAoUil7dmFyIGo9QWUucHRocmVhZHNbUl07TGUoaiksQWUucmV0dXJuV29ya2VyVG9Qb29sKGopfWZ1bmN0aW9uICRnKFIpe3ZhciBqPUFlLmdldE5ld1dvcmtlcigpO2lmKCFqKXJldHVybiA2O0FlLnJ1bm5pbmdXb3JrZXJzLnB1c2goaiksQWUucHRocmVhZHNbUi5wdGhyZWFkX3B0cl09aixqLnB0aHJlYWRfcHRyPVIucHRocmVhZF9wdHI7dmFyIGxlPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOlIuc3RhcnRSb3V0aW5lLGFyZzpSLmFyZyxwdGhyZWFkX3B0cjpSLnB0aHJlYWRfcHRyfTtyZXR1cm4gai5ydW5QdGhyZWFkPSgpPT57TiYmai5yZWYoKSxqLnBvc3RNZXNzYWdlKGxlLFIudHJhbnNmZXJMaXN0KSxkZWxldGUgai5ydW5QdGhyZWFkfSxqLmxvYWRlZCYmai5ydW5QdGhyZWFkKCksMH12YXIgWWQ9e3ZhcmFyZ3M6dm9pZCAwLGdldDpmdW5jdGlvbigpe1lkLnZhcmFyZ3MrPTQ7dmFyIFI9bCgpW1lkLnZhcmFyZ3MtND4+PjJdO3JldHVybiBSfSxnZXRTdHI6ZnVuY3Rpb24oUil7dmFyIGo9c3QoUik7cmV0dXJuIGp9fTtmdW5jdGlvbiBaZChSKXtpZihDKXJldHVybiBIcigxLDEsUik7U2U9UixJYSgpfHwoQWUudGVybWluYXRlQWxsVGhyZWFkcygpLGMub25FeGl0JiZjLm9uRXhpdChSKSxrZT0hMCkseChSLG5ldyBHcyhSKSl9ZnVuY3Rpb24gRGcoUixqKXtpZihTZT1SLCFqJiZDKXRocm93IFFkKFIpLFwidW53aW5kXCI7WmQoUil9dmFyIEpkPURnO2Z1bmN0aW9uIFJnKFIpe2lmKFIgaW5zdGFuY2VvZiBHc3x8Uj09XCJ1bndpbmRcIilyZXR1cm4gU2U7eCgxLFIpfXZhciBBZT17dW51c2VkV29ya2VyczpbXSxydW5uaW5nV29ya2VyczpbXSx0bHNJbml0RnVuY3Rpb25zOltdLHB0aHJlYWRzOnt9LGluaXQ6ZnVuY3Rpb24oKXtDP0FlLmluaXRXb3JrZXIoKTpBZS5pbml0TWFpblRocmVhZCgpfSxpbml0TWFpblRocmVhZDpmdW5jdGlvbigpe2Zvcih2YXIgUj04O1ItLTspQWUuYWxsb2NhdGVVbnVzZWRXb3JrZXIoKX0saW5pdFdvcmtlcjpmdW5jdGlvbigpe3ZlPSExfSxzZXRFeGl0U3RhdHVzOmZ1bmN0aW9uKFIpe1NlPVJ9LHRlcm1pbmF0ZUFsbFRocmVhZHM6ZnVuY3Rpb24oKXtmb3IodmFyIFIgb2YgT2JqZWN0LnZhbHVlcyhBZS5wdGhyZWFkcykpQWUucmV0dXJuV29ya2VyVG9Qb29sKFIpO2Zvcih2YXIgUiBvZiBBZS51bnVzZWRXb3JrZXJzKVIudGVybWluYXRlKCk7QWUudW51c2VkV29ya2Vycz1bXX0scmV0dXJuV29ya2VyVG9Qb29sOmZ1bmN0aW9uKFIpe3ZhciBqPVIucHRocmVhZF9wdHI7ZGVsZXRlIEFlLnB0aHJlYWRzW2pdLEFlLnVudXNlZFdvcmtlcnMucHVzaChSKSxBZS5ydW5uaW5nV29ya2Vycy5zcGxpY2UoQWUucnVubmluZ1dvcmtlcnMuaW5kZXhPZihSKSwxKSxSLnB0aHJlYWRfcHRyPTAsTiYmUi51bnJlZigpLGV4KGopfSxyZWNlaXZlT2JqZWN0VHJhbnNmZXI6ZnVuY3Rpb24oUil7fSx0aHJlYWRJbml0VExTOmZ1bmN0aW9uKCl7QWUudGxzSW5pdEZ1bmN0aW9ucy5mb3JFYWNoKFI9PlIoKSl9LGxvYWRXYXNtTW9kdWxlVG9Xb3JrZXI6ZnVuY3Rpb24oUixqKXtSLm9ubWVzc2FnZT1GZT0+e3ZhciBtZT1GZS5kYXRhLHdlPW1lLmNtZDtpZihSLnB0aHJlYWRfcHRyJiYoQWUuY3VycmVudFByb3hpZWRPcGVyYXRpb25DYWxsZXJUaHJlYWQ9Ui5wdGhyZWFkX3B0ciksbWUudGFyZ2V0VGhyZWFkJiZtZS50YXJnZXRUaHJlYWQhPWhoKCkpe3ZhciBUdD1BZS5wdGhyZWFkc1ttZS50YXJnZXRUaHJlYWRdO1R0P1R0LnBvc3RNZXNzYWdlKG1lLG1lLnRyYW5zZmVyTGlzdCk6SignSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrd2UrJ1wiIHRvIHRhcmdldCBwdGhyZWFkICcrbWUudGFyZ2V0VGhyZWFkK1wiLCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFcIiksQWUuY3VycmVudFByb3hpZWRPcGVyYXRpb25DYWxsZXJUaHJlYWQ9dm9pZCAwO3JldHVybn13ZT09PVwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIj9VcChtZS5xdWV1ZSk6d2U9PT1cInNwYXduVGhyZWFkXCI/JGcobWUpOndlPT09XCJjbGVhbnVwVGhyZWFkXCI/QnAobWUudGhyZWFkKTp3ZT09PVwia2lsbFRocmVhZFwiP0FnKG1lLnRocmVhZCk6d2U9PT1cImNhbmNlbFRocmVhZFwiP0ZnKG1lLnRocmVhZCk6d2U9PT1cImxvYWRlZFwiPyhSLmxvYWRlZD0hMCxOJiZSLnVucmVmKCksaiYmaihSKSxSLnJ1blB0aHJlYWQmJlIucnVuUHRocmVhZCgpKTp3ZT09PVwicHJpbnRcIj9aKFwiVGhyZWFkIFwiK21lLnRocmVhZElkK1wiOiBcIittZS50ZXh0KTp3ZT09PVwicHJpbnRFcnJcIj9KKFwiVGhyZWFkIFwiK21lLnRocmVhZElkK1wiOiBcIittZS50ZXh0KTp3ZT09PVwiYWxlcnRcIj9hbGVydChcIlRocmVhZCBcIittZS50aHJlYWRJZCtcIjogXCIrbWUudGV4dCk6bWUudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIj9SLnBvc3RNZXNzYWdlKG1lKTp3ZT09PVwiY2FsbEhhbmRsZXJcIj9jW21lLmhhbmRsZXJdKC4uLm1lLmFyZ3MpOndlJiZKKFwid29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kIFwiK3dlKSxBZS5jdXJyZW50UHJveGllZE9wZXJhdGlvbkNhbGxlclRocmVhZD12b2lkIDB9LFIub25lcnJvcj1GZT0+e3ZhciBtZT1cIndvcmtlciBzZW50IGFuIGVycm9yIVwiO3Rocm93IEoobWUrXCIgXCIrRmUuZmlsZW5hbWUrXCI6XCIrRmUubGluZW5vK1wiOiBcIitGZS5tZXNzYWdlKSxGZX0sTiYmKFIub24oXCJtZXNzYWdlXCIsZnVuY3Rpb24oRmUpe1Iub25tZXNzYWdlKHtkYXRhOkZlfSl9KSxSLm9uKFwiZXJyb3JcIixmdW5jdGlvbihGZSl7Ui5vbmVycm9yKEZlKX0pLFIub24oXCJkZXRhY2hlZEV4aXRcIixmdW5jdGlvbigpe30pKTt2YXIgbGU9W10sTmU9W1wib25FeGl0XCIsXCJvbkFib3J0XCIsXCJwcmludFwiLFwicHJpbnRFcnJcIl07Zm9yKHZhciBNZSBvZiBOZSljLmhhc093blByb3BlcnR5KE1lKSYmbGUucHVzaChNZSk7Ui5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmxlLHVybE9yQmxvYjpjLm1haW5TY3JpcHRVcmxPckJsb2J8fGEsd2FzbU1lbW9yeTp1ZSx3YXNtTW9kdWxlOnllfSl9LGFsbG9jYXRlVW51c2VkV29ya2VyOmZ1bmN0aW9uKCl7dmFyIFIsaj1GKFwidGZqcy1iYWNrZW5kLXdhc20tdGhyZWFkZWQtc2ltZC53b3JrZXIuanNcIik7Uj1uZXcgV29ya2VyKGopLEFlLnVudXNlZFdvcmtlcnMucHVzaChSKX0sZ2V0TmV3V29ya2VyOmZ1bmN0aW9uKCl7cmV0dXJuIEFlLnVudXNlZFdvcmtlcnMubGVuZ3RoPT0wJiYoQWUuYWxsb2NhdGVVbnVzZWRXb3JrZXIoKSxBZS5sb2FkV2FzbU1vZHVsZVRvV29ya2VyKEFlLnVudXNlZFdvcmtlcnNbMF0pKSxBZS51bnVzZWRXb3JrZXJzLnBvcCgpfX07Yy5QVGhyZWFkPUFlO2Z1bmN0aW9uIFZwKFIpe2Zvcig7Ui5sZW5ndGg+MDspUi5zaGlmdCgpKGMpfWZ1bmN0aW9uIE1nKCl7dmFyIFI9aGgoKSxqPWwoKVtSKzUyPj4+Ml0sbGU9bCgpW1IrNTY+Pj4yXSxOZT1qLWxlO1ZrKGosTmUpLG1oKGopfWMuZXN0YWJsaXNoU3RhY2tTcGFjZT1NZztmdW5jdGlvbiBRZChSKXtpZihDKXJldHVybiBIcigyLDAsUik7dHJ5e0pkKFIpfWNhdGNoKGope1JnKGopfX12YXIgYmw9W107ZnVuY3Rpb24gT2coUil7dmFyIGo9YmxbUl07cmV0dXJuIGp8fChSPj1ibC5sZW5ndGgmJihibC5sZW5ndGg9UisxKSxibFtSXT1qPUhuLmdldChSKSksan1mdW5jdGlvbiBQZyhSLGope3ZhciBsZT1PZyhSKShqKTtJYSgpP0FlLnNldEV4aXRTdGF0dXMobGUpOkJrKGxlKX1jLmludm9rZUVudHJ5UG9pbnQ9UGc7ZnVuY3Rpb24gTGcoUil7QWUudGxzSW5pdEZ1bmN0aW9ucy5wdXNoKFIpfWZ1bmN0aW9uIHpnKFIpe0xrKFIsIUksMSwhdiksQWUudGhyZWFkSW5pdFRMUygpfWZ1bmN0aW9uIFdnKFIpe0M/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6Un0pOkJwKFIpfWZ1bmN0aW9uIGVoKFIsaixsZSxOZSl7cmV0dXJuIEM/SHIoMywxLFIsaixsZSxOZSk6dGgoUixqLGxlLE5lKX1mdW5jdGlvbiB0aChSLGosbGUsTmUpe2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09XCJ1bmRlZmluZWRcIilyZXR1cm4gSihcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpLDY7dmFyIE1lPVtdLEZlPTA7aWYoQyYmKE1lLmxlbmd0aD09PTB8fEZlKSlyZXR1cm4gZWgoUixqLGxlLE5lKTtpZihGZSlyZXR1cm4gRmU7dmFyIG1lPXtzdGFydFJvdXRpbmU6bGUscHRocmVhZF9wdHI6Uixhcmc6TmUsdHJhbnNmZXJMaXN0Ok1lfTtyZXR1cm4gQz8obWUuY21kPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShtZSxNZSksMCk6JGcobWUpfWZ1bmN0aW9uIEJnKCl7cmV0dXJuIDY1NTM2fXZhciBWZz0hMDtmdW5jdGlvbiBVZygpe3JldHVybiBWZ31mdW5jdGlvbiBVcChSKXtBdG9taWNzLnN0b3JlKGwoKSxSPj4yLDEpLGhoKCkmJldrKFIpLEF0b21pY3MuY29tcGFyZUV4Y2hhbmdlKGwoKSxSPj4yLDEsMCl9Yy5leGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlPVVwO2Z1bmN0aW9uIEdnKFIsaixsZSxOZSl7aWYoUj09ailzZXRUaW1lb3V0KCgpPT5VcChOZSkpO2Vsc2UgaWYoQylwb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOlIsY21kOlwicHJvY2Vzc1Byb3h5aW5nUXVldWVcIixxdWV1ZTpOZX0pO2Vsc2V7dmFyIE1lPUFlLnB0aHJlYWRzW1JdO2lmKCFNZSlyZXR1cm47TWUucG9zdE1lc3NhZ2Uoe2NtZDpcInByb2Nlc3NQcm94eWluZ1F1ZXVlXCIscXVldWU6TmV9KX1yZXR1cm4gMX1mdW5jdGlvbiBIZyhSLGosbGUpe3JldHVybi0xfWZ1bmN0aW9uIGpnKCl7VXMoXCJcIil9ZnVuY3Rpb24gSHMoUil7SHMuc2hvd258fChIcy5zaG93bj17fSksSHMuc2hvd25bUl18fChIcy5zaG93bltSXT0xLE4mJihSPVwid2FybmluZzogXCIrUiksSihSKSl9ZnVuY3Rpb24gcWcoKXtOfHxJfHxIcyhcIkJsb2NraW5nIG9uIHRoZSBtYWluIHRocmVhZCBpcyB2ZXJ5IGRhbmdlcm91cywgc2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9wb3J0aW5nL3B0aHJlYWRzLmh0bWwjYmxvY2tpbmctb24tdGhlLW1haW4tYnJvd3Nlci10aHJlYWRcIil9ZnVuY3Rpb24gS2coKXtyZXR1cm4gRGF0ZS5ub3coKX1mdW5jdGlvbiBuaCgpe3JldHVybiA0Mjk0OTAxNzYwfWZ1bmN0aW9uIFhnKCl7cmV0dXJuIG5oKCl9dmFyIEdwO04/R3A9KCk9Pnt2YXIgUj1wcm9jZXNzLmhydGltZSgpO3JldHVybiBSWzBdKjFlMytSWzFdLzFlNn06R3A9KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCk7ZnVuY3Rpb24gWWcoUixqLGxlKXtpKCkuY29weVdpdGhpbihSPj4+MCxqPj4+MCxqK2xlPj4+MCl9ZnVuY3Rpb24gWmcoKXtyZXR1cm4gTj9CUigpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3l9ZnVuY3Rpb24gSmcoUil7dmFyIGo9dHgoKSxsZT1SKCk7cmV0dXJuIG1oKGopLGxlfWZ1bmN0aW9uIEhyKFIsail7dmFyIGxlPWFyZ3VtZW50cy5sZW5ndGgtMixOZT1hcmd1bWVudHM7cmV0dXJuIEpnKCgpPT57Zm9yKHZhciBNZT1sZSxGZT1maChNZSo4KSxtZT1GZT4+Myx3ZT0wO3dlPGxlO3dlKyspe3ZhciBUdD1OZVsyK3dlXTtkKClbbWUrd2U+Pj4wXT1UdH1yZXR1cm4gemsoUixNZSxGZSxqKX0pfXZhciBIcD1bXTtmdW5jdGlvbiBRZyhSLGosbGUpe0hwLmxlbmd0aD1qO2Zvcih2YXIgTmU9bGU+PjMsTWU9MDtNZTxqO01lKyspSHBbTWVdPWQoKVtOZStNZT4+PjBdO3ZhciBGZT1SPDAsbWU9RmU/WGRbLVItMV06bGJbUl07cmV0dXJuIG1lLmFwcGx5KG51bGwsSHApfWZ1bmN0aW9uIGViKFIpe3RyeXtyZXR1cm4gdWUuZ3JvdyhSLVJlLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksdXQodWUuYnVmZmVyKSwxfWNhdGNoKGope319ZnVuY3Rpb24gdGIoUil7dmFyIGo9aSgpLmxlbmd0aDtpZihSPVI+Pj4wLFI8PWopcmV0dXJuITE7dmFyIGxlPW5oKCk7aWYoUj5sZSlyZXR1cm4hMTtsZXQgTmU9KFR0LHVhKT0+VHQrKHVhLVR0JXVhKSV1YTtmb3IodmFyIE1lPTE7TWU8PTQ7TWUqPTIpe3ZhciBGZT1qKigxKy4yL01lKTtGZT1NYXRoLm1pbihGZSxSKzEwMDY2MzI5Nik7dmFyIG1lPU1hdGgubWluKGxlLE5lKE1hdGgubWF4KFIsRmUpLDY1NTM2KSksd2U9ZWIobWUpO2lmKHdlKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIG5iKCl7dGhyb3dcInVud2luZFwifWZ1bmN0aW9uIGFoKFIpe3JldHVybiBDP0hyKDQsMSxSKTo1Mn1mdW5jdGlvbiByaChSLGosbGUsTmUsTWUpe3JldHVybiBDP0hyKDUsMSxSLGosbGUsTmUsTWUpOjcwfXZhciBhYj1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gcmIoUixqKXt2YXIgbGU9YWJbUl07aj09PTB8fGo9PT0xMD8oKFI9PT0xP1o6SikobXQobGUsMCkpLGxlLmxlbmd0aD0wKTpsZS5wdXNoKGopfWZ1bmN0aW9uIHNoKFIsaixsZSxOZSl7aWYoQylyZXR1cm4gSHIoNiwxLFIsaixsZSxOZSk7Zm9yKHZhciBNZT0wLEZlPTA7RmU8bGU7RmUrKyl7dmFyIG1lPXUoKVtqPj4+Ml0sd2U9dSgpW2orND4+PjJdO2orPTg7Zm9yKHZhciBUdD0wO1R0PHdlO1R0KyspcmIoUixpKClbbWUrVHQ+Pj4wXSk7TWUrPXdlfXJldHVybiB1KClbTmU+Pj4yXT1NZSwwfWZ1bmN0aW9uIGloKFIpe3ZhciBqPWNbXCJfXCIrUl07cmV0dXJuIGp9ZnVuY3Rpb24gc2IoUixqKXtzKCkuc2V0KFIsaj4+PjApfWZ1bmN0aW9uIGliKFIsaixsZSxOZSxNZSl7dmFyIEZlPXtzdHJpbmc6cGE9Pnt2YXIgd2w9MDtpZihwYSE9bnVsbCYmcGEhPT0wKXt2YXIgSGs9KHBhLmxlbmd0aDw8MikrMTt3bD1maChIayksbnQocGEsd2wsSGspfXJldHVybiB3bH0sYXJyYXk6cGE9Pnt2YXIgd2w9ZmgocGEubGVuZ3RoKTtyZXR1cm4gc2IocGEsd2wpLHdsfX07ZnVuY3Rpb24gbWUocGEpe3JldHVybiBqPT09XCJzdHJpbmdcIj9zdChwYSk6aj09PVwiYm9vbGVhblwiPyEhcGE6cGF9dmFyIHdlPWloKFIpLFR0PVtdLHVhPTA7aWYoTmUpZm9yKHZhciBrcj0wO2tyPE5lLmxlbmd0aDtrcisrKXt2YXIgR2s9RmVbbGVba3JdXTtHaz8odWE9PT0wJiYodWE9dHgoKSksVHRba3JdPUdrKE5lW2tyXSkpOlR0W2tyXT1OZVtrcl19dmFyIG54PXdlLmFwcGx5KG51bGwsVHQpO2Z1bmN0aW9uIHhSKHBhKXtyZXR1cm4gdWEhPT0wJiZtaCh1YSksbWUocGEpfXJldHVybiBueD14UihueCksbnh9ZnVuY3Rpb24gb2IoUixqLGxlLE5lKXtsZT1sZXx8W107dmFyIE1lPWxlLmV2ZXJ5KG1lPT5tZT09PVwibnVtYmVyXCJ8fG1lPT09XCJib29sZWFuXCIpLEZlPWohPT1cInN0cmluZ1wiO3JldHVybiBGZSYmTWUmJiFOZT9paChSKTpmdW5jdGlvbigpe3JldHVybiBpYihSLGosbGUsYXJndW1lbnRzLE5lKX19QWUuaW5pdCgpO3ZhciBsYj1bbnVsbCxaZCxRZCxlaCxhaCxyaCxzaF0sb2g9e19fZW1zY3JpcHRlbl9pbml0X21haW5fdGhyZWFkX2pzOnpnLF9fZW1zY3JpcHRlbl90aHJlYWRfY2xlYW51cDpXZyxfX3B0aHJlYWRfY3JlYXRlX2pzOnRoLF9lbXNjcmlwdGVuX2RlZmF1bHRfcHRocmVhZF9zdGFja19zaXplOkJnLF9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljOlVnLF9lbXNjcmlwdGVuX25vdGlmeV90YXNrX3F1ZXVlOkdnLF9lbXNjcmlwdGVuX3NldF9vZmZzY3JlZW5jYW52YXNfc2l6ZTpIZyxhYm9ydDpqZyxlbXNjcmlwdGVuX2NoZWNrX2Jsb2NraW5nX2FsbG93ZWQ6cWcsZW1zY3JpcHRlbl9kYXRlX25vdzpLZyxlbXNjcmlwdGVuX2dldF9oZWFwX21heDpYZyxlbXNjcmlwdGVuX2dldF9ub3c6R3AsZW1zY3JpcHRlbl9tZW1jcHlfYmlnOllnLGVtc2NyaXB0ZW5fbnVtX2xvZ2ljYWxfY29yZXM6WmcsZW1zY3JpcHRlbl9yZWNlaXZlX29uX21haW5fdGhyZWFkX2pzOlFnLGVtc2NyaXB0ZW5fcmVzaXplX2hlYXA6dGIsZW1zY3JpcHRlbl91bndpbmRfdG9fanNfZXZlbnRfbG9vcDpuYixleGl0OkpkLGZkX2Nsb3NlOmFoLGZkX3NlZWs6cmgsZmRfd3JpdGU6c2gsbWVtb3J5OnVlfHxjLndhc21NZW1vcnl9LFBrPV9nKCksdWI9Yy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4odWI9Yy5fX193YXNtX2NhbGxfY3RvcnM9Yy5hc20uX193YXNtX2NhbGxfY3RvcnMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scGI9Yy5faW5pdD1mdW5jdGlvbigpe3JldHVybihwYj1jLl9pbml0PWMuYXNtLmluaXQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sY2I9Yy5faW5pdF93aXRoX3RocmVhZHNfY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oY2I9Yy5faW5pdF93aXRoX3RocmVhZHNfY291bnQ9Yy5hc20uaW5pdF93aXRoX3RocmVhZHNfY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZGI9Yy5fZ2V0X3RocmVhZHNfY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oZGI9Yy5fZ2V0X3RocmVhZHNfY291bnQ9Yy5hc20uZ2V0X3RocmVhZHNfY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saGI9Yy5fcmVnaXN0ZXJfdGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKGhiPWMuX3JlZ2lzdGVyX3RlbnNvcj1jLmFzbS5yZWdpc3Rlcl90ZW5zb3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbWI9Yy5fZGlzcG9zZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKG1iPWMuX2Rpc3Bvc2VfZGF0YT1jLmFzbS5kaXNwb3NlX2RhdGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZmI9Yy5fZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybihmYj1jLl9kaXNwb3NlPWMuYXNtLmRpc3Bvc2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZ2I9Yy5fQWJzPWZ1bmN0aW9uKCl7cmV0dXJuKGdiPWMuX0Ficz1jLmFzbS5BYnMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYmI9Yy5fQWNvcz1mdW5jdGlvbigpe3JldHVybihiYj1jLl9BY29zPWMuYXNtLkFjb3MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seWI9Yy5fQWNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4oeWI9Yy5fQWNvc2g9Yy5hc20uQWNvc2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seGI9Yy5fQWRkPWZ1bmN0aW9uKCl7cmV0dXJuKHhiPWMuX0FkZD1jLmFzbS5BZGQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdmI9Yy5fQWRkTj1mdW5jdGlvbigpe3JldHVybih2Yj1jLl9BZGROPWMuYXNtLkFkZE4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2I9Yy5fQWxsPWZ1bmN0aW9uKCl7cmV0dXJuKHdiPWMuX0FsbD1jLmFzbS5BbGwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sa2I9Yy5fQW55PWZ1bmN0aW9uKCl7cmV0dXJuKGtiPWMuX0FueT1jLmFzbS5BbnkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSWI9Yy5fQXJnTWF4PWZ1bmN0aW9uKCl7cmV0dXJuKEliPWMuX0FyZ01heD1jLmFzbS5BcmdNYXgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2I9Yy5fQXJnTWluPWZ1bmN0aW9uKCl7cmV0dXJuKFNiPWMuX0FyZ01pbj1jLmFzbS5BcmdNaW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTmI9Yy5fQXNpbj1mdW5jdGlvbigpe3JldHVybihOYj1jLl9Bc2luPWMuYXNtLkFzaW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGI9Yy5fQXNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4oVGI9Yy5fQXNpbmg9Yy5hc20uQXNpbmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ2I9Yy5fQXRhbj1mdW5jdGlvbigpe3JldHVybihDYj1jLl9BdGFuPWMuYXNtLkF0YW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRWI9Yy5fQXRhbjI9ZnVuY3Rpb24oKXtyZXR1cm4oRWI9Yy5fQXRhbjI9Yy5hc20uQXRhbjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX2I9Yy5fQXRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4oX2I9Yy5fQXRhbmg9Yy5hc20uQXRhbmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQWI9Yy5fQXZnUG9vbD1mdW5jdGlvbigpe3JldHVybihBYj1jLl9BdmdQb29sPWMuYXNtLkF2Z1Bvb2wpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRmI9Yy5fQXZnUG9vbDNEPWZ1bmN0aW9uKCl7cmV0dXJuKEZiPWMuX0F2Z1Bvb2wzRD1jLmFzbS5BdmdQb29sM0QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sJGI9Yy5fQXZnUG9vbDNER3JhZD1mdW5jdGlvbigpe3JldHVybigkYj1jLl9BdmdQb29sM0RHcmFkPWMuYXNtLkF2Z1Bvb2wzREdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGI9Yy5fQXZnUG9vbEdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oRGI9Yy5fQXZnUG9vbEdyYWQ9Yy5hc20uQXZnUG9vbEdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUmI9Yy5fQmF0Y2hNYXRNdWw9ZnVuY3Rpb24oKXtyZXR1cm4oUmI9Yy5fQmF0Y2hNYXRNdWw9Yy5hc20uQmF0Y2hNYXRNdWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWI9Yy5fQmluY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oTWI9Yy5fQmluY291bnQ9Yy5hc20uQmluY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2I9Yy5fQml0d2lzZUFuZD1mdW5jdGlvbigpe3JldHVybihPYj1jLl9CaXR3aXNlQW5kPWMuYXNtLkJpdHdpc2VBbmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUGI9Yy5fQ2VpbD1mdW5jdGlvbigpe3JldHVybihQYj1jLl9DZWlsPWMuYXNtLkNlaWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTGI9Yy5fQ2xpcEJ5VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4oTGI9Yy5fQ2xpcEJ5VmFsdWU9Yy5hc20uQ2xpcEJ5VmFsdWUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0semI9Yy5fQ29udjJEPWZ1bmN0aW9uKCl7cmV0dXJuKHpiPWMuX0NvbnYyRD1jLmFzbS5Db252MkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV2I9Yy5fQ29udjJEQmFja3Byb3BJbnB1dD1mdW5jdGlvbigpe3JldHVybihXYj1jLl9Db252MkRCYWNrcHJvcElucHV0PWMuYXNtLkNvbnYyREJhY2twcm9wSW5wdXQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQmI9Yy5fQ29udjNEPWZ1bmN0aW9uKCl7cmV0dXJuKEJiPWMuX0NvbnYzRD1jLmFzbS5Db252M0QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVmI9Yy5fQ29udjNEQmFja3Byb3BGaWx0ZXJWMj1mdW5jdGlvbigpe3JldHVybihWYj1jLl9Db252M0RCYWNrcHJvcEZpbHRlclYyPWMuYXNtLkNvbnYzREJhY2twcm9wRmlsdGVyVjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVWI9Yy5fQ29udjNEQmFja3Byb3BJbnB1dFYyPWZ1bmN0aW9uKCl7cmV0dXJuKFViPWMuX0NvbnYzREJhY2twcm9wSW5wdXRWMj1jLmFzbS5Db252M0RCYWNrcHJvcElucHV0VjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sR2I9Yy5fQ29zPWZ1bmN0aW9uKCl7cmV0dXJuKEdiPWMuX0Nvcz1jLmFzbS5Db3MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSGI9Yy5fQ29zaD1mdW5jdGlvbigpe3JldHVybihIYj1jLl9Db3NoPWMuYXNtLkNvc2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0samI9Yy5fQ3JvcEFuZFJlc2l6ZT1mdW5jdGlvbigpe3JldHVybihqYj1jLl9Dcm9wQW5kUmVzaXplPWMuYXNtLkNyb3BBbmRSZXNpemUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scWI9Yy5fQ3VtcHJvZD1mdW5jdGlvbigpe3JldHVybihxYj1jLl9DdW1wcm9kPWMuYXNtLkN1bXByb2QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sS2I9Yy5fQ3Vtc3VtPWZ1bmN0aW9uKCl7cmV0dXJuKEtiPWMuX0N1bXN1bT1jLmFzbS5DdW1zdW0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWGI9Yy5fRGVuc2VCaW5jb3VudD1mdW5jdGlvbigpe3JldHVybihYYj1jLl9EZW5zZUJpbmNvdW50PWMuYXNtLkRlbnNlQmluY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWWI9Yy5fRGVwdGhUb1NwYWNlPWZ1bmN0aW9uKCl7cmV0dXJuKFliPWMuX0RlcHRoVG9TcGFjZT1jLmFzbS5EZXB0aFRvU3BhY2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWmI9Yy5fRGVwdGh3aXNlQ29udjJkTmF0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuKFpiPWMuX0RlcHRod2lzZUNvbnYyZE5hdGl2ZT1jLmFzbS5EZXB0aHdpc2VDb252MmROYXRpdmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSmI9Yy5fRGlhZz1mdW5jdGlvbigpe3JldHVybihKYj1jLl9EaWFnPWMuYXNtLkRpYWcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUWI9Yy5fRGlsYXRpb24yRD1mdW5jdGlvbigpe3JldHVybihRYj1jLl9EaWxhdGlvbjJEPWMuYXNtLkRpbGF0aW9uMkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZXk9Yy5fRGlsYXRpb24yREJhY2twcm9wRmlsdGVyPWZ1bmN0aW9uKCl7cmV0dXJuKGV5PWMuX0RpbGF0aW9uMkRCYWNrcHJvcEZpbHRlcj1jLmFzbS5EaWxhdGlvbjJEQmFja3Byb3BGaWx0ZXIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdHk9Yy5fRGlsYXRpb24yREJhY2twcm9wSW5wdXQ9ZnVuY3Rpb24oKXtyZXR1cm4odHk9Yy5fRGlsYXRpb24yREJhY2twcm9wSW5wdXQ9Yy5hc20uRGlsYXRpb24yREJhY2twcm9wSW5wdXQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbnk9Yy5fRWx1PWZ1bmN0aW9uKCl7cmV0dXJuKG55PWMuX0VsdT1jLmFzbS5FbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYXk9Yy5fRWx1R3JhZD1mdW5jdGlvbigpe3JldHVybihheT1jLl9FbHVHcmFkPWMuYXNtLkVsdUdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scnk9Yy5fRXF1YWw9ZnVuY3Rpb24oKXtyZXR1cm4ocnk9Yy5fRXF1YWw9Yy5hc20uRXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sc3k9Yy5fRXJmPWZ1bmN0aW9uKCl7cmV0dXJuKHN5PWMuX0VyZj1jLmFzbS5FcmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saXk9Yy5fRXhwPWZ1bmN0aW9uKCl7cmV0dXJuKGl5PWMuX0V4cD1jLmFzbS5FeHApLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sb3k9Yy5fRXhwbTE9ZnVuY3Rpb24oKXtyZXR1cm4ob3k9Yy5fRXhwbTE9Yy5hc20uRXhwbTEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbHk9Yy5fRmxpcExlZnRSaWdodD1mdW5jdGlvbigpe3JldHVybihseT1jLl9GbGlwTGVmdFJpZ2h0PWMuYXNtLkZsaXBMZWZ0UmlnaHQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdXk9Yy5fRmxvb3I9ZnVuY3Rpb24oKXtyZXR1cm4odXk9Yy5fRmxvb3I9Yy5hc20uRmxvb3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scHk9Yy5fRmxvb3JEaXY9ZnVuY3Rpb24oKXtyZXR1cm4ocHk9Yy5fRmxvb3JEaXY9Yy5hc20uRmxvb3JEaXYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sY3k9Yy5fRnVzZWRCYXRjaE5vcm09ZnVuY3Rpb24oKXtyZXR1cm4oY3k9Yy5fRnVzZWRCYXRjaE5vcm09Yy5hc20uRnVzZWRCYXRjaE5vcm0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZHk9Yy5fRnVzZWRDb252MkQ9ZnVuY3Rpb24oKXtyZXR1cm4oZHk9Yy5fRnVzZWRDb252MkQ9Yy5hc20uRnVzZWRDb252MkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saHk9Yy5fRnVzZWREZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24oKXtyZXR1cm4oaHk9Yy5fRnVzZWREZXB0aHdpc2VDb252MkQ9Yy5hc20uRnVzZWREZXB0aHdpc2VDb252MkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbXk9Yy5fR2F0aGVyPWZ1bmN0aW9uKCl7cmV0dXJuKG15PWMuX0dhdGhlcj1jLmFzbS5HYXRoZXIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZnk9Yy5fR2F0aGVyTmQ9ZnVuY3Rpb24oKXtyZXR1cm4oZnk9Yy5fR2F0aGVyTmQ9Yy5hc20uR2F0aGVyTmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZ3k9Yy5fR3JlYXRlcj1mdW5jdGlvbigpe3JldHVybihneT1jLl9HcmVhdGVyPWMuYXNtLkdyZWF0ZXIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYnk9Yy5fR3JlYXRlckVxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKGJ5PWMuX0dyZWF0ZXJFcXVhbD1jLmFzbS5HcmVhdGVyRXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seXk9Yy5fSXNGaW5pdGU9ZnVuY3Rpb24oKXtyZXR1cm4oeXk9Yy5fSXNGaW5pdGU9Yy5hc20uSXNGaW5pdGUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHk9Yy5fSXNJbmY9ZnVuY3Rpb24oKXtyZXR1cm4oeHk9Yy5fSXNJbmY9Yy5hc20uSXNJbmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdnk9Yy5fSXNOYW49ZnVuY3Rpb24oKXtyZXR1cm4odnk9Yy5fSXNOYW49Yy5hc20uSXNOYW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd3k9Yy5fTFJOPWZ1bmN0aW9uKCl7cmV0dXJuKHd5PWMuX0xSTj1jLmFzbS5MUk4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sa3k9Yy5fTFJOR3JhZD1mdW5jdGlvbigpe3JldHVybihreT1jLl9MUk5HcmFkPWMuYXNtLkxSTkdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXk9Yy5fTGVha3lSZWx1PWZ1bmN0aW9uKCl7cmV0dXJuKEl5PWMuX0xlYWt5UmVsdT1jLmFzbS5MZWFreVJlbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3k9Yy5fTGVzcz1mdW5jdGlvbigpe3JldHVybihTeT1jLl9MZXNzPWMuYXNtLkxlc3MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTnk9Yy5fTGVzc0VxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKE55PWMuX0xlc3NFcXVhbD1jLmFzbS5MZXNzRXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHk9Yy5fTGluU3BhY2U9ZnVuY3Rpb24oKXtyZXR1cm4oVHk9Yy5fTGluU3BhY2U9Yy5hc20uTGluU3BhY2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3k9Yy5fTG9nPWZ1bmN0aW9uKCl7cmV0dXJuKEN5PWMuX0xvZz1jLmFzbS5Mb2cpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRXk9Yy5fTG9nMXA9ZnVuY3Rpb24oKXtyZXR1cm4oRXk9Yy5fTG9nMXA9Yy5hc20uTG9nMXApLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX3k9Yy5fTG9naWNhbEFuZD1mdW5jdGlvbigpe3JldHVybihfeT1jLl9Mb2dpY2FsQW5kPWMuYXNtLkxvZ2ljYWxBbmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXk9Yy5fTG9naWNhbE5vdD1mdW5jdGlvbigpe3JldHVybihBeT1jLl9Mb2dpY2FsTm90PWMuYXNtLkxvZ2ljYWxOb3QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnk9Yy5fTG9naWNhbE9yPWZ1bmN0aW9uKCl7cmV0dXJuKEZ5PWMuX0xvZ2ljYWxPcj1jLmFzbS5Mb2dpY2FsT3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sJHk9Yy5fTG9naWNhbFhvcj1mdW5jdGlvbigpe3JldHVybigkeT1jLl9Mb2dpY2FsWG9yPWMuYXNtLkxvZ2ljYWxYb3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRHk9Yy5fTWF4PWZ1bmN0aW9uKCl7cmV0dXJuKER5PWMuX01heD1jLmFzbS5NYXgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUnk9Yy5fTWF4UG9vbD1mdW5jdGlvbigpe3JldHVybihSeT1jLl9NYXhQb29sPWMuYXNtLk1heFBvb2wpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTXk9Yy5fTWF4UG9vbDNEPWZ1bmN0aW9uKCl7cmV0dXJuKE15PWMuX01heFBvb2wzRD1jLmFzbS5NYXhQb29sM0QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3k9Yy5fTWF4UG9vbDNER3JhZD1mdW5jdGlvbigpe3JldHVybihPeT1jLl9NYXhQb29sM0RHcmFkPWMuYXNtLk1heFBvb2wzREdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHk9Yy5fTWF4UG9vbEdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oUHk9Yy5fTWF4UG9vbEdyYWQ9Yy5hc20uTWF4UG9vbEdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTHk9Yy5fTWF4UG9vbFdpdGhBcmdtYXg9ZnVuY3Rpb24oKXtyZXR1cm4oTHk9Yy5fTWF4UG9vbFdpdGhBcmdtYXg9Yy5hc20uTWF4UG9vbFdpdGhBcmdtYXgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0senk9Yy5fTWF4aW11bT1mdW5jdGlvbigpe3JldHVybih6eT1jLl9NYXhpbXVtPWMuYXNtLk1heGltdW0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV3k9Yy5fTWVhbj1mdW5jdGlvbigpe3JldHVybihXeT1jLl9NZWFuPWMuYXNtLk1lYW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQnk9Yy5fTWluPWZ1bmN0aW9uKCl7cmV0dXJuKEJ5PWMuX01pbj1jLmFzbS5NaW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVnk9Yy5fTWluaW11bT1mdW5jdGlvbigpe3JldHVybihWeT1jLl9NaW5pbXVtPWMuYXNtLk1pbmltdW0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVXk9Yy5fTWlycm9yUGFkPWZ1bmN0aW9uKCl7cmV0dXJuKFV5PWMuX01pcnJvclBhZD1jLmFzbS5NaXJyb3JQYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sR3k9Yy5fTW9kPWZ1bmN0aW9uKCl7cmV0dXJuKEd5PWMuX01vZD1jLmFzbS5Nb2QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSHk9Yy5fTXVsdGlub21pYWw9ZnVuY3Rpb24oKXtyZXR1cm4oSHk9Yy5fTXVsdGlub21pYWw9Yy5hc20uTXVsdGlub21pYWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sank9Yy5fTXVsdGlwbHk9ZnVuY3Rpb24oKXtyZXR1cm4oank9Yy5fTXVsdGlwbHk9Yy5hc20uTXVsdGlwbHkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scXk9Yy5fTmVnPWZ1bmN0aW9uKCl7cmV0dXJuKHF5PWMuX05lZz1jLmFzbS5OZWcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sS3k9Yy5fTm9uTWF4U3VwcHJlc3Npb25WMz1mdW5jdGlvbigpe3JldHVybihLeT1jLl9Ob25NYXhTdXBwcmVzc2lvblYzPWMuYXNtLk5vbk1heFN1cHByZXNzaW9uVjMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWHk9Yy5fTm9uTWF4U3VwcHJlc3Npb25WND1mdW5jdGlvbigpe3JldHVybihYeT1jLl9Ob25NYXhTdXBwcmVzc2lvblY0PWMuYXNtLk5vbk1heFN1cHByZXNzaW9uVjQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbGg9Yy5fTm9uTWF4U3VwcHJlc3Npb25WNT1mdW5jdGlvbigpe3JldHVybihsaD1jLl9Ob25NYXhTdXBwcmVzc2lvblY1PWMuYXNtLk5vbk1heFN1cHByZXNzaW9uVjUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdWg9Yy5fTm90RXF1YWw9ZnVuY3Rpb24oKXtyZXR1cm4odWg9Yy5fTm90RXF1YWw9Yy5hc20uTm90RXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sanA9Yy5fT25lSG90PWZ1bmN0aW9uKCl7cmV0dXJuKGpwPWMuX09uZUhvdD1jLmFzbS5PbmVIb3QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWXk9Yy5fUGFkVjI9ZnVuY3Rpb24oKXtyZXR1cm4oWXk9Yy5fUGFkVjI9Yy5hc20uUGFkVjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWnk9Yy5fUG93PWZ1bmN0aW9uKCl7cmV0dXJuKFp5PWMuX1Bvdz1jLmFzbS5Qb3cpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seWw9Yy5fUHJlbHU9ZnVuY3Rpb24oKXtyZXR1cm4oeWw9Yy5fUHJlbHU9Yy5hc20uUHJlbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scGg9Yy5fUHJvZD1mdW5jdGlvbigpe3JldHVybihwaD1jLl9Qcm9kPWMuYXNtLlByb2QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seGw9Yy5fUmVhbERpdj1mdW5jdGlvbigpe3JldHVybih4bD1jLl9SZWFsRGl2PWMuYXNtLlJlYWxEaXYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdmw9Yy5fUmVjaXByb2NhbD1mdW5jdGlvbigpe3JldHVybih2bD1jLl9SZWNpcHJvY2FsPWMuYXNtLlJlY2lwcm9jYWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSnk9Yy5fUmVsdT1mdW5jdGlvbigpe3JldHVybihKeT1jLl9SZWx1PWMuYXNtLlJlbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWT1jLl9SZWx1Nj1mdW5jdGlvbigpe3JldHVybihZPWMuX1JlbHU2PWMuYXNtLlJlbHU2KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG9lPWMuX1Jlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKCl7cmV0dXJuKG9lPWMuX1Jlc2l6ZUJpbGluZWFyPWMuYXNtLlJlc2l6ZUJpbGluZWFyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEllPWMuX1Jlc2l6ZUJpbGluZWFyR3JhZD1mdW5jdGlvbigpe3JldHVybihJZT1jLl9SZXNpemVCaWxpbmVhckdyYWQ9Yy5hc20uUmVzaXplQmlsaW5lYXJHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFllPWMuX1Jlc2l6ZU5lYXJlc3ROZWlnaGJvcj1mdW5jdGlvbigpe3JldHVybihZZT1jLl9SZXNpemVOZWFyZXN0TmVpZ2hib3I9Yy5hc20uUmVzaXplTmVhcmVzdE5laWdoYm9yKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHd0PWMuX1Jlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4od3Q9Yy5fUmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZD1jLmFzbS5SZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGt0PWMuX1JldmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4oa3Q9Yy5fUmV2ZXJzZT1jLmFzbS5SZXZlcnNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEdlPWMuX1JvdGF0ZVdpdGhPZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4oR2U9Yy5fUm90YXRlV2l0aE9mZnNldD1jLmFzbS5Sb3RhdGVXaXRoT2Zmc2V0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJlPWMuX1JvdW5kPWZ1bmN0aW9uKCl7cmV0dXJuKEJlPWMuX1JvdW5kPWMuYXNtLlJvdW5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFB0PWMuX1JzcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuKFB0PWMuX1JzcXJ0PWMuYXNtLlJzcXJ0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxhPWMuX1NjYXR0ZXJOZD1mdW5jdGlvbigpe3JldHVybihsYT1jLl9TY2F0dGVyTmQ9Yy5hc20uU2NhdHRlck5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHdyPWMuX1NlYXJjaFNvcnRlZD1mdW5jdGlvbigpe3JldHVybih3cj1jLl9TZWFyY2hTb3J0ZWQ9Yy5hc20uU2VhcmNoU29ydGVkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGNoPWMuX1NlbGVjdFYyPWZ1bmN0aW9uKCl7cmV0dXJuKGNoPWMuX1NlbGVjdFYyPWMuYXNtLlNlbGVjdFYyKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHFwPWMuX1NlbHU9ZnVuY3Rpb24oKXtyZXR1cm4ocXA9Yy5fU2VsdT1jLmFzbS5TZWx1KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFF5PWMuX1NpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4oUXk9Yy5fU2lnbW9pZD1jLmFzbS5TaWdtb2lkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFJuPWMuX1NpZ249ZnVuY3Rpb24oKXtyZXR1cm4oUm49Yy5fU2lnbj1jLmFzbS5TaWduKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGpyPWMuX1Npbj1mdW5jdGlvbigpe3JldHVybihqcj1jLl9TaW49Yy5hc20uU2luKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRoPWMuX1Npbmg9ZnVuY3Rpb24oKXtyZXR1cm4oZGg9Yy5fU2luaD1jLmFzbS5TaW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJEPWMuX1NvZnRtYXg9ZnVuY3Rpb24oKXtyZXR1cm4oQkQ9Yy5fU29mdG1heD1jLmFzbS5Tb2Z0bWF4KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZEPWMuX1NvZnRwbHVzPWZ1bmN0aW9uKCl7cmV0dXJuKFZEPWMuX1NvZnRwbHVzPWMuYXNtLlNvZnRwbHVzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFVEPWMuX1NwYXJzZUZpbGxFbXB0eVJvd3M9ZnVuY3Rpb24oKXtyZXR1cm4oVUQ9Yy5fU3BhcnNlRmlsbEVtcHR5Um93cz1jLmFzbS5TcGFyc2VGaWxsRW1wdHlSb3dzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEdEPWMuX1NwYXJzZVJlc2hhcGU9ZnVuY3Rpb24oKXtyZXR1cm4oR0Q9Yy5fU3BhcnNlUmVzaGFwZT1jLmFzbS5TcGFyc2VSZXNoYXBlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEhEPWMuX1NwYXJzZVNlZ21lbnRSZWR1Y3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4oSEQ9Yy5fU3BhcnNlU2VnbWVudFJlZHVjdGlvbj1jLmFzbS5TcGFyc2VTZWdtZW50UmVkdWN0aW9uKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGpEPWMuX1NwYXJzZVRvRGVuc2U9ZnVuY3Rpb24oKXtyZXR1cm4oakQ9Yy5fU3BhcnNlVG9EZW5zZT1jLmFzbS5TcGFyc2VUb0RlbnNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHFEPWMuX1NxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4ocUQ9Yy5fU3FydD1jLmFzbS5TcXJ0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEtEPWMuX1NxdWFyZT1mdW5jdGlvbigpe3JldHVybihLRD1jLl9TcXVhcmU9Yy5hc20uU3F1YXJlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFhEPWMuX1NxdWFyZWREaWZmZXJlbmNlPWZ1bmN0aW9uKCl7cmV0dXJuKFhEPWMuX1NxdWFyZWREaWZmZXJlbmNlPWMuYXNtLlNxdWFyZWREaWZmZXJlbmNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFlEPWMuX1N0ZXA9ZnVuY3Rpb24oKXtyZXR1cm4oWUQ9Yy5fU3RlcD1jLmFzbS5TdGVwKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFpEPWMuX1N0cmlkZWRTbGljZT1mdW5jdGlvbigpe3JldHVybihaRD1jLl9TdHJpZGVkU2xpY2U9Yy5hc20uU3RyaWRlZFNsaWNlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEpEPWMuX1N1Yj1mdW5jdGlvbigpe3JldHVybihKRD1jLl9TdWI9Yy5hc20uU3ViKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFFEPWMuX1N1bT1mdW5jdGlvbigpe3JldHVybihRRD1jLl9TdW09Yy5hc20uU3VtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGVSPWMuX1Rhbj1mdW5jdGlvbigpe3JldHVybihlUj1jLl9UYW49Yy5hc20uVGFuKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHRSPWMuX1Rhbmg9ZnVuY3Rpb24oKXtyZXR1cm4odFI9Yy5fVGFuaD1jLmFzbS5UYW5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG5SPWMuX1RlbnNvclNjYXR0ZXJVcGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4oblI9Yy5fVGVuc29yU2NhdHRlclVwZGF0ZT1jLmFzbS5UZW5zb3JTY2F0dGVyVXBkYXRlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGFSPWMuX1RpbGU9ZnVuY3Rpb24oKXtyZXR1cm4oYVI9Yy5fVGlsZT1jLmFzbS5UaWxlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHJSPWMuX1RvcEs9ZnVuY3Rpb24oKXtyZXR1cm4oclI9Yy5fVG9wSz1jLmFzbS5Ub3BLKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHNSPWMuX1RyYW5zZm9ybT1mdW5jdGlvbigpe3JldHVybihzUj1jLl9UcmFuc2Zvcm09Yy5hc20uVHJhbnNmb3JtKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGlSPWMuX1RyYW5zcG9zZT1mdW5jdGlvbigpe3JldHVybihpUj1jLl9UcmFuc3Bvc2U9Yy5hc20uVHJhbnNwb3NlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG9SPWMuX19GdXNlZE1hdE11bD1mdW5jdGlvbigpe3JldHVybihvUj1jLl9fRnVzZWRNYXRNdWw9Yy5hc20uX0Z1c2VkTWF0TXVsKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGxSPWMuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihsUj1jLl9tYWxsb2M9Yy5hc20ubWFsbG9jKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHVSPWMuX2ZyZWU9ZnVuY3Rpb24oKXtyZXR1cm4odVI9Yy5fZnJlZT1jLmFzbS5mcmVlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHBSPWMuX19lbXNjcmlwdGVuX3Rsc19pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKHBSPWMuX19lbXNjcmlwdGVuX3Rsc19pbml0PWMuYXNtLl9lbXNjcmlwdGVuX3Rsc19pbml0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGhoPWMuX3B0aHJlYWRfc2VsZj1mdW5jdGlvbigpe3JldHVybihoaD1jLl9wdGhyZWFkX3NlbGY9Yy5hc20ucHRocmVhZF9zZWxmKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGNSPWMuX19fZXJybm9fbG9jYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4oY1I9Yy5fX19lcnJub19sb2NhdGlvbj1jLmFzbS5fX2Vycm5vX2xvY2F0aW9uKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LExrPWMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWZ1bmN0aW9uKCl7cmV0dXJuKExrPWMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PWMuYXNtLl9lbXNjcmlwdGVuX3RocmVhZF9pbml0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGRSPWMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWZ1bmN0aW9uKCl7cmV0dXJuKGRSPWMuX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkPWMuYXNtLl9lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGhSPWMuX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHM9ZnVuY3Rpb24oKXtyZXR1cm4oaFI9Yy5fZW1zY3JpcHRlbl9tYWluX3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscz1jLmFzbS5lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LG1SPWMuX2Vtc2NyaXB0ZW5fbWFpbl9icm93c2VyX3RocmVhZF9pZD1mdW5jdGlvbigpe3JldHVybihtUj1jLl9lbXNjcmlwdGVuX21haW5fYnJvd3Nlcl90aHJlYWRfaWQ9Yy5hc20uZW1zY3JpcHRlbl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHprPWMuX2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanM9ZnVuY3Rpb24oKXtyZXR1cm4oems9Yy5fZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz1jLmFzbS5lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGZSPWMuX2Vtc2NyaXB0ZW5fZGlzcGF0Y2hfdG9fdGhyZWFkXz1mdW5jdGlvbigpe3JldHVybihmUj1jLl9lbXNjcmlwdGVuX2Rpc3BhdGNoX3RvX3RocmVhZF89Yy5hc20uZW1zY3JpcHRlbl9kaXNwYXRjaF90b190aHJlYWRfKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFdrPWMuX19lbXNjcmlwdGVuX3Byb3h5X2V4ZWN1dGVfdGFza19xdWV1ZT1mdW5jdGlvbigpe3JldHVybihXaz1jLl9fZW1zY3JpcHRlbl9wcm94eV9leGVjdXRlX3Rhc2tfcXVldWU9Yy5hc20uX2Vtc2NyaXB0ZW5fcHJveHlfZXhlY3V0ZV90YXNrX3F1ZXVlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGV4PWMuX19lbXNjcmlwdGVuX3RocmVhZF9mcmVlX2RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4oZXg9Yy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2ZyZWVfZGF0YT1jLmFzbS5fZW1zY3JpcHRlbl90aHJlYWRfZnJlZV9kYXRhKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEJrPWMuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWZ1bmN0aW9uKCl7cmV0dXJuKEJrPWMuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PWMuYXNtLl9lbXNjcmlwdGVuX3RocmVhZF9leGl0KS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFZrPWMuX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1mdW5jdGlvbigpe3JldHVybihWaz1jLl9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9Yy5hc20uZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHR4PWMuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKHR4PWMuc3RhY2tTYXZlPWMuYXNtLnN0YWNrU2F2ZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxtaD1jLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihtaD1jLnN0YWNrUmVzdG9yZT1jLmFzbS5zdGFja1Jlc3RvcmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZmg9Yy5zdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKGZoPWMuc3RhY2tBbGxvYz1jLmFzbS5zdGFja0FsbG9jKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LGdSPWMuZHluQ2FsbF9paWpqaWlpaT1mdW5jdGlvbigpe3JldHVybihnUj1jLmR5bkNhbGxfaWlqamlpaWk9Yy5hc20uZHluQ2FsbF9paWpqaWlpaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxiUj1jLmR5bkNhbGxfamlqaT1mdW5jdGlvbigpe3JldHVybihiUj1jLmR5bkNhbGxfamlqaT1jLmFzbS5keW5DYWxsX2ppamkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Yy5rZWVwUnVudGltZUFsaXZlPUlhLGMud2FzbU1lbW9yeT11ZSxjLmN3cmFwPW9iLGMuRXhpdFN0YXR1cz1HcyxjLlBUaHJlYWQ9QWU7dmFyIGdoO3ZyPWZ1bmN0aW9uIFIoKXtnaHx8VWsoKSxnaHx8KHZyPVIpfTtmdW5jdGlvbiBVayhSKXtpZihSPVJ8fGIsR3I+MClyZXR1cm47aWYoQyl7aChjKSxKdCgpLHN0YXJ0V29ya2VyKGMpO3JldHVybn1pZihVcigpLEdyPjApcmV0dXJuO2Z1bmN0aW9uIGooKXtnaHx8KGdoPSEwLGMuY2FsbGVkUnVuPSEwLCFrZSYmKEp0KCksaChjKSxjLm9uUnVudGltZUluaXRpYWxpemVkJiZjLm9uUnVudGltZUluaXRpYWxpemVkKCksSGQoKSkpfWMuc2V0U3RhdHVzPyhjLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dChmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjLnNldFN0YXR1cyhcIlwiKX0sMSksaigpfSwxKSk6aigpfWlmKGMucHJlSW5pdClmb3IodHlwZW9mIGMucHJlSW5pdD09XCJmdW5jdGlvblwiJiYoYy5wcmVJbml0PVtjLnByZUluaXRdKTtjLnByZUluaXQubGVuZ3RoPjA7KWMucHJlSW5pdC5wb3AoKSgpO1VrKCk7dmFyIGJoO2YmJihiaD17dW5jYXVnaHRFeGNlcHRpb246cHJvY2Vzcy5saXN0ZW5lcnMoXCJ1bmNhdWdodEV4Y2VwdGlvblwiKS5maWx0ZXIoZnVuY3Rpb24oUil7cmV0dXJuIWYudW5jYXVnaHRFeGNlcHRpb24uaW5kZXhPZihSKT4tMX0pLHVuaGFuZGxlZFJlamVjdGlvbjpwcm9jZXNzLmxpc3RlbmVycyhcInVuaGFuZGxlZFJlamVjdGlvblwiKS5maWx0ZXIoZnVuY3Rpb24oUil7cmV0dXJuIWYudW5oYW5kbGVkUmVqZWN0aW9uLmluZGV4T2YoUik+LTF9KX0pO3ZhciB5aDtpZih0eXBlb2YgV2FzbUJhY2tlbmRNb2R1bGUhPVwidW5kZWZpbmVkXCIpeWg9V2FzbUJhY2tlbmRNb2R1bGU7ZWxzZSBpZih0eXBlb2YgciE9XCJ1bmRlZmluZWRcIil5aD1yO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2FzbSBtb2R1bGUgaW4gcG9zdC5qc1wiKTtpZihiaCl7dmFyIHlSPXloLl9kaXNwb3NlO3loLl9kaXNwb3NlPWZ1bmN0aW9uKCl7eVIoKSxiaC51bmNhdWdodEV4Y2VwdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKFIpe3Byb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLFIpfSksYmgudW5oYW5kbGVkUmVqZWN0aW9uLmZvckVhY2goZnVuY3Rpb24oUil7cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihcInVuaGFuZGxlZFJlamVjdGlvblwiLFIpfSl9fXJldHVybiByLnJlYWR5fX0pKCk7dHlwZW9mIGU9PVwib2JqZWN0XCImJnR5cGVvZiB0PT1cIm9iamVjdFwiP3QuZXhwb3J0cz1uOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZnVuY3Rpb24oKXtyZXR1cm4gbn0pOnR5cGVvZiBlPT1cIm9iamVjdFwiJiYoZS5XYXNtQmFja2VuZE1vZHVsZVRocmVhZGVkU2ltZD1uKX0pLFVSPVZ0KChlLHQpPT57dC5leHBvcnRzLndhc21Xb3JrZXJDb250ZW50cz1gXCJ1c2Ugc3RyaWN0XCI7dmFyIE1vZHVsZT17fTt2YXIgRU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCI7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7dmFyIG5vZGVXb3JrZXJUaHJlYWRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKTt2YXIgcGFyZW50UG9ydD1ub2RlV29ya2VyVGhyZWFkcy5wYXJlbnRQb3J0O3BhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsZGF0YT0+b25tZXNzYWdlKHtkYXRhOmRhdGF9KSk7dmFyIGZzPXJlcXVpcmUoXCJmc1wiKTtPYmplY3QuYXNzaWduKGdsb2JhbCx7c2VsZjpnbG9iYWwscmVxdWlyZTpyZXF1aXJlLE1vZHVsZTpNb2R1bGUsbG9jYXRpb246e2hyZWY6X19maWxlbmFtZX0sV29ya2VyOm5vZGVXb3JrZXJUaHJlYWRzLldvcmtlcixpbXBvcnRTY3JpcHRzOmZ1bmN0aW9uKGYpeygwLGV2YWwpKGZzLnJlYWRGaWxlU3luYyhmLFwidXRmOFwiKStcIi8vIyBzb3VyY2VVUkw9XCIrZil9LHBvc3RNZXNzYWdlOmZ1bmN0aW9uKG1zZyl7cGFyZW50UG9ydC5wb3N0TWVzc2FnZShtc2cpfSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX19fSl9dmFyIGluaXRpYWxpemVkSlM9ZmFsc2U7dmFyIHBlbmRpbmdOb3RpZmllZFByb3h5aW5nUXVldWVzPVtdO2Z1bmN0aW9uIHRocmVhZFByaW50RXJyKCl7dmFyIHRleHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtmcy53cml0ZVN5bmMoMix0ZXh0K1wiXG5cIik7cmV0dXJufWNvbnNvbGUuZXJyb3IodGV4dCl9ZnVuY3Rpb24gdGhyZWFkQWxlcnQoKXt2YXIgdGV4dD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO3Bvc3RNZXNzYWdlKHtjbWQ6XCJhbGVydFwiLHRleHQ6dGV4dCx0aHJlYWRJZDpNb2R1bGVbXCJfcHRocmVhZF9zZWxmXCJdKCl9KX12YXIgZXJyPXRocmVhZFByaW50RXJyO3NlbGYuYWxlcnQ9dGhyZWFkQWxlcnQ7TW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdPShpbmZvLHJlY2VpdmVJbnN0YW5jZSk9Pnt2YXIgaW5zdGFuY2U9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKE1vZHVsZVtcIndhc21Nb2R1bGVcIl0saW5mbyk7cmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlKTtNb2R1bGVbXCJ3YXNtTW9kdWxlXCJdPW51bGw7cmV0dXJuIGluc3RhbmNlLmV4cG9ydHN9O3NlbGYub251bmhhbmRsZWRyZWplY3Rpb249ZT0+e3Rocm93IGUucmVhc29uPz9lfTtzZWxmLnN0YXJ0V29ya2VyPWluc3RhbmNlPT57TW9kdWxlPWluc3RhbmNlO3Bvc3RNZXNzYWdlKHtcImNtZFwiOlwibG9hZGVkXCJ9KX07c2VsZi5vbm1lc3NhZ2U9ZT0+e3RyeXtpZihlLmRhdGEuY21kPT09XCJsb2FkXCIpe01vZHVsZVtcIndhc21Nb2R1bGVcIl09ZS5kYXRhLndhc21Nb2R1bGU7Zm9yKGNvbnN0IGhhbmRsZXIgb2YgZS5kYXRhLmhhbmRsZXJzKXtNb2R1bGVbaGFuZGxlcl09ZnVuY3Rpb24oKXtwb3N0TWVzc2FnZSh7Y21kOlwiY2FsbEhhbmRsZXJcIixoYW5kbGVyOmhhbmRsZXIsYXJnczpbLi4uYXJndW1lbnRzXX0pfX1Nb2R1bGVbXCJ3YXNtTWVtb3J5XCJdPWUuZGF0YS53YXNtTWVtb3J5O01vZHVsZVtcImJ1ZmZlclwiXT1Nb2R1bGVbXCJ3YXNtTWVtb3J5XCJdLmJ1ZmZlcjtNb2R1bGVbXCJFTlZJUk9OTUVOVF9JU19QVEhSRUFEXCJdPXRydWU7aWYodHlwZW9mIGUuZGF0YS51cmxPckJsb2I9PVwic3RyaW5nXCIpe2ltcG9ydFNjcmlwdHMoZS5kYXRhLnVybE9yQmxvYil9ZWxzZXt2YXIgb2JqZWN0VXJsPVVSTC5jcmVhdGVPYmplY3RVUkwoZS5kYXRhLnVybE9yQmxvYik7aW1wb3J0U2NyaXB0cyhvYmplY3RVcmwpO1VSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKX1XYXNtQmFja2VuZE1vZHVsZVRocmVhZGVkU2ltZChNb2R1bGUpfWVsc2UgaWYoZS5kYXRhLmNtZD09PVwicnVuXCIpe01vZHVsZVtcIl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdFwiXShlLmRhdGEucHRocmVhZF9wdHIsMCwwLDEpO01vZHVsZVtcImVzdGFibGlzaFN0YWNrU3BhY2VcIl0oKTtNb2R1bGVbXCJQVGhyZWFkXCJdLnJlY2VpdmVPYmplY3RUcmFuc2ZlcihlLmRhdGEpO01vZHVsZVtcIlBUaHJlYWRcIl0udGhyZWFkSW5pdFRMUygpO2lmKCFpbml0aWFsaXplZEpTKXtwZW5kaW5nTm90aWZpZWRQcm94eWluZ1F1ZXVlcy5mb3JFYWNoKHF1ZXVlPT57TW9kdWxlW1wiZXhlY3V0ZU5vdGlmaWVkUHJveHlpbmdRdWV1ZVwiXShxdWV1ZSl9KTtwZW5kaW5nTm90aWZpZWRQcm94eWluZ1F1ZXVlcz1bXTtpbml0aWFsaXplZEpTPXRydWV9dHJ5e01vZHVsZVtcImludm9rZUVudHJ5UG9pbnRcIl0oZS5kYXRhLnN0YXJ0X3JvdXRpbmUsZS5kYXRhLmFyZyl9Y2F0Y2goZXgpe2lmKGV4IT1cInVud2luZFwiKXtpZihleCBpbnN0YW5jZW9mIE1vZHVsZVtcIkV4aXRTdGF0dXNcIl0pe2lmKE1vZHVsZVtcImtlZXBSdW50aW1lQWxpdmVcIl0oKSl7fWVsc2V7TW9kdWxlW1wiX19lbXNjcmlwdGVuX3RocmVhZF9leGl0XCJdKGV4LnN0YXR1cyl9fWVsc2V7dGhyb3cgZXh9fX19ZWxzZSBpZihlLmRhdGEuY21kPT09XCJjYW5jZWxcIil7aWYoTW9kdWxlW1wiX3B0aHJlYWRfc2VsZlwiXSgpKXtNb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXRcIl0oLTEpfX1lbHNlIGlmKGUuZGF0YS50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiKXt9ZWxzZSBpZihlLmRhdGEuY21kPT09XCJwcm9jZXNzUHJveHlpbmdRdWV1ZVwiKXtpZihpbml0aWFsaXplZEpTKXtNb2R1bGVbXCJleGVjdXRlTm90aWZpZWRQcm94eWluZ1F1ZXVlXCJdKGUuZGF0YS5xdWV1ZSl9ZWxzZXtwZW5kaW5nTm90aWZpZWRQcm94eWluZ1F1ZXVlcy5wdXNoKGUuZGF0YS5xdWV1ZSl9fWVsc2UgaWYoZS5kYXRhLmNtZCl7ZXJyKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIitlLmRhdGEuY21kKTtlcnIoZS5kYXRhKX19Y2F0Y2goZXgpe2lmKE1vZHVsZVtcIl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZFwiXSl7TW9kdWxlW1wiX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkXCJdKCl9dGhyb3cgZXh9fTtgfSksR1I9VnQoKGUsdCk9Pnt2YXIgbj0oKCk9Pnt2YXIgYT10eXBlb2YgZG9jdW1lbnQhPVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwO3JldHVybiB0eXBlb2YgX19maWxlbmFtZSE9XCJ1bmRlZmluZWRcIiYmKGE9YXx8X19maWxlbmFtZSksZnVuY3Rpb24ocil7cj1yfHx7fTt2YXIgcz10eXBlb2YgciE9XCJ1bmRlZmluZWRcIj9yOnt9LGksbztzLnJlYWR5PW5ldyBQcm9taXNlKGZ1bmN0aW9uKFksb2Upe2k9WSxvPW9lfSk7dmFyIGw7dHlwZW9mIHByb2Nlc3MhPVwidW5kZWZpbmVkXCImJnByb2Nlc3MubGlzdGVuZXJzJiYobD17dW5jYXVnaHRFeGNlcHRpb246cHJvY2Vzcy5saXN0ZW5lcnMoXCJ1bmNhdWdodEV4Y2VwdGlvblwiKSx1bmhhbmRsZWRSZWplY3Rpb246cHJvY2Vzcy5saXN0ZW5lcnMoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIil9KTt2YXIgdT1PYmplY3QuYXNzaWduKHt9LHMpLHA9W10sZD1cIi4vdGhpcy5wcm9ncmFtXCIsYz0oWSxvZSk9Pnt0aHJvdyBvZX0saD10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLG09dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixmPXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09XCJzdHJpbmdcIixnPVwiXCI7ZnVuY3Rpb24gYihZKXtyZXR1cm4gcy5sb2NhdGVGaWxlP3MubG9jYXRlRmlsZShZLGcpOmcrWX12YXIgeSx4LHYsSTtmdW5jdGlvbiBOKFkpe1kgaW5zdGFuY2VvZiBmbHx8RChcImV4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogXCIrWSl9aWYoZil7dmFyIEM9SXYoKSxfPSRTKCk7bT9nPV8uZGlybmFtZShnKStcIi9cIjpnPV9fZGlybmFtZStcIi9cIix5PShZLG9lKT0+KFk9VXIoWSk/bmV3IFVSTChZKTpfLm5vcm1hbGl6ZShZKSxDLnJlYWRGaWxlU3luYyhZLG9lP3ZvaWQgMDpcInV0ZjhcIikpLHY9WT0+e3ZhciBvZT15KFksITApO3JldHVybiBvZS5idWZmZXJ8fChvZT1uZXcgVWludDhBcnJheShvZSkpLG9lfSx4PShZLG9lLEllKT0+e1k9VXIoWSk/bmV3IFVSTChZKTpfLm5vcm1hbGl6ZShZKSxDLnJlYWRGaWxlKFksZnVuY3Rpb24oWWUsd3Qpe1llP0llKFllKTpvZSh3dC5idWZmZXIpfSl9LHByb2Nlc3MuYXJndi5sZW5ndGg+MSYmKGQ9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZyxcIi9cIikpLHA9cHJvY2Vzcy5hcmd2LnNsaWNlKDIpLHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLGZ1bmN0aW9uKFkpe2lmKCEoWSBpbnN0YW5jZW9mIGZsKSl0aHJvdyBZfSkscHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLGZ1bmN0aW9uKFkpe3Rocm93IFl9KSxjPShZLG9lKT0+e2lmKEduKCkpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1ZLG9lO04ob2UpLHByb2Nlc3MuZXhpdChZKX0scy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifX1lbHNlKGh8fG0pJiYobT9nPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQhPVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihnPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxhJiYoZz1hKSxnLmluZGV4T2YoXCJibG9iOlwiKSE9PTA/Zz1nLnN1YnN0cigwLGcucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6Zz1cIlwiLHk9WT0+e3ZhciBvZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIG9lLm9wZW4oXCJHRVRcIixZLCExKSxvZS5zZW5kKG51bGwpLG9lLnJlc3BvbnNlVGV4dH0sbSYmKHY9WT0+e3ZhciBvZT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIG9lLm9wZW4oXCJHRVRcIixZLCExKSxvZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLG9lLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkob2UucmVzcG9uc2UpfSkseD0oWSxvZSxJZSk9Pnt2YXIgWWU9bmV3IFhNTEh0dHBSZXF1ZXN0O1llLm9wZW4oXCJHRVRcIixZLCEwKSxZZS5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLFllLm9ubG9hZD0oKT0+e2lmKFllLnN0YXR1cz09MjAwfHxZZS5zdGF0dXM9PTAmJlllLnJlc3BvbnNlKXtvZShZZS5yZXNwb25zZSk7cmV0dXJufUllKCl9LFllLm9uZXJyb3I9SWUsWWUuc2VuZChudWxsKX0sST1ZPT5kb2N1bWVudC50aXRsZT1ZKTt2YXIgRj1zLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEQ9cy5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihzLHUpLHU9bnVsbCxzLmFyZ3VtZW50cyYmKHA9cy5hcmd1bWVudHMpLHMudGhpc1Byb2dyYW0mJihkPXMudGhpc1Byb2dyYW0pLHMucXVpdCYmKGM9cy5xdWl0KTt2YXIgJD00LFM7cy53YXNtQmluYXJ5JiYoUz1zLndhc21CaW5hcnkpO3ZhciBNPXMubm9FeGl0UnVudGltZXx8ITA7dHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiJiZaYShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIEIsVT0hMSxIO2Z1bmN0aW9uIHEoWSxvZSl7WXx8WmEob2UpfXZhciBLPXR5cGVvZiBUZXh0RGVjb2RlciE9XCJ1bmRlZmluZWRcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiBaKFksb2UsSWUpe29lPj4+PTA7Zm9yKHZhciBZZT1vZStJZSx3dD1vZTtZW3d0XSYmISh3dD49WWUpOykrK3d0O2lmKHd0LW9lPjE2JiZZLmJ1ZmZlciYmSylyZXR1cm4gSy5kZWNvZGUoWS5zdWJhcnJheShvZSx3dCkpO2Zvcih2YXIga3Q9XCJcIjtvZTx3dDspe3ZhciBHZT1ZW29lKytdO2lmKCEoR2UmMTI4KSl7a3QrPVN0cmluZy5mcm9tQ2hhckNvZGUoR2UpO2NvbnRpbnVlfXZhciBCZT1ZW29lKytdJjYzO2lmKChHZSYyMjQpPT0xOTIpe2t0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKChHZSYzMSk8PDZ8QmUpO2NvbnRpbnVlfXZhciBQdD1ZW29lKytdJjYzO2lmKChHZSYyNDApPT0yMjQ/R2U9KEdlJjE1KTw8MTJ8QmU8PDZ8UHQ6R2U9KEdlJjcpPDwxOHxCZTw8MTJ8UHQ8PDZ8WVtvZSsrXSY2MyxHZTw2NTUzNilrdCs9U3RyaW5nLmZyb21DaGFyQ29kZShHZSk7ZWxzZXt2YXIgbGE9R2UtNjU1MzY7a3QrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8bGE+PjEwLDU2MzIwfGxhJjEwMjMpfX1yZXR1cm4ga3R9ZnVuY3Rpb24gSihZLG9lKXtyZXR1cm4gWT4+Pj0wLFk/WihpZSxZLG9lKTpcIlwifWZ1bmN0aW9uIGVlKFksb2UsSWUsWWUpe2lmKEllPj4+PTAsIShZZT4wKSlyZXR1cm4gMDtmb3IodmFyIHd0PUllLGt0PUllK1llLTEsR2U9MDtHZTxZLmxlbmd0aDsrK0dlKXt2YXIgQmU9WS5jaGFyQ29kZUF0KEdlKTtpZihCZT49NTUyOTYmJkJlPD01NzM0Myl7dmFyIFB0PVkuY2hhckNvZGVBdCgrK0dlKTtCZT02NTUzNisoKEJlJjEwMjMpPDwxMCl8UHQmMTAyM31pZihCZTw9MTI3KXtpZihJZT49a3QpYnJlYWs7b2VbSWUrKz4+PjBdPUJlfWVsc2UgaWYoQmU8PTIwNDcpe2lmKEllKzE+PWt0KWJyZWFrO29lW0llKys+Pj4wXT0xOTJ8QmU+PjYsb2VbSWUrKz4+PjBdPTEyOHxCZSY2M31lbHNlIGlmKEJlPD02NTUzNSl7aWYoSWUrMj49a3QpYnJlYWs7b2VbSWUrKz4+PjBdPTIyNHxCZT4+MTIsb2VbSWUrKz4+PjBdPTEyOHxCZT4+NiY2MyxvZVtJZSsrPj4+MF09MTI4fEJlJjYzfWVsc2V7aWYoSWUrMz49a3QpYnJlYWs7b2VbSWUrKz4+PjBdPTI0MHxCZT4+MTgsb2VbSWUrKz4+PjBdPTEyOHxCZT4+MTImNjMsb2VbSWUrKz4+PjBdPTEyOHxCZT4+NiY2MyxvZVtJZSsrPj4+MF09MTI4fEJlJjYzfX1yZXR1cm4gb2VbSWU+Pj4wXT0wLEllLXd0fWZ1bmN0aW9uIGFlKFksb2UsSWUpe3JldHVybiBlZShZLGllLG9lLEllKX12YXIgdGUsc2UsaWUsdmUsdWUseWUsa2UsU2UsTGU7ZnVuY3Rpb24gVWUoWSl7dGU9WSxzLkhFQVA4PXNlPW5ldyBJbnQ4QXJyYXkoWSkscy5IRUFQMTY9dmU9bmV3IEludDE2QXJyYXkoWSkscy5IRUFQMzI9eWU9bmV3IEludDMyQXJyYXkoWSkscy5IRUFQVTg9aWU9bmV3IFVpbnQ4QXJyYXkoWSkscy5IRUFQVTE2PXVlPW5ldyBVaW50MTZBcnJheShZKSxzLkhFQVBVMzI9a2U9bmV3IFVpbnQzMkFycmF5KFkpLHMuSEVBUEYzMj1TZT1uZXcgRmxvYXQzMkFycmF5KFkpLHMuSEVBUEY2ND1MZT1uZXcgRmxvYXQ2NEFycmF5KFkpfXZhciBtdD1zLklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNixzdCx0dD1bXSxudD1bXSxSZT1bXSxndD0hMTtmdW5jdGlvbiBHbigpe3JldHVybiBNfWZ1bmN0aW9uIE90KCl7aWYocy5wcmVSdW4pZm9yKHR5cGVvZiBzLnByZVJ1bj09XCJmdW5jdGlvblwiJiYocy5wcmVSdW49W3MucHJlUnVuXSk7cy5wcmVSdW4ubGVuZ3RoOylGbihzLnByZVJ1bi5zaGlmdCgpKTt2cih0dCl9ZnVuY3Rpb24gaWEoKXtndD0hMCx2cihudCl9ZnVuY3Rpb24gdW4oKXtpZihzLnBvc3RSdW4pZm9yKHR5cGVvZiBzLnBvc3RSdW49PVwiZnVuY3Rpb25cIiYmKHMucG9zdFJ1bj1bcy5wb3N0UnVuXSk7cy5wb3N0UnVuLmxlbmd0aDspJG4ocy5wb3N0UnVuLnNoaWZ0KCkpO3ZyKFJlKX1mdW5jdGlvbiBGbihZKXt0dC51bnNoaWZ0KFkpfWZ1bmN0aW9uIG9hKFkpe250LnVuc2hpZnQoWSl9ZnVuY3Rpb24gJG4oWSl7UmUudW5zaGlmdChZKX12YXIgdXQ9MCxEbj1udWxsLEhuPW51bGw7ZnVuY3Rpb24geHIoWSl7dXQrKyxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyh1dCl9ZnVuY3Rpb24gbWwoWSl7aWYodXQtLSxzLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJnMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyh1dCksdXQ9PTAmJihEbiE9PW51bGwmJihjbGVhckludGVydmFsKERuKSxEbj1udWxsKSxIbikpe3ZhciBvZT1IbjtIbj1udWxsLG9lKCl9fWZ1bmN0aW9uIFphKFkpe3Mub25BYm9ydCYmcy5vbkFib3J0KFkpLFk9XCJBYm9ydGVkKFwiK1krXCIpXCIsRChZKSxVPSEwLEg9MSxZKz1cIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIjt2YXIgb2U9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihZKTt0aHJvdyBvKG9lKSxvZX12YXIgV3A9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7ZnVuY3Rpb24gSWEoWSl7cmV0dXJuIFkuc3RhcnRzV2l0aChXcCl9ZnVuY3Rpb24gVXIoWSl7cmV0dXJuIFkuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil9dmFyIEp0O0p0PVwidGZqcy1iYWNrZW5kLXdhc20ud2FzbVwiLElhKEp0KXx8KEp0PWIoSnQpKTtmdW5jdGlvbiBIZChZKXt0cnl7aWYoWT09SnQmJlMpcmV0dXJuIG5ldyBVaW50OEFycmF5KFMpO2lmKHYpcmV0dXJuIHYoWSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2gob2Upe1phKG9lKX19ZnVuY3Rpb24gU2coKXtpZighUyYmKGh8fG0pKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIVVyKEp0KSlyZXR1cm4gZmV0Y2goSnQse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24oWSl7aWYoIVkub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK0p0K1wiJ1wiO3JldHVybiBZLmFycmF5QnVmZmVyKCl9KS5jYXRjaChmdW5jdGlvbigpe3JldHVybiBIZChKdCl9KTtpZih4KXJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihZLG9lKXt4KEp0LGZ1bmN0aW9uKEllKXtZKG5ldyBVaW50OEFycmF5KEllKSl9LG9lKX0pfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEhkKEp0KX0pfWZ1bmN0aW9uIE5nKCl7dmFyIFk9e2VudjpCcCx3YXNpX3NuYXBzaG90X3ByZXZpZXcxOkJwfTtmdW5jdGlvbiBvZShHZSxCZSl7dmFyIFB0PUdlLmV4cG9ydHM7cy5hc209UHQsQj1zLmFzbS5tZW1vcnksVWUoQi5idWZmZXIpLHN0PXMuYXNtLl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUsb2Eocy5hc20uX193YXNtX2NhbGxfY3RvcnMpLG1sKFwid2FzbS1pbnN0YW50aWF0ZVwiKX14cihcIndhc20taW5zdGFudGlhdGVcIik7ZnVuY3Rpb24gSWUoR2Upe29lKEdlLmluc3RhbmNlKX1mdW5jdGlvbiBZZShHZSl7cmV0dXJuIFNnKCkudGhlbihmdW5jdGlvbihCZSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEJlLFkpfSkudGhlbihmdW5jdGlvbihCZSl7cmV0dXJuIEJlfSkudGhlbihHZSxmdW5jdGlvbihCZSl7RChcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK0JlKSxaYShCZSl9KX1mdW5jdGlvbiB3dCgpe3JldHVybiFTJiZ0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmc9PVwiZnVuY3Rpb25cIiYmIUlhKEp0KSYmIVVyKEp0KSYmIWYmJnR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiP2ZldGNoKEp0LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKEdlKXt2YXIgQmU9V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoR2UsWSk7cmV0dXJuIEJlLnRoZW4oSWUsZnVuY3Rpb24oUHQpe3JldHVybiBEKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK1B0KSxEKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksWWUoSWUpfSl9KTpZZShJZSl9aWYocy5pbnN0YW50aWF0ZVdhc20pdHJ5e3ZhciBrdD1zLmluc3RhbnRpYXRlV2FzbShZLG9lKTtyZXR1cm4ga3R9Y2F0Y2goR2Upe0QoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitHZSksbyhHZSl9cmV0dXJuIHd0KCkuY2F0Y2gobykse319dmFyIFJrLEdyO2Z1bmN0aW9uIGZsKFkpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK1krXCIpXCIsdGhpcy5zdGF0dXM9WX1mdW5jdGlvbiB2cihZKXtmb3IoO1kubGVuZ3RoPjA7KVkuc2hpZnQoKShzKX1mdW5jdGlvbiBUZygpe1phKFwiXCIpfWZ1bmN0aW9uIGpkKCl7cmV0dXJuIDQyOTQ5MDE3NjB9ZnVuY3Rpb24gVXMoKXtyZXR1cm4gamQoKX1mdW5jdGlvbiBDZyhZLG9lLEllKXtpZS5jb3B5V2l0aGluKFk+Pj4wLG9lPj4+MCxvZStJZT4+PjApfWZ1bmN0aW9uIHFkKFkpe3RyeXtyZXR1cm4gQi5ncm93KFktdGUuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxVZShCLmJ1ZmZlciksMX1jYXRjaChvZSl7fX1mdW5jdGlvbiBnbChZKXt2YXIgb2U9aWUubGVuZ3RoO1k9WT4+PjA7dmFyIEllPWpkKCk7aWYoWT5JZSlyZXR1cm4hMTtsZXQgWWU9KFB0LGxhKT0+UHQrKGxhLVB0JWxhKSVsYTtmb3IodmFyIHd0PTE7d3Q8PTQ7d3QqPTIpe3ZhciBrdD1vZSooMSsuMi93dCk7a3Q9TWF0aC5taW4oa3QsWSsxMDA2NjMyOTYpO3ZhciBHZT1NYXRoLm1pbihJZSxZZShNYXRoLm1heChZLGt0KSw2NTUzNikpLEJlPXFkKEdlKTtpZihCZSlyZXR1cm4hMH1yZXR1cm4hMX12YXIgZ249e3ZhcmFyZ3M6dm9pZCAwLGdldDpmdW5jdGlvbigpe2duLnZhcmFyZ3MrPTQ7dmFyIFk9eWVbZ24udmFyYXJncy00Pj4+Ml07cmV0dXJuIFl9LGdldFN0cjpmdW5jdGlvbihZKXt2YXIgb2U9SihZKTtyZXR1cm4gb2V9fTtmdW5jdGlvbiBLZChZKXtyZXR1cm4gNTJ9ZnVuY3Rpb24gRWcoWSxvZSxJZSxZZSx3dCl7cmV0dXJuIDcwfXZhciBfZz1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gTWsoWSxvZSl7dmFyIEllPV9nW1ldO29lPT09MHx8b2U9PT0xMD8oKFk9PT0xP0Y6RCkoWihJZSwwKSksSWUubGVuZ3RoPTApOkllLnB1c2gob2UpfWZ1bmN0aW9uIE9rKFksb2UsSWUsWWUpe2Zvcih2YXIgd3Q9MCxrdD0wO2t0PEllO2t0Kyspe3ZhciBHZT1rZVtvZT4+PjJdLEJlPWtlW29lKzQ+Pj4yXTtvZSs9ODtmb3IodmFyIFB0PTA7UHQ8QmU7UHQrKylNayhZLGllW0dlK1B0Pj4+MF0pO3d0Kz1CZX1yZXR1cm4ga2VbWWU+Pj4yXT13dCwwfWZ1bmN0aW9uIFhkKFkpe3ZhciBvZT1zW1wiX1wiK1ldO3JldHVybiBvZX1mdW5jdGlvbiBHcyhZLG9lKXtzZS5zZXQoWSxvZT4+PjApfWZ1bmN0aW9uIEFnKFksb2UsSWUsWWUsd3Qpe3ZhciBrdD17c3RyaW5nOlJuPT57dmFyIGpyPTA7aWYoUm4hPW51bGwmJlJuIT09MCl7dmFyIGRoPShSbi5sZW5ndGg8PDIpKzE7anI9anAoZGgpLGFlKFJuLGpyLGRoKX1yZXR1cm4ganJ9LGFycmF5OlJuPT57dmFyIGpyPWpwKFJuLmxlbmd0aCk7cmV0dXJuIEdzKFJuLGpyKSxqcn19O2Z1bmN0aW9uIEdlKFJuKXtyZXR1cm4gb2U9PT1cInN0cmluZ1wiP0ooUm4pOm9lPT09XCJib29sZWFuXCI/ISFSbjpSbn12YXIgQmU9WGQoWSksUHQ9W10sbGE9MDtpZihZZSlmb3IodmFyIHdyPTA7d3I8WWUubGVuZ3RoO3dyKyspe3ZhciBjaD1rdFtJZVt3cl1dO2NoPyhsYT09PTAmJihsYT1saCgpKSxQdFt3cl09Y2goWWVbd3JdKSk6UHRbd3JdPVllW3dyXX12YXIgcXA9QmUuYXBwbHkobnVsbCxQdCk7ZnVuY3Rpb24gUXkoUm4pe3JldHVybiBsYSE9PTAmJnVoKGxhKSxHZShSbil9cmV0dXJuIHFwPVF5KHFwKSxxcH1mdW5jdGlvbiBGZyhZLG9lLEllLFllKXtJZT1JZXx8W107dmFyIHd0PUllLmV2ZXJ5KEdlPT5HZT09PVwibnVtYmVyXCJ8fEdlPT09XCJib29sZWFuXCIpLGt0PW9lIT09XCJzdHJpbmdcIjtyZXR1cm4ga3QmJnd0JiYhWWU/WGQoWSk6ZnVuY3Rpb24oKXtyZXR1cm4gQWcoWSxvZSxJZSxhcmd1bWVudHMsWWUpfX12YXIgQnA9e2Fib3J0OlRnLGVtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4OlVzLGVtc2NyaXB0ZW5fbWVtY3B5X2JpZzpDZyxlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwOmdsLGZkX2Nsb3NlOktkLGZkX3NlZWs6RWcsZmRfd3JpdGU6T2t9LCRnPU5nKCksWWQ9cy5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oWWQ9cy5fX193YXNtX2NhbGxfY3RvcnM9cy5hc20uX193YXNtX2NhbGxfY3RvcnMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWmQ9cy5faW5pdD1mdW5jdGlvbigpe3JldHVybihaZD1zLl9pbml0PXMuYXNtLmluaXQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGc9cy5faW5pdF93aXRoX3RocmVhZHNfY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oRGc9cy5faW5pdF93aXRoX3RocmVhZHNfY291bnQ9cy5hc20uaW5pdF93aXRoX3RocmVhZHNfY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSmQ9cy5fZ2V0X3RocmVhZHNfY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oSmQ9cy5fZ2V0X3RocmVhZHNfY291bnQ9cy5hc20uZ2V0X3RocmVhZHNfY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUmc9cy5fcmVnaXN0ZXJfdGVuc29yPWZ1bmN0aW9uKCl7cmV0dXJuKFJnPXMuX3JlZ2lzdGVyX3RlbnNvcj1zLmFzbS5yZWdpc3Rlcl90ZW5zb3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQWU9cy5fZGlzcG9zZV9kYXRhPWZ1bmN0aW9uKCl7cmV0dXJuKEFlPXMuX2Rpc3Bvc2VfZGF0YT1zLmFzbS5kaXNwb3NlX2RhdGEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVnA9cy5fZGlzcG9zZT1mdW5jdGlvbigpe3JldHVybihWcD1zLl9kaXNwb3NlPXMuYXNtLmRpc3Bvc2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWc9cy5fQWJzPWZ1bmN0aW9uKCl7cmV0dXJuKE1nPXMuX0Ficz1zLmFzbS5BYnMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUWQ9cy5fQWNvcz1mdW5jdGlvbigpe3JldHVybihRZD1zLl9BY29zPXMuYXNtLkFjb3MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYmw9cy5fQWNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4oYmw9cy5fQWNvc2g9cy5hc20uQWNvc2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2c9cy5fQWRkPWZ1bmN0aW9uKCl7cmV0dXJuKE9nPXMuX0FkZD1zLmFzbS5BZGQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUGc9cy5fQWRkTj1mdW5jdGlvbigpe3JldHVybihQZz1zLl9BZGROPXMuYXNtLkFkZE4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTGc9cy5fQWxsPWZ1bmN0aW9uKCl7cmV0dXJuKExnPXMuX0FsbD1zLmFzbS5BbGwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0semc9cy5fQW55PWZ1bmN0aW9uKCl7cmV0dXJuKHpnPXMuX0FueT1zLmFzbS5BbnkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV2c9cy5fQXJnTWF4PWZ1bmN0aW9uKCl7cmV0dXJuKFdnPXMuX0FyZ01heD1zLmFzbS5BcmdNYXgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZWg9cy5fQXJnTWluPWZ1bmN0aW9uKCl7cmV0dXJuKGVoPXMuX0FyZ01pbj1zLmFzbS5BcmdNaW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdGg9cy5fQXNpbj1mdW5jdGlvbigpe3JldHVybih0aD1zLl9Bc2luPXMuYXNtLkFzaW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQmc9cy5fQXNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4oQmc9cy5fQXNpbmg9cy5hc20uQXNpbmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVmc9cy5fQXRhbj1mdW5jdGlvbigpe3JldHVybihWZz1zLl9BdGFuPXMuYXNtLkF0YW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVWc9cy5fQXRhbjI9ZnVuY3Rpb24oKXtyZXR1cm4oVWc9cy5fQXRhbjI9cy5hc20uQXRhbjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVXA9cy5fQXRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4oVXA9cy5fQXRhbmg9cy5hc20uQXRhbmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sR2c9cy5fQXZnUG9vbD1mdW5jdGlvbigpe3JldHVybihHZz1zLl9BdmdQb29sPXMuYXNtLkF2Z1Bvb2wpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSGc9cy5fQXZnUG9vbDNEPWZ1bmN0aW9uKCl7cmV0dXJuKEhnPXMuX0F2Z1Bvb2wzRD1zLmFzbS5BdmdQb29sM0QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0samc9cy5fQXZnUG9vbDNER3JhZD1mdW5jdGlvbigpe3JldHVybihqZz1zLl9BdmdQb29sM0RHcmFkPXMuYXNtLkF2Z1Bvb2wzREdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSHM9cy5fQXZnUG9vbEdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oSHM9cy5fQXZnUG9vbEdyYWQ9cy5hc20uQXZnUG9vbEdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scWc9cy5fQmF0Y2hNYXRNdWw9ZnVuY3Rpb24oKXtyZXR1cm4ocWc9cy5fQmF0Y2hNYXRNdWw9cy5hc20uQmF0Y2hNYXRNdWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sS2c9cy5fQmluY291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4oS2c9cy5fQmluY291bnQ9cy5hc20uQmluY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbmg9cy5fQml0d2lzZUFuZD1mdW5jdGlvbigpe3JldHVybihuaD1zLl9CaXR3aXNlQW5kPXMuYXNtLkJpdHdpc2VBbmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWGc9cy5fQ2VpbD1mdW5jdGlvbigpe3JldHVybihYZz1zLl9DZWlsPXMuYXNtLkNlaWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sR3A9cy5fQ2xpcEJ5VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4oR3A9cy5fQ2xpcEJ5VmFsdWU9cy5hc20uQ2xpcEJ5VmFsdWUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWWc9cy5fQ29udjJEPWZ1bmN0aW9uKCl7cmV0dXJuKFlnPXMuX0NvbnYyRD1zLmFzbS5Db252MkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWmc9cy5fQ29udjJEQmFja3Byb3BJbnB1dD1mdW5jdGlvbigpe3JldHVybihaZz1zLl9Db252MkRCYWNrcHJvcElucHV0PXMuYXNtLkNvbnYyREJhY2twcm9wSW5wdXQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSmc9cy5fQ29udjNEPWZ1bmN0aW9uKCl7cmV0dXJuKEpnPXMuX0NvbnYzRD1zLmFzbS5Db252M0QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSHI9cy5fQ29udjNEQmFja3Byb3BGaWx0ZXJWMj1mdW5jdGlvbigpe3JldHVybihIcj1zLl9Db252M0RCYWNrcHJvcEZpbHRlclYyPXMuYXNtLkNvbnYzREJhY2twcm9wRmlsdGVyVjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSHA9cy5fQ29udjNEQmFja3Byb3BJbnB1dFYyPWZ1bmN0aW9uKCl7cmV0dXJuKEhwPXMuX0NvbnYzREJhY2twcm9wSW5wdXRWMj1zLmFzbS5Db252M0RCYWNrcHJvcElucHV0VjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUWc9cy5fQ29zPWZ1bmN0aW9uKCl7cmV0dXJuKFFnPXMuX0Nvcz1zLmFzbS5Db3MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZWI9cy5fQ29zaD1mdW5jdGlvbigpe3JldHVybihlYj1zLl9Db3NoPXMuYXNtLkNvc2gpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdGI9cy5fQ3JvcEFuZFJlc2l6ZT1mdW5jdGlvbigpe3JldHVybih0Yj1zLl9Dcm9wQW5kUmVzaXplPXMuYXNtLkNyb3BBbmRSZXNpemUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbmI9cy5fQ3VtcHJvZD1mdW5jdGlvbigpe3JldHVybihuYj1zLl9DdW1wcm9kPXMuYXNtLkN1bXByb2QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYWg9cy5fQ3Vtc3VtPWZ1bmN0aW9uKCl7cmV0dXJuKGFoPXMuX0N1bXN1bT1zLmFzbS5DdW1zdW0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scmg9cy5fRGVuc2VCaW5jb3VudD1mdW5jdGlvbigpe3JldHVybihyaD1zLl9EZW5zZUJpbmNvdW50PXMuYXNtLkRlbnNlQmluY291bnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYWI9cy5fRGVwdGhUb1NwYWNlPWZ1bmN0aW9uKCl7cmV0dXJuKGFiPXMuX0RlcHRoVG9TcGFjZT1zLmFzbS5EZXB0aFRvU3BhY2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scmI9cy5fRGVwdGh3aXNlQ29udjJkTmF0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuKHJiPXMuX0RlcHRod2lzZUNvbnYyZE5hdGl2ZT1zLmFzbS5EZXB0aHdpc2VDb252MmROYXRpdmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sc2g9cy5fRGlhZz1mdW5jdGlvbigpe3JldHVybihzaD1zLl9EaWFnPXMuYXNtLkRpYWcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saWg9cy5fRGlsYXRpb24yRD1mdW5jdGlvbigpe3JldHVybihpaD1zLl9EaWxhdGlvbjJEPXMuYXNtLkRpbGF0aW9uMkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sc2I9cy5fRGlsYXRpb24yREJhY2twcm9wRmlsdGVyPWZ1bmN0aW9uKCl7cmV0dXJuKHNiPXMuX0RpbGF0aW9uMkRCYWNrcHJvcEZpbHRlcj1zLmFzbS5EaWxhdGlvbjJEQmFja3Byb3BGaWx0ZXIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saWI9cy5fRGlsYXRpb24yREJhY2twcm9wSW5wdXQ9ZnVuY3Rpb24oKXtyZXR1cm4oaWI9cy5fRGlsYXRpb24yREJhY2twcm9wSW5wdXQ9cy5hc20uRGlsYXRpb24yREJhY2twcm9wSW5wdXQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sb2I9cy5fRWx1PWZ1bmN0aW9uKCl7cmV0dXJuKG9iPXMuX0VsdT1zLmFzbS5FbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbGI9cy5fRWx1R3JhZD1mdW5jdGlvbigpe3JldHVybihsYj1zLl9FbHVHcmFkPXMuYXNtLkVsdUdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sb2g9cy5fRXF1YWw9ZnVuY3Rpb24oKXtyZXR1cm4ob2g9cy5fRXF1YWw9cy5hc20uRXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUGs9cy5fRXJmPWZ1bmN0aW9uKCl7cmV0dXJuKFBrPXMuX0VyZj1zLmFzbS5FcmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdWI9cy5fRXhwPWZ1bmN0aW9uKCl7cmV0dXJuKHViPXMuX0V4cD1zLmFzbS5FeHApLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scGI9cy5fRXhwbTE9ZnVuY3Rpb24oKXtyZXR1cm4ocGI9cy5fRXhwbTE9cy5hc20uRXhwbTEpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sY2I9cy5fRmxpcExlZnRSaWdodD1mdW5jdGlvbigpe3JldHVybihjYj1zLl9GbGlwTGVmdFJpZ2h0PXMuYXNtLkZsaXBMZWZ0UmlnaHQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZGI9cy5fRmxvb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZGI9cy5fRmxvb3I9cy5hc20uRmxvb3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saGI9cy5fRmxvb3JEaXY9ZnVuY3Rpb24oKXtyZXR1cm4oaGI9cy5fRmxvb3JEaXY9cy5hc20uRmxvb3JEaXYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbWI9cy5fRnVzZWRCYXRjaE5vcm09ZnVuY3Rpb24oKXtyZXR1cm4obWI9cy5fRnVzZWRCYXRjaE5vcm09cy5hc20uRnVzZWRCYXRjaE5vcm0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZmI9cy5fRnVzZWRDb252MkQ9ZnVuY3Rpb24oKXtyZXR1cm4oZmI9cy5fRnVzZWRDb252MkQ9cy5hc20uRnVzZWRDb252MkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZ2I9cy5fRnVzZWREZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24oKXtyZXR1cm4oZ2I9cy5fRnVzZWREZXB0aHdpc2VDb252MkQ9cy5hc20uRnVzZWREZXB0aHdpc2VDb252MkQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYmI9cy5fR2F0aGVyPWZ1bmN0aW9uKCl7cmV0dXJuKGJiPXMuX0dhdGhlcj1zLmFzbS5HYXRoZXIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seWI9cy5fR2F0aGVyTmQ9ZnVuY3Rpb24oKXtyZXR1cm4oeWI9cy5fR2F0aGVyTmQ9cy5hc20uR2F0aGVyTmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seGI9cy5fR3JlYXRlcj1mdW5jdGlvbigpe3JldHVybih4Yj1zLl9HcmVhdGVyPXMuYXNtLkdyZWF0ZXIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdmI9cy5fR3JlYXRlckVxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKHZiPXMuX0dyZWF0ZXJFcXVhbD1zLmFzbS5HcmVhdGVyRXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd2I9cy5fSXNGaW5pdGU9ZnVuY3Rpb24oKXtyZXR1cm4od2I9cy5fSXNGaW5pdGU9cy5hc20uSXNGaW5pdGUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sa2I9cy5fSXNJbmY9ZnVuY3Rpb24oKXtyZXR1cm4oa2I9cy5fSXNJbmY9cy5hc20uSXNJbmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSWI9cy5fSXNOYW49ZnVuY3Rpb24oKXtyZXR1cm4oSWI9cy5fSXNOYW49cy5hc20uSXNOYW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU2I9cy5fTFJOPWZ1bmN0aW9uKCl7cmV0dXJuKFNiPXMuX0xSTj1zLmFzbS5MUk4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTmI9cy5fTFJOR3JhZD1mdW5jdGlvbigpe3JldHVybihOYj1zLl9MUk5HcmFkPXMuYXNtLkxSTkdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVGI9cy5fTGVha3lSZWx1PWZ1bmN0aW9uKCl7cmV0dXJuKFRiPXMuX0xlYWt5UmVsdT1zLmFzbS5MZWFreVJlbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ2I9cy5fTGVzcz1mdW5jdGlvbigpe3JldHVybihDYj1zLl9MZXNzPXMuYXNtLkxlc3MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRWI9cy5fTGVzc0VxdWFsPWZ1bmN0aW9uKCl7cmV0dXJuKEViPXMuX0xlc3NFcXVhbD1zLmFzbS5MZXNzRXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX2I9cy5fTGluU3BhY2U9ZnVuY3Rpb24oKXtyZXR1cm4oX2I9cy5fTGluU3BhY2U9cy5hc20uTGluU3BhY2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQWI9cy5fTG9nPWZ1bmN0aW9uKCl7cmV0dXJuKEFiPXMuX0xvZz1zLmFzbS5Mb2cpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRmI9cy5fTG9nMXA9ZnVuY3Rpb24oKXtyZXR1cm4oRmI9cy5fTG9nMXA9cy5hc20uTG9nMXApLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sJGI9cy5fTG9naWNhbEFuZD1mdW5jdGlvbigpe3JldHVybigkYj1zLl9Mb2dpY2FsQW5kPXMuYXNtLkxvZ2ljYWxBbmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRGI9cy5fTG9naWNhbE5vdD1mdW5jdGlvbigpe3JldHVybihEYj1zLl9Mb2dpY2FsTm90PXMuYXNtLkxvZ2ljYWxOb3QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUmI9cy5fTG9naWNhbE9yPWZ1bmN0aW9uKCl7cmV0dXJuKFJiPXMuX0xvZ2ljYWxPcj1zLmFzbS5Mb2dpY2FsT3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTWI9cy5fTG9naWNhbFhvcj1mdW5jdGlvbigpe3JldHVybihNYj1zLl9Mb2dpY2FsWG9yPXMuYXNtLkxvZ2ljYWxYb3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT2I9cy5fTWF4PWZ1bmN0aW9uKCl7cmV0dXJuKE9iPXMuX01heD1zLmFzbS5NYXgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUGI9cy5fTWF4UG9vbD1mdW5jdGlvbigpe3JldHVybihQYj1zLl9NYXhQb29sPXMuYXNtLk1heFBvb2wpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTGI9cy5fTWF4UG9vbDNEPWZ1bmN0aW9uKCl7cmV0dXJuKExiPXMuX01heFBvb2wzRD1zLmFzbS5NYXhQb29sM0QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0semI9cy5fTWF4UG9vbDNER3JhZD1mdW5jdGlvbigpe3JldHVybih6Yj1zLl9NYXhQb29sM0RHcmFkPXMuYXNtLk1heFBvb2wzREdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV2I9cy5fTWF4UG9vbEdyYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oV2I9cy5fTWF4UG9vbEdyYWQ9cy5hc20uTWF4UG9vbEdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQmI9cy5fTWF4UG9vbFdpdGhBcmdtYXg9ZnVuY3Rpb24oKXtyZXR1cm4oQmI9cy5fTWF4UG9vbFdpdGhBcmdtYXg9cy5hc20uTWF4UG9vbFdpdGhBcmdtYXgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVmI9cy5fTWF4aW11bT1mdW5jdGlvbigpe3JldHVybihWYj1zLl9NYXhpbXVtPXMuYXNtLk1heGltdW0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVWI9cy5fTWVhbj1mdW5jdGlvbigpe3JldHVybihVYj1zLl9NZWFuPXMuYXNtLk1lYW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sR2I9cy5fTWluPWZ1bmN0aW9uKCl7cmV0dXJuKEdiPXMuX01pbj1zLmFzbS5NaW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSGI9cy5fTWluaW11bT1mdW5jdGlvbigpe3JldHVybihIYj1zLl9NaW5pbXVtPXMuYXNtLk1pbmltdW0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0samI9cy5fTWlycm9yUGFkPWZ1bmN0aW9uKCl7cmV0dXJuKGpiPXMuX01pcnJvclBhZD1zLmFzbS5NaXJyb3JQYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scWI9cy5fTW9kPWZ1bmN0aW9uKCl7cmV0dXJuKHFiPXMuX01vZD1zLmFzbS5Nb2QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sS2I9cy5fTXVsdGlub21pYWw9ZnVuY3Rpb24oKXtyZXR1cm4oS2I9cy5fTXVsdGlub21pYWw9cy5hc20uTXVsdGlub21pYWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWGI9cy5fTXVsdGlwbHk9ZnVuY3Rpb24oKXtyZXR1cm4oWGI9cy5fTXVsdGlwbHk9cy5hc20uTXVsdGlwbHkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWWI9cy5fTmVnPWZ1bmN0aW9uKCl7cmV0dXJuKFliPXMuX05lZz1zLmFzbS5OZWcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWmI9cy5fTm9uTWF4U3VwcHJlc3Npb25WMz1mdW5jdGlvbigpe3JldHVybihaYj1zLl9Ob25NYXhTdXBwcmVzc2lvblYzPXMuYXNtLk5vbk1heFN1cHByZXNzaW9uVjMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSmI9cy5fTm9uTWF4U3VwcHJlc3Npb25WND1mdW5jdGlvbigpe3JldHVybihKYj1zLl9Ob25NYXhTdXBwcmVzc2lvblY0PXMuYXNtLk5vbk1heFN1cHByZXNzaW9uVjQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUWI9cy5fTm9uTWF4U3VwcHJlc3Npb25WNT1mdW5jdGlvbigpe3JldHVybihRYj1zLl9Ob25NYXhTdXBwcmVzc2lvblY1PXMuYXNtLk5vbk1heFN1cHByZXNzaW9uVjUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZXk9cy5fTm90RXF1YWw9ZnVuY3Rpb24oKXtyZXR1cm4oZXk9cy5fTm90RXF1YWw9cy5hc20uTm90RXF1YWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdHk9cy5fT25lSG90PWZ1bmN0aW9uKCl7cmV0dXJuKHR5PXMuX09uZUhvdD1zLmFzbS5PbmVIb3QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbnk9cy5fUGFkVjI9ZnVuY3Rpb24oKXtyZXR1cm4obnk9cy5fUGFkVjI9cy5hc20uUGFkVjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYXk9cy5fUG93PWZ1bmN0aW9uKCl7cmV0dXJuKGF5PXMuX1Bvdz1zLmFzbS5Qb3cpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scnk9cy5fUHJlbHU9ZnVuY3Rpb24oKXtyZXR1cm4ocnk9cy5fUHJlbHU9cy5hc20uUHJlbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sc3k9cy5fUHJvZD1mdW5jdGlvbigpe3JldHVybihzeT1zLl9Qcm9kPXMuYXNtLlByb2QpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saXk9cy5fUmVhbERpdj1mdW5jdGlvbigpe3JldHVybihpeT1zLl9SZWFsRGl2PXMuYXNtLlJlYWxEaXYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sb3k9cy5fUmVjaXByb2NhbD1mdW5jdGlvbigpe3JldHVybihveT1zLl9SZWNpcHJvY2FsPXMuYXNtLlJlY2lwcm9jYWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbHk9cy5fUmVsdT1mdW5jdGlvbigpe3JldHVybihseT1zLl9SZWx1PXMuYXNtLlJlbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdXk9cy5fUmVsdTY9ZnVuY3Rpb24oKXtyZXR1cm4odXk9cy5fUmVsdTY9cy5hc20uUmVsdTYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scHk9cy5fUmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24oKXtyZXR1cm4ocHk9cy5fUmVzaXplQmlsaW5lYXI9cy5hc20uUmVzaXplQmlsaW5lYXIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sY3k9cy5fUmVzaXplQmlsaW5lYXJHcmFkPWZ1bmN0aW9uKCl7cmV0dXJuKGN5PXMuX1Jlc2l6ZUJpbGluZWFyR3JhZD1zLmFzbS5SZXNpemVCaWxpbmVhckdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZHk9cy5fUmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKCl7cmV0dXJuKGR5PXMuX1Jlc2l6ZU5lYXJlc3ROZWlnaGJvcj1zLmFzbS5SZXNpemVOZWFyZXN0TmVpZ2hib3IpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0saHk9cy5fUmVzaXplTmVhcmVzdE5laWdoYm9yR3JhZD1mdW5jdGlvbigpe3JldHVybihoeT1zLl9SZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkPXMuYXNtLlJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbXk9cy5fUmV2ZXJzZT1mdW5jdGlvbigpe3JldHVybihteT1zLl9SZXZlcnNlPXMuYXNtLlJldmVyc2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZnk9cy5fUm90YXRlV2l0aE9mZnNldD1mdW5jdGlvbigpe3JldHVybihmeT1zLl9Sb3RhdGVXaXRoT2Zmc2V0PXMuYXNtLlJvdGF0ZVdpdGhPZmZzZXQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sZ3k9cy5fUm91bmQ9ZnVuY3Rpb24oKXtyZXR1cm4oZ3k9cy5fUm91bmQ9cy5hc20uUm91bmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sYnk9cy5fUnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4oYnk9cy5fUnNxcnQ9cy5hc20uUnNxcnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seXk9cy5fU2NhdHRlck5kPWZ1bmN0aW9uKCl7cmV0dXJuKHl5PXMuX1NjYXR0ZXJOZD1zLmFzbS5TY2F0dGVyTmQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0seHk9cy5fU2VhcmNoU29ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuKHh5PXMuX1NlYXJjaFNvcnRlZD1zLmFzbS5TZWFyY2hTb3J0ZWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sdnk9cy5fU2VsZWN0VjI9ZnVuY3Rpb24oKXtyZXR1cm4odnk9cy5fU2VsZWN0VjI9cy5hc20uU2VsZWN0VjIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sd3k9cy5fU2VsdT1mdW5jdGlvbigpe3JldHVybih3eT1zLl9TZWx1PXMuYXNtLlNlbHUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sa3k9cy5fU2lnbW9pZD1mdW5jdGlvbigpe3JldHVybihreT1zLl9TaWdtb2lkPXMuYXNtLlNpZ21vaWQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSXk9cy5fU2lnbj1mdW5jdGlvbigpe3JldHVybihJeT1zLl9TaWduPXMuYXNtLlNpZ24pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sU3k9cy5fU2luPWZ1bmN0aW9uKCl7cmV0dXJuKFN5PXMuX1Npbj1zLmFzbS5TaW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTnk9cy5fU2luaD1mdW5jdGlvbigpe3JldHVybihOeT1zLl9TaW5oPXMuYXNtLlNpbmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVHk9cy5fU29mdG1heD1mdW5jdGlvbigpe3JldHVybihUeT1zLl9Tb2Z0bWF4PXMuYXNtLlNvZnRtYXgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQ3k9cy5fU29mdHBsdXM9ZnVuY3Rpb24oKXtyZXR1cm4oQ3k9cy5fU29mdHBsdXM9cy5hc20uU29mdHBsdXMpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRXk9cy5fU3BhcnNlRmlsbEVtcHR5Um93cz1mdW5jdGlvbigpe3JldHVybihFeT1zLl9TcGFyc2VGaWxsRW1wdHlSb3dzPXMuYXNtLlNwYXJzZUZpbGxFbXB0eVJvd3MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX3k9cy5fU3BhcnNlUmVzaGFwZT1mdW5jdGlvbigpe3JldHVybihfeT1zLl9TcGFyc2VSZXNoYXBlPXMuYXNtLlNwYXJzZVJlc2hhcGUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQXk9cy5fU3BhcnNlU2VnbWVudFJlZHVjdGlvbj1mdW5jdGlvbigpe3JldHVybihBeT1zLl9TcGFyc2VTZWdtZW50UmVkdWN0aW9uPXMuYXNtLlNwYXJzZVNlZ21lbnRSZWR1Y3Rpb24pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRnk9cy5fU3BhcnNlVG9EZW5zZT1mdW5jdGlvbigpe3JldHVybihGeT1zLl9TcGFyc2VUb0RlbnNlPXMuYXNtLlNwYXJzZVRvRGVuc2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sJHk9cy5fU3FydD1mdW5jdGlvbigpe3JldHVybigkeT1zLl9TcXJ0PXMuYXNtLlNxcnQpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRHk9cy5fU3F1YXJlPWZ1bmN0aW9uKCl7cmV0dXJuKER5PXMuX1NxdWFyZT1zLmFzbS5TcXVhcmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUnk9cy5fU3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24oKXtyZXR1cm4oUnk9cy5fU3F1YXJlZERpZmZlcmVuY2U9cy5hc20uU3F1YXJlZERpZmZlcmVuY2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTXk9cy5fU3RlcD1mdW5jdGlvbigpe3JldHVybihNeT1zLl9TdGVwPXMuYXNtLlN0ZXApLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sT3k9cy5fU3RyaWRlZFNsaWNlPWZ1bmN0aW9uKCl7cmV0dXJuKE95PXMuX1N0cmlkZWRTbGljZT1zLmFzbS5TdHJpZGVkU2xpY2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUHk9cy5fU3ViPWZ1bmN0aW9uKCl7cmV0dXJuKFB5PXMuX1N1Yj1zLmFzbS5TdWIpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sTHk9cy5fU3VtPWZ1bmN0aW9uKCl7cmV0dXJuKEx5PXMuX1N1bT1zLmFzbS5TdW0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0senk9cy5fVGFuPWZ1bmN0aW9uKCl7cmV0dXJuKHp5PXMuX1Rhbj1zLmFzbS5UYW4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sV3k9cy5fVGFuaD1mdW5jdGlvbigpe3JldHVybihXeT1zLl9UYW5oPXMuYXNtLlRhbmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQnk9cy5fVGVuc29yU2NhdHRlclVwZGF0ZT1mdW5jdGlvbigpe3JldHVybihCeT1zLl9UZW5zb3JTY2F0dGVyVXBkYXRlPXMuYXNtLlRlbnNvclNjYXR0ZXJVcGRhdGUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVnk9cy5fVGlsZT1mdW5jdGlvbigpe3JldHVybihWeT1zLl9UaWxlPXMuYXNtLlRpbGUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVXk9cy5fVG9wSz1mdW5jdGlvbigpe3JldHVybihVeT1zLl9Ub3BLPXMuYXNtLlRvcEspLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sR3k9cy5fVHJhbnNmb3JtPWZ1bmN0aW9uKCl7cmV0dXJuKEd5PXMuX1RyYW5zZm9ybT1zLmFzbS5UcmFuc2Zvcm0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSHk9cy5fVHJhbnNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuKEh5PXMuX1RyYW5zcG9zZT1zLmFzbS5UcmFuc3Bvc2UpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sank9cy5fX0Z1c2VkTWF0TXVsPWZ1bmN0aW9uKCl7cmV0dXJuKGp5PXMuX19GdXNlZE1hdE11bD1zLmFzbS5fRnVzZWRNYXRNdWwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0scXk9cy5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKHF5PXMuX21hbGxvYz1zLmFzbS5tYWxsb2MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sS3k9cy5fZnJlZT1mdW5jdGlvbigpe3JldHVybihLeT1zLl9mcmVlPXMuYXNtLmZyZWUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWHk9cy5fX19lcnJub19sb2NhdGlvbj1mdW5jdGlvbigpe3JldHVybihYeT1zLl9fX2Vycm5vX2xvY2F0aW9uPXMuYXNtLl9fZXJybm9fbG9jYXRpb24pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sbGg9cy5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4obGg9cy5zdGFja1NhdmU9cy5hc20uc3RhY2tTYXZlKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LHVoPXMuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKHVoPXMuc3RhY2tSZXN0b3JlPXMuYXNtLnN0YWNrUmVzdG9yZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxqcD1zLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oanA9cy5zdGFja0FsbG9jPXMuYXNtLnN0YWNrQWxsb2MpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sWXk9cy5keW5DYWxsX2lpamppaWlpPWZ1bmN0aW9uKCl7cmV0dXJuKFl5PXMuZHluQ2FsbF9paWpqaWlpaT1zLmFzbS5keW5DYWxsX2lpamppaWlpKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LFp5PXMuZHluQ2FsbF9qaWppPWZ1bmN0aW9uKCl7cmV0dXJuKFp5PXMuZHluQ2FsbF9qaWppPXMuYXNtLmR5bkNhbGxfamlqaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtzLmN3cmFwPUZnO3ZhciB5bDtIbj1mdW5jdGlvbiBZKCl7eWx8fHBoKCkseWx8fChIbj1ZKX07ZnVuY3Rpb24gcGgoWSl7aWYoWT1ZfHxwLHV0PjB8fChPdCgpLHV0PjApKXJldHVybjtmdW5jdGlvbiBvZSgpe3lsfHwoeWw9ITAscy5jYWxsZWRSdW49ITAsIVUmJihpYSgpLGkocykscy5vblJ1bnRpbWVJbml0aWFsaXplZCYmcy5vblJ1bnRpbWVJbml0aWFsaXplZCgpLHVuKCkpKX1zLnNldFN0YXR1cz8ocy5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cy5zZXRTdGF0dXMoXCJcIil9LDEpLG9lKCl9LDEpKTpvZSgpfWlmKHMucHJlSW5pdClmb3IodHlwZW9mIHMucHJlSW5pdD09XCJmdW5jdGlvblwiJiYocy5wcmVJbml0PVtzLnByZUluaXRdKTtzLnByZUluaXQubGVuZ3RoPjA7KXMucHJlSW5pdC5wb3AoKSgpO3BoKCk7dmFyIHhsO2wmJih4bD17dW5jYXVnaHRFeGNlcHRpb246cHJvY2Vzcy5saXN0ZW5lcnMoXCJ1bmNhdWdodEV4Y2VwdGlvblwiKS5maWx0ZXIoZnVuY3Rpb24oWSl7cmV0dXJuIWwudW5jYXVnaHRFeGNlcHRpb24uaW5kZXhPZihZKT4tMX0pLHVuaGFuZGxlZFJlamVjdGlvbjpwcm9jZXNzLmxpc3RlbmVycyhcInVuaGFuZGxlZFJlamVjdGlvblwiKS5maWx0ZXIoZnVuY3Rpb24oWSl7cmV0dXJuIWwudW5oYW5kbGVkUmVqZWN0aW9uLmluZGV4T2YoWSk+LTF9KX0pO3ZhciB2bDtpZih0eXBlb2YgciE9XCJ1bmRlZmluZWRcIil2bD1yO2Vsc2UgaWYodHlwZW9mIFdhc21CYWNrZW5kTW9kdWxlVGhyZWFkZWRTaW1kIT1cInVuZGVmaW5lZFwiKXZsPVdhc21CYWNrZW5kTW9kdWxlVGhyZWFkZWRTaW1kO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2FzbSBtb2R1bGUgaW4gcG9zdC5qc1wiKTtpZih4bCl7dmFyIEp5PXZsLl9kaXNwb3NlO3ZsLl9kaXNwb3NlPWZ1bmN0aW9uKCl7SnkoKSx4bC51bmNhdWdodEV4Y2VwdGlvbi5mb3JFYWNoKGZ1bmN0aW9uKFkpe3Byb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLFkpfSkseGwudW5oYW5kbGVkUmVqZWN0aW9uLmZvckVhY2goZnVuY3Rpb24oWSl7cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihcInVuaGFuZGxlZFJlamVjdGlvblwiLFkpfSl9fXJldHVybiByLnJlYWR5fX0pKCk7dHlwZW9mIGU9PVwib2JqZWN0XCImJnR5cGVvZiB0PT1cIm9iamVjdFwiP3QuZXhwb3J0cz1uOnR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZnVuY3Rpb24oKXtyZXR1cm4gbn0pOnR5cGVvZiBlPT1cIm9iamVjdFwiJiYoZS5XYXNtQmFja2VuZE1vZHVsZT1uKX0pLHltPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5iYWNrZW5kPWUsdGhpcy5kYXRhTW92ZXI9dCx0aGlzLmRhdGE9bmV3IFdlYWtNYXAsdGhpcy5kYXRhSWRzQ291bnQ9MH1nZXQoZSl7cmV0dXJuIHRoaXMuZGF0YS5oYXMoZSl8fHRoaXMuZGF0YU1vdmVyLm1vdmVEYXRhKHRoaXMuYmFja2VuZCxlKSx0aGlzLmRhdGEuZ2V0KGUpfXNldChlLHQpe3RoaXMuZGF0YUlkc0NvdW50KyssdGhpcy5kYXRhLnNldChlLHQpfWhhcyhlKXtyZXR1cm4gdGhpcy5kYXRhLmhhcyhlKX1kZWxldGUoZSl7cmV0dXJuIHRoaXMuZGF0YUlkc0NvdW50LS0sdGhpcy5kYXRhLmRlbGV0ZShlKX1udW1EYXRhSWRzKCl7cmV0dXJuIHRoaXMuZGF0YUlkc0NvdW50fX0sRmM9Y2xhc3N7cmVmQ291bnQoZSl7cmV0dXJuIGpuKFwicmVmQ291bnRcIil9aW5jUmVmKGUpe3JldHVybiBqbihcImluY1JlZlwiKX10aW1lckF2YWlsYWJsZSgpe3JldHVybiEwfXRpbWUoZSl7cmV0dXJuIGpuKFwidGltZVwiKX1yZWFkKGUpe3JldHVybiBqbihcInJlYWRcIil9cmVhZFN5bmMoZSl7cmV0dXJuIGpuKFwicmVhZFN5bmNcIil9cmVhZFRvR1BVKGUsdCl7cmV0dXJuIGpuKFwicmVhZFRvR1BVXCIpfW51bURhdGFJZHMoKXtyZXR1cm4gam4oXCJudW1EYXRhSWRzXCIpfWRpc3Bvc2VEYXRhKGUsdCl7cmV0dXJuIGpuKFwiZGlzcG9zZURhdGFcIil9d3JpdGUoZSx0LG4pe3JldHVybiBqbihcIndyaXRlXCIpfW1vdmUoZSx0LG4sYSxyKXtyZXR1cm4gam4oXCJtb3ZlXCIpfWNyZWF0ZVRlbnNvckZyb21HUFVEYXRhKGUsdCxuKXtyZXR1cm4gam4oXCJjcmVhdGVUZW5zb3JGcm9tR1BVRGF0YVwiKX1tZW1vcnkoKXtyZXR1cm4gam4oXCJtZW1vcnlcIil9ZmxvYXRQcmVjaXNpb24oKXtyZXR1cm4gam4oXCJmbG9hdFByZWNpc2lvblwiKX1lcHNpbG9uKCl7cmV0dXJuIHRoaXMuZmxvYXRQcmVjaXNpb24oKT09PTMyPzFlLTc6MWUtNH1kaXNwb3NlKCl7cmV0dXJuIGpuKFwiZGlzcG9zZVwiKX19O2Z1bmN0aW9uIGpuKGUpe3Rocm93IG5ldyBFcnJvcihgJyR7ZX0nIG5vdCB5ZXQgaW1wbGVtZW50ZWQgb3Igbm90IGZvdW5kIGluIHRoZSByZWdpc3RyeS4gVGhpcyBrZXJuZWwgbWF5IG5vdCBiZSBzdXBwb3J0ZWQgYnkgdGhlIHRmanMgYmFja2VuZCB5b3UgaGF2ZSBjaG9zZW5gKX1mdW5jdGlvbiBEUyhlKXtsZXQgdD1lLmxlbmd0aCxuPTA7Zm9yKDt0PjA7KW49TWF0aC5yYW5kb20oKSp0fDAsdC0tLFZoKGUsdCxuKX1mdW5jdGlvbiBIUihlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBBcnJheSBzaXplcyBtdXN0IG1hdGNoIHRvIGJlIHNodWZmbGVkIHRvZ2V0aGVyIEZpcnN0IGFycmF5IGxlbmd0aCB3YXMgJHtlLmxlbmd0aH1TZWNvbmQgYXJyYXkgbGVuZ3RoIHdhcyAke3QubGVuZ3RofWApO2xldCBuPWUubGVuZ3RoLGE9MDtmb3IoO24+MDspYT1NYXRoLnJhbmRvbSgpKm58MCxuLS0sVmgoZSxuLGEpLFZoKHQsbixhKX1mdW5jdGlvbiBoYyhlLHQsbil7cmV0dXJuIE1hdGgubWF4KGUsTWF0aC5taW4odCxuKSl9ZnVuY3Rpb24galIoZSl7cmV0dXJuIGUlMj09PTA/ZTplKzF9ZnVuY3Rpb24gVmgoZSx0LG4pe2xldCBhPWVbdF07ZVt0XT1lW25dLGVbbl09YX1mdW5jdGlvbiBxUihlKXtsZXQgdD0wO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXQrPWVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gS1IoZSx0KXtsZXQgbj1NYXRoLnJhbmRvbSgpO3JldHVybiB0Km4rKDEtbikqZX1mdW5jdGlvbiBYUihlLHQpe2xldCBuPTA7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKyspe2xldCByPU51bWJlcihlW2FdKS1OdW1iZXIodFthXSk7bis9cipyfXJldHVybiBufWZ1bmN0aW9uIEEoZSx0KXtpZighZSl0aHJvdyBuZXcgRXJyb3IodHlwZW9mIHQ9PVwic3RyaW5nXCI/dDp0KCkpfWZ1bmN0aW9uIE5uKGUsdCxuPVwiXCIpe0EoQXIoZSx0KSwoKT0+bitgIFNoYXBlcyAke2V9IGFuZCAke3R9IG11c3QgbWF0Y2hgKX1mdW5jdGlvbiBTaShlKXtBKGUhPW51bGwsKCk9PlwiVGhlIGlucHV0IHRvIHRoZSB0ZW5zb3IgY29uc3RydWN0b3IgbXVzdCBiZSBhIG5vbi1udWxsIHZhbHVlLlwiKX1mdW5jdGlvbiBvdChlKXtpZihlLmxlbmd0aD09PTApcmV0dXJuIDE7bGV0IHQ9ZVswXTtmb3IobGV0IG49MTtuPGUubGVuZ3RoO24rKyl0Kj1lW25dO3JldHVybiB0fWZ1bmN0aW9uIFlSKGUpe3JldHVybiBlLmxlbmd0aD09PTB9ZnVuY3Rpb24gUlMoZSx0KXtpZihlPT09dClyZXR1cm4hMDtpZihlPT1udWxsfHx0PT1udWxsfHxlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKGVbbl0hPT1udWxsJiZ0W25dIT09bnVsbCYmZVtuXSE9PXRbbl0pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gQXIoZSx0KXtpZihlPT09dClyZXR1cm4hMDtpZihlPT1udWxsfHx0PT1udWxsfHxlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKGVbbl0hPT10W25dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uICRsKGUpe3JldHVybiBlJTE9PT0wfWZ1bmN0aW9uIFpSKGUpe2lmKE1hdGgudGFuaCE9bnVsbClyZXR1cm4gTWF0aC50YW5oKGUpO2lmKGU9PT0xLzApcmV0dXJuIDE7aWYoZT09PS0xLzApcmV0dXJuLTE7e2xldCB0PU1hdGguZXhwKDIqZSk7cmV0dXJuKHQtMSkvKHQrMSl9fWZ1bmN0aW9uIEpSKGUpe2xldCB0PU1hdGguY2VpbChNYXRoLnNxcnQoZSkpO3JldHVyblt0LE1hdGguY2VpbChlL3QpXX1mdW5jdGlvbiBRUihlKXtsZXQgdD1uZXcgVWludDMyQXJyYXkoZSk7Zm9yKGxldCBuPTA7bjxlOysrbil0W25dPW47cmV0dXJuIERTKHQpLHR9ZnVuY3Rpb24gdWMoZSx0KXtyZXR1cm4gdDw9ZS5sZW5ndGg/ZTplK1wiIFwiLnJlcGVhdCh0LWUubGVuZ3RoKX1mdW5jdGlvbiBlTShlLHQ9cj0+MCxuLGEpe3JldHVybiBuZXcgUHJvbWlzZSgocixzKT0+e2xldCBpPTAsbz0oKT0+e2lmKGUoKSl7cigpO3JldHVybn1pKys7bGV0IGw9dChpKTtpZihuIT1udWxsJiZpPj1uKXtzKCk7cmV0dXJufWEhPW51bGw/YShvLGwpOnNldFRpbWVvdXQobyxsKX07bygpfSl9ZnVuY3Rpb24gdE0oZSx0KXtsZXQgbj0xLGE9LTE7Zm9yKGxldCBzPTA7czxlLmxlbmd0aDsrK3MpaWYoZVtzXT49MCluKj1lW3NdO2Vsc2UgaWYoZVtzXT09PS0xKXtpZihhIT09LTEpdGhyb3cgRXJyb3IoYFNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gRm91bmQgLTEgYXQgZGltICR7YX0gYW5kIGRpbSAke3N9YCk7YT1zfWVsc2UgaWYoZVtzXTwwKXRocm93IEVycm9yKGBTaGFwZXMgY2FuIG5vdCBiZSA8IDAuIEZvdW5kICR7ZVtzXX0gYXQgZGltICR7c31gKTtpZihhPT09LTEpe2lmKHQ+MCYmdCE9PW4pdGhyb3cgRXJyb3IoYFNpemUoJHt0fSkgbXVzdCBtYXRjaCB0aGUgcHJvZHVjdCBvZiBzaGFwZSAke2V9YCk7cmV0dXJuIGV9aWYobj09PTApdGhyb3cgRXJyb3IoYENhbm5vdCBpbmZlciB0aGUgbWlzc2luZyBzaXplIGluIFske2V9XSB3aGVuIHRoZXJlIGFyZSAwIGVsZW1lbnRzYCk7aWYodCVuIT09MCl0aHJvdyBFcnJvcihgVGhlIGltcGxpY2l0IHNoYXBlIGNhbid0IGJlIGEgZnJhY3Rpb25hbCBudW1iZXIuIEdvdCAke3R9IC8gJHtufWApO2xldCByPWUuc2xpY2UoKTtyZXR1cm4gclthXT10L24scn1mdW5jdGlvbiBBYShlLHQpe2xldCBuPXQubGVuZ3RoO3JldHVybiBlPWU9PW51bGw/dC5tYXAoKGEscik9PnIpOltdLmNvbmNhdChlKSxBKGUuZXZlcnkoYT0+YT49LW4mJmE8biksKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLSR7bn0sICR7bn0pIGJ1dCBnb3QgYXhpcyAke2V9YCksQShlLmV2ZXJ5KGE9PiRsKGEpKSwoKT0+YEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCBnb3QgYXhpcyAke2V9YCksZS5tYXAoYT0+YTwwP24rYTphKX1mdW5jdGlvbiBNUyhlLHQpe2xldCBuPVtdLGE9W10scj10IT1udWxsJiZBcnJheS5pc0FycmF5KHQpJiZ0Lmxlbmd0aD09PTAscz10PT1udWxsfHxyP251bGw6QWEodCxlKS5zb3J0KCksaT0wO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKXtpZihzIT1udWxsKXtpZihzW2ldPT09byYmZVtvXSE9PTEpdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHtvfSBzaW5jZSBpdHMgZGltICcke2Vbb119JyBpcyBub3QgMWApOyhzW2ldPT1udWxsfHxzW2ldPm8pJiZlW29dPT09MSYmKG4ucHVzaChlW29dKSxhLnB1c2gobykpLHNbaV08PW8mJmkrK31lW29dIT09MSYmKG4ucHVzaChlW29dKSxhLnB1c2gobykpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOmF9fWZ1bmN0aW9uIE9TKGUsdCl7cmV0dXJuIFN2KGUsdCl9ZnVuY3Rpb24gU3YoZSx0KXtsZXQgbj1udWxsO2lmKGU9PW51bGx8fGU9PT1cImZsb2F0MzJcIiluPW5ldyBGbG9hdDMyQXJyYXkodCk7ZWxzZSBpZihlPT09XCJpbnQzMlwiKW49bmV3IEludDMyQXJyYXkodCk7ZWxzZSBpZihlPT09XCJib29sXCIpbj1uZXcgVWludDhBcnJheSh0KTtlbHNlIGlmKGU9PT1cInN0cmluZ1wiKW49bmV3IEFycmF5KHQpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZSAke2V9YCk7cmV0dXJuIG59ZnVuY3Rpb24gUFMoZSx0KXtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7bGV0IGE9ZVtuXTtpZihpc05hTihhKXx8IWlzRmluaXRlKGEpKXRocm93IEVycm9yKGBBIHRlbnNvciBvZiB0eXBlICR7dH0gYmVpbmcgdXBsb2FkZWQgY29udGFpbnMgJHthfS5gKX19ZnVuY3Rpb24gTFMoZSl7cmV0dXJuIGU9PT1cImJvb2xcInx8ZT09PVwiY29tcGxleDY0XCJ8fGU9PT1cImZsb2F0MzJcInx8ZT09PVwiaW50MzJcInx8ZT09PVwic3RyaW5nXCJ9ZnVuY3Rpb24gbk0oZSx0KXtyZXR1cm4hKHQ9PT1cImNvbXBsZXg2NFwifHx0PT09XCJmbG9hdDMyXCImJmUhPT1cImNvbXBsZXg2NFwifHx0PT09XCJpbnQzMlwiJiZlIT09XCJmbG9hdDMyXCImJmUhPT1cImNvbXBsZXg2NFwifHx0PT09XCJib29sXCImJmU9PT1cImJvb2xcIil9ZnVuY3Rpb24gVWgoZSl7aWYoZT09PVwiZmxvYXQzMlwifHxlPT09XCJpbnQzMlwiKXJldHVybiA0O2lmKGU9PT1cImNvbXBsZXg2NFwiKXJldHVybiA4O2lmKGU9PT1cImJvb2xcIilyZXR1cm4gMTt0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZHR5cGUgJHtlfWApfWZ1bmN0aW9uIHpTKGUpe2lmKGU9PW51bGwpcmV0dXJuIDA7bGV0IHQ9MDtyZXR1cm4gZS5mb3JFYWNoKG49PnQrPW4ubGVuZ3RoKSx0fWZ1bmN0aW9uIEpyKGUpe3JldHVybiB0eXBlb2YgZT09XCJzdHJpbmdcInx8ZSBpbnN0YW5jZW9mIFN0cmluZ31mdW5jdGlvbiBXUyhlKXtyZXR1cm4gdHlwZW9mIGU9PVwiYm9vbGVhblwifWZ1bmN0aW9uIEJTKGUpe3JldHVybiB0eXBlb2YgZT09XCJudW1iZXJcIn1mdW5jdGlvbiAkYyhlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT8kYyhlWzBdKTplIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P1wiZmxvYXQzMlwiOmUgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHxlIGluc3RhbmNlb2YgVWludDhBcnJheXx8ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5P1wiaW50MzJcIjpCUyhlKT9cImZsb2F0MzJcIjpKcihlKT9cInN0cmluZ1wiOldTKGUpP1wiYm9vbFwiOlwiZmxvYXQzMlwifWZ1bmN0aW9uIHNzKGUpe3JldHVybiEhKGUmJmUuY29uc3RydWN0b3ImJmUuY2FsbCYmZS5hcHBseSl9ZnVuY3Rpb24gR2goZSx0KXtmb3IobGV0IG49dDtuPGU7KytuKWlmKGUlbj09PTApcmV0dXJuIG47cmV0dXJuIGV9ZnVuY3Rpb24gWGwoZSl7bGV0IHQ9ZS5sZW5ndGg7aWYodDwyKXJldHVybltdO2xldCBuPW5ldyBBcnJheSh0LTEpO25bdC0yXT1lW3QtMV07Zm9yKGxldCBhPXQtMzthPj0wOy0tYSluW2FdPW5bYSsxXSplW2ErMV07cmV0dXJuIG59ZnVuY3Rpb24gVlMoZSx0LG4sYT0hMSl7bGV0IHI9bmV3IEFycmF5O2lmKHQubGVuZ3RoPT09MSl7bGV0IHM9dFswXSooYT8yOjEpO2ZvcihsZXQgaT0wO2k8cztpKyspcltpXT1uW2UraV19ZWxzZXtsZXQgcz10WzBdLGk9dC5zbGljZSgxKSxvPWkucmVkdWNlKChsLHUpPT5sKnUpKihhPzI6MSk7Zm9yKGxldCBsPTA7bDxzO2wrKylyW2xdPVZTKGUrbCpvLGksbixhKX1yZXR1cm4gcn1mdW5jdGlvbiBFbChlLHQsbj0hMSl7aWYoZS5sZW5ndGg9PT0wKXJldHVybiB0WzBdO2xldCBhPWUucmVkdWNlKChyLHMpPT5yKnMpKihuPzI6MSk7aWYoYT09PTApcmV0dXJuW107aWYoYSE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgWyR7ZX1dIGRvZXMgbm90IG1hdGNoIHRoZSBpbnB1dCBzaXplICR7dC5sZW5ndGh9JHtuP1wiIGZvciBhIGNvbXBsZXggdGVuc29yXCI6XCJcIn0uYCk7cmV0dXJuIFZTKDAsZSx0LG4pfWZ1bmN0aW9uIGFNKGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZTtpZih0PT09XCJmbG9hdDMyXCIpcmV0dXJuIGUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/ZTpuZXcgRmxvYXQzMkFycmF5KGUpO2lmKHQ9PT1cImludDMyXCIpcmV0dXJuIGUgaW5zdGFuY2VvZiBJbnQzMkFycmF5P2U6bmV3IEludDMyQXJyYXkoZSk7aWYodD09PVwiYm9vbFwifHx0PT09XCJzdHJpbmdcIilyZXR1cm4gVWludDhBcnJheS5mcm9tKG5ldyBJbnQzMkFycmF5KGUpKTt0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZHR5cGUgJHt0fWApfWZ1bmN0aW9uIE52KGUsdCl7bGV0IG49eG0oZSx0KTtmb3IobGV0IGE9MDthPG4ubGVuZ3RoO2ErKyluW2FdPTE7cmV0dXJuIG59ZnVuY3Rpb24geG0oZSx0KXtpZih0PT1udWxsfHx0PT09XCJmbG9hdDMyXCJ8fHQ9PT1cImNvbXBsZXg2NFwiKXJldHVybiBuZXcgRmxvYXQzMkFycmF5KGUpO2lmKHQ9PT1cImludDMyXCIpcmV0dXJuIG5ldyBJbnQzMkFycmF5KGUpO2lmKHQ9PT1cImJvb2xcIilyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZSk7dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZSAke3R9YCl9ZnVuY3Rpb24gck0oZSx0KXtsZXQgbj1lLnJlZHVjZSgoYSxyKT0+YSpyLDEpO2lmKHQ9PW51bGx8fHQ9PT1cImZsb2F0MzJcIilyZXR1cm4gRWwoZSxuZXcgRmxvYXQzMkFycmF5KG4pKTtpZih0PT09XCJpbnQzMlwiKXJldHVybiBFbChlLG5ldyBJbnQzMkFycmF5KG4pKTtpZih0PT09XCJib29sXCIpcmV0dXJuIEVsKGUsbmV3IFVpbnQ4QXJyYXkobikpO3Rocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGUgJHt0fWApfWZ1bmN0aW9uIG5hKGUpe2UuZm9yRWFjaCh0PT57QShOdW1iZXIuaXNJbnRlZ2VyKHQpJiZ0Pj0wLCgpPT5gVGVuc29yIG11c3QgaGF2ZSBhIHNoYXBlIGNvbXByaXNlZCBvZiBwb3NpdGl2ZSBpbnRlZ2VycyBidXQgZ290IHNoYXBlIFske2V9XS5gKX0pfWZ1bmN0aW9uIHNNKGUsdCxuKXtpZih0PT09MClyZXR1cm4gMDtpZih0PT09MSlyZXR1cm4gZVswXTtsZXQgYT1lW2UubGVuZ3RoLTFdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGgtMTsrK3IpYSs9bltyXSplW3JdO3JldHVybiBhfWZ1bmN0aW9uIGlNKGUsdCxuKXtpZih0PT09MClyZXR1cm5bXTtpZih0PT09MSlyZXR1cm5bZV07bGV0IGE9bmV3IEFycmF5KHQpO2ZvcihsZXQgcj0wO3I8YS5sZW5ndGgtMTsrK3IpYVtyXT1NYXRoLmZsb29yKGUvbltyXSksZS09YVtyXSpuW3JdO3JldHVybiBhW2EubGVuZ3RoLTFdPWUsYX1mdW5jdGlvbiB2bShlKXtyZXR1cm4gZSYmZS50aGVuJiZ0eXBlb2YgZS50aGVuPT1cImZ1bmN0aW9uXCJ9dmFyIGprPVwidGZqc2ZsYWdzXCIsVVM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5nbG9iYWw9ZSx0aGlzLmZsYWdzPXt9LHRoaXMuZmxhZ1JlZ2lzdHJ5PXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5nZXRRdWVyeVBhcmFtcz1vTSx0aGlzLnBvcHVsYXRlVVJMRmxhZ3MoKX1zZXRQbGF0Zm9ybShlLHQpe3RoaXMucGxhdGZvcm0hPW51bGwmJihHKCkuZ2V0Qm9vbChcIklTX1RFU1RcIil8fEcoKS5nZXRCb29sKFwiUFJPRFwiKXx8Y29uc29sZS53YXJuKGBQbGF0Zm9ybSAke3RoaXMucGxhdGZvcm1OYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHNldC4gT3ZlcndyaXRpbmcgdGhlIHBsYXRmb3JtIHdpdGggJHtlfS5gKSksdGhpcy5wbGF0Zm9ybU5hbWU9ZSx0aGlzLnBsYXRmb3JtPXR9cmVnaXN0ZXJGbGFnKGUsdCxuKXtpZih0aGlzLmZsYWdSZWdpc3RyeVtlXT17ZXZhbHVhdGlvbkZuOnQsc2V0SG9vazpufSx0aGlzLnVybEZsYWdzW2VdIT1udWxsKXtsZXQgYT10aGlzLnVybEZsYWdzW2VdO0coKS5nZXRCb29sKFwiSVNfVEVTVFwiKXx8RygpLmdldEJvb2woXCJQUk9EXCIpfHxjb25zb2xlLndhcm4oYFNldHRpbmcgZmVhdHVyZSBvdmVycmlkZSBmcm9tIFVSTCAke2V9OiAke2F9LmApLHRoaXMuc2V0KGUsYSl9fWFzeW5jIGdldEFzeW5jKGUpe3JldHVybiBlIGluIHRoaXMuZmxhZ3M/dGhpcy5mbGFnc1tlXToodGhpcy5mbGFnc1tlXT1hd2FpdCB0aGlzLmV2YWx1YXRlRmxhZyhlKSx0aGlzLmZsYWdzW2VdKX1nZXQoZSl7aWYoZSBpbiB0aGlzLmZsYWdzKXJldHVybiB0aGlzLmZsYWdzW2VdO2xldCB0PXRoaXMuZXZhbHVhdGVGbGFnKGUpO2lmKHZtKHQpKXRocm93IG5ldyBFcnJvcihgRmxhZyAke2V9IGNhbm5vdCBiZSBzeW5jaHJvbm91c2x5IGV2YWx1YXRlZC4gUGxlYXNlIHVzZSBnZXRBc3luYygpIGluc3RlYWQuYCk7cmV0dXJuIHRoaXMuZmxhZ3NbZV09dCx0aGlzLmZsYWdzW2VdfWdldE51bWJlcihlKXtyZXR1cm4gdGhpcy5nZXQoZSl9Z2V0Qm9vbChlKXtyZXR1cm4gdGhpcy5nZXQoZSl9Z2V0U3RyaW5nKGUpe3JldHVybiB0aGlzLmdldChlKX1nZXRGbGFncygpe3JldHVybiB0aGlzLmZsYWdzfWdldCBmZWF0dXJlcygpe3JldHVybiB0aGlzLmZsYWdzfXNldChlLHQpe2lmKHRoaXMuZmxhZ1JlZ2lzdHJ5W2VdPT1udWxsKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCBmbGFnICR7ZX0gYXMgaXQgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuYCk7dGhpcy5mbGFnc1tlXT10LHRoaXMuZmxhZ1JlZ2lzdHJ5W2VdLnNldEhvb2shPW51bGwmJnRoaXMuZmxhZ1JlZ2lzdHJ5W2VdLnNldEhvb2sodCl9ZXZhbHVhdGVGbGFnKGUpe2lmKHRoaXMuZmxhZ1JlZ2lzdHJ5W2VdPT1udWxsKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGV2YWx1YXRlIGZsYWcgJyR7ZX0nOiBubyBldmFsdWF0aW9uIGZ1bmN0aW9uIGZvdW5kLmApO3JldHVybiB0aGlzLmZsYWdSZWdpc3RyeVtlXS5ldmFsdWF0aW9uRm4oKX1zZXRGbGFncyhlKXt0aGlzLmZsYWdzPU9iamVjdC5hc3NpZ24oe30sZSl9cmVzZXQoKXt0aGlzLmZsYWdzPXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9cG9wdWxhdGVVUkxGbGFncygpe2lmKHR5cGVvZiB0aGlzLmdsb2JhbD09XCJ1bmRlZmluZWRcInx8dHlwZW9mIHRoaXMuZ2xvYmFsLmxvY2F0aW9uPT1cInVuZGVmaW5lZFwifHx0eXBlb2YgdGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoPT1cInVuZGVmaW5lZFwiKXJldHVybjtsZXQgZT10aGlzLmdldFF1ZXJ5UGFyYW1zKHRoaXMuZ2xvYmFsLmxvY2F0aW9uLnNlYXJjaCk7amsgaW4gZSYmZVtqa10uc3BsaXQoXCIsXCIpLmZvckVhY2godD0+e2xldFtuLGFdPXQuc3BsaXQoXCI6XCIpO3RoaXMudXJsRmxhZ3Nbbl09dU0obixhKX0pfX07ZnVuY3Rpb24gb00oZSl7bGV0IHQ9e307cmV0dXJuIGUucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZywobiwuLi5hKT0+KGxNKHQsYVswXSxhWzFdKSxhLmpvaW4oXCI9XCIpKSksdH1mdW5jdGlvbiBsTShlLHQsbil7ZVtkZWNvZGVVUklDb21wb25lbnQodCldPWRlY29kZVVSSUNvbXBvbmVudChufHxcIlwiKX1mdW5jdGlvbiB1TShlLHQpe2xldCBuPXQudG9Mb3dlckNhc2UoKTtyZXR1cm4gbj09PVwidHJ1ZVwifHxuPT09XCJmYWxzZVwiP249PT1cInRydWVcIjpgJHsrbn1gPT09bj8rbjp0fWZ1bmN0aW9uIEcoKXtyZXR1cm4gVHZ9dmFyIFR2PW51bGw7ZnVuY3Rpb24gcE0oZSl7VHY9ZX12YXIgcng7ZnVuY3Rpb24gR1MoKXtpZihyeD09bnVsbCl7bGV0IGU7aWYodHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIillPXdpbmRvdztlbHNlIGlmKHR5cGVvZiBnbG9iYWwhPVwidW5kZWZpbmVkXCIpZT1nbG9iYWw7ZWxzZSBpZih0eXBlb2YgcHJvY2VzcyE9XCJ1bmRlZmluZWRcIillPXByb2Nlc3M7ZWxzZSBpZih0eXBlb2Ygc2VsZiE9XCJ1bmRlZmluZWRcIillPXNlbGY7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3RcIik7cng9ZX1yZXR1cm4gcnh9ZnVuY3Rpb24gY00oKXtsZXQgZT1HUygpO3JldHVybiBlLl90Zkdsb2JhbHM9PW51bGwmJihlLl90Zkdsb2JhbHM9bmV3IE1hcCksZS5fdGZHbG9iYWxzfWZ1bmN0aW9uIEN2KGUsdCl7bGV0IG49Y00oKTtpZihuLmhhcyhlKSlyZXR1cm4gbi5nZXQoZSk7e2xldCBhPXQoKTtyZXR1cm4gbi5zZXQoZSxhKSxuLmdldChlKX19dmFyIFlsPVwiQWJzXCIsTmk9XCJBY29zXCIsVGk9XCJBY29zaFwiLHZzPVwiQWRkXCIsQ2k9XCJBZGROXCIsWmw9XCJBbGxcIixKbD1cIkFueVwiLFFsPVwiQXJnTWF4XCIsZXU9XCJBcmdNaW5cIixFaT1cIkFzaW5cIixfaT1cIkFzaW5oXCIsQWk9XCJBdGFuXCIsRmk9XCJBdGFuaFwiLCRpPVwiQXRhbjJcIixEaT1cIkF2Z1Bvb2xcIixEYz1cIkF2Z1Bvb2xHcmFkXCIsdHU9XCJBdmdQb29sM0RcIixSYz1cIkF2Z1Bvb2wzREdyYWRcIixSaT1cIkJhdGNoTWF0TXVsXCIsbnU9XCJCYXRjaFRvU3BhY2VORFwiLGF1PVwiQmluY291bnRcIixydT1cIkJpdHdpc2VBbmRcIixIUz1cIkJyb2FkY2FzdFRvXCIsTWM9XCJCcm9hZGNhc3RBcmdzXCIsTWk9XCJDYXN0XCIsT2k9XCJDZWlsXCIsd3M9XCJDbGlwQnlWYWx1ZVwiLHdtPVwiQ29tcGxleFwiLE9jPVwiQ29tcGxleEFic1wiLHN1PVwiQ29uY2F0XCIsUGk9XCJDb252MkRcIixrbT1cIkNvbnYyREJhY2twcm9wRmlsdGVyXCIsTGk9XCJDb252MkRCYWNrcHJvcElucHV0XCIsemk9XCJDb252M0RcIixpdT1cIkNvbnYzREJhY2twcm9wRmlsdGVyVjJcIixvdT1cIkNvbnYzREJhY2twcm9wSW5wdXRWMlwiLFdpPVwiQ29zXCIsQmk9XCJDb3NoXCIsbHU9XCJDdW1wcm9kXCIsVmk9XCJDdW1zdW1cIix1dT1cIkNyb3BBbmRSZXNpemVcIixQYz1cIkRlbnNlQmluY291bnRcIixwdT1cIkRlcHRoVG9TcGFjZVwiLFVpPVwiRGVwdGh3aXNlQ29udjJkTmF0aXZlXCIsSW09XCJEZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlclwiLFNtPVwiRGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BJbnB1dFwiLExjPVwiRGlhZ1wiLEdpPVwiRGlsYXRpb24yRFwiLERsPVwiRGlsYXRpb24yREJhY2twcm9wSW5wdXRcIixSbD1cIkRpbGF0aW9uMkRCYWNrcHJvcEZpbHRlclwiLE5tPVwiRHJhd1wiLEhpPVwiUmVhbERpdlwiLFRtPVwiRWluc3VtXCIsamk9XCJFbHVcIixjdT1cIkVsdUdyYWRcIixxaT1cIkVyZlwiLGR1PVwiRXF1YWxcIixLaT1cIkV4cFwiLGh1PVwiRXhwYW5kRGltc1wiLFhpPVwiRXhwbTFcIixDbT1cIkZGVFwiLHpjPVwiRmlsbFwiLG11PVwiRmxpcExlZnRSaWdodFwiLFlpPVwiRmxvb3JcIixaaT1cIkZsb29yRGl2XCIsSmk9XCJGdXNlZEJhdGNoTm9ybVwiLGZ1PVwiR2F0aGVyVjJcIixndT1cIkdhdGhlck5kXCIsYnU9XCJHcmVhdGVyXCIsUWk9XCJHcmVhdGVyRXF1YWxcIixlbz1cIklkZW50aXR5XCIsRW09XCJJRkZUXCIsX209XCJJbWFnXCIsdG89XCJJc0Zpbml0ZVwiLG5vPVwiSXNJbmZcIixhbz1cIklzTmFuXCIscm89XCJMZWFreVJlbHVcIix5dT1cIkxlc3NcIix4dT1cIkxlc3NFcXVhbFwiLHZ1PVwiTGluU3BhY2VcIixzbz1cIkxvZ1wiLGlvPVwiTG9nMXBcIix3dT1cIkxvZ2ljYWxBbmRcIixrdT1cIkxvZ2ljYWxOb3RcIixJdT1cIkxvZ2ljYWxPclwiLGpTPVwiTG9naWNhbFhvclwiLHFTPVwiTG9nU29mdG1heFwiLGRNPVwiTG93ZXJCb3VuZFwiLG9vPVwiTFJOXCIsU3U9XCJMUk5HcmFkXCIsaE09XCJNYXRyaXhCYW5kUGFydFwiLGxvPVwiTWF4XCIsdW89XCJNYXhpbXVtXCIscG89XCJNYXhQb29sXCIsV2M9XCJNYXhQb29sR3JhZFwiLE51PVwiTWF4UG9vbDNEXCIsQmM9XCJNYXhQb29sM0RHcmFkXCIsVmM9XCJNYXhQb29sV2l0aEFyZ21heFwiLGNvPVwiTWVhblwiLGhvPVwiTWluXCIsbW89XCJNaW5pbXVtXCIsZm89XCJNaXJyb3JQYWRcIixnbz1cIk1vZFwiLFR1PVwiTXVsdGlub21pYWxcIixibz1cIk11bHRpcGx5XCIsQ3U9XCJOZWdcIixFdT1cIk5vdEVxdWFsXCIsX3U9XCJOb25NYXhTdXBwcmVzc2lvblYzXCIsQXU9XCJOb25NYXhTdXBwcmVzc2lvblY0XCIsRnU9XCJOb25NYXhTdXBwcmVzc2lvblY1XCIsJHU9XCJPbmVzTGlrZVwiLHlvPVwiT25lSG90XCIsRHU9XCJQYWNrXCIseG89XCJQYWRWMlwiLG1NPVwiUG9vbFwiLHZvPVwiUG93XCIsd289XCJQcmVsdVwiLGtvPVwiUHJvZFwiLEFtPVwiUmFnZ2VkR2F0aGVyXCIsRm09XCJSYWdnZWRSYW5nZVwiLCRtPVwiUmFnZ2VkVGVuc29yVG9UZW5zb3JcIixVYz1cIlJhbmdlXCIsRG09XCJSZWFsXCIsSW89XCJSZWNpcHJvY2FsXCIsU289XCJSZWx1XCIsUnU9XCJSZXNoYXBlXCIsTm89XCJSZXNpemVOZWFyZXN0TmVpZ2hib3JcIixNdT1cIlJlc2l6ZU5lYXJlc3ROZWlnaGJvckdyYWRcIixUbz1cIlJlc2l6ZUJpbGluZWFyXCIsT3U9XCJSZXNpemVCaWxpbmVhckdyYWRcIixDbz1cIlJlbHU2XCIsRW89XCJSZXZlcnNlXCIsX289XCJSb3VuZFwiLEFvPVwiUnNxcnRcIixQdT1cIlNjYXR0ZXJOZFwiLEx1PVwiVGVuc29yU2NhdHRlclVwZGF0ZVwiLHp1PVwiU2VhcmNoU29ydGVkXCIsV3U9XCJTZWxlY3RcIixGbz1cIlNlbHVcIixCdT1cIlNsaWNlXCIsJG89XCJTaW5cIixEbz1cIlNpbmhcIixSbz1cIlNpZ25cIixNbz1cIlNpZ21vaWRcIixPbz1cIlNvZnRwbHVzXCIsUG89XCJTcXJ0XCIsTG89XCJTdW1cIixWdT1cIlNwYWNlVG9CYXRjaE5EXCIsVXU9XCJTcGxpdFZcIix6bz1cIlNvZnRtYXhcIixHYz1cIlNwYXJzZUZpbGxFbXB0eVJvd3NcIixHdT1cIlNwYXJzZVJlc2hhcGVcIixIYz1cIlNwYXJzZVNlZ21lbnRNZWFuXCIsamM9XCJTcGFyc2VTZWdtZW50U3VtXCIsSHU9XCJTcGFyc2VUb0RlbnNlXCIsV289XCJTcXVhcmVkRGlmZmVyZW5jZVwiLHFjPVwiU3F1YXJlXCIsS2M9XCJTdGF0aWNSZWdleFJlcGxhY2VcIixqdT1cIlN0cmlkZWRTbGljZVwiLFhjPVwiU3RyaW5nTkdyYW1zXCIsWWM9XCJTdHJpbmdTcGxpdFwiLFpjPVwiU3RyaW5nVG9IYXNoQnVja2V0RmFzdFwiLEJvPVwiU3ViXCIsVm89XCJUYW5cIixVbz1cIlRhbmhcIixrcz1cIlRpbGVcIixxdT1cIlRvcEtcIixLdT1cIlRyYW5zZm9ybVwiLENyPVwiVHJhbnNwb3NlXCIsSmM9XCJVbmlxdWVcIixYdT1cIlVucGFja1wiLFFjPVwiVW5zb3J0ZWRTZWdtZW50U3VtXCIsZk09XCJVcHBlckJvdW5kXCIsWXU9XCJaZXJvc0xpa2VcIixJcz1cIlN0ZXBcIixIaD1cIkZyb21QaXhlbHNcIixadT1cIlJvdGF0ZVdpdGhPZmZzZXRcIixpaT1cIl9GdXNlZE1hdE11bFwiLG9pPVwiRnVzZWRDb252MkRcIixsaT1cIkZ1c2VkRGVwdGh3aXNlQ29udjJEXCI7ZnVuY3Rpb24gWnIoLi4uZSl7RygpLmdldEJvb2woXCJJU19URVNUXCIpfHxHKCkuZ2V0Qm9vbChcIlBST0RcIil8fGNvbnNvbGUud2FybiguLi5lKX1mdW5jdGlvbiBnTSguLi5lKXtHKCkuZ2V0Qm9vbChcIklTX1RFU1RcIil8fEcoKS5nZXRCb29sKFwiUFJPRFwiKXx8Y29uc29sZS5sb2coLi4uZSl9dmFyIE1sPUN2KFwia2VybmVsUmVnaXN0cnlcIiwoKT0+bmV3IE1hcCksbWM9Q3YoXCJncmFkUmVnaXN0cnlcIiwoKT0+bmV3IE1hcCk7ZnVuY3Rpb24gZmMoZSx0KXtsZXQgbj1FdihlLHQpO3JldHVybiBNbC5nZXQobil9ZnVuY3Rpb24gdngoZSl7cmV0dXJuIG1jLmdldChlKX1mdW5jdGlvbiBqaChlKXtsZXQgdD1NbC5lbnRyaWVzKCksbj1bXTtmb3IoOzspe2xldHtkb25lOmEsdmFsdWU6cn09dC5uZXh0KCk7aWYoYSlicmVhaztsZXRbcyxpXT1yLFtvXT1zLnNwbGl0KFwiX1wiKTtvPT09ZSYmbi5wdXNoKGkpfXJldHVybiBufWZ1bmN0aW9uIGVkKGUpe2xldHtrZXJuZWxOYW1lOnQsYmFja2VuZE5hbWU6bn09ZSxhPUV2KHQsbik7TWwuaGFzKGEpJiZacihgVGhlIGtlcm5lbCAnJHt0fScgZm9yIGJhY2tlbmQgJyR7bn0nIGlzIGFscmVhZHkgcmVnaXN0ZXJlZGApLE1sLnNldChhLGUpfWZ1bmN0aW9uIEtTKGUpe2xldHtrZXJuZWxOYW1lOnR9PWU7bWMuaGFzKHQpJiZHKCkuZ2V0Qm9vbChcIkRFQlVHXCIpJiZacihgT3ZlcnJpZGluZyB0aGUgZ3JhZGllbnQgZm9yICcke3R9J2ApLG1jLnNldCh0LGUpfWZ1bmN0aW9uIGJNKGUsdCl7bGV0IG49RXYoZSx0KTtpZighTWwuaGFzKG4pKXRocm93IG5ldyBFcnJvcihgVGhlIGtlcm5lbCAnJHtlfScgZm9yIGJhY2tlbmQgJyR7dH0nIGlzIG5vdCByZWdpc3RlcmVkYCk7TWwuZGVsZXRlKG4pfWZ1bmN0aW9uIHlNKGUpe2lmKCFtYy5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKGBUaGUgZ3JhZGllbnQgJyR7ZX0nIGZvciBiYWNrZW5kIGlzIG5vdCByZWdpc3RlcmVkYCk7bWMuZGVsZXRlKGUpfWZ1bmN0aW9uIHhNKGUsdCl7amgoZSkuZm9yRWFjaChuPT57bGV0IGE9T2JqZWN0LmFzc2lnbih7fSxuLHtiYWNrZW5kTmFtZTp0fSk7ZWQoYSl9KX1mdW5jdGlvbiBFdihlLHQpe3JldHVybmAke3R9XyR7ZX1gfXZhciB3PXt9O19lKHcse2FycmF5c0VxdWFsOigpPT5BcixhcnJheXNFcXVhbFdpdGhOdWxsOigpPT5SUyxhc3NlcnQ6KCk9PkEsYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9uczooKT0+bmEsYXNzZXJ0Tm9uTnVsbDooKT0+U2ksYXNzZXJ0U2hhcGVzTWF0Y2g6KCk9Pk5uLGJ5dGVzRnJvbVN0cmluZ0FycmF5OigpPT56UyxieXRlc1BlckVsZW1lbnQ6KCk9PlVoLGNoZWNrQ29udmVyc2lvbkZvckVycm9yczooKT0+UFMsY2xhbXA6KCk9PmhjLGNvbXB1dGVTdHJpZGVzOigpPT5YbCxjb252ZXJ0QmFja2VuZFZhbHVlc0FuZEFycmF5QnVmZmVyOigpPT5hTSxjcmVhdGVTY2FsYXJWYWx1ZTooKT0+Tk0sY3JlYXRlU2h1ZmZsZWRJbmRpY2VzOigpPT5RUixkZWNvZGVTdHJpbmc6KCk9PnFoLGRpc3RTcXVhcmVkOigpPT5YUixlbmNvZGVTdHJpbmc6KCk9Pm5kLGZldGNoOigpPT5DTSxmaW5nZXJQcmludDY0OigpPT5TTSxmbGF0dGVuOigpPT5pcyxnZXRBcnJheUZyb21EVHlwZTooKT0+U3YsZ2V0VHlwZWRBcnJheUZyb21EVHlwZTooKT0+T1MsaGFzRW5jb2RpbmdMb3NzOigpPT5uTSxoZXhUb0xvbmc6KCk9PnRkLGluZGV4VG9Mb2M6KCk9PmlNLGluZmVyRHR5cGU6KCk9PiRjLGluZmVyRnJvbUltcGxpY2l0U2hhcGU6KCk9PnRNLGlzQm9vbGVhbjooKT0+V1MsaXNGdW5jdGlvbjooKT0+c3MsaXNJbnQ6KCk9PiRsLGlzTnVtYmVyOigpPT5CUyxpc1Byb21pc2U6KCk9PnZtLGlzU2NhbGFyU2hhcGU6KCk9PllSLGlzU3RyaW5nOigpPT5Kcixpc1R5cGVkQXJyYXk6KCk9PmVuLGlzVmFsaWREdHlwZTooKT0+TFMsbG9jVG9JbmRleDooKT0+c00sbWFrZU9uZXNUeXBlZEFycmF5OigpPT5OdixtYWtlWmVyb3NOZXN0ZWRUeXBlZEFycmF5OigpPT5yTSxtYWtlWmVyb3NUeXBlZEFycmF5OigpPT54bSxuZWFyZXN0RGl2aXNvcjooKT0+R2gsbmVhcmVzdExhcmdlckV2ZW46KCk9PmpSLG5vdzooKT0+Z2MscGFyc2VBeGlzUGFyYW06KCk9PkFhLHJhbmRVbmlmb3JtOigpPT5LUixyZXBlYXRlZFRyeTooKT0+ZU0scmlnaHRQYWQ6KCk9PnVjLHNodWZmbGU6KCk9PkRTLHNodWZmbGVDb21ibzooKT0+SFIsc2l6ZUZyb21TaGFwZTooKT0+b3Qsc2l6ZVRvU3F1YXJpc2hTaGFwZTooKT0+SlIsc3F1ZWV6ZVNoYXBlOigpPT5NUyxzdW06KCk9PnFSLHN3YXA6KCk9PlZoLHRhbmg6KCk9PlpSLHRvTmVzdGVkQXJyYXk6KCk9PkVsLHRvVHlwZWRBcnJheTooKT0+Um19KTtmdW5jdGlvbiBYUyhlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8ZSBpbnN0YW5jZW9mIEludDMyQXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl9dmFyIHFrPXhzKEVSKCkpLFlzPXFrLmRlZmF1bHR8fHFrO2Z1bmN0aW9uIHRkKGUpe3JldHVybiBZcy5mcm9tU3RyaW5nKGUsITAsMTYpfXZhciBZUz10ZChcImMzYTVjODVjOTdjYjMxMjdcIiksS3M9dGQoXCJiNDkyYjY2ZmJlOThmMjczXCIpLHduPXRkKFwiOWFlMTZhM2IyZjkwNDA0ZlwiKTtmdW5jdGlvbiB3eChlKXtyZXR1cm4gZS54b3IoZS5zaHJ1KDQ3KSl9ZnVuY3Rpb24gWlMoZSx0LG4pe2xldCBhPWUuc2xpY2UodCx0K24pO3JldHVybiBZcy5mcm9tQnl0ZXMoQXJyYXkuZnJvbShhKSwhMCwhMCl9ZnVuY3Rpb24gYnQoZSx0KXtyZXR1cm4gWlMoZSx0LDgpfWZ1bmN0aW9uIEtrKGUsdCl7cmV0dXJuIFpTKGUsdCw0KX1mdW5jdGlvbiBRdChlLHQpe3JldHVybiB0PT09MD9lOmUuc2hydSh0KS5vcihlLnNobCg2NC10KSl9ZnVuY3Rpb24gbnMoZSx0LG49dGQoXCI5ZGRmZWEwOGViMzgyZDY5XCIpKXtsZXQgYT1lLnhvcih0KS5tdWwobik7YT1hLnhvcihhLnNocnUoNDcpKTtsZXQgcj10LnhvcihhKS5tdWwobik7cmV0dXJuIHI9ci54b3Ioci5zaHJ1KDQ3KSkscj1yLm11bChuKSxyfWZ1bmN0aW9uIHZNKGUsdCxuLGEscixzKXtyPXIuYWRkKGUpLHM9UXQocy5hZGQocikuYWRkKGEpLDIxKTtsZXQgaT1yO3JldHVybiByPXIuYWRkKHQpLHI9ci5hZGQobikscz1zLmFkZChRdChyLDQ0KSksW3IuYWRkKGEpLHMuYWRkKGkpXX1mdW5jdGlvbiB4aChlLHQsbixhKXtyZXR1cm4gdk0oYnQoZSx0KSxidChlLHQrOCksYnQoZSx0KzE2KSxidChlLHQrMjQpLG4sYSl9ZnVuY3Rpb24gd00oZSx0PWUubGVuZ3RoKXtpZih0Pj04KXtsZXQgbj13bi5hZGQodCoyKSxhPWJ0KGUsMCkuYWRkKHduKSxyPWJ0KGUsdC04KSxzPVF0KHIsMzcpLm11bChuKS5hZGQoYSksaT1RdChhLDI1KS5hZGQocikubXVsKG4pO3JldHVybiBucyhzLGksbil9aWYodD49NCl7bGV0IG49d24uYWRkKHQqMiksYT1LayhlLDApO3JldHVybiBucyhhLnNobCgzKS5hZGQodCksS2soZSx0LTQpLG4pfWlmKHQ+MCl7bGV0IG49ZVswXSxhPWVbdD4+MV0scj1lW3QtMV0scz1uKyhhPDw4KSxpPXQrKHI8PDIpO3JldHVybiB3eCh3bi5tdWwocykueG9yKFlTLm11bChpKSkpLm11bCh3bil9cmV0dXJuIHdufWZ1bmN0aW9uIGtNKGUsdD1lLmxlbmd0aCl7bGV0IG49d24uYWRkKHQqMiksYT1idChlLDApLm11bChLcykscj1idChlLDgpLHM9YnQoZSx0LTgpLm11bChuKSxpPWJ0KGUsdC0xNikubXVsKHduKTtyZXR1cm4gbnMoUXQoYS5hZGQociksNDMpLmFkZChRdChzLDMwKSkuYWRkKGkpLGEuYWRkKFF0KHIuYWRkKHduKSwxOCkpLmFkZChzKSxuKX1mdW5jdGlvbiBJTShlLHQ9ZS5sZW5ndGgpe2xldCBuPXduLmFkZCh0KjIpLGE9YnQoZSwwKS5tdWwod24pLHI9YnQoZSw4KSxzPWJ0KGUsdC04KS5tdWwobiksaT1idChlLHQtMTYpLm11bCh3biksbz1RdChhLmFkZChyKSw0MykuYWRkKFF0KHMsMzApKS5hZGQoaSksbD1ucyhvLGEuYWRkKFF0KHIuYWRkKHduKSwxOCkpLmFkZChzKSxuKSx1PWJ0KGUsMTYpLm11bChuKSxwPWJ0KGUsMjQpLGQ9by5hZGQoYnQoZSx0LTMyKSkubXVsKG4pLGM9bC5hZGQoYnQoZSx0LTI0KSkubXVsKG4pO3JldHVybiBucyhRdCh1LmFkZChwKSw0MykuYWRkKFF0KGQsMzApKS5hZGQoYyksdS5hZGQoUXQocC5hZGQoYSksMTgpKS5hZGQoZCksbil9ZnVuY3Rpb24gU00oZSx0PWUubGVuZ3RoKXtsZXQgbj1Zcy5mcm9tTnVtYmVyKDgxLCEwKTtpZih0PD0zMilyZXR1cm4gdDw9MTY/d00oZSx0KTprTShlLHQpO2lmKHQ8PTY0KXJldHVybiBJTShlLHQpO2xldCBhPW4scj1uLm11bChLcykuYWRkKDExMykscz13eChyLm11bCh3bikuYWRkKDExMykpLm11bCh3biksaT1bWXMuVVpFUk8sWXMuVVpFUk9dLG89W1lzLlVaRVJPLFlzLlVaRVJPXTthPWEubXVsKHduKS5hZGQoYnQoZSwwKSk7bGV0IGw9MCx1PSh0LTE+PjYpKjY0LHA9dSsodC0xJjYzKS02MztkbyBhPVF0KGEuYWRkKHIpLmFkZChpWzBdKS5hZGQoYnQoZSxsKzgpKSwzNykubXVsKEtzKSxyPVF0KHIuYWRkKGlbMV0pLmFkZChidChlLGwrNDgpKSw0MikubXVsKEtzKSxhPWEueG9yKG9bMV0pLHI9ci5hZGQoaVswXSkuYWRkKGJ0KGUsbCs0MCkpLHM9UXQocy5hZGQob1swXSksMzMpLm11bChLcyksaT14aChlLGwsaVsxXS5tdWwoS3MpLGEuYWRkKG9bMF0pKSxvPXhoKGUsbCszMixzLmFkZChvWzFdKSxyLmFkZChidChlLGwrMTYpKSksW3MsYV09W2Esc10sbCs9NjQ7d2hpbGUobCE9PXUpO2xldCBkPUtzLmFkZChzLmFuZCgyNTUpLnNobCgxKSk7cmV0dXJuIGw9cCxvWzBdPW9bMF0uYWRkKHQtMSY2MyksaVswXT1pWzBdLmFkZChvWzBdKSxvWzBdPW9bMF0uYWRkKGlbMF0pLGE9UXQoYS5hZGQocikuYWRkKGlbMF0pLmFkZChidChlLGwrOCkpLDM3KS5tdWwoZCkscj1RdChyLmFkZChpWzFdKS5hZGQoYnQoZSxsKzQ4KSksNDIpLm11bChkKSxhPWEueG9yKG9bMV0ubXVsKDkpKSxyPXIuYWRkKGlbMF0ubXVsKDkpLmFkZChidChlLGwrNDApKSkscz1RdChzLmFkZChvWzBdKSwzMykubXVsKGQpLGk9eGgoZSxsLGlbMV0ubXVsKGQpLGEuYWRkKG9bMF0pKSxvPXhoKGUsbCszMixzLmFkZChvWzFdKSxyLmFkZChidChlLGwrMTYpKSksW3MsYV09W2Esc10sbnMobnMoaVswXSxvWzBdLGQpLmFkZCh3eChyKS5tdWwoWVMpKS5hZGQocyksbnMoaVsxXSxvWzFdLGQpLmFkZChhKSxkKX1mdW5jdGlvbiBOTShlLHQpe3JldHVybiB0PT09XCJzdHJpbmdcIj9uZChlKTpSbShbZV0sdCl9ZnVuY3Rpb24gVE0oZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSYmdD09PVwiZmxvYXQzMlwifHxlIGluc3RhbmNlb2YgSW50MzJBcnJheSYmdD09PVwiaW50MzJcInx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJnQ9PT1cImJvb2xcIn1mdW5jdGlvbiBSbShlLHQpe2lmKHQ9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgc3RyaW5nW10gdG8gYSBUeXBlZEFycmF5XCIpO2lmKEFycmF5LmlzQXJyYXkoZSkmJihlPWlzKGUpKSxHKCkuZ2V0Qm9vbChcIkRFQlVHXCIpJiZQUyhlLHQpLFRNKGUsdCkpcmV0dXJuIGU7aWYodD09bnVsbHx8dD09PVwiZmxvYXQzMlwifHx0PT09XCJjb21wbGV4NjRcIilyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShlKTtpZih0PT09XCJpbnQzMlwiKXJldHVybiBuZXcgSW50MzJBcnJheShlKTtpZih0PT09XCJib29sXCIpe2xldCBuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IGE9MDthPG4ubGVuZ3RoOysrYSlNYXRoLnJvdW5kKGVbYV0pIT09MCYmKG5bYV09MSk7cmV0dXJuIG59ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlICR7dH1gKX1mdW5jdGlvbiBnYygpe3JldHVybiBHKCkucGxhdGZvcm0ubm93KCl9ZnVuY3Rpb24gQ00oZSx0KXtyZXR1cm4gRygpLnBsYXRmb3JtLmZldGNoKGUsdCl9ZnVuY3Rpb24gbmQoZSx0PVwidXRmLThcIil7cmV0dXJuIHQ9dHx8XCJ1dGYtOFwiLEcoKS5wbGF0Zm9ybS5lbmNvZGUoZSx0KX1mdW5jdGlvbiBxaChlLHQ9XCJ1dGYtOFwiKXtyZXR1cm4gdD10fHxcInV0Zi04XCIsRygpLnBsYXRmb3JtLmRlY29kZShlLHQpfWZ1bmN0aW9uIGVuKGUpe3JldHVybiBHKCkucGxhdGZvcm0uaXNUeXBlZEFycmF5IT1udWxsP0coKS5wbGF0Zm9ybS5pc1R5cGVkQXJyYXkoZSk6WFMoZSl9ZnVuY3Rpb24gaXMoZSx0PVtdLG49ITEpe2lmKHQ9PW51bGwmJih0PVtdKSx0eXBlb2YgZT09XCJib29sZWFuXCJ8fHR5cGVvZiBlPT1cIm51bWJlclwifHx0eXBlb2YgZT09XCJzdHJpbmdcInx8dm0oZSl8fGU9PW51bGx8fGVuKGUpJiZuKXQucHVzaChlKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSl8fGVuKGUpKWZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7KythKWlzKGVbYV0sdCxuKTtlbHNle2xldCBhPS0xO2ZvcihsZXQgciBvZiBPYmplY3Qua2V5cyhlKSkvXihbMS05XStbMC05XSp8MCkkLy50ZXN0KHIpJiYoYT1NYXRoLm1heChhLE51bWJlcihyKSkpO2ZvcihsZXQgcj0wO3I8PWE7cisrKWlzKGVbcl0sdCxuKX1yZXR1cm4gdH12YXIgRU09Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmJhY2tlbmRUaW1lcj1lLHRoaXMubG9nZ2VyPXQsdD09bnVsbCYmKHRoaXMubG9nZ2VyPW5ldyBBTSl9cHJvZmlsZUtlcm5lbChlLHQsbil7bGV0IGEscj0oKT0+e2E9bigpfSxzLGk9Z2MoKTtpZih0aGlzLmJhY2tlbmRUaW1lci50aW1lckF2YWlsYWJsZSgpKXM9dGhpcy5iYWNrZW5kVGltZXIudGltZShyKTtlbHNle3IoKTtmb3IobGV0IG8gb2YgYSlvLmRhdGFTeW5jKCk7cz1Qcm9taXNlLnJlc29sdmUoe2tlcm5lbE1zOmdjKCktaX0pfWlmKEcoKS5nZXRCb29sKFwiQ0hFQ0tfQ09NUFVUQVRJT05fRk9SX0VSUk9SU1wiKSlmb3IobGV0IG89MDtvPGEubGVuZ3RoO28rKyl7bGV0IGw9YVtvXTtsLmRhdGEoKS50aGVuKHU9PntfTSh1LGwuZHR5cGUsZSl9KX1yZXR1cm57a2VybmVsTmFtZTplLG91dHB1dHM6YSxpbnB1dHM6dCx0aW1lTXM6cy50aGVuKG89Pm8ua2VybmVsTXMpLGV4dHJhSW5mbzpzLnRoZW4obz0+by5nZXRFeHRyYVByb2ZpbGVJbmZvIT1udWxsP28uZ2V0RXh0cmFQcm9maWxlSW5mbygpOlwiXCIpfX1sb2dLZXJuZWxQcm9maWxlKGUpe2xldHtrZXJuZWxOYW1lOnQsb3V0cHV0czpuLHRpbWVNczphLGlucHV0czpyLGV4dHJhSW5mbzpzfT1lO24uZm9yRWFjaChpPT57UHJvbWlzZS5hbGwoW2kuZGF0YSgpLGEsc10pLnRoZW4obz0+e3RoaXMubG9nZ2VyLmxvZ0tlcm5lbFByb2ZpbGUodCxpLG9bMF0sb1sxXSxyLG9bMl0pfSl9KX19O2Z1bmN0aW9uIF9NKGUsdCxuKXtpZih0IT09XCJmbG9hdDMyXCIpcmV0dXJuITE7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKyspe2xldCByPWVbYV07aWYoaXNOYU4ocil8fCFpc0Zpbml0ZShyKSlyZXR1cm4gY29uc29sZS53YXJuKGBGb3VuZCAke3J9IGluIHRoZSByZXN1bHQgb2YgJyR7bn0nYCksITB9cmV0dXJuITF9dmFyIEFNPWNsYXNze2xvZ0tlcm5lbFByb2ZpbGUoZSx0LG4sYSxyLHMpe2xldCBpPXR5cGVvZiBhPT1cIm51bWJlclwiP3VjKGAke2F9bXNgLDkpOmEuZXJyb3Isbz11YyhlLDI1KSxsPXQucmFuayx1PXQuc2l6ZSxwPXVjKHQuc2hhcGUudG9TdHJpbmcoKSwxNCksZD1cIlwiO2ZvcihsZXQgYyBpbiByKXtsZXQgaD1yW2NdO2lmKGghPW51bGwpe2xldCBtPWguc2hhcGV8fHQuc2hhcGUsZj1tLmxlbmd0aDtkKz1gJHtjfTogJHtmfUQgJHtmPjA/bTpcIlwifSBgfX1jb25zb2xlLmxvZyhgJWMke299XHQlYyR7aX1cdCVjJHtsfUQgJHtwfVx0JWMke3V9XHQlYyR7ZH1cdCVjJHtzfWAsXCJmb250LXdlaWdodDpib2xkXCIsXCJjb2xvcjpyZWRcIixcImNvbG9yOmJsdWVcIixcImNvbG9yOiBvcmFuZ2VcIixcImNvbG9yOiBncmVlblwiLFwiY29sb3I6IHN0ZWVsYmx1ZVwiKX19O2Z1bmN0aW9uIEZNKGUsdCxuKXtsZXQgYT17fSxyPXt9O2ZvcihsZXQgbD0wO2w8dC5sZW5ndGg7bCsrKWFbdFtsXS5pZF09ITA7Zm9yKGxldCBsPTA7bDxlLmxlbmd0aDtsKyspe2xldCB1PWVbbF0scD11LmlucHV0cztmb3IobGV0IGQgaW4gcCl7bGV0IGM9cFtkXSxoPSExO2ZvcihsZXQgbT0wO208dC5sZW5ndGg7bSsrKWlmKGFbYy5pZF0pe3Uub3V0cHV0cy5mb3JFYWNoKGY9PmFbZi5pZF09ITApLGg9ITAsclt1LmlkXT0hMDticmVha31pZihoKWJyZWFrfX1sZXQgcz17fTtzW24uaWRdPSEwO2xldCBpPXt9O2ZvcihsZXQgbD1lLmxlbmd0aC0xO2w+PTA7bC0tKXtsZXQgdT1lW2xdLHA9dS5pbnB1dHM7Zm9yKGxldCBkPTA7ZDx1Lm91dHB1dHMubGVuZ3RoO2QrKylpZihzW3Uub3V0cHV0c1tkXS5pZF0pe2ZvcihsZXQgYyBpbiBwKXNbcFtjXS5pZF09ITAsaVt1LmlkXT0hMDticmVha319bGV0IG89W107Zm9yKGxldCBsPTA7bDxlLmxlbmd0aDtsKyspe2xldCB1PWVbbF07aWYoclt1LmlkXSYmaVt1LmlkXSl7bGV0IHA9e307Zm9yKGxldCBjIGluIHUuaW5wdXRzKXtsZXQgaD11LmlucHV0c1tjXTthW2guaWRdJiYocFtjXT1oKX1sZXQgZD1PYmplY3QuYXNzaWduKHt9LHUpO2QuaW5wdXRzPXAsZC5vdXRwdXRzPXUub3V0cHV0cyxvLnB1c2goZCl9fXJldHVybiBvfWZ1bmN0aW9uICRNKGUsdCxuLGEpe2ZvcihsZXQgcj10Lmxlbmd0aC0xO3I+PTA7ci0tKXtsZXQgcz10W3JdLGk9W107aWYocy5vdXRwdXRzLmZvckVhY2gobD0+e2xldCB1PWVbbC5pZF07dSE9bnVsbD9pLnB1c2godSk6aS5wdXNoKG51bGwpfSkscy5ncmFkaWVudD09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb21wdXRlIGdyYWRpZW50OiBncmFkaWVudCBmdW5jdGlvbiBub3QgZm91bmQgZm9yICR7cy5rZXJuZWxOYW1lfS5gKTtsZXQgbz1zLmdyYWRpZW50KGkpO2ZvcihsZXQgbCBpbiBzLmlucHV0cyl7aWYoIShsIGluIG8pKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGJhY2twcm9wIHRocm91Z2ggaW5wdXQgJHtsfS4gQXZhaWxhYmxlIGdyYWRpZW50cyBmb3VuZDogJHtPYmplY3Qua2V5cyhvKX0uYCk7bGV0IHU9bigoKT0+b1tsXSgpKTtpZih1LmR0eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgJHtzLmtlcm5lbE5hbWV9LiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgJHtsfSBtdXN0IGhhdmUgJ2Zsb2F0MzInIGR0eXBlLCBidXQgaGFzICcke3UuZHR5cGV9J2ApO2xldCBwPXMuaW5wdXRzW2xdO2lmKCFBcih1LnNoYXBlLHAuc2hhcGUpKXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wICR7cy5rZXJuZWxOYW1lfS4gVGhlIGdyYWRpZW50IG9mIGlucHV0ICcke2x9JyBoYXMgc2hhcGUgJyR7dS5zaGFwZX0nLCB3aGljaCBkb2VzIG5vdCBtYXRjaCB0aGUgc2hhcGUgb2YgdGhlIGlucHV0ICcke3Auc2hhcGV9J2ApO2lmKGVbcC5pZF09PW51bGwpZVtwLmlkXT11O2Vsc2V7bGV0IGQ9ZVtwLmlkXTtlW3AuaWRdPWEoZCx1KSxkLmRpc3Bvc2UoKX19fX12YXIgWGs9MjAsS3A9MyxzeD03O2Z1bmN0aW9uIERNKGUsdCxuLGEpe2xldCByPVhsKHQpLHM9Uk0oZSx0LG4sciksaT10Lmxlbmd0aCxvPURoKGUsdCxuLHIscyksbD1bXCJUZW5zb3JcIl07cmV0dXJuIGEmJihsLnB1c2goYCAgZHR5cGU6ICR7bn1gKSxsLnB1c2goYCAgcmFuazogJHtpfWApLGwucHVzaChgICBzaGFwZTogWyR7dH1dYCksbC5wdXNoKFwiICB2YWx1ZXM6XCIpKSxsLnB1c2goby5tYXAodT0+XCIgICAgXCIrdSkuam9pbihgXG5gKSksbC5qb2luKGBcbmApfWZ1bmN0aW9uIFJNKGUsdCxuLGEpe2xldCByPW90KHQpLHM9YVthLmxlbmd0aC0xXSxpPW5ldyBBcnJheShzKS5maWxsKDApLG89dC5sZW5ndGgsbD1uPT09XCJjb21wbGV4NjRcIj9lYyhlKTplO2lmKG8+MSlmb3IobGV0IHU9MDt1PHIvczt1Kyspe2xldCBwPXUqcztmb3IobGV0IGQ9MDtkPHM7ZCsrKWlbZF09TWF0aC5tYXgoaVtkXSxRcChsW3ArZF0sMCxuKS5sZW5ndGgpfXJldHVybiBpfWZ1bmN0aW9uIFFwKGUsdCxuKXtsZXQgYTtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9hPWAke3BhcnNlRmxvYXQoZVswXS50b0ZpeGVkKHN4KSl9ICsgJHtwYXJzZUZsb2F0KGVbMV0udG9GaXhlZChzeCkpfWpgOkpyKGUpP2E9YCcke2V9J2A6bj09PVwiYm9vbFwiP2E9SlMoZSk6YT1wYXJzZUZsb2F0KGUudG9GaXhlZChzeCkpLnRvU3RyaW5nKCksdWMoYSx0KX1mdW5jdGlvbiBKUyhlKXtyZXR1cm4gZT09PTA/XCJmYWxzZVwiOlwidHJ1ZVwifWZ1bmN0aW9uIERoKGUsdCxuLGEscixzPSEwKXtsZXQgaT1uPT09XCJjb21wbGV4NjRcIj8yOjEsbz10WzBdLGw9dC5sZW5ndGg7aWYobD09PTApe2lmKG49PT1cImNvbXBsZXg2NFwiKXtsZXQgZj1lYyhlKTtyZXR1cm5bUXAoZlswXSwwLG4pXX1yZXR1cm4gbj09PVwiYm9vbFwiP1tKUyhlWzBdKV06W2VbMF0udG9TdHJpbmcoKV19aWYobD09PTEpe2lmKG8+WGspe2xldCBmPUtwKmksZz1BcnJheS5mcm9tKGUuc2xpY2UoMCxmKSksYj1BcnJheS5mcm9tKGUuc2xpY2UoKG8tS3ApKmksbyppKSk7cmV0dXJuIG49PT1cImNvbXBsZXg2NFwiJiYoZz1lYyhnKSxiPWVjKGIpKSxbXCJbXCIrZy5tYXAoKHkseCk9PlFwKHksclt4XSxuKSkuam9pbihcIiwgXCIpK1wiLCAuLi4sIFwiK2IubWFwKCh5LHgpPT5RcCh5LHJbby1LcCt4XSxuKSkuam9pbihcIiwgXCIpK1wiXVwiXX1yZXR1cm5bXCJbXCIrKG49PT1cImNvbXBsZXg2NFwiP2VjKGUpOkFycmF5LmZyb20oZSkpLm1hcCgoZixnKT0+UXAoZixyW2ddLG4pKS5qb2luKFwiLCBcIikrXCJdXCJdfWxldCB1PXQuc2xpY2UoMSkscD1hLnNsaWNlKDEpLGQ9YVswXSppLGM9W107aWYobz5Yayl7Zm9yKGxldCBmPTA7ZjxLcDtmKyspe2xldCBnPWYqZCxiPWcrZDtjLnB1c2goLi4uRGgoZS5zbGljZShnLGIpLHUsbixwLHIsITEpKX1jLnB1c2goXCIuLi5cIik7Zm9yKGxldCBmPW8tS3A7ZjxvO2YrKyl7bGV0IGc9ZipkLGI9ZytkO2MucHVzaCguLi5EaChlLnNsaWNlKGcsYiksdSxuLHAscixmPT09by0xKSl9fWVsc2UgZm9yKGxldCBmPTA7ZjxvO2YrKyl7bGV0IGc9ZipkLGI9ZytkO2MucHVzaCguLi5EaChlLnNsaWNlKGcsYiksdSxuLHAscixmPT09by0xKSl9bGV0IGg9bD09PTI/XCIsXCI6XCJcIjtjWzBdPVwiW1wiKyhvPjA/Y1swXStoOlwiXCIpO2ZvcihsZXQgZj0xO2Y8Yy5sZW5ndGgtMTtmKyspY1tmXT1cIiBcIitjW2ZdK2g7bGV0IG09YCxcbmA7Zm9yKGxldCBmPTI7ZjxsO2YrKyltKz1gXG5gO3JldHVybiBjW2MubGVuZ3RoLTFdPVwiIFwiK2NbYy5sZW5ndGgtMV0rXCJdXCIrKHM/XCJcIjptKSxjfWZ1bmN0aW9uIGVjKGUpe2xldCB0PVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bis9Mil0LnB1c2goW2Vbbl0sZVtuKzFdXSk7cmV0dXJuIHR9dmFyIFd0PWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXtpZih0aGlzLmR0eXBlPXQsdGhpcy5zaGFwZT1lLnNsaWNlKCksdGhpcy5zaXplPW90KGUpLG4hPW51bGwpe2xldCBhPW4ubGVuZ3RoO0EoYT09PXRoaXMuc2l6ZSwoKT0+YExlbmd0aCBvZiB2YWx1ZXMgJyR7YX0nIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIGluZmVycmVkIGJ5IHRoZSBzaGFwZSAnJHt0aGlzLnNpemV9Jy5gKX1pZih0PT09XCJjb21wbGV4NjRcIil0aHJvdyBuZXcgRXJyb3IoXCJjb21wbGV4NjQgZHR5cGUgVGVuc29yQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGNyZWF0ZSBhIFRlbnNvckJ1ZmZlciBmb3IgdGhlIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cyBzZXBhcmF0ZWx5IGFuZCBjYWxsIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMudmFsdWVzPW58fFN2KHQsdGhpcy5zaXplKSx0aGlzLnN0cmlkZXM9WGwoZSl9c2V0KGUsLi4udCl7dC5sZW5ndGg9PT0wJiYodD1bMF0pLEEodC5sZW5ndGg9PT10aGlzLnJhbmssKCk9PmBUaGUgbnVtYmVyIG9mIHByb3ZpZGVkIGNvb3JkaW5hdGVzICgke3QubGVuZ3RofSkgbXVzdCBtYXRjaCB0aGUgcmFuayAoJHt0aGlzLnJhbmt9KWApO2xldCBuPXRoaXMubG9jVG9JbmRleCh0KTt0aGlzLnZhbHVlc1tuXT1lfWdldCguLi5lKXtlLmxlbmd0aD09PTAmJihlPVswXSk7bGV0IHQ9MDtmb3IobGV0IGEgb2YgZSl7aWYoYTwwfHxhPj10aGlzLnNoYXBlW3RdKXtsZXQgcj1gUmVxdWVzdGVkIG91dCBvZiByYW5nZSBlbGVtZW50IGF0ICR7ZX0uICAgQnVmZmVyIHNoYXBlPSR7dGhpcy5zaGFwZX1gO3Rocm93IG5ldyBFcnJvcihyKX10Kyt9bGV0IG49ZVtlLmxlbmd0aC0xXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoLTE7KythKW4rPXRoaXMuc3RyaWRlc1thXSplW2FdO3JldHVybiB0aGlzLnZhbHVlc1tuXX1sb2NUb0luZGV4KGUpe2lmKHRoaXMucmFuaz09PTApcmV0dXJuIDA7aWYodGhpcy5yYW5rPT09MSlyZXR1cm4gZVswXTtsZXQgdD1lW2UubGVuZ3RoLTFdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGgtMTsrK24pdCs9dGhpcy5zdHJpZGVzW25dKmVbbl07cmV0dXJuIHR9aW5kZXhUb0xvYyhlKXtpZih0aGlzLnJhbms9PT0wKXJldHVybltdO2lmKHRoaXMucmFuaz09PTEpcmV0dXJuW2VdO2xldCB0PW5ldyBBcnJheSh0aGlzLnNoYXBlLmxlbmd0aCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xOysrbil0W25dPU1hdGguZmxvb3IoZS90aGlzLnN0cmlkZXNbbl0pLGUtPXRbbl0qdGhpcy5zdHJpZGVzW25dO3JldHVybiB0W3QubGVuZ3RoLTFdPWUsdH1nZXQgcmFuaygpe3JldHVybiB0aGlzLnNoYXBlLmxlbmd0aH10b1RlbnNvcigpe3JldHVybiB6YSgpLm1ha2VUZW5zb3IodGhpcy52YWx1ZXMsdGhpcy5zaGFwZSx0aGlzLmR0eXBlKX19LHphPW51bGwsU2w9bnVsbCxNTT1udWxsO2Z1bmN0aW9uIE9NKGUpe3phPWV9ZnVuY3Rpb24gUE0oZSl7U2w9ZX1mdW5jdGlvbiBMTShlKXtNTT1lfXZhciBDZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhKXt0aGlzLmtlcHQ9ITEsdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITEsdGhpcy5zaGFwZT1lLnNsaWNlKCksdGhpcy5kdHlwZT10fHxcImZsb2F0MzJcIix0aGlzLnNpemU9b3QoZSksdGhpcy5zdHJpZGVzPVhsKGUpLHRoaXMuZGF0YUlkPW4sdGhpcy5pZD1hLHRoaXMucmFua1R5cGU9dGhpcy5yYW5rPDU/dGhpcy5yYW5rLnRvU3RyaW5nKCk6XCJoaWdoZXJcIn1nZXQgcmFuaygpe3JldHVybiB0aGlzLnNoYXBlLmxlbmd0aH1hc3luYyBidWZmZXIoKXtsZXQgZT1hd2FpdCB0aGlzLmRhdGEoKTtyZXR1cm4gU2wuYnVmZmVyKHRoaXMuc2hhcGUsdGhpcy5kdHlwZSxlKX1idWZmZXJTeW5jKCl7cmV0dXJuIFNsLmJ1ZmZlcih0aGlzLnNoYXBlLHRoaXMuZHR5cGUsdGhpcy5kYXRhU3luYygpKX1hc3luYyBhcnJheSgpe2xldCBlPWF3YWl0IHRoaXMuZGF0YSgpO3JldHVybiBFbCh0aGlzLnNoYXBlLGUsdGhpcy5kdHlwZT09PVwiY29tcGxleDY0XCIpfWFycmF5U3luYygpe3JldHVybiBFbCh0aGlzLnNoYXBlLHRoaXMuZGF0YVN5bmMoKSx0aGlzLmR0eXBlPT09XCJjb21wbGV4NjRcIil9YXN5bmMgZGF0YSgpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7bGV0IGU9emEoKS5yZWFkKHRoaXMuZGF0YUlkKTtpZih0aGlzLmR0eXBlPT09XCJzdHJpbmdcIil7bGV0IHQ9YXdhaXQgZTt0cnl7cmV0dXJuIHQubWFwKG49PnFoKG4pKX1jYXRjaChuKXt0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIHRoZSBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOC4gVG8gZ2V0IHRoZSBvcmlnaW5hbCBieXRlcywgY2FsbCB0ZW5zb3IuYnl0ZXMoKS5cIil9fXJldHVybiBlfWRhdGFUb0dQVShlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx6YSgpLnJlYWRUb0dQVSh0aGlzLmRhdGFJZCxlKX1kYXRhU3luYygpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7bGV0IGU9emEoKS5yZWFkU3luYyh0aGlzLmRhdGFJZCk7aWYodGhpcy5kdHlwZT09PVwic3RyaW5nXCIpdHJ5e3JldHVybiBlLm1hcCh0PT5xaCh0KSl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSB0aGUgc3RyaW5nIGJ5dGVzIGludG8gdXRmLTguIFRvIGdldCB0aGUgb3JpZ2luYWwgYnl0ZXMsIGNhbGwgdGVuc29yLmJ5dGVzKCkuXCIpfXJldHVybiBlfWFzeW5jIGJ5dGVzKCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTtsZXQgZT1hd2FpdCB6YSgpLnJlYWQodGhpcy5kYXRhSWQpO3JldHVybiB0aGlzLmR0eXBlPT09XCJzdHJpbmdcIj9lOm5ldyBVaW50OEFycmF5KGUuYnVmZmVyKX1kaXNwb3NlKCl7dGhpcy5pc0Rpc3Bvc2VkfHwodGhpcy5rZXJhc01hc2smJnRoaXMua2VyYXNNYXNrLmRpc3Bvc2UoKSx6YSgpLmRpc3Bvc2VUZW5zb3IodGhpcyksdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITApfWdldCBpc0Rpc3Bvc2VkKCl7cmV0dXJuIHRoaXMuaXNEaXNwb3NlZEludGVybmFsfXRocm93SWZEaXNwb3NlZCgpe2lmKHRoaXMuaXNEaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaXMgZGlzcG9zZWQuXCIpfXByaW50KGU9ITEpe3JldHVybiBTbC5wcmludCh0aGlzLGUpfWNsb25lKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksU2wuY2xvbmUodGhpcyl9dG9TdHJpbmcoZT0hMSl7bGV0IHQ9dGhpcy5kYXRhU3luYygpO3JldHVybiBETSh0LHRoaXMuc2hhcGUsdGhpcy5kdHlwZSxlKX1jYXN0KGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFNsLmNhc3QodGhpcyxlKX12YXJpYWJsZShlPSEwLHQsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksemEoKS5tYWtlVmFyaWFibGUodGhpcyxlLHQsbil9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2UsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTplPT4hIWUmJmUuZGF0YSE9bnVsbCYmZS5kYXRhU3luYyE9bnVsbCYmZS50aHJvd0lmRGlzcG9zZWQhPW51bGx9KTtmdW5jdGlvbiBRKCl7cmV0dXJuIEN2KFwiVGVuc29yXCIsKCk9PkNlKX1RKCk7dmFyIG9zPWNsYXNzIGV4dGVuZHMgQ2V7Y29uc3RydWN0b3IoZSx0LG4sYSl7c3VwZXIoZS5zaGFwZSxlLmR0eXBlLGUuZGF0YUlkLGEpLHRoaXMudHJhaW5hYmxlPXQsdGhpcy5uYW1lPW59YXNzaWduKGUpe2lmKGUuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihgZHR5cGUgb2YgdGhlIG5ldyB2YWx1ZSAoJHtlLmR0eXBlfSkgYW5kIHByZXZpb3VzIHZhbHVlICgke3RoaXMuZHR5cGV9KSBtdXN0IG1hdGNoYCk7aWYoIUFyKGUuc2hhcGUsdGhpcy5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKGBzaGFwZSBvZiB0aGUgbmV3IHZhbHVlICgke2Uuc2hhcGV9KSBhbmQgcHJldmlvdXMgdmFsdWUgKCR7dGhpcy5zaGFwZX0pIG11c3QgbWF0Y2hgKTt6YSgpLmRpc3Bvc2VUZW5zb3IodGhpcyksdGhpcy5kYXRhSWQ9ZS5kYXRhSWQsemEoKS5pbmNSZWYodGhpcyxudWxsKX1kaXNwb3NlKCl7emEoKS5kaXNwb3NlVmFyaWFibGUodGhpcyksdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITB9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkob3MsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTplPT5lIGluc3RhbmNlb2YgQ2UmJmUuYXNzaWduIT1udWxsJiZlLmFzc2lnbiBpbnN0YW5jZW9mIEZ1bmN0aW9ufSk7dmFyIFdhPXt9O19lKFdhLHthc3NlcnRUeXBlc01hdGNoOigpPT50TixnZXRUZW5zb3JzSW5Db250YWluZXI6KCk9Pl92LGlzVGVuc29ySW5MaXN0OigpPT5XTSxtYWtlVHlwZXNNYXRjaDooKT0+X3R9KTt2YXIga3g7KGZ1bmN0aW9uKGUpe2UuUjA9XCJSMFwiLGUuUjE9XCJSMVwiLGUuUjI9XCJSMlwiLGUuUjM9XCJSM1wiLGUuUjQ9XCJSNFwiLGUuUjU9XCJSNVwiLGUuUjY9XCJSNlwifSkoa3h8fChreD17fSkpO3ZhciBJeDsoZnVuY3Rpb24oZSl7ZS5mbG9hdDMyPVwiZmxvYXQzMlwiLGUuaW50MzI9XCJpbnQzMlwiLGUuYm9vbD1cImludDMyXCIsZS5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0pKEl4fHwoSXg9e30pKTt2YXIgU3g7KGZ1bmN0aW9uKGUpe2UuZmxvYXQzMj1cImZsb2F0MzJcIixlLmludDMyPVwiaW50MzJcIixlLmJvb2w9XCJib29sXCIsZS5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0pKFN4fHwoU3g9e30pKTt2YXIgTng7KGZ1bmN0aW9uKGUpe2UuZmxvYXQzMj1cImZsb2F0MzJcIixlLmludDMyPVwiZmxvYXQzMlwiLGUuYm9vbD1cImZsb2F0MzJcIixlLmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifSkoTnh8fChOeD17fSkpO3ZhciBUeDsoZnVuY3Rpb24oZSl7ZS5mbG9hdDMyPVwiY29tcGxleDY0XCIsZS5pbnQzMj1cImNvbXBsZXg2NFwiLGUuYm9vbD1cImNvbXBsZXg2NFwiLGUuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KShUeHx8KFR4PXt9KSk7dmFyIHpNPXtmbG9hdDMyOk54LGludDMyOkl4LGJvb2w6U3gsY29tcGxleDY0OlR4fTtmdW5jdGlvbiBmYShlLHQpe2lmKGU9PT1cInN0cmluZ1wifHx0PT09XCJzdHJpbmdcIil7aWYoZT09PVwic3RyaW5nXCImJnQ9PT1cInN0cmluZ1wiKXJldHVyblwic3RyaW5nXCI7dGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IHVwY2FzdCAke2V9IHdpdGggJHt0fWApfXJldHVybiB6TVtlXVt0XX1mdW5jdGlvbiBNbShlKXtyZXR1cm4gZmEoZSxcImludDMyXCIpfWZ1bmN0aW9uIFFTKGUpe3JldHVybiBlIT1udWxsJiZ0eXBlb2YgZT09XCJvYmplY3RcIiYmXCJ0ZXh0dXJlXCJpbiBlJiZlLnRleHR1cmUgaW5zdGFuY2VvZiBXZWJHTFRleHR1cmV9ZnVuY3Rpb24gZU4oZSl7cmV0dXJuIHR5cGVvZiBHUFVCdWZmZXIhPVwidW5kZWZpbmVkXCImJmUhPW51bGwmJnR5cGVvZiBlPT1cIm9iamVjdFwiJiZcImJ1ZmZlclwiaW4gZSYmZS5idWZmZXIgaW5zdGFuY2VvZiBHUFVCdWZmZXJ9ZnVuY3Rpb24gX3QoZSx0KXtpZihlLmR0eXBlPT09dC5kdHlwZSlyZXR1cm5bZSx0XTtsZXQgbj1mYShlLmR0eXBlLHQuZHR5cGUpO3JldHVybltlLmNhc3QobiksdC5jYXN0KG4pXX1mdW5jdGlvbiB0TihlLHQpe0EoZS5kdHlwZT09PXQuZHR5cGUsKCk9PmBUaGUgZHR5cGVzIG9mIHRoZSBmaXJzdCgke2UuZHR5cGV9KSBhbmQgc2Vjb25kKCR7dC5kdHlwZX0pIGlucHV0IG11c3QgbWF0Y2hgKX1mdW5jdGlvbiBXTShlLHQpe3JldHVybiB0LnNvbWUobj0+bi5pZD09PWUuaWQpfWZ1bmN0aW9uIF92KGUpe2xldCB0PVtdO3JldHVybiBuTihlLHQsbmV3IFNldCksdH1mdW5jdGlvbiBuTihlLHQsbil7aWYoZT09bnVsbClyZXR1cm47aWYoZSBpbnN0YW5jZW9mIENlKXt0LnB1c2goZSk7cmV0dXJufWlmKCFCTShlKSlyZXR1cm47bGV0IGE9ZTtmb3IobGV0IHIgaW4gYSl7bGV0IHM9YVtyXTtuLmhhcyhzKXx8KG4uYWRkKHMpLG5OKHMsdCxuKSl9fWZ1bmN0aW9uIEJNKGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpfHx0eXBlb2YgZT09XCJvYmplY3RcIn1mdW5jdGlvbiBpeChlKXtyZXR1cm4gZS5rZXJuZWxOYW1lIT1udWxsfXZhciBZaz1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcz17fSx0aGlzLm5leHRUYXBlTm9kZUlkPTAsdGhpcy5udW1CeXRlcz0wLHRoaXMubnVtVGVuc29ycz0wLHRoaXMubnVtU3RyaW5nVGVuc29ycz0wLHRoaXMubnVtRGF0YUJ1ZmZlcnM9MCx0aGlzLmdyYWRpZW50RGVwdGg9MCx0aGlzLmtlcm5lbERlcHRoPTAsdGhpcy5zY29wZVN0YWNrPVtdLHRoaXMubnVtRGF0YU1vdmVzU3RhY2s9W10sdGhpcy5uZXh0U2NvcGVJZD0wLHRoaXMudGVuc29ySW5mbz1uZXcgV2Vha01hcCx0aGlzLnByb2ZpbGluZz0hMSx0aGlzLmFjdGl2ZVByb2ZpbGU9e25ld0J5dGVzOjAsbmV3VGVuc29yczowLHBlYWtCeXRlczowLGtlcm5lbHM6W10scmVzdWx0Om51bGwsZ2V0IGtlcm5lbE5hbWVzKCl7cmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh0aGlzLmtlcm5lbHMubWFwKGU9PmUubmFtZSkpKX19fWRpc3Bvc2UoKXtmb3IobGV0IGUgaW4gdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzKXRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1tlXS5kaXNwb3NlKCl9fSxBdj1jbGFzcyBDeHtjb25zdHJ1Y3Rvcih0KXt0aGlzLkVOVj10LHRoaXMucmVnaXN0cnk9e30sdGhpcy5yZWdpc3RyeUZhY3Rvcnk9e30sdGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZD0wLHRoaXMuc3RhdGU9bmV3IFlrfWFzeW5jIHJlYWR5KCl7aWYodGhpcy5wZW5kaW5nQmFja2VuZEluaXQhPW51bGwpcmV0dXJuIHRoaXMucGVuZGluZ0JhY2tlbmRJbml0LnRoZW4oKCk9Pnt9KTtpZih0aGlzLmJhY2tlbmRJbnN0YW5jZSE9bnVsbClyZXR1cm47bGV0IHQ9dGhpcy5nZXRTb3J0ZWRCYWNrZW5kcygpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtsZXQgYT10W25dO2lmKGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQoYSkuc3VjY2Vzcyl7YXdhaXQgdGhpcy5zZXRCYWNrZW5kKGEpO3JldHVybn19dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX1nZXQgYmFja2VuZCgpe2lmKHRoaXMucGVuZGluZ0JhY2tlbmRJbml0IT1udWxsKXRocm93IG5ldyBFcnJvcihgQmFja2VuZCAnJHt0aGlzLmJhY2tlbmROYW1lfScgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXplZC4gTWFrZSBzdXJlIHRvIGF3YWl0IHRmLnJlYWR5KCkgb3IgYXdhaXQgdGYuc2V0QmFja2VuZCgpIGJlZm9yZSBjYWxsaW5nIG90aGVyIG1ldGhvZHNgKTtpZih0aGlzLmJhY2tlbmRJbnN0YW5jZT09bnVsbCl7bGV0e25hbWU6dCxhc3luY0luaXQ6bn09dGhpcy5pbml0aWFsaXplQmFja2VuZHNBbmRSZXR1cm5CZXN0KCk7aWYobil0aHJvdyBuZXcgRXJyb3IoYFRoZSBoaWdoZXN0IHByaW9yaXR5IGJhY2tlbmQgJyR7dH0nIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB0byBhd2FpdCB0Zi5yZWFkeSgpIG9yIGF3YWl0IHRmLnNldEJhY2tlbmQoKSBiZWZvcmUgY2FsbGluZyBvdGhlciBtZXRob2RzYCk7dGhpcy5zZXRCYWNrZW5kKHQpfXJldHVybiB0aGlzLmJhY2tlbmRJbnN0YW5jZX1iYWNrZW5kTmFtZXMoKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpfWZpbmRCYWNrZW5kKHQpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5KSlpZih0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KXtsZXR7YXN5bmNJbml0Om59PXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQodCk7aWYobilyZXR1cm4gbnVsbH1lbHNlIHJldHVybiBudWxsO3JldHVybiB0aGlzLnJlZ2lzdHJ5W3RdfWZpbmRCYWNrZW5kRmFjdG9yeSh0KXtyZXR1cm4gdCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeT90aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XS5mYWN0b3J5Om51bGx9cmVnaXN0ZXJCYWNrZW5kKHQsbixhPTEpe3JldHVybiB0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5PyhacihgJHt0fSBiYWNrZW5kIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQuIFJldXNpbmcgZXhpc3RpbmcgYmFja2VuZCBmYWN0b3J5LmApLCExKToodGhpcy5yZWdpc3RyeUZhY3RvcnlbdF09e2ZhY3Rvcnk6bixwcmlvcml0eTphfSwhMCl9YXN5bmMgc2V0QmFja2VuZCh0KXtpZih0aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmQgbmFtZSAnJHt0fScgbm90IGZvdW5kIGluIHJlZ2lzdHJ5YCk7aWYodGhpcy5iYWNrZW5kTmFtZT10LHRoaXMucmVnaXN0cnlbdF09PW51bGwpe3RoaXMuYmFja2VuZEluc3RhbmNlPW51bGw7bGV0e3N1Y2Nlc3M6bixhc3luY0luaXQ6YX09dGhpcy5pbml0aWFsaXplQmFja2VuZCh0KTtpZighKGE/YXdhaXQgbjpuKSlyZXR1cm4hMX1yZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2U9dGhpcy5yZWdpc3RyeVt0XSx0aGlzLnNldHVwUmVnaXN0ZXJlZEtlcm5lbHMoKSx0aGlzLnByb2ZpbGVyPW5ldyBFTSh0aGlzLmJhY2tlbmRJbnN0YW5jZSksITB9c2V0dXBSZWdpc3RlcmVkS2VybmVscygpe2poKHRoaXMuYmFja2VuZE5hbWUpLmZvckVhY2godD0+e3Quc2V0dXBGdW5jIT1udWxsJiZ0LnNldHVwRnVuYyh0aGlzLmJhY2tlbmRJbnN0YW5jZSl9KX1kaXNwb3NlUmVnaXN0ZXJlZEtlcm5lbHModCl7amgodCkuZm9yRWFjaChuPT57bi5kaXNwb3NlRnVuYyE9bnVsbCYmbi5kaXNwb3NlRnVuYyh0aGlzLnJlZ2lzdHJ5W3RdKX0pfWluaXRpYWxpemVCYWNrZW5kKHQpe2xldCBuPXRoaXMucmVnaXN0cnlGYWN0b3J5W3RdO2lmKG49PW51bGwpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW5pdGlhbGl6ZSBiYWNrZW5kICR7dH0sIG5vIHJlZ2lzdHJhdGlvbiBmb3VuZC5gKTt0cnl7bGV0IGE9bi5mYWN0b3J5KCk7aWYoYSYmIShhIGluc3RhbmNlb2YgRmMpJiZ0eXBlb2YgYS50aGVuPT1cImZ1bmN0aW9uXCIpe2xldCByPSsrdGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZCxzPWEudGhlbihpPT5yPHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQ/ITE6KHRoaXMucmVnaXN0cnlbdF09aSx0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLCEwKSkuY2F0Y2goaT0+KHI8dGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZHx8KHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsWnIoYEluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgJHt0fSBmYWlsZWRgKSxacihpLnN0YWNrfHxpLm1lc3NhZ2UpKSwhMSkpO3JldHVybiB0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1zLHtzdWNjZXNzOnMsYXN5bmNJbml0OiEwfX1lbHNlIHJldHVybiB0aGlzLnJlZ2lzdHJ5W3RdPWEse3N1Y2Nlc3M6ITAsYXN5bmNJbml0OiExfX1jYXRjaChhKXtyZXR1cm4gWnIoYEluaXRpYWxpemF0aW9uIG9mIGJhY2tlbmQgJHt0fSBmYWlsZWRgKSxacihhLnN0YWNrfHxhLm1lc3NhZ2UpLHtzdWNjZXNzOiExLGFzeW5jSW5pdDohMX19fXJlbW92ZUJhY2tlbmQodCl7aWYoISh0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5KSl0aHJvdyBuZXcgRXJyb3IoYCR7dH0gYmFja2VuZCBub3QgZm91bmQgaW4gcmVnaXN0cnlgKTt0aGlzLmJhY2tlbmROYW1lPT09dCYmdGhpcy5wZW5kaW5nQmFja2VuZEluaXQhPW51bGwmJnRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQrKyx0IGluIHRoaXMucmVnaXN0cnkmJih0aGlzLmRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyh0KSx0aGlzLnJlZ2lzdHJ5W3RdLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5yZWdpc3RyeVt0XSksZGVsZXRlIHRoaXMucmVnaXN0cnlGYWN0b3J5W3RdLHRoaXMuYmFja2VuZE5hbWU9PT10JiYodGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCx0aGlzLmJhY2tlbmROYW1lPW51bGwsdGhpcy5iYWNrZW5kSW5zdGFuY2U9bnVsbCl9Z2V0U29ydGVkQmFja2VuZHMoKXtpZihPYmplY3Qua2V5cyh0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJObyBiYWNrZW5kIGZvdW5kIGluIHJlZ2lzdHJ5LlwiKTtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RyeUZhY3RvcnkpLnNvcnQoKHQsbik9PnRoaXMucmVnaXN0cnlGYWN0b3J5W25dLnByaW9yaXR5LXRoaXMucmVnaXN0cnlGYWN0b3J5W3RdLnByaW9yaXR5KX1pbml0aWFsaXplQmFja2VuZHNBbmRSZXR1cm5CZXN0KCl7bGV0IHQ9dGhpcy5nZXRTb3J0ZWRCYWNrZW5kcygpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtsZXQgYT10W25dLHtzdWNjZXNzOnIsYXN5bmNJbml0OnN9PXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQoYSk7aWYoc3x8cilyZXR1cm57bmFtZTphLGFzeW5jSW5pdDpzfX10aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgaW5pdGlhbGl6ZSBhbnkgYmFja2VuZHMsIGFsbCBiYWNrZW5kIGluaXRpYWxpemF0aW9ucyBmYWlsZWQuXCIpfW1vdmVEYXRhKHQsbil7bGV0IGE9dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldChuKSxyPWEuYmFja2VuZCxzPXRoaXMucmVhZFN5bmMobiksaT1yLnJlZkNvdW50KG4pO3IuZGlzcG9zZURhdGEobiwhMCksYS5iYWNrZW5kPXQsdC5tb3ZlKG4scyxhLnNoYXBlLGEuZHR5cGUsaSksdGhpcy5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnRoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2tbdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFjay5sZW5ndGgtMV0rK310aWR5KHQsbil7bGV0IGE9bnVsbDtpZihuPT1udWxsKXtpZih0eXBlb2YgdCE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgZnVuY3Rpb24gdG8gdGlkeSgpXCIpO249dH1lbHNle2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiJiYhKHQgaW5zdGFuY2VvZiBTdHJpbmcpKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aWR5KCkgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZih0eXBlb2YgbiE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSAybmQgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBmdW5jdGlvblwiKTthPXR9bGV0IHI7cmV0dXJuIHRoaXMuc2NvcGVkUnVuKCgpPT50aGlzLnN0YXJ0U2NvcGUoYSksKCk9PnRoaXMuZW5kU2NvcGUociksKCk9PihyPW4oKSxyIGluc3RhbmNlb2YgUHJvbWlzZSYmY29uc29sZS5lcnJvcihcIkNhbm5vdCByZXR1cm4gYSBQcm9taXNlIGluc2lkZSBvZiB0aWR5LlwiKSxyKSl9c2NvcGVkUnVuKHQsbixhKXt0KCk7dHJ5e2xldCByPWEoKTtyZXR1cm4gbigpLHJ9Y2F0Y2gocil7dGhyb3cgbigpLHJ9fW5leHRUZW5zb3JJZCgpe3JldHVybiBDeC5uZXh0VGVuc29ySWQrK31uZXh0VmFyaWFibGVJZCgpe3JldHVybiBDeC5uZXh0VmFyaWFibGVJZCsrfWNsb25lKHQpe2xldCBuPVAucnVuS2VybmVsKGVvLHt4OnR9KSxhPXt4OnR9LHI9aT0+KHt4OigpPT57bGV0IG89XCJmbG9hdDMyXCIsbD17eDppfSx1PXtkdHlwZTpvfTtyZXR1cm4gUC5ydW5LZXJuZWwoTWksbCx1KX19KSxzPVtdO3JldHVybiB0aGlzLmFkZFRhcGVOb2RlKHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZSxhLFtuXSxyLHMse30pLG59cnVuS2VybmVsKHQsbixhKXtpZih0aGlzLmJhY2tlbmROYW1lPT1udWxsJiZ0aGlzLmJhY2tlbmQsZmModCx0aGlzLmJhY2tlbmROYW1lKT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYEtlcm5lbCAnJHt0fScgbm90IHJlZ2lzdGVyZWQgZm9yIGJhY2tlbmQgJyR7dGhpcy5iYWNrZW5kTmFtZX0nYCk7cmV0dXJuIHRoaXMucnVuS2VybmVsRnVuYyh7a2VybmVsTmFtZTp0LGlucHV0czpuLGF0dHJzOmF9KX1zaG91bGRDaGVja0Zvck1lbUxlYWtzKCl7cmV0dXJuIHRoaXMuRU5WLmdldEJvb2woXCJJU19URVNUXCIpfWNoZWNrS2VybmVsRm9yTWVtTGVhayh0LG4sYSl7bGV0IHI9dGhpcy5iYWNrZW5kLm51bURhdGFJZHMoKSxzPTA7YS5mb3JFYWNoKGw9PntzKz1sLmR0eXBlPT09XCJjb21wbGV4NjRcIj8zOjF9KTtsZXQgaT10aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrW3RoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2subGVuZ3RoLTFdLG89ci1uLXMtaTtpZihvPjApdGhyb3cgbmV3IEVycm9yKGBCYWNrZW5kICcke3RoaXMuYmFja2VuZE5hbWV9JyBoYXMgYW4gaW50ZXJuYWwgbWVtb3J5IGxlYWsgKCR7b30gZGF0YSBpZHMpIGFmdGVyIHJ1bm5pbmcgJyR7dH0nYCl9cnVuS2VybmVsRnVuYyh0KXtsZXQgbixhPVtdLHI9dGhpcy5pc1RhcGVPbigpLHM9dGhpcy5zdGF0ZS5udW1CeXRlcyxpPXRoaXMuc3RhdGUubnVtVGVuc29yczt0aGlzLnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFjay5wdXNoKDApO2xldCBvO3RoaXMuYmFja2VuZE5hbWU9PW51bGwmJnRoaXMuYmFja2VuZDtsZXQgbCx1PWl4KHQpP3Qua2VybmVsTmFtZTp0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlIT1udWxsP3RoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZTpcIlwiO2lmKGl4KHQpKXtsZXR7a2VybmVsTmFtZTptLGlucHV0czpmLGF0dHJzOmd9PXQ7dGhpcy5iYWNrZW5kTmFtZT09bnVsbCYmdGhpcy5iYWNrZW5kO2xldCBiPWZjKG0sdGhpcy5iYWNrZW5kTmFtZSk7QShiIT1udWxsLCgpPT5gQ2Fubm90IGZpbmQgcmVnaXN0ZXJlZCBrZXJuZWwgJyR7bX0nIGZvciBiYWNrZW5kICcke3RoaXMuYmFja2VuZE5hbWV9J2ApLG89KCk9PntsZXQgeT10aGlzLmJhY2tlbmQubnVtRGF0YUlkcygpO2w9Yi5rZXJuZWxGdW5jKHtpbnB1dHM6ZixhdHRyczpnLGJhY2tlbmQ6dGhpcy5iYWNrZW5kfSk7bGV0IHg9QXJyYXkuaXNBcnJheShsKT9sOltsXTt0aGlzLnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdGhpcy5jaGVja0tlcm5lbEZvck1lbUxlYWsobSx5LHgpO2xldCB2PXgubWFwKEk9PkkucmFuayE9bnVsbD9JOnRoaXMubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKEkpKTtpZihyKXtsZXQgST10aGlzLmdldFRlbnNvcnNGb3JHcmFkaWVudChtLGYsdik7YT10aGlzLnNhdmVUZW5zb3JzRm9yQmFja3dhcmRNb2RlKEkpfXJldHVybiB2fX1lbHNle2xldHtmb3J3YXJkRnVuYzptfT10LGY9Zz0+e3ImJihhPWcubWFwKGI9PnRoaXMua2VlcCh0aGlzLmNsb25lKGIpKSkpfTtvPSgpPT57bGV0IGc9dGhpcy5iYWNrZW5kLm51bURhdGFJZHMoKTtsPXRoaXMudGlkeSgoKT0+bSh0aGlzLmJhY2tlbmQsZikpO2xldCBiPUFycmF5LmlzQXJyYXkobCk/bDpbbF07cmV0dXJuIHRoaXMuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcygpJiZ0aGlzLmNoZWNrS2VybmVsRm9yTWVtTGVhayh1LGcsYiksYn19bGV0e2lucHV0czpwLGF0dHJzOmR9PXQsYz1peCh0KT9udWxsOnQuYmFja3dhcmRzRnVuYyxoO3JldHVybiB0aGlzLnNjb3BlZFJ1bigoKT0+dGhpcy5zdGF0ZS5rZXJuZWxEZXB0aCsrLCgpPT50aGlzLnN0YXRlLmtlcm5lbERlcHRoLS0sKCk9PnshdGhpcy5FTlYuZ2V0Qm9vbChcIkRFQlVHXCIpJiYhdGhpcy5zdGF0ZS5wcm9maWxpbmc/bj1vKCk6KGg9dGhpcy5wcm9maWxlci5wcm9maWxlS2VybmVsKHUscCwoKT0+bygpKSx0aGlzLkVOVi5nZXRCb29sKFwiREVCVUdcIikmJnRoaXMucHJvZmlsZXIubG9nS2VybmVsUHJvZmlsZShoKSxuPWgub3V0cHV0cyl9KSxyJiZ0aGlzLmFkZFRhcGVOb2RlKHUscCxuLGMsYSxkKSx0aGlzLnN0YXRlLnByb2ZpbGluZyYmdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMucHVzaCh7bmFtZTp1LGJ5dGVzQWRkZWQ6dGhpcy5zdGF0ZS5udW1CeXRlcy1zLHRvdGFsQnl0ZXNTbmFwc2hvdDp0aGlzLnN0YXRlLm51bUJ5dGVzLHRlbnNvcnNBZGRlZDp0aGlzLnN0YXRlLm51bVRlbnNvcnMtaSx0b3RhbFRlbnNvcnNTbmFwc2hvdDp0aGlzLnN0YXRlLm51bVRlbnNvcnMsaW5wdXRTaGFwZXM6T2JqZWN0LmtleXMocCkubWFwKG09PnBbbV0hPW51bGw/cFttXS5zaGFwZTpudWxsKSxvdXRwdXRTaGFwZXM6bi5tYXAobT0+bS5zaGFwZSksa2VybmVsVGltZU1zOmgudGltZU1zLGV4dHJhSW5mbzpoLmV4dHJhSW5mb30pLEFycmF5LmlzQXJyYXkobCk/bjpuWzBdfXNhdmVUZW5zb3JzRm9yQmFja3dhcmRNb2RlKHQpe3JldHVybiB0Lm1hcChuPT50aGlzLmtlZXAodGhpcy5jbG9uZShuKSkpfWdldFRlbnNvcnNGb3JHcmFkaWVudCh0LG4sYSl7bGV0IHI9dngodCk7aWYociE9bnVsbCl7bGV0IHM9ci5pbnB1dHNUb1NhdmV8fFtdLGk9ci5vdXRwdXRzVG9TYXZlfHxbXSxvO3Iuc2F2ZUFsbElucHV0cz8oQShBcnJheS5pc0FycmF5KG4pLCgpPT5cInNhdmVBbGxJbnB1dHMgaXMgdHJ1ZSwgZXhwZWN0ZWQgaW5wdXRzIHRvIGJlIGFuIGFycmF5LlwiKSxvPU9iamVjdC5rZXlzKG4pLm1hcCh1PT5uW3VdKSk6bz1zLm1hcCh1PT5uW3VdKTtsZXQgbD1hLmZpbHRlcigodSxwKT0+aVtwXSk7cmV0dXJuIG8uY29uY2F0KGwpfXJldHVybltdfW1ha2VUZW5zb3IodCxuLGEscil7aWYodD09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZXMgcGFzc2VkIHRvIGVuZ2luZS5tYWtlVGVuc29yKCkgYXJlIG51bGxcIik7YT1hfHxcImZsb2F0MzJcIixyPXJ8fHRoaXMuYmFja2VuZDtsZXQgcz10O2E9PT1cInN0cmluZ1wiJiZKcih0WzBdKSYmKHM9dC5tYXAobD0+bmQobCkpKTtsZXQgaT1yLndyaXRlKHMsbixhKSxvPW5ldyBDZShuLGEsaSx0aGlzLm5leHRUZW5zb3JJZCgpKTtpZih0aGlzLnRyYWNrVGVuc29yKG8sciksYT09PVwic3RyaW5nXCIpe2xldCBsPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQoaSksdT16UyhzKTt0aGlzLnN0YXRlLm51bUJ5dGVzKz11LWwuYnl0ZXMsbC5ieXRlcz11fXJldHVybiBvfW1ha2VUZW5zb3JGcm9tRGF0YUlkKHQsbixhLHIpe2E9YXx8XCJmbG9hdDMyXCI7bGV0IHM9e2RhdGFJZDp0LHNoYXBlOm4sZHR5cGU6YX07cmV0dXJuIHRoaXMubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKHMscil9bWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKHQsbil7bGV0e2RhdGFJZDphLHNoYXBlOnIsZHR5cGU6c309dCxpPW5ldyBDZShyLHMsYSx0aGlzLm5leHRUZW5zb3JJZCgpKTtyZXR1cm4gdGhpcy50cmFja1RlbnNvcihpLG4pLGl9bWFrZVZhcmlhYmxlKHQsbj0hMCxhLHIpe2E9YXx8dGhpcy5uZXh0VmFyaWFibGVJZCgpLnRvU3RyaW5nKCksciE9bnVsbCYmciE9PXQuZHR5cGUmJih0PXQuY2FzdChyKSk7bGV0IHM9bmV3IG9zKHQsbixhLHRoaXMubmV4dFRlbnNvcklkKCkpO2lmKHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1tzLm5hbWVdIT1udWxsKXRocm93IG5ldyBFcnJvcihgVmFyaWFibGUgd2l0aCBuYW1lICR7cy5uYW1lfSB3YXMgYWxyZWFkeSByZWdpc3RlcmVkYCk7cmV0dXJuIHRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1tzLm5hbWVdPXMsdGhpcy5pbmNSZWYocyx0aGlzLmJhY2tlbmQpLHN9dHJhY2tUZW5zb3IodCxuKXt0aGlzLnN0YXRlLm51bVRlbnNvcnMrKyx0LmR0eXBlPT09XCJzdHJpbmdcIiYmdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzKys7bGV0IGE9MDt0LmR0eXBlIT09XCJjb21wbGV4NjRcIiYmdC5kdHlwZSE9PVwic3RyaW5nXCImJihhPXQuc2l6ZSpVaCh0LmR0eXBlKSksdGhpcy5zdGF0ZS5udW1CeXRlcys9YSx0aGlzLnN0YXRlLnRlbnNvckluZm8uaGFzKHQuZGF0YUlkKXx8KHRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMrKyx0aGlzLnN0YXRlLnRlbnNvckluZm8uc2V0KHQuZGF0YUlkLHtiYWNrZW5kOm58fHRoaXMuYmFja2VuZCxkdHlwZTp0LmR0eXBlLHNoYXBlOnQuc2hhcGUsYnl0ZXM6YX0pKSx0IGluc3RhbmNlb2Ygb3N8fHRoaXMudHJhY2sodCl9aW5jUmVmKHQsbil7dGhpcy50cmFja1RlbnNvcih0LG4pLHRoaXMuYmFja2VuZC5pbmNSZWYodC5kYXRhSWQpfXJlbW92ZURhdGFJZCh0LG4pe3RoaXMuc3RhdGUudGVuc29ySW5mby5oYXModCkmJnRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCkuYmFja2VuZD09PW4mJih0aGlzLnN0YXRlLnRlbnNvckluZm8uZGVsZXRlKHQpLHRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMtLSl9ZGlzcG9zZVRlbnNvcih0KXtpZighdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyh0LmRhdGFJZCkpcmV0dXJuO2xldCBuPXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpO2lmKHRoaXMuc3RhdGUubnVtVGVuc29ycy0tLHQuZHR5cGU9PT1cInN0cmluZ1wiJiYodGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzLS0sdGhpcy5zdGF0ZS5udW1CeXRlcy09bi5ieXRlcyksdC5kdHlwZSE9PVwiY29tcGxleDY0XCImJnQuZHR5cGUhPT1cInN0cmluZ1wiKXtsZXQgYT10LnNpemUqVWgodC5kdHlwZSk7dGhpcy5zdGF0ZS5udW1CeXRlcy09YX1uLmJhY2tlbmQuZGlzcG9zZURhdGEodC5kYXRhSWQpJiZ0aGlzLnJlbW92ZURhdGFJZCh0LmRhdGFJZCxuLmJhY2tlbmQpfWRpc3Bvc2VWYXJpYWJsZXMoKXtmb3IobGV0IHQgaW4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzKXtsZXQgbj10aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF07dGhpcy5kaXNwb3NlVmFyaWFibGUobil9fWRpc3Bvc2VWYXJpYWJsZSh0KXt0aGlzLmRpc3Bvc2VUZW5zb3IodCksdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV0hPW51bGwmJmRlbGV0ZSB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdC5uYW1lXX1tZW1vcnkoKXtsZXQgdD10aGlzLmJhY2tlbmQubWVtb3J5KCk7cmV0dXJuIHQubnVtVGVuc29ycz10aGlzLnN0YXRlLm51bVRlbnNvcnMsdC5udW1EYXRhQnVmZmVycz10aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzLHQubnVtQnl0ZXM9dGhpcy5zdGF0ZS5udW1CeXRlcyx0aGlzLnN0YXRlLm51bVN0cmluZ1RlbnNvcnM+MCYmKHQudW5yZWxpYWJsZT0hMCx0LnJlYXNvbnM9PW51bGwmJih0LnJlYXNvbnM9W10pLHQucmVhc29ucy5wdXNoKFwiTWVtb3J5IHVzYWdlIGJ5IHN0cmluZyB0ZW5zb3JzIGlzIGFwcHJveGltYXRlICgyIGJ5dGVzIHBlciBjaGFyYWN0ZXIpXCIpKSx0fWFzeW5jIHByb2ZpbGUodCl7dGhpcy5zdGF0ZS5wcm9maWxpbmc9ITA7bGV0IG49dGhpcy5zdGF0ZS5udW1CeXRlcyxhPXRoaXMuc3RhdGUubnVtVGVuc29yczt0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscz1bXSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucmVzdWx0PWF3YWl0IHQoKSx0aGlzLnN0YXRlLnByb2ZpbGluZz0hMSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucGVha0J5dGVzPU1hdGgubWF4KC4uLnRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzLm1hcChyPT5yLnRvdGFsQnl0ZXNTbmFwc2hvdCkpLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5uZXdCeXRlcz10aGlzLnN0YXRlLm51bUJ5dGVzLW4sdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld1RlbnNvcnM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzLWE7Zm9yKGxldCByIG9mIHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5rZXJuZWxzKXIua2VybmVsVGltZU1zPWF3YWl0IHIua2VybmVsVGltZU1zLHIuZXh0cmFJbmZvPWF3YWl0IHIuZXh0cmFJbmZvO3JldHVybiB0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGV9aXNUYXBlT24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoPjAmJnRoaXMuc3RhdGUua2VybmVsRGVwdGg9PT0wfWFkZFRhcGVOb2RlKHQsbixhLHIscyxpKXtsZXQgbz17aWQ6dGhpcy5zdGF0ZS5uZXh0VGFwZU5vZGVJZCsrLGtlcm5lbE5hbWU6dCxpbnB1dHM6bixvdXRwdXRzOmEsc2F2ZWQ6c30sbD12eCh0KTtsIT1udWxsJiYocj1sLmdyYWRGdW5jKSxyIT1udWxsJiYoby5ncmFkaWVudD11PT4odT11Lm1hcCgocCxkKT0+e2lmKHA9PW51bGwpe2xldCBjPWFbZF0saD14bShjLnNpemUsYy5kdHlwZSk7cmV0dXJuIHRoaXMubWFrZVRlbnNvcihoLGMuc2hhcGUsYy5kdHlwZSl9cmV0dXJuIHB9KSxyKHUubGVuZ3RoPjE/dTp1WzBdLHMsaSkpKSx0aGlzLnN0YXRlLmFjdGl2ZVRhcGUucHVzaChvKX1rZWVwKHQpe3JldHVybiB0LmtlcHQ9ITAsdH1zdGFydFRhcGUoKXt0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGg9PT0wJiYodGhpcy5zdGF0ZS5hY3RpdmVUYXBlPVtdKSx0aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgrK31lbmRUYXBlKCl7dGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoLS19c3RhcnRTY29wZSh0KXtsZXQgbj17dHJhY2s6W10sbmFtZTpcInVubmFtZWQgc2NvcGVcIixpZDp0aGlzLnN0YXRlLm5leHRTY29wZUlkKyt9O3QmJihuLm5hbWU9dCksdGhpcy5zdGF0ZS5zY29wZVN0YWNrLnB1c2gobiksdGhpcy5zdGF0ZS5hY3RpdmVTY29wZT1ufWVuZFNjb3BlKHQpe2xldCBuPV92KHQpLGE9bmV3IFNldChuLm1hcChzPT5zLmlkKSk7Zm9yKGxldCBzPTA7czx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLmxlbmd0aDtzKyspe2xldCBpPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2tbc107IWkua2VwdCYmIWEuaGFzKGkuaWQpJiZpLmRpc3Bvc2UoKX1sZXQgcj10aGlzLnN0YXRlLnNjb3BlU3RhY2sucG9wKCk7dGhpcy5zdGF0ZS5hY3RpdmVTY29wZT10aGlzLnN0YXRlLnNjb3BlU3RhY2subGVuZ3RoPT09MD9udWxsOnRoaXMuc3RhdGUuc2NvcGVTdGFja1t0aGlzLnN0YXRlLnNjb3BlU3RhY2subGVuZ3RoLTFdLG4uZm9yRWFjaChzPT57IXMua2VwdCYmcy5zY29wZUlkPT09ci5pZCYmdGhpcy50cmFjayhzKX0pfWdyYWRpZW50cyh0LG4sYSxyPSExKXtpZihBKG4ubGVuZ3RoPjAsKCk9PlwiZ3JhZGllbnRzKCkgcmVjZWl2ZWQgYW4gZW1wdHkgbGlzdCBvZiB4cy5cIiksYSE9bnVsbCYmYS5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgZHkgbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnJHthLmR0eXBlfSdgKTtsZXQgcz10aGlzLnNjb3BlZFJ1bigoKT0+dGhpcy5zdGFydFRhcGUoKSwoKT0+dGhpcy5lbmRUYXBlKCksKCk9PnRoaXMudGlkeShcImZvcndhcmRcIix0KSk7QShzIGluc3RhbmNlb2YgQ2UsKCk9PlwiVGhlIHJlc3VsdCB5IHJldHVybmVkIGJ5IGYoKSBtdXN0IGJlIGEgdGVuc29yLlwiKTtsZXQgaT1GTSh0aGlzLnN0YXRlLmFjdGl2ZVRhcGUsbixzKTtpZighciYmaS5sZW5ndGg9PT0wJiZuLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlIHRoYXQgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4IHRvIHkuXCIpO3JldHVybiB0aGlzLnRpZHkoXCJiYWNrd2FyZFwiLCgpPT57bGV0IG89e307b1tzLmlkXT1hPT1udWxsP1ZNKHMuc2hhcGUpOmEsJE0obyxpLHU9PnRoaXMudGlkeSh1KSxVTSk7bGV0IGw9bi5tYXAodT0+b1t1LmlkXSk7cmV0dXJuIHRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aD09PTAmJih0aGlzLnN0YXRlLmFjdGl2ZVRhcGUuZm9yRWFjaCh1PT57Zm9yKGxldCBwIG9mIHUuc2F2ZWQpcC5kaXNwb3NlKCl9KSx0aGlzLnN0YXRlLmFjdGl2ZVRhcGU9bnVsbCkse3ZhbHVlOnMsZ3JhZHM6bH19KX1jdXN0b21HcmFkKHQpe3JldHVybiBBKHNzKHQpLCgpPT5cIlRoZSBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvbi5cIiksKC4uLm4pPT57QShuLmV2ZXJ5KG89Pm8gaW5zdGFuY2VvZiBDZSksKCk9PlwiVGhlIGFyZ3MgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikoeDEsIHgyLC4uLikgbXVzdCBhbGwgYmUgdGVuc29yc1wiKTtsZXQgYSxyPXt9O24uZm9yRWFjaCgobyxsKT0+e3JbbF09b30pO2xldCBzPShvLGwpPT4oYT10KC4uLm4sbCksQShhLnZhbHVlIGluc3RhbmNlb2YgQ2UsKCk9PlwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmoudmFsdWVgIGlzIGEgdGVuc29yXCIpLEEoc3MoYS5ncmFkRnVuYyksKCk9PlwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24uXCIpLGEudmFsdWUpLGk9KG8sbCk9PntsZXQgdT1hLmdyYWRGdW5jKG8sbCkscD1BcnJheS5pc0FycmF5KHUpP3U6W3VdO0EocC5sZW5ndGg9PT1uLmxlbmd0aCwoKT0+XCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNhbWUgbnVtYmVyIG9mIHRlbnNvcnMgYXMgaW5wdXRzIHBhc3NlZCB0byBmKC4uLikuXCIpLEEocC5ldmVyeShjPT5jIGluc3RhbmNlb2YgQ2UpLCgpPT5cIlRoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2Ygb25seSB0ZW5zb3JzLlwiKTtsZXQgZD17fTtyZXR1cm4gcC5mb3JFYWNoKChjLGgpPT57ZFtoXT0oKT0+Y30pLGR9O3JldHVybiB0aGlzLnJ1bktlcm5lbEZ1bmMoe2ZvcndhcmRGdW5jOnMsYmFja3dhcmRzRnVuYzppLGlucHV0czpyfSl9fXJlYWRTeW5jKHQpe3JldHVybiB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQucmVhZFN5bmModCl9cmVhZCh0KXtyZXR1cm4gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWQodCl9cmVhZFRvR1BVKHQsbil7cmV0dXJuIHRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodCkuYmFja2VuZC5yZWFkVG9HUFUodCxuKX1hc3luYyB0aW1lKHQpe2xldCBuPWdjKCksYT1hd2FpdCB0aGlzLmJhY2tlbmQudGltZSh0KTtyZXR1cm4gYS53YWxsTXM9Z2MoKS1uLGF9dHJhY2sodCl7cmV0dXJuIHRoaXMuc3RhdGUuYWN0aXZlU2NvcGUhPW51bGwmJih0LnNjb3BlSWQ9dGhpcy5zdGF0ZS5hY3RpdmVTY29wZS5pZCx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLnB1c2godCkpLHR9Z2V0IHJlZ2lzdGVyZWRWYXJpYWJsZXMoKXtyZXR1cm4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzfXJlc2V0KCl7dGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZCsrLHRoaXMuc3RhdGUuZGlzcG9zZSgpLHRoaXMuRU5WLnJlc2V0KCksdGhpcy5zdGF0ZT1uZXcgWWs7Zm9yKGxldCB0IGluIHRoaXMucmVnaXN0cnkpdGhpcy5kaXNwb3NlUmVnaXN0ZXJlZEtlcm5lbHModCksdGhpcy5yZWdpc3RyeVt0XS5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbdF07dGhpcy5iYWNrZW5kTmFtZT1udWxsLHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwsdGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbH19O0F2Lm5leHRUZW5zb3JJZD0wO0F2Lm5leHRWYXJpYWJsZUlkPTA7ZnVuY3Rpb24gVk0oZSl7bGV0IHQ9TnYob3QoZSksXCJmbG9hdDMyXCIpO3JldHVybiBQLm1ha2VUZW5zb3IodCxlLFwiZmxvYXQzMlwiKX1mdW5jdGlvbiBhTigpe2xldCBlPUdTKCk7aWYoZS5fdGZlbmdpbmU9PW51bGwpe2xldCB0PW5ldyBVUyhlKTtlLl90ZmVuZ2luZT1uZXcgQXYodCl9cmV0dXJuIHBNKGUuX3RmZW5naW5lLkVOViksT00oKCk9PmUuX3RmZW5naW5lKSxlLl90ZmVuZ2luZX12YXIgUD1hTigpO2Z1bmN0aW9uIFVNKGUsdCl7bGV0IG49e2E6ZSxiOnR9O3JldHVybiBQLnJ1bktlcm5lbCh2cyxuKX12YXIgYWQ9e307X2UoYWQse2lzQnJvd3NlcjooKT0+ck4saXNNb2JpbGU6KCk9PmpNLG1vY2tJc01vYmlsZTooKT0+SE19KTtmdW5jdGlvbiBHTSgpe3JldHVybiB0eXBlb2YgbmF2aWdhdG9yIT1cInVuZGVmaW5lZFwiJiZuYXZpZ2F0b3IhPW51bGx9dmFyIEV4O2Z1bmN0aW9uIEhNKGUpe0V4PWV9ZnVuY3Rpb24gak0oZSl7aWYoRXghPT12b2lkIDApcmV0dXJuIEV4O2lmKGV8fEdNKCkpe2lmKGV8fChlPW5hdmlnYXRvciksZS5wcm9kdWN0PT09XCJSZWFjdE5hdGl2ZVwiKXJldHVybiEwO2xldCB0PWUudXNlckFnZW50fHxlLnZlbmRvcnx8KHR5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCI/d2luZG93Lm9wZXJhOlwiXCIpO2lmKCF0KXtsZXQgbj1lO3JldHVybiBuLnVzZXJBZ2VudERhdGEmJm4udXNlckFnZW50RGF0YS5tb2JpbGV9cmV0dXJuLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QodCl8fC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pLnRlc3QodC5zdWJzdHIoMCw0KSl9cmV0dXJuITF9ZnVuY3Rpb24gck4oKXtyZXR1cm4gdHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIiYmd2luZG93LmRvY3VtZW50IT1udWxsfHx0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUhPVwidW5kZWZpbmVkXCJ9dmFyIFduPUcoKTtXbi5yZWdpc3RlckZsYWcoXCJERUJVR1wiLCgpPT4hMSxlPT57ZSYmY29uc29sZS53YXJuKFwiRGVidWdnaW5nIG1vZGUgaXMgT04uIFRoZSBvdXRwdXQgb2YgZXZlcnkgbWF0aCBjYWxsIHdpbGwgYmUgZG93bmxvYWRlZCB0byBDUFUgYW5kIGNoZWNrZWQgZm9yIE5hTnMuIFRoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLlwiKX0pO1duLnJlZ2lzdGVyRmxhZyhcIklTX0JST1dTRVJcIiwoKT0+ck4oKSk7V24ucmVnaXN0ZXJGbGFnKFwiSVNfTk9ERVwiLCgpPT50eXBlb2YgcHJvY2VzcyE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMhPVwidW5kZWZpbmVkXCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUhPVwidW5kZWZpbmVkXCIpO1duLnJlZ2lzdGVyRmxhZyhcIklTX0NIUk9NRVwiLCgpPT50eXBlb2YgbmF2aWdhdG9yIT1cInVuZGVmaW5lZFwiJiZuYXZpZ2F0b3IhPW51bGwmJm5hdmlnYXRvci51c2VyQWdlbnQhPW51bGwmJi9DaHJvbWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9Hb29nbGUgSW5jLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpKTtXbi5yZWdpc3RlckZsYWcoXCJJU19TQUZBUklcIiwoKT0+dHlwZW9mIG5hdmlnYXRvciE9XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yIT1udWxsJiZuYXZpZ2F0b3IudXNlckFnZW50IT1udWxsJiYvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvQXBwbGUvLnRlc3QobmF2aWdhdG9yLnZlbmRvcikpO1duLnJlZ2lzdGVyRmxhZyhcIlBST0RcIiwoKT0+ITEpO1duLnJlZ2lzdGVyRmxhZyhcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIiwoKT0+V24uZ2V0Qm9vbChcIkRFQlVHXCIpKTtXbi5yZWdpc3RlckZsYWcoXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIsKCk9PiEwKTtXbi5yZWdpc3RlckZsYWcoXCJJU19URVNUXCIsKCk9PiExKTtXbi5yZWdpc3RlckZsYWcoXCJDSEVDS19DT01QVVRBVElPTl9GT1JfRVJST1JTXCIsKCk9PlduLmdldEJvb2woXCJERUJVR1wiKSk7V24ucmVnaXN0ZXJGbGFnKFwiV1JBUF9UT19JTUFHRUJJVE1BUFwiLCgpPT4hMSk7V24ucmVnaXN0ZXJGbGFnKFwiQ0FOVkFTMkRfV0lMTF9SRUFEX0ZSRVFVRU5UTFlfRk9SX0dQVVwiLCgpPT4hMSk7V24ucmVnaXN0ZXJGbGFnKFwiVVNFX1NFVFRJTUVPVVRDVVNUT01cIiwoKT0+ITEpO2Z1bmN0aW9uIGxyKGUsdCl7bGV0IG49ZTtpZihlbihlKSlyZXR1cm4gdD09PVwic3RyaW5nXCI/W106W2UubGVuZ3RoXTtpZihRUyhlKSl7bGV0IHI9ZS5jaGFubmVsc3x8XCJSR0JBXCI7cmV0dXJuW2UuaGVpZ2h0LGUud2lkdGgqci5sZW5ndGhdfWVsc2UgaWYoZU4oZSkpcmV0dXJuW2UuYnVmZmVyLnNpemUvKHQ9PW51bGw/NDpVaCh0KSldO2lmKCFBcnJheS5pc0FycmF5KGUpKXJldHVybltdO2xldCBhPVtdO2Zvcig7QXJyYXkuaXNBcnJheShuKXx8ZW4obikmJnQhPT1cInN0cmluZ1wiOylhLnB1c2gobi5sZW5ndGgpLG49blswXTtyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmRygpLmdldEJvb2woXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIpJiZzTihlLGEsW10pLGF9ZnVuY3Rpb24gc04oZSx0LG4pe2lmKG49bnx8W10sIUFycmF5LmlzQXJyYXkoZSkmJiFlbihlKSl7QSh0Lmxlbmd0aD09PTAsKCk9PmBFbGVtZW50IGFyclske24uam9pbihcIl1bXCIpfV0gaXMgYSBwcmltaXRpdmUsIGJ1dCBzaG91bGQgYmUgYW4gYXJyYXkvVHlwZWRBcnJheSBvZiAke3RbMF19IGVsZW1lbnRzYCk7cmV0dXJufUEodC5sZW5ndGg+MCwoKT0+YEVsZW1lbnQgYXJyWyR7bi5qb2luKFwiXVtcIil9XSBzaG91bGQgYmUgYSBwcmltaXRpdmUsIGJ1dCBpcyBhbiBhcnJheSBvZiAke2UubGVuZ3RofSBlbGVtZW50c2ApLEEoZS5sZW5ndGg9PT10WzBdLCgpPT5gRWxlbWVudCBhcnJbJHtuLmpvaW4oXCJdW1wiKX1dIHNob3VsZCBoYXZlICR7dFswXX0gZWxlbWVudHMsIGJ1dCBoYXMgJHtlLmxlbmd0aH0gZWxlbWVudHNgKTtsZXQgYT10LnNsaWNlKDEpO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKXNOKGVbcl0sYSxuLmNvbmNhdChyKSl9ZnVuY3Rpb24gWmsoZSx0LG4sYSl7aWYoZSE9PVwic3RyaW5nX29yX251bWVyaWNcIil7aWYoZT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBkdHlwZSBjYW5ub3QgYmUgbnVsbC5cIik7aWYoZSE9PVwibnVtZXJpY1wiJiZlIT09dHx8ZT09PVwibnVtZXJpY1wiJiZ0PT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICcke259JyBwYXNzZWQgdG8gJyR7YX0nIG11c3QgYmUgJHtlfSB0ZW5zb3IsIGJ1dCBnb3QgJHt0fSB0ZW5zb3JgKX19ZnVuY3Rpb24gRShlLHQsbixhPVwibnVtZXJpY1wiKXtpZihlIGluc3RhbmNlb2YgUSgpKXJldHVybiBaayhhLGUuZHR5cGUsdCxuKSxlO2xldCByPSRjKGUpO2lmKHIhPT1cInN0cmluZ1wiJiZbXCJib29sXCIsXCJpbnQzMlwiLFwiZmxvYXQzMlwiXS5pbmRleE9mKGEpPj0wJiYocj1hKSxaayhhLHIsdCxuKSxlPT1udWxsfHwhZW4oZSkmJiFBcnJheS5pc0FycmF5KGUpJiZ0eXBlb2YgZSE9XCJudW1iZXJcIiYmdHlwZW9mIGUhPVwiYm9vbGVhblwiJiZ0eXBlb2YgZSE9XCJzdHJpbmdcIil7bGV0IG89ZT09bnVsbD9cIm51bGxcIjplLmNvbnN0cnVjdG9yLm5hbWU7dGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAnJHt0fScgcGFzc2VkIHRvICcke259JyBtdXN0IGJlIGEgVGVuc29yIG9yIFRlbnNvckxpa2UsIGJ1dCBnb3QgJyR7b30nYCl9bGV0IHM9bHIoZSxyKTshZW4oZSkmJiFBcnJheS5pc0FycmF5KGUpJiYoZT1bZV0pO2xldCBpPXIhPT1cInN0cmluZ1wiP1JtKGUscik6aXMoZSxbXSwhMCk7cmV0dXJuIFAubWFrZVRlbnNvcihpLHMscil9ZnVuY3Rpb24gYmMoZSx0LG4sYT1cIm51bWVyaWNcIil7aWYoIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IEVycm9yKGBBcmd1bWVudCAke3R9IHBhc3NlZCB0byAke259IG11c3QgYmUgYSBcXGBUZW5zb3JbXVxcYCBvciBcXGBUZW5zb3JMaWtlW11cXGBgKTtyZXR1cm4gZS5tYXAoKHIscyk9PkUocixgJHt0fVske3N9XWAsbixhKSl9dmFyIEZ2PVwiX19vcFwiO2Z1bmN0aW9uIEwoZSl7bGV0IHQ9T2JqZWN0LmtleXMoZSk7aWYodC5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5IChvcGVyYXRpb24gbmFtZSkgbWFwcGluZyB0byBhIGZ1bmN0aW9uLiBHb3QgYW4gb2JqZWN0IHdpdGggJHt0Lmxlbmd0aH0ga2V5cy5gKTtsZXQgbj10WzBdLGE9ZVtuXTtuLmVuZHNXaXRoKFwiX1wiKSYmKG49bi5zdWJzdHJpbmcoMCxuLmxlbmd0aC0xKSksbj1uK0Z2O2xldCByPSguLi5zKT0+e1Auc3RhcnRTY29wZShuKTt0cnl7bGV0IGk9YSguLi5zKTtyZXR1cm4gdm0oaSkmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksUC5lbmRTY29wZShpKSxpfWNhdGNoKGkpe3Rocm93IFAuZW5kU2NvcGUobnVsbCksaX19O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIm5hbWVcIix7dmFsdWU6bixjb25maWd1cmFibGU6ITB9KSxyfWZ1bmN0aW9uIHFNKGUsdCl7bGV0IG49RShlLFwicmVhbFwiLFwiY29tcGxleFwiKSxhPUUodCxcImltYWdcIixcImNvbXBsZXhcIik7Tm4obi5zaGFwZSxhLnNoYXBlLGByZWFsIGFuZCBpbWFnIHNoYXBlcywgJHtuLnNoYXBlfSBhbmQgJHthLnNoYXBlfSwgbXVzdCBtYXRjaCBpbiBjYWxsIHRvIHRmLmNvbXBsZXgoKS5gKTtsZXQgcj17cmVhbDpuLGltYWc6YX07cmV0dXJuIFAucnVuS2VybmVsKHdtLHIpfXZhciBfcj1MKHtjb21wbGV4XzpxTX0pO2Z1bmN0aW9uIFNzKGUsdCxuLGEpe2lmKGE9PW51bGwpYT0kYyhlKTtlbHNlIGlmKGE9PT1cImNvbXBsZXg2NFwiKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgYSBjb21wbGV4NjQgdGVuc29yIGRpcmVjdGx5LiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO2lmKGVOKGUpfHxRUyhlKSl7aWYoYSE9PVwiZmxvYXQzMlwiJiZhIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihgQ3JlYXRpbmcgdGVuc29yIGZyb20gR1BVIGRhdGEgb25seSBzdXBwb3J0cyAnZmxvYXQzMid8J2ludDMyJyBkdHlwZSwgd2hpbGUgdGhlIGR0eXBlIGlzICR7YX0uYCk7cmV0dXJuIFAuYmFja2VuZC5jcmVhdGVUZW5zb3JGcm9tR1BVRGF0YShlLHR8fG4sYSl9aWYoIWVuKGUpJiYhQXJyYXkuaXNBcnJheShlKSYmdHlwZW9mIGUhPVwibnVtYmVyXCImJnR5cGVvZiBlIT1cImJvb2xlYW5cIiYmdHlwZW9mIGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIHBhc3NlZCB0byB0ZW5zb3IodmFsdWVzKSBtdXN0IGJlIGEgbnVtYmVyL2Jvb2xlYW4vc3RyaW5nIG9yIGFuIGFycmF5IG9mIG51bWJlcnMvYm9vbGVhbnMvc3RyaW5ncywgb3IgYSBUeXBlZEFycmF5XCIpO2lmKHQhPW51bGwpe25hKHQpO2xldCByPW90KHQpLHM9b3Qobik7QShyPT09cywoKT0+YEJhc2VkIG9uIHRoZSBwcm92aWRlZCBzaGFwZSwgWyR7dH1dLCB0aGUgdGVuc29yIHNob3VsZCBoYXZlICR7cn0gdmFsdWVzIGJ1dCBoYXMgJHtzfWApO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7KytpKXtsZXQgbz1uW2ldLGw9aT09PW4ubGVuZ3RoLTE/byE9PW90KHQuc2xpY2UoaSkpOiEwO0EobltpXT09PXRbaV18fCFsLCgpPT5gRXJyb3IgY3JlYXRpbmcgYSBuZXcgVGVuc29yLiBJbmZlcnJlZCBzaGFwZSAoJHtufSkgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlICgke3R9KS4gYCl9fXJldHVybiFlbihlKSYmIUFycmF5LmlzQXJyYXkoZSkmJihlPVtlXSksdD10fHxuLGU9YSE9PVwic3RyaW5nXCI/Um0oZSxhKTppcyhlLFtdLCEwKSxQLm1ha2VUZW5zb3IoZSx0LGEpfWZ1bmN0aW9uIGJuKGUsdCxuKXtsZXQgYT1scihlLG4pO3JldHVybiBTcyhlLHQsYSxuKX12YXIgdWk9e2Zsb2F0MzI6NCxmbG9hdDE2OjIsaW50MzI6NCx1aW50MTY6Mix1aW50ODoxLGJvb2w6MSxjb21wbGV4NjQ6OH0sRnI9Y2xhc3MgaU57c3RhdGljIGpvaW4odCl7cmV0dXJuIG5ldyBpTih0KS5zbGljZSgpfWNvbnN0cnVjdG9yKHQpe2lmKHRoaXMuc2hhcmRzPVtdLHRoaXMucHJldmlvdXNTaGFyZEluZGV4PTAsdD09bnVsbHx8KHQgaW5zdGFuY2VvZiBBcnJheXx8KHQ9W3RdKSx0PXQubWFwKGE9PmVuKGEpP2EuYnVmZmVyOmEpLHQubGVuZ3RoPT09MCkpcmV0dXJuO3RoaXMuYnVmZmVyVW5pZm9ybVNpemU9dFswXS5ieXRlTGVuZ3RoO2xldCBuPTA7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2xldCByPXRbYV07YSE9PXQubGVuZ3RoLTEmJnIuYnl0ZUxlbmd0aCE9PXRoaXMuYnVmZmVyVW5pZm9ybVNpemUmJih0aGlzLmJ1ZmZlclVuaWZvcm1TaXplPXZvaWQgMCk7bGV0IHM9bityLmJ5dGVMZW5ndGg7dGhpcy5zaGFyZHMucHVzaCh7YnVmZmVyOnIsc3RhcnQ6bixlbmQ6c30pLG49c310aGlzLnNoYXJkcy5sZW5ndGg9PT0wJiYodGhpcy5ieXRlTGVuZ3RoPTApLHRoaXMuYnl0ZUxlbmd0aD10aGlzLnNoYXJkc1t0aGlzLnNoYXJkcy5sZW5ndGgtMV0uZW5kfXNsaWNlKHQ9MCxuPXRoaXMuYnl0ZUxlbmd0aCl7aWYodGhpcy5zaGFyZHMubGVuZ3RoPT09MClyZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO2lmKHQ9aXNOYU4oTnVtYmVyKHQpKT8wOnQsbj1pc05hTihOdW1iZXIobikpPzA6bix0PU1hdGgubWF4KDAsdCksbj1NYXRoLm1pbih0aGlzLmJ5dGVMZW5ndGgsbiksbjw9dClyZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO2xldCBhPXRoaXMuZmluZFNoYXJkRm9yQnl0ZSh0KTtpZihhPT09LTEpdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBzdGFydCBzaGFyZCBmb3IgYnl0ZSAke3R9YCk7bGV0IHI9bi10LHM9bmV3IEFycmF5QnVmZmVyKHIpLGk9bmV3IFVpbnQ4QXJyYXkocyksbz0wO2ZvcihsZXQgbD1hO2w8dGhpcy5zaGFyZHMubGVuZ3RoO2wrKyl7bGV0IHU9dGhpcy5zaGFyZHNbbF0scD10K28tdS5zdGFydCxkPW8sYz1NYXRoLm1pbihuLHUuZW5kKS11LnN0YXJ0LGg9bmV3IFVpbnQ4QXJyYXkodS5idWZmZXIscCxjLXApO2lmKGkuc2V0KGgsZCksbys9aC5sZW5ndGgsbjx1LmVuZClicmVha31yZXR1cm4gc31maW5kU2hhcmRGb3JCeXRlKHQpe2lmKHRoaXMuc2hhcmRzLmxlbmd0aD09PTB8fHQ8MHx8dD49dGhpcy5ieXRlTGVuZ3RoKXJldHVybi0xO2lmKHRoaXMuYnVmZmVyVW5pZm9ybVNpemUhPW51bGwpcmV0dXJuIHRoaXMucHJldmlvdXNTaGFyZEluZGV4PU1hdGguZmxvb3IodC90aGlzLmJ1ZmZlclVuaWZvcm1TaXplKSx0aGlzLnByZXZpb3VzU2hhcmRJbmRleDtmdW5jdGlvbiBuKHIpe3JldHVybiB0PHIuc3RhcnQ/LTE6dD49ci5lbmQ/MTowfWlmKG4odGhpcy5zaGFyZHNbdGhpcy5wcmV2aW91c1NoYXJkSW5kZXhdKT09PTApcmV0dXJuIHRoaXMucHJldmlvdXNTaGFyZEluZGV4O2xldCBhPUtNKHRoaXMuc2hhcmRzLG4pO3JldHVybiBhPT09LTE/LTE6KHRoaXMucHJldmlvdXNTaGFyZEluZGV4PWEsdGhpcy5wcmV2aW91c1NoYXJkSW5kZXgpfX07ZnVuY3Rpb24gS00oZSx0KXtsZXQgbj0wLGE9ZS5sZW5ndGg7Zm9yKDtuPD1hOyl7bGV0IHI9TWF0aC5mbG9vcigoYS1uKS8yKStuLHM9dChlW3JdKTtpZihzPT09MClyZXR1cm4gcjtzPDA/YT1yOm49cisxfXJldHVybi0xfWZ1bmN0aW9uIFhNKCl7RygpLnNldChcIlBST0RcIiwhMCl9ZnVuY3Rpb24gWU0oKXtHKCkuc2V0KFwiREVCVUdcIiwhMCl9ZnVuY3Rpb24gWk0oKXtHKCkuc2V0KFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiLCExKSxjb25zb2xlLndhcm4oXCJUZW5zb3JGbG93LmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzIGhhdmUgYmVlbiBkaXNhYmxlZC5cIil9ZnVuY3Rpb24gJHYoZSl7RygpLmdldEJvb2woXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIpJiZjb25zb2xlLndhcm4oZStcIiBZb3UgY2FuIGRpc2FibGUgZGVwcmVjYXRpb24gd2FybmluZ3Mgd2l0aCB0Zi5kaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5ncygpLlwiKX1MTSgkdik7ZnVuY3Rpb24gSk0oKXtQLmRpc3Bvc2VWYXJpYWJsZXMoKX1mdW5jdGlvbiBUYSgpe3JldHVybiBQfWZ1bmN0aW9uIEtoKCl7cmV0dXJuIFAubWVtb3J5KCl9ZnVuY3Rpb24gUU0oZSl7cmV0dXJuIFAucHJvZmlsZShlKX1mdW5jdGlvbiBPKGUsdCl7cmV0dXJuIFAudGlkeShlLHQpfWZ1bmN0aW9uIEVlKGUpe192KGUpLmZvckVhY2godD0+dC5kaXNwb3NlKCkpfWZ1bmN0aW9uIEh0KGUpe3JldHVybiBQLmtlZXAoZSl9ZnVuY3Rpb24gZU8oZSl7cmV0dXJuIFAudGltZShlKX1mdW5jdGlvbiB0TyhlKXtyZXR1cm4gUC5zZXRCYWNrZW5kKGUpfWZ1bmN0aW9uIG5PKCl7cmV0dXJuIFAucmVhZHkoKX1mdW5jdGlvbiBvTigpe3JldHVybiBQLmJhY2tlbmROYW1lfWZ1bmN0aW9uIGFPKGUpe1AucmVtb3ZlQmFja2VuZChlKX1mdW5jdGlvbiByTyhlKXtyZXR1cm4gUC5maW5kQmFja2VuZChlKX1mdW5jdGlvbiBzTyhlKXtyZXR1cm4gUC5maW5kQmFja2VuZEZhY3RvcnkoZSl9ZnVuY3Rpb24gT20oZSx0LG49MSl7cmV0dXJuIFAucmVnaXN0ZXJCYWNrZW5kKGUsdCxuKX1mdW5jdGlvbiBEdigpe3JldHVybiBQLmJhY2tlbmR9ZnVuY3Rpb24gaU8oZSx0KXtHKCkuc2V0UGxhdGZvcm0oZSx0KX12YXIgbHM9NDthc3luYyBmdW5jdGlvbiBvTyhlLHQpe2xldCBuPVtdLGE9W10scj1BcnJheS5pc0FycmF5KGUpP2UubWFwKGk9PmkubmFtZSk6T2JqZWN0LmtleXMoZSk7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDsrK2kpe2xldCBvPXJbaV0sbD1BcnJheS5pc0FycmF5KGUpP2VbaV0udGVuc29yOmVbb107aWYobC5kdHlwZSE9PVwiZmxvYXQzMlwiJiZsLmR0eXBlIT09XCJpbnQzMlwiJiZsLmR0eXBlIT09XCJib29sXCImJmwuZHR5cGUhPT1cInN0cmluZ1wiJiZsLmR0eXBlIT09XCJjb21wbGV4NjRcIil0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnJHtvfSc6ICR7bC5kdHlwZX1gKTtsZXQgdT17bmFtZTpvLHNoYXBlOmwuc2hhcGUsZHR5cGU6bC5kdHlwZX07aWYobC5kdHlwZT09PVwic3RyaW5nXCIpe2xldCBwPW5ldyBQcm9taXNlKGFzeW5jIGQ9PntsZXQgYz1hd2FpdCBsLmJ5dGVzKCksaD1jLnJlZHVjZSgoZyxiKT0+ZytiLmxlbmd0aCwwKStscypjLmxlbmd0aCxtPW5ldyBVaW50OEFycmF5KGgpLGY9MDtmb3IobGV0IGc9MDtnPGMubGVuZ3RoO2crKyl7bGV0IGI9Y1tnXSx5PW5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbYi5sZW5ndGhdKS5idWZmZXIpO20uc2V0KHksZiksZis9bHMsbS5zZXQoYixmKSxmKz1iLmxlbmd0aH1kKG0pfSk7YS5wdXNoKHApfWVsc2UgYS5wdXNoKGwuZGF0YSgpKTt0IT1udWxsJiYodS5ncm91cD10KSxuLnB1c2godSl9bGV0IHM9YXdhaXQgUHJvbWlzZS5hbGwoYSk7cmV0dXJue2RhdGE6cE8ocyksc3BlY3M6bn19ZnVuY3Rpb24gbE4oZSx0KXtsZXQgbj1uZXcgRnIoZSksYT17fSxyPTA7Zm9yKGxldCBzIG9mIHQpe2xldCBpPWxPKHMsKG8sbCk9Pm4uc2xpY2UocitvLHIrbCkpO2Fbcy5uYW1lXT11TihzLG4uc2xpY2UocixyK2kpKSxyKz1pfXJldHVybiBhfWZ1bmN0aW9uIGxPKGUsdCl7bGV0IG49b3QoZS5zaGFwZSksYTtpZihcInF1YW50aXphdGlvblwiaW4gZSl7bGV0IHI9ZS5xdWFudGl6YXRpb247YT11aVtyLmR0eXBlXX1lbHNlIGlmKGUuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgcj0wO2ZvcihsZXQgcz0wO3M8bjtzKyspcis9bHMrbmV3IFVpbnQzMkFycmF5KHQocixyK2xzKSlbMF07cmV0dXJuIHJ9ZWxzZSBhPXVpW2UuZHR5cGVdO3JldHVybiBuKmF9YXN5bmMgZnVuY3Rpb24gdU8oZSx0KXtsZXQgbj1vdChlLnNoYXBlKSxhO2lmKFwicXVhbnRpemF0aW9uXCJpbiBlKXtsZXQgcj1lLnF1YW50aXphdGlvbjthPXVpW3IuZHR5cGVdfWVsc2UgaWYoZS5kdHlwZT09PVwic3RyaW5nXCIpe2xldCByPTA7Zm9yKGxldCBzPTA7czxuO3MrKylyKz1scytuZXcgVWludDMyQXJyYXkoYXdhaXQgdChyLHIrbHMpKVswXTtyZXR1cm4gcn1lbHNlIGE9dWlbZS5kdHlwZV07cmV0dXJuIG4qYX1mdW5jdGlvbiB1TihlLHQpe2xldCBuPWUubmFtZSxhPWUuZHR5cGUscj1lLnNoYXBlLHM9b3QociksaSxvPTA7aWYoXCJxdWFudGl6YXRpb25cImluIGUpe2xldCBsPWUucXVhbnRpemF0aW9uO2lmKGwuZHR5cGU9PT1cInVpbnQ4XCJ8fGwuZHR5cGU9PT1cInVpbnQxNlwiKXtpZighKFwibWluXCJpbiBsJiZcInNjYWxlXCJpbiBsKSl0aHJvdyBuZXcgRXJyb3IoYFdlaWdodCAke2UubmFtZX0gd2l0aCBxdWFudGl6YXRpb24gJHtsLmR0eXBlfSBkb2Vzbid0IGhhdmUgY29ycmVzcG9uZGluZyBtZXRhZGF0YSBtaW4gYW5kIHNjYWxlLmApfWVsc2UgaWYobC5kdHlwZT09PVwiZmxvYXQxNlwiKXtpZihhIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKGBXZWlnaHQgJHtlLm5hbWV9IGlzIHF1YW50aXplZCB3aXRoICR7bC5kdHlwZX0gd2hpY2ggb25seSBzdXBwb3J0cyB3ZWlnaHRzIG9mIHR5cGUgZmxvYXQzMiBub3QgJHthfS5gKX1lbHNlIHRocm93IG5ldyBFcnJvcihgV2VpZ2h0ICR7ZS5uYW1lfSBoYXMgdW5rbm93biBxdWFudGl6YXRpb24gZHR5cGUgJHtsLmR0eXBlfS4gU3VwcG9ydGVkIHF1YW50aXphdGlvbiBkdHlwZXMgYXJlOiAndWludDgnLCAndWludDE2JywgYW5kICdmbG9hdDE2Jy5gKTtsZXQgdT11aVtsLmR0eXBlXSxwPWwuZHR5cGU9PT1cInVpbnQ4XCI/bmV3IFVpbnQ4QXJyYXkodCk6bmV3IFVpbnQxNkFycmF5KHQpO2lmKGE9PT1cImZsb2F0MzJcIilpZihsLmR0eXBlPT09XCJ1aW50OFwifHxsLmR0eXBlPT09XCJ1aW50MTZcIil7aT1uZXcgRmxvYXQzMkFycmF5KHAubGVuZ3RoKTtmb3IobGV0IGQ9MDtkPHAubGVuZ3RoO2QrKyl7bGV0IGM9cFtkXTtpW2RdPWMqbC5zY2FsZStsLm1pbn19ZWxzZSBpZihsLmR0eXBlPT09XCJmbG9hdDE2XCIpaT1iTygpKHApO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBxdWFudGl6YXRpb24gdHlwZSAke2wuZHR5cGV9IGZvciB3ZWlnaHQgdHlwZSBmbG9hdDMyLmApO2Vsc2UgaWYoYT09PVwiaW50MzJcIil7aWYobC5kdHlwZSE9PVwidWludDhcIiYmbC5kdHlwZSE9PVwidWludDE2XCIpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBxdWFudGl6YXRpb24gdHlwZSAke2wuZHR5cGV9IGZvciB3ZWlnaHQgdHlwZSBpbnQzMi5gKTtpPW5ldyBJbnQzMkFycmF5KHAubGVuZ3RoKTtmb3IobGV0IGQ9MDtkPHAubGVuZ3RoO2QrKyl7bGV0IGM9cFtkXTtpW2RdPU1hdGgucm91bmQoYypsLnNjYWxlK2wubWluKX19ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnJHtufSc6ICR7YX1gKTtvKz1zKnV9ZWxzZSBpZihhPT09XCJzdHJpbmdcIil7bGV0IGw9b3QoZS5zaGFwZSk7aT1bXTtmb3IobGV0IHU9MDt1PGw7dSsrKXtsZXQgcD1uZXcgVWludDMyQXJyYXkodC5zbGljZShvLG8rbHMpKVswXTtvKz1scztsZXQgZD1uZXcgVWludDhBcnJheSh0LnNsaWNlKG8sbytwKSk7aS5wdXNoKGQpLG8rPXB9fWVsc2V7bGV0IGw9dWlbYV07aWYoYT09PVwiZmxvYXQzMlwiKWk9bmV3IEZsb2F0MzJBcnJheSh0KTtlbHNlIGlmKGE9PT1cImludDMyXCIpaT1uZXcgSW50MzJBcnJheSh0KTtlbHNlIGlmKGE9PT1cImJvb2xcIilpPW5ldyBVaW50OEFycmF5KHQpO2Vsc2UgaWYoYT09PVwiY29tcGxleDY0XCIpe2k9bmV3IEZsb2F0MzJBcnJheSh0KTtsZXQgdT1uZXcgRmxvYXQzMkFycmF5KGkubGVuZ3RoLzIpLHA9bmV3IEZsb2F0MzJBcnJheShpLmxlbmd0aC8yKTtmb3IobGV0IG09MDttPHUubGVuZ3RoO20rKyl1W21dPWlbbSoyXSxwW21dPWlbbSoyKzFdO2xldCBkPWJuKHUscixcImZsb2F0MzJcIiksYz1ibihwLHIsXCJmbG9hdDMyXCIpLGg9X3IoZCxjKTtyZXR1cm4gZC5kaXNwb3NlKCksYy5kaXNwb3NlKCksaH1lbHNlIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZHR5cGUgaW4gd2VpZ2h0ICcke259JzogJHthfWApO28rPXMqbH1yZXR1cm4gYm4oaSxyLGEpfWFzeW5jIGZ1bmN0aW9uIEprKGUsdCxuKXtsZXQgYT1uZXcgVWludDhBcnJheSh0KTtmb3IoO2EuYnl0ZUxlbmd0aDxuOyl7bGV0e2RvbmU6cix2YWx1ZTpzfT1hd2FpdCBlLnJlYWQoKTtpZihyJiZzPT1udWxsKXtsZXQgbz1uLWEuYnl0ZUxlbmd0aDt0aHJvdyBuZXcgRXJyb3IoYFJlYWRlciBpcyBkb25lIGJ1dCAke299IGJ5dGVzIGFyZSBzdGlsbCBleHBlY3RlZGApfWxldCBpPW5ldyBVaW50OEFycmF5KGEubGVuZ3RoK3MuYnl0ZUxlbmd0aCk7aS5zZXQoYSwwKSxpLnNldChuZXcgVWludDhBcnJheShzKSxhLmxlbmd0aCksYT1pfXJldHVybiBhLmJ1ZmZlcn1hc3luYyBmdW5jdGlvbiBwTihlLHQpe2xldCBuPXt9LGE9ZS5nZXRSZWFkZXIoKSxyPW5ldyBBcnJheUJ1ZmZlcigwKTtmb3IobGV0IHMgb2YgdCl7bGV0IGk9YXdhaXQgdU8ocyxhc3luYyh1LHApPT4ocj1hd2FpdCBKayhhLHIscCksci5zbGljZSh1LHApKSk7cj1hd2FpdCBKayhhLHIsaSk7bGV0IG89ci5zbGljZSgwLGkpO3I9ci5zbGljZShpKTtsZXQgbD11TihzLG8pO2lmKG5bcy5uYW1lXT1sLG9OKCk9PT1cIndlYmdwdVwiKXtsZXQgdT1EdigpO1widXBsb2FkVG9HUFVcImluIHUmJm90KGwuc2hhcGUpPj1HKCkuZ2V0KFwiV0VCR1BVX0NQVV9IQU5ET0ZGX1NJWkVfVEhSRVNIT0xEXCIpJiZ1LnVwbG9hZFRvR1BVKGwuZGF0YUlkKX19cmV0dXJuIG59ZnVuY3Rpb24gcE8oZSl7aWYoZT09PW51bGwpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlucHV0IHZhbHVlOiAke0pTT04uc3RyaW5naWZ5KGUpfWApO2xldCB0PTAsbj1bXTtlLmZvckVhY2gocz0+e2lmKHQrPXMuYnl0ZUxlbmd0aCxuLnB1c2gocy5ieXRlTGVuZ3RoPT09cy5idWZmZXIuYnl0ZUxlbmd0aD9zOm5ldyBzLmNvbnN0cnVjdG9yKHMpKSwhKHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fHMgaW5zdGFuY2VvZiBJbnQzMkFycmF5fHxzIGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBUeXBlZEFycmF5IHN1YnR5cGU6ICR7cy5jb25zdHJ1Y3Rvci5uYW1lfWApfSk7bGV0IGE9bmV3IFVpbnQ4QXJyYXkodCkscj0wO3JldHVybiBuLmZvckVhY2gocz0+e2Euc2V0KG5ldyBVaW50OEFycmF5KHMuYnVmZmVyKSxyKSxyKz1zLmJ5dGVMZW5ndGh9KSxhLmJ1ZmZlcn12YXIgUnY9dHlwZW9mIEJ1ZmZlciE9XCJ1bmRlZmluZWRcIiYmKHR5cGVvZiBCbG9iPT1cInVuZGVmaW5lZFwifHx0eXBlb2YgYXRvYj09XCJ1bmRlZmluZWRcInx8dHlwZW9mIGJ0b2E9PVwidW5kZWZpbmVkXCIpO2Z1bmN0aW9uIFFrKGUpe3JldHVybiBSdj9CdWZmZXIuYnl0ZUxlbmd0aChlLFwidXRmOFwiKTpuZXcgQmxvYihbZV0pLnNpemV9ZnVuY3Rpb24gY08oZSl7aWYoUnYpcmV0dXJuIEJ1ZmZlci5mcm9tKGUpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO2xldCB0PW5ldyBVaW50OEFycmF5KGUpLG49XCJcIjtmb3IobGV0IGE9MCxyPXQubGVuZ3RoO2E8cjthKyspbis9U3RyaW5nLmZyb21DaGFyQ29kZSh0W2FdKTtyZXR1cm4gYnRvYShuKX1mdW5jdGlvbiBkTyhlKXtpZihSdil7bGV0IGE9QnVmZmVyLmZyb20oZSxcImJhc2U2NFwiKTtyZXR1cm4gYS5idWZmZXIuc2xpY2UoYS5ieXRlT2Zmc2V0LGEuYnl0ZU9mZnNldCthLmJ5dGVMZW5ndGgpfWxldCB0PWF0b2IoZSksbj1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDsrK2Epbi5zZXQoW3QuY2hhckNvZGVBdChhKV0sYSk7cmV0dXJuIG4uYnVmZmVyfWZ1bmN0aW9uIGhPKGUpe3JldHVybiBGci5qb2luKGUpfWZ1bmN0aW9uIGVJKGUpe2xldCB0PVwiL1wiO2ZvcihlPWUudHJpbSgpO2UuZW5kc1dpdGgodCk7KWU9ZS5zbGljZSgwLGUubGVuZ3RoLTEpO2xldCBuPWUuc3BsaXQodCk7cmV0dXJuIG5bbi5sZW5ndGgtMV19ZnVuY3Rpb24gY04oZSx0KXtsZXQgbj17bW9kZWxUb3BvbG9neTplLm1vZGVsVG9wb2xvZ3ksZm9ybWF0OmUuZm9ybWF0LGdlbmVyYXRlZEJ5OmUuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6ZS5jb252ZXJ0ZWRCeSx3ZWlnaHRzTWFuaWZlc3Q6dH07cmV0dXJuIGUuc2lnbmF0dXJlIT1udWxsJiYobi5zaWduYXR1cmU9ZS5zaWduYXR1cmUpLGUudXNlckRlZmluZWRNZXRhZGF0YSE9bnVsbCYmKG4udXNlckRlZmluZWRNZXRhZGF0YT1lLnVzZXJEZWZpbmVkTWV0YWRhdGEpLGUubW9kZWxJbml0aWFsaXplciE9bnVsbCYmKG4ubW9kZWxJbml0aWFsaXplcj1lLm1vZGVsSW5pdGlhbGl6ZXIpLGUuaW5pdGlhbGl6ZXJTaWduYXR1cmUhPW51bGwmJihuLmluaXRpYWxpemVyU2lnbmF0dXJlPWUuaW5pdGlhbGl6ZXJTaWduYXR1cmUpLGUudHJhaW5pbmdDb25maWchPW51bGwmJihuLnRyYWluaW5nQ29uZmlnPWUudHJhaW5pbmdDb25maWcpLG59ZnVuY3Rpb24gZE4oZSx0LG4pe2xldCBhPXttb2RlbFRvcG9sb2d5OmUubW9kZWxUb3BvbG9neSxmb3JtYXQ6ZS5mb3JtYXQsZ2VuZXJhdGVkQnk6ZS5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTplLmNvbnZlcnRlZEJ5fTtpZihlLnRyYWluaW5nQ29uZmlnIT1udWxsJiYoYS50cmFpbmluZ0NvbmZpZz1lLnRyYWluaW5nQ29uZmlnKSxlLndlaWdodHNNYW5pZmVzdCE9bnVsbCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwibW9kZWxKU09OIGhhcyB3ZWlnaHRzTWFuaWZlc3QgYnV0IHdlaWdodFNwZWNzIGlzIG51bGxcIik7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwibW9kZWxKU09OIGhhcyB3ZWlnaHRzTWFuaWZlc3QgYnV0IHdlaWdodERhdGEgaXMgbnVsbFwiKTthLndlaWdodFNwZWNzPXQsYS53ZWlnaHREYXRhPW59cmV0dXJuIGUuc2lnbmF0dXJlIT1udWxsJiYoYS5zaWduYXR1cmU9ZS5zaWduYXR1cmUpLGUudXNlckRlZmluZWRNZXRhZGF0YSE9bnVsbCYmKGEudXNlckRlZmluZWRNZXRhZGF0YT1lLnVzZXJEZWZpbmVkTWV0YWRhdGEpLGUubW9kZWxJbml0aWFsaXplciE9bnVsbCYmKGEubW9kZWxJbml0aWFsaXplcj1lLm1vZGVsSW5pdGlhbGl6ZXIpLGUuaW5pdGlhbGl6ZXJTaWduYXR1cmUhPW51bGwmJihhLmluaXRpYWxpemVyU2lnbmF0dXJlPWUuaW5pdGlhbGl6ZXJTaWduYXR1cmUpLGF9YXN5bmMgZnVuY3Rpb24gTXYoZSx0KXtsZXQgbixhO3JldHVybiBlLndlaWdodHNNYW5pZmVzdCE9bnVsbCYmKFtuLGFdPWF3YWl0IHQoZS53ZWlnaHRzTWFuaWZlc3QpKSxkTihlLG4sYSl9ZnVuY3Rpb24gcmQoZSl7aWYoZS5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgSlNPTiBtb2RlbCB0b3BvbG9neSwgcmVjZWl2ZWQgQXJyYXlCdWZmZXIuXCIpO3JldHVybntkYXRlU2F2ZWQ6bmV3IERhdGUsbW9kZWxUb3BvbG9neVR5cGU6XCJKU09OXCIsbW9kZWxUb3BvbG9neUJ5dGVzOmUubW9kZWxUb3BvbG9neT09bnVsbD8wOlFrKEpTT04uc3RyaW5naWZ5KGUubW9kZWxUb3BvbG9neSkpLHdlaWdodFNwZWNzQnl0ZXM6ZS53ZWlnaHRTcGVjcz09bnVsbD8wOlFrKEpTT04uc3RyaW5naWZ5KGUud2VpZ2h0U3BlY3MpKSx3ZWlnaHREYXRhQnl0ZXM6ZS53ZWlnaHREYXRhPT1udWxsPzA6bmV3IEZyKGUud2VpZ2h0RGF0YSkuYnl0ZUxlbmd0aH19ZnVuY3Rpb24gX3goZSl7bGV0IHQ9W107Zm9yKGxldCBuIG9mIGUpdC5wdXNoKC4uLm4ud2VpZ2h0cyk7cmV0dXJuIHR9ZnVuY3Rpb24gbU8oKXtsZXQgZT1uPT57bGV0IGE9bjw8MTMscj0wO2Zvcig7IShhJjgzODg2MDgpOylyLT04Mzg4NjA4LGE8PD0xO3JldHVybiBhJj0tODM4ODYwOSxyKz05NDc5MTI3MDQsYXxyfSx0PW5ldyBVaW50MzJBcnJheSgyMDQ4KTt0WzBdPTA7Zm9yKGxldCBuPTE7bjwxMDI0O24rKyl0W25dPWUobik7Zm9yKGxldCBuPTEwMjQ7bjwyMDQ4O24rKyl0W25dPTkzOTUyNDA5Nisobi0xMDI0PDwxMyk7cmV0dXJuIHR9ZnVuY3Rpb24gZk8oKXtsZXQgZT1uZXcgVWludDMyQXJyYXkoNjQpO2VbMF09MCxlWzMxXT0xMTk5NTcwOTQ0LGVbMzJdPTIxNDc0ODM2NDgsZVs2M109MzM0NzA1NDU5Mjtmb3IobGV0IHQ9MTt0PDMxO3QrKyllW3RdPXQ8PDIzO2ZvcihsZXQgdD0zMzt0PDYzO3QrKyllW3RdPTIxNDc0ODM2NDgrKHQtMzI8PDIzKTtyZXR1cm4gZX1mdW5jdGlvbiBnTygpe2xldCBlPW5ldyBVaW50MzJBcnJheSg2NCk7Zm9yKGxldCB0PTA7dDw2NDt0KyspZVt0XT0xMDI0O3JldHVybiBlWzBdPWVbMzJdPTAsZX1mdW5jdGlvbiBiTygpe2xldCBlPW1PKCksdD1mTygpLG49Z08oKTtyZXR1cm4gYT0+e2xldCByPW5ldyBBcnJheUJ1ZmZlcig0KmEubGVuZ3RoKSxzPW5ldyBVaW50MzJBcnJheShyKTtmb3IobGV0IGk9MDtpPGEubGVuZ3RoO2krKyl7bGV0IG89YVtpXSxsPWVbbltvPj4xMF0rKG8mMTAyMyldK3Rbbz4+MTBdO3NbaV09bH1yZXR1cm4gbmV3IEZsb2F0MzJBcnJheShyKX19dmFyIGdhPWNsYXNzIExhe2NvbnN0cnVjdG9yKCl7dGhpcy5zYXZlUm91dGVycz1bXSx0aGlzLmxvYWRSb3V0ZXJzPVtdfXN0YXRpYyBnZXRJbnN0YW5jZSgpe3JldHVybiBMYS5pbnN0YW5jZT09bnVsbCYmKExhLmluc3RhbmNlPW5ldyBMYSksTGEuaW5zdGFuY2V9c3RhdGljIHJlZ2lzdGVyU2F2ZVJvdXRlcih0KXtMYS5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzLnB1c2godCl9c3RhdGljIHJlZ2lzdGVyTG9hZFJvdXRlcih0KXtMYS5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzLnB1c2godCl9c3RhdGljIGdldFNhdmVIYW5kbGVycyh0KXtyZXR1cm4gTGEuZ2V0SGFuZGxlcnModCxcInNhdmVcIil9c3RhdGljIGdldExvYWRIYW5kbGVycyh0LG4pe3JldHVybiBMYS5nZXRIYW5kbGVycyh0LFwibG9hZFwiLG4pfXN0YXRpYyBnZXRIYW5kbGVycyh0LG4sYSl7bGV0IHI9W107cmV0dXJuKG49PT1cImxvYWRcIj9MYS5nZXRJbnN0YW5jZSgpLmxvYWRSb3V0ZXJzOkxhLmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnMpLmZvckVhY2gocz0+e2xldCBpPXModCxhKTtpIT09bnVsbCYmci5wdXNoKGkpfSkscn19LHlPPWU9PmdhLnJlZ2lzdGVyU2F2ZVJvdXRlcihlKSx4Tz1lPT5nYS5yZWdpc3RlckxvYWRSb3V0ZXIoZSksdk89ZT0+Z2EuZ2V0U2F2ZUhhbmRsZXJzKGUpLHdPPShlLHQpPT5nYS5nZXRMb2FkSGFuZGxlcnMoZSx0KSxBeD1cInRlbnNvcmZsb3dqc1wiLEZ4PTEsdGk9XCJtb2RlbHNfc3RvcmVcIixRcj1cIm1vZGVsX2luZm9fc3RvcmVcIjtmdW5jdGlvbiBoTigpe2lmKCFHKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIG9idGFpbiBJbmRleGVkREIgZmFjdG9yeSBiZWNhdXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50aXMgbm90IGEgd2ViIGJyb3dzZXIuXCIpO2xldCBlPXR5cGVvZiB3aW5kb3c9PVwidW5kZWZpbmVkXCI/c2VsZjp3aW5kb3csdD1lLmluZGV4ZWREQnx8ZS5tb3pJbmRleGVkREJ8fGUud2Via2l0SW5kZXhlZERCfHxlLm1zSW5kZXhlZERCfHxlLnNoaW1JbmRleGVkREI7aWYodD09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IEluZGV4ZWREQi5cIik7cmV0dXJuIHR9ZnVuY3Rpb24gJHgoZSl7bGV0IHQ9ZS5yZXN1bHQ7dC5jcmVhdGVPYmplY3RTdG9yZSh0aSx7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSksdC5jcmVhdGVPYmplY3RTdG9yZShRcix7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSl9dmFyIHBpPWNsYXNze2NvbnN0cnVjdG9yKGUpe2lmKHRoaXMuaW5kZXhlZERCPWhOKCksZT09bnVsbHx8IWUpdGhyb3cgbmV3IEVycm9yKFwiRm9yIEluZGV4ZWREQiwgbW9kZWxQYXRoIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIik7dGhpcy5tb2RlbFBhdGg9ZX1hc3luYyBzYXZlKGUpe2lmKGUubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7cmV0dXJuIHRoaXMuZGF0YWJhc2VBY3Rpb24odGhpcy5tb2RlbFBhdGgsZSl9YXN5bmMgbG9hZCgpe3JldHVybiB0aGlzLmRhdGFiYXNlQWN0aW9uKHRoaXMubW9kZWxQYXRoKX1kYXRhYmFzZUFjdGlvbihlLHQpe3JldHVybiBuZXcgUHJvbWlzZSgobixhKT0+e2xldCByPXRoaXMuaW5kZXhlZERCLm9wZW4oQXgsRngpO3Iub251cGdyYWRlbmVlZGVkPSgpPT4keChyKSxyLm9uc3VjY2Vzcz0oKT0+e2xldCBzPXIucmVzdWx0O2lmKHQ9PW51bGwpe2xldCBpPXMudHJhbnNhY3Rpb24odGksXCJyZWFkb25seVwiKSxvPWkub2JqZWN0U3RvcmUodGkpLmdldCh0aGlzLm1vZGVsUGF0aCk7by5vbnN1Y2Nlc3M9KCk9PntpZihvLnJlc3VsdD09bnVsbClyZXR1cm4gcy5jbG9zZSgpLGEobmV3IEVycm9yKGBDYW5ub3QgZmluZCBtb2RlbCB3aXRoIHBhdGggJyR7dGhpcy5tb2RlbFBhdGh9JyBpbiBJbmRleGVkREIuYCkpO24oby5yZXN1bHQubW9kZWxBcnRpZmFjdHMpfSxvLm9uZXJyb3I9bD0+KHMuY2xvc2UoKSxhKG8uZXJyb3IpKSxpLm9uY29tcGxldGU9KCk9PnMuY2xvc2UoKX1lbHNle3Qud2VpZ2h0RGF0YT1Gci5qb2luKHQud2VpZ2h0RGF0YSk7bGV0IGk9cmQodCksbz1zLnRyYW5zYWN0aW9uKFFyLFwicmVhZHdyaXRlXCIpLGw9by5vYmplY3RTdG9yZShRciksdTt0cnl7dT1sLnB1dCh7bW9kZWxQYXRoOnRoaXMubW9kZWxQYXRoLG1vZGVsQXJ0aWZhY3RzSW5mbzppfSl9Y2F0Y2goZCl7cmV0dXJuIGEoZCl9bGV0IHA7dS5vbnN1Y2Nlc3M9KCk9PntwPXMudHJhbnNhY3Rpb24odGksXCJyZWFkd3JpdGVcIik7bGV0IGQ9cC5vYmplY3RTdG9yZSh0aSksYzt0cnl7Yz1kLnB1dCh7bW9kZWxQYXRoOnRoaXMubW9kZWxQYXRoLG1vZGVsQXJ0aWZhY3RzOnQsbW9kZWxBcnRpZmFjdHNJbmZvOml9KX1jYXRjaChoKXtyZXR1cm4gYShoKX1jLm9uc3VjY2Vzcz0oKT0+bih7bW9kZWxBcnRpZmFjdHNJbmZvOml9KSxjLm9uZXJyb3I9aD0+e2w9by5vYmplY3RTdG9yZShRcik7bGV0IG09bC5kZWxldGUodGhpcy5tb2RlbFBhdGgpO20ub25zdWNjZXNzPSgpPT4ocy5jbG9zZSgpLGEoYy5lcnJvcikpLG0ub25lcnJvcj1mPT4ocy5jbG9zZSgpLGEoYy5lcnJvcikpfX0sdS5vbmVycm9yPWQ9PihzLmNsb3NlKCksYSh1LmVycm9yKSksby5vbmNvbXBsZXRlPSgpPT57cD09bnVsbD9zLmNsb3NlKCk6cC5vbmNvbXBsZXRlPSgpPT5zLmNsb3NlKCl9fX0sci5vbmVycm9yPXM9PmEoci5lcnJvcil9KX19O3BpLlVSTF9TQ0hFTUU9XCJpbmRleGVkZGI6Ly9cIjt2YXIgbU49ZT0+RygpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheShlKSYmZS5zdGFydHNXaXRoKHBpLlVSTF9TQ0hFTUUpP2tPKGUuc2xpY2UocGkuVVJMX1NDSEVNRS5sZW5ndGgpKTpudWxsO2dhLnJlZ2lzdGVyU2F2ZVJvdXRlcihtTik7Z2EucmVnaXN0ZXJMb2FkUm91dGVyKG1OKTtmdW5jdGlvbiBrTyhlKXtyZXR1cm4gbmV3IHBpKGUpfWZ1bmN0aW9uIElPKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgocGkuVVJMX1NDSEVNRSk/ZS5zbGljZShwaS5VUkxfU0NIRU1FLmxlbmd0aCk6ZX12YXIgU089Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmluZGV4ZWREQj1oTigpfWFzeW5jIGxpc3RNb2RlbHMoKXtyZXR1cm4gbmV3IFByb21pc2UoKGUsdCk9PntsZXQgbj10aGlzLmluZGV4ZWREQi5vcGVuKEF4LEZ4KTtuLm9udXBncmFkZW5lZWRlZD0oKT0+JHgobiksbi5vbnN1Y2Nlc3M9KCk9PntsZXQgYT1uLnJlc3VsdCxyPWEudHJhbnNhY3Rpb24oUXIsXCJyZWFkb25seVwiKSxzPXIub2JqZWN0U3RvcmUoUXIpLmdldEFsbCgpO3Mub25zdWNjZXNzPSgpPT57bGV0IGk9e307Zm9yKGxldCBvIG9mIHMucmVzdWx0KWlbby5tb2RlbFBhdGhdPW8ubW9kZWxBcnRpZmFjdHNJbmZvO2UoaSl9LHMub25lcnJvcj1pPT4oYS5jbG9zZSgpLHQocy5lcnJvcikpLHIub25jb21wbGV0ZT0oKT0+YS5jbG9zZSgpfSxuLm9uZXJyb3I9YT0+dChuLmVycm9yKX0pfWFzeW5jIHJlbW92ZU1vZGVsKGUpe3JldHVybiBlPUlPKGUpLG5ldyBQcm9taXNlKCh0LG4pPT57bGV0IGE9dGhpcy5pbmRleGVkREIub3BlbihBeCxGeCk7YS5vbnVwZ3JhZGVuZWVkZWQ9KCk9PiR4KGEpLGEub25zdWNjZXNzPSgpPT57bGV0IHI9YS5yZXN1bHQscz1yLnRyYW5zYWN0aW9uKFFyLFwicmVhZHdyaXRlXCIpLGk9cy5vYmplY3RTdG9yZShRciksbz1pLmdldChlKSxsO28ub25zdWNjZXNzPSgpPT57aWYoby5yZXN1bHQ9PW51bGwpcmV0dXJuIHIuY2xvc2UoKSxuKG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgbW9kZWwgd2l0aCBwYXRoICcke2V9JyBpbiBJbmRleGVkREIuYCkpO3tsZXQgdT1pLmRlbGV0ZShlKSxwPSgpPT57bD1yLnRyYW5zYWN0aW9uKHRpLFwicmVhZHdyaXRlXCIpO2xldCBkPWwub2JqZWN0U3RvcmUodGkpLmRlbGV0ZShlKTtkLm9uc3VjY2Vzcz0oKT0+dChvLnJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8pLGQub25lcnJvcj1jPT5uKG8uZXJyb3IpfTt1Lm9uc3VjY2Vzcz1wLHUub25lcnJvcj1kPT4ocCgpLHIuY2xvc2UoKSxuKG8uZXJyb3IpKX19LG8ub25lcnJvcj11PT4oci5jbG9zZSgpLG4oby5lcnJvcikpLHMub25jb21wbGV0ZT0oKT0+e2w9PW51bGw/ci5jbG9zZSgpOmwub25jb21wbGV0ZT0oKT0+ci5jbG9zZSgpfX0sYS5vbmVycm9yPXI9Pm4oYS5lcnJvcil9KX19LFRyPVwiL1wiLE5sPVwidGVuc29yZmxvd2pzX21vZGVsc1wiLGZOPVwiaW5mb1wiLE5PPVwibW9kZWxfdG9wb2xvZ3lcIixUTz1cIndlaWdodF9zcGVjc1wiLENPPVwid2VpZ2h0X2RhdGFcIixFTz1cIm1vZGVsX21ldGFkYXRhXCI7ZnVuY3Rpb24gZ04oZSl7cmV0dXJue2luZm86W05sLGUsZk5dLmpvaW4oVHIpLHRvcG9sb2d5OltObCxlLE5PXS5qb2luKFRyKSx3ZWlnaHRTcGVjczpbTmwsZSxUT10uam9pbihUciksd2VpZ2h0RGF0YTpbTmwsZSxDT10uam9pbihUciksbW9kZWxNZXRhZGF0YTpbTmwsZSxFT10uam9pbihUcil9fWZ1bmN0aW9uIGJOKGUpe2ZvcihsZXQgdCBvZiBPYmplY3QudmFsdWVzKGUpKXdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0KX1mdW5jdGlvbiBfTyhlKXtsZXQgdD1lLnNwbGl0KFRyKTtpZih0Lmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXkgZm9ybWF0OiAke2V9YCk7cmV0dXJuIHQuc2xpY2UoMSx0Lmxlbmd0aC0xKS5qb2luKFRyKX1mdW5jdGlvbiBBTyhlKXtyZXR1cm4gZS5zdGFydHNXaXRoKGNpLlVSTF9TQ0hFTUUpP2Uuc2xpY2UoY2kuVVJMX1NDSEVNRS5sZW5ndGgpOmV9dmFyIGNpPWNsYXNze2NvbnN0cnVjdG9yKGUpe2lmKCFHKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIil8fHR5cGVvZiB3aW5kb3c9PVwidW5kZWZpbmVkXCJ8fHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlPT1cInVuZGVmaW5lZFwiKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgbG9jYWwgc3RvcmFnZS5cIik7aWYodGhpcy5MUz13aW5kb3cubG9jYWxTdG9yYWdlLGU9PW51bGx8fCFlKXRocm93IG5ldyBFcnJvcihcIkZvciBsb2NhbCBzdG9yYWdlLCBtb2RlbFBhdGggbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkIG9yIGVtcHR5LlwiKTt0aGlzLm1vZGVsUGF0aD1lLHRoaXMua2V5cz1nTih0aGlzLm1vZGVsUGF0aCl9YXN5bmMgc2F2ZShlKXtpZihlLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlLnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3tsZXQgdD1KU09OLnN0cmluZ2lmeShlLm1vZGVsVG9wb2xvZ3kpLG49SlNPTi5zdHJpbmdpZnkoZS53ZWlnaHRTcGVjcyksYT1yZChlKSxyPUZyLmpvaW4oZS53ZWlnaHREYXRhKTt0cnl7dGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy5pbmZvLEpTT04uc3RyaW5naWZ5KGEpKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5LHQpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MsbiksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy53ZWlnaHREYXRhLGNPKHIpKTtsZXQgcz17Zm9ybWF0OmUuZm9ybWF0LGdlbmVyYXRlZEJ5OmUuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6ZS5jb252ZXJ0ZWRCeSxzaWduYXR1cmU6ZS5zaWduYXR1cmUhPW51bGw/ZS5zaWduYXR1cmU6dm9pZCAwLHVzZXJEZWZpbmVkTWV0YWRhdGE6ZS51c2VyRGVmaW5lZE1ldGFkYXRhIT1udWxsP2UudXNlckRlZmluZWRNZXRhZGF0YTp2b2lkIDAsbW9kZWxJbml0aWFsaXplcjplLm1vZGVsSW5pdGlhbGl6ZXIhPW51bGw/ZS5tb2RlbEluaXRpYWxpemVyOnZvaWQgMCxpbml0aWFsaXplclNpZ25hdHVyZTplLmluaXRpYWxpemVyU2lnbmF0dXJlIT1udWxsP2UuaW5pdGlhbGl6ZXJTaWduYXR1cmU6dm9pZCAwLHRyYWluaW5nQ29uZmlnOmUudHJhaW5pbmdDb25maWchPW51bGw/ZS50cmFpbmluZ0NvbmZpZzp2b2lkIDB9O3JldHVybiB0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEsSlNPTi5zdHJpbmdpZnkocykpLHttb2RlbEFydGlmYWN0c0luZm86YX19Y2F0Y2gocyl7dGhyb3cgYk4odGhpcy5rZXlzKSxuZXcgRXJyb3IoYEZhaWxlZCB0byBzYXZlIG1vZGVsICcke3RoaXMubW9kZWxQYXRofScgdG8gbG9jYWwgc3RvcmFnZTogc2l6ZSBxdW90YSBiZWluZyBleGNlZWRlZCBpcyBhIHBvc3NpYmxlIGNhdXNlIG9mIHRoaXMgZmFpbHVyZTogbW9kZWxUb3BvbG9neUJ5dGVzPSR7YS5tb2RlbFRvcG9sb2d5Qnl0ZXN9LCB3ZWlnaHRTcGVjc0J5dGVzPSR7YS53ZWlnaHRTcGVjc0J5dGVzfSwgd2VpZ2h0RGF0YUJ5dGVzPSR7YS53ZWlnaHREYXRhQnl0ZXN9LmApfX19YXN5bmMgbG9hZCgpe2xldCBlPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5pbmZvKSk7aWYoZT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYEluIGxvY2FsIHN0b3JhZ2UsIHRoZXJlIGlzIG5vIG1vZGVsIHdpdGggbmFtZSAnJHt0aGlzLm1vZGVsUGF0aH0nYCk7aWYoZS5tb2RlbFRvcG9sb2d5VHlwZSE9PVwiSlNPTlwiKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2UgZG9lcyBub3Qgc3VwcG9ydCBsb2FkaW5nIG5vbi1KU09OIG1vZGVsIHRvcG9sb2d5IHlldC5cIik7bGV0IHQ9e30sbj1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpKTtpZihuPT1udWxsKXRocm93IG5ldyBFcnJvcihgSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHRvcG9sb2d5IG9mIG1vZGVsICcke3RoaXMubW9kZWxQYXRofScgaXMgbWlzc2luZy5gKTt0Lm1vZGVsVG9wb2xvZ3k9bjtsZXQgYT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MpKTtpZihhPT1udWxsKXRocm93IG5ldyBFcnJvcihgSW4gbG9jYWwgc3RvcmFnZSwgdGhlIHdlaWdodCBzcGVjcyBvZiBtb2RlbCAnJHt0aGlzLm1vZGVsUGF0aH0nIGFyZSBtaXNzaW5nLmApO3Qud2VpZ2h0U3BlY3M9YTtsZXQgcj10aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEpO2lmKHIhPW51bGwpe2xldCBpPUpTT04ucGFyc2Uocik7dC5mb3JtYXQ9aS5mb3JtYXQsdC5nZW5lcmF0ZWRCeT1pLmdlbmVyYXRlZEJ5LHQuY29udmVydGVkQnk9aS5jb252ZXJ0ZWRCeSxpLnNpZ25hdHVyZSE9bnVsbCYmKHQuc2lnbmF0dXJlPWkuc2lnbmF0dXJlKSxpLnVzZXJEZWZpbmVkTWV0YWRhdGEhPW51bGwmJih0LnVzZXJEZWZpbmVkTWV0YWRhdGE9aS51c2VyRGVmaW5lZE1ldGFkYXRhKSxpLm1vZGVsSW5pdGlhbGl6ZXIhPW51bGwmJih0Lm1vZGVsSW5pdGlhbGl6ZXI9aS5tb2RlbEluaXRpYWxpemVyKSxpLmluaXRpYWxpemVyU2lnbmF0dXJlIT1udWxsJiYodC5pbml0aWFsaXplclNpZ25hdHVyZT1pLmluaXRpYWxpemVyU2lnbmF0dXJlKSxpLnRyYWluaW5nQ29uZmlnIT1udWxsJiYodC50cmFpbmluZ0NvbmZpZz1pLnRyYWluaW5nQ29uZmlnKX1sZXQgcz10aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLndlaWdodERhdGEpO2lmKHM9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBJbiBsb2NhbCBzdG9yYWdlLCB0aGUgYmluYXJ5IHdlaWdodCB2YWx1ZXMgb2YgbW9kZWwgJyR7dGhpcy5tb2RlbFBhdGh9JyBhcmUgbWlzc2luZy5gKTtyZXR1cm4gdC53ZWlnaHREYXRhPWRPKHMpLHR9fTtjaS5VUkxfU0NIRU1FPVwibG9jYWxzdG9yYWdlOi8vXCI7dmFyIHlOPWU9PkcoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkoZSkmJmUuc3RhcnRzV2l0aChjaS5VUkxfU0NIRU1FKT9GTyhlLnNsaWNlKGNpLlVSTF9TQ0hFTUUubGVuZ3RoKSk6bnVsbDtnYS5yZWdpc3RlclNhdmVSb3V0ZXIoeU4pO2dhLnJlZ2lzdGVyTG9hZFJvdXRlcih5Tik7ZnVuY3Rpb24gRk8oZSl7cmV0dXJuIG5ldyBjaShlKX12YXIgJE89Y2xhc3N7Y29uc3RydWN0b3IoKXtBKEcoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSwoKT0+XCJDdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIHdlYiBicm93c2VyXCIpLEEodHlwZW9mIHdpbmRvdz09XCJ1bmRlZmluZWRcInx8dHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UhPVwidW5kZWZpbmVkXCIsKCk9PlwiQ3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IGxvY2FsU3RvcmFnZVwiKSx0aGlzLkxTPXdpbmRvdy5sb2NhbFN0b3JhZ2V9YXN5bmMgbGlzdE1vZGVscygpe2xldCBlPXt9LHQ9TmwrVHIsbj1UcitmTjtmb3IobGV0IGE9MDthPHRoaXMuTFMubGVuZ3RoOysrYSl7bGV0IHI9dGhpcy5MUy5rZXkoYSk7aWYoci5zdGFydHNXaXRoKHQpJiZyLmVuZHNXaXRoKG4pKXtsZXQgcz1fTyhyKTtlW3NdPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHIpKX19cmV0dXJuIGV9YXN5bmMgcmVtb3ZlTW9kZWwoZSl7ZT1BTyhlKTtsZXQgdD1nTihlKTtpZih0aGlzLkxTLmdldEl0ZW0odC5pbmZvKT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kIG1vZGVsIGF0IHBhdGggJyR7ZX0nYCk7bGV0IG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odC5pbmZvKSk7cmV0dXJuIGJOKHQpLG59fSxfbD1cIjovL1wiLHVzPWNsYXNzIHFye2NvbnN0cnVjdG9yKCl7dGhpcy5tYW5hZ2Vycz17fX1zdGF0aWMgZ2V0SW5zdGFuY2UoKXtyZXR1cm4gcXIuaW5zdGFuY2U9PW51bGwmJihxci5pbnN0YW5jZT1uZXcgcXIpLHFyLmluc3RhbmNlfXN0YXRpYyByZWdpc3Rlck1hbmFnZXIodCxuKXtBKHQhPW51bGwsKCk9Plwic2NoZW1lIG11c3Qgbm90IGJlIHVuZGVmaW5lZCBvciBudWxsLlwiKSx0LmVuZHNXaXRoKF9sKSYmKHQ9dC5zbGljZSgwLHQuaW5kZXhPZihfbCkpKSxBKHQubGVuZ3RoPjAsKCk9Plwic2NoZW1lIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZy5cIik7bGV0IGE9cXIuZ2V0SW5zdGFuY2UoKTtBKGEubWFuYWdlcnNbdF09PW51bGwsKCk9PmBBIG1vZGVsIHN0b3JlIG1hbmFnZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBzY2hlbWUgJyR7dH0nLmApLGEubWFuYWdlcnNbdF09bn1zdGF0aWMgZ2V0TWFuYWdlcih0KXtsZXQgbj1xci5nZXRJbnN0YW5jZSgpLm1hbmFnZXJzW3RdO2lmKG49PW51bGwpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBtb2RlbCBtYW5hZ2VyIGZvciBzY2hlbWUgJyR7dH0nYCk7cmV0dXJuIG59c3RhdGljIGdldFNjaGVtZXMoKXtyZXR1cm4gT2JqZWN0LmtleXMocXIuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vycyl9fTtmdW5jdGlvbiBSaChlKXtpZihlLmluZGV4T2YoX2wpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBUaGUgdXJsIHN0cmluZyBwcm92aWRlZCBkb2VzIG5vdCBjb250YWluIGEgc2NoZW1lLiBTdXBwb3J0ZWQgc2NoZW1lcyBhcmU6ICR7dXMuZ2V0U2NoZW1lcygpLmpvaW4oXCIsXCIpfWApO3JldHVybntzY2hlbWU6ZS5zcGxpdChfbClbMF0scGF0aDplLnNwbGl0KF9sKVsxXX19YXN5bmMgZnVuY3Rpb24geE4oZSx0LG49ITEpe0EoZSE9PXQsKCk9PmBPbGQgcGF0aCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lOiAnJHtlfSdgKTtsZXQgYT1nYS5nZXRMb2FkSGFuZGxlcnMoZSk7QShhLmxlbmd0aD4wLCgpPT5gQ29weWluZyBmYWlsZWQgYmVjYXVzZSBubyBsb2FkIGhhbmRsZXIgaXMgZm91bmQgZm9yIHNvdXJjZSBVUkwgJHtlfS5gKSxBKGEubGVuZ3RoPDIsKCk9PmBDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG1vcmUgdGhhbiBvbmUgKCR7YS5sZW5ndGh9KSBsb2FkIGhhbmRsZXJzIGZvciBzb3VyY2UgVVJMICR7ZX0uYCk7bGV0IHI9YVswXSxzPWdhLmdldFNhdmVIYW5kbGVycyh0KTtBKHMubGVuZ3RoPjAsKCk9PmBDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIHNhdmUgaGFuZGxlciBpcyBmb3VuZCBmb3IgZGVzdGluYXRpb24gVVJMICR7dH0uYCksQShzLmxlbmd0aDwyLCgpPT5gQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lICgke2EubGVuZ3RofSkgc2F2ZSBoYW5kbGVycyBmb3IgZGVzdGluYXRpb24gVVJMICR7dH0uYCk7bGV0IGk9c1swXSxvPVJoKGUpLnNjaGVtZSxsPVJoKGUpLnBhdGgsdT1vPT09UmgoZSkuc2NoZW1lLHA9YXdhaXQgci5sb2FkKCk7biYmdSYmYXdhaXQgdXMuZ2V0TWFuYWdlcihvKS5yZW1vdmVNb2RlbChsKTtsZXQgZD1hd2FpdCBpLnNhdmUocCk7cmV0dXJuIG4mJiF1JiZhd2FpdCB1cy5nZXRNYW5hZ2VyKG8pLnJlbW92ZU1vZGVsKGwpLGQubW9kZWxBcnRpZmFjdHNJbmZvfWFzeW5jIGZ1bmN0aW9uIERPKCl7bGV0IGU9dXMuZ2V0U2NoZW1lcygpLHQ9e307Zm9yKGxldCBuIG9mIGUpe2xldCBhPWF3YWl0IHVzLmdldE1hbmFnZXIobikubGlzdE1vZGVscygpO2ZvcihsZXQgciBpbiBhKXtsZXQgcz1uK19sK3I7dFtzXT1hW3JdfX1yZXR1cm4gdH1hc3luYyBmdW5jdGlvbiBSTyhlKXtsZXQgdD1SaChlKTtyZXR1cm4gdXMuZ2V0TWFuYWdlcih0LnNjaGVtZSkucmVtb3ZlTW9kZWwodC5wYXRoKX1hc3luYyBmdW5jdGlvbiBNTyhlLHQpe3JldHVybiB4TihlLHQsITEpfWFzeW5jIGZ1bmN0aW9uIE9PKGUsdCl7cmV0dXJuIHhOKGUsdCwhMCl9dmFyIFBPPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5tZXNzYWdlTmFtZT1cInNldFRpbWVvdXRDdXN0b21cIix0aGlzLmZ1bmN0aW9uUmVmcz1bXSx0aGlzLmhhbmRsZWRNZXNzYWdlQ291bnQ9MCx0aGlzLmhhc0V2ZW50TGlzdGVuZXI9ITF9ZmV0Y2goZSx0KXtyZXR1cm4gZmV0Y2goZSx0KX1ub3coKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9ZW5jb2RlKGUsdCl7aWYodCE9PVwidXRmLThcIiYmdCE9PVwidXRmOFwiKXRocm93IG5ldyBFcnJvcihgQnJvd3NlcidzIGVuY29kZXIgb25seSBzdXBwb3J0cyB1dGYtOCwgYnV0IGdvdCAke3R9YCk7cmV0dXJuIHRoaXMudGV4dEVuY29kZXI9PW51bGwmJih0aGlzLnRleHRFbmNvZGVyPW5ldyBUZXh0RW5jb2RlciksdGhpcy50ZXh0RW5jb2Rlci5lbmNvZGUoZSl9ZGVjb2RlKGUsdCl7cmV0dXJuIG5ldyBUZXh0RGVjb2Rlcih0KS5kZWNvZGUoZSl9c2V0VGltZW91dEN1c3RvbShlLHQpe2lmKHR5cGVvZiB3aW5kb3c9PVwidW5kZWZpbmVkXCJ8fCFHKCkuZ2V0Qm9vbChcIlVTRV9TRVRUSU1FT1VUQ1VTVE9NXCIpKXtzZXRUaW1lb3V0KGUsdCk7cmV0dXJufXRoaXMuZnVuY3Rpb25SZWZzLnB1c2goZSksc2V0VGltZW91dCgoKT0+e3dpbmRvdy5wb3N0TWVzc2FnZSh7bmFtZTp0aGlzLm1lc3NhZ2VOYW1lLGluZGV4OnRoaXMuZnVuY3Rpb25SZWZzLmxlbmd0aC0xfSxcIipcIil9LHQpLHRoaXMuaGFzRXZlbnRMaXN0ZW5lcnx8KHRoaXMuaGFzRXZlbnRMaXN0ZW5lcj0hMCx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixuPT57aWYobi5zb3VyY2U9PT13aW5kb3cmJm4uZGF0YS5uYW1lPT09dGhpcy5tZXNzYWdlTmFtZSl7bi5zdG9wUHJvcGFnYXRpb24oKTtsZXQgYT10aGlzLmZ1bmN0aW9uUmVmc1tuLmRhdGEuaW5kZXhdO2EoKSx0aGlzLmhhbmRsZWRNZXNzYWdlQ291bnQrKyx0aGlzLmhhbmRsZWRNZXNzYWdlQ291bnQ9PT10aGlzLmZ1bmN0aW9uUmVmcy5sZW5ndGgmJih0aGlzLmZ1bmN0aW9uUmVmcz1bXSx0aGlzLmhhbmRsZWRNZXNzYWdlQ291bnQ9MCl9fSwhMCkpfWlzVHlwZWRBcnJheShlKXtyZXR1cm4gWFMoZSl9fTtpZihHKCkuZ2V0KFwiSVNfQlJPV1NFUlwiKSl7RygpLnNldFBsYXRmb3JtKFwiYnJvd3NlclwiLG5ldyBQTyk7dHJ5e3VzLnJlZ2lzdGVyTWFuYWdlcihjaS5VUkxfU0NIRU1FLG5ldyAkTyl9Y2F0Y2goZSl7fXRyeXt1cy5yZWdpc3Rlck1hbmFnZXIocGkuVVJMX1NDSEVNRSxuZXcgU08pfWNhdGNoKGUpe319dmFyIExPPXtpbXBvcnRGZXRjaDooKT0+X1IoKX0sb3gsek89Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnV0aWw9QVIoKSx0aGlzLnRleHRFbmNvZGVyPW5ldyB0aGlzLnV0aWwuVGV4dEVuY29kZXJ9ZmV0Y2goZSx0KXtyZXR1cm4gRygpLmdsb2JhbC5mZXRjaCE9bnVsbD9HKCkuZ2xvYmFsLmZldGNoKGUsdCk6KG94PT1udWxsJiYob3g9TE8uaW1wb3J0RmV0Y2goKSksb3goZSx0KSl9bm93KCl7bGV0IGU9cHJvY2Vzcy5ocnRpbWUoKTtyZXR1cm4gZVswXSoxZTMrZVsxXS8xZTZ9ZW5jb2RlKGUsdCl7aWYodCE9PVwidXRmLThcIiYmdCE9PVwidXRmOFwiKXRocm93IG5ldyBFcnJvcihgTm9kZSBidWlsdC1pbiBlbmNvZGVyIG9ubHkgc3VwcG9ydHMgdXRmLTgsIGJ1dCBnb3QgJHt0fWApO3JldHVybiB0aGlzLnRleHRFbmNvZGVyLmVuY29kZShlKX1kZWNvZGUoZSx0KXtyZXR1cm4gZS5sZW5ndGg9PT0wP1wiXCI6bmV3IHRoaXMudXRpbC5UZXh0RGVjb2Rlcih0KS5kZWNvZGUoZSl9aXNUeXBlZEFycmF5KGUpe3JldHVybiB0aGlzLnV0aWwudHlwZXMuaXNGbG9hdDMyQXJyYXkoZSl8fHRoaXMudXRpbC50eXBlcy5pc0ludDMyQXJyYXkoZSl8fHRoaXMudXRpbC50eXBlcy5pc1VpbnQ4QXJyYXkoZSl8fHRoaXMudXRpbC50eXBlcy5pc1VpbnQ4Q2xhbXBlZEFycmF5KGUpfX07RygpLmdldChcIklTX05PREVcIikmJiFHKCkuZ2V0KFwiSVNfQlJPV1NFUlwiKSYmRygpLnNldFBsYXRmb3JtKFwibm9kZVwiLG5ldyB6Tyk7ZnVuY3Rpb24gT2UoZSx0PVwiZmxvYXQzMlwiLG4pe3JldHVybiB0PXR8fFwiZmxvYXQzMlwiLG5hKGUpLG5ldyBXdChlLHQsbil9ZnVuY3Rpb24gV08oZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJjYXN0XCIpO2lmKCFMUyh0KSl0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjYXN0IHRvIHVua25vd24gZHR5cGUgJHt0fWApO2lmKHQ9PT1cInN0cmluZ1wiJiZuLmR0eXBlIT09XCJzdHJpbmdcInx8dCE9PVwic3RyaW5nXCImJm4uZHR5cGU9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIk9ubHkgc3RyaW5ncyBjYW4gYmUgY2FzdGVkIHRvIHN0cmluZ3NcIik7bGV0IGE9e3g6bn0scj17ZHR5cGU6dH07cmV0dXJuIFAucnVuS2VybmVsKE1pLGEscil9dmFyIHJlPUwoe2Nhc3RfOldPfSk7ZnVuY3Rpb24gQk8oZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiY2xvbmVcIixcInN0cmluZ19vcl9udW1lcmljXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoZW8sdCl9dmFyIHNyPUwoe2Nsb25lXzpCT30pO2Z1bmN0aW9uIE92KGUsdD0hMSl7Y29uc29sZS5sb2coZS50b1N0cmluZyh0KSl9YU4oKTt2YXIgVk89e2J1ZmZlcjpPZSxjYXN0OnJlLGNsb25lOnNyLHByaW50Ok92fTtQTShWTyk7ZnVuY3Rpb24gVU8oZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJhZGRcIiksYT1FKHQsXCJiXCIsXCJhZGRcIik7W24sYV09X3QobixhKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKHZzLHIpfXZhciBYPUwoe2FkZF86VU99KTtmdW5jdGlvbiBHTyhlLHQpe2xldCBuPUUoZSxcImFcIixcImZsb29yRGl2XCIpLGE9RSh0LFwiYlwiLFwiZmxvb3JEaXZcIik7W24sYV09X3QobixhKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKFppLHIpfXZhciBQbT1MKHtmbG9vckRpdl86R099KTtmdW5jdGlvbiBITyhlLHQpe2xldCBuPUUoZSxcImFcIixcImRpdlwiKSxhPUUodCxcImJcIixcImRpdlwiKTtpZihbbixhXT1fdChuLGEpLG4uZHR5cGU9PT1cImludDMyXCImJmEuZHR5cGU9PT1cImludDMyXCIpcmV0dXJuIFBtKG4sYSk7bGV0IHI9e2E6bixiOmF9LHM9e307cmV0dXJuIFAucnVuS2VybmVsKEhpLHIscyl9dmFyIGhlPUwoe2Rpdl86SE99KTtmdW5jdGlvbiBqTyhlLHQpe2xldCBuPUUoZSxcImFcIixcIm11bFwiKSxhPUUodCxcImJcIixcIm11bFwiKTtbbixhXT1fdChuLGEpO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwoYm8scil9dmFyIHo9TCh7bXVsXzpqT30pO2Z1bmN0aW9uIHFPKGUpe2xldCB0PUUoZSxcInhcIixcImFic1wiKTtpZih0LmR0eXBlPT09XCJjb21wbGV4NjRcIil7bGV0IG49e3g6dH07cmV0dXJuIFAucnVuS2VybmVsKE9jLG4pfWVsc2V7bGV0IG49e3g6dH07cmV0dXJuIFAucnVuS2VybmVsKFlsLG4pfX12YXIgTHQ9TCh7YWJzXzpxT30pO2Z1bmN0aW9uIEtPKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImFjb3NcIil9O3JldHVybiBQLnJ1bktlcm5lbChOaSx0KX12YXIgUHY9TCh7YWNvc186S099KTtmdW5jdGlvbiBYTyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJhY29zaFwiKX07cmV0dXJuIFAucnVuS2VybmVsKFRpLHQpfXZhciBMdj1MKHthY29zaF86WE99KTtmdW5jdGlvbiBZTyhlKXtBKEFycmF5LmlzQXJyYXkoZSksKCk9PlwiVGhlIGFyZ3VtZW50IHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBiZSBhIGxpc3Qgb2YgdGVuc29yc1wiKSxBKGUubGVuZ3RoPj0xLCgpPT5gTXVzdCBwYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuYWRkTigpLCBidXQgZ290ICR7ZS5sZW5ndGh9YCk7bGV0IHQ9ZS5tYXAoKHIscyk9PkUocixgdGVuc29ycyR7c31gLFwiYWRkTlwiKSksbj10WzBdO3QuZm9yRWFjaChyPT57aWYoci5kdHlwZSE9PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgZHR5cGVcIil9KSx0LmZvckVhY2gocj0+e2lmKCFBcihyLnNoYXBlLG4uc2hhcGUpKXRocm93IG5ldyBFcnJvcihcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byB0Zi5hZGROKCkgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpfSk7bGV0IGE9dDtyZXR1cm4gUC5ydW5LZXJuZWwoQ2ksYSl9dmFyIHZOPUwoe2FkZE5fOllPfSk7ZnVuY3Rpb24gWk8oZSx0PW51bGwsbj0hMSl7bGV0IGE9e3g6RShlLFwieFwiLFwiYWxsXCIsXCJib29sXCIpfSxyPXtheGlzOnQsa2VlcERpbXM6bn07cmV0dXJuIFAucnVuS2VybmVsKFpsLGEscil9dmFyIExtPUwoe2FsbF86Wk99KTtmdW5jdGlvbiBKTyhlLHQ9bnVsbCxuPSExKXtsZXQgYT17eDpFKGUsXCJ4XCIsXCJhbnlcIixcImJvb2xcIil9LHI9e2F4aXM6dCxrZWVwRGltczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoSmwsYSxyKX12YXIgeWM9TCh7YW55XzpKT30pO2Z1bmN0aW9uIFFPKGUsdD0wKXtsZXQgbj17eDpFKGUsXCJ4XCIsXCJhcmdNYXhcIil9LGE9e2F4aXM6dH07cmV0dXJuIFAucnVuS2VybmVsKFFsLG4sYSl9dmFyIGRpPUwoe2FyZ01heF86UU99KTtmdW5jdGlvbiBlUChlLHQ9MCl7bGV0IG49e3g6RShlLFwieFwiLFwiYXJnTWluXCIpfSxhPXtheGlzOnR9O3JldHVybiBQLnJ1bktlcm5lbChldSxuLGEpfXZhciB6dj1MKHthcmdNaW5fOmVQfSk7ZnVuY3Rpb24gdFAoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiYXNpblwiKX07cmV0dXJuIFAucnVuS2VybmVsKEVpLHQpfXZhciBXdj1MKHthc2luXzp0UH0pO2Z1bmN0aW9uIG5QKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImFzaW5oXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoX2ksdCl9dmFyIEJ2PUwoe2FzaW5oXzpuUH0pO2Z1bmN0aW9uIGFQKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImF0YW5cIil9O3JldHVybiBQLnJ1bktlcm5lbChBaSx0KX12YXIgVnY9TCh7YXRhbl86YVB9KTtmdW5jdGlvbiByUChlLHQpe2xldCBuPUUoZSxcImFcIixcImF0YW4yXCIpLGE9RSh0LFwiYlwiLFwiYXRhbjJcIik7W24sYV09X3QobixhKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKCRpLHIpfXZhciBVdj1MKHthdGFuMl86clB9KTtmdW5jdGlvbiBzUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJhdGFuaFwiKX07cmV0dXJuIFAucnVuS2VybmVsKEZpLHQpfXZhciBHdj1MKHthdGFuaF86c1B9KTtmdW5jdGlvbiBpUChlLHQsbixhLHI9XCJOSFdDXCIscyl7bGV0IGk9ZVszXSxvPVsuLi50LGldLGw9SU4ocik7cmV0dXJuIHNkKGUsbyxuLHMsYSxudWxsLG51bGwsbCl9ZnVuY3Rpb24gd04oZSx0LG4sYSxyLHMsaT1cImNoYW5uZWxzTGFzdFwiKXtsZXRbbyxsXT14Yyh0KSx1O2lmKGk9PT1cImNoYW5uZWxzTGFzdFwiKXU9W28sbCxlWzNdLGVbM11dO2Vsc2UgaWYoaT09PVwiY2hhbm5lbHNGaXJzdFwiKXU9W28sbCxlWzFdLGVbMV1dO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHtpfWApO3JldHVybiBzZChlLHUsbixhLHIscywhMSxpKX1mdW5jdGlvbiBvUChlLHQsbixhLHIscyxpPVwiTkRIV0NcIil7bGV0W28sbCx1XT1EeCh0KSxwLGQ7aWYoaT09PVwiTkRIV0NcIilkPVwiY2hhbm5lbHNMYXN0XCIscD1bbyxsLHUsZVs0XSxlWzRdXTtlbHNlIGlmKGk9PT1cIk5DREhXXCIpZD1cImNoYW5uZWxzRmlyc3RcIixwPVtvLGwsdSxlWzFdLGVbMV1dO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHtpfWApO3JldHVybiBrTihlLHAsbixhLHIsITEsZCxzKX1mdW5jdGlvbiBzZChlLHQsbixhLHIscyxpPSExLG89XCJjaGFubmVsc0xhc3RcIil7bGV0W2wsdSxwLGRdPVstMSwtMSwtMSwtMV07aWYobz09PVwiY2hhbm5lbHNMYXN0XCIpW2wsdSxwLGRdPWU7ZWxzZSBpZihvPT09XCJjaGFubmVsc0ZpcnN0XCIpW2wsZCx1LHBdPWU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YUZvcm1hdCAke299YCk7bGV0W2MsaCwsbV09dCxbZixnXT14YyhuKSxbYix5XT14YyhhKSx4PUFsKGMsYiksdj1BbChoLHkpLHtwYWRJbmZvOkksb3V0SGVpZ2h0Ok4sb3V0V2lkdGg6Q309cFAocix1LHAsZixnLHgsdixzLG8pLF89aT9tKmQ6bSxGO3JldHVybiBvPT09XCJjaGFubmVsc0ZpcnN0XCI/Rj1bbCxfLE4sQ106bz09PVwiY2hhbm5lbHNMYXN0XCImJihGPVtsLE4sQyxfXSkse2JhdGNoU2l6ZTpsLGRhdGFGb3JtYXQ6byxpbkhlaWdodDp1LGluV2lkdGg6cCxpbkNoYW5uZWxzOmQsb3V0SGVpZ2h0Ok4sb3V0V2lkdGg6QyxvdXRDaGFubmVsczpfLHBhZEluZm86SSxzdHJpZGVIZWlnaHQ6ZixzdHJpZGVXaWR0aDpnLGZpbHRlckhlaWdodDpjLGZpbHRlcldpZHRoOmgsZWZmZWN0aXZlRmlsdGVySGVpZ2h0OngsZWZmZWN0aXZlRmlsdGVyV2lkdGg6dixkaWxhdGlvbkhlaWdodDpiLGRpbGF0aW9uV2lkdGg6eSxpblNoYXBlOmUsb3V0U2hhcGU6RixmaWx0ZXJTaGFwZTp0fX1mdW5jdGlvbiBrTihlLHQsbixhLHIscz0hMSxpPVwiY2hhbm5lbHNMYXN0XCIsbyl7bGV0W2wsdSxwLGQsY109Wy0xLC0xLC0xLC0xLC0xXTtpZihpPT09XCJjaGFubmVsc0xhc3RcIilbbCx1LHAsZCxjXT1lO2Vsc2UgaWYoaT09PVwiY2hhbm5lbHNGaXJzdFwiKVtsLGMsdSxwLGRdPWU7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YUZvcm1hdCAke2l9YCk7bGV0W2gsbSxmLCxnXT10LFtiLHkseF09RHgobiksW3YsSSxOXT1EeChhKSxDPUFsKGgsdiksXz1BbChtLEkpLEY9QWwoZixOKSx7cGFkSW5mbzpELG91dERlcHRoOiQsb3V0SGVpZ2h0OlMsb3V0V2lkdGg6TX09Y1Aocix1LHAsZCxiLHkseCxDLF8sRixvKSxCPXM/ZypjOmcsVTtyZXR1cm4gaT09PVwiY2hhbm5lbHNGaXJzdFwiP1U9W2wsQiwkLFMsTV06aT09PVwiY2hhbm5lbHNMYXN0XCImJihVPVtsLCQsUyxNLEJdKSx7YmF0Y2hTaXplOmwsZGF0YUZvcm1hdDppLGluRGVwdGg6dSxpbkhlaWdodDpwLGluV2lkdGg6ZCxpbkNoYW5uZWxzOmMsb3V0RGVwdGg6JCxvdXRIZWlnaHQ6UyxvdXRXaWR0aDpNLG91dENoYW5uZWxzOkIscGFkSW5mbzpELHN0cmlkZURlcHRoOmIsc3RyaWRlSGVpZ2h0Onksc3RyaWRlV2lkdGg6eCxmaWx0ZXJEZXB0aDpoLGZpbHRlckhlaWdodDptLGZpbHRlcldpZHRoOmYsZWZmZWN0aXZlRmlsdGVyRGVwdGg6QyxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6XyxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpGLGRpbGF0aW9uRGVwdGg6dixkaWxhdGlvbkhlaWdodDpJLGRpbGF0aW9uV2lkdGg6TixpblNoYXBlOmUsb3V0U2hhcGU6VSxmaWx0ZXJTaGFwZTp0fX1mdW5jdGlvbiBsUChlLHQsbixhLHIpe2E9PW51bGwmJihhPUh2KGUsdCxuKSk7bGV0IHM9ZVswXSxpPWVbMV0sbz12Yygocy10KzIqYSkvbisxLHIpLGw9dmMoKGktdCsyKmEpL24rMSxyKTtyZXR1cm5bbyxsXX1mdW5jdGlvbiB1UChlLHQsbixhLHIscyl7cj09bnVsbCYmKHI9SHYoZSx0WzBdLGFbMF0pKTtsZXQgaT1bMCwwLDAsbl07Zm9yKGxldCBvPTA7bzwzO28rKyllW29dKzIqcj49dFtvXSYmKGlbb109dmMoKGVbb10tdFtvXSsyKnIpL2Fbb10rMSxzKSk7cmV0dXJuIGl9ZnVuY3Rpb24gSHYoZSx0LG4sYT0xKXtsZXQgcj1BbCh0LGEpO3JldHVybiBNYXRoLmZsb29yKChlWzBdKihuLTEpLW4rcikvMil9ZnVuY3Rpb24geGMoZSl7cmV0dXJuIHR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZS5sZW5ndGg9PT0yP1tlWzBdLGVbMV0sMV06ZX1mdW5jdGlvbiBEeChlKXtyZXR1cm4gdHlwZW9mIGU9PVwibnVtYmVyXCI/W2UsZSxlXTplfWZ1bmN0aW9uIEFsKGUsdCl7cmV0dXJuIHQ8PTE/ZTplKyhlLTEpKih0LTEpfWZ1bmN0aW9uIHBQKGUsdCxuLGEscixzLGksbyxsKXtsZXQgdSxwLGQ7aWYodHlwZW9mIGU9PVwibnVtYmVyXCIpe3U9e3RvcDplLGJvdHRvbTplLGxlZnQ6ZSxyaWdodDplLHR5cGU6ZT09PTA/XCJWQUxJRFwiOlwiTlVNQkVSXCJ9O2xldCBjPWxQKFt0LG5dLHMsYSxlLG8pO3A9Y1swXSxkPWNbMV19ZWxzZSBpZihlPT09XCJzYW1lXCIpe3A9TWF0aC5jZWlsKHQvYSksZD1NYXRoLmNlaWwobi9yKTtsZXQgYz1NYXRoLm1heCgwLChwLTEpKmErcy10KSxoPU1hdGgubWF4KDAsKGQtMSkqcitpLW4pLG09TWF0aC5mbG9vcihjLzIpLGY9Yy1tLGc9TWF0aC5mbG9vcihoLzIpLGI9aC1nO3U9e3RvcDptLGJvdHRvbTpmLGxlZnQ6ZyxyaWdodDpiLHR5cGU6XCJTQU1FXCJ9fWVsc2UgaWYoZT09PVwidmFsaWRcIil1PXt0b3A6MCxib3R0b206MCxsZWZ0OjAscmlnaHQ6MCx0eXBlOlwiVkFMSURcIn0scD1NYXRoLmNlaWwoKHQtcysxKS9hKSxkPU1hdGguY2VpbCgobi1pKzEpL3IpO2Vsc2UgaWYodHlwZW9mIGU9PVwib2JqZWN0XCIpe2xldCBjPWw9PT1cImNoYW5uZWxzTGFzdFwiP2VbMV1bMF06ZVsyXVswXSxoPWw9PT1cImNoYW5uZWxzTGFzdFwiP2VbMV1bMV06ZVsyXVsxXSxtPWw9PT1cImNoYW5uZWxzTGFzdFwiP2VbMl1bMF06ZVszXVswXSxmPWw9PT1cImNoYW5uZWxzTGFzdFwiP2VbMl1bMV06ZVszXVsxXTt1PXt0b3A6Yyxib3R0b206aCxsZWZ0Om0scmlnaHQ6Zix0eXBlOmM9PT0wJiZoPT09MCYmbT09PTAmJmY9PT0wP1wiVkFMSURcIjpcIkVYUExJQ0lUXCJ9LHA9dmMoKHQtcytjK2gpL2ErMSxvKSxkPXZjKChuLWkrbStmKS9yKzEsbyl9ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOnUsb3V0SGVpZ2h0OnAsb3V0V2lkdGg6ZH19ZnVuY3Rpb24gY1AoZSx0LG4sYSxyLHMsaSxvLGwsdSxwKXtsZXQgZCxjLGgsbTtpZihlPT09XCJ2YWxpZFwiJiYoZT0wKSx0eXBlb2YgZT09XCJudW1iZXJcIil7ZD17dG9wOmUsYm90dG9tOmUsbGVmdDplLHJpZ2h0OmUsZnJvbnQ6ZSxiYWNrOmUsdHlwZTplPT09MD9cIlZBTElEXCI6XCJOVU1CRVJcIn07bGV0IGY9dVAoW3QsbixhLDFdLFtvLGwsdV0sMSxbcixzLGldLGUscCk7Yz1mWzBdLGg9ZlsxXSxtPWZbMl19ZWxzZSBpZihlPT09XCJzYW1lXCIpe2M9TWF0aC5jZWlsKHQvciksaD1NYXRoLmNlaWwobi9zKSxtPU1hdGguY2VpbChhL2kpO2xldCBmPShjLTEpKnIrby10LGc9KGgtMSkqcytsLW4sYj0obS0xKSppK3UtYSx5PU1hdGguZmxvb3IoZi8yKSx4PWYteSx2PU1hdGguZmxvb3IoZy8yKSxJPWctdixOPU1hdGguZmxvb3IoYi8yKSxDPWItTjtkPXt0b3A6dixib3R0b206SSxsZWZ0Ok4scmlnaHQ6Qyxmcm9udDp5LGJhY2s6eCx0eXBlOlwiU0FNRVwifX1lbHNlIHRocm93IEVycm9yKGBVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiAke2V9YCk7cmV0dXJue3BhZEluZm86ZCxvdXREZXB0aDpjLG91dEhlaWdodDpoLG91dFdpZHRoOm19fWZ1bmN0aW9uIHZjKGUsdCl7aWYoIXQpcmV0dXJuIE1hdGgudHJ1bmMoZSk7c3dpdGNoKHQpe2Nhc2VcInJvdW5kXCI6cmV0dXJuIE1hdGgucm91bmQoZSk7Y2FzZVwiY2VpbFwiOnJldHVybiBNYXRoLmNlaWwoZSk7Y2FzZVwiZmxvb3JcIjpyZXR1cm4gTWF0aC5mbG9vcihlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biByb3VuZGluZ01vZGUgJHt0fWApfX1mdW5jdGlvbiBwcyhlKXtsZXRbdCxuLGFdPXhjKGUpO3JldHVybiB0PT09MSYmbj09PTEmJmE9PT0xfWZ1bmN0aW9uIGRyKGUsdCl7cmV0dXJuIHBzKGUpfHxwcyh0KX1mdW5jdGlvbiBoaShlKXtyZXR1cm4geGMoZSkuZXZlcnkodD0+dD4wKX1mdW5jdGlvbiBJTihlKXtpZihlPT09XCJOSFdDXCIpcmV0dXJuXCJjaGFubmVsc0xhc3RcIjtpZihlPT09XCJOQ0hXXCIpcmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI7dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHtlfWApfWZ1bmN0aW9uIFRuKGUsdCxuKXtpZihuIT1udWxsKXtpZih0eXBlb2YgdD09XCJzdHJpbmdcIil0aHJvdyBFcnJvcihgRXJyb3IgaW4gJHtlfTogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nIGRpbVJvdW5kaW5nTW9kZSAke259IGJ1dCBnb3QgcGFkICR7dH0uYCk7aWYodHlwZW9mIHQ9PVwibnVtYmVyXCIpQSgkbCh0KSwoKT0+YEVycm9yIGluICR7ZX06IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZyBkaW1Sb3VuZGluZ01vZGUgJHtufSBidXQgZ290IHBhZCAke3R9LmApO2Vsc2UgaWYodHlwZW9mIHQ9PVwib2JqZWN0XCIpdC5mb3JFYWNoKGE9PnthLmZvckVhY2gocj0+e0EoJGwociksKCk9PmBFcnJvciBpbiAke2V9OiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcgZGltUm91bmRpbmdNb2RlICR7bn0gYnV0IGdvdCBwYWQgJHtyfS5gKX0pfSk7ZWxzZSB0aHJvdyBFcnJvcihgRXJyb3IgaW4gJHtlfTogVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHt0fWApfX1mdW5jdGlvbiBkUChlLHQpe2xldCBuPXt4OkUoZSxcInhcIixcInJlc2hhcGVcIixcInN0cmluZ19vcl9udW1lcmljXCIpfSxhPXtzaGFwZTp0fTtyZXR1cm4gUC5ydW5LZXJuZWwoUnUsbixhKX12YXIgVz1MKHtyZXNoYXBlXzpkUH0pO2Z1bmN0aW9uIGhQKGUsdCxuLGEscil7bGV0IHM9RShlLFwieFwiLFwiYXZnUG9vbFwiLFwiZmxvYXQzMlwiKSxpPTE7QShkcihuLGkpLCgpPT5gRXJyb3IgaW4gYXZnUG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtufSBhbmQgZGlsYXRpb25zICcke2l9J2ApO2xldCBvPXMsbD0hMTtzLnJhbms9PT0zJiYobD0hMCxvPVcocyxbMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXV0pKSxBKG8ucmFuaz09PTQsKCk9PmBFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayAke28ucmFua30uYCksVG4oXCJhdmdQb29sXCIsYSxyKTtsZXQgdT17eDpvfSxwPXtmaWx0ZXJTaXplOnQsc3RyaWRlczpuLHBhZDphLGRpbVJvdW5kaW5nTW9kZTpyfSxkPVAucnVuS2VybmVsKERpLHUscCk7cmV0dXJuIGQ9cmUoZCxzLmR0eXBlKSxsP1coZCxbZC5zaGFwZVsxXSxkLnNoYXBlWzJdLGQuc2hhcGVbM11dKTpkfXZhciB5YT1MKHthdmdQb29sXzpoUH0pO2Z1bmN0aW9uIG1QKGUsdCxuLGEscixzPVwiTkRIV0NcIil7bGV0IGk9RShlLFwieFwiLFwiYXZnUG9vbDNkXCIsXCJmbG9hdDMyXCIpLG89aSxsPSExO2kucmFuaz09PTQmJihsPSEwLG89VyhpLFsxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM11dKSksQShvLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gYXZnUG9vbDNkOiB4IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayAke28ucmFua30uYCksQShzPT09XCJOREhXQ1wiLCgpPT5gRXJyb3IgaW4gYXZnUG9vbDNkOiBPbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQsIGJ1dCBnb3QgZGF0YUZvcm1hdCBvZiAke3N9YCksQSh0eXBlb2Ygbj09XCJudW1iZXJcIiYmbj4wfHxBcnJheS5pc0FycmF5KG4pJiZuWzBdPjAmJm5bMV0+MCYmblsyXT4wLCgpPT5gRXJyb3IgaW4gYXZnUG9vbDNkOiBTdHJpZGUgbXVzdCBiZSA+IDAsIGJ1dCBnb3QgJyR7bn0nYCksVG4oXCJhdmdQb29sM2RcIixhLHIpO2xldCB1PXt4Om99LHA9e2ZpbHRlclNpemU6dCxzdHJpZGVzOm4scGFkOmEsZGltUm91bmRpbmdNb2RlOnIsZGF0YUZvcm1hdDpzfSxkPVAucnVuS2VybmVsKHR1LHUscCk7cmV0dXJuIGQ9cmUoZCxvLmR0eXBlKSxsP1coZCxbZC5zaGFwZVsxXSxkLnNoYXBlWzJdLGQuc2hhcGVbM10sZC5zaGFwZVs0XV0pOmR9dmFyIGp2PUwoe2F2Z1Bvb2wzZF86bVB9KTtmdW5jdGlvbiBmUChlLHQ9MCl7QShlLmxlbmd0aD49MSwoKT0+XCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gY29uY2F0XCIpO2xldCBuPWJjKGUsXCJ0ZW5zb3JzXCIsXCJjb25jYXRcIixcInN0cmluZ19vcl9udW1lcmljXCIpO2lmKG5bMF0uZHR5cGU9PT1cImNvbXBsZXg2NFwiJiZuLmZvckVhY2gocz0+e2lmKHMuZHR5cGUhPT1cImNvbXBsZXg2NFwiKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbmNhdGVuYXRlIGNvbXBsZXg2NCB0ZW5zb3JzIHdpdGggYSB0ZW5zb3JcbiAgICAgICAgICB3aXRoIGR0eXBlICR7cy5kdHlwZX0uIGApfSksbi5sZW5ndGg9PT0xKXJldHVybiBzcihuWzBdKTtsZXQgYT1uLHI9e2F4aXM6dH07cmV0dXJuIFAucnVuS2VybmVsKHN1LGEscil9dmFyIGV0PUwoe2NvbmNhdF86ZlB9KTtmdW5jdGlvbiBnUChlLHQsbj0hMSxhPSExKXtsZXQgcj1FKGUsXCJhXCIsXCJtYXRNdWxcIikscz1FKHQsXCJiXCIsXCJtYXRNdWxcIik7W3Isc109X3QocixzKTtsZXQgaT17YTpyLGI6c30sbz17dHJhbnNwb3NlQTpuLHRyYW5zcG9zZUI6YX07cmV0dXJuIFAucnVuS2VybmVsKFJpLGksbyl9dmFyICRlPUwoe21hdE11bF86Z1B9KTtmdW5jdGlvbiBiUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJzaWdtb2lkXCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoTW8sdCl9dmFyIGhhPUwoe3NpZ21vaWRfOmJQfSk7ZnVuY3Rpb24geVAoZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInNsaWNlXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtpZihhLnJhbms9PT0wKXRocm93IG5ldyBFcnJvcihcIlNsaWNpbmcgc2NhbGFyIGlzIG5vdCBwb3NzaWJsZVwiKTtsZXQgcj17eDphfSxzPXtiZWdpbjp0LHNpemU6bn07cmV0dXJuIFAucnVuS2VybmVsKEJ1LHIscyl9dmFyIFZlPUwoe3NsaWNlXzp5UH0pO2Z1bmN0aW9uIHhQKGUpe2xldCB0PXt4OkUoZSxcInhcIixcInRhbmhcIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbChVbyx0KX12YXIgY3M9TCh7dGFuaF86eFB9KTtmdW5jdGlvbiB2UChlLHQsbixhLHIscyl7bGV0IGk9RShlLFwiZm9yZ2V0Qmlhc1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSxvPUUodCxcImxzdG1LZXJuZWxcIixcImJhc2ljTFNUTUNlbGxcIiksbD1FKG4sXCJsc3RtQmlhc1wiLFwiYmFzaWNMU1RNQ2VsbFwiKSx1PUUoYSxcImRhdGFcIixcImJhc2ljTFNUTUNlbGxcIikscD1FKHIsXCJjXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGQ9RShzLFwiaFwiLFwiYmFzaWNMU1RNQ2VsbFwiKSxjPWV0KFt1LGRdLDEpLGg9JGUoYyxvKSxtPVgoaCxsKSxmPW0uc2hhcGVbMF0sZz1tLnNoYXBlWzFdLzQsYj1bZixnXSx5PVZlKG0sWzAsMF0sYikseD1WZShtLFswLGddLGIpLHY9VmUobSxbMCxnKjJdLGIpLEk9VmUobSxbMCxnKjNdLGIpLE49WCh6KGhhKHkpLGNzKHgpKSx6KHAsaGEoWChpLHYpKSkpLEM9eihjcyhOKSxoYShJKSk7cmV0dXJuW04sQ119dmFyIFNOPUwoe2Jhc2ljTFNUTUNlbGxfOnZQfSk7ZnVuY3Rpb24gd1AoZSx0LG4pe2xldCBhPUUoZSxcInhcIixcImJhdGNoVG9TcGFjZU5EXCIpLHI9dC5yZWR1Y2UoKG8sbCk9Pm8qbCk7QShhLnJhbms+PTErdC5sZW5ndGgsKCk9PmBpbnB1dCByYW5rIGlzICR7YS5yYW5rfSBidXQgc2hvdWxkIGJlID4gdGhhbiBibG9ja1NoYXBlLmxlbmd0aCAke3QubGVuZ3RofWApLEEobi5sZW5ndGg9PT10Lmxlbmd0aCwoKT0+YGNyb3BzLmxlbmd0aCBpcyAke24ubGVuZ3RofSBidXQgc2hvdWxkIGJlIGVxdWFsIHRvIGJsb2NrU2hhcGUubGVuZ3RoICAke3QubGVuZ3RofWApLEEoYS5zaGFwZVswXSVyPT09MCwoKT0+YGlucHV0IHRlbnNvciBiYXRjaCBpcyAke2Euc2hhcGVbMF19IGJ1dCBpcyBub3QgZGl2aXNpYmxlIGJ5IHRoZSBwcm9kdWN0IG9mIHRoZSBlbGVtZW50cyBvZiBibG9ja1NoYXBlICR7dC5qb2luKFwiICogXCIpfSA9PT0gJHtyfWApO2xldCBzPXt4OmF9LGk9e2Jsb2NrU2hhcGU6dCxjcm9wczpufTtyZXR1cm4gUC5ydW5LZXJuZWwobnUscyxpKX12YXIgaWQ9TCh7YmF0Y2hUb1NwYWNlTkRfOndQfSk7ZnVuY3Rpb24ga1AoZSl7bGV0IHQ7cmV0dXJuIGUucmFuaz09PTB8fGUucmFuaz09PTE/dD1XKGUsWzEsMSwxLGUuc2l6ZV0pOmUucmFuaz09PTI/dD1XKGUsWzEsMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV1dKTplLnJhbms9PT0zP3Q9VyhlLFsxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdXSk6dD1lLHR9ZnVuY3Rpb24gSVAoZSx0LG4sYSxyLHMpe3M9PW51bGwmJihzPS4wMDEpO2xldCBpPUUoZSxcInhcIixcImJhdGNoTm9ybVwiKSxvPUUodCxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxsPUUobixcInZhcmlhbmNlXCIsXCJiYXRjaE5vcm1cIiksdTtyIT1udWxsJiYodT1FKHIsXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKTtsZXQgcDthIT1udWxsJiYocD1FKGEsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQShvLnJhbms9PT1sLnJhbmssKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCB2YXJpYW5jZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSxBKHA9PW51bGx8fG8ucmFuaz09PXAucmFuaywoKT0+XCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIG9mZnNldCB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSxBKHU9PW51bGx8fG8ucmFuaz09PXUucmFuaywoKT0+XCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHNjYWxlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCIpO2xldCBkPXt4OmtQKGkpLHNjYWxlOnUsb2Zmc2V0OnAsbWVhbjpvLHZhcmlhbmNlOmx9LGM9e3ZhcmlhbmNlRXBzaWxvbjpzfSxoPVAucnVuS2VybmVsKEppLGQsYyk7cmV0dXJuIFcoaCxpLnNoYXBlKX12YXIgTnM9TCh7YmF0Y2hOb3JtXzpJUH0pO2Z1bmN0aW9uIFNQKGUsdCxuLGEscixzKXtsZXQgaT1FKGUsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbz1FKHQsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1FKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpLHU7ciE9bnVsbCYmKHU9RShyLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSk7bGV0IHA7cmV0dXJuIGEhPW51bGwmJihwPUUoYSxcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxBKGkucmFuaz09PTIsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0yRDogeCBtdXN0IGJlIHJhbmsgMiBidXQgZ290IHJhbmsgJHtpLnJhbmt9LmApLEEoby5yYW5rPT09Mnx8by5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTJEOiBtZWFuIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApLEEobC5yYW5rPT09Mnx8bC5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTJEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSx1IT1udWxsJiZBKHUucmFuaz09PTJ8fHUucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0yRDogc2NhbGUgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke3UucmFua30uYCkscCE9bnVsbCYmQShwLnJhbms9PT0yfHxwLnJhbms9PT0xLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7cC5yYW5rfS5gKSxOcyhpLG8sbCxwLHUscyl9dmFyIHF2PUwoe2JhdGNoTm9ybTJkXzpTUH0pO2Z1bmN0aW9uIE5QKGUsdCxuLGEscixzKXtsZXQgaT1FKGUsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbz1FKHQsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1FKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpLHU7ciE9bnVsbCYmKHU9RShyLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSk7bGV0IHA7cmV0dXJuIGEhPW51bGwmJihwPUUoYSxcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxBKGkucmFuaz09PTMsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgJHtpLnJhbmt9LmApLEEoby5yYW5rPT09M3x8by5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApLEEobC5yYW5rPT09M3x8bC5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTNEOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSx1IT1udWxsJiZBKHUucmFuaz09PTN8fHUucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm0zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke3UucmFua30uYCkscCE9bnVsbCYmQShwLnJhbms9PT0zfHxwLnJhbms9PT0xLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IG9mZnNldCBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7cC5yYW5rfS5gKSxOcyhpLG8sbCxwLHUscyl9dmFyIEt2PUwoe2JhdGNoTm9ybTNkXzpOUH0pO2Z1bmN0aW9uIFRQKGUsdCxuLGEscixzKXtsZXQgaT1FKGUsXCJ4XCIsXCJiYXRjaE5vcm1cIiksbz1FKHQsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1FKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpLHU7ciE9bnVsbCYmKHU9RShyLFwic2NhbGVcIixcImJhdGNoTm9ybVwiKSk7bGV0IHA7cmV0dXJuIGEhPW51bGwmJihwPUUoYSxcIm9mZnNldFwiLFwiYmF0Y2hOb3JtXCIpKSxBKGkucmFuaz09PTQsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm00RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtpLnJhbmt9LmApLEEoby5yYW5rPT09NHx8by5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTREOiBtZWFuIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApLEEobC5yYW5rPT09NHx8bC5yYW5rPT09MSwoKT0+YEVycm9yIGluIGJhdGNoTm9ybTREOiB2YXJpYW5jZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSx1IT1udWxsJiZBKHUucmFuaz09PTR8fHUucmFuaz09PTEsKCk9PmBFcnJvciBpbiBiYXRjaE5vcm00RDogc2NhbGUgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayAke3UucmFua30uYCkscCE9bnVsbCYmQShwLnJhbms9PT00fHxwLnJhbms9PT0xLCgpPT5gRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rICR7cC5yYW5rfS5gKSxOcyhpLG8sbCxwLHUscyl9dmFyIFh2PUwoe2JhdGNoTm9ybTRkXzpUUH0pO2Z1bmN0aW9uIENQKGUsdCxuKXtsZXQgYT1FKGUsXCJ4XCIsXCJiaW5jb3VudFwiKSxyPUUodCxcIndlaWdodHNcIixcImJpbmNvdW50XCIpO0EoYS5kdHlwZT09PVwiaW50MzJcIiwoKT0+YEVycm9yIGluIGJpbmNvdW50OiBpbnB1dCBkdHlwZSBtdXN0IGJlIGludDMyLCBidXQgZ290ICR7YS5kdHlwZX1gKSxBKG4+PTAsKCk9PmBzaXplIG11c3QgYmUgbm9uLW5lZ2F0aXZlLCBidXQgZ290ICR7bn0uYCksQShyLnNpemU9PT1hLnNpemV8fHIuc2l6ZT09PTAsKCk9PmBFcnJvciBpbiBiaW5jb3VudDogd2VpZ2h0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2l6ZSBhcyBpbnB1dCBvcjAtbGVuZ3RoLCBidXQgZ290IGlucHV0IHNoYXBlOiAke2Euc2hhcGV9LCB3ZWlnaHRzIHNoYXBlOiAke3Iuc2hhcGV9LmApO2xldCBzPXt4OmEsd2VpZ2h0czpyfSxpPXtzaXplOm59O3JldHVybiBQLnJ1bktlcm5lbChhdSxzLGkpfXZhciBZdj1MKHtiaW5jb3VudF86Q1B9KTtmdW5jdGlvbiBFUChlLHQpe2xldCBuPUUoZSxcInhcIixcImJpdHdpc2VBbmRcIiksYT1FKHQsXCJ5XCIsXCJiaXR3aXNlQW5kXCIpO2lmKCFBcihuLnNoYXBlLGEuc2hhcGUpKXRocm93IG5ldyBFcnJvcihgQml0d2lzZUFuZDogVGVuc29ycyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuIHg6ICR7bi5zaGFwZX0sIHk6ICR7YS5zaGFwZX1gKTtpZihuLmR0eXBlIT09XCJpbnQzMlwifHxhLmR0eXBlIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihgQml0d2lzZUFuZDogT25seSBzdXBwb3J0cyAnaW50MzInIHZhbHVlcyBpbiB0ZW5zb3IsIGZvdW5kIHR5cGUgb2YgeDogJHtuLmR0eXBlfSBhbmQgdHlwZSBvZiB5OiAke2EuZHR5cGV9YCk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbChydSxyKX12YXIgTk49TCh7Yml0d2lzZUFuZF86RVB9KTtmdW5jdGlvbiBfUChlLHQpe2xldCBuPUUoZSxcInMwXCIsXCJicm9hZGNhc3RBcmdzXCIsXCJpbnQzMlwiKSxhPUUodCxcInMxXCIsXCJicm9hZGNhc3RBcmdzXCIsXCJpbnQzMlwiKTtpZihuLnJhbmshPT0xKXRocm93IG5ldyBFcnJvcihgYnJvYWRjYXN0QXJncygpOiBmaXJzdCBpbnB1dCBtdXN0IGJlIGEgdmVjdG9yIChyYW5rPTEpLiBIYXMgcmFuayAke24ucmFua31gKTtpZihhLnJhbmshPT0xKXRocm93IG5ldyBFcnJvcihgYnJvYWRjYXN0QXJncygpOiBzZWNvbmQgaW5wdXQgbXVzdCBiZSBhIHZlY3RvciAocmFuaz0xKS4gSGFzIHJhbmsgJHthLnJhbmt9YCk7bGV0IHI9e3MwOm4sczE6YX07cmV0dXJuIFAucnVuS2VybmVsKE1jLHIpfXZhciBUTj1MKHticm9hZGNhc3RBcmdzXzpfUH0pO2Z1bmN0aW9uIEFQKGUsdCl7bGV0IG49RShlLFwiYnJvYWRjYXN0VG9cIixcInhcIiksYT1uLnNoYXBlO2lmKG5hKHQpLHQubGVuZ3RoPG4ucmFuayl0aHJvdyBuZXcgRXJyb3IoYGJyb2FkY2FzdFRvKCk6IHNoYXBlLmxlbmd0aD0ke3QubGVuZ3RofSA8IGlucHV0LnJhbms9JHtuLnJhbmt9LmApO2lmKHQubGVuZ3RoPm4ucmFuayl7bGV0IGw9bi5zaGFwZS5zbGljZSgpO2Zvcig7bC5sZW5ndGg8dC5sZW5ndGg7KWwudW5zaGlmdCgxKTtuPVcobixsKX1sZXQgcj1uLnNoYXBlLHM9QXJyYXkuZnJvbSh0KTtmb3IobGV0IGw9dC5sZW5ndGgtMTtsPj0wO2wtLSlpZihyW2xdPT09dFtsXSlzW2xdPTE7ZWxzZSBpZihuLnNoYXBlW2xdIT09MSl0aHJvdyBuZXcgRXJyb3IoYGJyb2FkY2FzdFRvKCk6IFske2F9XSBjYW5ub3QgYmUgYnJvYWRjYXN0IHRvIFske3R9XS5gKTtpZihzLm1hcCgobCx1KT0+bD4xP3U6LTEpLmZpbHRlcihsPT5sPj0wKS5sZW5ndGg9PT0wKXJldHVybiBzcihuKTtsZXQgaT17eDpufSxvPXtyZXBzOnN9O3JldHVybiBQLnJ1bktlcm5lbChrcyxpLG8pfXZhciBhaT1MKHticm9hZGNhc3RUb186QVB9KTtmdW5jdGlvbiBGUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJjZWlsXCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoT2ksdCl9dmFyIFp2PUwoe2NlaWxfOkZQfSk7ZnVuY3Rpb24geW4oZSx0LG4pe25hKGUpLG49bnx8JGModCk7bGV0IGE9e3NoYXBlOmUsdmFsdWU6dCxkdHlwZTpufTtyZXR1cm4gUC5ydW5LZXJuZWwoemMse30sYSl9ZnVuY3Rpb24gJFAoZSx0LG4pe2xldCBhPUUoZSxcInhcIixcImNsaXBCeVZhbHVlXCIpO2lmKEEodDw9biwoKT0+YEVycm9yIGluIGNsaXA6IG1pbiAoJHt0fSkgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4ICgke259KS5gKSx0PT09bilyZXR1cm4geW4oYS5zaGFwZSx0LGEuZHR5cGUpO2xldCByPXt4OmF9LHM9e2NsaXBWYWx1ZU1pbjp0LGNsaXBWYWx1ZU1heDpufTtyZXR1cm4gUC5ydW5LZXJuZWwod3MscixzKX12YXIgYW49TCh7Y2xpcEJ5VmFsdWVfOiRQfSk7ZnVuY3Rpb24gRFAoZSl7cmV0dXJuIGV0KGUsMCl9dmFyIEp2PUwoe2NvbmNhdDFkXzpEUH0pO2Z1bmN0aW9uIFJQKGUsdCl7cmV0dXJuIGV0KGUsdCl9dmFyIFF2PUwoe2NvbmNhdDJkXzpSUH0pO2Z1bmN0aW9uIE1QKGUsdCl7cmV0dXJuIGV0KGUsdCl9dmFyIGV3PUwoe2NvbmNhdDNkXzpNUH0pO2Z1bmN0aW9uIE9QKGUsdCl7cmV0dXJuIGV0KGUsdCl9dmFyIHR3PUwoe2NvbmNhdDRkXzpPUH0pO2Z1bmN0aW9uIFBQKGUsdCxuLGEscj1cIk5IV0NcIixzPVsxLDFdLGkpe2xldCBvPUUoZSxcInhcIixcImNvbnYyZFwiLFwiZmxvYXQzMlwiKSxsPUUodCxcImZpbHRlclwiLFwiY29udjJkXCIsXCJmbG9hdDMyXCIpLHU9byxwPSExO28ucmFuaz09PTMmJihwPSEwLHU9VyhvLFsxLG8uc2hhcGVbMF0sby5zaGFwZVsxXSxvLnNoYXBlWzJdXSkpLEEodS5yYW5rPT09NCwoKT0+YEVycm9yIGluIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke3UucmFua30uYCksQShsLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksVG4oXCJjb252MmRcIixhLGkpO2xldCBkPXI9PT1cIk5IV0NcIj91LnNoYXBlWzNdOnUuc2hhcGVbMV07QShkPT09bC5zaGFwZVsyXSwoKT0+YEVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKCR7ZH0pIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciAke2wuc2hhcGVbMl19LmApLEEoZHIobixzKSwoKT0+YEVycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtufSBhbmQgZGlsYXRpb25zICcke3N9J2ApLEEoaGkocyksKCk9PlwiRXJyb3IgaW4gY29udjJEOiBEaWxhdGVkIHJhdGVzIHNob3VsZCBiZSBsYXJnZXIgdGhhbiAwLlwiKSxBKGhpKG4pLCgpPT5cIkVycm9yIGluIGNvbnYyRDogU3RyaWRlcyBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gMC5cIik7bGV0IGM9e3g6dSxmaWx0ZXI6bH0saD17c3RyaWRlczpuLHBhZDphLGRhdGFGb3JtYXQ6cixkaWxhdGlvbnM6cyxkaW1Sb3VuZGluZ01vZGU6aX0sbT1QLnJ1bktlcm5lbChQaSxjLGgpO3JldHVybiBwP1cobSxbbS5zaGFwZVsxXSxtLnNoYXBlWzJdLG0uc2hhcGVbM11dKTptfXZhciAkdD1MKHtjb252MmRfOlBQfSk7ZnVuY3Rpb24gTFAoZSx0LG4sYSxyPVwiTldDXCIscz0xLGkpe2xldCBvPUUoZSxcInhcIixcImNvbnYxZFwiKSxsPUUodCxcImZpbHRlclwiLFwiY29udjFkXCIpLHU9byxwPSExO28ucmFuaz09PTImJihwPSEwLHU9VyhvLFsxLG8uc2hhcGVbMF0sby5zaGFwZVsxXV0pKSxBKHUucmFuaz09PTMsKCk9PmBFcnJvciBpbiBjb252MWQ6IGlucHV0IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgJHt1LnJhbmt9LmApLEEobC5yYW5rPT09MywoKT0+YEVycm9yIGluIGNvbnYxZDogZmlsdGVyIG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgJHtsLnJhbmt9LmApLFRuKFwiY29udjFkXCIsYSxpKSxBKHUuc2hhcGVbMl09PT1sLnNoYXBlWzFdLCgpPT5gRXJyb3IgaW4gY29udjFkOiBkZXB0aCBvZiBpbnB1dCAoJHt1LnNoYXBlWzJdfSkgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyICR7bC5zaGFwZVsxXX0uYCksQShkcihuLHMpLCgpPT5gRXJyb3IgaW4gY29udjFEOiBFaXRoZXIgc3RyaWRlIG9yIGRpbGF0aW9uIG11c3QgYmUgMS4gR290IHN0cmlkZSAke259IGFuZCBkaWxhdGlvbiAnJHtzfSdgKSxBKGhpKHMpLCgpPT5cIkVycm9yIGluIGNvbnYxRDogRGlsYXRlZCByYXRlcyBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gMC5cIiksQShoaShuKSwoKT0+XCJFcnJvciBpbiBjb252MUQ6IFN0cmlkZSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gMC5cIiksQShyPT09XCJOV0NcIiwoKT0+YEVycm9yIGluIGNvbnYxZDogZ290IGRhdGFGb3JtYXQgb2YgJHtyfSBidXQgb25seSBOV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5gKTtsZXQgZD1XKGwsWzEsbC5zaGFwZVswXSxsLnNoYXBlWzFdLGwuc2hhcGVbMl1dKSxjPVcodSxbdS5zaGFwZVswXSwxLHUuc2hhcGVbMV0sdS5zaGFwZVsyXV0pLGg9JHQoYyxkLFsxLG5dLGEsXCJOSFdDXCIsWzEsc10saSk7cmV0dXJuIHA/VyhoLFtoLnNoYXBlWzJdLGguc2hhcGVbM11dKTpXKGgsW2guc2hhcGVbMF0saC5zaGFwZVsyXSxoLnNoYXBlWzNdXSl9dmFyIHptPUwoe2NvbnYxZF86TFB9KTtmdW5jdGlvbiB6UChlLHQsbixhLHIscz1cIk5IV0NcIixpKXtBKGUubGVuZ3RoPT09dC5yYW5rLCgpPT5gTGVuZ3RoIG9mIGluU2hhcGUgKCR7ZS5sZW5ndGh9KSBhbmQgcmFuayBvZiBkeSAoJHt0LnJhbmt9KSBtdXN0IG1hdGNoYCk7bGV0IG89ZSxsPXQsdT0hMTt0LnJhbms9PT0zJiYodT0hMCxsPVcodCxbMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXV0pLG89WzEsZVswXSxlWzFdLGVbMl1dKSxBKG8ubGVuZ3RoPT09NCwoKT0+YEVycm9yIGluIGNvbnYyZERlcklucHV0OiBpblNoYXBlIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgbGVuZ3RoICR7by5sZW5ndGh9LmApLEEobC5yYW5rPT09NCwoKT0+YEVycm9yIGluIGNvbnYyZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rICR7bC5yYW5rfWApLEEobi5yYW5rPT09NCwoKT0+YEVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke24ucmFua31gKTtsZXQgcD1zPT09XCJOSFdDXCI/b1szXTpvWzFdLGQ9cz09PVwiTkhXQ1wiP2wuc2hhcGVbM106bC5zaGFwZVsxXTtBKHA9PT1uLnNoYXBlWzJdLCgpPT5gRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0ICgke3B9KSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgJHtuLnNoYXBlWzJdfS5gKSxBKGQ9PT1uLnNoYXBlWzNdLCgpPT5gRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoJHtkfSkgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciAke24uc2hhcGVbM119LmApLFRuKFwiY29udjJkRGVySW5wdXRcIixyLGkpO2xldCBjPXtkeTpsLGZpbHRlcjpufSxoPXtzdHJpZGVzOmEscGFkOnIsZGF0YUZvcm1hdDpzLGRpbVJvdW5kaW5nTW9kZTppLGlucHV0U2hhcGU6b30sbT1QLnJ1bktlcm5lbChMaSxjLGgpO3JldHVybiB1P1cobSxbbS5zaGFwZVsxXSxtLnNoYXBlWzJdLG0uc2hhcGVbM11dKTptfXZhciBudz1MKHtjb252MkRCYWNrcHJvcElucHV0Xzp6UH0pO2Z1bmN0aW9uIFdQKGUsdCxuLGEscixzKXtsZXQgaT1FKGUsXCJ4XCIsXCJjb252MmRUcmFuc3Bvc2VcIiksbz1FKHQsXCJmaWx0ZXJcIixcImNvbnYyZFRyYW5zcG9zZVwiKTtyZXR1cm4gbncobixpLG8sYSxyLFwiTkhXQ1wiLHMpfXZhciBXbT1MKHtjb252MmRUcmFuc3Bvc2VfOldQfSk7ZnVuY3Rpb24gQlAoZSx0LG4sYSxyPVwiTkRIV0NcIixzPVsxLDEsMV0pe2xldCBpPUUoZSxcInhcIixcImNvbnYzZFwiKSxvPUUodCxcImZpbHRlclwiLFwiY29udjNkXCIpLGw9aSx1PSExO2kucmFuaz09PTQmJih1PSEwLGw9VyhpLFsxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdLGkuc2hhcGVbM11dKSksQShsLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gY29udjNkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSxBKG8ucmFuaz09PTUsKCk9PmBFcnJvciBpbiBjb252M2Q6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rICR7by5yYW5rfS5gKSxBKGwuc2hhcGVbNF09PT1vLnNoYXBlWzNdLCgpPT5gRXJyb3IgaW4gY29udjNkOiBkZXB0aCBvZiBpbnB1dCAoJHtsLnNoYXBlWzRdfSkgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyICR7by5zaGFwZVszXX0uYCksQShkcihuLHMpLCgpPT5gRXJyb3IgaW4gY29udjNEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke259IGFuZCBkaWxhdGlvbnMgJyR7c30nYCksQShyPT09XCJOREhXQ1wiLCgpPT5gRXJyb3IgaW4gY29udjNkOiBnb3QgZGF0YUZvcm1hdCBvZiAke3J9IGJ1dCBvbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCksQShoaShzKSwoKT0+XCJFcnJvciBpbiBjb252M0Q6IERpbGF0ZWQgcmF0ZXMgc2hvdWxkIGJlIGxhcmdlciB0aGFuIDAuXCIpLEEoaGkobiksKCk9PlwiRXJyb3IgaW4gY29udjNEOiBTdHJpZGVzIHNob3VsZCBiZSBsYXJnZXIgdGhhbiAwLlwiKTtsZXQgcD17eDpsLGZpbHRlcjpvfSxkPXtzdHJpZGVzOm4scGFkOmEsZGF0YUZvcm1hdDpyLGRpbGF0aW9uczpzfSxjPVAucnVuS2VybmVsKHppLHAsZCk7cmV0dXJuIHU/VyhjLFtjLnNoYXBlWzFdLGMuc2hhcGVbMl0sYy5zaGFwZVszXSxjLnNoYXBlWzRdXSk6Y312YXIgYXc9TCh7Y29udjNkXzpCUH0pO2Z1bmN0aW9uIFZQKGUsdCxuLGEscil7QShlLmxlbmd0aD09PXQucmFuaywoKT0+YExlbmd0aCBvZiBpblNoYXBlICgke2UubGVuZ3RofSkgYW5kIHJhbmsgb2YgZHkgKCR7dC5yYW5rfSkgbXVzdCBtYXRjaGApO2xldCBzPWUsaT10LG89ITE7dC5yYW5rPT09NCYmKG89ITAsaT1XKHQsWzEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0sdC5zaGFwZVszXV0pLHM9WzEsZVswXSxlWzFdLGVbMl0sZVszXV0pO2xldCBsPXNbNF0sdT1pLnNoYXBlWzRdO0Eocy5sZW5ndGg9PT01LCgpPT5gRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNSwgYnV0IGdvdCBsZW5ndGggJHtzLmxlbmd0aH0uYCksQShpLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayA1LCBidXQgZ290IHJhbmsgJHtpLnJhbmt9YCksQShuLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rICR7bi5yYW5rfWApLEEobD09PW4uc2hhcGVbM10sKCk9PmBFcnJvciBpbiBjb252M2REZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKCR7bH0pIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciAke24uc2hhcGVbM119LmApLEEodT09PW4uc2hhcGVbNF0sKCk9PmBFcnJvciBpbiBjb252M2REZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0ICgke3V9KSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyICR7bi5zaGFwZVs0XX0uYCk7bGV0IHA9e2R5OmksZmlsdGVyOm59LGQ9e3BhZDpyLHN0cmlkZXM6YSxpbnB1dFNoYXBlOnN9LGM9UC5ydW5LZXJuZWwob3UscCxkKTtyZXR1cm4gbz9XKGMsW2Muc2hhcGVbMV0sYy5zaGFwZVsyXSxjLnNoYXBlWzNdLGMuc2hhcGVbNF1dKTpjfXZhciBDTj1MKHtjb252M0RCYWNrcHJvcElucHV0XzpWUH0pO2Z1bmN0aW9uIFVQKGUsdCxuLGEscil7bGV0IHM9RShlLFwieFwiLFwiY29udjNkVHJhbnNwb3NlXCIpLGk9RSh0LFwiZmlsdGVyXCIsXCJjb252M2RUcmFuc3Bvc2VcIik7cmV0dXJuIENOKG4scyxpLGEscil9dmFyIHJ3PUwoe2NvbnYzZFRyYW5zcG9zZV86VVB9KTtmdW5jdGlvbiBHUChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJjb3NcIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbChXaSx0KX12YXIgb2Q9TCh7Y29zXzpHUH0pO2Z1bmN0aW9uIEhQKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImNvc2hcIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbChCaSx0KX12YXIgQm09TCh7Y29zaF86SFB9KTtmdW5jdGlvbiBqUChlLHQ9MCxuPSExLGE9ITEpe2xldCByPXt4OkUoZSxcInhcIixcImN1bXByb2RcIil9LHM9e2F4aXM6dCxleGNsdXNpdmU6bixyZXZlcnNlOmF9O3JldHVybiBQLnJ1bktlcm5lbChsdSxyLHMpfXZhciB3Yz1MKHtjdW1wcm9kXzpqUH0pO2Z1bmN0aW9uIHFQKGUsdD0wLG49ITEsYT0hMSl7bGV0IHI9e3g6RShlLFwieFwiLFwiY3Vtc3VtXCIpfSxzPXtheGlzOnQsZXhjbHVzaXZlOm4scmV2ZXJzZTphfTtyZXR1cm4gUC5ydW5LZXJuZWwoVmkscixzKX12YXIgVm09TCh7Y3Vtc3VtXzpxUH0pO2Z1bmN0aW9uIEtQKGUsdCxuLGE9ITEpe2xldCByPUUoZSxcInhcIixcImRlbnNlQmluY291bnRcIikscz1FKHQsXCJ3ZWlnaHRzXCIsXCJkZW5zZUJpbmNvdW50XCIpO0Eoci5kdHlwZT09PVwiaW50MzJcIiwoKT0+YEVycm9yIGluIGRlbnNlQmluY291bnQ6IGlucHV0IGR0eXBlIG11c3QgYmUgaW50MzIsIGJ1dCBnb3QgJHtyLmR0eXBlfWApLEEoci5yYW5rPD0yLCgpPT5gRXJyb3IgaW4gZGVuc2VCaW5jb3VudDogaW5wdXQgbXVzdCBiZSBhdCBtb3N0IHJhbmsgMiwgYnV0IGdvdCByYW5rICR7ci5yYW5rfS5gKSxBKG4+PTAsKCk9PmBzaXplIG11c3QgYmUgbm9uLW5lZ2F0aXZlLCBidXQgZ290ICR7bn0uYCksQShzLnNpemU9PT1yLnNpemV8fHMuc2l6ZT09PTAsKCk9PmBFcnJvciBpbiBkZW5zZUJpbmNvdW50OiB3ZWlnaHRzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZSBhcyB4IG9yIDAtbGVuZ3RoLCBidXQgZ290IHggc2hhcGU6ICR7ci5zaGFwZX0sIHdlaWdodHMgc2hhcGU6ICR7cy5zaGFwZX0uYCk7bGV0IGk9e3g6cix3ZWlnaHRzOnN9LG89e3NpemU6bixiaW5hcnlPdXRwdXQ6YX07cmV0dXJuIFAucnVuS2VybmVsKFBjLGksbyl9dmFyIFhoPUwoe2RlbnNlQmluY291bnRfOktQfSk7ZnVuY3Rpb24gWFAoZSx0LG49XCJOSFdDXCIpe2xldCBhPUUoZSxcInhcIixcImRlcHRoVG9TcGFjZVwiLFwiZmxvYXQzMlwiKSxyPW49PT1cIk5IV0NcIj9hLnNoYXBlWzFdOmEuc2hhcGVbMl0scz1uPT09XCJOSFdDXCI/YS5zaGFwZVsyXTphLnNoYXBlWzNdLGk9bj09PVwiTkhXQ1wiP2Euc2hhcGVbM106YS5zaGFwZVsxXTtBKHQ+MSwoKT0+YGJsb2NrU2l6ZSBzaG91bGQgYmUgPiAxIGZvciBkZXB0aFRvU3BhY2UsIGJ1dCB3YXM6ICR7dH1gKSxBKHIqdD49MCwoKT0+YE5lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBvdmVyZmxvdyB3aGVuIG11bHRpcGx5aW5nXG4gICAgJHtyfSBhbmQgJHt0fSAgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXG4gICAgJHthLnNoYXBlfWApLEEocyp0Pj0wLCgpPT5gTmVnYXRpdmUgZGltZW5zaW9uIHNpemUgY2F1c2VkIGJ5IG92ZXJmbG93IHdoZW4gbXVsdGlwbHlpbmdcbiAgICAke3N9IGFuZCAke3R9IGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxuICAgICAgICAke2Euc2hhcGV9YCksQShpJSh0KnQpPT09MCwoKT0+YERpbWVuc2lvbiBzaXplIG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSAke3QqdH0gYnV0IGlzICR7aX0gZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlICR7YS5zaGFwZX1gKTtsZXQgbz17eDphfSxsPXtibG9ja1NpemU6dCxkYXRhRm9ybWF0Om59O3JldHVybiBQLnJ1bktlcm5lbChwdSxvLGwpfXZhciBzdz1MKHtkZXB0aFRvU3BhY2VfOlhQfSk7ZnVuY3Rpb24gWVAoZSx0LG4sYSxyPVwiTkhXQ1wiLHM9WzEsMV0saSl7bGV0IG89RShlLFwieFwiLFwiZGVwdGh3aXNlQ29udjJkXCIsXCJmbG9hdDMyXCIpLGw9RSh0LFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIixcImZsb2F0MzJcIiksdT1vLHA9ITE7by5yYW5rPT09MyYmKHA9ITAsdT1XKG8sWzEsby5zaGFwZVswXSxvLnNoYXBlWzFdLG8uc2hhcGVbMl1dKSksQSh1LnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rICR7dS5yYW5rfS5gKSxBKGwucmFuaz09PTQsKCk9PmBFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKTtsZXQgZD1yPT09XCJOSFdDXCI/dS5zaGFwZVszXTp1LnNoYXBlWzFdO0EoZD09PWwuc2hhcGVbMl0sKCk9PmBFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IG51bWJlciBvZiBpbnB1dCBjaGFubmVscyAoJHtkfSkgbXVzdCBtYXRjaCB0aGUgaW5DaGFubmVscyBkaW1lbnNpb24gaW4gZmlsdGVyICR7bC5zaGFwZVsyXX0uYCksVG4oXCJkZXB0aHdpc2VDb252MmRcIixhLGkpO2xldCBjPXt4OnUsZmlsdGVyOmx9LGg9e3N0cmlkZXM6bixwYWQ6YSxkYXRhRm9ybWF0OnIsZGlsYXRpb25zOnMsZGltUm91bmRpbmdNb2RlOml9LG09UC5ydW5LZXJuZWwoVWksYyxoKTtyZXR1cm4gcD9XKG0sW20uc2hhcGVbMV0sbS5zaGFwZVsyXSxtLnNoYXBlWzNdXSk6bX12YXIgVHM9TCh7ZGVwdGh3aXNlQ29udjJkXzpZUH0pO2Z1bmN0aW9uIFpQKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImRpYWdcIil9O3JldHVybiBQLnJ1bktlcm5lbChMYyx0KX12YXIgRU49TCh7ZGlhZ186WlB9KTtmdW5jdGlvbiBKUChlLHQsbixhLHI9WzEsMV0scz1cIk5IV0NcIil7bGV0IGk9RShlLFwieFwiLFwiZGlsYXRpb24yZFwiKSxvPUUodCxcImZpbHRlclwiLFwiZGlsYXRpb24yZFwiKTtBKGkucmFuaz09PTN8fGkucmFuaz09PTQsKCk9PmBFcnJvciBpbiBkaWxhdGlvbjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IHJhbmsgJHtpLnJhbmt9LmApLEEoby5yYW5rPT09MywoKT0+YEVycm9yIGluIGRpbGF0aW9uMmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rICR7by5yYW5rfS5gKSxBKHM9PT1cIk5IV0NcIiwoKT0+YEVycm9yIGluIGRpbGF0aW9uMmQ6IE9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLCBidXQgZ290IGRhdGFGb3JtYXQgb2YgJHtzfWApO2xldCBsPWksdT0hMTtpLnJhbms9PT0zJiYobD1XKGksWzEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl1dKSx1PSEwKSxBKGwuc2hhcGVbM109PT1vLnNoYXBlWzJdLCgpPT5gRXJyb3IgaW4gZGlsYXRpb24yZDogIGlucHV0IGFuZCBmaWx0ZXIgbXVzdCBoYXZlIHRoZSBzYW1lIGRlcHRoOiAke2wuc2hhcGVbM119IHZzICR7by5zaGFwZVsyXX1gKTtsZXQgcD17eDpsLGZpbHRlcjpvfSxkPXtzdHJpZGVzOm4scGFkOmEsZGlsYXRpb25zOnJ9LGM9UC5ydW5LZXJuZWwoR2kscCxkKTtyZXR1cm4gdT9XKGMsW2Muc2hhcGVbMV0sYy5zaGFwZVsyXSxjLnNoYXBlWzNdXSk6Y312YXIgaXc9TCh7ZGlsYXRpb24yZF86SlB9KSxKdT17fTtfZShKdSx7YXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGU6KCk9PmN0LGdldEJyb2FkY2FzdERpbXM6KCk9Pl9OLGdldFJlZHVjdGlvbkF4ZXM6KCk9PkJ0fSk7ZnVuY3Rpb24gX04oZSx0KXtsZXQgbj1lLmxlbmd0aCxhPVtdO2ZvcihsZXQgcj0wO3I8bjtyKyspe2xldCBzPW4tMS1yLGk9ZVtzXXx8MTsodFt0Lmxlbmd0aC0xLXJdfHwxKT4xJiZpPT09MSYmYS51bnNoaWZ0KHMpfXJldHVybiBhfWZ1bmN0aW9uIEJ0KGUsdCl7bGV0IG49W107Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2xldCByPWVbZS5sZW5ndGgtYS0xXSxzPXQubGVuZ3RoLWEtMSxpPXRbc107KHI9PW51bGx8fHI9PT0xJiZpPjEpJiZuLnVuc2hpZnQocyl9cmV0dXJuIG59ZnVuY3Rpb24gY3QoZSx0KXtsZXQgbj1NYXRoLm1heChlLmxlbmd0aCx0Lmxlbmd0aCksYT1uZXcgQXJyYXkobik7Zm9yKGxldCByPTA7cjxuO3IrKyl7bGV0IHM9ZVtlLmxlbmd0aC1yLTFdO3M9PW51bGwmJihzPTEpO2xldCBpPXRbdC5sZW5ndGgtci0xXTtpZihpPT1udWxsJiYoaT0xKSxzPT09MSlhW24tci0xXT1pO2Vsc2UgaWYoaT09PTEpYVtuLXItMV09cztlbHNlIGlmKHMhPT1pKXtsZXQgbz1gT3BlcmFuZHMgY291bGQgbm90IGJlIGJyb2FkY2FzdCB0b2dldGhlciB3aXRoIHNoYXBlcyAke2V9IGFuZCAke3R9LmA7dGhyb3cgRXJyb3Iobyl9ZWxzZSBhW24tci0xXT1zfXJldHVybiBhfWZ1bmN0aW9uIFFQKGUsdCl7bGV0IG49RShlLFwiYVwiLFwiZXF1YWxcIixcInN0cmluZ19vcl9udW1lcmljXCIpLGE9RSh0LFwiYlwiLFwiZXF1YWxcIixcInN0cmluZ19vcl9udW1lcmljXCIpO1tuLGFdPV90KG4sYSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKGR1LHIpfXZhciBKbj1MKHtlcXVhbF86UVB9KTtmdW5jdGlvbiBlMyhlLHQsbil7bGV0IGE9RSh0LFwiYVwiLFwid2hlcmVcIikscj1FKG4sXCJiXCIsXCJ3aGVyZVwiKSxzPUUoZSxcImNvbmRpdGlvblwiLFwid2hlcmVcIixcImJvb2xcIiksaT1jdChjdChzLnNoYXBlLGEuc2hhcGUpLHIuc2hhcGUpLG89YWkocyxpKSxsPWFpKGEsaSksdT1haShyLGkpLHA9e2NvbmRpdGlvbjpvLHQ6bCxlOnV9O3JldHVybiBQLnJ1bktlcm5lbChXdSxwKX12YXIgbm49TCh7d2hlcmVfOmUzfSk7ZnVuY3Rpb24gdDMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiemVyb3NMaWtlXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoWXUsdCl9dmFyIHFlPUwoe3plcm9zTGlrZV86dDN9KTtmdW5jdGlvbiBuMyhlLHQpe2xldCBuPUUoZSxcImFcIixcImRpdlwiKSxhPUUodCxcImJcIixcImRpdlwiKTtbbixhXT1fdChuLGEpO2xldCByPWhlKG4sYSkscz1xZShyKSxpPUpuKGEscyk7cmV0dXJuIG5uKGkscyxyKX12YXIgb3c9TCh7ZGl2Tm9OYW5fOm4zfSk7ZnVuY3Rpb24gYTMoZSx0KXtsZXQgbj1FKGUsXCJ0MVwiLFwiZG90XCIpLGE9RSh0LFwidDJcIixcImRvdFwiKTtBKChuLnJhbms9PT0xfHxuLnJhbms9PT0yKSYmKGEucmFuaz09PTF8fGEucmFuaz09PTIpLCgpPT5gRXJyb3IgaW4gZG90OiBpbnB1dHMgbXVzdCBhbGwgYmUgcmFuayAxIG9yIDIsIGJ1dCBnb3QgcmFua3MgJHtuLnJhbmt9IGFuZCAke2EucmFua30uYCk7bGV0IHI9bi5yYW5rPT09MT9uLnNpemU6bi5zaGFwZVsxXSxzPWEucmFuaz09PTE/YS5zaXplOmEuc2hhcGVbMF07aWYoQShyPT09cywoKT0+YEVycm9yIGluIGRvdDogaW5uZXIgZGltZW5zaW9ucyBvZiBpbnB1dHMgbXVzdCBtYXRjaCwgYnV0IGdvdCAke3J9IGFuZCAke3N9LmApLG4ucmFuaz09PTEmJmEucmFuaz09PTEpe2xldCBpPVcobixbMSwtMV0pLG89VyhhLFstMSwxXSksbD0kZShpLG8pO3JldHVybiBXKGwsW10pfWVsc2UgaWYobi5yYW5rPT09MSYmYS5yYW5rPT09Mil7bGV0IGk9VyhuLFsxLC0xXSksbz1XKGEsW2Euc2hhcGVbMF0sYS5zaGFwZVsxXV0pLGw9JGUoaSxvKTtyZXR1cm4gVyhsLFtsLnNpemVdKX1lbHNlIGlmKG4ucmFuaz09PTImJmEucmFuaz09PTEpe2xldCBpPVcoYSxbLTEsMV0pLG89JGUobixpKTtyZXR1cm4gVyhvLFtvLnNpemVdKX1lbHNle2xldCBpPVcoYSxbYS5zaGFwZVswXSxhLnNoYXBlWzFdXSk7cmV0dXJuICRlKG4saSl9fXZhciBsdz1MKHtkb3RfOmEzfSk7ZnVuY3Rpb24gcjMoZSwuLi50KXtsZXQgbj10Lm1hcCgocixzKT0+RShyLGB0ZW5zb3JzJHtzfWAsXCJlaW5zdW1cIikpLGE9e2VxdWF0aW9uOmV9O3JldHVybiBQLnJ1bktlcm5lbChUbSxuLGEpfXZhciBacz1MKHtlaW5zdW1fOnIzfSk7ZnVuY3Rpb24gczMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiZWx1XCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoamksdCl9dmFyIFF1PUwoe2VsdV86czN9KTtmdW5jdGlvbiBpMyhlLHQpe2xldCBuPUUoZSxcInhcIixcImVuc3VyZVNoYXBlXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtpZighUlMobi5zaGFwZSx0KSl0aHJvdyBuZXcgRXJyb3IoYEVuc3VyZVNoYXBlOiBTaGFwZSBvZiB0ZW5zb3IgJHtuLnNoYXBlfSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGV4cGVjdGVkIHNoYXBlICR7dH1gKTtyZXR1cm4gZX12YXIgQU49TCh7ZW5zdXJlU2hhcGVfOmkzfSk7ZnVuY3Rpb24gbzMoZSl7bGV0IHQ9RShlLFwieFwiLFwiZXJmXCIpO0EodC5kdHlwZT09PVwiaW50MzJcInx8dC5kdHlwZT09PVwiZmxvYXQzMlwiLCgpPT5cIklucHV0IGR0eXBlIG11c3QgYmUgYGludDMyYCBvciBgZmxvYXQzMmAuXCIpLHQuZHR5cGU9PT1cImludDMyXCImJih0PXJlKHQsXCJmbG9hdDMyXCIpKTtsZXQgbj17eDp0fTtyZXR1cm4gUC5ydW5LZXJuZWwocWksbil9dmFyIFVtPUwoe2VyZl86bzN9KTtmdW5jdGlvbiB1dyhlLHQpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKWlmKGVbZS5sZW5ndGgtbi0xXSE9PXQtMS1uKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEZOKGUsdCxuKXtsZXQgYT1lLmxlbmd0aCt0Lmxlbmd0aCxyPVtdLHM9MCxpPTA7Zm9yKGxldCBvPTA7bzxhO28rKyluLmluZGV4T2Yobyk9PT0tMT9yLnB1c2goZVtzKytdKTpyLnB1c2godFtpKytdKTtyZXR1cm4gcn1mdW5jdGlvbiAkTihlLHQpe2xldCBuPVtdLGE9ZS5sZW5ndGg7Zm9yKGxldCBzPTA7czxhO3MrKyl0LmluZGV4T2Yocyk9PT0tMSYmbi5wdXNoKGVbc10pO2xldCByPXQubWFwKHM9PmVbc10pO3JldHVybltuLHJdfWZ1bmN0aW9uIG1pKGUsdCl7bGV0IG49dC5tYXAoYT0+MSk7cmV0dXJuIEZOKGUsbix0KX1mdW5jdGlvbiBsMyhlLHQsbil7QSh1dyh0LG4pLCgpPT5gJHtlfSBzdXBwb3J0cyBvbmx5IGlubmVyLW1vc3QgYXhlcyBmb3Igbm93LiBHb3QgYXhlcyAke3R9IGFuZCByYW5rLSR7bn0gaW5wdXQuYCl9ZnVuY3Rpb24gRE4oZSx0KXtpZih1dyhlLHQpKXJldHVybiBudWxsO2xldCBuPVtdO2ZvcihsZXQgYT0wO2E8dDsrK2EpZS5pbmRleE9mKGEpPT09LTEmJm4ucHVzaChhKTtyZXR1cm4gZS5mb3JFYWNoKGE9Pm4ucHVzaChhKSksbn1mdW5jdGlvbiBwdyhlKXtyZXR1cm4gZS5tYXAoKHQsbik9PltuLHRdKS5zb3J0KCh0LG4pPT50WzFdLW5bMV0pLm1hcCh0PT50WzBdKX1mdW5jdGlvbiB1MyhlLHQpe2xldCBuPVtdO2ZvcihsZXQgYT10LWU7YTx0OysrYSluLnB1c2goYSk7cmV0dXJuIG59ZnVuY3Rpb24gcDMoZSx0PW51bGwsbj0hMSl7bGV0IGE9e3g6RShlLFwieFwiLFwibWF4XCIpfSxyPXtyZWR1Y3Rpb25JbmRpY2VzOnQsa2VlcERpbXM6bn07cmV0dXJuIFAucnVuS2VybmVsKGxvLGEscil9dmFyIG1hPUwoe21heF86cDN9KTtmdW5jdGlvbiBjMyhlLHQ9bnVsbCxuPSExKXtsZXQgYT17eDpFKGUsXCJ4XCIsXCJtaW5cIil9LHI9e2F4aXM6dCxrZWVwRGltczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoaG8sYSxyKX12YXIgT2w9TCh7bWluXzpjM30pO2Z1bmN0aW9uIGQzKGUsdCl7bGV0IG49RShlLFwiYmFzZVwiLFwicG93XCIpLGE9RSh0LFwiZXhwXCIsXCJwb3dcIik7W24sYV09X3QobixhKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKHZvLHIpfXZhciB1cj1MKHtwb3dfOmQzfSk7ZnVuY3Rpb24geGUoZSx0KXtpZigoZW4oZSkmJnQhPT1cInN0cmluZ1wifHxBcnJheS5pc0FycmF5KGUpKSYmdCE9PVwiY29tcGxleDY0XCIpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgYSBuZXcgU2NhbGFyOiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlIChudW1iZXJ8Ym9vbGVhbnxzdHJpbmcpXCIpO2lmKHQ9PT1cInN0cmluZ1wiJiZlbihlKSYmIShlIGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBtYWtpbmcgYSBzY2FsYXIgZnJvbSBlbmNvZGVkIHN0cmluZywgdGhlIHZhbHVlIG11c3QgYmUgYFVpbnQ4QXJyYXlgLlwiKTtyZXR1cm4gU3MoZSxbXSxbXSx0KX1mdW5jdGlvbiBoMyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJzcXJ0XCIsXCJmbG9hdDMyXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoUG8sdCl9dmFyIHJuPUwoe3NxcnRfOmgzfSk7ZnVuY3Rpb24gbTMoZSl7bGV0IHQ9RShlLFwieFwiLFwic3F1YXJlXCIpLG49e307cmV0dXJuIFAucnVuS2VybmVsKFwiU3F1YXJlXCIse3g6dH0sbil9dmFyIHB0PUwoe3NxdWFyZV86bTN9KTtmdW5jdGlvbiBmMyhlLHQ9bnVsbCxuPSExKXtsZXQgYT1FKGUsXCJ4XCIsXCJzdW1cIik7YS5kdHlwZT09PVwiYm9vbFwiJiYoYT1yZShhLFwiaW50MzJcIikpO2xldCByPXt4OmF9LHM9e2F4aXM6dCxrZWVwRGltczpufTtyZXR1cm4gUC5ydW5LZXJuZWwoTG8scixzKX12YXIgZmU9TCh7c3VtXzpmM30pO2Z1bmN0aW9uIGczKGUsdD1cImV1Y2xpZGVhblwiLG49bnVsbCxhPSExKXtlPUUoZSxcInhcIixcIm5vcm1cIik7bGV0IHI9Uk4oZSx0LG4pLHM9ci5zaGFwZTtpZihhKXtsZXQgaT1BYShuLGUuc2hhcGUpO3M9bWkoci5zaGFwZSxpKX1yZXR1cm4gVyhyLHMpfWZ1bmN0aW9uIFJOKGUsdCxuPW51bGwpe2lmKGUucmFuaz09PTApcmV0dXJuIEx0KGUpO2lmKGUucmFuayE9PTEmJm49PT1udWxsKXJldHVybiBSTihXKGUsWy0xXSksdCxuKTtpZihlLnJhbms9PT0xfHx0eXBlb2Ygbj09XCJudW1iZXJcInx8QXJyYXkuaXNBcnJheShuKSYmbi5sZW5ndGg9PT0xKXtpZih0PT09MSlyZXR1cm4gZmUoTHQoZSksbik7aWYodD09PTEvMClyZXR1cm4gbWEoTHQoZSksbik7aWYodD09PS0xLzApcmV0dXJuIE9sKEx0KGUpLG4pO2lmKHQ9PT1cImV1Y2xpZGVhblwifHx0PT09MilyZXR1cm4gcm4oZmUodXIoTHQoZSkseGUoMixcImludDMyXCIpKSxuKSk7dGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogJHt0fWApfWlmKEFycmF5LmlzQXJyYXkobikmJm4ubGVuZ3RoPT09Mil7aWYodD09PTEpcmV0dXJuIG1hKGZlKEx0KGUpLG5bMF0pLG5bMV0tMSk7aWYodD09PTEvMClyZXR1cm4gbWEoZmUoTHQoZSksblsxXSksblswXSk7aWYodD09PS0xLzApcmV0dXJuIE9sKGZlKEx0KGUpLG5bMV0pLG5bMF0pO2lmKHQ9PT1cImZyb1wifHx0PT09XCJldWNsaWRlYW5cIilyZXR1cm4gcm4oZmUocHQoZSksbikpO3Rocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6ICR7dH1gKX10aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIG5vcm06IGludmFsaWQgYXhpczogJHtufWApfXZhciBlcD1MKHtub3JtXzpnM30pO2Z1bmN0aW9uIGIzKGUsdD1udWxsLG49ITEpe3JldHVybiBlcChlLFwiZXVjbGlkZWFuXCIsdCxuKX12YXIgY3c9TCh7ZXVjbGlkZWFuTm9ybV86YjN9KTtmdW5jdGlvbiB5MyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJleHBcIil9O3JldHVybiBQLnJ1bktlcm5lbChLaSx0KX12YXIgZG49TCh7ZXhwXzp5M30pO2Z1bmN0aW9uIHgzKGUsdD0wKXtsZXQgbj1FKGUsXCJ4XCIsXCJleHBhbmREaW1zXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtBKHQ8PW4ucmFuaywoKT0+XCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCIpO2xldCBhPXtpbnB1dDpufSxyPXtkaW06dH07cmV0dXJuIFAucnVuS2VybmVsKGh1LGEscil9dmFyIEd0PUwoe2V4cGFuZERpbXNfOngzfSk7ZnVuY3Rpb24gdjMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiZXhwbTFcIil9O3JldHVybiBQLnJ1bktlcm5lbChYaSx0KX12YXIgZHc9TCh7ZXhwbTFfOnYzfSk7ZnVuY3Rpb24gdzMoZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJ0aWxlXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtBKG4ucmFuaz09PXQubGVuZ3RoLCgpPT5gRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0ICR7bi5yYW5rfSBtdXN0IG1hdGNoIGxlbmd0aCBvZiByZXBzICR7dH0uYCk7bGV0IGE9e3g6bn0scj17cmVwczp0fTtyZXR1cm4gUC5ydW5LZXJuZWwoa3MsYSxyKX12YXIgT249TCh7dGlsZV86dzN9KTtmdW5jdGlvbiBrMyhlLHQsbixhPVwiZmxvYXQzMlwiKXt0PT1udWxsJiYodD1lKTtsZXQgcj1PZShbZSx0XSxhKSxzPWU8PXQ/ZTp0O2ZvcihsZXQgbz0wO288czsrK28pci5zZXQoMSxvLG8pO2xldCBpPVcoci50b1RlbnNvcigpLFtlLHRdKTtpZihuPT1udWxsKXJldHVybiBpO2lmKG4ubGVuZ3RoPT09MSlyZXR1cm4gT24oR3QoaSwwKSxbblswXSwxLDFdKTtpZihuLmxlbmd0aD09PTIpcmV0dXJuIE9uKEd0KEd0KGksMCksMCksW25bMF0sblsxXSwxLDFdKTtpZihuLmxlbmd0aD09PTMpcmV0dXJuIE9uKEd0KEd0KEd0KGksMCksMCksMCksW25bMF0sblsxXSxuWzJdLDEsMV0pO3Rocm93IG5ldyBFcnJvcihgZXllKCkgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgMUQgYW5kIDJEIGJhdGNoU2hhcGVzLCBidXQgcmVjZWl2ZWQgJHtuLmxlbmd0aH1ELmApfXZhciBHbT1MKHtleWVfOmszfSk7ZnVuY3Rpb24gSTMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiZmxvb3JcIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbChZaSx0KX12YXIgdHA9TCh7Zmxvb3JfOkkzfSk7ZnVuY3Rpb24gUzMoZSx0LG49MCxhPTApe2xldCByPUUoZSxcInhcIixcImdhdGhlclwiKSxzPUUodCxcImluZGljZXNcIixcImdhdGhlclwiLFwiaW50MzJcIiksaT17eDpyLGluZGljZXM6c30sbz17YXhpczpuLGJhdGNoRGltczphfTtyZXR1cm4gUC5ydW5LZXJuZWwoZnUsaSxvKX12YXIgbnA9TCh7Z2F0aGVyXzpTM30pO2Z1bmN0aW9uIE4zKGUsdCl7bGV0IG49RShlLFwiYVwiLFwiZ3JlYXRlclwiLFwic3RyaW5nX29yX251bWVyaWNcIiksYT1FKHQsXCJiXCIsXCJncmVhdGVyXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtbbixhXT1fdChuLGEpLGN0KG4uc2hhcGUsYS5zaGFwZSk7bGV0IHI9e2E6bixiOmF9O3JldHVybiBQLnJ1bktlcm5lbChidSxyKX12YXIgQ249TCh7Z3JlYXRlcl86TjN9KTtmdW5jdGlvbiBUMyhlLHQpe2xldCBuPUUoZSxcImFcIixcImdyZWF0ZXJFcXVhbFwiLFwic3RyaW5nX29yX251bWVyaWNcIiksYT1FKHQsXCJiXCIsXCJncmVhdGVyRXF1YWxcIixcInN0cmluZ19vcl9udW1lcmljXCIpO1tuLGFdPV90KG4sYSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKFFpLHIpfXZhciAkcj1MKHtncmVhdGVyRXF1YWxfOlQzfSk7ZnVuY3Rpb24gQzMoZSl7bGV0IHQ9e2lucHV0OkUoZSxcImlucHV0XCIsXCJpbWFnXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoX20sdCl9dmFyIGxkPUwoe2ltYWdfOkMzfSk7ZnVuY3Rpb24gRTMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiaXNGaW5pdGVcIil9O3JldHVybiBQLnJ1bktlcm5lbCh0byx0KX12YXIgaHc9TCh7aXNGaW5pdGVfOkUzfSk7ZnVuY3Rpb24gXzMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiaXNJbmZcIil9O3JldHVybiBQLnJ1bktlcm5lbChubyx0KX12YXIgbXc9TCh7aXNJbmZfOl8zfSk7ZnVuY3Rpb24gQTMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwiaXNOYU5cIil9O3JldHVybiBQLnJ1bktlcm5lbChhbyx0KX12YXIgZnc9TCh7aXNOYU5fOkEzfSk7ZnVuY3Rpb24gRjMoZSx0PS4yKXtsZXQgbj17eDpFKGUsXCJ4XCIsXCJsZWFreVJlbHVcIil9LGE9e2FscGhhOnR9O3JldHVybiBQLnJ1bktlcm5lbChybyxuLGEpfXZhciB1ZD1MKHtsZWFreVJlbHVfOkYzfSk7ZnVuY3Rpb24gJDMoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJsZXNzXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKSxhPUUodCxcImJcIixcImxlc3NcIixcInN0cmluZ19vcl9udW1lcmljXCIpO1tuLGFdPV90KG4sYSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKHl1LHIpfXZhciBQbD1MKHtsZXNzXzokM30pO2Z1bmN0aW9uIEQzKGUsdCl7bGV0IG49RShlLFwiYVwiLFwibGVzc0VxdWFsXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKSxhPUUodCxcImJcIixcImxlc3NFcXVhbFwiLFwic3RyaW5nX29yX251bWVyaWNcIik7W24sYV09X3QobixhKSxjdChuLnNoYXBlLGEuc2hhcGUpO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwoeHUscil9dmFyIENzPUwoe2xlc3NFcXVhbF86RDN9KTtmdW5jdGlvbiBNTihlLHQsbil7aWYobjw9MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHZhbHVlcyBzaG91bGQgYmUgcG9zaXRpdmUuXCIpO2xldCBhPXtzdGFydDplLHN0b3A6dCxudW06bn07cmV0dXJuIFAucnVuS2VybmVsKHZ1LHt9LGEpfWZ1bmN0aW9uIFIzKGUsdD01LG49MSxhPTEscj0uNSl7bGV0IHM9RShlLFwieFwiLFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25cIik7QShzLnJhbms9PT00fHxzLnJhbms9PT0zLCgpPT5gRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IHggbXVzdCBiZSByYW5rIDMgb3IgNCBidXQgZ290XG4gICAgICAgICAgICAgICByYW5rICR7cy5yYW5rfS5gKSxBKCRsKHQpLCgpPT5gRXJyb3IgaW4gbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246IGRlcHRoUmFkaXVzIG11c3QgYmUgYW4gaW50ZWdlciBidXQgZ290IGRlcHRoUmFkaXVzICR7dH0uYCk7bGV0IGk9cyxvPSExO3MucmFuaz09PTMmJihvPSEwLGk9VyhzLFsxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdXSkpO2xldCBsPXt4Oml9LHU9e2RlcHRoUmFkaXVzOnQsYmlhczpuLGFscGhhOmEsYmV0YTpyfSxwPVAucnVuS2VybmVsKG9vLGwsdSk7cmV0dXJuIG8/VyhwLFtwLnNoYXBlWzFdLHAuc2hhcGVbMl0scC5zaGFwZVszXV0pOnB9dmFyIGd3PUwoe2xvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXzpSM30pO2Z1bmN0aW9uIE0zKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImxvZ1wiLFwiZmxvYXQzMlwiKX07cmV0dXJuIFAucnVuS2VybmVsKHNvLHQpfXZhciBRbj1MKHtsb2dfOk0zfSk7ZnVuY3Rpb24gTzMoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwibG9nMXBcIil9O3JldHVybiBQLnJ1bktlcm5lbChpbyx0KX12YXIgcGQ9TCh7bG9nMXBfOk8zfSk7ZnVuY3Rpb24gUDMoZSl7cmV0dXJuIEEoc3MoZSksKCk9PlwiVGhlIGYgcGFzc2VkIGluIGdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpLCh0LG4pPT57bGV0IGE9RSh0LFwieFwiLFwidGYuZ3JhZFwiLFwic3RyaW5nX29yX251bWVyaWNcIikscj1uIT1udWxsP0UobixcImR5XCIsXCJ0Zi5ncmFkXCIpOm51bGw7cmV0dXJuIFAudGlkeSgoKT0+e2xldHt2YWx1ZTpzLGdyYWRzOml9PVAuZ3JhZGllbnRzKCgpPT5lKGEpLFthXSxyKTtyZXR1cm4gciE9bnVsbCYmTm4ocy5zaGFwZSxyLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkKGYpKHgsIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKHgpXCIpLEhtKGkpLGlbMF19KX19ZnVuY3Rpb24gTDMoZSl7cmV0dXJuIEEoc3MoZSksKCk9PlwiVGhlIGYgcGFzc2VkIGluIGdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwiKSwodCxuKT0+e0EoQXJyYXkuaXNBcnJheSh0KSwoKT0+XCJUaGUgYXJncyBwYXNzZWQgaW4gZ3JhZHMoZikoYXJncykgbXVzdCBiZSBhbiBhcnJheSBvZiBgVGVuc29yYHMgb3IgYFRlbnNvckxpa2Vgc1wiKTtsZXQgYT1iYyh0LFwiYXJnc1wiLFwidGYuZ3JhZHNcIixcInN0cmluZ19vcl9udW1lcmljXCIpLHI9biE9bnVsbD9FKG4sXCJkeVwiLFwidGYuZ3JhZHNcIik6bnVsbDtyZXR1cm4gUC50aWR5KCgpPT57bGV0e3ZhbHVlOnMsZ3JhZHM6aX09UC5ncmFkaWVudHMoKCk9PmUoLi4uYSksYSxyKTtyZXR1cm4gciE9bnVsbCYmTm4ocy5zaGFwZSxyLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pXCIpLEhtKGkpLGl9KX19ZnVuY3Rpb24gejMoZSl7cmV0dXJuIEEoc3MoZSksKCk9PlwiVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIiksKHQsbik9PntBKHQgaW5zdGFuY2VvZiBDZSwoKT0+XCJUaGUgeCBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgpIG11c3QgYmUgYSB0ZW5zb3JcIiksQShuPT1udWxsfHxuIGluc3RhbmNlb2YgQ2UsKCk9PlwiVGhlIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCwgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIik7bGV0e2dyYWRzOmEsdmFsdWU6cn09UC5ncmFkaWVudHMoKCk9PmUodCksW3RdLG4pO3JldHVybiBIbShhKSx7Z3JhZDphWzBdLHZhbHVlOnJ9fX1mdW5jdGlvbiBXMyhlKXtyZXR1cm4gQShzcyhlKSwoKT0+XCJUaGUgZiBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIiksKHQsbik9PntBKEFycmF5LmlzQXJyYXkodCkmJnQuZXZlcnkocj0+ciBpbnN0YW5jZW9mIENlKSwoKT0+XCJUaGUgYXJncyBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzKSBtdXN0IGJlIGFycmF5IG9mIHRlbnNvcnNcIiksQShuPT1udWxsfHxuIGluc3RhbmNlb2YgQ2UsKCk9PlwiVGhlIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKGFyZ3MsIGR5KSBtdXN0IGJlIGEgdGVuc29yXCIpO2xldCBhPVAuZ3JhZGllbnRzKCgpPT5lKC4uLnQpLHQsbik7cmV0dXJuIG4hPW51bGwmJk5uKGEudmFsdWUuc2hhcGUsbi5zaGFwZSxcIlRoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgbWF0Y2ggdGhlIHNoYXBlIHJldHVybmVkIGJ5IGYoW3gxLC4uLl0pXCIpLEhtKGEuZ3JhZHMpLGF9fWZ1bmN0aW9uIE9OKGUsdCl7QShzcyhlKSwoKT0+XCJUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb25cIiksQSh0PT1udWxsfHxBcnJheS5pc0FycmF5KHQpJiZ0LmV2ZXJ5KHU9PnUgaW5zdGFuY2VvZiBvcyksKCk9PlwiVGhlIHZhckxpc3QgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZiwgdmFyTGlzdCkgbXVzdCBiZSBhbiBhcnJheSBvZiB2YXJpYWJsZXNcIik7bGV0IG49dCE9bnVsbDtpZighbil7dD1bXTtmb3IobGV0IHUgaW4gUC5yZWdpc3RlcmVkVmFyaWFibGVzKXQucHVzaChQLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdV0pfWxldCBhPW4/dC5maWx0ZXIodT0+IXUudHJhaW5hYmxlKTpudWxsLHI9dC5sZW5ndGg7dD10LmZpbHRlcih1PT51LnRyYWluYWJsZSksQSh0Lmxlbmd0aD4wLCgpPT5gdmFyaWFibGVHcmFkcygpIGV4cGVjdHMgYXQgbGVhc3Qgb25lIG9mIHRoZSBpbnB1dCB2YXJpYWJsZXMgdG8gYmUgdHJhaW5hYmxlLCBidXQgbm9uZSBvZiB0aGUgJHtyfSB2YXJpYWJsZXMgaXMgdHJhaW5hYmxlLmApO2xldCBzPSEwLHt2YWx1ZTppLGdyYWRzOm99PVAuZ3JhZGllbnRzKGUsdCxudWxsLHMpO0Eoby5zb21lKHU9PnUhPW51bGwpLCgpPT5cIkNhbm5vdCBmaW5kIGEgY29ubmVjdGlvbiBiZXR3ZWVuIGFueSB2YXJpYWJsZSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgbG9zcyBmdW5jdGlvbiB5PWYoeCkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIG9wZXJhdGlvbnMgdGhhdCB1c2UgdmFyaWFibGVzIGFyZSBpbnNpZGUgdGhlIGZ1bmN0aW9uIGYgcGFzc2VkIHRvIG1pbmltaXplKCkuXCIpLEEoaS5yYW5rPT09MCwoKT0+YFRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgcmV0dXJuIGEgc2NhbGFyLCBidXQgaXQgcmV0dXJuZWQgYSByYW5rLSR7aS5yYW5rfSB0ZW5zb3JgKTtsZXQgbD17fTtyZXR1cm4gdC5mb3JFYWNoKCh1LHApPT57b1twXSE9bnVsbCYmKGxbdS5uYW1lXT1vW3BdKX0pLGEhPW51bGwmJmEuZm9yRWFjaCh1PT5sW3UubmFtZV09bnVsbCkse3ZhbHVlOmksZ3JhZHM6bH19ZnVuY3Rpb24gcHIoZSl7cmV0dXJuIFAuY3VzdG9tR3JhZChlKX1mdW5jdGlvbiBIbShlKXtpZihlLmZpbHRlcih0PT50PT1udWxsKS5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb21wdXRlIGdyYWRpZW50IG9mIHk9Zih4KSB3aXRoIHJlc3BlY3QgdG8geC4gTWFrZSBzdXJlIHRoYXRcbiAgICB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5gKX1mdW5jdGlvbiBCMyhlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJuZWdcIil9O3JldHVybiBQLnJ1bktlcm5lbChDdSx0KX12YXIgeXQ9TCh7bmVnXzpCM30pO2Z1bmN0aW9uIFYzKGUpe2xldCB0PXt4OkUoZSxcInhcIixcInNvZnRwbHVzXCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoT28sdCl9dmFyIEdvPUwoe3NvZnRwbHVzXzpWM30pO2Z1bmN0aW9uIFUzKGUpe2xldCB0PUUoZSxcInhcIixcImxvZ1NpZ21vaWRcIik7cmV0dXJuIHByKG49Pih7dmFsdWU6eXQoR28oeXQobikpKSxncmFkRnVuYzphPT56KGEsaGEoeXQobikpKX0pKSh0KX12YXIgYnc9TCh7bG9nU2lnbW9pZF86VTN9KTtmdW5jdGlvbiBHMyhlLHQpe2xldCBuPUUoZSxcImFcIixcInN1YlwiKSxhPUUodCxcImJcIixcInN1YlwiKTtbbixhXT1fdChuLGEpO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwoQm8scil9dmFyIHBlPUwoe3N1Yl86RzN9KTtmdW5jdGlvbiBIMyhlLHQ9LTEpe2xldCBuPUUoZSxcImxvZ2l0c1wiLFwibG9nU29mdG1heFwiKTtpZih0PT09LTEmJih0PW4ucmFuay0xKSx0IT09bi5yYW5rLTEpdGhyb3cgRXJyb3IoYExvZyBTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgJHtuLnJhbmt9IGFuZCBheGlzIHdhcyAke3R9YCk7cmV0dXJuIHByKChhLHIpPT57bGV0IHM9bWEoYSx0LCEwKSxpPXBlKGEscyksbz1wZShyZShpLFwiZmxvYXQzMlwiKSxRbihmZShkbihpKSx0LCEwKSkpO3JldHVybiByKFtvXSkse3ZhbHVlOm8sZ3JhZEZ1bmM6KGwsdSk9PntsZXRbcF09dSxkPSEwLGM9ZG4ocCk7cmV0dXJuIHBlKGwseihmZShsLHQsZCksYykpfX19KShuKX12YXIgam09TCh7bG9nU29mdG1heF86SDN9KTtmdW5jdGlvbiBqMyhlLHQ9bnVsbCxuPSExKXtsZXQgYT1FKGUsXCJ4XCIsXCJsb2dTdW1FeHBcIikscj1BYSh0LGEuc2hhcGUpLHM9bWEoYSxyLCEwKSxpPXBlKGEscyksbz1kbihpKSxsPWZlKG8sciksdT1RbihsKSxwPVgoVyhzLHUuc2hhcGUpLHUpO2lmKG4pe2xldCBkPW1pKHAuc2hhcGUscik7cmV0dXJuIFcocCxkKX1yZXR1cm4gcH12YXIgY2Q9TCh7bG9nU3VtRXhwXzpqM30pO2Z1bmN0aW9uIHEzKGUsdCl7bGV0IG49RShlLFwiYVwiLFwibG9naWNhbEFuZFwiLFwiYm9vbFwiKSxhPUUodCxcImJcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIik7Y3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKHd1LHIpfXZhciBfYT1MKHtsb2dpY2FsQW5kXzpxM30pO2Z1bmN0aW9uIEszKGUpe2xldCB0PXt4OkUoZSxcInhcIixcImxvZ2ljYWxOb3RcIixcImJvb2xcIil9O3JldHVybiBQLnJ1bktlcm5lbChrdSx0KX12YXIgZGQ9TCh7bG9naWNhbE5vdF86SzN9KTtmdW5jdGlvbiBYMyhlLHQpe2xldCBuPUUoZSxcImFcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKSxhPUUodCxcImJcIixcImxvZ2ljYWxPclwiLFwiYm9vbFwiKTtjdChuLnNoYXBlLGEuc2hhcGUpO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwoSXUscil9dmFyIHFtPUwoe2xvZ2ljYWxPcl86WDN9KTtmdW5jdGlvbiBZMyhlLHQpe2xldCBuPUUoZSxcImFcIixcImxvZ2ljYWxYb3JcIixcImJvb2xcIiksYT1FKHQsXCJiXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpO3JldHVybiBjdChuLnNoYXBlLGEuc2hhcGUpLF9hKHFtKGUsdCksZGQoX2EoZSx0KSkpfXZhciB5dz1MKHtsb2dpY2FsWG9yXzpZM30pLHZoPTIxNDc0ODM2NDg7ZnVuY3Rpb24gWjMoZSx0LG49XCJsZWZ0XCIpe2xldCBhPUUoZSxcInNvcnRlZFNlcXVlbmNlXCIsXCJzZWFyY2hTb3J0ZWRcIikscj1FKHQsXCJ2YWx1ZXNcIixcInNlYXJjaFNvcnRlZFwiKSxzPWEuc2hhcGVbYS5zaGFwZS5sZW5ndGgtMV0saT1yLnNoYXBlW3Iuc2hhcGUubGVuZ3RoLTFdLG89VyhhLFstMSxzXSksbD1XKHIsWy0xLGldKTtpZihvLnJhbms8Mil0aHJvdyBuZXcgRXJyb3IoXCJTb3J0ZWQgaW5wdXQgYXJndW1lbnQgbXVzdCBiZSBhdCBsZWFzdCAyLWRpbWVuc2lvbmFsXCIpO2lmKG8uc2hhcGVbMF0hPT1sLnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcIkxlYWRpbmcgZGltZW5zaW9uIG9mICdzb3J0ZWRTZXF1ZW5jZScgYW5kICd2YWx1ZXMnIG11c3QgbWF0Y2guXCIpO2lmKG90KGwuc2hhcGUpPj12aCl0aHJvdyBuZXcgRXJyb3IoYHZhbHVlcyB0ZW5zb3Igc2l6ZSBtdXN0IGxlc3MgdGhhbiAke3ZofWApO2lmKG8uc2hhcGVbMV0+PXZoKXRocm93IG5ldyBFcnJvcihgdHJhaWxpbmcgZGltX3NpemUgbXVzdCBsZXNzIHRoYW4gJHt2aH0gZm9yIGludDMyIG91dHB1dCB0eXBlLCB3YXMgJHtvLnNoYXBlWzFdfWApO2xldCB1PXtzb3J0ZWRTZXF1ZW5jZTpvLHZhbHVlczpsfSxwPXtzaWRlOm59O3JldHVybiBQLnJ1bktlcm5lbCh6dSx1LHApfXZhciBLbT1MKHtzZWFyY2hTb3J0ZWRfOlozfSk7ZnVuY3Rpb24gUE4oZSx0KXtyZXR1cm4gS20oZSx0LFwibGVmdFwiKX1mdW5jdGlvbiBKMyhlLHQsbixhLHIpe2xldCBzPUUoZSxcInhcIixcIm1heFBvb2xcIiksaT0xLG89cyxsPSExO3MucmFuaz09PTMmJihsPSEwLG89VyhzLFsxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdXSkpLEEoby5yYW5rPT09NCwoKT0+YEVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayAke28ucmFua30uYCksQShkcihuLGkpLCgpPT5gRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtufSBhbmQgZGlsYXRpb25zICcke2l9J2ApLFRuKFwibWF4UG9vbFwiLGEscik7bGV0IHU9e3g6b30scD17ZmlsdGVyU2l6ZTp0LHN0cmlkZXM6bixwYWQ6YSxkaW1Sb3VuZGluZ01vZGU6cn0sZD1QLnJ1bktlcm5lbChwbyx1LHApO3JldHVybiBsP1coZCxbZC5zaGFwZVsxXSxkLnNoYXBlWzJdLGQuc2hhcGVbM11dKTpkfXZhciBEdD1MKHttYXhQb29sXzpKM30pO2Z1bmN0aW9uIFEzKGUsdD1bMSwxLDFdLG4sYSxyLHM9XCJOREhXQ1wiKXtsZXQgaT1FKGUsXCJ4XCIsXCJtYXhQb29sM2RcIiksbz1pLGw9ITE7aS5yYW5rPT09NCYmKGw9ITAsbz1XKGksWzEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0saS5zaGFwZVszXV0pKSxBKG8ucmFuaz09PTUsKCk9PmBFcnJvciBpbiBtYXhQb29sM2Q6IHggbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rICR7by5yYW5rfS5gKSxBKHM9PT1cIk5ESFdDXCIsKCk9PmBFcnJvciBpbiBtYXhQb29sM2Q6IE9ubHkgTkRIV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZCwgYnV0IGdvdCBkYXRhRm9ybWF0IG9mICR7c31gKSxUbihcIm1heFBvb2wzZFwiLGEscik7bGV0IHU9e3g6b30scD17ZmlsdGVyU2l6ZTp0LHN0cmlkZXM6bixwYWQ6YSxkaW1Sb3VuZGluZ01vZGU6cixkYXRhRm9ybWF0OnN9LGQ9UC5ydW5LZXJuZWwoTnUsdSxwKTtyZXR1cm4gbD9XKGQsW2Quc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdLGQuc2hhcGVbNF1dKTpkfXZhciB4dz1MKHttYXhQb29sM2RfOlEzfSk7ZnVuY3Rpb24gZUwoZSx0LG4sYSxyPSExKXtsZXQgcz17eDpFKGUsXCJ4XCIsXCJtYXhQb29sV2l0aEFyZ21heFwiKX0saT17ZmlsdGVyU2l6ZTp0LHN0cmlkZXM6bixwYWQ6YSxpbmNsdWRlQmF0Y2hJbkluZGV4OnJ9LG89UC5ydW5LZXJuZWwoVmMscyxpKTtyZXR1cm57cmVzdWx0Om9bMF0saW5kZXhlczpvWzFdfX12YXIgTE49TCh7bWF4UG9vbFdpdGhBcmdtYXhfOmVMfSk7ZnVuY3Rpb24gdEwoZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJtYXhpbXVtXCIpLGE9RSh0LFwiYlwiLFwibWF4aW11bVwiKTtbbixhXT1fdChuLGEpLG4uZHR5cGU9PT1cImJvb2xcIiYmKG49cmUobixcImludDMyXCIpLGE9cmUoYSxcImludDMyXCIpKSxjdChuLnNoYXBlLGEuc2hhcGUpO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwodW8scil9dmFyIGhyPUwoe21heGltdW1fOnRMfSk7ZnVuY3Rpb24gbkwoZSx0PW51bGwsbj0hMSl7bGV0IGE9e3g6RShlLFwieFwiLFwibWVhblwiKX0scj17YXhpczp0LGtlZXBEaW1zOm59O3JldHVybiBQLnJ1bktlcm5lbChjbyxhLHIpfXZhciBDdD1MKHttZWFuXzpuTH0pO2Z1bmN0aW9uIEl0KGUsdD1cImZsb2F0MzJcIil7aWYobmEoZSksdD09PVwiY29tcGxleDY0XCIpe2xldCBhPUl0KGUsXCJmbG9hdDMyXCIpLHI9SXQoZSxcImZsb2F0MzJcIik7cmV0dXJuIF9yKGEscil9bGV0IG49eG0ob3QoZSksdCk7cmV0dXJuIFAubWFrZVRlbnNvcihuLGUsdCl9ZnVuY3Rpb24gUG4oZSx0PVwiZmxvYXQzMlwiKXtpZihuYShlKSx0PT09XCJjb21wbGV4NjRcIil7bGV0IGE9UG4oZSxcImZsb2F0MzJcIikscj1JdChlLFwiZmxvYXQzMlwiKTtyZXR1cm4gX3IoYSxyKX1sZXQgbj1OdihvdChlKSx0KTtyZXR1cm4gUC5tYWtlVGVuc29yKG4sZSx0KX1mdW5jdGlvbiB6TihlLHQse2luZGV4aW5nOm49XCJ4eVwifT17fSl7aWYobiE9PVwieHlcIiYmbiE9PVwiaWpcIil0aHJvdyBuZXcgVHlwZUVycm9yKGAke259IGlzIG5vdCBhIHZhbGlkIHRoaXJkIGFyZ3VtZW50IHRvIG1lc2hncmlkYCk7aWYoZT09PXZvaWQgMClyZXR1cm5bXTtsZXQgYT1FKGUsXCJ4XCIsXCJtZXNoZ3JpZFwiLGUgaW5zdGFuY2VvZiBDZT9lLmR0eXBlOlwiZmxvYXQzMlwiKTtpZih0PT09dm9pZCAwKXJldHVyblthXTtsZXQgcj1FKHQsXCJ5XCIsXCJtZXNoZ3JpZFwiLHQgaW5zdGFuY2VvZiBDZT90LmR0eXBlOlwiZmxvYXQzMlwiKSxzPW90KGEuc2hhcGUpLGk9b3Qoci5zaGFwZSk7cmV0dXJuIG49PT1cInh5XCI/KGE9VyhhLFsxLC0xXSkscj1XKHIsWy0xLDFdKSxbJGUoUG4oW2ksMV0sYS5kdHlwZSksYSksJGUocixQbihbMSxzXSxyLmR0eXBlKSldKTooYT1XKGEsWy0xLDFdKSxyPVcocixbMSwtMV0pLFskZShhLFBuKFsxLGldLGEuZHR5cGUpKSwkZShQbihbcywxXSxyLmR0eXBlKSxyKV0pfWZ1bmN0aW9uIGFMKGUsdCl7bGV0IG49RShlLFwiYVwiLFwibWluaW11bVwiKSxhPUUodCxcImJcIixcIm1pbmltdW1cIik7W24sYV09X3QobixhKSxuLmR0eXBlPT09XCJib29sXCImJihuPXJlKG4sXCJpbnQzMlwiKSxhPXJlKGEsXCJpbnQzMlwiKSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKG1vLHIpfXZhciBkcz1MKHttaW5pbXVtXzphTH0pO2Z1bmN0aW9uIHJMKGUsdCxuKXtBKG49PT1cInJlZmxlY3RcInx8bj09PVwic3ltbWV0cmljXCIsKCk9PmBJbnZhbGlkIG1vZGUuIE1vZGUgbXVzdCBiZSBlaXRoZXIgcmVmbGVjdCBvciBzeW1tZXRyaWMuIEdvdCAke259LmApO2xldCBhPUUoZSxcInhcIixcIm1pcnJvclBhZFwiKTtpZihhLnJhbms9PT0wKXRocm93IG5ldyBFcnJvcihcIm1pcnJvclBhZChzY2FsYXIpIGlzIG5vdCBkZWZpbmVkLiBQYXNzIG5vbi1zY2FsYXIgdG8gbWlycm9yUGFkXCIpO0EodC5sZW5ndGg9PT1hLnJhbmssKCk9PmBQYWRkaW5nIGRvZXNuJ3QgbWF0Y2ggaW5wdXQuIE11c3QgYmUgJHthLnJhbmt9LiBHb3QgJHt0Lmxlbmd0aH0uYCk7bGV0IHI9bj09PVwicmVmbGVjdFwiPzE6MDtmb3IobGV0IG89MDtvPGEucmFuaztvKyspQSh0W29dLmxlbmd0aD09PTIsKCk9PlwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIiksQSh0W29dWzBdPj0wJiZ0W29dWzBdPD1hLnNoYXBlW29dLXImJnRbb11bMV0+PTAmJnRbb11bMV08PWEuc2hhcGVbb10tciwoKT0+YFBhZGRpbmcgaW4gZGltZW5zaW9uICR7b30gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2Euc2hhcGVbb10tcn0gb3IgbGVzcyB0aGFuIDAgZm9yIGlucHV0IG9mIHNoYXBlICR7YS5zaGFwZX1gKTtsZXQgcz17cGFkZGluZ3M6dCxtb2RlOm59LGk9e3g6YX07cmV0dXJuIFAucnVuS2VybmVsKGZvLGkscyl9dmFyIHZ3PUwoe21pcnJvclBhZF86ckx9KTtmdW5jdGlvbiBzTChlLHQpe2xldCBuPUUoZSxcImFcIixcIm1vZFwiKSxhPUUodCxcImJcIixcIm1vZFwiKTtbbixhXT1fdChuLGEpO2xldCByPXthOm4sYjphfTtyZXR1cm4gUC5ydW5LZXJuZWwoZ28scil9dmFyIHd3PUwoe21vZF86c0x9KTtmdW5jdGlvbiBpTChlLHQ9bnVsbCxuPSExKXtlPUUoZSxcInhcIixcIm1vbWVudHNcIik7bGV0IGE9QWEodCxlLnNoYXBlKSxyPUN0KGUsYSxuKSxzPXIuc2hhcGU7bnx8KHM9bWkoci5zaGFwZSxhKSk7bGV0IGk9cHQocGUocmUoZSxcImZsb2F0MzJcIiksVyhyLHMpKSksbz1DdChpLGEsbik7cmV0dXJue21lYW46cix2YXJpYW5jZTpvfX12YXIgaGQ9TCh7bW9tZW50c186aUx9KTtmdW5jdGlvbiBvTChlLHQsbixhKXtsZXQgcj1FKHQsXCJkYXRhXCIsXCJtdWx0aVJOTkNlbGxcIikscz1iYyhuLFwiY1wiLFwibXVsdGlSTk5DZWxsXCIpLGk9YmMoYSxcImhcIixcIm11bHRpUk5OQ2VsbFwiKSxvPXIsbD1bXTtmb3IobGV0IGQ9MDtkPGUubGVuZ3RoO2QrKyl7bGV0IGM9ZVtkXShvLHNbZF0saVtkXSk7bC5wdXNoKGNbMF0pLGwucHVzaChjWzFdKSxvPWNbMV19bGV0IHU9W10scD1bXTtmb3IobGV0IGQ9MDtkPGwubGVuZ3RoO2QrPTIpdS5wdXNoKGxbZF0pLHAucHVzaChsW2QrMV0pO3JldHVyblt1LHBdfXZhciBXTj1MKHttdWx0aVJOTkNlbGxfOm9MfSk7ZnVuY3Rpb24gbEwoZSx0LG4sYT0hMSl7bGV0IHI9RShlLFwibG9naXRzXCIsXCJtdWx0aW5vbWlhbFwiKSxzPXIuc2l6ZSxpPXIucmFuaztpZihzPDIpdGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBtdWx0aW5vbWlhbDogeW91IG5lZWQgYXQgbGVhc3QgMiBvdXRjb21lcywgYnV0IGdvdCAke3N9LmApO2lmKGk+Mil0aHJvdyBuZXcgRXJyb3IoYFJhbmsgb2YgcHJvYmFiaWxpdGllcyBtdXN0IGJlIDEgb3IgMiwgYnV0IGlzICR7aX1gKTtuPW58fE1hdGgucmFuZG9tKCk7bGV0IG89e2xvZ2l0czppPT09MT9XKHIsWzEsLTFdKTpyfSxsPXtudW1TYW1wbGVzOnQsc2VlZDpuLG5vcm1hbGl6ZWQ6YX0sdT1QLnJ1bktlcm5lbChUdSxvLGwpO3JldHVybiBpPT09MT9XKHUsW3Uuc2l6ZV0pOnV9dmFyIEJOPUwoe211bHRpbm9taWFsXzpsTH0pO2Z1bmN0aW9uIHVMKGUsdCl7bGV0IG49RShlLFwiYVwiLFwibm90RXF1YWxcIixcInN0cmluZ19vcl9udW1lcmljXCIpLGE9RSh0LFwiYlwiLFwibm90RXF1YWxcIixcInN0cmluZ19vcl9udW1lcmljXCIpO1tuLGFdPV90KG4sYSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX07cmV0dXJuIFAucnVuS2VybmVsKEV1LHIpfXZhciBmaT1MKHtub3RFcXVhbF86dUx9KTtmdW5jdGlvbiBwTChlLHQsbj0xLGE9MCxyPVwiaW50MzJcIil7aWYodDwyKXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzICR7dH1gKTtsZXQgcz17aW5kaWNlczpFKGUsXCJpbmRpY2VzXCIsXCJvbmVIb3RcIixcImludDMyXCIpfSxpPXtkdHlwZTpyLGRlcHRoOnQsb25WYWx1ZTpuLG9mZlZhbHVlOmF9O3JldHVybiBQLnJ1bktlcm5lbCh5byxzLGkpfXZhciBMbD1MKHtvbmVIb3RfOnBMfSk7ZnVuY3Rpb24gY0woZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwib25lc0xpa2VcIil9O3JldHVybiBQLnJ1bktlcm5lbCgkdSx0KX12YXIgZWE9TCh7b25lc0xpa2VfOmNMfSk7ZnVuY3Rpb24gZEwoZSx0KXtsZXQgbj1FKGUsXCJ2MVwiLFwib3V0ZXJQcm9kdWN0XCIpLGE9RSh0LFwidjJcIixcIm91dGVyUHJvZHVjdFwiKTtBKG4ucmFuaz09PTEmJmEucmFuaz09PTEsKCk9PmBFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyAke24ucmFua30gYW5kICR7YS5yYW5rfS5gKTtsZXQgcj1XKG4sWy0xLDFdKSxzPVcoYSxbMSwtMV0pO3JldHVybiAkZShyLHMpfXZhciBWTj1MKHtvdXRlclByb2R1Y3RfOmRMfSk7ZnVuY3Rpb24gaEwoZSx0LG49MCl7bGV0IGE9RShlLFwieFwiLFwicGFkXCIpO2lmKGEucmFuaz09PTApdGhyb3cgbmV3IEVycm9yKFwicGFkKHNjYWxhcikgaXMgbm90IGRlZmluZWQuIFBhc3Mgbm9uLXNjYWxhciB0byBwYWRcIik7bGV0IHI9e3BhZGRpbmdzOnQsY29uc3RhbnRWYWx1ZTpufSxzPXt4OmF9O3JldHVybiBQLnJ1bktlcm5lbCh4byxzLHIpfXZhciB4YT1MKHtwYWRfOmhMfSk7ZnVuY3Rpb24gbUwoZSx0LG49MCl7cmV0dXJuIEEodC5sZW5ndGg9PT0yLCgpPT5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyLlwiKSx4YShlLFt0XSxuKX12YXIgVU49TCh7cGFkMWRfOm1MfSk7ZnVuY3Rpb24gZkwoZSx0LG49MCl7cmV0dXJuIEEodC5sZW5ndGg9PT0yJiZ0WzBdLmxlbmd0aD09PTImJnRbMV0ubGVuZ3RoPT09MiwoKT0+XCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwiKSx4YShlLHQsbil9dmFyIEdOPUwoe3BhZDJkXzpmTH0pO2Z1bmN0aW9uIGdMKGUsdCxuPTApe3JldHVybiBBKHQubGVuZ3RoPT09MyYmdFswXS5sZW5ndGg9PT0yJiZ0WzFdLmxlbmd0aD09PTImJnRbMl0ubGVuZ3RoPT09MiwoKT0+XCJJbnZhbGlkIG51bWJlciBvZiBwYWRkaW5ncy4gTXVzdCBiZSBsZW5ndGggb2YgMiBlYWNoLlwiKSx4YShlLHQsbil9dmFyIEhOPUwoe3BhZDNkXzpnTH0pO2Z1bmN0aW9uIGJMKGUsdCxuPTApe3JldHVybiBBKHQubGVuZ3RoPT09NCYmdFswXS5sZW5ndGg9PT0yJiZ0WzFdLmxlbmd0aD09PTImJnRbMl0ubGVuZ3RoPT09MiYmdFszXS5sZW5ndGg9PT0yLCgpPT5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCIpLHhhKGUsdCxuKX12YXIgak49TCh7cGFkNGRfOmJMfSk7ZnVuY3Rpb24geUwoZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInNwYWNlVG9CYXRjaE5EXCIpO0EoYS5yYW5rPj0xK3QubGVuZ3RoLCgpPT5gaW5wdXQgcmFuayAke2EucmFua30gc2hvdWxkIGJlID4gdGhhbiBbYmxvY2tTaGFwZV0gJHt0Lmxlbmd0aH1gKSxBKG4ubGVuZ3RoPT09dC5sZW5ndGgsKCk9PmBwYWRkaW5ncy5zaGFwZVswXSAke24ubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvIFtibG9ja1NoYXBlXSAke3QubGVuZ3RofWApLEEoYS5zaGFwZS5yZWR1Y2UoKGksbyxsKT0+bD4wJiZsPD10Lmxlbmd0aD9pJiYobytuW2wtMV1bMF0rbltsLTFdWzFdKSV0W2wtMV09PT0wOmksITApLCgpPT5gaW5wdXQgc3BhdGlhbCBkaW1lbnNpb25zICR7YS5zaGFwZS5zbGljZSgxKX0gd2l0aCBwYWRkaW5ncyAke24udG9TdHJpbmcoKX0gbXVzdCBiZSBkaXZpc2libGUgYnkgYmxvY2tTaGFwZXMgJHt0LnRvU3RyaW5nKCl9YCk7bGV0IHI9e3g6YX0scz17YmxvY2tTaGFwZTp0LHBhZGRpbmdzOm59O3JldHVybiBQLnJ1bktlcm5lbChWdSxyLHMpfXZhciBtZD1MKHtzcGFjZVRvQmF0Y2hORF86eUx9KTtmdW5jdGlvbiB4TChlLHQsbixhLHIscyxpKXtyPT1udWxsJiYocj1bMSwxXSkscz09bnVsbCYmKHM9MSksYT09PTAmJihhPVwidmFsaWRcIik7bGV0IG89RShlLFwieFwiLFwibWF4UG9vbFwiKSxsPW8sdT0hMTtvLnJhbms9PT0zJiYodT0hMCxsPVcobyxbMSxvLnNoYXBlWzBdLG8uc2hhcGVbMV0sby5zaGFwZVsyXV0pKSxBKGRyKHMsciksKCk9PmBFcnJvciBpbiBwb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke3N9IGFuZCBkaWxhdGlvbnMgJyR7cn0nYCk7bGV0IHA9d04obC5zaGFwZSx0LHMscixhKSxkPVtwLmRpbGF0aW9uSGVpZ2h0LHAuZGlsYXRpb25XaWR0aF0sYzthPT09XCJzYW1lXCI/Yz13TChbcC5maWx0ZXJIZWlnaHQscC5maWx0ZXJXaWR0aF0sZCk6Yz1bWzAsMF0sWzAsMF1dO2xldCBoPWRbMF09PT0xJiZkWzFdPT09MSxbbSxmXT12TChbcC5pbkhlaWdodCxwLmluV2lkdGhdLGQsYyksZz1oP2E6XCJ2YWxpZFwiLGI9aD9sOm1kKGwsZCxtKSx5PShuPT09XCJhdmdcIj8oKT0+eWEoYix0LHMsZyxpKTooKT0+RHQoYix0LHMsZyxpKSkoKSx4PWg/eTppZCh5LGQsZik7cmV0dXJuIHU/Vyh4LFt4LnNoYXBlWzFdLHguc2hhcGVbMl0seC5zaGFwZVszXV0pOnh9ZnVuY3Rpb24gdkwoZSx0LG4pe2xldCBhPW4ubWFwKHA9PnBbMF0pLHI9bi5tYXAocD0+cFsxXSkscz1lLmNvbmNhdChhLHIpLGk9dC5tYXAoKHAsZCk9PihwLXNbZF0lcCklcCksbz1yLm1hcCgocCxkKT0+cCtpW2RdKSxsPXQubWFwKChwLGQpPT5bYVtkXSxvW2RdXSksdT10Lm1hcCgocCxkKT0+WzAsaVtkXV0pO3JldHVybltsLHVdfWZ1bmN0aW9uIHdMKGUsdCl7bGV0IG49ZS5tYXAoKHMsaSk9PnMrKHMtMSkqKHRbaV0tMSkpLm1hcChzPT5zLTEpLGE9bi5tYXAocz0+TWF0aC5mbG9vcihzLzIpKSxyPW4ubWFwKChzLGkpPT5zLWFbaV0pO3JldHVybiBuLm1hcCgocyxpKT0+W2FbaV0scltpXV0pfXZhciBrdz1MKHtwb29sXzp4TH0pO2Z1bmN0aW9uIGtMKGUsdCl7bGV0IG49RShlLFwieFwiLFwicHJlbHVcIiksYT1FKHQsXCJhbHBoYVwiLFwicHJlbHVcIikscj17eDpuLGFscGhhOmF9O3JldHVybiBQLnJ1bktlcm5lbCh3byxyKX12YXIgZmQ9TCh7cHJlbHVfOmtMfSk7ZnVuY3Rpb24gSUwoZSx0PW51bGwsbj0hMSl7bGV0IGE9RShlLFwieFwiLFwicHJvZFwiKTthLmR0eXBlPT09XCJib29sXCImJihhPXJlKGEsXCJpbnQzMlwiKSk7bGV0IHI9e3g6YX0scz17YXhpczp0LGtlZXBEaW1zOm59O3JldHVybiBQLnJ1bktlcm5lbChrbyxyLHMpfXZhciBJdz1MKHtwcm9kXzpJTH0pO2Z1bmN0aW9uIFNMKGUsdCxuLGEpe2xldCByPWUubWFwKChwLGQpPT5FKHAsYHRlbnNvcnMke2R9YCxcInJhZ2dlZEdhdGhlclwiLFwiaW50MzJcIikpLHM9RSh0LFwicGFyYW1zRGVuc2VWYWx1ZXNcIixcInJhZ2dlZEdhdGhlclwiKSxpPUUobixcImluZGljZXNcIixcInJhZ2dlZEdhdGhlclwiLFwiaW50MzJcIiksbz17cGFyYW1zTmVzdGVkU3BsaXRzOnIscGFyYW1zRGVuc2VWYWx1ZXM6cyxpbmRpY2VzOml9LGw9e291dHB1dFJhZ2dlZFJhbms6YX0sdT1QLnJ1bktlcm5lbChBbSxvLGwpO3JldHVybntvdXRwdXROZXN0ZWRTcGxpdHM6dS5zbGljZSgwLHUubGVuZ3RoLTEpLG91dHB1dERlbnNlVmFsdWVzOnVbdS5sZW5ndGgtMV19fXZhciBxTj1MKHtyYWdnZWRHYXRoZXJfOlNMfSk7ZnVuY3Rpb24gTkwoZSx0LG4pe2xldCBhPUUoZSxcInN0YXJ0c1wiLFwicmFnZ2VkUmFuZ2VcIikscj1FKHQsXCJsaW1pdHNcIixcInJhZ2dlZFJhbmdlXCIsYS5kdHlwZSkscz1FKG4sXCJkZWx0YXNcIixcInJhZ2dlZFJhbmdlXCIsYS5kdHlwZSksaT17c3RhcnRzOmEsbGltaXRzOnIsZGVsdGFzOnN9LG89UC5ydW5LZXJuZWwoRm0saSk7cmV0dXJue3J0TmVzdGVkU3BsaXRzOm9bMF0scnREZW5zZVZhbHVlczpvWzFdfX12YXIgS049TCh7cmFnZ2VkUmFuZ2VfOk5MfSk7ZnVuY3Rpb24gVEwoZSx0LG4sYSxyKXtsZXQgcz1FKGUsXCJzaGFwZVwiLFwicmFnZ2VkVGVuc29yVG9UZW5zb3JcIixcImludDMyXCIpLGk9RSh0LFwidmFsdWVzXCIsXCJyYWdnZWRUZW5zb3JUb1RlbnNvclwiKSxvPUUobixcImRlZmF1bHRWYWx1ZVwiLFwicmFnZ2VkVGVuc29yVG9UZW5zb3JcIixpLmR0eXBlKSxsPWEubWFwKChkLGMpPT5FKGQsYHRlbnNvcnMke2N9YCxcInJhZ2dlZFRlbnNvclRvVGVuc29yXCIsXCJpbnQzMlwiKSksdT17c2hhcGU6cyx2YWx1ZXM6aSxkZWZhdWx0VmFsdWU6byxyb3dQYXJ0aXRpb25UZW5zb3JzOmx9LHA9e3Jvd1BhcnRpdGlvblR5cGVzOnJ9O3JldHVybiBQLnJ1bktlcm5lbCgkbSx1LHApfXZhciBYTj1MKHtyYWdnZWRUZW5zb3JUb1RlbnNvcl86VEx9KTtmdW5jdGlvbiBDTChlLHQsbil7bmEoZSk7bGV0IGE9b3QoZSkscj1udWxsO2lmKG49PW51bGx8fG49PT1cImZsb2F0MzJcIilyPW5ldyBGbG9hdDMyQXJyYXkoYSk7ZWxzZSBpZihuPT09XCJpbnQzMlwiKXI9bmV3IEludDMyQXJyYXkoYSk7ZWxzZSBpZihuPT09XCJib29sXCIpcj1uZXcgVWludDhBcnJheShhKTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGUgJHtufWApO2ZvcihsZXQgcz0wO3M8YTtzKyspcltzXT10KCk7cmV0dXJuIFAubWFrZVRlbnNvcihyLGUsbil9dmFyIFlOPUwoe3JhbmRfOkNMfSksU3c9eHMoYm0oKSksWk49e307X2UoWk4se1RFU1RfRVBTSUxPTl9GTE9BVDE2OigpPT5KTixjcmVhdGVWaWRlb0VsZW1lbnQ6KCk9Pk1MLGVuY29kZVN0cmluZ3M6KCk9PlFOLGV4cGVjdEFycmF5QnVmZmVyc0VxdWFsOigpPT5STCxleHBlY3RBcnJheXNDbG9zZTooKT0+X0wsZXhwZWN0QXJyYXlzRXF1YWw6KCk9PkZMLGV4cGVjdE51bWJlcnNDbG9zZTooKT0+JEwsZXhwZWN0UHJvbWlzZVRvRmFpbDooKT0+QUwsZXhwZWN0VmFsdWVzSW5SYW5nZTooKT0+REwscGxheTooKT0+T0wsdGVzdEVwc2lsb246KCk9Pk53fSk7dmFyIEVMPS4wMDEsSk49LjE7ZnVuY3Rpb24gX0woZSx0LG4pe3JldHVybiBuPT1udWxsJiYobj1OdygpKSxSeChlLHQsKGEscik9PlR3KGEscixuKSl9ZnVuY3Rpb24gTncoKXtyZXR1cm4gUC5iYWNrZW5kLmZsb2F0UHJlY2lzaW9uKCk9PT0zMj9FTDpKTn1mdW5jdGlvbiBSeChlLHQsbil7bGV0IGE9ITA7aWYoKGVuKGUpfHxlbih0KSkmJihhPSExKSxlbihlKSYmZW4odCkmJihhPSEwKSxhKXtsZXQgaT1lLmNvbnN0cnVjdG9yLm5hbWUsbz10LmNvbnN0cnVjdG9yLm5hbWU7aWYoaSE9PW8pdGhyb3cgbmV3IEVycm9yKGBBcnJheXMgYXJlIG9mIGRpZmZlcmVudCB0eXBlLiBBY3R1YWw6ICR7aX0uIEV4cGVjdGVkOiAke299YCl9aWYoQXJyYXkuaXNBcnJheShlKSYmQXJyYXkuaXNBcnJheSh0KSl7bGV0IGk9bHIoZSksbz1scih0KTtpZighQXIoaSxvKSl0aHJvdyBuZXcgRXJyb3IoYEFycmF5cyBoYXZlIGRpZmZlcmVudCBzaGFwZXMuIEFjdHVhbDogWyR7aX1dLiBFeHBlY3RlZDogWyR7b31dYCl9bGV0IHI9ZW4oZSk/ZTppcyhlKSxzPWVuKHQpP3Q6aXModCk7aWYoci5sZW5ndGghPT1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEFycmF5cyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzIGFjdHVhbDogJHtyLmxlbmd0aH0gdnMgZXhwZWN0ZWQ6ICR7cy5sZW5ndGh9LlxuQWN0dWFsOiAgICR7cn0uXG5FeHBlY3RlZDogJHtzfS5gKTtmb3IobGV0IGk9MDtpPHMubGVuZ3RoOysraSl7bGV0IG89cltpXSxsPXNbaV07aWYoIW4obyxsKSl0aHJvdyBuZXcgRXJyb3IoYEFycmF5cyBkaWZmZXI6IGFjdHVhbFske2l9XSA9ICR7b30sIGV4cGVjdGVkWyR7aX1dID0gJHtsfS5cbkFjdHVhbDogICAke3J9LlxuRXhwZWN0ZWQ6ICR7c30uYCl9dHlwZW9mIGV4cGVjdCE9XCJ1bmRlZmluZWRcIiYmZXhwZWN0KCkubm90aGluZygpfWZ1bmN0aW9uIEFMKGUsdCl7ZSgpLnRoZW4oKCk9PnQuZmFpbCgpLCgpPT50KCkpLHR5cGVvZiBleHBlY3QhPVwidW5kZWZpbmVkXCImJmV4cGVjdCgpLm5vdGhpbmcoKX1mdW5jdGlvbiBGTChlLHQpe2xldCBuPXR5cGVvZiB0PT1cInN0cmluZ1wifHx0eXBlb2YgdD09XCJudW1iZXJcInx8dHlwZW9mIHQ9PVwiYm9vbGVhblwiP1t0XTp0O3JldHVybiBKcihlKXx8SnIoZVswXSl8fEpyKHQpfHxKcih0WzBdKT9SeChlLG4sKGEscik9PmE9PXIpOlJ4KGUsdCwoYSxyKT0+VHcoYSxyLDApKX1mdW5jdGlvbiAkTChlLHQsbil7aWYobj09bnVsbCYmKG49TncoKSksIVR3KGUsdCxuKSl0aHJvdyBuZXcgRXJyb3IoYE51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09ICR7ZX0sIGV4cGVjdGVkID09PSAke3R9YCk7dHlwZW9mIGV4cGVjdCE9XCJ1bmRlZmluZWRcIiYmZXhwZWN0KCkubm90aGluZygpfWZ1bmN0aW9uIFR3KGUsdCxuKXtyZXR1cm4haXNGaW5pdGUoZSkmJiFpc0Zpbml0ZSh0KT8hMDohKGlzTmFOKGUpfHxpc05hTih0KXx8TWF0aC5hYnMoZS10KT5uKX1mdW5jdGlvbiBETChlLHQsbil7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKyspaWYoZVthXTx0fHxlW2FdPm4pdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBvdXQgb2YgcmFuZ2U6JHtlW2FdfSBsb3c6ICR7dH0sIGhpZ2g6ICR7bn1gKX1mdW5jdGlvbiBSTChlLHQpe2xldCBuPW5ldyBGbG9hdDMyQXJyYXkoZSksYT1uZXcgRmxvYXQzMkFycmF5KHQpO2lmKG4ubGVuZ3RoIT09YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBBcnJheUJ1ZmZlciB0byBiZSBvZiBsZW5ndGggJHthLmxlbmd0aH0sIGJ1dCBpdCB3YXMgJHtuLmxlbmd0aH1gKTtmb3IobGV0IHI9MDtyPGEubGVuZ3RoO3IrKylpZihuW3JdIT09YVtyXSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEFycmF5QnVmZmVyIHZhbHVlIGF0ICR7cn0gdG8gYmUgJHthW3JdfSBidXQgZ290ICR7bltyXX0gaW5zdGVhZGApfWZ1bmN0aW9uIFFOKGUpe2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtsZXQgbj1lW3RdO0FycmF5LmlzQXJyYXkobik/UU4obik6ZVt0XT1uZChuKX1yZXR1cm4gZX1mdW5jdGlvbiBNTChlKXtsZXQgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7cmV0dXJuXCJwbGF5c0lubGluZVwiaW4gdCYmKHQucGxheXNJbmxpbmU9ITApLHQubXV0ZWQ9ITAsdC5sb29wPSEwLHQuc3R5bGUucG9zaXRpb249XCJmaXhlZFwiLHQuc3R5bGUubGVmdD1cIjBweFwiLHQuc3R5bGUudG9wPVwiMHB4XCIsdC5wcmVsb2FkPVwiYXV0b1wiLHQuYXBwZW5kQ2hpbGQoZSksbmV3IFByb21pc2Uobj0+e3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIixhPT5uKHQpKSx0LmxvYWQoKX0pfWFzeW5jIGZ1bmN0aW9uIE9MKGUpe2F3YWl0IGUucGxheSgpLFwicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFja1wiaW4gZSYmYXdhaXQgbmV3IFByb21pc2UodD0+e2UucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayh0KX0pfXZhciBDdz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIpe3RoaXMubWVhbj1lLHRoaXMuc3RkRGV2PXQsdGhpcy5kdHlwZT1uLHRoaXMubmV4dFZhbD1OYU4sdGhpcy50cnVuY2F0ZWQ9YSx0aGlzLnRydW5jYXRlZCYmKHRoaXMudXBwZXI9dGhpcy5tZWFuK3RoaXMuc3RkRGV2KjIsdGhpcy5sb3dlcj10aGlzLm1lYW4tdGhpcy5zdGREZXYqMik7bGV0IHM9cnx8TWF0aC5yYW5kb20oKTt0aGlzLnJhbmRvbT1Tdy5hbGVhKHMudG9TdHJpbmcoKSl9bmV4dFZhbHVlKCl7aWYoIWlzTmFOKHRoaXMubmV4dFZhbCkpe2xldCBhPXRoaXMubmV4dFZhbDtyZXR1cm4gdGhpcy5uZXh0VmFsPU5hTixhfWxldCBlLHQsbj0hMTtmb3IoOyFuOyl7bGV0IGEscixzO2RvIGE9Mip0aGlzLnJhbmRvbSgpLTEscj0yKnRoaXMucmFuZG9tKCktMSxzPWEqYStyKnI7d2hpbGUocz49MXx8cz09PTApO2xldCBpPU1hdGguc3FydCgtMipNYXRoLmxvZyhzKS9zKTtlPXRoaXMubWVhbit0aGlzLnN0ZERldiphKmksdD10aGlzLm1lYW4rdGhpcy5zdGREZXYqcippLCghdGhpcy50cnVuY2F0ZWR8fHRoaXMuaXNWYWxpZFRydW5jYXRlZChlKSkmJihuPSEwKX1yZXR1cm4oIXRoaXMudHJ1bmNhdGVkfHx0aGlzLmlzVmFsaWRUcnVuY2F0ZWQodCkpJiYodGhpcy5uZXh0VmFsPXRoaXMuY29udmVydFZhbHVlKHQpKSx0aGlzLmNvbnZlcnRWYWx1ZShlKX1jb252ZXJ0VmFsdWUoZSl7cmV0dXJuIHRoaXMuZHR5cGU9PW51bGx8fHRoaXMuZHR5cGU9PT1cImZsb2F0MzJcIj9lOk1hdGgucm91bmQoZSl9aXNWYWxpZFRydW5jYXRlZChlKXtyZXR1cm4gZTw9dGhpcy51cHBlciYmZT49dGhpcy5sb3dlcn19LFBMPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEpe3RoaXMuYWxwaGE9ZSx0aGlzLmJldGE9MS90LHRoaXMuZHR5cGU9bjtsZXQgcj1hfHxNYXRoLnJhbmRvbSgpO3RoaXMucmFuZHU9U3cuYWxlYShyLnRvU3RyaW5nKCkpLHRoaXMucmFuZG49bmV3IEN3KDAsMSxuLCExLHRoaXMucmFuZHUoKSksZTwxP3RoaXMuZD1lKzIvMzp0aGlzLmQ9ZS0xLzMsdGhpcy5jPTEvTWF0aC5zcXJ0KDkqdGhpcy5kKX1uZXh0VmFsdWUoKXtsZXQgZSx0LG4sYSxyLHM7Zm9yKDs7KXtkbyBhPXRoaXMucmFuZG4ubmV4dFZhbHVlKCkscz0xK3RoaXMuYyphO3doaWxlKHM8PTApO2lmKHMqPXMqcyxlPWEqYSx0PTEtLjMzMSplKmUsbj0uNSplK3RoaXMuZCooMS1zK01hdGgubG9nKHMpKSxyPXRoaXMucmFuZHUoKSxyPHR8fE1hdGgubG9nKHIpPG4pYnJlYWt9cmV0dXJuIHM9MS90aGlzLmJldGEqdGhpcy5kKnMsdGhpcy5hbHBoYTwxJiYocyo9TWF0aC5wb3codGhpcy5yYW5kdSgpLDEvdGhpcy5hbHBoYSkpLHRoaXMuY29udmVydFZhbHVlKHMpfWNvbnZlcnRWYWx1ZShlKXtyZXR1cm4gdGhpcy5kdHlwZT09PVwiZmxvYXQzMlwiP2U6TWF0aC5yb3VuZChlKX19LExMPWNsYXNze2NvbnN0cnVjdG9yKGU9MCx0PTEsbixhKXtpZih0aGlzLmNhblJldHVybkZsb2F0PSgpPT50aGlzLmR0eXBlPT1udWxsfHx0aGlzLmR0eXBlPT09XCJmbG9hdDMyXCIsdGhpcy5taW49ZSx0aGlzLnJhbmdlPXQtZSx0aGlzLmR0eXBlPW4sYT09bnVsbCYmKGE9TWF0aC5yYW5kb20oKSksdHlwZW9mIGE9PVwibnVtYmVyXCImJihhPWEudG9TdHJpbmcoKSksIXRoaXMuY2FuUmV0dXJuRmxvYXQoKSYmdGhpcy5yYW5nZTw9MSl0aHJvdyBuZXcgRXJyb3IoYFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJHtlfSAtICR7dH0gPD0gMSBhbmQgZHR5cGUgaXMgbm90IGZsb2F0YCk7dGhpcy5yYW5kb209U3cuYWxlYShhKX1jb252ZXJ0VmFsdWUoZSl7cmV0dXJuIHRoaXMuY2FuUmV0dXJuRmxvYXQoKT9lOk1hdGgucm91bmQoZSl9bmV4dFZhbHVlKCl7cmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHRoaXMubWluK3RoaXMucmFuZ2UqdGhpcy5yYW5kb20oKSl9fTtmdW5jdGlvbiB6TChlLHQsbj0xLGE9XCJmbG9hdDMyXCIscil7aWYobmEoZSksbj09bnVsbCYmKG49MSksYT09bnVsbCYmKGE9XCJmbG9hdDMyXCIpLGEhPT1cImZsb2F0MzJcIiYmYSE9PVwiaW50MzJcIil0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZSAke2F9YCk7bGV0IHM9bmV3IFBMKHQsbixhLHIpLGk9T2UoZSxhKTtmb3IobGV0IG89MDtvPGkudmFsdWVzLmxlbmd0aDtvKyspaS52YWx1ZXNbb109cy5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfXZhciBlVD1MKHtyYW5kb21HYW1tYV86ekx9KTtmdW5jdGlvbiBXTChlLHQ9MCxuPTEsYSxyKXtpZihuYShlKSxhIT1udWxsJiZhPT09XCJib29sXCIpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGUgJHthfWApO2xldCBzPW5ldyBDdyh0LG4sYSwhMSxyKSxpPU9lKGUsYSk7Zm9yKGxldCBvPTA7bzxpLnZhbHVlcy5sZW5ndGg7bysrKWkudmFsdWVzW29dPXMubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX12YXIgWG09TCh7cmFuZG9tTm9ybWFsXzpXTH0pO2Z1bmN0aW9uIEJMKGUsdCxuKXtpZih0IT1udWxsJiZ0PT09XCJib29sXCIpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGUgJHt0fWApO3JldHVybiBYbShlLDAsMSx0LG4pfXZhciB0VD1MKHtyYW5kb21TdGFuZGFyZE5vcm1hbF86Qkx9KTtmdW5jdGlvbiBWTChlLHQ9MCxuPTEsYT1cImZsb2F0MzJcIixyKXtuYShlKTtsZXQgcz1PZShlLGEpLGk9bmV3IExMKHQsbixudWxsLHIpO2ZvcihsZXQgbz0wO288cy52YWx1ZXMubGVuZ3RoO28rKylzLnZhbHVlc1tvXT1pLm5leHRWYWx1ZSgpO3JldHVybiBzLnRvVGVuc29yKCl9dmFyIEVzPUwoe3JhbmRvbVVuaWZvcm1fOlZMfSk7ZnVuY3Rpb24gVUwoZSx0LG4sYSl7cmV0dXJuIEVzKGUsdCxuLFwiaW50MzJcIixhKX12YXIgblQ9TCh7cmFuZG9tVW5pZm9ybUludF86VUx9KTtmdW5jdGlvbiBnaShlLHQsbj0xLGE9XCJmbG9hdDMyXCIpe2lmKG49PT0wKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGEgc3RlcCBvZiB6ZXJvXCIpO2xldCByPXtzdGFydDplLHN0b3A6dCxzdGVwOm4sZHR5cGU6YX07cmV0dXJuIFAucnVuS2VybmVsKFVjLHt9LHIpfWZ1bmN0aW9uIEdMKGUpe2xldCB0PXtpbnB1dDpFKGUsXCJpbnB1dFwiLFwicmVhbFwiKX07cmV0dXJuIFAucnVuS2VybmVsKERtLHQpfXZhciB6bD1MKHtyZWFsXzpHTH0pO2Z1bmN0aW9uIEhMKGUpe2xldCB0PXt4OkUoZSxcInhcIixcInJlY2lwcm9jYWxcIil9O3JldHVybiBQLnJ1bktlcm5lbChJbyx0KX12YXIgRXc9TCh7cmVjaXByb2NhbF86SEx9KTtmdW5jdGlvbiBqTChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJyZWx1XCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoU28sdCl9dmFyIEtlPUwoe3JlbHVfOmpMfSk7ZnVuY3Rpb24gcUwoZSl7bGV0IHQ9e3g6RShlLFwieFwiLFwicmVsdTZcIil9O3JldHVybiBQLnJ1bktlcm5lbChDbyx0KX12YXIgWW09TCh7cmVsdTZfOnFMfSk7ZnVuY3Rpb24gS0woZSx0KXtsZXQgbj17eDpFKGUsXCJ4XCIsXCJyZXZlcnNlXCIpfSxhPXtkaW1zOnR9O3JldHVybiBQLnJ1bktlcm5lbChFbyxuLGEpfXZhciBiYT1MKHtyZXZlcnNlXzpLTH0pO2Z1bmN0aW9uIFhMKGUpe2xldCB0PUUoZSxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEEodC5yYW5rPT09MSwoKT0+YEVycm9yIGluIHJldmVyc2UxRDogeCBtdXN0IGJlIHJhbmsgMSBidXQgZ290IHJhbmsgJHt0LnJhbmt9LmApLGJhKHQsMCl9dmFyIGFUPUwoe3JldmVyc2UxZF86WEx9KTtmdW5jdGlvbiBZTChlLHQpe2xldCBuPUUoZSxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEEobi5yYW5rPT09MiwoKT0+YEVycm9yIGluIHJldmVyc2UyRDogeCBtdXN0IGJlIHJhbmsgMiBidXQgZ290IHJhbmsgJHtuLnJhbmt9LmApLGJhKG4sdCl9dmFyIHJUPUwoe3JldmVyc2UyZF86WUx9KTtmdW5jdGlvbiBaTChlLHQpe2xldCBuPUUoZSxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEEobi5yYW5rPT09MywoKT0+YEVycm9yIGluIHJldmVyc2UzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgJHtuLnJhbmt9LmApLGJhKG4sdCl9dmFyIHNUPUwoe3JldmVyc2UzZF86Wkx9KTtmdW5jdGlvbiBKTChlLHQpe2xldCBuPUUoZSxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEEobi5yYW5rPT09NCwoKT0+YEVycm9yIGluIHJldmVyc2U0RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtuLnJhbmt9LmApLGJhKG4sdCl9dmFyIGlUPUwoe3JldmVyc2U0ZF86Skx9KTtmdW5jdGlvbiBRTChlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJyb3VuZFwiKX07cmV0dXJuIFAucnVuS2VybmVsKF9vLHQpfXZhciBabT1MKHtyb3VuZF86UUx9KTtmdW5jdGlvbiBleihlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJyc3FydFwiLFwiZmxvYXQzMlwiKX07cmV0dXJuIFAucnVuS2VybmVsKEFvLHQpfXZhciBKbT1MKHtyc3FydF86ZXp9KTtmdW5jdGlvbiB0eihlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJzZWx1XCIpfTtyZXR1cm4gUC5ydW5LZXJuZWwoRm8sdCl9dmFyIFFtPUwoe3NlbHVfOnR6fSk7ZnVuY3Rpb24gbnooZSx0LG4sYSxyLHM9WzEsMV0saT1cIk5IV0NcIil7bGV0IG89RShlLFwieFwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGw9RSh0LFwiZGVwdGh3aXNlRmlsdGVyXCIsXCJzZXBhcmFibGVDb252MmRcIiksdT1FKG4sXCJwb2ludHdpc2VGaWx0ZXJcIixcInNlcGFyYWJsZUNvbnYyZFwiKSxwPW8sZD0hMTtpZihvLnJhbms9PT0zJiYoZD0hMCxwPVcobyxbMSxvLnNoYXBlWzBdLG8uc2hhcGVbMV0sby5zaGFwZVsyXV0pKSxpPT09XCJOQ0hXXCIpdGhyb3cgbmV3IEVycm9yKFwic2VwYXJhYmxlQ29udjJkIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQgTkNIVzsgb25seSBOSFdDIGlzIHN1cHBvcnRlZFwiKTtBKHAucmFuaz09PTQsKCk9PmBFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgJHtwLnJhbmt9LmApLEEobC5yYW5rPT09NCwoKT0+YEVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogZGVwdGh3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSxBKHUucmFuaz09PTQsKCk9PmBFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksQSh1LnNoYXBlWzBdPT09MSwoKT0+YEVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgJHt1LnNoYXBlWzBdfS5gKSxBKHUuc2hhcGVbMV09PT0xLCgpPT5gRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgc2Vjb25kIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgMSwgYnV0IGdvdCAke3Uuc2hhcGVbMV19LmApO2xldCBjPWwuc2hhcGVbMl0saD1sLnNoYXBlWzNdO0EodS5zaGFwZVsyXT09PWMqaCwoKT0+YEVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHRoaXJkIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgJHtjKmh9LCBidXQgZ290ICR7dS5zaGFwZVsyXX0uYCk7bGV0IG09VHMocCxsLGEscixpLHMpLGY9JHQobSx1LDEsXCJ2YWxpZFwiLGkpO3JldHVybiBkP1coZixbZi5zaGFwZVsxXSxmLnNoYXBlWzJdLGYuc2hhcGVbM11dKTpmfXZhciBfcz1MKHtzZXBhcmFibGVDb252MmRfOm56fSk7YXN5bmMgZnVuY3Rpb24gYXooZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJzZXRkaWZmMWRcIiksYT1FKHQsXCJ5XCIsXCJzZXRkaWZmMWRcIik7QShuLmR0eXBlPT09YS5kdHlwZSwoKT0+YHggYW5kIHkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZHR5cGUsIGJ1dCBnb3QgeCAoJHtuLmR0eXBlfSkgYW5kIHkgKCR7YS5kdHlwZX0pLmApLEEobi5yYW5rPT09MSwoKT0+YHggc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB4ICgke24uc2hhcGV9KS5gKSxBKGEucmFuaz09PTEsKCk9PmB5IHNob3VsZCBiZSAxRCB0ZW5zb3IsIGJ1dCBnb3QgeSAoJHthLnNoYXBlfSkuYCk7bGV0IHI9YXdhaXQgbi5kYXRhKCkscz1hd2FpdCBhLmRhdGEoKSxpPW5ldyBTZXQocyksbz0wO2ZvcihsZXQgcD0wO3A8ci5sZW5ndGg7cCsrKWkuaGFzKHJbcF0pfHxvKys7bGV0IGw9bmV3IFd0KFtvXSxuLmR0eXBlKSx1PW5ldyBXdChbb10sXCJpbnQzMlwiKTtmb3IobGV0IHA9MCxkPTA7cDxyLmxlbmd0aDtwKyspaS5oYXMocltwXSl8fChsLnZhbHVlc1tkXT1yW3BdLHUudmFsdWVzW2RdPXAsZCsrKTtyZXR1cm5bbC50b1RlbnNvcigpLHUudG9UZW5zb3IoKV19dmFyIG9UPWF6O2Z1bmN0aW9uIHJ6KGUpe2xldCB0PXt4OkUoZSxcInhcIixcInNpZ25cIil9O3JldHVybiBQLnJ1bktlcm5lbChSbyx0KX12YXIgX3c9TCh7c2lnbl86cnp9KTtmdW5jdGlvbiBzeihlKXtsZXQgdD17eDpFKGUsXCJ4XCIsXCJzaW5cIixcImZsb2F0MzJcIil9O3JldHVybiBQLnJ1bktlcm5lbCgkbyx0KX12YXIgZWY9TCh7c2luXzpzen0pO2Z1bmN0aW9uIGl6KGUpe2xldCB0PXt4OkUoZSxcInhcIixcInNpbmhcIil9O3JldHVybiBQLnJ1bktlcm5lbChEbyx0KX12YXIgdGY9TCh7c2luaF86aXp9KTtmdW5jdGlvbiBveihlLHQsbil7bGV0IGE9RShlLFwieFwiLFwic2xpY2UxZFwiKTtyZXR1cm4gQShhLnJhbms9PT0xLCgpPT5gc2xpY2UxZCBleHBlY3RzIGEgcmFuay0xIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstJHthLnJhbmt9IHRlbnNvcmApLFZlKGEsW3RdLFtuXSl9dmFyIGdkPUwoe3NsaWNlMWRfOm96fSk7ZnVuY3Rpb24gbHooZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInNsaWNlMmRcIik7cmV0dXJuIEEoYS5yYW5rPT09MiwoKT0+YHNsaWNlMmQgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLSR7YS5yYW5rfSB0ZW5zb3JgKSxWZShhLHQsbil9dmFyIG5mPUwoe3NsaWNlMmRfOmx6fSk7ZnVuY3Rpb24gdXooZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInNsaWNlM2RcIik7cmV0dXJuIEEoYS5yYW5rPT09MywoKT0+YHNsaWNlM2QgZXhwZWN0cyBhIHJhbmstMyB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLSR7YS5yYW5rfSB0ZW5zb3JgKSxWZShhLHQsbil9dmFyIEhvPUwoe3NsaWNlM2RfOnV6fSk7ZnVuY3Rpb24gcHooZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInNsaWNlNGRcIik7cmV0dXJuIEEoYS5yYW5rPT09NCwoKT0+YHNsaWNlNGQgZXhwZWN0cyBhIHJhbmstNCB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLSR7YS5yYW5rfSB0ZW5zb3JgKSxWZShhLHQsbil9dmFyIFdsPUwoe3NsaWNlNGRfOnB6fSk7ZnVuY3Rpb24gY3ooZSx0PS0xKXtsZXQgbj1FKGUsXCJsb2dpdHNcIixcInNvZnRtYXhcIixcImZsb2F0MzJcIik7aWYodD09PS0xJiYodD1uLnJhbmstMSksdCE9PW4ucmFuay0xKXRocm93IEVycm9yKGBTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgJHtuLnJhbmt9IGFuZCBkaW0gd2FzICR7dH1gKTtsZXQgYT17bG9naXRzOm59LHI9e2RpbTp0fTtyZXR1cm4gUC5ydW5LZXJuZWwoem8sYSxyKX12YXIgcWE9TCh7c29mdG1heF86Y3p9KTtmdW5jdGlvbiBkeihlKXtBKGUuZHR5cGU9PT1cImNvbXBsZXg2NFwiLCgpPT5gVGhlIGR0eXBlIGZvciB0Zi5zcGVjdHJhbC5mZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290ICR7ZS5kdHlwZX0uYCk7bGV0IHQ9e2lucHV0OmV9O3JldHVybiBQLnJ1bktlcm5lbChDbSx0KX12YXIgYmQ9TCh7ZmZ0Xzpken0pO2Z1bmN0aW9uIGh6KGUpe0EoZS5kdHlwZT09PVwiY29tcGxleDY0XCIsKCk9PmBUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmlmZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290ICR7ZS5kdHlwZX0uYCk7bGV0IHQ9e2lucHV0OmV9O3JldHVybiBQLnJ1bktlcm5lbChFbSx0KX12YXIgQmw9TCh7aWZmdF86aHp9KTtmdW5jdGlvbiBteihlKXtsZXQgdD1lLnNoYXBlW2Uuc2hhcGUubGVuZ3RoLTFdLG49ZS5zaXplL3QsYTtpZih0PD0yKXtsZXQgcj1XKGUsW24sdF0pO2E9Qmwocil9ZWxzZXtsZXQgcj1bbiwyKih0LTEpXSxzPVcoemwoZSksW24sdF0pLGk9VyhsZChlKSxbbix0XSksbz1iYShWZShzLFswLDFdLFtuLHQtMl0pLDEpLGw9eihiYShWZShpLFswLDFdLFtuLHQtMl0pLDEpLHhlKC0xKSksdT1ldChbcyxvXSwxKSxwPWV0KFtpLGxdLDEpLGQ9Vyhfcih1LHApLFtyWzBdLHJbMV1dKTthPUJsKGQpfWlmKGE9emwoYSksZS5yYW5rPT09MyYmZS5zaGFwZVswXSE9PTApe2xldCByPWEscz1lLnNoYXBlWzBdO2E9VyhhLFtzLGEuc2hhcGVbMF0vcyxhLnNoYXBlWzFdXSksci5kaXNwb3NlKCl9cmV0dXJuIGF9dmFyIGFmPUwoe2lyZmZ0Xzpten0pO2Z1bmN0aW9uIGZ6KGUsdCxuPTApe2xldCBhPXt4OkUoZSxcInhcIixcInNwbGl0XCIpfSxyPXtudW1PclNpemVTcGxpdHM6dCxheGlzOm59O3JldHVybiBQLnJ1bktlcm5lbChVdSxhLHIpfXZhciBMbj1MKHtzcGxpdF86Znp9KTtmdW5jdGlvbiBneihlLHQpe0EoZS5kdHlwZT09PVwiZmxvYXQzMlwiLCgpPT5gVGhlIGR0eXBlIGZvciByZmZ0KCkgbXVzdCBiZSByZWFsIHZhbHVlIGJ1dCBnb3QgJHtlLmR0eXBlfWApO2xldCBuPWUuc2hhcGVbZS5zaGFwZS5sZW5ndGgtMV0sYT1lLnNpemUvbixyO2lmKHQhPW51bGwmJnQ8bil7bGV0IG09ZS5zaGFwZS5tYXAoZz0+MCksZj1lLnNoYXBlLm1hcChnPT5nKTtmW2Uuc2hhcGUubGVuZ3RoLTFdPXQscj1WZShlLG0sZiksbj10fWVsc2UgaWYodCE9bnVsbCYmdD5uKXtsZXQgbT1lLnNoYXBlLm1hcChmPT5mKTttW2Uuc2hhcGUubGVuZ3RoLTFdPXQtbixyPWV0KFtlLEl0KG0pXSxlLnNoYXBlLmxlbmd0aC0xKSxuPXR9ZWxzZSByPWU7bGV0IHM9cWUociksaT1XKF9yKHIscyksW2Esbl0pLG89YmQoaSksbD1NYXRoLmZsb29yKG4vMikrMSx1PXpsKG8pLHA9bGQobyksZD1Mbih1LFtsLG4tbF0sdS5zaGFwZS5sZW5ndGgtMSksYz1MbihwLFtsLG4tbF0scC5zaGFwZS5sZW5ndGgtMSksaD1yLnNoYXBlLnNsaWNlKCk7cmV0dXJuIGhbci5zaGFwZS5sZW5ndGgtMV09bCxXKF9yKGRbMF0sY1swXSksaCl9dmFyIHlkPUwoe3JmZnRfOmd6fSk7ZnVuY3Rpb24gYnooZSx0KXtsZXQgbj1FKGUsXCJhXCIsXCJzcXVhcmVkRGlmZmVyZW5jZVwiKSxhPUUodCxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpO1tuLGFdPV90KG4sYSksY3Qobi5zaGFwZSxhLnNoYXBlKTtsZXQgcj17YTpuLGI6YX0scz17fTtyZXR1cm4gUC5ydW5LZXJuZWwoV28scixzKX12YXIgcmY9TCh7c3F1YXJlZERpZmZlcmVuY2VfOmJ6fSk7ZnVuY3Rpb24geXooZSx0KXtsZXQgbj1FKGUsXCJ4XCIsXCJzcXVlZXplXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKTtyZXR1cm4gVyhuLE1TKG4uc2hhcGUsdCkubmV3U2hhcGUpfXZhciBBcz1MKHtzcXVlZXplXzp5en0pO2Z1bmN0aW9uIHh6KGUsdD0wKXtsZXQgbj1iYyhlLFwidGVuc29yc1wiLFwic3RhY2tcIixcInN0cmluZ19vcl9udW1lcmljXCIpO0Eobi5sZW5ndGg+PTEsKCk9PlwiUGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLnN0YWNrXCIpLG4ubGVuZ3RoPjAmJkEodDw9blswXS5yYW5rLCgpPT5cIkF4aXMgbXVzdCBiZSA8PSByYW5rIG9mIHRoZSB0ZW5zb3JcIik7bGV0IGE9bixyPXtheGlzOnR9O3JldHVybiBQLnJ1bktlcm5lbChEdSxhLHIpfXZhciBBdD1MKHtzdGFja186eHp9KTtmdW5jdGlvbiB2eihlLHQ9MCl7bGV0IG49e3g6RShlLFwieFwiLFwic3RlcFwiKX0sYT17YWxwaGE6dH07cmV0dXJuIFAucnVuS2VybmVsKElzLG4sYSl9dmFyIGpvPUwoe3N0ZXBfOnZ6fSk7ZnVuY3Rpb24gd3ooZSx0LG4sYSxyPTAscz0wLGk9MCxvPTAsbD0wKXtsZXQgdT17eDpFKGUsXCJ4XCIsXCJzdHJpZGVkU2xpY2VcIixcInN0cmluZ19vcl9udW1lcmljXCIpfSxwPXtiZWdpbjp0LGVuZDpuLHN0cmlkZXM6YSxiZWdpbk1hc2s6cixlbmRNYXNrOnMsZWxsaXBzaXNNYXNrOmksbmV3QXhpc01hc2s6byxzaHJpbmtBeGlzTWFzazpsfTtyZXR1cm4gUC5ydW5LZXJuZWwoanUsdSxwKX12YXIgQXc9TCh7c3RyaWRlZFNsaWNlXzp3en0pO2Z1bmN0aW9uIGt6KGUpe2xldCB0PXt4OkUoZSxcInhcIixcInRhblwiLFwiZmxvYXQzMlwiKX07cmV0dXJuIFAucnVuS2VybmVsKFZvLHQpfXZhciBGdz1MKHt0YW5fOmt6fSk7ZnVuY3Rpb24gamUoZSx0KXtTaShlKTtsZXQgbj1scihlLHQpO2lmKG4ubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IxZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gU3MoZSxudWxsLG4sdCl9ZnVuY3Rpb24gRWEoZSx0LG4pe2lmKFNpKGUpLHQhPW51bGwmJnQubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdHdvIG51bWJlcnNcIik7bGV0IGE9bHIoZSxuKTtpZihhLmxlbmd0aCE9PTImJmEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZihhLmxlbmd0aD09PTEmJnQ9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gU3MoZSx0LGEsbil9ZnVuY3Rpb24geGQoZSx0LG4pe2lmKFNpKGUpLHQhPW51bGwmJnQubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IzZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdGhyZWUgbnVtYmVyc1wiKTtsZXQgYT1scihlLG4pO2lmKGEubGVuZ3RoIT09MyYmYS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgdmFsdWVzIHRvIGJlIG51bWJlcltdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoYS5sZW5ndGg9PT0xJiZ0PT1udWxsKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBTcyhlLHQsYSxuKX1mdW5jdGlvbiBGYShlLHQsbil7aWYoU2koZSksdCE9bnVsbCYmdC5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmb3VyIG51bWJlcnNcIik7bGV0IGE9bHIoZSxuKTtpZihhLmxlbmd0aCE9PTQmJmEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXSBvciBmbGF0L1R5cGVkQXJyYXlcIik7aWYoYS5sZW5ndGg9PT0xJiZ0PT1udWxsKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjRkKCkgcmVxdWlyZXMgc2hhcGUgdG8gYmUgcHJvdmlkZWQgd2hlbiBgdmFsdWVzYCBhcmUgYSBmbGF0IGFycmF5XCIpO3JldHVybiBTcyhlLHQsYSxuKX1mdW5jdGlvbiBsVChlLHQsbil7aWYoU2koZSksdCE9bnVsbCYmdC5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmaXZlIG51bWJlcnNcIik7bGV0IGE9bHIoZSxuKTtpZihhLmxlbmd0aCE9PTUmJmEubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZihhLmxlbmd0aD09PTEmJnQ9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIFNzKGUsdCxhLG4pfWZ1bmN0aW9uIHVUKGUsdCxuKXtpZihTaShlKSx0IT1udWxsJiZ0Lmxlbmd0aCE9PTYpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBoYXZlIHNpeCBudW1iZXJzXCIpO2xldCBhPWxyKGUsbik7aWYoYS5sZW5ndGghPT02JiZhLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZihhLmxlbmd0aD09PTEmJnQ9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIHQ9dHx8YSxTcyhlLHQsYSxuKX12YXIgc2Y9e307X2Uoc2Yse2NhbGN1bGF0ZVNoYXBlczooKT0+cFQsdmFsaWRhdGVJbnB1dDooKT0+b2YsdmFsaWRhdGVVcGRhdGVTaGFwZTooKT0+JHd9KTtmdW5jdGlvbiAkdyhlLHQsbil7bGV0IGE9dC5yYW5rPjE/dC5zaGFwZVt0LnJhbmstMV06MSxyPXQucmFuaz4xP3QucmFuay0xOjEscz1gTXVzdCBoYXZlIHVwZGF0ZXMuc2hhcGUgPSBpbmRpY2VzLnNoYXBlWzpiYXRjaERpbV0gKyBzaGFwZVtzbGljZURpbTpdLCBnb3QgdXBkYXRlcy5zaGFwZTogJHtuLnNoYXBlfSwgaW5kaWNlcy5zaGFwZTogJHt0LnNoYXBlfSwgc2hhcGU6ICR7ZX0sIHNsaWNlRGltOiAke2F9LCBhbmQgYmF0Y2hEaW06ICR7cn0uYDtpZihuLnJhbms8cil0aHJvdyBuZXcgRXJyb3IocytgIHVwZGF0ZS5yYW5rIDwgJHtyfS4gYCk7aWYoZS5sZW5ndGg8YSsobi5yYW5rLXIpKXRocm93IG5ldyBFcnJvcihzK2AgT3V0cHV0IHNoYXBlIGxlbmd0aCA8ICR7YSsobi5yYW5rLXIpfWApO2lmKG4ucmFuayE9PXIrZS5sZW5ndGgtYSl0aHJvdyBuZXcgRXJyb3IocytgIHVwZGF0ZS5yYW5rICE9ICR7citlLmxlbmd0aC1hfWApO2ZvcihsZXQgaT0wO2k8cjsrK2kpaWYobi5zaGFwZVtpXSE9PXQuc2hhcGVbaV0pdGhyb3cgbmV3IEVycm9yKHMrYCB1cGRhdGVzLnNoYXBlWyR7aX1dICgke24uc2hhcGVbaV19KSAhPSBpbmRpY2VzLnNoYXBlWyR7aX1dICgke3Quc2hhcGVbaV19KS5gKTtmb3IobGV0IGk9MDtpPG4ucmFuay1yOysraSlpZihuLnNoYXBlW2krcl0hPT1lW2krYV0pdGhyb3cgbmV3IEVycm9yKHMrYCB1cGRhdGVzLnNoYXBlWyR7aStyfV0gKCR7bi5zaGFwZVtpK3JdfSkgIT0gc2hhcGVbJHtpK3J9XSAoJHtlW2krcl19KWApfWZ1bmN0aW9uIG9mKGUsdCxuKXtpZih0LnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoYHRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyAke3QucmFua30uYCk7aWYoZS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKGB0Zi5zY2F0dGVyTkQoKSBleHBlY3RzIHRoZSB1cGRhdGVzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgJHtlLnJhbmt9LmApO2lmKHQuZHR5cGUhPT1cImludDMyXCIpdGhyb3cgbmV3IEVycm9yKGBUaGUgZHR5cGUgb2YgJ2luZGljZXMnIHNob3VsZCBiZSBpbnQzMiwgYnV0IGdvdCBkdHlwZTogJHt0LmR0eXBlfWApO2lmKG4ubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgcmFuayBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMSwgYnV0IGdvdCBzaGFwZTogJHtufWApO2lmKG4ubGVuZ3RoPT09MCl7aWYodC5zaXplPT09MCl0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIGluZGljZXMgc2hhcGU6ICR7dC5zaGFwZX1gKTtpZihlLnNpemU9PT0wKXRocm93IG5ldyBFcnJvcihgVXBkYXRlcyBzcGVjaWZpZWQgZm9yIGVtcHR5IG91dHB1dC4gdXBkYXRlcyBzaGFwZTogJHtlLnNoYXBlfWApfSR3KG4sdCxlKX1mdW5jdGlvbiBwVChlLHQsbil7bGV0IGE9dC5zaGFwZS5sZW5ndGgscj1hPjE/dC5zaGFwZVthLTFdOjEscz1uLmxlbmd0aCxpPTE7Zm9yKGxldCBkPXI7ZDxzOysrZClpKj1uW2RdO2xldCBvPXI8MT8xOnIsbD1vdCh0LnNoYXBlKS9vLHU9Wy4uLlhsKG4uc2xpY2UoMCxyKSksMV0scD1vdChuKTtyZXR1cm57c2xpY2VSYW5rOnIsbnVtVXBkYXRlczpsLHNsaWNlU2l6ZTppLHN0cmlkZXM6dSxvdXRwdXRTaXplOnB9fWZ1bmN0aW9uIEl6KGUsdCxuKXtsZXQgYT1FKGUsXCJ0ZW5zb3JcIixcInRlbnNvclNjYXR0ZXJ1cGRhdGVcIikscj1FKHQsXCJpbmRpY2VzXCIsXCJ0ZW5zb3JTY2F0dGVydXBkYXRlXCIsXCJpbnQzMlwiKSxzPUUobixcInVwZGF0ZXNcIixcInRlbnNvclNjYXR0ZXJ1cGRhdGVcIik7aWYob2YocyxyLGEuc2hhcGUpLGEuZHR5cGUhPT1zLmR0eXBlKXRocm93IG5ldyBFcnJvcihgdGVuc29yIGFuZCB1cGRhdGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZSwgaW5zdGVhZCB0aGV5IGFyZSAke2EuZHR5cGV9IGFuZCAke3MuZHR5cGV9LmApO2xldCBpPXt0ZW5zb3I6YSxpbmRpY2VzOnIsdXBkYXRlczpzfSxvPXt9O3JldHVybiBQLnJ1bktlcm5lbChMdSxpLG8pfXZhciBjVD1MKHt0ZW5zb3JTY2F0dGVyVXBkYXRlXzpJen0pO2Z1bmN0aW9uIFN6KGUsdD0xLG49ITApe2xldCBhPUUoZSxcInhcIixcInRvcGtcIik7aWYoYS5yYW5rPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ0b3BrKCkgZXhwZWN0cyB0aGUgaW5wdXQgdG8gYmUgb2YgcmFuayAxIG9yIGhpZ2hlclwiKTtsZXQgcj1hLnNoYXBlW2Euc2hhcGUubGVuZ3RoLTFdO2lmKHQ8MCl0aHJvdyBuZXcgRXJyb3IoYCdrJyBwYXNzZWQgdG8gdG9waygpIG11c3QgYmUgPj0gMCBidXQgZ290ICR7dH1gKTtpZih0PnIpdGhyb3cgbmV3IEVycm9yKGAnaycgcGFzc2VkIHRvIHRvcGsoKSBtdXN0IGJlIDw9IHRoZSBsYXN0IGRpbWVuc2lvbiAoJHtyfSkgYnV0IGdvdCAke3R9YCk7bGV0IHM9e3g6YX0saT17azp0LHNvcnRlZDpufSxbbyxsXT1QLnJ1bktlcm5lbChxdSxzLGkpO3JldHVybnt2YWx1ZXM6byxpbmRpY2VzOmx9fXZhciBEdz1MKHt0b3BrXzpTen0pO2Z1bmN0aW9uIE56KGUsdD0wLG49MSxhLHIpe2lmKG5hKGUpLGEhPW51bGwmJmE9PT1cImJvb2xcIil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUgJCB7IGR0eXBlIH1cIik7bGV0IHM9bmV3IEN3KHQsbixhLCEwLHIpLGk9T2UoZSxhKTtmb3IobGV0IG89MDtvPGkudmFsdWVzLmxlbmd0aDtvKyspaS52YWx1ZXNbb109cy5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfXZhciBsZj1MKHt0cnVuY2F0ZWROb3JtYWxfOk56fSk7ZnVuY3Rpb24gVHooZSx0PTApe2xldCBuPUUoZSxcInhcIixcInVuaXF1ZVwiLFwic3RyaW5nX29yX251bWVyaWNcIik7QShuLnJhbms+MCwoKT0+XCJUaGUgaW5wdXQgdGVuc29yIG11c3QgYmUgYXQgbGVhc3QgMURcIik7bGV0IGE9e3g6bn0scj17YXhpczp0fSxbcyxpXT1QLnJ1bktlcm5lbChKYyxhLHIpO3JldHVybnt2YWx1ZXM6cyxpbmRpY2VzOml9fXZhciBSdz1MKHt1bmlxdWVfOlR6fSk7ZnVuY3Rpb24gQ3ooZSx0LG4pe2xldCBhPUUoZSxcInhcIixcInVuc29ydGVkU2VnbWVudFN1bVwiKSxyPUUodCxcInNlZ21lbnRJZHNcIixcInVuc29ydGVkU2VnbWVudFN1bVwiLFwiaW50MzJcIik7QSgkbChuKSwoKT0+XCJudW1TZWdtZW50cyBtdXN0IGJlIG9mIGR0eXBlIGludFwiKTtsZXQgcz17eDphLHNlZ21lbnRJZHM6cn0saT17bnVtU2VnbWVudHM6bn07cmV0dXJuIFAucnVuS2VybmVsKFFjLHMsaSl9dmFyIHVmPUwoe3Vuc29ydGVkU2VnbWVudFN1bV86Q3p9KTtmdW5jdGlvbiBFeihlLHQ9MCl7bGV0IG49RShlLFwieFwiLFwidW5zdGFja1wiLFwic3RyaW5nX29yX251bWVyaWNcIik7QSh0Pj0tbi5zaGFwZS5sZW5ndGgmJnQ8bi5zaGFwZS5sZW5ndGgsKCk9PmBBeGlzID0gJHt0fSBpcyBub3QgaW4gWy0ke24uc2hhcGUubGVuZ3RofSwgJHtuLnNoYXBlLmxlbmd0aH0pYCk7bGV0IGE9e3ZhbHVlOm59LHI9e2F4aXM6dH07cmV0dXJuIFAucnVuS2VybmVsKFh1LGEscil9dmFyIGR0PUwoe3Vuc3RhY2tfOkV6fSk7ZnVuY3Rpb24gZFQoZSx0KXtyZXR1cm4gS20oZSx0LFwicmlnaHRcIil9ZnVuY3Rpb24gTXcoZSx0PSEwLG4sYSl7cmV0dXJuIFAubWFrZVZhcmlhYmxlKGUsdCxuLGEpfWZ1bmN0aW9uIGhUKGUsdCl7bGV0IG49W107Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXSYmbi5wdXNoKHMpO2xldCBhPU9lKGUsXCJpbnQzMlwiKSxyPU9lKFtuLmxlbmd0aCxlLmxlbmd0aF0sXCJpbnQzMlwiKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IGk9YS5pbmRleFRvTG9jKG5bc10pLG89cyplLmxlbmd0aDtyLnZhbHVlcy5zZXQoaSxvKX1yZXR1cm4gci50b1RlbnNvcigpfWFzeW5jIGZ1bmN0aW9uIF96KGUpe2xldCB0PUUoZSxcImNvbmRpdGlvblwiLFwid2hlcmVBc3luY1wiLFwiYm9vbFwiKSxuPWF3YWl0IHQuZGF0YSgpLGE9aFQodC5zaGFwZSxuKTtyZXR1cm4gZSE9PXQmJnQuZGlzcG9zZSgpLGF9dmFyIE93PV96O2FzeW5jIGZ1bmN0aW9uIEF6KGUsdCxuKXtsZXQgYT1FKGUsXCJ0ZW5zb3JcIixcImJvb2xNYXNrXCIpLHI9RSh0LFwibWFza1wiLFwiYm9vbE1hc2tcIixcImJvb2xcIikscz1uPT1udWxsPzA6bixpPXIucmFuayxvPWEuc2hhcGU7QShpPjAsKCk9PlwibWFzayBjYW5ub3QgYmUgc2NhbGFyXCIpLE5uKG8uc2xpY2UocyxzK2kpLHIuc2hhcGUsXCJtYXNrJ3Mgc2hhcGUgbXVzdCBtYXRjaCB0aGUgZmlyc3QgSyBkaW1lbnNpb25zIG9mIHRlbnNvcidzIHNoYXBlLFwiKTtsZXQgbD0xO2ZvcihsZXQgZj1zO2Y8cytpO2YrKylsKj1vW2ZdO2xldCB1PW8uc2xpY2UoMCxzKS5jb25jYXQoW2xdLG8uc2xpY2UocytpKSkscD1XKGEsdSksZD1XKHIsWy0xXSksYz1hd2FpdCBPdyhkKSxoPUFzKGMsWzFdKSxtPW5wKHAsaCxzKTtyZXR1cm4gZSE9PWEmJmEuZGlzcG9zZSgpLHQhPT1yJiZyLmRpc3Bvc2UoKSxoLmRpc3Bvc2UoKSxwLmRpc3Bvc2UoKSxkLmRpc3Bvc2UoKSxjLmRpc3Bvc2UoKSxtfXZhciBtVD1BejtmdW5jdGlvbiBGeihlLHQsbil7bGV0IGE9RShlLFwieFwiLFwidHJhbnNwb3NlXCIpO2lmKHQ9PW51bGwmJih0PWEuc2hhcGUubWFwKChpLG8pPT5vKS5yZXZlcnNlKCkpLEEoYS5yYW5rPT09dC5sZW5ndGgsKCk9PmBFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgJHthLnJhbmt9IG11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gJHt0fS5gKSx0LmZvckVhY2goaT0+e0EoaT49MCYmaTxhLnJhbmssKCk9PmBBbGwgZW50cmllcyBpbiAncGVybScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7YS5yYW5rLTF9IGJ1dCBnb3QgJHt0fWApfSksYS5yYW5rPD0xKXJldHVybiBhLmNsb25lKCk7bGV0IHI9e3g6YX0scz17cGVybTp0fTtyZXR1cm4gYS5kdHlwZT09PVwiY29tcGxleDY0XCI/TygoKT0+e2xldCBpPXpsKGEpLG89bGQoYSk7cmV0dXJuIGk9UC5ydW5LZXJuZWwoQ3Ise3g6aX0scyksbz1QLnJ1bktlcm5lbChDcix7eDpvfSxzKSxuJiYobz15dChvKSksX3IoaSxvKX0pOlAucnVuS2VybmVsKENyLHIscyl9dmFyIERlPUwoe3RyYW5zcG9zZV86Rnp9KTtmdW5jdGlvbiAkeihlLHQsbixhLHI9ITApe2xldCBzPUUoZSxcInZcIixcIm1vdmluZ0F2ZXJhZ2VcIiksaT1FKHQsXCJ4XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLG89RShuLFwiZGVjYXlcIixcIm1vdmluZ0F2ZXJhZ2VcIik7dE4ocyxpKSxBKEFyKHMuc2hhcGUsaS5zaGFwZSksKCk9PlwiU2hhcGUgbWlzbWF0Y2ggaW4gdiBhbmQgeFwiKTtsZXQgbD14ZSgxKSx1PXBlKGwsbykscD16KHBlKGkscyksdSk7aWYocil7QShhIT1udWxsLCgpPT5cIldoZW4gdXNpbmcgemVyb0RlYmlhczogdHJ1ZSwgc3RlcCBpcyByZXF1aXJlZC5cIik7bGV0IGQ9RShhLFwic3RlcFwiLFwibW92aW5nQXZlcmFnZVwiKTtwPWhlKHAscGUobCx1cihvLGQpKSl9cmV0dXJuIFgocyxwKX12YXIgZlQ9TCh7bW92aW5nQXZlcmFnZV86JHp9KTtmdW5jdGlvbiBEeihlLHQsbil7bmEobik7bGV0IGE9RShlLFwiaW5kaWNlc1wiLFwic2NhdHRlck5EXCIsXCJpbnQzMlwiKSxyPUUodCxcInVwZGF0ZXNcIixcInNjYXR0ZXJORFwiKTtvZihyLGEsbik7bGV0IHM9e2luZGljZXM6YSx1cGRhdGVzOnJ9LGk9e3NoYXBlOm59O3JldHVybiBQLnJ1bktlcm5lbChQdSxzLGkpfXZhciBnVD1MKHtzY2F0dGVyTkRfOkR6fSk7ZnVuY3Rpb24gUnooZSx0LG4sYSl7aWYoZS5kdHlwZSE9PVwiaW50MzJcIil0aHJvdyBuZXcgRXJyb3IoYHRmLnNwYXJzZVRvRGVuc2UoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzICR7ZS5kdHlwZX0uYCk7aWYoZS5yYW5rPjIpdGhyb3cgbmV3IEVycm9yKGBzcGFyc2VJbmRpY2VzIHNob3VsZCBiZSBhIHNjYWxhciwgdmVjdG9yLCBvciBtYXRyaXgsIGJ1dCBnb3Qgc2hhcGUgJHtlLnNoYXBlfS5gKTtsZXQgcj1lLnJhbms+MD9lLnNoYXBlWzBdOjEscz1lLnJhbms+MT9lLnNoYXBlWzFdOjE7aWYobi5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgb3V0cHV0U2hhcGUgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgZWxlbWVudHM6LCAke24ubGVuZ3RofSwgc2hvdWxkIGJlOiAke3N9LmApO2xldCBpPXQuc2l6ZTtpZighKHQucmFuaz09PTB8fHQucmFuaz09PTEmJmk9PT1yKSl0aHJvdyBuZXcgRXJyb3IoYHNwYXJzZVZhbHVlcyBoYXMgaW5jb3JyZWN0IHNoYXBlICR7dC5zaGFwZX0sIHNob3VsZCBiZSBbXSBvciBbJHtyfV1gKTtpZih0LmR0eXBlIT09YS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VWYWx1ZXMuZHR5cGUgbXVzdCBtYXRjaCBkZWZhdWx0VmFsdWVzLmR0eXBlXCIpfWZ1bmN0aW9uIE16KGUsdCxuLGE9MCl7bmEobik7bGV0IHI9RShlLFwic3BhcnNlSW5kaWNlc1wiLFwic3BhcnNlVG9EZW5zZVwiLFwiaW50MzJcIikscz1FKHQsXCJzcGFyc2VWYWx1ZXNcIixcInNwYXJzZVRvRGVuc2VcIixcInN0cmluZ19vcl9udW1lcmljXCIpLGk9RShhLFwiZGVmYXVsdFZhbHVlXCIsXCJzcGFyc2VUb0RlbnNlXCIscy5kdHlwZSk7UnoocixzLG4saSk7bGV0IG89e3NwYXJzZUluZGljZXM6cixzcGFyc2VWYWx1ZXM6cyxkZWZhdWx0VmFsdWU6aX0sbD17b3V0cHV0U2hhcGU6bn07cmV0dXJuIFAucnVuS2VybmVsKEh1LG8sbCl9dmFyIGJUPUwoe3NwYXJzZVRvRGVuc2VfOk16fSk7ZnVuY3Rpb24gT3ooZSx0KXtsZXQgbj1FKHQsXCJpbmRpY2VzXCIsXCJnYXRoZXJORFwiLFwiaW50MzJcIiksYT17cGFyYW1zOkUoZSxcInhcIixcImdhdGhlck5EXCIsXCJzdHJpbmdfb3JfbnVtZXJpY1wiKSxpbmRpY2VzOm59O3JldHVybiBQLnJ1bktlcm5lbChndSxhKX12YXIgeVQ9TCh7Z2F0aGVyTkRfOk96fSk7ZnVuY3Rpb24gUHooZSx0KXtpZih0PT1udWxsKXJldHVybiBlLnNoYXBlLnNsaWNlKCk7aWYoQXIoZS5zaGFwZSx0KSlyZXR1cm4gdDtpZihlLnNoYXBlLmxlbmd0aD09PXQubGVuZ3RoKXtsZXQgbj1bXTtmb3IobGV0IGE9MDthPGUuc2hhcGUubGVuZ3RoO2ErKyl0W2FdPT1udWxsJiZlLnNoYXBlW2FdIT1udWxsP24ucHVzaChlLnNoYXBlW2FdKTpuLnB1c2godFthXSk7cmV0dXJuIG59cmV0dXJuIHR9ZnVuY3Rpb24gTHooZSx0LG4sYSl7bGV0IHI9RShlLFwieFwiLFwiZHJvcG91dFwiKTtpZihBKHIuZHR5cGU9PT1cImZsb2F0MzJcIiwoKT0+YHggaGFzIHRvIGJlIGEgZmxvYXRpbmcgcG9pbnQgdGVuc29yIHNpbmNlIGl0J3MgZ29pbmcgdG8gYmUgc2NhbGVkLCBidXQgZ290IGEgJHtyLmR0eXBlfSB0ZW5zb3IgaW5zdGVhZC5gKSxBKHQ+PTAmJnQ8MSwoKT0+YHJhdGUgbXVzdCBiZSBhIGZsb2F0IGluIHRoZSByYW5nZSBbMCwgMSksIGJ1dCBnb3QgJHt0fS5gKSx0PT09MClyZXR1cm4gZSBpbnN0YW5jZW9mIENlP3IuY2xvbmUoKTpyO2xldCBzPVB6KHIsbiksaT0xLXQsbz1oZSh0cChYKEVzKHMsMCwxLFwiZmxvYXQzMlwiLGEpLGkpKSxpKTtyZXR1cm4geihyLG8pfXZhciBQdz1MKHtkcm9wb3V0XzpMen0pO2Z1bmN0aW9uIEx3KGUpe3JldHVybiBNYXRoLmZsb29yKE1hdGgucG93KDIsTWF0aC5jZWlsKE1hdGgubG9nKGUpL01hdGgubG9nKDIpKSkpfWZ1bmN0aW9uIHBmKGUsdCxuKXtsZXQgYT0xLWUlMixyPW5ldyBGbG9hdDMyQXJyYXkoZSk7Zm9yKGxldCBzPTA7czxlOysrcyl7bGV0IGk9MipNYXRoLlBJKnMvKGUrYS0xKTtyW3NdPXQtbipNYXRoLmNvcyhpKX1yZXR1cm4gamUocixcImZsb2F0MzJcIil9YXN5bmMgZnVuY3Rpb24genooZSx0LG49MSl7bGV0IGE9RShlLFwicHJlZGljdGlvbnNcIixcImluVG9wS1wiKSxyPUUodCxcInRhcmdldHNcIixcImluVG9wS1wiKTtBKGEucmFuaz4xLCgpPT5gaW5Ub3BLKCkgZXhwZWN0cyB0aGUgcHJlZGljdGlvbnMgdG8gYmUgb2YgcmFuayAyIG9yIGhpZ2hlciwgYnV0IGdvdCAke2EucmFua31gKSxBKGEucmFuay0xPT09ci5yYW5rLCgpPT5gcHJlZGljdGlvbnMgcmFuayBzaG91bGQgYmUgMSBsYXJnZXIgdGhhbiB0YXJnZXRzIHJhbmssIGJ1dCBnb3QgcHJlZGljdGlvbnMgcmFuayAke2EucmFua30gYW5kIHRhcmdldHMgcmFuayAke3IucmFua31gKSxObihhLnNoYXBlLnNsaWNlKDAsYS5zaGFwZS5sZW5ndGgtMSksci5zaGFwZSxcInByZWRpY3Rpb25zJ3Mgc2hhcGUgc2hvdWxkIGJlIGFsaWduIHdpdGggdGhlIHRhcmdldHMnIHNoYXBlLCBleGNlcHQgdGhlIGxhc3QgZGltZW5zaW9uLlwiKTtsZXQgcz1hLnNoYXBlW2Euc2hhcGUubGVuZ3RoLTFdO0Eobj4wJiZuPD1zLCgpPT5gJ2snIHBhc3NlZCB0byBpblRvcEsoKSBtdXN0IGJlID4gMCAmJiA8PSB0aGUgcHJlZGljdGlvbnMgbGFzdCBkaW1lbnNpb24gKCR7c30pLCBidXQgZ290ICR7bn1gKTtsZXQgaT1hd2FpdCBhLmRhdGEoKSxvPWF3YWl0IHIuZGF0YSgpLFtsLHVdPVtpLmxlbmd0aC9zLHNdLHA9T1MoXCJib29sXCIsbCk7Zm9yKGxldCBkPTA7ZDxsO2QrKyl7bGV0IGM9ZCp1LGg9aS5zdWJhcnJheShjLGMrdSksbT1bXTtmb3IobGV0IGY9MDtmPGgubGVuZ3RoO2YrKyltLnB1c2goe3ZhbHVlOmhbZl0saW5kZXg6Zn0pO20uc29ydCgoZixnKT0+Zy52YWx1ZS1mLnZhbHVlKSxwW2RdPTA7Zm9yKGxldCBmPTA7ZjxuO2YrKylpZihtW2ZdLmluZGV4PT09b1tkXSl7cFtkXT0xO2JyZWFrfX1yZXR1cm4gZSE9PWEmJmEuZGlzcG9zZSgpLHQhPT1yJiZyLmRpc3Bvc2UoKSxibihwLHIuc2hhcGUsXCJib29sXCIpfXZhciB4VD16eixWbD17fTtfZShWbCx7Y29udjJkOigpPT5WeixkZXB0aHdpc2VDb252MmQ6KCk9Pmp6LG1hdE11bDooKT0+S3p9KTtmdW5jdGlvbiBXeihlLHQsbixhLHIscz1cIk5IV0NcIixpKXtsZXQgbz1lO2UucmFuaz09PTMmJihvPVcoZSxbMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXV0pKTtsZXQgbD10O2wucmFuaz09PTMmJihsPVcodCxbMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXV0pKSxBKG8ucmFuaz09PTQsKCk9PmBFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHNoYXBlICR7by5zaGFwZX0uYCksQShsLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSAke2wuc2hhcGV9LmApLEEobi5sZW5ndGg9PT00LCgpPT5gRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290ICR7bn0uYCk7bGV0IHU9cz09PVwiTkhXQ1wiP28uc2hhcGVbM106by5zaGFwZVsxXSxwPXM9PT1cIk5IV0NcIj9sLnNoYXBlWzNdOmwuc2hhcGVbMV07QSh1PT09blsyXSwoKT0+YEVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgaW5wdXQgJHt1fSkgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBpbiBmaWx0ZXIgKCR7blsyXX0uYCksQShwPT09blszXSwoKT0+YEVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKCR7cH0pIG11c3QgbWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKCR7blszXX0pLmApLFRuKFwiY29udjJkRGVyRmlsdGVyXCIscixpKTtsZXQgZD17eDpvLGR5Omx9LGM9e3N0cmlkZXM6YSxwYWQ6cixkYXRhRm9ybWF0OnMsZGltUm91bmRpbmdNb2RlOmksZmlsdGVyU2hhcGU6bn07cmV0dXJuIFAucnVuS2VybmVsKGttLGQsYyl9dmFyIHp3PUwoe2NvbnYyREJhY2twcm9wRmlsdGVyXzpXen0pO2Z1bmN0aW9uIGNmKGUsdCxuKXtpZihuPT1udWxsfHxuPT09XCJsaW5lYXJcIilyZXR1cm4gZTtpZihuPT09XCJyZWx1XCIpcmV0dXJuIHooZSxqbyh0KSk7dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBmb3IgZnVzZWQgYWN0aXZhdGlvbiAke259LmApfWZ1bmN0aW9uIGRmKGUsdCl7bGV0IG49dCxhPUJ0KGUuc2hhcGUsdC5zaGFwZSk7cmV0dXJuIGEubGVuZ3RoPjAmJihuPWZlKG4sYSkpLFcobixlLnNoYXBlKX1mdW5jdGlvbiBoZihlLHQsbixhKXtpZih0PT09XCJsaW5lYXJcIilyZXR1cm4gZTtpZih0PT09XCJyZWx1XCIpcmV0dXJuIEtlKGUpO2lmKHQ9PT1cImVsdVwiKXJldHVybiBRdShlKTtpZih0PT09XCJyZWx1NlwiKXJldHVybiBZbShlKTtpZih0PT09XCJwcmVsdVwiKXJldHVybiBmZChlLG4pO2lmKHQ9PT1cImxlYWt5cmVsdVwiKXJldHVybiB1ZChlLGEpO2lmKHQ9PT1cInNpZ21vaWRcIilyZXR1cm4gaGEoZSk7dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZ1c2VkIGFjdGl2YXRpb24gJHt0fS5gKX12YXIgbWY9KGUsdCk9PiEoZT4wKXx8dD09PVwibGluZWFyXCI7ZnVuY3Rpb24gQnooe3g6ZSxmaWx0ZXI6dCxzdHJpZGVzOm4scGFkOmEsZGF0YUZvcm1hdDpyPVwiTkhXQ1wiLGRpbGF0aW9uczpzPVsxLDFdLGRpbVJvdW5kaW5nTW9kZTppLGJpYXM6byxhY3RpdmF0aW9uOmw9XCJsaW5lYXJcIixwcmVsdUFjdGl2YXRpb25XZWlnaHRzOnUsbGVha3lyZWx1QWxwaGE6cH0pe2lmKGw9bHx8XCJsaW5lYXJcIixtZihQLnN0YXRlLmdyYWRpZW50RGVwdGgsbCk9PT0hMSl7QShyPT09XCJOSFdDXCIsKCk9PmBFcnJvciBpbiBmdXNlZCBjb252MmQ6IGdvdCBkYXRhRm9ybWF0IG9mICR7cn0gYnV0IG9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciB0aGUgY2FzZSBvZiBncmFkaWVudCBkZXB0aCBpcyAwIGFuZCB0aGUgYWN0aXZhdGlvbiBpcyBub3QgbGluZWFyLmApO2xldCBOPSR0KGUsdCxuLGEscixzLGkpO3JldHVybiBvIT1udWxsJiYoTj1YKE4sbykpLGhmKE4sbCx1LHApfWxldCBkPUUoZSxcInhcIixcImNvbnYyZFwiLFwiZmxvYXQzMlwiKSxjPUUodCxcImZpbHRlclwiLFwiY29udjJkXCIsXCJmbG9hdDMyXCIpLGg9ZCxtPSExO2QucmFuaz09PTMmJihtPSEwLGg9VyhkLFsxLGQuc2hhcGVbMF0sZC5zaGFwZVsxXSxkLnNoYXBlWzJdXSkpLEEoaC5yYW5rPT09NCwoKT0+YEVycm9yIGluIGZ1c2VkIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2gucmFua30uYCksQShjLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZnVzZWQgY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2MucmFua30uYCksVG4oXCJmdXNlZCBjb252MmRcIixhLGkpO2xldCBmPXI9PT1cIk5IV0NcIj9oLnNoYXBlWzNdOmguc2hhcGVbMV07QShjLnNoYXBlWzJdPT09ZiwoKT0+YEVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKCR7Zn0pIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciAke2Muc2hhcGVbMl19LmApLEEoZHIobixzKSwoKT0+YEVycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtufSBhbmQgZGlsYXRpb25zICcke3N9J2ApO2xldCBnPXNkKGguc2hhcGUsYy5zaGFwZSxuLHMsYSxpKSxiO28hPW51bGwmJihiPUUobyxcImJpYXNcIixcImZ1c2VkIGNvbnYyZFwiKSxbYl09X3QoYixkKSxyPT09XCJOSFdDXCI/Y3QoZy5vdXRTaGFwZSxiLnNoYXBlKTooQShiLnNoYXBlLmxlbmd0aDw9MSwoKT0+YEVycm9yIGluIGZ1c2VkIGNvbnYyZDogb25seSBzdXBwb3J0cyBzY2FsYXIgb3IgMS1EIFRlbnNvciBiaWFzIGZvciBOQ0hXIGZvcm1hdCBidXQgZ290IHRoZSBiaWFzIG9mIHJhbmstJHtiLnNoYXBlLmxlbmd0aH0uYCksQShiLnNoYXBlLmxlbmd0aD09PTB8fGIuc2hhcGVbMF09PT1nLm91dENoYW5uZWxzfHxiLnNoYXBlWzBdPT09MSwoKT0+YEVycm9yIGluIGZ1c2VkIGNvbnYyZDogYmlhcyBzaGFwZSAoJHtiLnNoYXBlfSkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgbnVtYmVyIG9mIG91dHB1dCBjaGFubmVscyAoJHtnLm91dENoYW5uZWxzfSlgKSkpO2xldCB5O2lmKHUhPW51bGwpe2xldCBOPXUuc2hhcGU7aWYoQShOLmxlbmd0aDw9MXx8Ti5sZW5ndGg9PT0zLCgpPT5gRXJyb3IgaW4gZnVzZWQgY29udjJkOiBvbmx5IHN1cHBvcnRzIHNjYWxhciwgMS1EIFRlbnNvciBvciAzLUQgVGVuc29yIFBSZUxVIGFjdGl2YXRpb24gd2VpZ2h0cyBidXQgZ290IGEgdGVuc29yIG9mIHJhbmstJHtOLmxlbmd0aH0uYCksTi5sZW5ndGg9PT0xKUEoTlswXT09PTF8fE5bMF09PT1nLm91dENoYW5uZWxzLCgpPT5gRXJyb3IgaW4gZnVzZWQgY29udjJkOiBQUmVMVSBhY3RpdmF0aW9uIHdlaWdodHMgKCR7Tn0pIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIG51bWJlciBvZiBvdXRwdXQgY2hhbm5lbHMgKCR7Zy5vdXRDaGFubmVsc30pLmApO2Vsc2UgaWYoTi5sZW5ndGg9PT0zKXRyeXtjdChOLGcub3V0U2hhcGUpfWNhdGNoKEMpe2xldCBfPWBFcnJvciBpbiBmdXNlZCBjb252MmQ6IFBSZUxVIGFjdGl2YXRpb24gd2VpZ2h0cyAoJHtOfSkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgb3V0cHV0IHNoYXBlIG9mIHRoZSBjb252MmQgKCR7Zy5vdXRTaGFwZX0pLmA7dGhyb3cgRXJyb3IoXyl9eT1FKHUsXCJwcmVsdSB3ZWlnaHRzXCIsXCJmdXNlZCBjb252MmRcIil9bGV0IHg9KE4sQyk9PntBKHI9PT1cIk5IV0NcIiwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGZ1c2VkIGNvbnYyRDogZ290IGRhdGFGb3JtYXQgb2YgJHtyfSBidXQgb25seSBOSFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7bGV0W18sRixELCRdPUMsUz1jZihOLEQsbCk7QShwcyhzKSwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGZ1c2VkIGNvbnYyRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnJHtzfSdgKTtsZXQgTT1udyhGLnNoYXBlLFMsXyxuLGEpLEI9encoRixTLF8uc2hhcGUsbixhKSxVPVtNLEJdO2lmKCQhPW51bGwpe2xldCBIPWRmKCQsUyk7VS5wdXNoKEgpfXJldHVybiBVfSx2PXt4OmgsZmlsdGVyOmMsYmlhczpiLHByZWx1QWN0aXZhdGlvbldlaWdodHM6eX0sST17c3RyaWRlczpuLHBhZDphLGRhdGFGb3JtYXQ6cixkaWxhdGlvbnM6cyxkaW1Sb3VuZGluZ01vZGU6aSxhY3RpdmF0aW9uOmwsbGVha3lyZWx1QWxwaGE6cH07cmV0dXJuIG89PW51bGw/cHIoKE4sQyxfKT0+e2xldCBGPVAucnVuS2VybmVsKG9pLHYsSSk7cmV0dXJuIF8oW0MsTixGXSksbSYmKEY9VyhGLFtGLnNoYXBlWzFdLEYuc2hhcGVbMl0sRi5zaGFwZVszXV0pKSx7dmFsdWU6RixncmFkRnVuYzp4fX0pKGgsYyk6cHIoKE4sQyxfLEYpPT57bGV0IEQ9UC5ydW5LZXJuZWwob2ksdixJKTtyZXR1cm4gRihbQyxOLEQsX10pLG0mJihEPVcoRCxbRC5zaGFwZVsxXSxELnNoYXBlWzJdLEQuc2hhcGVbM11dKSkse3ZhbHVlOkQsZ3JhZEZ1bmM6eH19KShoLGMsYil9dmFyIFZ6PUwoe2Z1c2VkQ29udjJkXzpCen0pO2Z1bmN0aW9uIFV6KGUsdCxuLGEscixzPVsxLDFdLGkpe2xldCBvPWU7ZS5yYW5rPT09MyYmKG89VyhlLFsxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdXSkpO2xldCBsPXQ7bC5yYW5rPT09MyYmKGw9Vyh0LFsxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdXSkpO2xldCB1PXt4Om8sZHk6bH0scD17c3RyaWRlczphLHBhZDpyLGRpbVJvdW5kaW5nTW9kZTppLGRpbGF0aW9uczpzLGZpbHRlclNoYXBlOm59O3JldHVybiBQLnJ1bktlcm5lbChJbSx1LHApfXZhciB2VD1MKHtkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlcl86VXp9KTtmdW5jdGlvbiBHeihlLHQsbixhLHIscz1bMSwxXSxpKXtsZXQgbz10LGw9ITE7dC5yYW5rPT09MyYmKGw9ITAsbz1XKHQsWzEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl1dKSk7bGV0IHU9e2R5Om8sZmlsdGVyOm59LHA9e3N0cmlkZXM6YSxwYWQ6cixkaW1Sb3VuZGluZ01vZGU6aSxkaWxhdGlvbnM6cyxpbnB1dFNoYXBlOmV9LGQ9UC5ydW5LZXJuZWwoU20sdSxwKTtyZXR1cm4gbD9XKGQsW2Quc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdXSk6ZH12YXIgd1Q9TCh7ZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BJbnB1dF86R3p9KTtmdW5jdGlvbiBIeih7eDplLGZpbHRlcjp0LHN0cmlkZXM6bixwYWQ6YSxkYXRhRm9ybWF0OnI9XCJOSFdDXCIsZGlsYXRpb25zOnM9WzEsMV0sZGltUm91bmRpbmdNb2RlOmksYmlhczpvLGFjdGl2YXRpb246bD1cImxpbmVhclwiLHByZWx1QWN0aXZhdGlvbldlaWdodHM6dSxsZWFreXJlbHVBbHBoYTpwfSl7aWYobWYoUC5zdGF0ZS5ncmFkaWVudERlcHRoLGwpPT09ITEpe2xldCBJPVRzKGUsdCxuLGEscixzLGkpO3JldHVybiBvIT1udWxsJiYoST1YKEksbykpLGhmKEksbCx1LHApfWxldCBkPUUoZSxcInhcIixcImRlcHRod2lzZUNvbnYyZFwiLFwiZmxvYXQzMlwiKSxjPUUodCxcImZpbHRlclwiLFwiZGVwdGh3aXNlQ29udjJkXCIsXCJmbG9hdDMyXCIpLGg9ZCxtPSExO2QucmFuaz09PTMmJihtPSEwLGg9VyhkLFsxLGQuc2hhcGVbMF0sZC5zaGFwZVsxXSxkLnNoYXBlWzJdXSkpLEEoaC5yYW5rPT09NCwoKT0+YEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2gucmFua30uYCksQShjLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayAke2MucmFua30uYCksQShoLnNoYXBlWzNdPT09Yy5zaGFwZVsyXSwoKT0+YEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzICgke2guc2hhcGVbM119KSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBmaWx0ZXIgJHtjLnNoYXBlWzJdfS5gKSxzPT1udWxsJiYocz1bMSwxXSksQShkcihuLHMpLCgpPT5gRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke259IGFuZCBkaWxhdGlvbnMgJyR7c30nYCksVG4oXCJmdXNlZCBkZXB0aHdpc2VDb252MmRcIixhLGkpO2xldCBmPXNkKGguc2hhcGUsYy5zaGFwZSxuLHMsYSxpLCEwKSxnO28hPW51bGwmJihnPUUobyxcImJpYXNcIixcImZ1c2VkIGNvbnYyZFwiKSxbZ109X3QoZyxkKSxjdChmLm91dFNoYXBlLGcuc2hhcGUpKTtsZXQgYjt1IT1udWxsJiYoYj1FKHUsXCJwcmVsdSB3ZWlnaHRzXCIsXCJmdXNlZCBkZXB0aHdpc2VDb252MmRcIikpO2xldCB5PShJLE4pPT57QShwcyhzKSwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICcke3N9J2ApO2xldFtDLF8sRixEXT1OLCQ9Y2YoSSxGLGwpLFM9d1QoXy5zaGFwZSwkLEMsbixhLHMsaSksTT12VChfLCQsQy5zaGFwZSxuLGEscyxpKTtpZihEIT1udWxsKXtsZXQgQj1kZihnLCQpO3JldHVybltTLE0sQl19cmV0dXJuW1MsTV19LHg9e3g6aCxmaWx0ZXI6YyxiaWFzOmcscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpifSx2PXtzdHJpZGVzOm4scGFkOmEsZGF0YUZvcm1hdDpyLGRpbGF0aW9uczpzLGRpbVJvdW5kaW5nTW9kZTppLGFjdGl2YXRpb246bCxsZWFreXJlbHVBbHBoYTpwfTtyZXR1cm4gbz09bnVsbD9wcigoSSxOLEMpPT57bGV0IF89UC5ydW5LZXJuZWwobGkseCx2KTtyZXR1cm4gQyhbTixJLF9dKSxtJiYoXz1XKF8sW18uc2hhcGVbMV0sXy5zaGFwZVsyXSxfLnNoYXBlWzNdXSkpLHt2YWx1ZTpfLGdyYWRGdW5jOnl9fSkoaCxjKTpwcigoSSxOLEMsXyk9PntsZXQgRj1QLnJ1bktlcm5lbChsaSx4LHYpO3JldHVybiBfKFtOLEksRixDXSksbSYmKEY9VyhGLFtGLnNoYXBlWzFdLEYuc2hhcGVbMl0sRi5zaGFwZVszXV0pKSx7dmFsdWU6RixncmFkRnVuYzp5fX0pKGgsYyxnKX12YXIgano9TCh7ZnVzZWREZXB0aHdpc2VDb252MmRfOkh6fSk7ZnVuY3Rpb24gcXooe2E6ZSxiOnQsdHJhbnNwb3NlQTpuPSExLHRyYW5zcG9zZUI6YT0hMSxiaWFzOnIsYWN0aXZhdGlvbjpzPVwibGluZWFyXCIscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czppLGxlYWt5cmVsdUFscGhhOm89LjJ9KXtpZihtZihQLnN0YXRlLmdyYWRpZW50RGVwdGgscyk9PT0hMSl7bGV0IEQ9JGUoZSx0LG4sYSk7cmV0dXJuIHIhPW51bGwmJihEPVgoRCxyKSksaGYoRCxzLGksbyl9bGV0IGw9RShlLFwiYVwiLFwiZnVzZWQgbWF0TXVsXCIpLHU9RSh0LFwiYlwiLFwiZnVzZWQgbWF0TXVsXCIpO1tsLHVdPV90KGwsdSk7bGV0IHA9bj9sLnNoYXBlW2wucmFuay0yXTpsLnNoYXBlW2wucmFuay0xXSxkPWE/dS5zaGFwZVt1LnJhbmstMV06dS5zaGFwZVt1LnJhbmstMl0sYz1uP2wuc2hhcGVbbC5yYW5rLTFdOmwuc2hhcGVbbC5yYW5rLTJdLGg9YT91LnNoYXBlW3UucmFuay0yXTp1LnNoYXBlW3UucmFuay0xXSxtPWwuc2hhcGUuc2xpY2UoMCwtMiksZj11LnNoYXBlLnNsaWNlKDAsLTIpLGc9b3QobSksYj1vdChmKTtBKHA9PT1kLCgpPT5gRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBpbm5lciBzaGFwZXMgKCR7cH0pIGFuZCAoJHtkfSkgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyAke2wuc2hhcGV9IGFuZCAke3Uuc2hhcGV9IGFuZCB0cmFuc3Bvc2VBPSR7bn0gYW5kIHRyYW5zcG9zZUI9JHthfSBtdXN0IG1hdGNoLmApO2xldCB5PWN0KGwuc2hhcGUuc2xpY2UoMCwtMiksdS5zaGFwZS5zbGljZSgwLC0yKSkuY29uY2F0KFtjLGhdKSx4PW4/VyhsLFtnLHAsY10pOlcobCxbZyxjLHBdKSx2PWE/Vyh1LFtiLGgsZF0pOlcodSxbYixkLGhdKSxJO3IhPW51bGwmJihJPUUocixcImJpYXNcIixcImZ1c2VkIG1hdE11bFwiKSxbSV09X3QoSSxsKSxjdCh5LEkuc2hhcGUpKTtsZXQgTjtpIT1udWxsJiYoTj1FKGksXCJwcmVsdSB3ZWlnaHRzXCIsXCJmdXNlZCBtYXRNdWxcIikpO2xldCBDPShELCQpPT57bGV0W1MsTSxCLFVdPSQsSD1jZihXKEQsQi5zaGFwZSksQixzKSxxLEs7aWYoIW4mJiFhPyhxPSRlKEgsTSwhMSwhMCksSz0kZShTLEgsITAsITEpKTohbiYmYT8ocT0kZShILE0sITEsITEpLEs9JGUoSCxTLCEwLCExKSk6biYmIWE/KHE9JGUoTSxILCExLCEwKSxLPSRlKFMsSCwhMSwhMSkpOihxPSRlKE0sSCwhMCwhMCksSz0kZShILFMsITAsITApKSxyIT1udWxsKXtsZXQgWj1kZihVLEgpO3JldHVybltxLEssWl19ZWxzZSByZXR1cm5bcSxLXX0sXz17YTp4LGI6dixiaWFzOkkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpOfSxGPXt0cmFuc3Bvc2VBOm4sdHJhbnNwb3NlQjphLGFjdGl2YXRpb246cyxsZWFreXJlbHVBbHBoYTpvfTtyZXR1cm4gcj09bnVsbD9wcigoRCwkLFMpPT57bGV0IE09UC5ydW5LZXJuZWwoaWksXyxGKTtyZXR1cm4gUyhbRCwkLE1dKSx7dmFsdWU6VyhNLHkpLGdyYWRGdW5jOkN9fSkoeCx2KTpwcigoRCwkLFMsTSk9PntsZXQgQj1QLnJ1bktlcm5lbChpaSxfLEYpO3JldHVybiBNKFtELCQsQixTXSkse3ZhbHVlOlcoQix5KSxncmFkRnVuYzpDfX0pKHgsdixJKX12YXIgS3o9TCh7ZnVzZWRNYXRNdWxfOnF6fSk7ZnVuY3Rpb24gWHooZSl7cmV0dXJuIHBmKGUsLjU0LC40Nil9dmFyIFl6PUwoe2hhbW1pbmdXaW5kb3dfOlh6fSk7ZnVuY3Rpb24gWnooZSl7cmV0dXJuIHBmKGUsLjUsLjUpfXZhciBrVD1MKHtoYW5uV2luZG93Xzpaen0pO2Z1bmN0aW9uIEp6KGUsdCxuLGE9ITEscj0wKXtsZXQgcz0wLGk9W107Zm9yKDtzK3Q8PWUuc2l6ZTspaS5wdXNoKFZlKGUscyx0KSkscys9bjtpZihhKWZvcig7czxlLnNpemU7KXtsZXQgbz1zK3QtZS5zaXplLGw9ZXQoW1ZlKGUscyx0LW8pLHluKFtvXSxyKV0pO2kucHVzaChsKSxzKz1ufXJldHVybiBpLmxlbmd0aD09PTA/RWEoW10sWzAsdF0pOlcoZXQoaSksW2kubGVuZ3RoLHRdKX12YXIgSVQ9TCh7ZnJhbWVfOkp6fSk7ZnVuY3Rpb24gUXooZSx0LG4sYSxyPWtUKXthPT1udWxsJiYoYT1Mdyh0KSk7bGV0IHM9SVQoZSx0LG4pLGk9eihzLHIodCkpO3JldHVybiB5ZChpLGEpfXZhciBlVz1MKHtzdGZ0XzpRen0pO2Z1bmN0aW9uIHRXKGUsdCxuLGEscj1cImJpbGluZWFyXCIscz0wKXtsZXQgaT1FKGUsXCJpbWFnZVwiLFwiY3JvcEFuZFJlc2l6ZVwiKSxvPUUodCxcImJveGVzXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJmbG9hdDMyXCIpLGw9RShuLFwiYm94SW5kXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJpbnQzMlwiKSx1PW8uc2hhcGVbMF07QShpLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogaW1hZ2UgbXVzdCBiZSByYW5rIDQsYnV0IGdvdCByYW5rICR7aS5yYW5rfS5gKSxBKG8ucmFuaz09PTImJm8uc2hhcGVbMV09PT00LCgpPT5gRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94ZXMgbXVzdCBiZSBoYXZlIHNpemUgWyR7dX0sNF0gYnV0IGhhZCBzaGFwZSAke28uc2hhcGV9LmApLEEobC5yYW5rPT09MSYmbC5zaGFwZVswXT09PXUsKCk9PmBFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBib3hJbmQgbXVzdCBiZSBoYXZlIHNpemUgWyR7dX1dIGJ1dCBoYWQgc2hhcGUgJHtvLnNoYXBlfS5gKSxBKGEubGVuZ3RoPT09MiwoKT0+YEVycm9yIGluIGNyb3BBbmRSZXNpemU6IGNyb3BTaXplIG11c3QgYmUgb2YgbGVuZ3RoIDIsIGJ1dCBnb3QgbGVuZ3RoICR7YS5sZW5ndGh9LmApLEEoYVswXT49MSYmYVsxXT49MSwoKT0+YGNyb3BTaXplIG11c3QgYmUgYXRsZWFzdCBbMSwxXSwgYnV0IHdhcyAke2F9YCksQShyPT09XCJiaWxpbmVhclwifHxyPT09XCJuZWFyZXN0XCIsKCk9PmBtZXRob2QgbXVzdCBiZSBiaWxpbmVhciBvciBuZWFyZXN0LCBidXQgd2FzICR7cn1gKTtsZXQgcD17aW1hZ2U6aSxib3hlczpvLGJveEluZDpsfSxkPXttZXRob2Q6cixleHRyYXBvbGF0aW9uVmFsdWU6cyxjcm9wU2l6ZTphfTtyZXR1cm4gUC5ydW5LZXJuZWwodXUscCxkKX12YXIgblc9TCh7Y3JvcEFuZFJlc2l6ZV86dFd9KTtmdW5jdGlvbiBhVyhlKXtsZXQgdD1FKGUsXCJpbWFnZVwiLFwiZmxpcExlZnRSaWdodFwiLFwiZmxvYXQzMlwiKTtBKHQucmFuaz09PTQsKCk9PmBFcnJvciBpbiBmbGlwTGVmdFJpZ2h0OiBpbWFnZSBtdXN0IGJlIHJhbmsgNCxidXQgZ290IHJhbmsgJHt0LnJhbmt9LmApO2xldCBuPXtpbWFnZTp0fTtyZXR1cm4gUC5ydW5LZXJuZWwobXUsbix7fSl9dmFyIHJXPUwoe2ZsaXBMZWZ0UmlnaHRfOmFXfSk7ZnVuY3Rpb24gc1coZSl7bGV0IHQ9RShlLFwiaW1hZ2VcIixcImdyYXlzY2FsZVRvUkdCXCIpLG49dC5yYW5rLTEsYT10LnNoYXBlW25dO0EodC5yYW5rPj0yLCgpPT5gRXJyb3IgaW4gZ3JheXNjYWxlVG9SR0I6IGltYWdlcyBtdXN0IGJlIGF0IGxlYXN0IHJhbmsgMiwgYnV0IGdvdCByYW5rICR7dC5yYW5rfS5gKSxBKGE9PT0xLCgpPT5gRXJyb3IgaW4gZ3JheXNjYWxlVG9SR0I6IGxhc3QgZGltZW5zaW9uIG9mIGEgZ3JheXNjYWxlIGltYWdlIHNob3VsZCBiZSBzaXplIDEsIGJ1dCBnb3Qgc2l6ZSAke2F9LmApO2xldCByPW5ldyBBcnJheSh0LnJhbmspO3JldHVybiByLmZpbGwoMSwwLG4pLHJbbl09MyxPbih0LHIpfXZhciBpVz1MKHtncmF5c2NhbGVUb1JHQl86c1d9KTtmdW5jdGlvbiBvVyhlKXtsZXQgdD1FKGUsXCJpbWFnZVwiLFwiUkdCVG9HcmF5c2NhbGVcIiksbj10LnJhbmstMSxhPXQuc2hhcGVbbl07QSh0LnJhbms+PTIsKCk9PmBFcnJvciBpbiBSR0JUb0dyYXlzY2FsZTogaW1hZ2VzIG11c3QgYmUgYXQgbGVhc3QgcmFuayAyLCBidXQgZ290IHJhbmsgJHt0LnJhbmt9LmApLEEoYT09PTMsKCk9PmBFcnJvciBpbiBSR0JUb0dyYXlzY2FsZTogbGFzdCBkaW1lbnNpb24gb2YgYW4gUkdCIGltYWdlIHNob3VsZCBiZSBzaXplIDMsIGJ1dCBnb3Qgc2l6ZSAke2F9LmApO2xldCByPXQuZHR5cGUscz1yZSh0LFwiZmxvYXQzMlwiKSxpPWplKFsuMjk4OSwuNTg3LC4xMTRdKSxvO3N3aXRjaCh0LnJhbmspe2Nhc2UgMjpvPVpzKFwiaWosai0+aVwiLHMsaSk7YnJlYWs7Y2FzZSAzOm89WnMoXCJpamssay0+aWpcIixzLGkpO2JyZWFrO2Nhc2UgNDpvPVpzKFwiaWprbCxsLT5pamtcIixzLGkpO2JyZWFrO2Nhc2UgNTpvPVpzKFwiaWprbG0sbS0+aWprbFwiLHMsaSk7YnJlYWs7Y2FzZSA2Om89WnMoXCJpamtsbW4sbi0+aWprbG1cIixzLGkpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIHJhbmsuXCIpfXJldHVybiBvPUd0KG8sLTEpLHJlKG8scil9dmFyIGxXPUwoe3JnYlRvR3JheXNjYWxlXzpvV30pO2Z1bmN0aW9uIHVXKGUsdCxuPTAsYT0uNSl7bGV0IHI9RShlLFwiaW1hZ2VcIixcInJvdGF0ZVdpdGhPZmZzZXRcIixcImZsb2F0MzJcIik7QShyLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gcm90YXRlV2l0aE9mZnNldDogaW1hZ2UgbXVzdCBiZSByYW5rIDQsYnV0IGdvdCByYW5rICR7ci5yYW5rfS5gKTtsZXQgcz17aW1hZ2U6cn0saT17cmFkaWFuczp0LGZpbGxWYWx1ZTpuLGNlbnRlcjphfTtyZXR1cm4gUC5ydW5LZXJuZWwoWnUscyxpKX12YXIgcFc9TCh7cm90YXRlV2l0aE9mZnNldF86dVd9KTtmdW5jdGlvbiBhcChlLHQsbixhLHIscyl7YT09bnVsbCYmKGE9LjUpLHI9PW51bGwmJihyPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSkscz09bnVsbCYmKHM9MCk7bGV0IGk9ZS5zaGFwZVswXTtyZXR1cm4gbj1NYXRoLm1pbihuLGkpLEEoMDw9YSYmYTw9MSwoKT0+YGlvdVRocmVzaG9sZCBtdXN0IGJlIGluIFswLCAxXSwgYnV0IHdhcyAnJHthfSdgKSxBKGUucmFuaz09PTIsKCk9PmBib3hlcyBtdXN0IGJlIGEgMkQgdGVuc29yLCBidXQgd2FzIG9mIHJhbmsgJyR7ZS5yYW5rfSdgKSxBKGUuc2hhcGVbMV09PT00LCgpPT5gYm94ZXMgbXVzdCBoYXZlIDQgY29sdW1ucywgYnV0IDJuZCBkaW1lbnNpb24gd2FzICR7ZS5zaGFwZVsxXX1gKSxBKHQucmFuaz09PTEsKCk9Plwic2NvcmVzIG11c3QgYmUgYSAxRCB0ZW5zb3JcIiksQSh0LnNoYXBlWzBdPT09aSwoKT0+YHNjb3JlcyBoYXMgaW5jb21wYXRpYmxlIHNoYXBlIHdpdGggYm94ZXMuIEV4cGVjdGVkICR7aX0sIGJ1dCB3YXMgJHt0LnNoYXBlWzBdfWApLEEoMDw9cyYmczw9MSwoKT0+YHNvZnRObXNTaWdtYSBtdXN0IGJlIGluIFswLCAxXSwgYnV0IHdhcyAnJHtzfSdgKSx7bWF4T3V0cHV0U2l6ZTpuLGlvdVRocmVzaG9sZDphLHNjb3JlVGhyZXNob2xkOnIsc29mdE5tc1NpZ21hOnN9fWZ1bmN0aW9uIGNXKGUsdCxuLGE9LjUscj1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpe2xldCBzPUUoZSxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiLFwiZmxvYXQzMlwiKSxpPUUodCxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIixcImZsb2F0MzJcIiksbz1hcChzLGksbixhLHIpO249by5tYXhPdXRwdXRTaXplLGE9by5pb3VUaHJlc2hvbGQscj1vLnNjb3JlVGhyZXNob2xkO2xldCBsPXttYXhPdXRwdXRTaXplOm4saW91VGhyZXNob2xkOmEsc2NvcmVUaHJlc2hvbGQ6cn07cmV0dXJuIFAucnVuS2VybmVsKF91LHtib3hlczpzLHNjb3JlczppfSxsKX12YXIgZFc9TCh7bm9uTWF4U3VwcHJlc3Npb25fOmNXfSk7ZnVuY3Rpb24gaFcoZSx0LG4pe2xldCBhPW1XKGUsdCxuKSxyPWE8MD8tKGErMSk6YTtlLnNwbGljZShyLDAsdCl9ZnVuY3Rpb24gbVcoZSx0LG4pe3JldHVybiBnVyhlLHQsbnx8ZlcpfWZ1bmN0aW9uIGZXKGUsdCl7cmV0dXJuIGU+dD8xOmU8dD8tMTowfWZ1bmN0aW9uIGdXKGUsdCxuKXtsZXQgYT0wLHI9ZS5sZW5ndGgscz0wLGk9ITE7Zm9yKDthPHI7KXtzPWErKHItYT4+PjEpO2xldCBvPW4odCxlW3NdKTtvPjA/YT1zKzE6KHI9cyxpPSFvKX1yZXR1cm4gaT9hOi1hLTF9ZnVuY3Rpb24gU1QoZSx0LG4sYSxyKXtyZXR1cm4gV3coZSx0LG4sYSxyLDApfWZ1bmN0aW9uIE5UKGUsdCxuLGEscixzKXtyZXR1cm4gV3coZSx0LG4sYSxyLDAsITEscywhMCl9ZnVuY3Rpb24gVFQoZSx0LG4sYSxyLHMpe3JldHVybiBXdyhlLHQsbixhLHIscywhMCl9ZnVuY3Rpb24gV3coZSx0LG4sYSxyLHMsaT0hMSxvPSExLGw9ITEpe2xldCB1PVtdO2ZvcihsZXQgZz0wO2c8dC5sZW5ndGg7ZysrKXRbZ10+ciYmdS5wdXNoKHtzY29yZTp0W2ddLGJveEluZGV4Omcsc3VwcHJlc3NCZWdpbkluZGV4OjB9KTt1LnNvcnQodEkpO2xldCBwPXM+MD8tLjUvczowLGQ9W10sYz1bXTtmb3IoO2QubGVuZ3RoPG4mJnUubGVuZ3RoPjA7KXtsZXQgZz11LnBvcCgpLHtzY29yZTpiLGJveEluZGV4Onksc3VwcHJlc3NCZWdpbkluZGV4Onh9PWc7aWYoYjxyKWJyZWFrO2xldCB2PSExO2ZvcihsZXQgST1kLmxlbmd0aC0xO0k+PXg7LS1JKXtsZXQgTj1iVyhlLHksZFtJXSk7aWYoTj49YSl7dj0hMDticmVha31pZihnLnNjb3JlPWcuc2NvcmUqeVcoYSxwLE4pLGcuc2NvcmU8PXIpYnJlYWt9Zy5zdXBwcmVzc0JlZ2luSW5kZXg9ZC5sZW5ndGgsdnx8KGcuc2NvcmU9PT1iPyhkLnB1c2goeSksYy5wdXNoKGcuc2NvcmUpKTpnLnNjb3JlPnImJmhXKHUsZyx0SSkpfWxldCBoPWQubGVuZ3RoLG09bi1oO28mJm0+MCYmKGQucHVzaCguLi5uZXcgQXJyYXkobSkuZmlsbCgwKSksYy5wdXNoKC4uLm5ldyBBcnJheShtKS5maWxsKDApKSk7bGV0IGY9e3NlbGVjdGVkSW5kaWNlczpkfTtyZXR1cm4gaSYmKGYuc2VsZWN0ZWRTY29yZXM9YyksbCYmKGYudmFsaWRPdXRwdXRzPWgpLGZ9ZnVuY3Rpb24gYlcoZSx0LG4pe2xldCBhPWUuc3ViYXJyYXkodCo0LHQqNCs0KSxyPWUuc3ViYXJyYXkobio0LG4qNCs0KSxzPU1hdGgubWluKGFbMF0sYVsyXSksaT1NYXRoLm1pbihhWzFdLGFbM10pLG89TWF0aC5tYXgoYVswXSxhWzJdKSxsPU1hdGgubWF4KGFbMV0sYVszXSksdT1NYXRoLm1pbihyWzBdLHJbMl0pLHA9TWF0aC5taW4oclsxXSxyWzNdKSxkPU1hdGgubWF4KHJbMF0sclsyXSksYz1NYXRoLm1heChyWzFdLHJbM10pLGg9KG8tcykqKGwtaSksbT0oZC11KSooYy1wKTtpZihoPD0wfHxtPD0wKXJldHVybiAwO2xldCBmPU1hdGgubWF4KHMsdSksZz1NYXRoLm1heChpLHApLGI9TWF0aC5taW4obyxkKSx5PU1hdGgubWluKGwsYykseD1NYXRoLm1heChiLWYsMCkqTWF0aC5tYXgoeS1nLDApO3JldHVybiB4LyhoK20teCl9ZnVuY3Rpb24geVcoZSx0LG4pe2xldCBhPU1hdGguZXhwKHQqbipuKTtyZXR1cm4gbjw9ZT9hOjB9ZnVuY3Rpb24gdEkoZSx0KXtyZXR1cm4gZS5zY29yZS10LnNjb3JlfHxlLnNjb3JlPT09dC5zY29yZSYmdC5ib3hJbmRleC1lLmJveEluZGV4fWFzeW5jIGZ1bmN0aW9uIHhXKGUsdCxuLGE9LjUscj1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpe2xldCBzPUUoZSxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLGk9RSh0LFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLG89YXAocyxpLG4sYSxyKTtuPW8ubWF4T3V0cHV0U2l6ZSxhPW8uaW91VGhyZXNob2xkLHI9by5zY29yZVRocmVzaG9sZDtsZXQgbD1hd2FpdCBQcm9taXNlLmFsbChbcy5kYXRhKCksaS5kYXRhKCldKSx1PWxbMF0scD1sWzFdLHtzZWxlY3RlZEluZGljZXM6ZH09U1QodSxwLG4sYSxyKTtyZXR1cm4gcyE9PWUmJnMuZGlzcG9zZSgpLGkhPT10JiZpLmRpc3Bvc2UoKSxqZShkLFwiaW50MzJcIil9dmFyIHZXPXhXO2Z1bmN0aW9uIHdXKGUsdCxuLGE9LjUscj1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkscz0wKXtsZXQgaT1FKGUsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIiksbz1FKHQsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLGw9YXAoaSxvLG4sYSxyLHMpO249bC5tYXhPdXRwdXRTaXplLGE9bC5pb3VUaHJlc2hvbGQscj1sLnNjb3JlVGhyZXNob2xkLHM9bC5zb2Z0Tm1zU2lnbWE7bGV0IHU9e2JveGVzOmksc2NvcmVzOm99LHA9e21heE91dHB1dFNpemU6bixpb3VUaHJlc2hvbGQ6YSxzY29yZVRocmVzaG9sZDpyLHNvZnRObXNTaWdtYTpzfSxkPVAucnVuS2VybmVsKEZ1LHUscCk7cmV0dXJue3NlbGVjdGVkSW5kaWNlczpkWzBdLHNlbGVjdGVkU2NvcmVzOmRbMV19fXZhciBrVz1MKHtub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZV86d1d9KTthc3luYyBmdW5jdGlvbiBJVyhlLHQsbixhPS41LHI9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHM9MCl7bGV0IGk9RShlLFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksbz1FKHQsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksbD1hcChpLG8sbixhLHIscyk7bj1sLm1heE91dHB1dFNpemUsYT1sLmlvdVRocmVzaG9sZCxyPWwuc2NvcmVUaHJlc2hvbGQscz1sLnNvZnRObXNTaWdtYTtsZXQgdT1hd2FpdCBQcm9taXNlLmFsbChbaS5kYXRhKCksby5kYXRhKCldKSxwPXVbMF0sZD11WzFdLHtzZWxlY3RlZEluZGljZXM6YyxzZWxlY3RlZFNjb3JlczpofT1UVChwLGQsbixhLHIscyk7cmV0dXJuIGkhPT1lJiZpLmRpc3Bvc2UoKSxvIT09dCYmby5kaXNwb3NlKCkse3NlbGVjdGVkSW5kaWNlczpqZShjLFwiaW50MzJcIiksc2VsZWN0ZWRTY29yZXM6amUoaCl9fXZhciBTVz1JVztmdW5jdGlvbiBOVyhlLHQsbixhPS41LHI9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHM9ITEpe2xldCBpPUUoZSxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxvPUUodCxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIiksbD1hcChpLG8sbixhLHIsbnVsbCksdT1sLm1heE91dHB1dFNpemUscD1sLmlvdVRocmVzaG9sZCxkPWwuc2NvcmVUaHJlc2hvbGQsYz17Ym94ZXM6aSxzY29yZXM6b30saD17bWF4T3V0cHV0U2l6ZTp1LGlvdVRocmVzaG9sZDpwLHNjb3JlVGhyZXNob2xkOmQscGFkVG9NYXhPdXRwdXRTaXplOnN9LG09UC5ydW5LZXJuZWwoQXUsYyxoKTtyZXR1cm57c2VsZWN0ZWRJbmRpY2VzOm1bMF0sdmFsaWRPdXRwdXRzOm1bMV19fXZhciBUVz1MKHtub25NYXhTdXBwcmVzc2lvblBhZGRlZF86Tld9KTthc3luYyBmdW5jdGlvbiBDVyhlLHQsbixhPS41LHI9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHM9ITEpe2xldCBpPUUoZSxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLG89RSh0LFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLGw9YXAoaSxvLG4sYSxyLG51bGwpLHU9bC5tYXhPdXRwdXRTaXplLHA9bC5pb3VUaHJlc2hvbGQsZD1sLnNjb3JlVGhyZXNob2xkLFtjLGhdPWF3YWl0IFByb21pc2UuYWxsKFtpLmRhdGEoKSxvLmRhdGEoKV0pLHtzZWxlY3RlZEluZGljZXM6bSx2YWxpZE91dHB1dHM6Zn09TlQoYyxoLHUscCxkLHMpO3JldHVybiBpIT09ZSYmaS5kaXNwb3NlKCksbyE9PXQmJm8uZGlzcG9zZSgpLHtzZWxlY3RlZEluZGljZXM6amUobSxcImludDMyXCIpLHZhbGlkT3V0cHV0czp4ZShmLFwiaW50MzJcIil9fXZhciBFVz1DVztmdW5jdGlvbiBfVyhlLHQsbj0hMSxhPSExKXtsZXQgcj1FKGUsXCJpbWFnZXNcIixcInJlc2l6ZUJpbGluZWFyXCIpO0Eoci5yYW5rPT09M3x8ci5yYW5rPT09NCwoKT0+YEVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiB4IG11c3QgYmUgcmFuayAzIG9yIDQsIGJ1dCBnb3QgcmFuayAke3IucmFua30uYCksQSh0Lmxlbmd0aD09PTIsKCk9PmBFcnJvciBpbiByZXNpemVCaWxpbmVhcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgJHt0fS5gKSxBKGE9PT0hMXx8bj09PSExLCgpPT5cIkVycm9yIGluIHJlc2l6ZUJpbGluZWFyOiBJZiBoYWxmUGl4ZWxDZW50ZXJzIGlzIHRydWUsIGFsaWduQ29ybmVycyBtdXN0IGJlIGZhbHNlLlwiKTtsZXQgcz1yLGk9ITE7ci5yYW5rPT09MyYmKGk9ITAscz1XKHIsWzEsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl1dKSk7bGV0W109dCxvPXtpbWFnZXM6c30sbD17YWxpZ25Db3JuZXJzOm4saGFsZlBpeGVsQ2VudGVyczphLHNpemU6dH0sdT1QLnJ1bktlcm5lbChUbyxvLGwpO3JldHVybiBpP1codSxbdS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM11dKTp1fXZhciBDVD1MKHtyZXNpemVCaWxpbmVhcl86X1d9KTtmdW5jdGlvbiBBVyhlLHQsbj0hMSxhPSExKXtsZXQgcj1FKGUsXCJpbWFnZXNcIixcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiKTtBKHIucmFuaz09PTN8fHIucmFuaz09PTQsKCk9PmBFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rICR7ci5yYW5rfS5gKSxBKHQubGVuZ3RoPT09MiwoKT0+YEVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgJHt0fS5gKSxBKHIuZHR5cGU9PT1cImZsb2F0MzJcInx8ci5kdHlwZT09PVwiaW50MzJcIiwoKT0+XCJgaW1hZ2VzYCBtdXN0IGhhdmUgYGludDMyYCBvciBgZmxvYXQzMmAgYXMgZHR5cGVcIiksQShhPT09ITF8fG49PT0hMSwoKT0+XCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IElmIGhhbGZQaXhlbENlbnRlcnMgaXMgdHJ1ZSwgYWxpZ25Db3JuZXJzIG11c3QgYmUgZmFsc2UuXCIpO2xldCBzPXIsaT0hMTtyLnJhbms9PT0zJiYoaT0hMCxzPVcocixbMSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXV0pKTtsZXRbXT10LG89e2ltYWdlczpzfSxsPXthbGlnbkNvcm5lcnM6bixoYWxmUGl4ZWxDZW50ZXJzOmEsc2l6ZTp0fSx1PVAucnVuS2VybmVsKE5vLG8sbCk7cmV0dXJuIGk/Vyh1LFt1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXV0pOnV9dmFyIEVUPUwoe3Jlc2l6ZU5lYXJlc3ROZWlnaGJvcl86QVd9KTtmdW5jdGlvbiBGVyhlLHQ9XCJiaW5hcnlcIixuPSExLGE9LjUpe2xldCByPUUoZSxcImltYWdlXCIsXCJ0aHJlc2hvbGRcIikscz0uMjk4OSxpPS41ODcsbz0uMTE0LGw9ci5zaGFwZVswXSpyLnNoYXBlWzFdLHU9eihqZShbYV0pLDI1NSkscCxkLGMsaDtpZihBKHIucmFuaz09PTMsKCk9PmBFcnJvciBpbiB0aHJlc2hvbGQ6IGltYWdlIG11c3QgYmUgcmFuayAzLGJ1dCBnb3QgcmFuayAke3IucmFua30uYCksQShyLnNoYXBlWzJdPT09M3x8ci5zaGFwZVsyXT09PTEsKCk9PmBFcnJvciBpbiB0aHJlc2hvbGQ6IGltYWdlIGNvbG9yIGNoYW5uZWwgbXVzdCBiZSBlcXVhbCB0byAzIG9yIDFidXQgZ290ICR7ci5zaGFwZVsyXX0uYCksQShyLmR0eXBlPT09XCJpbnQzMlwifHxyLmR0eXBlPT09XCJmbG9hdDMyXCIsKCk9PmBFcnJvciBpbiBkdHlwZTogaW1hZ2UgZHR5cGUgbXVzdCBiZSBpbnQzMiBvciBmbG9hdDMyLGJ1dCBnb3QgZHR5cGUgJHtyLmR0eXBlfS5gKSxBKHQ9PT1cIm90c3VcInx8dD09PVwiYmluYXJ5XCIsKCk9PmBNZXRob2QgbXVzdCBiZSBiaW5hcnkgb3Igb3RzdSwgYnV0IHdhcyAke3R9YCksci5zaGFwZVsyXT09PTMpe1twLGQsY109TG4ocixbMSwxLDFdLC0xKTtsZXQgZj16KHAscyksZz16KGQsaSksYj16KGMsbyk7aD1YKFgoZixnKSxiKX1lbHNlIGg9ZTtpZih0PT09XCJvdHN1XCIpe2xldCBmPVl2KHJlKFptKGgpLFwiaW50MzJcIiksYm4oW10pLDI1Nik7dT0kVyhmLGwpfWxldCBtPW4/Q3MoaCx1KTpDbihoLHUpO3JldHVybiByZSh6KG0sMjU1KSxcImludDMyXCIpfWZ1bmN0aW9uICRXKGUsdCl7bGV0IG49amUoWy0xXSksYT1qZShbMF0pLHI9amUoWzBdKSxzLGksbyxsLHUscDtmb3IobGV0IGQ9MDtkPGUuc2l6ZS0xO2QrKyl7cz1WZShlLDAsZCsxKSxpPVZlKGUsZCsxKSx1PWhlKGZlKHMpLHQpLHA9aGUoZmUoaSksdCk7bGV0IGM9ZmUoeihzLGdpKDAscy5zaXplKSkpO289aGUoYyxmZShzKSk7bGV0IGg9eW4oaS5zaGFwZSxzLnNpemUpLG09WChnaSgwLGkuc2l6ZSksaCksZj16KGksbSk7bD1oZShmZShmKSxmZShpKSk7bGV0IGc9cGUobyxsKSxiPXBlKG8sbCkseT16KHUscCk7cj16KHooeSxnKSxiKTtsZXQgeD1DbihyLGEpO2E9bm4oeCxyLGEpLG49bm4oeCxqZShbZF0pLG4pfXJldHVybiBufXZhciBEVz1MKHt0aHJlc2hvbGRfOkZXfSk7ZnVuY3Rpb24gUlcoZSx0LG49XCJuZWFyZXN0XCIsYT1cImNvbnN0YW50XCIscj0wLHMpe2xldCBpPUUoZSxcImltYWdlXCIsXCJ0cmFuc2Zvcm1cIixcImZsb2F0MzJcIiksbz1FKHQsXCJ0cmFuc2Zvcm1zXCIsXCJ0cmFuc2Zvcm1cIixcImZsb2F0MzJcIik7QShpLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gdHJhbnNmb3JtOiBpbWFnZSBtdXN0IGJlIHJhbmsgNCxidXQgZ290IHJhbmsgJHtpLnJhbmt9LmApLEEoby5yYW5rPT09MiYmKG8uc2hhcGVbMF09PT1pLnNoYXBlWzBdfHxvLnNoYXBlWzBdPT09MSkmJm8uc2hhcGVbMV09PT04LCgpPT5cIkVycm9yIGluIHRyYW5zZm9ybTogSW5wdXQgdHJhbnNmb3JtIHNob3VsZCBiZSBiYXRjaCB4IDggb3IgMSB4IDhcIiksQShzPT1udWxsfHxzLmxlbmd0aD09PTIsKCk9PmBFcnJvciBpbiB0cmFuc2Zvcm06IG91dHB1dFNoYXBlIG11c3QgYmUgW2hlaWdodCwgd2lkdGhdIG9yIG51bGwsIGJ1dCBnb3QgJHtzfS5gKTtsZXQgbD17aW1hZ2U6aSx0cmFuc2Zvcm1zOm99LHU9e2ludGVycG9sYXRpb246bixmaWxsTW9kZTphLGZpbGxWYWx1ZTpyLG91dHB1dFNoYXBlOnN9O3JldHVybiBQLnJ1bktlcm5lbChLdSxsLHUpfXZhciBNVz1MKHt0cmFuc2Zvcm1fOlJXfSk7ZnVuY3Rpb24gT1coZSx0LG4pe2xldCBhPUUoZSxcImFcIixcImJhbmRQYXJ0XCIpO0EoYS5yYW5rPj0yLCgpPT5gYmFuZFBhcnQoKTogUmFuayBtdXN0IGJlIGF0IGxlYXN0IDIsIGdvdCAke2EucmFua30uYCk7bGV0IHI9YS5zaGFwZSxbcyxpXT1hLnNoYXBlLnNsaWNlKC0yKSxvLGw7dHlwZW9mIHQ9PVwibnVtYmVyXCI/KEEodCUxPT09MCwoKT0+YGJhbmRQYXJ0KCk6IG51bUxvd2VyIG11c3QgYmUgYW4gaW50ZWdlciwgZ290ICR7dH0uYCksQSh0PD1zLCgpPT5gYmFuZFBhcnQoKTogbnVtTG93ZXIgKCR7dH0pIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHJvd3MgKCR7c30pLmApLG89RSh0PDA/czp0LFwibnVtTG93ZXJcIixcImJhbmRQYXJ0XCIpKTooQSh0LmR0eXBlPT09XCJpbnQzMlwiLCgpPT5cImJhbmRQYXJ0KCk6IG51bUxvd2VyJ3MgZHR5cGUgbXVzdCBiZSBhbiBpbnQzMi5cIiksbz1ubihQbCh0LDApLHMsZHModCxzKSkpLHR5cGVvZiBuPT1cIm51bWJlclwiPyhBKG4lMT09PTAsKCk9PmBiYW5kUGFydCgpOiBudW1VcHBlciBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCAke259LmApLEEobjw9aSwoKT0+YGJhbmRQYXJ0KCk6IG51bVVwcGVyICgke259KSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBjb2x1bW5zICgke2l9KS5gKSxsPUUobjwwP2k6bixcIm51bVVwcGVyXCIsXCJiYW5kUGFydFwiKSk6KEEobi5kdHlwZT09PVwiaW50MzJcIiwoKT0+XCJiYW5kUGFydCgpOiBudW1VcHBlcidzIGR0eXBlIG11c3QgYmUgYW4gaW50MzIuXCIpLGw9bm4oUGwobiwwKSxpLGRzKG4saSkpKTtsZXQgdT1XKGdpKDAscywxLFwiaW50MzJcIiksWy0xLDFdKSxwPWdpKDAsaSwxLFwiaW50MzJcIiksZD1wZSh1LHApLGM9X2EoQ3MoZCxvKSwkcihkLHl0KGwpKSksaD1JdChbcyxpXSxhLmR0eXBlKTtyZXR1cm4gVyhBdChkdChXKGEsWy0xLHMsaV0pKS5tYXAobT0+bm4oYyxtLGgpKSkscil9dmFyIFBXPUwoe2JhbmRQYXJ0XzpPV30pO2Z1bmN0aW9uIExXKGUpe2xldCB0O2lmKEFycmF5LmlzQXJyYXkoZSkpe3Q9ITEsQShlIT1udWxsJiZlLmxlbmd0aD4wLCgpPT5cIkdyYW0tU2NobWlkdCBwcm9jZXNzOiBpbnB1dCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5XCIpO2xldCByPWVbMF0uc2hhcGVbMF07Zm9yKGxldCBzPTE7czxlLmxlbmd0aDsrK3MpQShlW3NdLnNoYXBlWzBdPT09ciwoKT0+YEdyYW0tU2NobWlkdDogTm9uLXVuaXF1ZSBsZW5ndGhzIGZvdW5kIGluIHRoZSBpbnB1dCB2ZWN0b3JzOiAoJHtlW3NdLnNoYXBlWzBdfSB2cy4gJHtyfSlgKX1lbHNlIHQ9ITAsZT1MbihlLGUuc2hhcGVbMF0sMCkubWFwKHI9PkFzKHIsWzBdKSk7QShlLmxlbmd0aDw9ZVswXS5zaGFwZVswXSwoKT0+YEdyYW0tU2NobWlkdDogTnVtYmVyIG9mIHZlY3RvcnMgKCR7ZS5sZW5ndGh9KSBleGNlZWRzIG51bWJlciBvZiBkaW1lbnNpb25zICgke2VbMF0uc2hhcGVbMF19KS5gKTtsZXQgbj1bXSxhPWU7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipbi5wdXNoKFAudGlkeSgoKT0+e2xldCBzPWFbcl07aWYocj4wKWZvcihsZXQgaT0wO2k8cjsrK2kpe2xldCBvPXooZmUoeihuW2ldLHMpKSxuW2ldKTtzPXBlKHMsbyl9cmV0dXJuIGhlKHMsZXAocyxcImV1Y2xpZGVhblwiKSl9KSk7cmV0dXJuIHQ/QXQobiwwKTpufXZhciB6Vz1MKHtncmFtU2NobWlkdF86TFd9KTtmdW5jdGlvbiBXVyhlLHQ9ITEpe2lmKEEoZS5yYW5rPj0yLCgpPT5gcXIoKSByZXF1aXJlcyBpbnB1dCB0ZW5zb3IgdG8gaGF2ZSBhIHJhbmsgPj0gMiwgYnV0IGdvdCByYW5rICR7ZS5yYW5rfWApLGUucmFuaz09PTIpcmV0dXJuIG5JKGUsdCk7e2xldCBuPWUuc2hhcGUuc2xpY2UoMCxlLnNoYXBlLmxlbmd0aC0yKS5yZWR1Y2UoKGwsdSk9PmwqdSksYT1kdChXKGUsW24sZS5zaGFwZVtlLnNoYXBlLmxlbmd0aC0yXSxlLnNoYXBlW2Uuc2hhcGUubGVuZ3RoLTFdXSksMCkscj1bXSxzPVtdO2EuZm9yRWFjaChsPT57bGV0W3UscF09bkkobCx0KTtyLnB1c2godSkscy5wdXNoKHApfSk7bGV0IGk9VyhBdChyLDApLGUuc2hhcGUpLG89VyhBdChzLDApLGUuc2hhcGUpO3JldHVybltpLG9dfX1mdW5jdGlvbiBuSShlLHQ9ITEpe3JldHVybiBQLnRpZHkoKCk9PntBKGUuc2hhcGUubGVuZ3RoPT09MiwoKT0+YHFyMmQoKSByZXF1aXJlcyBhIDJEIFRlbnNvciwgYnV0IGdvdCBhICR7ZS5zaGFwZS5sZW5ndGh9RCBUZW5zb3IuYCk7bGV0IG49ZS5zaGFwZVswXSxhPWUuc2hhcGVbMV0scj1HbShuKSxzPXNyKGUpLGk9RWEoW1sxXV0sWzEsMV0pLG89c3IoaSksbD1uPj1hP2E6bjtmb3IobGV0IHU9MDt1PGw7Kyt1KXtsZXQgcD1zLGQ9byxjPXI7W28scyxyXT1QLnRpZHkoKCk9PntsZXQgaD1WZShzLFt1LHVdLFtuLXUsMV0pLG09ZXAoaCksZj1WZShzLFt1LHVdLFsxLDFdKSxnPW5uKENuKGYsMCksRWEoW1stMV1dKSxFYShbWzFdXSkpLGI9cGUoZix6KGcsbSkpLHk9aGUoaCxiKTt5LnNoYXBlWzBdPT09MT9vPXNyKGkpOm89ZXQoW2ksVmUoeSxbMSwwXSxbeS5zaGFwZVswXS0xLHkuc2hhcGVbMV1dKV0sMCk7bGV0IHg9eXQoaGUoJGUoZyxiKSxtKSksdj1WZShzLFt1LDBdLFtuLXUsYV0pLEk9eih4LG8pLE49RGUobyk7aWYodT09PTApcz1wZSh2LCRlKEksJGUoTix2KSkpO2Vsc2V7bGV0IEY9cGUodiwkZShJLCRlKE4sdikpKTtzPWV0KFtWZShzLFswLDBdLFt1LGFdKSxGXSwwKX1sZXQgQz1EZShJKSxfPVZlKHIsWzAsdV0sW24sci5zaGFwZVsxXS11XSk7aWYodT09PTApcj1wZShfLCRlKCRlKF8sbyksQykpO2Vsc2V7bGV0IEY9cGUoXywkZSgkZShfLG8pLEMpKTtyPWV0KFtWZShyLFswLDBdLFtuLHVdKSxGXSwxKX1yZXR1cm5bbyxzLHJdfSksRWUoW3AsZCxjXSl9cmV0dXJuIXQmJm4+YSYmKHI9VmUocixbMCwwXSxbbixhXSkscz1WZShzLFswLDBdLFthLGFdKSksW3Isc119KX12YXIgQlc9TCh7cXJfOldXfSksa247KGZ1bmN0aW9uKGUpe2VbZS5OT05FPTBdPVwiTk9ORVwiLGVbZS5NRUFOPTFdPVwiTUVBTlwiLGVbZS5TVU09Ml09XCJTVU1cIixlW2UuU1VNX0JZX05PTlpFUk9fV0VJR0hUUz0zXT1cIlNVTV9CWV9OT05aRVJPX1dFSUdIVFNcIn0pKGtufHwoa249e30pKTtmdW5jdGlvbiBWVyhlLHQsbj1rbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtsZXQgYT1FKGUsXCJsb3NzZXNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIikscj1udWxsO3QhPW51bGwmJihyPUUodCxcIndlaWdodHNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIikpO2xldCBzPXI9PW51bGw/YTp6KGEscik7aWYobj09PWtuLk5PTkUpcmV0dXJuIHM7aWYobj09PWtuLlNVTSlyZXR1cm4gZmUocyk7aWYobj09PWtuLk1FQU4pe2lmKHI9PW51bGwpcmV0dXJuIEN0KHMpO3tsZXQgaT1hLnNpemUvci5zaXplLG89aGUoZmUocyksZmUocikpO3JldHVybiBpPjE/aGUobyx4ZShpKSk6b319aWYobj09PWtuLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2lmKHI9PW51bGwpcmV0dXJuIGhlKGZlKHMpLHhlKGEuc2l6ZSkpO3tsZXQgaT16KHIsUG4oYS5zaGFwZSkpLG89cmUoZmUoZmkoaSx4ZSgwKSkpLFwiZmxvYXQzMlwiKTtyZXR1cm4gaGUoZmUocyksbyl9fXRocm93IEVycm9yKGBVbmtub3duIHJlZHVjdGlvbjogJHtufWApfXZhciBEcj1MKHtjb21wdXRlV2VpZ2h0ZWRMb3NzXzpWV30pO2Z1bmN0aW9uIFVXKGUsdCxuLGE9a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IHI9RShlLFwibGFiZWxzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIikscz1FKHQsXCJwcmVkaWN0aW9uc1wiLFwiYWJzb2x1dGVEaWZmZXJlbmNlXCIpLGk9bnVsbDtuIT1udWxsJiYoaT1FKG4sXCJ3ZWlnaHRzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIikpLE5uKHIuc2hhcGUscy5zaGFwZSxcIkVycm9yIGluIGFic29sdXRlRGlmZmVyZW5jZTogXCIpO2xldCBvPUx0KHBlKHIscykpO3JldHVybiBEcihvLGksYSl9dmFyIEdXPUwoe2Fic29sdXRlRGlmZmVyZW5jZV86VVd9KTtmdW5jdGlvbiBIVyhlLHQsbixhLHI9a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IHM9RShlLFwibGFiZWxzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxpPUUodCxcInByZWRpY3Rpb25zXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxvPW51bGw7YSE9bnVsbCYmKG89RShhLFwid2VpZ2h0c1wiLFwiY29zaW5lRGlzdGFuY2VcIikpLE5uKHMuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGNvc2luZURpc3RhbmNlOiBcIik7bGV0IGw9eGUoMSksdT1wZShsLGZlKHoocyxpKSxuLCEwKSk7cmV0dXJuIERyKHUsbyxyKX12YXIgalc9TCh7Y29zaW5lRGlzdGFuY2VfOkhXfSk7ZnVuY3Rpb24gcVcoZSx0LG4sYT1rbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtsZXQgcj1FKGUsXCJsYWJlbHNcIixcImhpbmdlTG9zc1wiKSxzPUUodCxcInByZWRpY3Rpb25zXCIsXCJoaW5nZUxvc3NcIiksaT1udWxsO24hPW51bGwmJihpPUUobixcIndlaWdodHNcIixcImhpbmdlTG9zc1wiKSksTm4oci5zaGFwZSxzLnNoYXBlLFwiRXJyb3IgaW4gaGluZ2VMb3NzOiBcIik7bGV0IG89eGUoMSk7cj1wZSh6KHhlKDIpLHIpLG8pO2xldCBsPUtlKHBlKG8seihyLHMpKSk7cmV0dXJuIERyKGwsaSxhKX12YXIgS1c9TCh7aGluZ2VMb3NzXzpxV30pO2Z1bmN0aW9uIFhXKGUsdCxuLGE9MSxyPWtuLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpe2xldCBzPUUoZSxcImxhYmVsc1wiLFwiaHViZXJMb3NzXCIpLGk9RSh0LFwicHJlZGljdGlvbnNcIixcImh1YmVyTG9zc1wiKSxvPW51bGw7biE9bnVsbCYmKG89RShuLFwid2VpZ2h0c1wiLFwiaHViZXJMb3NzXCIpKSxObihzLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBodWJlckxvc3M6IFwiKTtsZXQgbD14ZShhKSx1PUx0KHBlKGkscykpLHA9ZHModSxsKSxkPXBlKHUscCksYz1YKHooeGUoLjUpLHB0KHApKSx6KGwsZCkpO3JldHVybiBEcihjLG8scil9dmFyIFlXPUwoe2h1YmVyTG9zc186WFd9KTtmdW5jdGlvbiBaVyhlLHQsbixhPTFlLTcscj1rbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtsZXQgcz1FKGUsXCJsYWJlbHNcIixcImxvZ0xvc3NcIiksaT1FKHQsXCJwcmVkaWN0aW9uc1wiLFwibG9nTG9zc1wiKSxvPW51bGw7biE9bnVsbCYmKG89RShuLFwid2VpZ2h0c1wiLFwibG9nTG9zc1wiKSksTm4ocy5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gbG9nTG9zczogXCIpO2xldCBsPXhlKDEpLHU9eGUoYSkscD15dCh6KHMsUW4oWChpLHUpKSkpLGQ9eihwZShsLHMpLFFuKFgocGUobCxpKSx1KSkpLGM9cGUocCxkKTtyZXR1cm4gRHIoYyxvLHIpfXZhciBKVz1MKHtsb2dMb3NzXzpaV30pO2Z1bmN0aW9uIFFXKGUsdCxuLGE9a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IHI9RShlLFwibGFiZWxzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpLHM9RSh0LFwicHJlZGljdGlvbnNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksaT1udWxsO24hPW51bGwmJihpPUUobixcIndlaWdodHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIikpLE5uKHIuc2hhcGUscy5zaGFwZSxcIkVycm9yIGluIG1lYW5TcXVhcmVkRXJyb3I6IFwiKTtsZXQgbz1yZihyLHMpO3JldHVybiBEcihvLGksYSl9dmFyIGVCPUwoe21lYW5TcXVhcmVkRXJyb3JfOlFXfSk7ZnVuY3Rpb24gdEIoZSx0KXtsZXQgbj1FKGUsXCJsYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpLGE9RSh0LFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKTtObihuLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0czogXCIpO2xldCByPUtlKGEpLHM9eihhLG4pLGk9cGQoZG4oeXQoTHQoYSkpKSk7cmV0dXJuIFgocGUocixzKSxpKX1mdW5jdGlvbiBuQihlLHQsbixhPTAscj1rbi5TVU1fQllfTk9OWkVST19XRUlHSFRTKXtsZXQgcz1FKGUsXCJtdWx0aUNsYXNzTGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLGk9RSh0LFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLG89bnVsbDtpZihuIT1udWxsJiYobz1FKG4sXCJ3ZWlnaHRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpKSxObihzLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5OiBcIiksYT4wKXtsZXQgdT14ZShhKSxwPXhlKDEpLGQ9eGUoLjUpO3M9WCh6KHMscGUocCx1KSkseihkLHUpKX1sZXQgbD10QihzLGkpO3JldHVybiBEcihsLG8scil9dmFyIGFCPUwoe3NpZ21vaWRDcm9zc0VudHJvcHlfOm5CfSk7ZnVuY3Rpb24gckIoZSx0LG49LTEpe2lmKG49PT0tMSYmKG49dC5yYW5rLTEpLG4hPT10LnJhbmstMSl0aHJvdyBFcnJvcihgU29mdG1heCBjcm9zcyBlbnRyb3B5IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMYWJlbHMgLyBsb2dpdHMgd2FzIHJhbmsgJHt0LnJhbmt9IGFuZCBkaW0gd2FzICR7bn1gKTtyZXR1cm4gcHIoKGEscixzKT0+e2xldCBpPWNkKHIsW25dLCEwKSxvPXBlKHJlKHIsXCJmbG9hdDMyXCIpLGkpO3MoW2Esb10pO2xldCBsPXl0KHoobyxhKSk7cmV0dXJue3ZhbHVlOmZlKGwsW25dKSxncmFkRnVuYzoodSxwKT0+e2xldFtkLGNdPXAsaD1taSh1LnNoYXBlLFtuXSk7cmV0dXJuW3ooVyh1LGgpLHBlKHJlKGQsXCJmbG9hdDMyXCIpLGRuKGMpKSkseihXKHUsaCkscGUoZG4oYykscmUoZCxcImZsb2F0MzJcIikpKV19fX0pKGUsdCl9ZnVuY3Rpb24gc0IoZSx0LG4sYT0wLHI9a24uU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7bGV0IHM9RShlLFwib25laG90TGFiZWxzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLGk9RSh0LFwibG9naXRzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLG89bnVsbDtpZihuIT1udWxsJiYobz1FKG4sXCJ3ZWlnaHRzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpKSxObihzLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzb2Z0bWF4Q3Jvc3NFbnRyb3B5OiBcIiksYT4wKXtsZXQgdT14ZShhKSxwPXhlKDEpLGQ9eGUocy5zaGFwZVsxXSk7cz1YKHoocyxwZShwLHUpKSxoZSh1LGQpKX1sZXQgbD1yQihzLGkpO3JldHVybiBEcihsLG8scil9dmFyIGlCPUwoe3NvZnRtYXhDcm9zc0VudHJvcHlfOnNCfSk7ZnVuY3Rpb24gb0IoZSx0LG4sYSl7bGV0IHI9RShlLFwiaW5kaWNlc1wiLFwic3BhcnNlRmlsbEVtcHR5Um93c1wiLFwiaW50MzJcIikscz1FKHQsXCJ2YWx1ZXNcIixcInNwYXJzZUZpbGxFbXB0eVJvd3NcIiksaT1FKG4sXCJkZW5zZVNoYXBlXCIsXCJzcGFyc2VGaWxsRW1wdHlSb3dzXCIsXCJpbnQzMlwiKSxvPUUoYSxcImRlZmF1bHRWYWx1ZVwiLFwic3BhcnNlRmlsbEVtcHR5Um93c1wiLHMuZHR5cGUpO2lmKHIucmFuayE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBUZW5zb3IyRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgJHtyLnNoYXBlfWApO2lmKHMucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBWYWx1ZXMgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZSAke3Muc2hhcGV9YCk7aWYoaS5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYERlbnNlIHNoYXBlIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGUgJHtpLnNoYXBlfWApO2lmKG8ucmFuayE9PTApdGhyb3cgbmV3IEVycm9yKGBEZWZhdWx0IHZhbHVlIHNob3VsZCBiZSBhIHNjYWxhciBidXQgcmVjZWl2ZWQgc2hhcGUgJHtvLnNoYXBlfWApO2xldCBsPXtpbmRpY2VzOnIsdmFsdWVzOnMsZGVuc2VTaGFwZTppLGRlZmF1bHRWYWx1ZTpvfSx1PVAucnVuS2VybmVsKEdjLGwpO3JldHVybntvdXRwdXRJbmRpY2VzOnVbMF0sb3V0cHV0VmFsdWVzOnVbMV0sZW1wdHlSb3dJbmRpY2F0b3I6dVsyXSxyZXZlcnNlSW5kZXhNYXA6dVszXX19dmFyIGxCPUwoe3NwYXJzZUZpbGxFbXB0eVJvd3NfOm9CfSk7ZnVuY3Rpb24gdUIoZSx0LG4pe2xldCBhPUUoZSxcImlucHV0SW5kaWNlc1wiLFwic3BhcnNlUmVzaGFwZVwiLFwiaW50MzJcIikscj1FKHQsXCJpbnB1dFNoYXBlXCIsXCJzcGFyc2VSZXNoYXBlXCIsXCJpbnQzMlwiKSxzPUUobixcIm5ld1NoYXBlXCIsXCJzcGFyc2VSZXNoYXBlXCIsXCJpbnQzMlwiKTtpZihhLnJhbmshPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgaW5kaWNlcyBzaG91bGQgYmUgVGVuc29yMkQgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICR7YS5zaGFwZX1gKTtpZihyLnJhbmshPT0xKXRocm93IG5ldyBFcnJvcihgSW5wdXQgc2hhcGUgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZSAke3Iuc2hhcGV9YCk7aWYocy5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYE5ldyBzaGFwZSBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlICR7cy5zaGFwZX1gKTtsZXQgaT17aW5wdXRJbmRpY2VzOmEsaW5wdXRTaGFwZTpyLG5ld1NoYXBlOnN9LG89UC5ydW5LZXJuZWwoR3UsaSk7cmV0dXJue291dHB1dEluZGljZXM6b1swXSxvdXRwdXRTaGFwZTpvWzFdfX12YXIgcEI9TCh7c3BhcnNlUmVzaGFwZV86dUJ9KTtmdW5jdGlvbiBjQihlLHQsbil7bGV0IGE9RShlLFwiZGF0YVwiLFwic3BhcnNlU2VnbWVudE1lYW5cIikscj1FKHQsXCJpbmRpY2VzXCIsXCJzcGFyc2VTZWdtZW50TWVhblwiLFwiaW50MzJcIikscz1FKG4sXCJzZWdtZW50SWRzXCIsXCJzcGFyc2VTZWdtZW50TWVhblwiLFwiaW50MzJcIik7aWYoYS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBzaG91bGQgYmUgYXQgbGVhc3QgMSBkaW1lbnNpb25hbCBidXQgcmVjZWl2ZWQgc2NhbGFyXCIpO2lmKHIucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICAke3Iuc2hhcGV9YCk7aWYocy5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYFNlZ21lbnQgaWRzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICAke3Muc2hhcGV9YCk7bGV0IGk9e2RhdGE6YSxpbmRpY2VzOnIsc2VnbWVudElkczpzfTtyZXR1cm4gUC5ydW5LZXJuZWwoSGMsaSl9dmFyIGRCPUwoe3NwYXJzZVNlZ21lbnRNZWFuXzpjQn0pO2Z1bmN0aW9uIGhCKGUsdCxuKXtsZXQgYT1FKGUsXCJkYXRhXCIsXCJzcGFyc2VTZWdtZW50U3VtXCIpLHI9RSh0LFwiaW5kaWNlc1wiLFwic3BhcnNlU2VnbWVudFN1bVwiLFwiaW50MzJcIikscz1FKG4sXCJzZWdtZW50SWRzXCIsXCJzcGFyc2VTZWdtZW50U3VtXCIsXCJpbnQzMlwiKTtpZihhLnJhbms8MSl0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHNob3VsZCBiZSBhdCBsZWFzdCAxIGRpbWVuc2lvbmFsIGJ1dCByZWNlaXZlZCBzY2FsYXJcIik7aWYoci5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgJHtyLnNoYXBlfWApO2lmKHMucmFuayE9PTEpdGhyb3cgbmV3IEVycm9yKGBTZWdtZW50IGlkcyBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAke3Muc2hhcGV9YCk7bGV0IGk9e2RhdGE6YSxpbmRpY2VzOnIsc2VnbWVudElkczpzfTtyZXR1cm4gUC5ydW5LZXJuZWwoamMsaSl9dmFyIG1CPUwoe3NwYXJzZVNlZ21lbnRTdW1fOmhCfSk7ZnVuY3Rpb24gZkIoZSx0LG4sYSxyLHMsaSxvKXtsZXQgbD1FKGUsXCJkYXRhXCIsXCJzdHJpbmdOR3JhbXNcIixcInN0cmluZ1wiKTtpZihsLmR0eXBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIG11c3QgYmUgb2YgZGF0YXR5cGUgc3RyaW5nXCIpO2lmKGwuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYERhdGEgbXVzdCBiZSBhIHZlY3Rvciwgc2F3OiAke2wuc2hhcGV9YCk7bGV0IHU9RSh0LFwiZGF0YVNwbGl0c1wiLFwic3RyaW5nTkdyYW1zXCIpO2lmKHUuZHR5cGUhPT1cImludDMyXCIpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBzcGxpdHMgbXVzdCBiZSBvZiBkYXRhdHlwZSBpbnQzMlwiKTtsZXQgcD17c2VwYXJhdG9yOm4sbkdyYW1XaWR0aHM6YSxsZWZ0UGFkOnIscmlnaHRQYWQ6cyxwYWRXaWR0aDppLHByZXNlcnZlU2hvcnRTZXF1ZW5jZXM6b30sZD17ZGF0YTpsLGRhdGFTcGxpdHM6dX0sYz1QLnJ1bktlcm5lbChYYyxkLHApO3JldHVybntuR3JhbXM6Y1swXSxuR3JhbXNTcGxpdHM6Y1sxXX19dmFyIGdCPUwoe3N0cmluZ05HcmFtc186ZkJ9KTtmdW5jdGlvbiBiQihlLHQsbj0hMCl7bGV0IGE9RShlLFwiaW5wdXRcIixcInN0cmluZ1NwbGl0XCIsXCJzdHJpbmdcIikscj1FKHQsXCJkZWxpbWl0ZXJcIixcInN0cmluZ1NwbGl0XCIsXCJzdHJpbmdcIik7aWYoYS5yYW5rIT09MSl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGUgJHthLnNoYXBlfWApO2lmKHIucmFuayE9PTApdGhyb3cgbmV3IEVycm9yKGBEZWxpbWl0ZXIgc2hvdWxkIGJlIGEgc2NhbGFyIGJ1dCByZWNlaXZlZCBzaGFwZSAke3Iuc2hhcGV9YCk7bGV0IHM9e3NraXBFbXB0eTpufSxpPXtpbnB1dDphLGRlbGltaXRlcjpyfSxvPVAucnVuS2VybmVsKFljLGkscyk7cmV0dXJue2luZGljZXM6b1swXSx2YWx1ZXM6b1sxXSxzaGFwZTpvWzJdfX12YXIgeUI9TCh7c3RyaW5nU3BsaXRfOmJCfSk7ZnVuY3Rpb24geEIoZSx0KXtsZXQgbj1FKGUsXCJpbnB1dFwiLFwic3RyaW5nVG9IYXNoQnVja2V0RmFzdFwiLFwic3RyaW5nXCIpLGE9e251bUJ1Y2tldHM6dH07aWYodDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYnVja2V0cyBtdXN0IGJlIGF0IGxlYXN0IDFcIik7bGV0IHI9e2lucHV0Om59O3JldHVybiBQLnJ1bktlcm5lbChaYyxyLGEpfXZhciB2Qj1MKHtzdHJpbmdUb0hhc2hCdWNrZXRGYXN0Xzp4Qn0pO2Z1bmN0aW9uIHdCKGUsdCxuLGE9ITApe2xldCByPUUoZSxcImlucHV0XCIsXCJzdGF0aWNSZWdleFJlcGxhY2VcIixcInN0cmluZ1wiKSxzPXtwYXR0ZXJuOnQscmV3cml0ZTpuLHJlcGxhY2VHbG9iYWw6YX07cmV0dXJuIFAucnVuS2VybmVsKEtjLHt4OnJ9LHMpfXZhciBrQj1MKHtzdGF0aWNSZWdleFJlcGxhY2VfOndCfSksX1Q9e2ZmdDpiZCxpZmZ0OkJsLHJmZnQ6eWQsaXJmZnQ6YWZ9LEFUPXtoYW1taW5nV2luZG93Oll6LGhhbm5XaW5kb3c6a1QsZnJhbWU6SVQsc3RmdDplV30sWm49e2ZsaXBMZWZ0UmlnaHQ6clcsZ3JheXNjYWxlVG9SR0I6aVcscmVzaXplTmVhcmVzdE5laWdoYm9yOkVULHJlc2l6ZUJpbGluZWFyOkNULHJnYlRvR3JheXNjYWxlOmxXLHJvdGF0ZVdpdGhPZmZzZXQ6cFcsY3JvcEFuZFJlc2l6ZTpuVyxub25NYXhTdXBwcmVzc2lvbjpkVyxub25NYXhTdXBwcmVzc2lvbkFzeW5jOnZXLG5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlOmtXLG5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlQXN5bmM6U1csbm9uTWF4U3VwcHJlc3Npb25QYWRkZWQ6VFcsbm9uTWF4U3VwcHJlc3Npb25QYWRkZWRBc3luYzpFVyx0aHJlc2hvbGQ6RFcsdHJhbnNmb3JtOk1XfSxCdz17YmFuZFBhcnQ6UFcsZ3JhbVNjaG1pZHQ6elcscXI6Qld9LEZUPXthYnNvbHV0ZURpZmZlcmVuY2U6R1csY29tcHV0ZVdlaWdodGVkTG9zczpEcixjb3NpbmVEaXN0YW5jZTpqVyxoaW5nZUxvc3M6S1csaHViZXJMb3NzOllXLGxvZ0xvc3M6SlcsbWVhblNxdWFyZWRFcnJvcjplQixzaWdtb2lkQ3Jvc3NFbnRyb3B5OmFCLHNvZnRtYXhDcm9zc0VudHJvcHk6aUJ9LCRUPXtzcGFyc2VGaWxsRW1wdHlSb3dzOmxCLHNwYXJzZVJlc2hhcGU6cEIsc3BhcnNlU2VnbWVudE1lYW46ZEIsc3BhcnNlU2VnbWVudFN1bTptQn0sRFQ9e3N0cmluZ05HcmFtczpnQixzdHJpbmdTcGxpdDp5QixzdHJpbmdUb0hhc2hCdWNrZXRGYXN0OnZCLHN0YXRpY1JlZ2V4UmVwbGFjZTprQn0sbmU9e307X2UobmUse1NlcmlhbGl6YWJsZTooKT0+UlQsU2VyaWFsaXphdGlvbk1hcDooKT0+TVQsZ2V0UmVnaXN0ZXJlZE5hbWU6KCk9PlNCLHJlZ2lzdGVyQ2xhc3M6KCk9Pk9UfSk7dmFyIElCPW5ldyBNYXAsTXg9bmV3IE1hcCxSVD1jbGFzc3tnZXRDbGFzc05hbWUoKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWV9c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodCl9fSxNVD1jbGFzcyBUbHtjb25zdHJ1Y3Rvcigpe3RoaXMuY2xhc3NOYW1lTWFwPXt9fXN0YXRpYyBnZXRNYXAoKXtyZXR1cm4gVGwuaW5zdGFuY2U9PW51bGwmJihUbC5pbnN0YW5jZT1uZXcgVGwpLFRsLmluc3RhbmNlfXN0YXRpYyByZWdpc3Rlcih0KXtUbC5nZXRNYXAoKS5jbGFzc05hbWVNYXBbdC5jbGFzc05hbWVdPVt0LHQuZnJvbUNvbmZpZ119fTtmdW5jdGlvbiBPVChlLHQsbil7QShlLmNsYXNzTmFtZSE9bnVsbCwoKT0+XCJDbGFzcyBiZWluZyByZWdpc3RlcmVkIGRvZXMgbm90IGhhdmUgdGhlIHN0YXRpYyBjbGFzc05hbWUgcHJvcGVydHkgZGVmaW5lZC5cIiksQSh0eXBlb2YgZS5jbGFzc05hbWU9PVwic3RyaW5nXCIsKCk9PlwiY2xhc3NOYW1lIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nLCBidXQgZ290IHR5cGUgXCIrdHlwZW9mIGUuY2xhc3NOYW1lKSxBKGUuY2xhc3NOYW1lLmxlbmd0aD4wLCgpPT5cIkNsYXNzIGJlaW5nIHJlZ2lzdGVyZWQgaGFzIGFuIGVtcHR5LXN0cmluZyBhcyBpdHMgY2xhc3NOYW1lLCB3aGljaCBpcyBkaXNhbGxvd2VkLlwiKSx0eXBlb2YgdD09XCJ1bmRlZmluZWRcIiYmKHQ9XCJDdXN0b21cIiksdHlwZW9mIG49PVwidW5kZWZpbmVkXCImJihuPWUuY2xhc3NOYW1lKTtsZXQgYT1uLHI9dCtcIj5cIithO3JldHVybiBNVC5yZWdpc3RlcihlKSxJQi5zZXQocixlKSxNeC5zZXQoZSxyKSxlfWZ1bmN0aW9uIFNCKGUpe3JldHVybiBNeC5oYXMoZSk/TXguZ2V0KGUpOmUuY2xhc3NOYW1lfXZhciBScj1jbGFzcyBleHRlbmRzIFJUe21pbmltaXplKGUsdD0hMSxuKXtsZXR7dmFsdWU6YSxncmFkczpyfT10aGlzLmNvbXB1dGVHcmFkaWVudHMoZSxuKTtpZihuIT1udWxsKXtsZXQgcz1uLm1hcChpPT4oe25hbWU6aS5uYW1lLHRlbnNvcjpyW2kubmFtZV19KSk7dGhpcy5hcHBseUdyYWRpZW50cyhzKX1lbHNlIHRoaXMuYXBwbHlHcmFkaWVudHMocik7cmV0dXJuIEVlKHIpLHQ/YTooYS5kaXNwb3NlKCksbnVsbCl9Z2V0IGl0ZXJhdGlvbnMoKXtyZXR1cm4gdGhpcy5pdGVyYXRpb25zXz09bnVsbCYmKHRoaXMuaXRlcmF0aW9uc189MCksdGhpcy5pdGVyYXRpb25zX31pbmNyZW1lbnRJdGVyYXRpb25zKCl7dGhpcy5pdGVyYXRpb25zXz10aGlzLml0ZXJhdGlvbnMrMX1jb21wdXRlR3JhZGllbnRzKGUsdCl7cmV0dXJuIE9OKGUsdCl9ZGlzcG9zZSgpe3RoaXMuaXRlcmF0aW9uc18hPW51bGwmJkVlKHRoaXMuaXRlcmF0aW9uc18pfWFzeW5jIHNhdmVJdGVyYXRpb25zKCl7cmV0dXJuIHRoaXMuaXRlcmF0aW9uc189PW51bGwmJih0aGlzLml0ZXJhdGlvbnNfPTApLHtuYW1lOlwiaXRlclwiLHRlbnNvcjp4ZSh0aGlzLml0ZXJhdGlvbnNfLFwiaW50MzJcIil9fWFzeW5jIGdldFdlaWdodHMoKXt0aHJvdyBuZXcgRXJyb3IoXCJnZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG9wdGltaXplciB5ZXQuXCIpfWFzeW5jIHNldFdlaWdodHMoZSl7dGhyb3cgbmV3IEVycm9yKGBzZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG9wdGltaXplciBjbGFzcyAke3RoaXMuZ2V0Q2xhc3NOYW1lKCl9YCl9YXN5bmMgZXh0cmFjdEl0ZXJhdGlvbnMoZSl7cmV0dXJuIHRoaXMuaXRlcmF0aW9uc189KGF3YWl0IGVbMF0udGVuc29yLmRhdGEoKSlbMF0sZS5zbGljZSgxKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShScixTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmU9PmUubWluaW1pemUhPW51bGwmJmUuY29tcHV0ZUdyYWRpZW50cyE9bnVsbCYmZS5hcHBseUdyYWRpZW50cyE9bnVsbH0pO3ZhciBWdz1jbGFzcyBleHRlbmRzIFJye3N0YXRpYyBnZXQgY2xhc3NOYW1lKCl7cmV0dXJuXCJBZGFkZWx0YVwifWNvbnN0cnVjdG9yKGUsdCxuPW51bGwpe3N1cGVyKCksdGhpcy5sZWFybmluZ1JhdGU9ZSx0aGlzLnJobz10LHRoaXMuZXBzaWxvbj1uLHRoaXMuYWNjdW11bGF0ZWRHcmFkcz1bXSx0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcz1bXSxuPT1udWxsJiYodGhpcy5lcHNpbG9uPVAuYmFja2VuZC5lcHNpbG9uKCkpfWFwcGx5R3JhZGllbnRzKGUpeyhBcnJheS5pc0FycmF5KGUpP2UubWFwKHQ9PnQubmFtZSk6T2JqZWN0LmtleXMoZSkpLmZvckVhY2goKHQsbik9PntsZXQgYT1QLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF0scj0hMTt0aGlzLmFjY3VtdWxhdGVkR3JhZHNbbl09PW51bGwmJih0aGlzLmFjY3VtdWxhdGVkR3JhZHNbbl09e29yaWdpbmFsTmFtZTpgJHt0fS9hY2N1bV9ncmFkYCx2YXJpYWJsZTpPKCgpPT5xZShhKS52YXJpYWJsZShyKSl9KSx0aGlzLmFjY3VtdWxhdGVkVXBkYXRlc1tuXT09bnVsbCYmKHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzW25dPXtvcmlnaW5hbE5hbWU6YCR7dH0vYWNjdW1fdmFyYCx2YXJpYWJsZTpPKCgpPT5xZShhKS52YXJpYWJsZShyKSl9KTtsZXQgcz1BcnJheS5pc0FycmF5KGUpP2Vbbl0udGVuc29yOmVbdF07aWYocz09bnVsbClyZXR1cm47bGV0IGk9dGhpcy5hY2N1bXVsYXRlZEdyYWRzW25dLnZhcmlhYmxlLG89dGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXNbbl0udmFyaWFibGU7TygoKT0+e2xldCBsPVgoeihpLHRoaXMucmhvKSx6KHB0KHMpLDEtdGhpcy5yaG8pKSx1PXooaGUocm4oWChvLHRoaXMuZXBzaWxvbikpLHJuKFgoaSx0aGlzLmVwc2lsb24pKSkscykscD1YKHoobyx0aGlzLnJobykseihwdCh1KSwxLXRoaXMucmhvKSk7aS5hc3NpZ24obCksby5hc3NpZ24ocCk7bGV0IGQ9WCh6KHUsLXRoaXMubGVhcm5pbmdSYXRlKSxhKTthLmFzc2lnbihkKX0pfSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9ZGlzcG9zZSgpe3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzIT1udWxsJiYoRWUodGhpcy5hY2N1bXVsYXRlZEdyYWRzLm1hcChlPT5lLnZhcmlhYmxlKSksRWUodGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMubWFwKGU9PmUudmFyaWFibGUpKSl9YXN5bmMgZ2V0V2VpZ2h0cygpe2xldCBlPVsuLi50aGlzLmFjY3VtdWxhdGVkR3JhZHMsLi4udGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXNdO3JldHVyblthd2FpdCB0aGlzLnNhdmVJdGVyYXRpb25zKCldLmNvbmNhdChlLm1hcCh0PT4oe25hbWU6dC5vcmlnaW5hbE5hbWUsdGVuc29yOnQudmFyaWFibGV9KSkpfWFzeW5jIHNldFdlaWdodHMoZSl7ZT1hd2FpdCB0aGlzLmV4dHJhY3RJdGVyYXRpb25zKGUpO2xldCB0PWUubGVuZ3RoLzIsbj0hMTt0aGlzLmFjY3VtdWxhdGVkR3JhZHM9ZS5zbGljZSgwLHQpLm1hcChhPT4oe29yaWdpbmFsTmFtZTphLm5hbWUsdmFyaWFibGU6YS50ZW5zb3IudmFyaWFibGUobil9KSksdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXM9ZS5zbGljZSh0LHQqMikubWFwKGE9Pih7b3JpZ2luYWxOYW1lOmEubmFtZSx2YXJpYWJsZTphLnRlbnNvci52YXJpYWJsZShuKX0pKX1nZXRDb25maWcoKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLHJobzp0aGlzLnJobyxlcHNpbG9uOnRoaXMuZXBzaWxvbn19c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUsdC5yaG8sdC5lcHNpbG9uKX19LFV3PWNsYXNzIGV4dGVuZHMgUnJ7c3RhdGljIGdldCBjbGFzc05hbWUoKXtyZXR1cm5cIkFkYWdyYWRcIn1jb25zdHJ1Y3RvcihlLHQ9LjEpe3N1cGVyKCksdGhpcy5sZWFybmluZ1JhdGU9ZSx0aGlzLmluaXRpYWxBY2N1bXVsYXRvclZhbHVlPXQsdGhpcy5hY2N1bXVsYXRlZEdyYWRzPVtdfWFwcGx5R3JhZGllbnRzKGUpeyhBcnJheS5pc0FycmF5KGUpP2UubWFwKHQ9PnQubmFtZSk6T2JqZWN0LmtleXMoZSkpLmZvckVhY2goKHQsbik9PntsZXQgYT1QLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF07dGhpcy5hY2N1bXVsYXRlZEdyYWRzW25dPT1udWxsJiYodGhpcy5hY2N1bXVsYXRlZEdyYWRzW25dPXtvcmlnaW5hbE5hbWU6YCR7dH0vYWNjdW11bGF0b3JgLHZhcmlhYmxlOk8oKCk9PnluKGEuc2hhcGUsdGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSkudmFyaWFibGUoITEpKX0pO2xldCByPUFycmF5LmlzQXJyYXkoZSk/ZVtuXS50ZW5zb3I6ZVt0XTtpZihyPT1udWxsKXJldHVybjtsZXQgcz10aGlzLmFjY3VtdWxhdGVkR3JhZHNbbl0udmFyaWFibGU7TygoKT0+e2xldCBpPVgocyxwdChyKSk7cy5hc3NpZ24oaSk7bGV0IG89WCh6KGhlKHIscm4oWChpLFAuYmFja2VuZC5lcHNpbG9uKCkpKSksLXRoaXMubGVhcm5pbmdSYXRlKSxhKTthLmFzc2lnbihvKX0pfSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9ZGlzcG9zZSgpe3RoaXMuYWNjdW11bGF0ZWRHcmFkcyE9bnVsbCYmRWUodGhpcy5hY2N1bXVsYXRlZEdyYWRzLm1hcChlPT5lLnZhcmlhYmxlKSl9YXN5bmMgZ2V0V2VpZ2h0cygpe3JldHVyblthd2FpdCB0aGlzLnNhdmVJdGVyYXRpb25zKCldLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkR3JhZHMubWFwKGU9Pih7bmFtZTplLm9yaWdpbmFsTmFtZSx0ZW5zb3I6ZS52YXJpYWJsZX0pKSl9YXN5bmMgc2V0V2VpZ2h0cyhlKXtlPWF3YWl0IHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnMoZSk7bGV0IHQ9ITE7dGhpcy5hY2N1bXVsYXRlZEdyYWRzPWUubWFwKG49Pih7b3JpZ2luYWxOYW1lOm4ubmFtZSx2YXJpYWJsZTpuLnRlbnNvci52YXJpYWJsZSh0KX0pKX1nZXRDb25maWcoKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGluaXRpYWxBY2N1bXVsYXRvclZhbHVlOnRoaXMuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWV9fXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpfX0sR3c9Y2xhc3MgZXh0ZW5kcyBScntzdGF0aWMgZ2V0IGNsYXNzTmFtZSgpe3JldHVyblwiQWRhbVwifWNvbnN0cnVjdG9yKGUsdCxuLGE9bnVsbCl7c3VwZXIoKSx0aGlzLmxlYXJuaW5nUmF0ZT1lLHRoaXMuYmV0YTE9dCx0aGlzLmJldGEyPW4sdGhpcy5lcHNpbG9uPWEsdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PVtdLHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQ9W10sTygoKT0+e3RoaXMuYWNjQmV0YTE9eGUodCkudmFyaWFibGUoKSx0aGlzLmFjY0JldGEyPXhlKG4pLnZhcmlhYmxlKCl9KSxhPT1udWxsJiYodGhpcy5lcHNpbG9uPVAuYmFja2VuZC5lcHNpbG9uKCkpfWFwcGx5R3JhZGllbnRzKGUpe2xldCB0PUFycmF5LmlzQXJyYXkoZSk/ZS5tYXAobj0+bi5uYW1lKTpPYmplY3Qua2V5cyhlKTtPKCgpPT57bGV0IG49cGUoMSx0aGlzLmFjY0JldGExKSxhPXBlKDEsdGhpcy5hY2NCZXRhMik7dC5mb3JFYWNoKChyLHMpPT57bGV0IGk9UC5yZWdpc3RlcmVkVmFyaWFibGVzW3JdLG89ITE7dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3NdPT1udWxsJiYodGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3NdPXtvcmlnaW5hbE5hbWU6YCR7cn0vbWAsdmFyaWFibGU6TygoKT0+cWUoaSkudmFyaWFibGUobykpfSksdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtzXT09bnVsbCYmKHRoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbc109e29yaWdpbmFsTmFtZTpgJHtyfS92YCx2YXJpYWJsZTpPKCgpPT5xZShpKS52YXJpYWJsZShvKSl9KTtsZXQgbD1BcnJheS5pc0FycmF5KGUpP2Vbc10udGVuc29yOmVbcl07aWYobD09bnVsbClyZXR1cm47bGV0IHU9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3NdLnZhcmlhYmxlLHA9dGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtzXS52YXJpYWJsZSxkPVgoeih1LHRoaXMuYmV0YTEpLHoobCwxLXRoaXMuYmV0YTEpKSxjPVgoeihwLHRoaXMuYmV0YTIpLHoocHQobCksMS10aGlzLmJldGEyKSksaD1oZShkLG4pLG09aGUoYyxhKTt1LmFzc2lnbihkKSxwLmFzc2lnbihjKTtsZXQgZj1YKHooaGUoaCxYKHJuKG0pLHRoaXMuZXBzaWxvbikpLC10aGlzLmxlYXJuaW5nUmF0ZSksaSk7aS5hc3NpZ24oZil9KSx0aGlzLmFjY0JldGExLmFzc2lnbih6KHRoaXMuYWNjQmV0YTEsdGhpcy5iZXRhMSkpLHRoaXMuYWNjQmV0YTIuYXNzaWduKHoodGhpcy5hY2NCZXRhMix0aGlzLmJldGEyKSl9KSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX1kaXNwb3NlKCl7dGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5hY2NCZXRhMi5kaXNwb3NlKCksdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50IT1udWxsJiZFZSh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQubWFwKGU9PmUudmFyaWFibGUpKSx0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50IT1udWxsJiZFZSh0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50Lm1hcChlPT5lLnZhcmlhYmxlKSl9YXN5bmMgZ2V0V2VpZ2h0cygpe2xldCBlPVsuLi50aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQsLi4udGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudF07cmV0dXJuW2F3YWl0IHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV0uY29uY2F0KGUubWFwKHQ9Pih7bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX0pKSl9YXN5bmMgc2V0V2VpZ2h0cyhlKXtlPWF3YWl0IHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnMoZSksTygoKT0+e3RoaXMuYWNjQmV0YTEuYXNzaWduKHVyKHRoaXMuYmV0YTEsdGhpcy5pdGVyYXRpb25zXysxKSksdGhpcy5hY2NCZXRhMi5hc3NpZ24odXIodGhpcy5iZXRhMix0aGlzLml0ZXJhdGlvbnNfKzEpKX0pO2xldCB0PWUubGVuZ3RoLzIsbj0hMTt0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9ZS5zbGljZSgwLHQpLm1hcChhPT4oe29yaWdpbmFsTmFtZTphLm5hbWUsdmFyaWFibGU6YS50ZW5zb3IudmFyaWFibGUobil9KSksdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudD1lLnNsaWNlKHQsdCoyKS5tYXAoYT0+KHtvcmlnaW5hbE5hbWU6YS5uYW1lLHZhcmlhYmxlOmEudGVuc29yLnZhcmlhYmxlKG4pfSkpfWdldENvbmZpZygpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsYmV0YTE6dGhpcy5iZXRhMSxiZXRhMjp0aGlzLmJldGEyLGVwc2lsb246dGhpcy5lcHNpbG9ufX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQpe3JldHVybiBuZXcgZSh0LmxlYXJuaW5nUmF0ZSx0LmJldGExLHQuYmV0YTIsdC5lcHNpbG9uKX19LEh3PWNsYXNzIGV4dGVuZHMgUnJ7c3RhdGljIGdldCBjbGFzc05hbWUoKXtyZXR1cm5cIkFkYW1heFwifWNvbnN0cnVjdG9yKGUsdCxuLGE9bnVsbCxyPTApe3N1cGVyKCksdGhpcy5sZWFybmluZ1JhdGU9ZSx0aGlzLmJldGExPXQsdGhpcy5iZXRhMj1uLHRoaXMuZXBzaWxvbj1hLHRoaXMuZGVjYXk9cix0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQ9W10sdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybT1bXSxPKCgpPT57dGhpcy5pdGVyYXRpb249eGUoMCkudmFyaWFibGUoKSx0aGlzLmFjY0JldGExPXhlKHQpLnZhcmlhYmxlKCl9KSxhPT1udWxsJiYodGhpcy5lcHNpbG9uPVAuYmFja2VuZC5lcHNpbG9uKCkpfWFwcGx5R3JhZGllbnRzKGUpe2xldCB0PUFycmF5LmlzQXJyYXkoZSk/ZS5tYXAobj0+bi5uYW1lKTpPYmplY3Qua2V5cyhlKTtPKCgpPT57bGV0IG49cGUoMSx0aGlzLmFjY0JldGExKSxhPWhlKC10aGlzLmxlYXJuaW5nUmF0ZSxYKHoodGhpcy5pdGVyYXRpb24sdGhpcy5kZWNheSksMSkpO3QuZm9yRWFjaCgocixzKT0+e2xldCBpPVAucmVnaXN0ZXJlZFZhcmlhYmxlc1tyXSxvPSExO3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtzXT09bnVsbCYmKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFtzXT17b3JpZ2luYWxOYW1lOmAke3J9L21gLHZhcmlhYmxlOnFlKGkpLnZhcmlhYmxlKG8pfSksdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtzXT09bnVsbCYmKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bc109e29yaWdpbmFsTmFtZTpgJHtyfS92YCx2YXJpYWJsZTpxZShpKS52YXJpYWJsZShvKX0pO2xldCBsPUFycmF5LmlzQXJyYXkoZSk/ZVtzXS50ZW5zb3I6ZVtyXTtpZihsPT1udWxsKXJldHVybjtsZXQgdT10aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbc10udmFyaWFibGUscD10aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtW3NdLnZhcmlhYmxlLGQ9WCh6KHUsdGhpcy5iZXRhMSkseihsLDEtdGhpcy5iZXRhMSkpLGM9eihwLHRoaXMuYmV0YTIpLGg9THQobCksbT1ocihjLGgpO3UuYXNzaWduKGQpLHAuYXNzaWduKG0pO2xldCBmPVgoeihoZShhLG4pLGhlKGQsWChtLHRoaXMuZXBzaWxvbikpKSxpKTtpLmFzc2lnbihmKX0pLHRoaXMuaXRlcmF0aW9uLmFzc2lnbihYKHRoaXMuaXRlcmF0aW9uLDEpKSx0aGlzLmFjY0JldGExLmFzc2lnbih6KHRoaXMuYWNjQmV0YTEsdGhpcy5iZXRhMSkpfSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9ZGlzcG9zZSgpe3RoaXMuYWNjQmV0YTEuZGlzcG9zZSgpLHRoaXMuaXRlcmF0aW9uLmRpc3Bvc2UoKSx0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQhPW51bGwmJkVlKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudC5tYXAoZT0+ZS52YXJpYWJsZSkpLHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0hPW51bGwmJkVlKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0ubWFwKGU9PmUudmFyaWFibGUpKX1hc3luYyBnZXRXZWlnaHRzKCl7dGhyb3cgbmV3IEVycm9yKFwiZ2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQWRhbWF4IHlldC5cIil9YXN5bmMgc2V0V2VpZ2h0cyhlKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciBBZGFtYXggeWV0LlwiKX1nZXRDb25maWcoKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbixkZWNheTp0aGlzLmRlY2F5fX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQpe3JldHVybiBuZXcgZSh0LmxlYXJuaW5nUmF0ZSx0LmJldGExLHQuYmV0YTIsdC5lcHNpbG9uLHQuZGVjYXkpfX0sZmY9Y2xhc3MgZXh0ZW5kcyBScntzdGF0aWMgZ2V0IGNsYXNzTmFtZSgpe3JldHVyblwiU0dEXCJ9Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmxlYXJuaW5nUmF0ZT1lLHRoaXMuc2V0TGVhcm5pbmdSYXRlKGUpfWFwcGx5R3JhZGllbnRzKGUpeyhBcnJheS5pc0FycmF5KGUpP2UubWFwKHQ9PnQubmFtZSk6T2JqZWN0LmtleXMoZSkpLmZvckVhY2goKHQsbik9PntsZXQgYT1BcnJheS5pc0FycmF5KGUpP2Vbbl0udGVuc29yOmVbdF07aWYoYT09bnVsbClyZXR1cm47bGV0IHI9UC5yZWdpc3RlcmVkVmFyaWFibGVzW3RdO08oKCk9PntsZXQgcz1YKHoodGhpcy5jLGEpLHIpO3IuYXNzaWduKHMpfSl9KSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX1zZXRMZWFybmluZ1JhdGUoZSl7dGhpcy5sZWFybmluZ1JhdGU9ZSx0aGlzLmMhPW51bGwmJnRoaXMuYy5kaXNwb3NlKCksdGhpcy5jPUh0KHhlKC1lKSl9ZGlzcG9zZSgpe3RoaXMuYy5kaXNwb3NlKCl9YXN5bmMgZ2V0V2VpZ2h0cygpe3JldHVyblthd2FpdCB0aGlzLnNhdmVJdGVyYXRpb25zKCldfWFzeW5jIHNldFdlaWdodHMoZSl7aWYoZT1hd2FpdCB0aGlzLmV4dHJhY3RJdGVyYXRpb25zKGUpLGUubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJTR0Qgb3B0aW1pemVyIGRvZXMgbm90IGhhdmUgc2V0dGFibGUgd2VpZ2h0cy5cIil9Z2V0Q29uZmlnKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZX19c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUpfX0sanc9Y2xhc3MgZXh0ZW5kcyBmZntzdGF0aWMgZ2V0IGNsYXNzTmFtZSgpe3JldHVyblwiTW9tZW50dW1cIn1jb25zdHJ1Y3RvcihlLHQsbj0hMSl7c3VwZXIoZSksdGhpcy5sZWFybmluZ1JhdGU9ZSx0aGlzLm1vbWVudHVtPXQsdGhpcy51c2VOZXN0ZXJvdj1uLHRoaXMuYWNjdW11bGF0aW9ucz1bXSx0aGlzLm09eGUodGhpcy5tb21lbnR1bSl9YXBwbHlHcmFkaWVudHMoZSl7KEFycmF5LmlzQXJyYXkoZSk/ZS5tYXAodD0+dC5uYW1lKTpPYmplY3Qua2V5cyhlKSkuZm9yRWFjaCgodCxuKT0+e2xldCBhPVAucmVnaXN0ZXJlZFZhcmlhYmxlc1t0XTt0aGlzLmFjY3VtdWxhdGlvbnNbbl09PW51bGwmJih0aGlzLmFjY3VtdWxhdGlvbnNbbl09e29yaWdpbmFsTmFtZTpgJHt0fS9tb21lbnR1bWAsdmFyaWFibGU6TygoKT0+cWUoYSkudmFyaWFibGUoITEpKX0pO2xldCByPXRoaXMuYWNjdW11bGF0aW9uc1tuXS52YXJpYWJsZSxzPUFycmF5LmlzQXJyYXkoZSk/ZVtuXS50ZW5zb3I6ZVt0XTtzIT1udWxsJiZPKCgpPT57bGV0IGksbz1YKHoodGhpcy5tLHIpLHMpO3RoaXMudXNlTmVzdGVyb3Y/aT1YKHoodGhpcy5jLFgocyx6KG8sdGhpcy5tKSkpLGEpOmk9WCh6KHRoaXMuYyxvKSxhKSxyLmFzc2lnbihvKSxhLmFzc2lnbihpKX0pfSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9ZGlzcG9zZSgpe3RoaXMubS5kaXNwb3NlKCksdGhpcy5hY2N1bXVsYXRpb25zIT1udWxsJiZFZSh0aGlzLmFjY3VtdWxhdGlvbnMubWFwKGU9PmUudmFyaWFibGUpKX1zZXRNb21lbnR1bShlKXt0aGlzLm1vbWVudHVtPWV9YXN5bmMgZ2V0V2VpZ2h0cygpe3JldHVyblthd2FpdCB0aGlzLnNhdmVJdGVyYXRpb25zKCldLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGlvbnMubWFwKGU9Pih7bmFtZTplLm9yaWdpbmFsTmFtZSx0ZW5zb3I6ZS52YXJpYWJsZX0pKSl9YXN5bmMgc2V0V2VpZ2h0cyhlKXtlPWF3YWl0IHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnMoZSk7bGV0IHQ9ITE7dGhpcy5hY2N1bXVsYXRpb25zPWUubWFwKG49Pih7b3JpZ2luYWxOYW1lOm4ubmFtZSx2YXJpYWJsZTpuLnRlbnNvci52YXJpYWJsZSh0KX0pKX1nZXRDb25maWcoKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLG1vbWVudHVtOnRoaXMubW9tZW50dW0sdXNlTmVzdGVyb3Y6dGhpcy51c2VOZXN0ZXJvdn19c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodC5sZWFybmluZ1JhdGUsdC5tb21lbnR1bSx0LnVzZU5lc3Rlcm92KX19LHF3PWNsYXNzIGV4dGVuZHMgUnJ7c3RhdGljIGdldCBjbGFzc05hbWUoKXtyZXR1cm5cIlJNU1Byb3BcIn1jb25zdHJ1Y3RvcihlLHQ9Ljksbj0wLGE9bnVsbCxyPSExKXtpZihzdXBlcigpLHRoaXMubGVhcm5pbmdSYXRlPWUsdGhpcy5kZWNheT10LHRoaXMubW9tZW50dW09bix0aGlzLmVwc2lsb249YSx0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9W10sdGhpcy5hY2N1bXVsYXRlZE1vbWVudHM9W10sdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcz1bXSx0aGlzLmNlbnRlcmVkPXIsYT09bnVsbCYmKHRoaXMuZXBzaWxvbj1QLmJhY2tlbmQuZXBzaWxvbigpKSxlPT1udWxsKXRocm93IG5ldyBFcnJvcihcImxlYXJuaW5nUmF0ZSBmb3IgUk1TUHJvcE9wdGltaXplciBtdXN0IGJlIGRlZmluZWQuXCIpfWFwcGx5R3JhZGllbnRzKGUpeyhBcnJheS5pc0FycmF5KGUpP2UubWFwKHQ9PnQubmFtZSk6T2JqZWN0LmtleXMoZSkpLmZvckVhY2goKHQsbik9PntsZXQgYT1QLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF0scj0hMTt0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl09PW51bGwmJih0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbbl09e29yaWdpbmFsTmFtZTpgJHt0fS9ybXNgLHZhcmlhYmxlOk8oKCk9PnFlKGEpLnZhcmlhYmxlKHIpKX0pLHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzW25dPT1udWxsJiYodGhpcy5hY2N1bXVsYXRlZE1vbWVudHNbbl09e29yaWdpbmFsTmFtZTpgJHt0fS9tb21lbnR1bWAsdmFyaWFibGU6TygoKT0+cWUoYSkudmFyaWFibGUocikpfSksdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkc1tuXT09bnVsbCYmdGhpcy5jZW50ZXJlZCYmKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbl09e29yaWdpbmFsTmFtZTpgJHt0fS9tZ2AsdmFyaWFibGU6TygoKT0+cWUoYSkudmFyaWFibGUocikpfSk7bGV0IHM9QXJyYXkuaXNBcnJheShlKT9lW25dLnRlbnNvcjplW3RdO2lmKHM9PW51bGwpcmV0dXJuO2xldCBpPXRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tuXS52YXJpYWJsZSxvPXRoaXMuYWNjdW11bGF0ZWRNb21lbnRzW25dLnZhcmlhYmxlO08oKCk9PntsZXQgbD1YKHooaSx0aGlzLmRlY2F5KSx6KHB0KHMpLDEtdGhpcy5kZWNheSkpO2lmKHRoaXMuY2VudGVyZWQpe2xldCB1PXRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHNbbl0udmFyaWFibGUscD1YKHoodSx0aGlzLmRlY2F5KSx6KHMsMS10aGlzLmRlY2F5KSksZD1oZSh6KHMsdGhpcy5sZWFybmluZ1JhdGUpLHJuKHBlKGwsWChwdChwKSx0aGlzLmVwc2lsb24pKSkpLGM9WCh6KG8sdGhpcy5tb21lbnR1bSksZCk7aS5hc3NpZ24obCksdS5hc3NpZ24ocCksby5hc3NpZ24oYyk7bGV0IGg9cGUoYSxjKTthLmFzc2lnbihoKX1lbHNle2xldCB1PVgoeihpLHRoaXMuZGVjYXkpLHoocHQocyksMS10aGlzLmRlY2F5KSkscD1YKHoobyx0aGlzLm1vbWVudHVtKSxoZSh6KHMsdGhpcy5sZWFybmluZ1JhdGUpLHJuKFgodSx0aGlzLmVwc2lsb24pKSkpO2kuYXNzaWduKHUpLG8uYXNzaWduKHApO2xldCBkPXBlKGEscCk7YS5hc3NpZ24oZCl9fSl9KSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX1kaXNwb3NlKCl7dGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzIT1udWxsJiZFZSh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMubWFwKGU9PmUudmFyaWFibGUpKSx0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzIT1udWxsJiZ0aGlzLmNlbnRlcmVkJiZFZSh0aGlzLmFjY3VtdWxhdGVkTWVhbkdyYWRzLm1hcChlPT5lLnZhcmlhYmxlKSksdGhpcy5hY2N1bXVsYXRlZE1vbWVudHMhPW51bGwmJkVlKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzLm1hcChlPT5lLnZhcmlhYmxlKSl9YXN5bmMgZ2V0V2VpZ2h0cygpe2xldCBlPVsuLi50aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMsLi4udGhpcy5hY2N1bXVsYXRlZE1vbWVudHNdO3JldHVybiB0aGlzLmNlbnRlcmVkJiZlLnB1c2goLi4udGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyksW2F3YWl0IHRoaXMuc2F2ZUl0ZXJhdGlvbnMoKV0uY29uY2F0KGUubWFwKHQ9Pih7bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX0pKSl9YXN5bmMgc2V0V2VpZ2h0cyhlKXtlPWF3YWl0IHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnMoZSk7bGV0IHQ9dGhpcy5jZW50ZXJlZD9lLmxlbmd0aC8zOmUubGVuZ3RoLzIsbj0hMTt0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9ZS5zbGljZSgwLHQpLm1hcChhPT4oe29yaWdpbmFsTmFtZTphLm5hbWUsdmFyaWFibGU6YS50ZW5zb3IudmFyaWFibGUobil9KSksdGhpcy5hY2N1bXVsYXRlZE1vbWVudHM9ZS5zbGljZSh0LHQqMikubWFwKGE9Pih7b3JpZ2luYWxOYW1lOmEubmFtZSx2YXJpYWJsZTphLnRlbnNvci52YXJpYWJsZShuKX0pKSx0aGlzLmNlbnRlcmVkJiYodGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcz1lLnNsaWNlKHQqMix0KjMpLm1hcChhPT4oe29yaWdpbmFsTmFtZTphLm5hbWUsdmFyaWFibGU6YS50ZW5zb3IudmFyaWFibGUobil9KSkpfWdldENvbmZpZygpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsZGVjYXk6dGhpcy5kZWNheSxtb21lbnR1bTp0aGlzLm1vbWVudHVtLGVwc2lsb246dGhpcy5lcHNpbG9uLGNlbnRlcmVkOnRoaXMuY2VudGVyZWR9fXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHQubGVhcm5pbmdSYXRlLHQuZGVjYXksdC5tb21lbnR1bSx0LmVwc2lsb24sdC5jZW50ZXJlZCl9fSxOQj1bVncsVXcsR3csSHcsancscXcsZmZdO2Z1bmN0aW9uIFRCKCl7Zm9yKGxldCBlIG9mIE5CKU9UKGUpfXZhciBqdD17fTtfZShqdCx7Q29tcG9zaXRlQXJyYXlCdWZmZXI6KCk9PkZyLGJyb3dzZXJGaWxlczooKT0+REIsYnJvd3NlckhUVFBSZXF1ZXN0OigpPT56Qixjb25jYXRlbmF0ZUFycmF5QnVmZmVyczooKT0+aE8sY29weU1vZGVsOigpPT5NTyxkZWNvZGVXZWlnaHRzOigpPT5sTixkZWNvZGVXZWlnaHRzU3RyZWFtOigpPT5wTixlbmNvZGVXZWlnaHRzOigpPT5vTyxmcm9tTWVtb3J5OigpPT5CQixmcm9tTWVtb3J5U3luYzooKT0+QlQsZ2V0TG9hZEhhbmRsZXJzOigpPT53TyxnZXRNb2RlbEFydGlmYWN0c0ZvckpTT046KCk9Pk12LGdldE1vZGVsQXJ0aWZhY3RzRm9ySlNPTlN5bmM6KCk9PmROLGdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT046KCk9PnJkLGdldFNhdmVIYW5kbGVyczooKT0+dk8sZ2V0V2VpZ2h0U3BlY3M6KCk9Pl94LGh0dHA6KCk9Plh3LGlzSFRUUFNjaGVtZTooKT0+UHgsbGlzdE1vZGVsczooKT0+RE8sbG9hZFdlaWdodHM6KCk9Pk1CLG1vdmVNb2RlbDooKT0+T08scmVnaXN0ZXJMb2FkUm91dGVyOigpPT54TyxyZWdpc3RlclNhdmVSb3V0ZXI6KCk9PnlPLHJlbW92ZU1vZGVsOigpPT5STyx3ZWlnaHRzTG9hZGVyRmFjdG9yeTooKT0+TFQsd2l0aFNhdmVIYW5kbGVyOigpPT5WQix3aXRoU2F2ZUhhbmRsZXJTeW5jOigpPT5VQn0pO3ZhciBDQj1cIm1vZGVsXCIsRUI9XCIuanNvblwiLF9CPVwiLndlaWdodHMuYmluXCI7ZnVuY3Rpb24gYUkoZSl7cmV0dXJuIG5ldyBQcm9taXNlKHQ9PnNldFRpbWVvdXQodCkpLnRoZW4oZSl9dmFyIFloPWNsYXNzIE94e2NvbnN0cnVjdG9yKHQpe2lmKCFHKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlckRvd25sb2FkcygpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgYnJvd3Nlci5cIik7dC5zdGFydHNXaXRoKE94LlVSTF9TQ0hFTUUpJiYodD10LnNsaWNlKE94LlVSTF9TQ0hFTUUubGVuZ3RoKSksKHQ9PW51bGx8fHQubGVuZ3RoPT09MCkmJih0PUNCKSx0aGlzLm1vZGVsSnNvbkZpbGVOYW1lPXQrRUIsdGhpcy53ZWlnaHREYXRhRmlsZU5hbWU9dCtfQn1hc3luYyBzYXZlKHQpe2lmKHR5cGVvZiBkb2N1bWVudD09XCJ1bmRlZmluZWRcIil0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIGRvd25sb2FkcyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHNpbmNlIGBkb2N1bWVudGAgaXMgbm90IHByZXNlbnRcIik7bGV0IG49RnIuam9pbih0LndlaWdodERhdGEpLGE9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW25dLHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSk7aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckRvd25sb2Fkcy5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTt7bGV0IHI9W3twYXRoczpbXCIuL1wiK3RoaXMud2VpZ2h0RGF0YUZpbGVOYW1lXSx3ZWlnaHRzOnQud2VpZ2h0U3BlY3N9XSxzPWNOKHQsciksaT13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocyldLHt0eXBlOlwiYXBwbGljYXRpb24vanNvblwifSkpLG89dGhpcy5tb2RlbEpzb25BbmNob3I9PW51bGw/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik6dGhpcy5tb2RlbEpzb25BbmNob3I7aWYoby5kb3dubG9hZD10aGlzLm1vZGVsSnNvbkZpbGVOYW1lLG8uaHJlZj1pLGF3YWl0IGFJKCgpPT5vLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSkpLHQud2VpZ2h0RGF0YSE9bnVsbCl7bGV0IGw9dGhpcy53ZWlnaHREYXRhQW5jaG9yPT1udWxsP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMud2VpZ2h0RGF0YUFuY2hvcjtsLmRvd25sb2FkPXRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lLGwuaHJlZj1hLGF3YWl0IGFJKCgpPT5sLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSkpfXJldHVybnttb2RlbEFydGlmYWN0c0luZm86cmQodCl9fX19O1loLlVSTF9TQ0hFTUU9XCJkb3dubG9hZHM6Ly9cIjt2YXIgQUI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7aWYoZT09bnVsbHx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoYFdoZW4gY2FsbGluZyBicm93c2VyRmlsZXMsIGF0IGxlYXN0IDEgZmlsZSBpcyByZXF1aXJlZCwgYnV0IHJlY2VpdmVkICR7ZX1gKTt0aGlzLmpzb25GaWxlPWVbMF0sdGhpcy53ZWlnaHRzRmlsZXM9ZS5zbGljZSgxKX1hc3luYyBsb2FkKCl7cmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57bGV0IG49bmV3IEZpbGVSZWFkZXI7bi5vbmxvYWQ9YT0+e2xldCByPUpTT04ucGFyc2UoYS50YXJnZXQucmVzdWx0KSxzPXIubW9kZWxUb3BvbG9neTtpZihzPT1udWxsKXt0KG5ldyBFcnJvcihgbW9kZWxUb3BvbG9neSBmaWVsZCBpcyBtaXNzaW5nIGZyb20gZmlsZSAke3RoaXMuanNvbkZpbGUubmFtZX1gKSk7cmV0dXJufWlmKHIud2VpZ2h0c01hbmlmZXN0PT1udWxsKXt0KG5ldyBFcnJvcihgd2VpZ2h0TWFuaWZlc3QgZmllbGQgaXMgbWlzc2luZyBmcm9tIGZpbGUgJHt0aGlzLmpzb25GaWxlLm5hbWV9YCkpO3JldHVybn1pZih0aGlzLndlaWdodHNGaWxlcy5sZW5ndGg9PT0wKXtlKHttb2RlbFRvcG9sb2d5OnN9KTtyZXR1cm59bGV0IGk9TXYocixvPT50aGlzLmxvYWRXZWlnaHRzKG8pKTtlKGkpfSxuLm9uZXJyb3I9YT0+dChgRmFpbGVkIHRvIHJlYWQgbW9kZWwgdG9wb2xvZ3kgYW5kIHdlaWdodHMgbWFuaWZlc3QgSlNPTiBmcm9tIGZpbGUgJyR7dGhpcy5qc29uRmlsZS5uYW1lfScuIEJyb3dzZXJGaWxlcyBzdXBwb3J0cyBsb2FkaW5nIEtlcmFzLXN0eWxlIHRmLk1vZGVsIGFydGlmYWN0cyBvbmx5LmApLG4ucmVhZEFzVGV4dCh0aGlzLmpzb25GaWxlKX0pfWxvYWRXZWlnaHRzKGUpe2xldCB0PVtdLG49W107Zm9yKGxldCBzIG9mIGUpdC5wdXNoKC4uLnMud2VpZ2h0cyksbi5wdXNoKC4uLnMucGF0aHMpO2xldCBhPXRoaXMuY2hlY2tNYW5pZmVzdEFuZFdlaWdodEZpbGVzKGUpLHI9bi5tYXAocz0+dGhpcy5sb2FkV2VpZ2h0c0ZpbGUocyxhW3NdKSk7cmV0dXJuIFByb21pc2UuYWxsKHIpLnRoZW4ocz0+W3Qsc10pfWxvYWRXZWlnaHRzRmlsZShlLHQpe3JldHVybiBuZXcgUHJvbWlzZSgobixhKT0+e2xldCByPW5ldyBGaWxlUmVhZGVyO3Iub25sb2FkPXM9PntsZXQgaT1zLnRhcmdldC5yZXN1bHQ7bihpKX0sci5vbmVycm9yPXM9PmEoYEZhaWxlZCB0byB3ZWlnaHRzIGRhdGEgZnJvbSBmaWxlIG9mIHBhdGggJyR7ZX0nLmApLHIucmVhZEFzQXJyYXlCdWZmZXIodCl9KX1jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXMoZSl7bGV0IHQ9W10sbj10aGlzLndlaWdodHNGaWxlcy5tYXAocj0+ZUkoci5uYW1lKSksYT17fTtmb3IobGV0IHIgb2YgZSlyLnBhdGhzLmZvckVhY2gocz0+e2xldCBpPWVJKHMpO2lmKHQuaW5kZXhPZihpKSE9PS0xKXRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZpbGUgYmFzZW5hbWUgZm91bmQgaW4gd2VpZ2h0cyBtYW5pZmVzdDogJyR7aX0nYCk7aWYodC5wdXNoKGkpLG4uaW5kZXhPZihpKT09PS0xKXRocm93IG5ldyBFcnJvcihgV2VpZ2h0IGZpbGUgd2l0aCBiYXNlbmFtZSAnJHtpfScgaXMgbm90IHByb3ZpZGVkLmApO2Fbc109dGhpcy53ZWlnaHRzRmlsZXNbbi5pbmRleE9mKGkpXX0pO2lmKHQubGVuZ3RoIT09dGhpcy53ZWlnaHRzRmlsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBmaWxlcyBpbiB3ZWlnaHRzIG1hbmlmZXN0ICgke3QubGVuZ3RofSkgYW5kIHRoZSBudW1iZXIgb2Ygd2VpZ2h0IGZpbGVzIHByb3ZpZGVkICgke3RoaXMud2VpZ2h0c0ZpbGVzLmxlbmd0aH0pLmApO3JldHVybiBhfX0sRkI9ZT0+RygpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpJiYhQXJyYXkuaXNBcnJheShlKSYmZS5zdGFydHNXaXRoKFloLlVSTF9TQ0hFTUUpPyRCKGUuc2xpY2UoWWguVVJMX1NDSEVNRS5sZW5ndGgpKTpudWxsO2dhLnJlZ2lzdGVyU2F2ZVJvdXRlcihGQik7ZnVuY3Rpb24gJEIoZT1cIm1vZGVsXCIpe3JldHVybiBuZXcgWWgoZSl9ZnVuY3Rpb24gREIoZSl7cmV0dXJuIG5ldyBBQihlKX1mdW5jdGlvbiBySShlLHQsbixhKXtpKGUpLG49bj09bnVsbD8wOm4sYT1hPT1udWxsPzE6YSxvKG4sYSk7bGV0IHI9MCxzPWw9PihsLnRoZW4odT0+e2xldCBwPW4rICsrci9lLmxlbmd0aCooYS1uKTtyZXR1cm4gdChwKSx1fSksbCk7ZnVuY3Rpb24gaShsKXtBKGwhPW51bGwmJkFycmF5LmlzQXJyYXkobCkmJmwubGVuZ3RoPjAsKCk9PlwicHJvbWlzZXMgbXVzdCBiZSBhIG5vbmUgZW1wdHkgYXJyYXlcIil9ZnVuY3Rpb24gbyhsLHUpe0EobD49MCYmbDw9MSwoKT0+YFByb2dyZXNzIGZyYWN0aW9uIG11c3QgYmUgaW4gcmFuZ2UgWzAsIDFdLCBidXQgZ290IHN0YXJ0RnJhY3Rpb24gJHtsfWApLEEodT49MCYmdTw9MSwoKT0+YFByb2dyZXNzIGZyYWN0aW9uIG11c3QgYmUgaW4gcmFuZ2UgWzAsIDFdLCBidXQgZ290IGVuZEZyYWN0aW9uICR7dX1gKSxBKHU+PWwsKCk9PmBzdGFydEZyYWN0aW9uIG11c3QgYmUgbm8gbW9yZSB0aGFuIGVuZEZyYWN0aW9uLCBidXQgZ290IHN0YXJ0RnJhY3Rpb24gJHtsfSBhbmQgZW5kRnJhY3Rpb24gJHt1fWApfXJldHVybiBQcm9taXNlLmFsbChlLm1hcChzKSl9YXN5bmMgZnVuY3Rpb24gUFQoZSx0KXt0PT1udWxsJiYodD17fSk7bGV0IG49dC5mZXRjaEZ1bmM9PW51bGw/RygpLnBsYXRmb3JtLmZldGNoOnQuZmV0Y2hGdW5jLGE9ZS5tYXAocz0+bihzLHQucmVxdWVzdEluaXQse2lzQmluYXJ5OiEwfSkpLHI9KHQub25Qcm9ncmVzcz09bnVsbD9hd2FpdCBQcm9taXNlLmFsbChhKTphd2FpdCBySShhLHQub25Qcm9ncmVzcywwLC41KSkubWFwKHM9PnMuYXJyYXlCdWZmZXIoKSk7cmV0dXJuIHQub25Qcm9ncmVzcz09bnVsbD9hd2FpdCBQcm9taXNlLmFsbChyKTphd2FpdCBySShyLHQub25Qcm9ncmVzcywuNSwxKX1mdW5jdGlvbiBSQihlLHQpe3ZhciBuO2xldCBhPXQuZmV0Y2hGdW5jPT1udWxsP0coKS5wbGF0Zm9ybS5mZXRjaDp0LmZldGNoRnVuYyxyPTAscztyZXR1cm4obj10Lm9uUHJvZ3Jlc3MpPT09bnVsbHx8bj09PXZvaWQgMHx8bi5jYWxsKHQsMCksbmV3IFJlYWRhYmxlU3RyZWFtKHtwdWxsOmFzeW5jIGk9Pntmb3IodmFyIG87cjxlLmxlbmd0aDspe3N8fChzPShhd2FpdCBhKGVbcl0sdC5yZXF1ZXN0SW5pdCx7aXNCaW5hcnk6ITB9KSkuYm9keS5nZXRSZWFkZXIoKSk7bGV0e2RvbmU6bCx2YWx1ZTp1fT1hd2FpdCBzLnJlYWQoKTtpZihsKXtyKysscz12b2lkIDAsKG89dC5vblByb2dyZXNzKT09PW51bGx8fG89PT12b2lkIDB8fG8uY2FsbCh0LHIvZS5sZW5ndGgpO2NvbnRpbnVlfWkuZW5xdWV1ZSh1KTtyZXR1cm59aS5jbG9zZSgpfX0pfWFzeW5jIGZ1bmN0aW9uIE1CKGUsdD1cIlwiLG4sYSl7cmV0dXJuIExUKHI9PlBUKHIse3JlcXVlc3RJbml0OmF9KSkoZSx0LG4pfWZ1bmN0aW9uIExUKGUpe3JldHVybiBhc3luYyh0LG49XCJcIixhKT0+e2xldCByPXQubWFwKCgpPT4hMSkscz17fSxpPWEhPW51bGw/YS5tYXAoKCk9PiExKTpbXSxvPVtdO2lmKHQuZm9yRWFjaCgoaCxtKT0+e2xldCBmPTA7aC53ZWlnaHRzLmZvckVhY2goZz0+e2xldCBiPVwicXVhbnRpemF0aW9uXCJpbiBnP2cucXVhbnRpemF0aW9uLmR0eXBlOmcuZHR5cGUseT11aVtiXSpvdChnLnNoYXBlKSx4PSgpPT57clttXT0hMCxzW21dPT1udWxsJiYoc1ttXT1bXSksc1ttXS5wdXNoKHttYW5pZmVzdEVudHJ5OmcsZ3JvdXBPZmZzZXQ6ZixzaXplQnl0ZXM6eX0pfTthIT1udWxsP2EuZm9yRWFjaCgodixJKT0+e3Y9PT1nLm5hbWUmJih4KCksaVtJXT0hMCl9KTp4KCksby5wdXNoKGcubmFtZSksZis9eX0pfSksIWkuZXZlcnkoaD0+aCkpe2xldCBoPWEuZmlsdGVyKChtLGYpPT4haVtmXSk7dGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCB3ZWlnaHRzIGluIG1hbmlmZXN0IHdpdGggbmFtZXM6ICR7aC5qb2luKFwiLCBcIil9LiBcbk1hbmlmZXN0IEpTT04gaGFzIHdlaWdodHMgd2l0aCBuYW1lczogJHtvLmpvaW4oXCIsIFwiKX0uYCl9bGV0IGw9ci5yZWR1Y2UoKGgsbSxmKT0+KG0mJmgucHVzaChmKSxoKSxbXSksdT1bXTtsLmZvckVhY2goaD0+e3RbaF0ucGF0aHMuZm9yRWFjaChtPT57bGV0IGY9bisobi5lbmRzV2l0aChcIi9cIik/XCJcIjpcIi9cIikrbTt1LnB1c2goZil9KX0pO2xldCBwPWF3YWl0IGUodSksZD17fSxjPTA7cmV0dXJuIGwuZm9yRWFjaChoPT57bGV0IG09dFtoXS5wYXRocy5sZW5ndGgsZj1uZXcgRnIocC5zbGljZShjLGMrbSkpO3NbaF0uZm9yRWFjaChnPT57bGV0IGI9Zi5zbGljZShnLmdyb3VwT2Zmc2V0LGcuZ3JvdXBPZmZzZXQrZy5zaXplQnl0ZXMpLHk9bE4oYixbZy5tYW5pZmVzdEVudHJ5XSk7Zm9yKGxldCB4IGluIHkpZFt4XT15W3hdfSksYys9bX0pLGR9fXZhciBPQj1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFBCPVwiYXBwbGljYXRpb24vanNvblwiLEt3PWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7aWYodGhpcy5ERUZBVUxUX01FVEhPRD1cIlBPU1RcIix0PT1udWxsJiYodD17fSksdGhpcy53ZWlnaHRQYXRoUHJlZml4PXQud2VpZ2h0UGF0aFByZWZpeCx0aGlzLndlaWdodFVybENvbnZlcnRlcj10LndlaWdodFVybENvbnZlcnRlcix0LmZldGNoRnVuYyE9bnVsbD8oQSh0eXBlb2YgdC5mZXRjaEZ1bmM9PVwiZnVuY3Rpb25cIiwoKT0+XCJNdXN0IHBhc3MgYSBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHNpZ25hdHVyZSBvZiBgZmV0Y2hgIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSSlcIiksdGhpcy5mZXRjaD10LmZldGNoRnVuYyk6dGhpcy5mZXRjaD1HKCkucGxhdGZvcm0uZmV0Y2gsQShlIT1udWxsJiZlLmxlbmd0aD4wLCgpPT5cIlVSTCBwYXRoIGZvciBodHRwIG11c3Qgbm90IGJlIG51bGwsIHVuZGVmaW5lZCBvciBlbXB0eS5cIiksQXJyYXkuaXNBcnJheShlKSYmQShlLmxlbmd0aD09PTIsKCk9PmBVUkwgcGF0aHMgZm9yIGh0dHAgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDIsIChhY3R1YWwgbGVuZ3RoIGlzICR7ZS5sZW5ndGh9KS5gKSx0aGlzLnBhdGg9ZSx0LnJlcXVlc3RJbml0IT1udWxsJiZ0LnJlcXVlc3RJbml0LmJvZHkhPW51bGwpdGhyb3cgbmV3IEVycm9yKFwicmVxdWVzdEluaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBubyBwcmUtZXhpc3RpbmcgYm9keSwgYnV0IGhhcyBvbmUuXCIpO3RoaXMucmVxdWVzdEluaXQ9dC5yZXF1ZXN0SW5pdHx8e30sdGhpcy5sb2FkT3B0aW9ucz10fWFzeW5jIHNhdmUoZSl7aWYoZS5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO2xldCB0PU9iamVjdC5hc3NpZ24oe21ldGhvZDp0aGlzLkRFRkFVTFRfTUVUSE9EfSx0aGlzLnJlcXVlc3RJbml0KTt0LmJvZHk9bmV3IEZvcm1EYXRhO2xldCBuPVt7cGF0aHM6W1wiLi9tb2RlbC53ZWlnaHRzLmJpblwiXSx3ZWlnaHRzOmUud2VpZ2h0U3BlY3N9XSxhPWNOKGUsbik7aWYodC5ib2R5LmFwcGVuZChcIm1vZGVsLmpzb25cIixuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoYSldLHt0eXBlOlBCfSksXCJtb2RlbC5qc29uXCIpLGUud2VpZ2h0RGF0YSE9bnVsbCl7bGV0IHM9RnIuam9pbihlLndlaWdodERhdGEpO3QuYm9keS5hcHBlbmQoXCJtb2RlbC53ZWlnaHRzLmJpblwiLG5ldyBCbG9iKFtzXSx7dHlwZTpPQn0pLFwibW9kZWwud2VpZ2h0cy5iaW5cIil9bGV0IHI9YXdhaXQgdGhpcy5mZXRjaCh0aGlzLnBhdGgsdCk7aWYoci5vaylyZXR1cm57bW9kZWxBcnRpZmFjdHNJbmZvOnJkKGUpLHJlc3BvbnNlczpbcl19O3Rocm93IG5ldyBFcnJvcihgQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2Ugc3RhdHVzICR7ci5zdGF0dXN9LmApfWFzeW5jIGxvYWRNb2RlbEpTT04oKXtsZXQgZT1hd2FpdCB0aGlzLmZldGNoKHRoaXMucGF0aCx0aGlzLnJlcXVlc3RJbml0KTtpZighZS5vayl0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3QgdG8gJHt0aGlzLnBhdGh9IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZS5zdGF0dXN9LiBQbGVhc2UgdmVyaWZ5IHRoaXMgVVJMIHBvaW50cyB0byB0aGUgbW9kZWwgSlNPTiBvZiB0aGUgbW9kZWwgdG8gbG9hZC5gKTtsZXQgdDt0cnl7dD1hd2FpdCBlLmpzb24oKX1jYXRjaChyKXtsZXQgcz1gRmFpbGVkIHRvIHBhcnNlIG1vZGVsIEpTT04gb2YgcmVzcG9uc2UgZnJvbSAke3RoaXMucGF0aH0uYDt0aHJvdyB0aGlzLnBhdGguZW5kc1dpdGgoXCIucGJcIik/cys9XCIgWW91ciBwYXRoIGNvbnRhaW5zIGEgLnBiIGZpbGUgZXh0ZW5zaW9uLiBTdXBwb3J0IGZvciAucGIgbW9kZWxzIGhhdmUgYmVlbiByZW1vdmVkIGluIFRlbnNvckZsb3cuanMgMS4wIGluIGZhdm9yIG9mIC5qc29uIG1vZGVscy4gWW91IGNhbiByZS1jb252ZXJ0IHlvdXIgUHl0aG9uIFRlbnNvckZsb3cgbW9kZWwgdXNpbmcgdGhlIFRlbnNvckZsb3cuanMgMS4wIGNvbnZlcnNpb24gc2NyaXB0cyBvciB5b3UgY2FuIGNvbnZlcnQgeW91ci5wYiBtb2RlbHMgd2l0aCB0aGUgJ3BiMmpzb24nTlBNIHNjcmlwdCBpbiB0aGUgdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlciByZXBvc2l0b3J5LlwiOnMrPVwiIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHNlcnZlciBpcyBzZXJ2aW5nIHZhbGlkIEpTT04gZm9yIHRoaXMgcmVxdWVzdC5cIixuZXcgRXJyb3Iocyl9bGV0IG49dC5tb2RlbFRvcG9sb2d5LGE9dC53ZWlnaHRzTWFuaWZlc3Q7aWYobj09bnVsbCYmYT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYFRoZSBKU09OIGZyb20gSFRUUCBwYXRoICR7dGhpcy5wYXRofSBjb250YWlucyBuZWl0aGVyIG1vZGVsIHRvcG9sb2d5IG9yIG1hbmlmZXN0IGZvciB3ZWlnaHRzLmApO3JldHVybiB0fWFzeW5jIGxvYWQoKXtpZih0aGlzLmxvYWRPcHRpb25zLnN0cmVhbVdlaWdodHMpcmV0dXJuIHRoaXMubG9hZFN0cmVhbSgpO2xldCBlPWF3YWl0IHRoaXMubG9hZE1vZGVsSlNPTigpO3JldHVybiBNdihlLHQ9PnRoaXMubG9hZFdlaWdodHModCkpfWFzeW5jIGxvYWRTdHJlYW0oKXtsZXQgZT1hd2FpdCB0aGlzLmxvYWRNb2RlbEpTT04oKSx0PWF3YWl0IHRoaXMuZ2V0V2VpZ2h0VXJscyhlLndlaWdodHNNYW5pZmVzdCksbj1feChlLndlaWdodHNNYW5pZmVzdCksYT0oKT0+UkIodCx0aGlzLmxvYWRPcHRpb25zKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHt3ZWlnaHRTcGVjczpuLGdldFdlaWdodFN0cmVhbTphfSl9YXN5bmMgZ2V0V2VpZ2h0VXJscyhlKXtsZXQgdD1BcnJheS5pc0FycmF5KHRoaXMucGF0aCk/dGhpcy5wYXRoWzFdOnRoaXMucGF0aCxbbixhXT1MQih0KSxyPXRoaXMud2VpZ2h0UGF0aFByZWZpeHx8bixzPVtdLGk9W107Zm9yKGxldCBvIG9mIGUpZm9yKGxldCBsIG9mIG8ucGF0aHMpdGhpcy53ZWlnaHRVcmxDb252ZXJ0ZXIhPW51bGw/aS5wdXNoKHRoaXMud2VpZ2h0VXJsQ29udmVydGVyKGwpKTpzLnB1c2gocitsK2EpO3JldHVybiB0aGlzLndlaWdodFVybENvbnZlcnRlciYmcy5wdXNoKC4uLmF3YWl0IFByb21pc2UuYWxsKGkpKSxzfWFzeW5jIGxvYWRXZWlnaHRzKGUpe2xldCB0PWF3YWl0IHRoaXMuZ2V0V2VpZ2h0VXJscyhlKSxuPV94KGUpLGE9YXdhaXQgUFQodCx0aGlzLmxvYWRPcHRpb25zKTtyZXR1cm5bbixhXX19O0t3LlVSTF9TQ0hFTUVfUkVHRVg9L15odHRwcz86XFwvXFwvLztmdW5jdGlvbiBMQihlKXtsZXQgdD1lLmxhc3RJbmRleE9mKFwiL1wiKSxuPWUubGFzdEluZGV4T2YoXCI/XCIpLGE9ZS5zdWJzdHJpbmcoMCx0KSxyPW4+dD9lLnN1YnN0cmluZyhuKTpcIlwiO3JldHVyblthK1wiL1wiLHJdfWZ1bmN0aW9uIFB4KGUpe3JldHVybiBlLm1hdGNoKEt3LlVSTF9TQ0hFTUVfUkVHRVgpIT1udWxsfXZhciB6VD0oZSx0KT0+e2lmKHR5cGVvZiBmZXRjaD09XCJ1bmRlZmluZWRcIiYmKHQ9PW51bGx8fHQuZmV0Y2hGdW5jPT1udWxsKSlyZXR1cm4gbnVsbDt7bGV0IG49ITA7aWYoQXJyYXkuaXNBcnJheShlKT9uPWUuZXZlcnkoYT0+UHgoYSkpOm49UHgoZSksbilyZXR1cm4gWHcoZSx0KX1yZXR1cm4gbnVsbH07Z2EucmVnaXN0ZXJTYXZlUm91dGVyKHpUKTtnYS5yZWdpc3RlckxvYWRSb3V0ZXIoelQpO2Z1bmN0aW9uIFh3KGUsdCl7cmV0dXJuIG5ldyBLdyhlLHQpfWZ1bmN0aW9uIHpCKGUsdCl7cmV0dXJuIFh3KGUsdCl9dmFyIGx4PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMubW9kZWxBcnRpZmFjdHM9ZX1sb2FkKCl7cmV0dXJuIHRoaXMubW9kZWxBcnRpZmFjdHN9fSxXVD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnNhdmVIYW5kbGVyPWV9c2F2ZShlKXtyZXR1cm4gdGhpcy5zYXZlSGFuZGxlcihlKX19LFdCPWNsYXNze2NvbnN0cnVjdG9yKGUpe2UubG9hZCYmKHRoaXMubG9hZD0oKT0+UHJvbWlzZS5yZXNvbHZlKGUubG9hZCgpKSksZS5zYXZlJiYodGhpcy5zYXZlPXQ9PlByb21pc2UucmVzb2x2ZShlLnNhdmUodCkpKX19O2Z1bmN0aW9uIEJCKGUsdCxuLGEpe2xldCByPWFyZ3VtZW50cztyZXR1cm4gbmV3IFdCKEJUKC4uLnIpKX1mdW5jdGlvbiBCVChlLHQsbixhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD09PTE/ZS5tb2RlbFRvcG9sb2d5IT1udWxsfHxlLndlaWdodFNwZWNzIT1udWxsP25ldyBseChlKTooY29uc29sZS53YXJuKFwiUGxlYXNlIGNhbGwgdGYuaW8uZnJvbU1lbW9yeSgpIHdpdGggb25seSBvbmUgYXJndW1lbnQuIFRoZSBhcmd1bWVudCBzaG91bGQgYmUgb2YgdHlwZSBNb2RlbEFydGlmYWN0cy4gVGhlIG11bHRpLWFyZ3VtZW50IHNpZ25hdHVyZSBvZiB0Zi5pby5mcm9tTWVtb3J5KCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXCIpLG5ldyBseCh7bW9kZWxUb3BvbG9neTplfSkpOihjb25zb2xlLndhcm4oXCJQbGVhc2UgY2FsbCB0Zi5pby5mcm9tTWVtb3J5KCkgd2l0aCBvbmx5IG9uZSBhcmd1bWVudC4gVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBvZiB0eXBlIE1vZGVsQXJ0aWZhY3RzLiBUaGUgbXVsdGktYXJndW1lbnQgc2lnbmF0dXJlIG9mIHRmLmlvLmZyb21NZW1vcnkoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIiksbmV3IGx4KHttb2RlbFRvcG9sb2d5OmUsd2VpZ2h0U3BlY3M6dCx3ZWlnaHREYXRhOm4sdHJhaW5pbmdDb25maWc6YX0pKX1mdW5jdGlvbiBWQihlKXtyZXR1cm4gbmV3IFdUKGUpfWZ1bmN0aW9uIFVCKGUpe3JldHVybiBuZXcgV1QoZSl9dmFyIFZUPXt9O19lKFZULHtjb25mdXNpb25NYXRyaXg6KCk9PkhCfSk7ZnVuY3Rpb24gR0IoZSx0LG4pe2xldCBhPUUoZSxcImxhYmVsc1wiLFwiY29uZnVzaW9uTWF0cml4XCIpLHI9RSh0LFwicHJlZGljdGlvbnNcIixcImNvbmZ1c2lvbk1hdHJpeFwiKTtBKG49PW51bGx8fG4+MCYmTnVtYmVyLmlzSW50ZWdlcihuKSwoKT0+YElmIHByb3ZpZGVkLCBudW1DbGFzc2VzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290ICR7bn1gKSxBKGEucmFuaz09PTEsKCk9PmBFeHBlY3RlZCB0aGUgcmFuayBvZiBsYWJlbHMgdG8gYmUgMSwgYnV0IGdvdCAke2EucmFua31gKSxBKHIucmFuaz09PTEsKCk9PmBFeHBlY3RlZCB0aGUgcmFuayBvZiBwcmVkaWN0aW9ucyB0byBiZSAxLCBidXQgZ290ICR7ci5yYW5rfWApLEEoYS5zaGFwZVswXT09PXIuc2hhcGVbMF0sKCk9PmBNaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGV4YW1wbGVzOiAke2Euc2hhcGVbMF19IHZzLiAke3Iuc2hhcGVbMF19LiBMYWJlbHMgYW5kIHByZWRpY3Rpb25zIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5gKSxBKG4+MCYmTnVtYmVyLmlzSW50ZWdlcihuKSwoKT0+YG51bUNsYXNzZXMgaXMgcmVxdWlyZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290ICR7bn1gKTtsZXQgcz1MbChyZShhLFwiaW50MzJcIiksbiksaT1MbChyZShyLFwiaW50MzJcIiksbiksbz1EZShzKSxsPSRlKG8saSk7cmV0dXJuIHJlKGwsXCJpbnQzMlwiKX12YXIgSEI9TCh7Y29uZnVzaW9uTWF0cml4XzpHQn0pLHFvPXt9O19lKHFvLHtkcmF3OigpPT5RQixmcm9tUGl4ZWxzOigpPT5lNCxmcm9tUGl4ZWxzQXN5bmM6KCk9PllCLHRvUGl4ZWxzOigpPT5KQn0pO3ZhciBqcyxzST0hMTtmdW5jdGlvbiBVVChlLHQ9Myl7aWYodD40KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgVGVuc29yIHdpdGggbW9yZSB0aGFuIDQgY2hhbm5lbHMgZnJvbSBwaXhlbHMuXCIpO2lmKGU9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBjYW4gbm90IGJlIG51bGxcIik7bGV0IG49ITEsYT0hMSxyPSExLHM9ITEsaT0hMSxvPSExO2lmKGUuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpbj0hMDtlbHNlIGlmKHR5cGVvZiBJbWFnZURhdGEhPVwidW5kZWZpbmVkXCImJmUgaW5zdGFuY2VvZiBJbWFnZURhdGEpYT0hMDtlbHNlIGlmKHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50IT1cInVuZGVmaW5lZFwiJiZlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudClyPSEwO2Vsc2UgaWYodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQhPVwidW5kZWZpbmVkXCImJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KXM9ITA7ZWxzZSBpZihlLmdldENvbnRleHQhPW51bGwpaT0hMDtlbHNlIGlmKHR5cGVvZiBJbWFnZUJpdG1hcCE9XCJ1bmRlZmluZWRcIiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKW89ITA7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYHBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgbXVzdCBiZSBlaXRoZXIgYW4gSFRNTFZpZGVvRWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQsIEltYWdlRGF0YSBpbiBicm93c2VyLCBvciBPZmZzY3JlZW5DYW52YXMsIEltYWdlRGF0YSBpbiB3ZWJ3b3JrZXIgb3Ige2RhdGE6IFVpbnQzMkFycmF5LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIGJ1dCB3YXMgJHtlLmNvbnN0cnVjdG9yLm5hbWV9YCk7aWYoZmMoSGgsUC5iYWNrZW5kTmFtZSkhPW51bGwpe2xldCBjPXtwaXhlbHM6ZX0saD17bnVtQ2hhbm5lbHM6dH07cmV0dXJuIFAucnVuS2VybmVsKEhoLGMsaCl9bGV0W2wsdV09cj9bZS52aWRlb1dpZHRoLGUudmlkZW9IZWlnaHRdOltlLndpZHRoLGUuaGVpZ2h0XSxwO2lmKGkpcD1lLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwwLGwsdSkuZGF0YTtlbHNlIGlmKGF8fG4pcD1lLmRhdGE7ZWxzZSBpZihzfHxyfHxvKXtpZihqcz09bnVsbClpZih0eXBlb2YgZG9jdW1lbnQ9PVwidW5kZWZpbmVkXCIpaWYodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCE9XCJ1bmRlZmluZWRcIilqcz1uZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSkuZ2V0Q29udGV4dChcIjJkXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIGlucHV0IGluIGN1cnJlbnQgY29udGV4dC4gUmVhc29uOiBPZmZzY3JlZW5DYW52YXMgQ29udGV4dDJEIHJlbmRlcmluZyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtlbHNlIGpzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIse3dpbGxSZWFkRnJlcXVlbnRseTohMH0pO2pzLmNhbnZhcy53aWR0aD1sLGpzLmNhbnZhcy5oZWlnaHQ9dSxqcy5kcmF3SW1hZ2UoZSwwLDAsbCx1KSxwPWpzLmdldEltYWdlRGF0YSgwLDAsbCx1KS5kYXRhfWxldCBkO2lmKHQ9PT00KWQ9bmV3IEludDMyQXJyYXkocCk7ZWxzZXtsZXQgYz1sKnU7ZD1uZXcgSW50MzJBcnJheShjKnQpO2ZvcihsZXQgaD0wO2g8YztoKyspZm9yKGxldCBtPTA7bTx0OysrbSlkW2gqdCttXT1wW2gqNCttXX1yZXR1cm4geGQoZCxbdSxsLHRdLFwiaW50MzJcIil9ZnVuY3Rpb24gakIoZSl7cmV0dXJuIGUhPW51bGwmJmUuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl9ZnVuY3Rpb24gcUIoKXtyZXR1cm4gdHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIEltYWdlQml0bWFwIT1cInVuZGVmaW5lZFwiJiZ3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJjcmVhdGVJbWFnZUJpdG1hcFwiKX1mdW5jdGlvbiBLQihlKXtyZXR1cm4gZSE9bnVsbCYmZS53aWR0aCE9PTAmJmUuaGVpZ2h0IT09MH1mdW5jdGlvbiBYQihlKXtyZXR1cm4gcUIoKSYmIShlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApJiZLQihlKSYmIWpCKGUpfWFzeW5jIGZ1bmN0aW9uIFlCKGUsdD0zKXtsZXQgbj1udWxsO2lmKEcoKS5nZXRCb29sKFwiV1JBUF9UT19JTUFHRUJJVE1BUFwiKSYmWEIoZSkpe2xldCBhO3RyeXthPWF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGUse3ByZW11bHRpcGx5QWxwaGE6XCJub25lXCJ9KX1jYXRjaChyKXthPW51bGx9YSE9bnVsbCYmYS53aWR0aD09PWUud2lkdGgmJmEuaGVpZ2h0PT09ZS5oZWlnaHQ/bj1hOm49ZX1lbHNlIG49ZTtyZXR1cm4gVVQobix0KX1mdW5jdGlvbiBHVChlKXtpZihlLnJhbmshPT0yJiZlLnJhbmshPT0zKXRocm93IG5ldyBFcnJvcihgdG9QaXhlbHMgb25seSBzdXBwb3J0cyByYW5rIDIgb3IgMyB0ZW5zb3JzLCBnb3QgcmFuayAke2UucmFua30uYCk7bGV0IHQ9ZS5yYW5rPT09Mj8xOmUuc2hhcGVbMl07aWYodD40fHx0PT09Mil0aHJvdyBuZXcgRXJyb3IoYHRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgZGVwdGggb2Ygc2l6ZSAxLCAzIG9yIDQgYnV0IGdvdCAke3R9YCk7aWYoZS5kdHlwZSE9PVwiZmxvYXQzMlwiJiZlLmR0eXBlIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdG9QaXhlbHM6ICR7ZS5kdHlwZX0uIFBsZWFzZSB1c2UgZmxvYXQzMiBvciBpbnQzMiB0ZW5zb3JzLmApfWZ1bmN0aW9uIFpCKGUpe2xldCB0PShlPT1udWxsP3ZvaWQgMDplLmFscGhhKXx8MTtpZih0PjF8fHQ8MCl0aHJvdyBuZXcgRXJyb3IoYEFscGhhIHZhbHVlICR7dH0gaXMgc3VwcG9lZCB0byBiZSBpbiByYW5nZSBbMCAtIDFdLmApfWFzeW5jIGZ1bmN0aW9uIEpCKGUsdCl7bGV0IG49RShlLFwiaW1nXCIsXCJ0b1BpeGVsc1wiKTtpZighKGUgaW5zdGFuY2VvZiBDZSkpe2xldCB1PW47bj1yZSh1LFwiaW50MzJcIiksdS5kaXNwb3NlKCl9R1Qobik7bGV0W2Escl09bi5zaGFwZS5zbGljZSgwLDIpLHM9bi5yYW5rPT09Mj8xOm4uc2hhcGVbMl0saT1hd2FpdCBuLmRhdGEoKSxvPW4uZHR5cGU9PT1cImZsb2F0MzJcIj8yNTU6MSxsPW5ldyBVaW50OENsYW1wZWRBcnJheShyKmEqNCk7Zm9yKGxldCB1PTA7dTxhKnI7Kyt1KXtsZXQgcD1bMCwwLDAsMjU1XTtmb3IobGV0IGM9MDtjPHM7YysrKXtsZXQgaD1pW3UqcytjXTtpZihuLmR0eXBlPT09XCJmbG9hdDMyXCIpe2lmKGg8MHx8aD4xKXRocm93IG5ldyBFcnJvcihgVGVuc29yIHZhbHVlcyBmb3IgYSBmbG9hdDMyIFRlbnNvciBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCAtIDFdIGJ1dCBlbmNvdW50ZXJlZCAke2h9LmApfWVsc2UgaWYobi5kdHlwZT09PVwiaW50MzJcIiYmKGg8MHx8aD4yNTUpKXRocm93IG5ldyBFcnJvcihgVGVuc29yIHZhbHVlcyBmb3IgYSBpbnQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAyNTVdIGJ1dCBlbmNvdW50ZXJlZCAke2h9LmApO3M9PT0xPyhwWzBdPWgqbyxwWzFdPWgqbyxwWzJdPWgqbyk6cFtjXT1oKm99bGV0IGQ9dSo0O2xbZCswXT1NYXRoLnJvdW5kKHBbMF0pLGxbZCsxXT1NYXRoLnJvdW5kKHBbMV0pLGxbZCsyXT1NYXRoLnJvdW5kKHBbMl0pLGxbZCszXT1NYXRoLnJvdW5kKHBbM10pfWlmKHQhPW51bGwpe3NJfHxmYyhObSxQLmJhY2tlbmROYW1lKSE9bnVsbCYmKGNvbnNvbGUud2FybihcInRmLmJyb3dzZXIudG9QaXhlbHMgaXMgbm90IGVmZmljaWVudCB0byBkcmF3IHRlbnNvciBvbiBjYW52YXMuIFBsZWFzZSB0cnkgdGYuYnJvd3Nlci5kcmF3IGluc3RlYWQuXCIpLHNJPSEwKSx0LndpZHRoPXIsdC5oZWlnaHQ9YTtsZXQgdT10LmdldENvbnRleHQoXCIyZFwiKSxwPW5ldyBJbWFnZURhdGEobCxyLGEpO3UucHV0SW1hZ2VEYXRhKHAsMCwwKX1yZXR1cm4gbiE9PWUmJm4uZGlzcG9zZSgpLGx9ZnVuY3Rpb24gUUIoZSx0LG4pe2xldCBhPUUoZSxcImltZ1wiLFwiZHJhd1wiKTtpZighKGUgaW5zdGFuY2VvZiBDZSkpe2xldCBpPWE7YT1yZShpLFwiaW50MzJcIiksaS5kaXNwb3NlKCl9R1QoYSksWkIobj09bnVsbD92b2lkIDA6bi5pbWFnZU9wdGlvbnMpO2xldCByPXtpbWFnZTphfSxzPXtjYW52YXM6dCxvcHRpb25zOm59O1AucnVuS2VybmVsKE5tLHIscyl9dmFyIGU0PUwoe2Zyb21QaXhlbHNfOlVUfSksWXc9e307X2UoWXcse3ByZXBhcmVBbmRWYWxpZGF0ZTooKT0+SFR9KTtmdW5jdGlvbiBIVChlLHQpe2xldCBuPWUuc2hhcGUubGVuZ3RoLGE9dC5zaGFwZS5sZW5ndGg7aWYobjwxKXRocm93IG5ldyBFcnJvcihgdGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbnB1dCB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzICR7bn0uYCk7aWYoYTwxKXRocm93IG5ldyBFcnJvcihgdGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgJHthfS5gKTtpZih0LmR0eXBlIT09XCJpbnQzMlwiKXRocm93IG5ldyBFcnJvcihgdGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsIGJ1dCB0aGUgZHR5cGUgd2FzICR7dC5kdHlwZX0uYCk7aWYodC5zaGFwZVthLTFdPm4pdGhyb3cgbmV3IEVycm9yKGBpbmRleCBpbm5lcm1vc3QgZGltZW5zaW9uIGxlbmd0aCBtdXN0IGJlIDw9IHRlbnNvciByYW5rOyBzYXc6ICR7dC5zaGFwZVthLTFdfSB2cy4gJHtufWApO2lmKG90KGUuc2hhcGUpPT09MCl0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3RlZCBtb3JlIHRoYW4gMCBlbnRyaWVzLCBidXQgaW5wdXQgaXMgZW1wdHkuIElucHV0IHNoYXBlOiAke2Uuc2hhcGV9LmApO2xldCByPXQuc2hhcGUscz1yW3IubGVuZ3RoLTFdLGk9MTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoLTE7KytkKWkqPXJbZF07bGV0IG89ZS5zaGFwZSxsPXIuc2xpY2UoKTtsLnBvcCgpO2xldCB1PTE7Zm9yKGxldCBkPXM7ZDxuOysrZCl1Kj1vW2RdLGwucHVzaChvW2RdKTtsZXQgcD1bLi4uWGwoZS5zaGFwZSkubWFwKGQ9PmQvdSksMV0uc2xpY2UoMCxzKTtyZXR1cm5bbCxpLHUscF19dmFyIEt0PXt9O19lKEt0LHthc3NlcnRQYXJhbXNWYWxpZDooKT0+bjQsY29tcHV0ZUZsYXRPZmZzZXQ6KCk9Pm80LGNvbXB1dGVPdXRTaGFwZTooKT0+cjQsZ2V0Tm9ybWFsaXplZEF4ZXM6KCk9PnM0LGlzU2xpY2VDb250aW5vdXM6KCk9Pmk0LG1hc2tUb0F4ZXM6KCk9PmE0LHBhcnNlU2xpY2VQYXJhbXM6KCk9PmUyLHNsaWNlSW5mbzooKT0+bDQsc3RhcnRGb3JBeGlzOigpPT5KVCxzdGFydEluZGljZXNXaXRoRWxpZGVkRGltczooKT0+WFQsc3RvcEZvckF4aXM6KCk9PlFULHN0b3BJbmRpY2VzV2l0aEVsaWRlZERpbXM6KCk9PllULHN0cmlkZXNGb3JBeGlzOigpPT5aVCxzdHJpZGVzV2l0aEVsaWRlZERpbXM6KCk9PmpUfSk7dmFyIEx4PS0yLHQ0PS0xO2Z1bmN0aW9uIG40KGUsdCxuKXtsZXQgYT1lLnNoYXBlLmxlbmd0aDtBKGE9PT10Lmxlbmd0aCwoKT0+YEVycm9yIGluIHNsaWNlJHthfUQ6IExlbmd0aCBvZiBiZWdpbiAke3R9IG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5ICgke2F9KS5gKSxBKGE9PT1uLmxlbmd0aCwoKT0+YEVycm9yIGluIHNsaWNlJHthfUQ6IExlbmd0aCBvZiBzaXplICR7bn0gbXVzdCBtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKCR7YX0pLmApO2ZvcihsZXQgcj0wO3I8YTsrK3IpQSh0W3JdK25bcl08PWUuc2hhcGVbcl0sKCk9PmBFcnJvciBpbiBzbGljZSR7YX1EOiBiZWdpblske3J9XSArIHNpemVbJHtyfV0gKCR7dFtyXStuW3JdfSkgd291bGQgb3ZlcmZsb3cgaW5wdXQuc2hhcGVbJHtyfV0gKCR7ZS5zaGFwZVtyXX0pYCl9ZnVuY3Rpb24gYTQoZSl7bGV0IHQ9W10sbj0wO2Zvcig7ZT4wOyllJjEmJnQucHVzaChuKSxlLz0yLG4rKztyZXR1cm4gdH1mdW5jdGlvbiByNChlLHQsbil7bGV0IGE9W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspYVtyXT1NYXRoLmNlaWwoKHRbcl0tZVtyXSkvbltyXSk7cmV0dXJuIGF9ZnVuY3Rpb24galQoZSx0LG4sYSl7bGV0IHI9Wy4uLmVdO2ZvcihsZXQgcz1yLmxlbmd0aDtzPGEubGVuZ3RoO3MrKylyLnB1c2goMSk7Zm9yKGxldCBzPTA7czxuO3MrKylzPT09MD9yW3RdPTE6KHIuc3BsaWNlKHQsMCwxKSxyLnBvcCgpKTtyZXR1cm4gcn1mdW5jdGlvbiBxVChlLHQsbil7cmV0dXJuIG48PWU/bjpuLSh0LTEpfWZ1bmN0aW9uIEtUKGUsdCl7bGV0IG49W107Zm9yKGxldCBhPTA7YTxlO2ErKyluLnB1c2godCthKTtyZXR1cm4gbn1mdW5jdGlvbiBzNChlLHQsbixhLHIscyxpLG8sbCl7bGV0IHU9ZS5sZW5ndGgscD1uZXcgQXJyYXkodSksZD1uZXcgQXJyYXkodSksYz1uZXcgQXJyYXkodSk7aWYodC5sZW5ndGgmJm4+MCl7bGV0IGg9dFswXSxtPW4rMTtwPVhUKGksaCxtLGEsZSksZD1ZVChvLGgsbSxyLGUpLGM9alQocyxoLG0sZSl9ZWxzZSBmb3IobGV0IGg9MDtoPHU7aCsrKXBbaF09SlQoaSxhLHMsZSxoLGwpLGRbaF09UVQobyxyLHMsZSxoLGwpLGNbaF09WlQocyxoLGwpO3JldHVybntiZWdpbjpwLGVuZDpkLHN0cmlkZXM6Y319ZnVuY3Rpb24gWFQoZSx0LG4sYSxyKXtsZXQgcz1bLi4ucl0saT1LVChuLHQpO2ZvcihsZXQgbz0wO288cy5sZW5ndGg7bysrKWlmKGkuaW5kZXhPZihvKT4tMSlzW29dPTA7ZWxzZXtsZXQgbD1xVCh0LG4sbyksdT1hW2xdO2UmMTw8bCYmKHU9MCksc1tvXT11fXJldHVybiBzfWZ1bmN0aW9uIFlUKGUsdCxuLGEscil7bGV0IHM9Wy4uLnJdLGk9S1Qobix0KTtmb3IobGV0IG89MDtvPHMubGVuZ3RoO28rKylpZihpLmluZGV4T2Yobyk+LTEpc1tvXT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtlbHNle2xldCBsPXFUKHQsbixvKSx1PWFbbF07ZSYxPDxsJiYodT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUiksc1tvXT11fWZvcihsZXQgbz0wO288cy5sZW5ndGg7bysrKXtsZXQgbD1yW29dO3Nbb108MCYmKHNbb10rPWwpLHNbb109aGMoMCxzW29dLHJbb10pfXJldHVybiBzfWZ1bmN0aW9uIFpUKGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybihuJjE8PHR8fGE9PW51bGwpJiYoYT0xKSxhfWZ1bmN0aW9uIEpUKGUsdCxuLGEscixzKXtsZXQgaT10W3JdLG89bltyXXx8MTsoZSYxPDxyfHxzJjE8PHJ8fGk9PW51bGwpJiYobz4wP2k9TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI6aT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7bGV0IGw9YVtyXTtyZXR1cm4gaTwwJiYoaSs9bCksaT1oYygwLGksbC0xKSxpfWZ1bmN0aW9uIFFUKGUsdCxuLGEscixzKXtsZXQgaT10W3JdLG89bltyXXx8MTsoZSYxPDxyfHxzJjE8PHJ8fGk9PW51bGwpJiYobz4wP2k9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI6aT1OdW1iZXIuTUlOX1NBRkVfSU5URUdFUik7bGV0IGw9YVtyXTtyZXR1cm4gaTwwJiYoaSs9bCksbz4wP2k9aGMoMCxpLGwpOmk9aGMoLTEsaSxsLTEpLGl9ZnVuY3Rpb24gaTQoZSx0LG4pe2xldCBhPW4ubGVuZ3RoO2ZvcihsZXQgcj0wO3I8bi5sZW5ndGg7cisrKWlmKG5bcl0+MSl7YT1yO2JyZWFrfWZvcihsZXQgcj1hKzE7cjxuLmxlbmd0aDtyKyspaWYodFtyXT4wfHxuW3JdIT09ZVtyXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBvNChlLHQpe2xldCBuPWUubGVuZ3RoPjA/ZVtlLmxlbmd0aC0xXToxO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGgtMTthKyspbis9ZVthXSp0W2FdO3JldHVybiBufWZ1bmN0aW9uIGUyKGUsdCxuKXtsZXQgYSxyPWUuc2hhcGUubGVuZ3RoO3R5cGVvZiB0PT1cIm51bWJlclwiP2E9W3QsLi4ubmV3IEFycmF5KHItMSkuZmlsbCgwKV06dC5sZW5ndGg8cj9hPXQuY29uY2F0KG5ldyBBcnJheShyLXQubGVuZ3RoKS5maWxsKDApKTphPXQuc2xpY2UoKSxhLmZvckVhY2goaT0+e0EoaSE9PS0xLCgpPT5cInNsaWNlKCkgZG9lcyBub3Qgc3VwcG9ydCBuZWdhdGl2ZSBiZWdpbiBpbmRleGluZy5cIil9KTtsZXQgcztyZXR1cm4gbj09bnVsbD9zPW5ldyBBcnJheShyKS5maWxsKC0xKTp0eXBlb2Ygbj09XCJudW1iZXJcIj9zPVtuLC4uLm5ldyBBcnJheShyLTEpLmZpbGwoLTEpXTpuLmxlbmd0aDxyP3M9bi5jb25jYXQobmV3IEFycmF5KHItbi5sZW5ndGgpLmZpbGwoLTEpKTpzPW4scz1zLm1hcCgoaSxvKT0+aT49MD9pOihBKGk9PT0tMSwoKT0+YE5lZ2F0aXZlIHNpemUgdmFsdWVzIHNob3VsZCBiZSBleGFjdGx5IC0xIGJ1dCBnb3QgJHtpfSBmb3IgdGhlIHNsaWNlKCkgc2l6ZSBhdCBpbmRleCAke299LmApLGUuc2hhcGVbb10tYVtvXSkpLFthLHNdfWZ1bmN0aW9uIGw0KGUsdCxuLGEscixzLGksbyxsKXtsZXQgdTtpZihhPT1udWxsPyh1PW5ldyBBcnJheSh0Lmxlbmd0aCksdS5maWxsKDEpKTp1PWEsaSE9bnVsbCYmaSZpLTEpdGhyb3cgbmV3IEVycm9yKFwiTXVsdGlwbGUgZWxsaXBzZXMgaW4gc2xpY2UgaXMgbm90IGFsbG93ZWQuXCIpO2xldCBwPSExLGQ9e2RpbXM6dS5sZW5ndGgsbnVtQWRkQXhpc0FmdGVyRWxsaXBzaXM6MCxiZWdpbjp0LnNsaWNlKCksZW5kOm4uc2xpY2UoKSxzdHJpZGVzOnUuc2xpY2UoKSxiZWdpbk1hc2s6cixlbmRNYXNrOnMsZWxsaXBzaXNNYXNrOmksbmV3QXhpc01hc2s6byxzaHJpbmtBeGlzTWFzazpsfTtmb3IobGV0IHk9MDt5PGQuZGltczt5KyspcCYmMTw8eSZvJiZkLm51bUFkZEF4aXNBZnRlckVsbGlwc2lzKyssMTw8eSZpJiYocD0hMCk7cHx8KGQuZWxsaXBzaXNNYXNrfD0xPDxkLmRpbXMsZC5kaW1zKyspO2xldCBjPXtkaW1zOmUubGVuZ3RoLGJlZ2luTWFzazowLGVuZE1hc2s6MCxiZWdpblZhbGlkOiExLGVuZFZhbGlkOiExfTt1NChkLGMpO2xldCBoPSEwLG09ITAsZj0hMCxnPVtdLGI9W107Zm9yKGxldCB5PTA7eTxlLmxlbmd0aDsrK3kpe2lmKGMuc3RyaWRlc1t5XT09PTApdGhyb3cgRXJyb3IoYHN0cmlkZXNbJHt5fV0gbXVzdCBiZSBub24temVyb2ApO2xldCB4PSEhKGMuc2hyaW5rQXhpc01hc2smMTw8eSksdj1lW3ldO2lmKHY9PT0tMSl7Zy5wdXNoKHg/MTotMSk7Y29udGludWV9bGV0IEk9W2MuYmVnaW5NYXNrJjE8PHksYy5lbmRNYXNrJjE8PHldLE49W2Muc3RyaWRlc1t5XT4wPzA6LTEsYy5zdHJpZGVzW3ldPjA/djp2LTFdO2lmKHgmJmMuc3RyaWRlc1t5XTw9MCl0aHJvdyBFcnJvcihcIm9ubHkgc3RyaWRlIDEgYWxsb3dlZCBvbiBub24tcmFuZ2UgaW5kZXhpbmcuXCIpO2Y9ZiYmYy5zdHJpZGVzW3ldPT09MTtsZXQgQz0hIShjLmJlZ2luTWFzayYxPDx5JiZjLmVuZE1hc2smMTw8eSk7aWYoYy5iZWdpblZhbGlkJiZjLmVuZFZhbGlkKXtpZih4KXtsZXQgJD1jLmJlZ2luW3ldPDA/ditjLmJlZ2luW3ldOmMuYmVnaW5beV07aWYoYy5iZWdpblt5XT0kLGMuZW5kW3ldPWMuYmVnaW5beV0rMSwkPDB8fCQ+PXYpdGhyb3cgRXJyb3IoYHNsaWNlIGluZGV4ICR7Yy5iZWdpblt5XX0gb2YgZGltZW5zaW9uICR7eX0gb3V0IG9mIGJvdW5kcy5gKX1lbHNlIGMuYmVnaW5beV09aUkoYy5iZWdpblt5XSwwLGMuc3RyaWRlc1t5XSx2LEksTiksYy5lbmRbeV09aUkoYy5lbmRbeV0sMSxjLnN0cmlkZXNbeV0sdixJLE4pO2xldCBEPWMuc3RyaWRlc1t5XT09PTEmJmMuYmVnaW5beV09PT0wJiZjLmVuZFt5XT09PXY7aD1oJiZELG09bSYmKHk9PT0wJiZjLnN0cmlkZXNbeV09PT0xfHxEKX1lbHNlIGg9aCYmYy5zdHJpZGVzW3ldPT09MSYmQyxtPW0mJih5PT09MCYmYy5zdHJpZGVzW3ldPT09MXx8Qyk7bGV0IF8sRj0hMTtpZihjLmJlZ2luVmFsaWQmJmMuZW5kVmFsaWQ/KF89Yy5lbmRbeV0tYy5iZWdpblt5XSxGPSEwKTp4PyhfPTEsRj0hMCk6QyYmdj49MCYmKGMuc3RyaWRlc1t5XTwwP189LXY6Xz12LEY9ITApLEYpe2xldCBEO189PT0wfHxfPDAhPWMuc3RyaWRlc1t5XTwwP0Q9MDpEPU1hdGgudHJ1bmMoXy9jLnN0cmlkZXNbeV0pKyhfJWMuc3RyaWRlc1t5XSE9PTA/MTowKSxnLnB1c2goRCl9ZWxzZSBnLnB1c2goLTEpfWZvcihsZXQgeT0wO3k8Yy5maW5hbFNoYXBlR2F0aGVySW5kaWNlcy5sZW5ndGg7Kyt5KXtsZXQgeD1jLmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzW3ldO3g+PTA/Yi5wdXNoKGdbeF0pOng9PT1MeCYmYi5wdXNoKDEpfXJldHVybntmaW5hbFNoYXBlU3BhcnNlOmIuZmlsdGVyKCh5LHgpPT5jLmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzW3hdIT09THgpLGZpbmFsU2hhcGU6Yixpc0lkZW50aXR5Omgsc2xpY2VEaW0wOm0saXNTaW1wbGVTbGljZTpmLGJlZ2luOmMuYmVnaW4sZW5kOmMuZW5kLHN0cmlkZXM6Yy5zdHJpZGVzfX1mdW5jdGlvbiB1NChlLHQpe3QuYmVnaW5NYXNrPTAsdC5lbmRNYXNrPTAsdC5zaHJpbmtBeGlzTWFzaz0wO2xldCBuPTA7dC5iZWdpblZhbGlkPWUuYmVnaW4hPW51bGwsdC5lbmRWYWxpZD1lLmVuZCE9bnVsbCx0LmJlZ2luPW5ldyBBcnJheSh0LmRpbXMpLHQuZW5kPW5ldyBBcnJheSh0LmRpbXMpLHQuc3RyaWRlcz1uZXcgQXJyYXkodC5kaW1zKSx0LmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzPVtdLHQuZmluYWxTaGFwZUdhdGhlckluZGljZXNTcGFyc2U9W10sdC5pbnB1dFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZT1uZXcgQXJyYXkodC5kaW1zKTtmb3IobGV0IGE9MDthPGUuZGltczthKyspaWYoMTw8YSZlLmVsbGlwc2lzTWFzayl7bGV0IHI9TWF0aC5taW4odC5kaW1zLShlLmRpbXMtYSkrMStlLm51bUFkZEF4aXNBZnRlckVsbGlwc2lzLHQuZGltcyk7Zm9yKDtuPHI7bisrKXQuYmVnaW5bbl09MCx0LmVuZFtuXT0wLHQuc3RyaWRlc1tuXT0xLHQuYmVnaW5NYXNrfD0xPDxuLHQuZW5kTWFza3w9MTw8bix0LmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzLnB1c2gobiksdC5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZS5wdXNoKC0xKSx0LmlucHV0U2hhcGVHYXRoZXJJbmRpY2VzU3BhcnNlW25dPWF9ZWxzZSBpZigxPDxhJmUubmV3QXhpc01hc2spdC5maW5hbFNoYXBlR2F0aGVySW5kaWNlcy5wdXNoKEx4KSx0LmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzU3BhcnNlLnB1c2goLTEpO2Vsc2V7aWYobj09PXQuYmVnaW4ubGVuZ3RoKXRocm93IEVycm9yKGBJbmRleCBvdXQgb2YgcmFuZ2UgdXNpbmcgaW5wdXQgZGltICR7bn07IGlucHV0IGhhcyBvbmx5ICR7dC5kaW1zfSBkaW1zLCAke3QuYmVnaW4ubGVuZ3RofS5gKTtlLmJlZ2luIT1udWxsJiYodC5iZWdpbltuXT1lLmJlZ2luW2FdKSxlLmVuZCE9bnVsbCYmKHQuZW5kW25dPWUuZW5kW2FdKSx0LnN0cmlkZXNbbl09ZS5zdHJpZGVzW2FdLGUuYmVnaW5NYXNrJjE8PGEmJih0LmJlZ2luTWFza3w9MTw8biksZS5lbmRNYXNrJjE8PGEmJih0LmVuZE1hc2t8PTE8PG4pLGUuc2hyaW5rQXhpc01hc2smMTw8YT8odC5maW5hbFNoYXBlR2F0aGVySW5kaWNlcy5wdXNoKHQ0KSx0LmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzU3BhcnNlLnB1c2goLTEpLHQuc2hyaW5rQXhpc01hc2t8PTE8PG4pOih0LmZpbmFsU2hhcGVHYXRoZXJJbmRpY2VzLnB1c2gobiksdC5maW5hbFNoYXBlR2F0aGVySW5kaWNlc1NwYXJzZS5wdXNoKGEpKSx0LmlucHV0U2hhcGVHYXRoZXJJbmRpY2VzU3BhcnNlW25dPWEsbisrfX1mdW5jdGlvbiBpSShlLHQsbixhLHIscyl7aWYoclt0XSlyZXR1cm4gbj4wP3NbdF06c1t0KzEmMV07e2xldCBpPWU8MD9hK2U6ZTtyZXR1cm4gaTxzWzBdP3NbMF06aT5zWzFdP3NbMV06aX19dmFyIHA0PVwiNC4yMi4wXCIsdDI9Y2xhc3N7c3RhdGljIHNnZChlKXtyZXR1cm4gbmV3IGZmKGUpfXN0YXRpYyBtb21lbnR1bShlLHQsbj0hMSl7cmV0dXJuIG5ldyBqdyhlLHQsbil9c3RhdGljIHJtc3Byb3AoZSx0PS45LG49MCxhPW51bGwscj0hMSl7cmV0dXJuIG5ldyBxdyhlLHQsbixhLHIpfXN0YXRpYyBhZGFtKGU9LjAwMSx0PS45LG49Ljk5OSxhPW51bGwpe3JldHVybiBuZXcgR3coZSx0LG4sYSl9c3RhdGljIGFkYWRlbHRhKGU9LjAwMSx0PS45NSxuPW51bGwpe3JldHVybiBuZXcgVncoZSx0LG4pfXN0YXRpYyBhZGFtYXgoZT0uMDAyLHQ9Ljksbj0uOTk5LGE9bnVsbCxyPTApe3JldHVybiBuZXcgSHcoZSx0LG4sYSxyKX1zdGF0aWMgYWRhZ3JhZChlLHQ9LjEpe3JldHVybiBuZXcgVXcoZSx0KX19LFhzPXQyLGM0PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUhPVwidW5kZWZpbmVkXCI/cmVxdWVzdEFuaW1hdGlvbkZyYW1lOnR5cGVvZiBzZXRJbW1lZGlhdGUhPVwidW5kZWZpbmVkXCI/c2V0SW1tZWRpYXRlOmU9PmUoKTtmdW5jdGlvbiBadygpe3JldHVybiBuZXcgUHJvbWlzZShlPT5jNCgoKT0+ZSgpKSl9dmFyIFQ9e307X2UoVCx7RVJGX0ExOigpPT5UNCxFUkZfQTI6KCk9PkM0LEVSRl9BMzooKT0+RTQsRVJGX0E0OigpPT5fNCxFUkZfQTU6KCk9PkE0LEVSRl9QOigpPT5ONCxQQVJBTExFTElaRV9USFJFU0hPTEQ6KCk9Pkp3LFJvd1BhcnRpdGlvblR5cGU6KCk9PmVyLFNFTFVfU0NBTEU6KCk9PmEyLFNFTFVfU0NBTEVBTFBIQTooKT0+bjIsYXBwbHlBY3RpdmF0aW9uOigpPT5oZixhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZTooKT0+Y3QsYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXM6KCk9PmwzLGFzc2VydFBhcmFtc0NvbnNpc3RlbnQ6KCk9PmQ0LGFzc2lnblRvVHlwZWRBcnJheTooKT0+TzQsYXhlc0FyZUlubmVyTW9zdERpbXM6KCk9PnV3LGNhbGN1bGF0ZVNoYXBlczooKT0+cFQsY2hlY2tFaW5zdW1EaW1TaXplczooKT0+VjQsY2hlY2tQYWRPbkRpbVJvdW5kaW5nTW9kZTooKT0+VG4sY29tYmluZUxvY2F0aW9uczooKT0+Rk4sY29tYmluZVJhZ2dlZFRlbnNvclRvVGVuc29yU2hhcGVzOigpPT5tNCxjb21wbGV4V2l0aEV2ZW5JbmRleDooKT0+RDQsY29tcGxleFdpdGhPZGRJbmRleDooKT0+UjQsY29tcHV0ZUNvbnYyREluZm86KCk9PnNkLGNvbXB1dGVDb252M0RJbmZvOigpPT5rTixjb21wdXRlRGVmYXVsdFBhZDooKT0+SHYsY29tcHV0ZURpbGF0aW9uMkRJbmZvOigpPT5pUCxjb21wdXRlT3B0aW1hbFdpbmRvd1NpemU6KCk9Pnk0LGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXM6KCk9PiROLGNvbXB1dGVPdXRTaGFwZTooKT0+aDQsY29tcHV0ZVBvb2wyREluZm86KCk9PndOLGNvbXB1dGVQb29sM0RJbmZvOigpPT5vUCxjb252ZXJ0Q29udjJERGF0YUZvcm1hdDooKT0+SU4sZGVjb2RlRWluc3VtRXF1YXRpb246KCk9Plc0LGVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZTooKT0+ZHIsZXhwYW5kU2hhcGVUb0tlZXBEaW06KCk9Pm1pLGV4cG9uZW50OigpPT5MNCxleHBvbmVudHM6KCk9PlA0LGZyb21TdHJpbmdBcnJheVRvVWludDg6KCk9PnVWLGZyb21VaW50OFRvU3RyaW5nQXJyYXk6KCk9PmxWLGdldEF4ZXNQZXJtdXRhdGlvbjooKT0+RE4sZ2V0QnJvYWRjYXN0RGltczooKT0+X04sZ2V0Q29tcGxleFdpdGhJbmRleDooKT0+TTQsZ2V0RWluc3VtQ29tcHV0ZVBhdGg6KCk9PlU0LGdldEVpbnN1bVBlcm11dGF0aW9uOigpPT5CNCxnZXRGdXNlZEJpYXNHcmFkaWVudDooKT0+ZGYsZ2V0RnVzZWREeUFjdGl2YXRpb246KCk9PmNmLGdldEltYWdlQ2VudGVyOigpPT54NCxnZXRJbm5lck1vc3RBeGVzOigpPT51MyxnZXRQZXJtdXRlZDooKT0+dzQsZ2V0UmFnZ2VkUmFuazooKT0+ZzQsZ2V0UmVkdWN0aW9uQXhlczooKT0+QnQsZ2V0UmVzaGFwZWQ6KCk9PnY0LGdldFJlc2hhcGVkUGVybXV0ZWQ6KCk9Pms0LGdldFJvd1BhcnRpdGlvblR5cGVzSGVscGVyOigpPT5mNCxnZXRTbGljZUJlZ2luQ29vcmRzOigpPT5JNCxnZXRTbGljZVNpemU6KCk9PlM0LGdldFNwYXJzZUZpbGxFbXB0eVJvd3NJbmRpY2VzRGVuc2VTaGFwZU1pc21hdGNoOigpPT5xNCxnZXRTcGFyc2VGaWxsRW1wdHlSb3dzTmVnYXRpdmVJbmRleEVycm9yTWVzc2FnZTooKT0+SzQsZ2V0U3BhcnNlRmlsbEVtcHR5Um93c091dE9mUmFuZ2VJbmRleEVycm9yTWVzc2FnZTooKT0+WDQsZ2V0U3BhcnNlUmVzaGFwZUVtcHR5VGVuc29yWmVyb091dHB1dERpbUVycm9yTWVzc2FnZTooKT0+SjQsZ2V0U3BhcnNlUmVzaGFwZUlucHV0T3V0cHV0TWlzbWF0Y2hFcnJvck1lc3NhZ2U6KCk9PmVWLGdldFNwYXJzZVJlc2hhcGVJbnB1dE91dHB1dE11bHRpcGxlRXJyb3JNZXNzYWdlOigpPT5RNCxnZXRTcGFyc2VSZXNoYXBlTXVsdGlwbGVOZWdhdGl2ZU9uZU91dHB1dERpbUVycm9yTWVzc2FnZTooKT0+WTQsZ2V0U3BhcnNlUmVzaGFwZU5lZ2F0aXZlT3V0cHV0RGltRXJyb3JNZXNzYWdlOigpPT5aNCxnZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uSW5kaWNlc091dE9mUmFuZ2VFcnJvck1lc3NhZ2U6KCk9PnJWLGdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25OZWdhdGl2ZVNlZ21lbnRJZHNFcnJvck1lc3NhZ2U6KCk9PnRWLGdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25Ob25JbmNyZWFzaW5nU2VnbWVudElkc0Vycm9yTWVzc2FnZTooKT0+blYsZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvblNlZ21lbnRJZE91dE9mUmFuZ2VFcnJvck1lc3NhZ2U6KCk9PmFWLGdldFVuZG9BeGVzUGVybXV0YXRpb246KCk9PnB3LGlzSWRlbnRpdHlQZXJtdXRhdGlvbjooKT0+RzQsbG9nOigpPT5nTSxtZXJnZVJlYWxBbmRJbWFnQXJyYXlzOigpPT5GNCxwcmVwYXJlQW5kVmFsaWRhdGU6KCk9PkhULHByZXBhcmVTcGxpdFNpemU6KCk9Pmo0LHNlZ21lbnRfdXRpbDooKT0+cjIsc2hvdWxkRnVzZTooKT0+bWYsc2xpY2VfdXRpbDooKT0+S3Qsc3BsaXRSZWFsQW5kSW1hZ0FycmF5czooKT0+JDQsc3RyaWRlc09yRGlsYXRpb25zQXJlUG9zaXRpdmU6KCk9PmhpLHR1cGxlVmFsdWVzQXJlT25lOigpPT5wcyx1cGNhc3RUeXBlOigpPT5mYSx2YWxpZGF0ZURlZmF1bHRWYWx1ZVNoYXBlOigpPT5iNCx2YWxpZGF0ZUlucHV0OigpPT5vZix2YWxpZGF0ZVVwZGF0ZVNoYXBlOigpPT4kdyx3YXJuOigpPT5acn0pO2Z1bmN0aW9uIGQ0KGUsdCl7bGV0IG49ZVswXS5sZW5ndGg7ZS5mb3JFYWNoKChyLHMpPT57QShyLmxlbmd0aD09PW4sKCk9PmBFcnJvciBpbiBjb25jYXQke259RDogcmFuayBvZiB0ZW5zb3JzWyR7c31dIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHJhbmsgb2YgdGhlIHJlc3QgKCR7bn0pYCl9KSxBKHQ+PTAmJnQ8biwoKT0+YEVycm9yIGluIGNvbmNhdCR7bn1EOiBheGlzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke24tMX0uYCk7bGV0IGE9ZVswXTtlLmZvckVhY2goKHIscyk9Pntmb3IobGV0IGk9MDtpPG47aSsrKUEoaT09PXR8fHJbaV09PT1hW2ldLCgpPT5gRXJyb3IgaW4gY29uY2F0JHtufUQ6IFNoYXBlIG9mIHRlbnNvcnNbJHtzfV0gKCR7cn0pIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgcmVzdCAoJHthfSkgYWxvbmcgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhpcyAke3N9LmApfSl9ZnVuY3Rpb24gaDQoZSx0KXtsZXQgbj1lWzBdLnNsaWNlKCk7Zm9yKGxldCBhPTE7YTxlLmxlbmd0aDthKyspblt0XSs9ZVthXVt0XTtyZXR1cm4gbn12YXIgZXI7KGZ1bmN0aW9uKGUpe2VbZS5GSVJTVF9ESU1fU0laRT0wXT1cIkZJUlNUX0RJTV9TSVpFXCIsZVtlLlZBTFVFX1JPV0lEUz0xXT1cIlZBTFVFX1JPV0lEU1wiLGVbZS5ST1dfTEVOR1RIUz0yXT1cIlJPV19MRU5HVEhTXCIsZVtlLlJPV19TUExJVFM9M109XCJST1dfU1BMSVRTXCIsZVtlLlJPV19MSU1JVFM9NF09XCJST1dfTElNSVRTXCIsZVtlLlJPV19TVEFSVFM9NV09XCJST1dfU1RBUlRTXCJ9KShlcnx8KGVyPXt9KSk7ZnVuY3Rpb24gbTQoZSx0LG4pe2xldCBhPW5ldyBBcnJheTtpZihuPT1udWxsJiZ0PT1udWxsKXJldHVybiBhO2lmKHQ9PW51bGwpZm9yKDthLmxlbmd0aDxlK24ubGVuZ3RoOylhLnB1c2goLTEpO2Vsc2UgYT10LnNsaWNlKCk7aWYobj09bnVsbClyZXR1cm4gYTtpZihlK24ubGVuZ3RoIT09YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBydCBpbnB1dC5zaGFwZSBhbmQgc2hhcGU9JHt0fSBhcmUgaW5jb21wYXRpYmxlOiBydCBpbnB1dC5yYW5rID0gJHtlK24ubGVuZ3RofSwgYnV0IHNoYXBlLnJhbmsgPSAke2EubGVuZ3RofWApO2ZvcihsZXQgcj0xO3I8bi5sZW5ndGg7KytyKXtsZXQgcz1uW3JdLGk9YVthLmxlbmd0aC1uLmxlbmd0aCtyXSxvPWFbaV07aWYocz49MClpZihvPj0wKXtpZihvIT09cyl0aHJvdyBuZXcgRXJyb3IoYHJ0IGlucHV0LnNoYXBlIGFuZCBzaGFwZT0ke3R9IGFyZSBpbmNvbXBhdGlibGU6IHJ0IGlucHV0LnNoYXBlWyR7citlfV0gPSAke3N9IGJ1dCBzaGFwZVske3IrZX1dID0gJHtvfWApfWVsc2UgYVtpXT1zfXJldHVybiBhfWZ1bmN0aW9uIGY0KGUpe2xldCB0PXtGSVJTVF9ESU1fU0laRTplci5GSVJTVF9ESU1fU0laRSxWQUxVRV9ST1dJRFM6ZXIuVkFMVUVfUk9XSURTLFJPV19MRU5HVEhTOmVyLlJPV19MRU5HVEhTLFJPV19TUExJVFM6ZXIuUk9XX1NQTElUUyxST1dfTElNSVRTOmVyLlJPV19MSU1JVFMsUk9XX1NUQVJUUzplci5ST1dfU1RBUlRTfSxuPVtdO2ZvcihsZXQgYSBvZiBlKWlmKGEgaW4gdCluLnB1c2godFthXSk7ZWxzZSBicmVhaztyZXR1cm4gbn1mdW5jdGlvbiBnNChlKXtyZXR1cm4gZS5sZW5ndGg9PT0wPzA6ZVswXT09PWVyLkZJUlNUX0RJTV9TSVpFP2UubGVuZ3RoLTE6ZS5sZW5ndGh9ZnVuY3Rpb24gYjQoZSx0KXtpZihlPT1udWxsfHx0PT1udWxsKXJldHVybjtsZXQgbj1lLmxlbmd0aCxhPXQubGVuZ3RoO2lmKG4+PWEpdGhyb3cgbmV3IEVycm9yKGBkZWZhdWx0VmFsdWUuc2hhcGU9JHtlfSBhbmQgcmFnZ2VkIHRlbnNvciBmbGF0VmFsdWVzLnNoYXBlPSR7dH0sIGFyZSBpbmNvbXBhdGlibGU6IGRlZmF1bHRWYWx1ZS5yYW5rID0gJHtufSBtdXN0IGJlIGxlc3MgdGhhbiByYWdnZWQgdGVuc29yIGlucHV0IGZsYXRWYWx1ZXMucmFuayA9ICR7YX0pYCk7Zm9yKGxldCByPTA7cjxNYXRoLm1pbihuLGEtMSk7KytyKXtsZXQgcz1lW3JdLGk9dFtyKzFdO2lmKHM+PTAmJmk+PTAmJnMhPT0xJiZzIT09aSl0aHJvdyBuZXcgRXJyb3IoYGRlZmF1bHRWYWx1ZS5zaGFwZT0ke2V9LCBhbmQgcmFnZ2VkIHRlbnNvciBpbnB1dCBmbGF0VmFsdWVzLnNoYXBlPSR7dH0gYXJlIGluY29tcGF0aWJsZTogZGVmYXVsdFZhbHVlLnNoYXBlWyR7ci1lLmxlbmd0aH1dID0gJHtzfSBidXQgcmFnZ2VkIHRlbnNvciBpbnB1dC5mbGF0VmFsdWVzLnNoYXBlWyR7ci1lLmxlbmd0aH1dID0gJHtpfWApfX12YXIgSnc9MzA7ZnVuY3Rpb24geTQoZSl7cmV0dXJuIGU8PUp3P2U6R2goZSxNYXRoLmZsb29yKE1hdGguc3FydChlKSkpfWZ1bmN0aW9uIHg0KGUsdCxuKXtsZXQgYT1uKih0eXBlb2YgZT09XCJudW1iZXJcIj9lOmVbMF0pLHI9dCoodHlwZW9mIGU9PVwibnVtYmVyXCI/ZTplWzFdKTtyZXR1cm5bYSxyXX1mdW5jdGlvbiB2NChlLHQsbixhPSEwKXtsZXQgcj1bXTtpZihhKXI9ci5jb25jYXQodC5zbGljZSgwKSksci5wdXNoKGVbMF0vbikscj1yLmNvbmNhdChlLnNsaWNlKDEpKTtlbHNle3I9ci5jb25jYXQoZVswXSk7bGV0IHM9dC5sZW5ndGg7Zm9yKGxldCBpPTA7aTxzOysraSlyPXIuY29uY2F0KFtlW2krMV0vdFtpXSx0W2ldXSk7cj1yLmNvbmNhdChlLnNsaWNlKHMrMSkpfXJldHVybiByfWZ1bmN0aW9uIHc0KGUsdCxuPSEwKXtsZXQgYT1bXTtpZihuKXthLnB1c2godCk7Zm9yKGxldCByPXQrMTtyPGU7KytyKXI8PTIqdD8oYS5wdXNoKHIpLGEucHVzaChyLSh0KzEpKSk6YS5wdXNoKHIpfWVsc2V7bGV0IHI9W10scz1bXTtmb3IobGV0IGk9MTtpPGU7KytpKWk+PXQqMisxfHxpJTI9PT0xP3MucHVzaChpKTpyLnB1c2goaSk7YS5wdXNoKC4uLnIpLGEucHVzaCgwKSxhLnB1c2goLi4ucyl9cmV0dXJuIGF9ZnVuY3Rpb24gazQoZSx0LG4sYT0hMCl7bGV0IHI9W107YT9yLnB1c2goZVswXS9uKTpyLnB1c2goZVswXSpuKTtmb3IobGV0IHM9MTtzPGUubGVuZ3RoOysrcylzPD10Lmxlbmd0aD9hP3IucHVzaCh0W3MtMV0qZVtzXSk6ci5wdXNoKGVbc10vdFtzLTFdKTpyLnB1c2goZVtzXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gSTQoZSx0KXtsZXQgbj1bMF07Zm9yKGxldCBhPTA7YTx0OysrYSluLnB1c2goZVthXVswXSk7cmV0dXJuIG59ZnVuY3Rpb24gUzQoZSx0LG4pe2xldCBhPWUuc2xpY2UoMCwxKTtmb3IobGV0IHI9MDtyPG47KytyKWEucHVzaChlW3IrMV0tdFtyXVswXS10W3JdWzFdKTtyZXR1cm4gYX12YXIgbjI9MS43NTgwOTkzNDA4NDczNzY4LGEyPTEuMDUwNzAwOTg3MzU1NDgwNSxOND0uMzI3NTkxMSxUND0uMjU0ODI5NTkyLEM0PS0uMjg0NDk2NzM2LEU0PTEuNDIxNDEzNzQxLF80PS0xLjQ1MzE1MjAyNyxBND0xLjA2MTQwNTQyOTtmdW5jdGlvbiBGNChlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbWVyZ2UgcmVhbCBhbmQgaW1hZyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aHMuIHJlYWw6JHtlLmxlbmd0aH0sIGltYWc6ICR7dC5sZW5ndGh9LmApO2xldCBuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgqMik7Zm9yKGxldCBhPTA7YTxuLmxlbmd0aDthKz0yKW5bYV09ZVthLzJdLG5bYSsxXT10W2EvMl07cmV0dXJuIG59ZnVuY3Rpb24gJDQoZSl7bGV0IHQ9bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aC8yKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgvMik7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDthKz0yKXRbYS8yXT1lW2FdLG5bYS8yXT1lW2ErMV07cmV0dXJue3JlYWw6dCxpbWFnOm59fWZ1bmN0aW9uIEQ0KGUpe2xldCB0PU1hdGguY2VpbChlLmxlbmd0aC80KSxuPW5ldyBGbG9hdDMyQXJyYXkodCksYT1uZXcgRmxvYXQzMkFycmF5KHQpO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cis9NCluW01hdGguZmxvb3Ioci80KV09ZVtyXSxhW01hdGguZmxvb3Ioci80KV09ZVtyKzFdO3JldHVybntyZWFsOm4saW1hZzphfX1mdW5jdGlvbiBSNChlKXtsZXQgdD1NYXRoLmZsb29yKGUubGVuZ3RoLzQpLG49bmV3IEZsb2F0MzJBcnJheSh0KSxhPW5ldyBGbG9hdDMyQXJyYXkodCk7Zm9yKGxldCByPTI7cjxlLmxlbmd0aDtyKz00KW5bTWF0aC5mbG9vcihyLzQpXT1lW3JdLGFbTWF0aC5mbG9vcihyLzQpXT1lW3IrMV07cmV0dXJue3JlYWw6bixpbWFnOmF9fWZ1bmN0aW9uIE00KGUsdCl7bGV0IG49ZVt0KjJdLGE9ZVt0KjIrMV07cmV0dXJue3JlYWw6bixpbWFnOmF9fWZ1bmN0aW9uIE80KGUsdCxuLGEpe2VbYSoyXT10LGVbYSoyKzFdPW59ZnVuY3Rpb24gUDQoZSx0KXtsZXQgbj1uZXcgRmxvYXQzMkFycmF5KGUvMiksYT1uZXcgRmxvYXQzMkFycmF5KGUvMik7Zm9yKGxldCByPTA7cjxNYXRoLmNlaWwoZS8yKTtyKyspe2xldCBzPSh0PzI6LTIpKk1hdGguUEkqKHIvZSk7bltyXT1NYXRoLmNvcyhzKSxhW3JdPU1hdGguc2luKHMpfXJldHVybntyZWFsOm4saW1hZzphfX1mdW5jdGlvbiBMNChlLHQsbil7bGV0IGE9KG4/MjotMikqTWF0aC5QSSooZS90KSxyPU1hdGguY29zKGEpLHM9TWF0aC5zaW4oYSk7cmV0dXJue3JlYWw6cixpbWFnOnN9fXZhciB1eD1cIi0+XCIsejQ9Ly0+L2csb0k9XCIsXCIsbEk9XCIuLi5cIjtmdW5jdGlvbiBXNChlLHQpe2U9ZS5yZXBsYWNlKC9cXHMvZyxcIlwiKTtsZXQgbj0oZS5sZW5ndGgtZS5yZXBsYWNlKHo0LFwiXCIpLmxlbmd0aCkvdXgubGVuZ3RoO2lmKG48MSl0aHJvdyBuZXcgRXJyb3IoXCJFcXVhdGlvbnMgd2l0aG91dCBhbiBhcnJvdyBhcmUgbm90IHN1cHBvcnRlZC5cIik7aWYobj4xKXRocm93IG5ldyBFcnJvcihgRXF1YXRpb24gbXVzdCBjb250YWluIGV4YWN0bHkgb25lIGFycm93IChcIiR7dXh9XCIpLmApO2xldFthLHJdPWUuc3BsaXQodXgpO0EoYS5pbmRleE9mKGxJKT09PS0xLCgpPT5gVGhlIGVsbGlwc2lzIG5vdGF0aW9uIChcIiR7bEl9XCIpIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LmApO2xldCBzPWEuc3BsaXQob0kpLGk9cy5sZW5ndGg7aWYodCE9PWkpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke2l9IGlucHV0IHRlbnNvcnMsIHJlY2VpdmVkICR7dH1gKTtpZihpPjIpdGhyb3cgbmV3IEVycm9yKFwiU3VwcG9ydCBmb3IgbW9yZSB0aGFuIDIgaW5wdXQgdGVuc29ycyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtsZXQgbz1bXTtmb3IobGV0IGM9MDtjPHIubGVuZ3RoOysrYyl7bGV0IGg9cltjXTtpZighcy5zb21lKG09Pm0uaW5kZXhPZihoKSE9PS0xKSl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzdWJzY3JpcHRzIGNvbnRhaW4gdGhlIGxhYmVsICR7aH0gbm90IHByZXNlbnQgaW4gdGhlIGlucHV0IHN1YnNjcmlwdHMuYCk7by5pbmRleE9mKGgpPT09LTEmJm8ucHVzaChoKX1mb3IobGV0IGM9MDtjPGEubGVuZ3RoOysrYyl7bGV0IGg9YVtjXTtvLmluZGV4T2YoaCk9PT0tMSYmaCE9PW9JJiZvLnB1c2goaCl9bGV0IGw9bmV3IEFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGM9MDtjPGk7KytjKXtpZihuZXcgU2V0KHNbY10uc3BsaXQoXCJcIikpLnNpemUhPT1zW2NdLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGR1cGxpY2F0ZSBheGVzIGluIGlucHV0IGNvbXBvbmVudCAke3NbY119LiBTdXBwb3J0IGZvciBkdXBsaWNhdGUgYXhlcyBpbiBpbnB1dCBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LmApO2xbY109W107Zm9yKGxldCBoPTA7aDxzW2NdLmxlbmd0aDsrK2gpbFtjXS5wdXNoKG8uaW5kZXhPZihzW2NdW2hdKSl9bGV0IHU9by5sZW5ndGgscD1yLmxlbmd0aCxkPVtdO2ZvcihsZXQgYz1wO2M8dTsrK2MpZC5wdXNoKGMpO3JldHVybnthbGxEaW1zOm8sc3VtbWVkRGltczpkLGlkRGltczpsfX1mdW5jdGlvbiBCNChlLHQpe2xldCBuPW5ldyBBcnJheShlKTtuLmZpbGwoLTEpO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKW5bdFtyXV09cjtsZXQgYT1bXTtmb3IobGV0IHI9MDtyPGU7KytyKW5bcl09PT0tMSYmYS5wdXNoKHIpO3JldHVybiBuPW4uZmlsdGVyKHI9PnIhPT0tMSkse3Blcm11dGF0aW9uSW5kaWNlczpuLGV4cGFuZERpbXM6YX19ZnVuY3Rpb24gVjQoZSx0LG4pe2xldCBhPW5ldyBBcnJheShlKTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrcil7bGV0IHM9bltyXS5zaGFwZTtmb3IobGV0IGk9MDtpPHRbcl0ubGVuZ3RoOysraSlhW3Rbcl1baV1dPT09dm9pZCAwP2FbdFtyXVtpXV09c1tpXTpBKGFbdFtyXVtpXV09PT1zW2ldLCgpPT5gRXhwZWN0ZWQgZGltZW5zaW9uICR7YVt0W3JdW2ldXX0gYXQgYXhpcyAke2l9IG9mIGlucHV0IHNoYXBlZCAke0pTT04uc3RyaW5naWZ5KHMpfSwgYnV0IGdvdCBkaW1lbnNpb24gJHtzW2ldfWApfX1mdW5jdGlvbiBVNChlLHQpe2xldCBuPWUsYT1bXSxyPTA7ZS5sZW5ndGg9PT0wJiZuLnB1c2goLTEpLHI9ZS5sZW5ndGgrMTtmb3IobGV0IGk9MDtpPHI7KytpKWEucHVzaChbXSk7bGV0IHM9W107Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDsrK2kpe2xldCBvPW5baV0sbD1INCh0LG8pO2ZvcihsZXQgdSBvZiBsKXMuaW5kZXhPZih1KT09PS0xJiYoYVtpXS5wdXNoKHUpLHMucHVzaCh1KSl9cmV0dXJue3BhdGg6bixzdGVwczphfX1mdW5jdGlvbiBHNChlKXtyZXR1cm4gZS5ldmVyeSgodCxuKT0+dD09PW4pfWZ1bmN0aW9uIEg0KGUsdCl7bGV0IG49W107Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDsrK2EpKGVbYV0ubGVuZ3RoPT09MHx8ZVthXS5pbmRleE9mKHQpIT09LTF8fHQ9PT0tMSkmJm4ucHVzaChhKTtyZXR1cm4gbn1mdW5jdGlvbiBqNChlLHQsbj0wKXtsZXQgYT1bXTtpZih0eXBlb2YgdD09XCJudW1iZXJcIilBKGUuc2hhcGVbbl0ldD09PTAsKCk9PlwiTnVtYmVyIG9mIHNwbGl0cyBtdXN0IGV2ZW5seSBkaXZpZGUgdGhlIGF4aXMuXCIpLGE9bmV3IEFycmF5KHQpLmZpbGwoZS5zaGFwZVtuXS90KTtlbHNle2xldCByPXQucmVkdWNlKChpLG8pPT4obz09PS0xJiYoaSs9MSksaSksMCk7QShyPD0xLCgpPT5cIlRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBuZWdhdGl2ZSB2YWx1ZSBpbiBzcGxpdCBhcnJheS5cIik7bGV0IHM9dC5pbmRleE9mKC0xKTtpZihzIT09LTEpe2xldCBpPXQucmVkdWNlKChvLGwpPT5sPjA/bytsOm8pO3Rbc109ZS5zaGFwZVtuXS1pfUEoZS5zaGFwZVtuXT09PXQucmVkdWNlKChpLG8pPT5pK28pLCgpPT5cIlRoZSBzdW0gb2Ygc2l6ZXMgbXVzdCBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgYXhpcyBkaW1lbnNpb24uXCIpLGE9dH1yZXR1cm4gYX1mdW5jdGlvbiBxNChlKXtyZXR1cm5gUmVjZWl2ZWQgU3BhcnNlVGVuc29yIHdpdGggZGVuc2VTaGFwZVswXSA9IDAgYnV0XG4gIGluZGljZXMuc2hhcGVbMF0gPSAke2V9YH1mdW5jdGlvbiBLNChlLHQpe3JldHVybmBpbmRpY2VzKCR7ZX0sIDApIGlzIGludmFsaWQ6ICR7dH0gPCAwYH1mdW5jdGlvbiBYNChlLHQsbil7cmV0dXJuYGluZGljZXMoJHtlfSwgMCkgaXMgaW52YWxpZDogJHt0fSA+PSAke259YH1mdW5jdGlvbiBZNChlLHQpe3JldHVybmBvbmx5IG9uZSBvdXRwdXQgZGltZW5zaW9uIG1heSBiZSAtMSwgbm90IGJvdGggJHtlfSBhbmQgJHt0fWB9ZnVuY3Rpb24gWjQoZSx0KXtyZXR1cm5gc2l6ZSAke2V9IG11c3QgYmUgbm9uLW5lZ2F0aXZlLCBub3QgJHt0fWB9ZnVuY3Rpb24gSjQoKXtyZXR1cm5cInJlc2hhcGUgY2Fubm90IGluZmVyIHRoZSBtaXNzaW5nIGlucHV0IHNpemUgZm9yIGFuIGVtcHR5IHRlbnNvciB1bmxlc3MgYWxsIHNwZWNpZmllZCBpbnB1dCBzaXplcyBhcmUgbm9uLXplcm9cIn1mdW5jdGlvbiBRNChlLHQpe2xldCBuPW90KGUpLGE9b3QodCk7cmV0dXJuYElucHV0IHRvIHJlc2hhcGUgaXMgYSBTcGFyc2VUZW5zb3Igd2l0aCAke259XG4gIGRlbnNlIHZhbHVlcywgYnV0IHRoZSByZXF1ZXN0ZWQgc2hhcGUgcmVxdWlyZXMgYSBtdWx0aXBsZSBvZiAke2F9LiBpbnB1dFNoYXBlPSR7ZX0gb3V0cHV0U2hhcGU9ICR7dH1gfWZ1bmN0aW9uIGVWKGUsdCl7bGV0IG49b3QoZSksYT1vdCh0KTtyZXR1cm5gSW5wdXQgdG8gcmVzaGFwZSBpcyBhIHRlbnNvciB3aXRoICR7bn0gZGVuc2UgdmFsdWVzLCBidXQgdGhlIHJlcXVlc3RlZCBzaGFwZSBoYXMgJHthfS4gaW5wdXRTaGFwZT0ke2V9IG91dHB1dFNoYXBlPSR7dH1gfWZ1bmN0aW9uIHRWKCl7cmV0dXJuXCJzZWdtZW50IGlkcyBtdXN0IGJlID49IDBcIn1mdW5jdGlvbiBuVigpe3JldHVyblwic2VnbWVudCBpZHMgYXJlIG5vdCBpbmNyZWFzaW5nXCJ9ZnVuY3Rpb24gYVYoZSx0KXtyZXR1cm5gU2VnbWVudCBpZCAke2V9IG91dCBvZiByYW5nZSBbMCwgJHt0fSksIHBvc3NpYmx5IGJlY2F1c2Ugc2VnbWVudElkcyBpbnB1dCBpcyBub3Qgc29ydGVkLmB9ZnVuY3Rpb24gclYoZSx0LG4pe3JldHVybmBCYWQ6IGluZGljZXNbJHtlfV0gPT0gJHt0fSBvdXQgb2YgcmFuZ2UgWzAsICR7bn0pYH12YXIgcjI9e307X2UocjIse2NvbGxlY3RHYXRoZXJPcFNoYXBlSW5mbzooKT0+b1YsY29tcHV0ZU91dFNoYXBlOigpPT5pVixzZWdPcENvbXB1dGVPcHRpbWFsV2luZG93U2l6ZTooKT0+c1Z9KTtmdW5jdGlvbiBzVihlLHQpe2xldCBuPSExLGE7Zm9yKGU8PUp3PyhhPWUsbj0hMCk6YT1HaChlLE1hdGguZmxvb3IoTWF0aC5zcXJ0KGUpKSk7IW47KWE+dHx8YT09PWU/bj0hMDphPUdoKGUsYSsxKTtyZXR1cm4gYX1mdW5jdGlvbiBpVihlLHQsbil7bGV0IGE9W10scj1lLmxlbmd0aDtmb3IobGV0IHM9MDtzPHI7cysrKXMhPT10P2EucHVzaChlW3NdKTphLnB1c2gobik7cmV0dXJuIGF9ZnVuY3Rpb24gb1YoZSx0LG4sYSl7bGV0IHI9dC5zaGFwZS5sZW5ndGgscz1lLnNoYXBlLmxlbmd0aDtpZihhIT09MCYmKGE8LXJ8fGE+cikpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3QgYmF0Y2hEaW1zIGluIHRoZSByYW5nZSBvZiBbLSR7cn0sICR7cn1dLCBidXQgZ290ICR7YX1gKTtpZihhPDAmJihhKz1yKSxhPnMpdGhyb3cgbmV3IEVycm9yKGBiYXRjaERpbXMgKCR7YX0pIG11c3QgYmUgbGVzcyB0aGFuIHJhbmsoeCkgKFxuICAgICR7c30pLmApO2lmKG48YSl0aHJvdyBuZXcgRXJyb3IoYGJhdGNoRGltcyAoJHthfSkgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYXhpcyAoJHtufSkuYCk7Zm9yKGxldCBkPTA7ZDxhOysrZClpZihlLnNoYXBlW2RdIT09dC5zaGFwZVtkXSl0aHJvdyBuZXcgRXJyb3IoYHguc2hhcGVbJHtkfV06ICR7ZS5zaGFwZVtkXX0gc2hvdWxkIGJlIGVxdWFsIHRvIGluZGljZXMuc2hhcGVbJHtkfV06ICR7dC5zaGFwZVtkXX0uYCk7bGV0IGk9ZS5zaGFwZVtuXSxvPVtdLGw9MSx1PTEscD0xO2ZvcihsZXQgZD0wO2Q8YTsrK2Qpby5wdXNoKGUuc2hhcGVbZF0pLGwqPWUuc2hhcGVbZF07Zm9yKGxldCBkPWE7ZDxuO2QrKylvLnB1c2goZS5zaGFwZVtkXSksdSo9ZS5zaGFwZVtkXTtmb3IobGV0IGQ9YTtkPHI7ZCsrKW8ucHVzaCh0LnNoYXBlW2RdKTtmb3IobGV0IGQ9bisxO2Q8cztkKyspby5wdXNoKGUuc2hhcGVbZF0pLHAqPWUuc2hhcGVbZF07cmV0dXJue2JhdGNoU2l6ZTpsLHNsaWNlU2l6ZTpwLG91dGVyU2l6ZTp1LGRpbVNpemU6aSxvdXRwdXRTaGFwZTpvfX1mdW5jdGlvbiBsVihlKXt0cnl7cmV0dXJuIGUubWFwKHQ9PnFoKHQpKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWNvZGUgZW5jb2RlZCBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOCwgZXJyb3I6ICR7dH1gKX19ZnVuY3Rpb24gdVYoZSl7cmV0dXJuIGUubWFwKHQ9Pm5kKHQpKX12YXIgbXI9e307X2UobXIse25vbk1heFN1cHByZXNzaW9uVjNJbXBsOigpPT5TVCxub25NYXhTdXBwcmVzc2lvblY0SW1wbDooKT0+TlQsbm9uTWF4U3VwcHJlc3Npb25WNUltcGw6KCk9PlRULHdoZXJlSW1wbDooKT0+aFR9KTtUQigpO3ZhciBzMj17a2VybmVsTmFtZTpZbCxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KGUsam8ocmUobixcImZsb2F0MzJcIiksLTEpKX19fSxwVj17a2VybmVsTmFtZTpOaSxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT57bGV0IGE9cHQocmUobixcImZsb2F0MzJcIikpLHI9cm4ocGUoeGUoMSksYSkpO3JldHVybiB5dChoZShlLHIpKX19fX0sY1Y9e2tlcm5lbE5hbWU6VGksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+e2xldCBhPXJuKHBlKHB0KHJlKG4sXCJmbG9hdDMyXCIpKSwxKSk7cmV0dXJuIGhlKGUsYSl9fX19LGRWPXtrZXJuZWxOYW1lOnZzLGlucHV0c1RvU2F2ZTpbXCJhXCIsXCJiXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W24sYV09dCxyPWN0KG4uc2hhcGUsYS5zaGFwZSk7cmV0dXJue2E6KCk9PntsZXQgcz1lLGk9QnQobi5zaGFwZSxyKTtyZXR1cm4gaS5sZW5ndGg+MCYmKHM9ZmUocyxpKSksVyhzLG4uc2hhcGUpfSxiOigpPT57bGV0IHM9ZSxpPUJ0KGEuc2hhcGUscik7cmV0dXJuIGkubGVuZ3RoPjAmJihzPWZlKHMsaSkpLFcocyxhLnNoYXBlKX19fX0saFY9e2tlcm5lbE5hbWU6Q2ksc2F2ZUFsbElucHV0czohMCxncmFkRnVuYzooZSx0KT0+e2xldCBuPXt9O3JldHVybiB0LmZvckVhY2goKGEscik9PntuW3JdPSgpPT5lLmNsb25lKCl9KSxufX0sbVY9e2tlcm5lbE5hbWU6UWwsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+cWUobil9fX0sZlY9e2tlcm5lbE5hbWU6ZXUsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+cWUobil9fX0sZ1Y9e2tlcm5lbE5hbWU6RWksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+aGUoZSxybihwZSh4ZSgxKSxwdChyZShuLFwiZmxvYXQzMlwiKSkpKSl9fX0sYlY9e2tlcm5lbE5hbWU6X2ksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+e2xldCBhPXJuKFgoeGUoMSkscHQocmUobixcImZsb2F0MzJcIikpKSk7cmV0dXJuIGhlKGUsYSl9fX19LHlWPXtrZXJuZWxOYW1lOiRpLGlucHV0c1RvU2F2ZTpbXCJhXCIsXCJiXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W24sYV09dCxyPWN0KG4uc2hhcGUsYS5zaGFwZSk7cmV0dXJue2E6KCk9PntsZXQgcz1YKHB0KG4pLHB0KGEpKSxpPXooZSxoZShhLHMpKSxvPUJ0KG4uc2hhcGUscik7cmV0dXJuIG8ubGVuZ3RoPjAmJihpPWZlKGksbykpLFcoaSxuLnNoYXBlKX0sYjooKT0+e2xldCBzPVgocHQobikscHQoYSkpLGk9eXQoeihlLGhlKG4scykpKSxvPUJ0KGEuc2hhcGUscik7cmV0dXJuIG8ubGVuZ3RoPjAmJihpPWZlKGksbykpLFcoaSxhLnNoYXBlKX19fX0seFY9e2tlcm5lbE5hbWU6QWksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+aGUoZSxYKHB0KHJlKG4sXCJmbG9hdDMyXCIpKSwxKSl9fX0sdlY9e2tlcm5lbE5hbWU6RmksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+aGUoZSxwZSh4ZSgxKSxwdChyZShuLFwiZmxvYXQzMlwiKSkpKX19fTtmdW5jdGlvbiB3VihlLHQsbixhLHIscyl7bGV0IGk9RShlLFwiZHlcIixcImF2Z1Bvb2wzZEdyYWRcIiksbz1FKHQsXCJpbnB1dFwiLFwiYXZnUG9vbDNkR3JhZFwiKSxsPWksdT1vLHA9ITE7by5yYW5rPT09NCYmKHA9ITAsbD1XKGksWzEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0saS5zaGFwZVszXV0pLHU9VyhvLFsxLG8uc2hhcGVbMF0sby5zaGFwZVsxXSxvLnNoYXBlWzJdLG8uc2hhcGVbM11dKSksQShsLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gYXZnUG9vbDNkR3JhZDogZHkgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSxBKHUucmFuaz09PTUsKCk9PmBFcnJvciBpbiBhdmdQb29sM2RHcmFkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgJHt1LnJhbmt9LmApLFRuKFwiYXZnUG9vbDNkR3JhZFwiLHIscyk7bGV0IGQ9e2R5OmwsaW5wdXQ6dX0sYz17ZmlsdGVyU2l6ZTpuLHN0cmlkZXM6YSxwYWQ6cixkaW1Sb3VuZGluZ01vZGU6c30saD1QLnJ1bktlcm5lbChSYyxkLGMpO3JldHVybiBwP1coaCxbaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10saC5zaGFwZVs0XV0pOmh9dmFyIGtWPUwoe2F2Z1Bvb2wzZEdyYWRfOndWfSksSVY9e2tlcm5lbE5hbWU6dHUsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtmaWx0ZXJTaXplOnIsc3RyaWRlczpzLHBhZDppLGRpbVJvdW5kaW5nTW9kZTpvfT1uO3JldHVybnt4OigpPT5rVihlLGEscixzLGksbyl9fX07ZnVuY3Rpb24gU1YoZSx0LG4sYSxyKXtsZXQgcz1FKGUsXCJkeVwiLFwiYXZnUG9vbEdyYWRcIiksaT1FKHQsXCJpbnB1dFwiLFwiYXZnUG9vbEdyYWRcIik7QShpLnJhbms9PT1zLnJhbmssKCk9PmBSYW5rIG9mIGlucHV0ICgke2kucmFua30pIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKCR7cy5yYW5rfSlgKTtsZXQgbz1pLGw9cyx1PSExO2kucmFuaz09PTMmJih1PSEwLG89VyhpLFsxLGkuc2hhcGVbMF0saS5zaGFwZVsxXSxpLnNoYXBlWzJdXSksbD1XKHMsWzEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl1dKSksQShsLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gYXZnUG9vbEdyYWQ6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayAke2wucmFua30uYCksQShvLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gYXZnUG9vbEdyYWQ6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayAke28ucmFua30uYCk7bGV0IHA9e2R5OmwsaW5wdXQ6b30sZD17ZmlsdGVyU2l6ZTpuLHN0cmlkZXM6YSxwYWQ6cn0sYz1QLnJ1bktlcm5lbChEYyxwLGQpO3JldHVybiB1P1coYyxbYy5zaGFwZVsxXSxjLnNoYXBlWzJdLGMuc2hhcGVbM11dKTpjfXZhciBOVj1MKHthdmdQb29sR3JhZF86U1Z9KSxUVj17a2VybmVsTmFtZTpEaSxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQse2ZpbHRlclNpemU6cixzdHJpZGVzOnMscGFkOml9PW47cmV0dXJue3g6KCk9Pk5WKGUsYSxyLHMsaSl9fX0sQ1Y9e2tlcm5lbE5hbWU6UmksaW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQse3RyYW5zcG9zZUE6cyx0cmFuc3Bvc2VCOml9PW47cmV0dXJuIXMmJiFpP3thOigpPT4kZShlLHIsITEsITApLGI6KCk9PiRlKGEsZSwhMCwhMSl9OiFzJiZpP3thOigpPT4kZShlLHIsITEsITEpLGI6KCk9PiRlKGUsYSwhMCwhMSl9OnMmJiFpP3thOigpPT4kZShyLGUsITEsITApLGI6KCk9PiRlKGEsZSwhMSwhMSl9OnthOigpPT4kZShyLGUsITAsITApLGI6KCk9PiRlKGUsYSwhMCwhMCl9fX0sRVY9e2tlcm5lbE5hbWU6bnUsZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldHtibG9ja1NoYXBlOmEsY3JvcHM6cn09bjtyZXR1cm57eDooKT0+bWQoZSxhLHIpfX19LF9WPXtrZXJuZWxOYW1lOkhTLGdyYWRGdW5jOihlLHQsbik9PntsZXQgYT1uLHI9YS5pbnB1dFNoYXBlLHM9YS5zaGFwZSxpPUFycmF5LmZyb20ocyk7Zm9yKGxldCBsPXIubGVuZ3RoLTE7bD49MDtsLS0paWYocltsXT09PXNbbF0paVtsXT0xO2Vsc2UgaWYocltsXSE9PTEpdGhyb3cgbmV3IEVycm9yKGBicm9hZGNhc3RUbygpOiBbJHtyfV0gY2Fubm90IGJlIGJyb2FkY2FzdCB0byBbJHtzfV0uYCk7bGV0IG89W107Zm9yKGxldCBsPTA7bDxpLmxlbmd0aDtsKyspaVtsXT4xJiZvLnB1c2gobCk7cmV0dXJue3g6KCk9PmZlKGUsbywhMCl9fX0sQVY9e2tlcm5lbE5hbWU6TWksZ3JhZEZ1bmM6ZT0+KHt4OigpPT5lLmNsb25lKCl9KX0sRlY9e2tlcm5lbE5hbWU6T2ksZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSwkVj17a2VybmVsTmFtZTp3cyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQse2NsaXBWYWx1ZU1pbjpyLGNsaXBWYWx1ZU1heDpzfT1uO3JldHVybnt4OigpPT5ubihfYSgkcihhLHIpLENzKGEscykpLGUscWUoZSkpfX19LERWPXtrZXJuZWxOYW1lOk9jLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOnMyLmdyYWRGdW5jfSxSVj17a2VybmVsTmFtZTpzdSxzYXZlQWxsSW5wdXRzOiEwLGdyYWRGdW5jOihlLHQsbik9PntsZXQgYT10Lm1hcChvPT5vLnNoYXBlKSx7YXhpczpyfT1uLHM9QWEocix0WzBdLnNoYXBlKVswXSxpPWEubWFwKG89Pm9bc10pO3JldHVybiBMbihlLGkscykubWFwKG89PigpPT5vKX19LE1WPXtrZXJuZWxOYW1lOlBpLGlucHV0c1RvU2F2ZTpbXCJ4XCIsXCJmaWx0ZXJcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQse2RpbGF0aW9uczpzLHN0cmlkZXM6aSxwYWQ6byxkYXRhRm9ybWF0Omx9PW47cmV0dXJuIEEocHMocyksKCk9PmBFcnJvciBpbiBncmFkaWVudCBvZiBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJyR7c30nYCkse3g6KCk9Pm53KGEuc2hhcGUsZSxyLGksbyxsKSxmaWx0ZXI6KCk9Pnp3KGEsZSxyLnNoYXBlLGksbyxsKX19fSxPVj17a2VybmVsTmFtZTpMaSxpbnB1dHNUb1NhdmU6W1wiZHlcIixcImZpbHRlclwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2Escl09dCx7c3RyaWRlczpzLHBhZDppLGRhdGFGb3JtYXQ6byxkaW1Sb3VuZGluZ01vZGU6bH09bjtyZXR1cm57ZHk6KCk9PiR0KGUscixzLGksbywxLGwpLGZpbHRlcjooKT0+encoZSxhLHIuc2hhcGUscyxpLG8sbCl9fX07ZnVuY3Rpb24gUFYoZSx0LG4sYSxyKXtsZXQgcz1lO2UucmFuaz09PTQmJihzPVcoZSxbMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdXSkpO2xldCBpPXQ7aS5yYW5rPT09NCYmKGk9Vyh0LFsxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSx0LnNoYXBlWzJdLHQuc2hhcGVbM11dKSksQShzLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCBzaGFwZSAke3Muc2hhcGV9LmApLEEoaS5yYW5rPT09NSwoKT0+YEVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3Qgc2hhcGUgJHtpLnNoYXBlfS5gKSxBKG4ubGVuZ3RoPT09NSwoKT0+YEVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNSwgYnV0IGdvdCAke259LmApLEEocy5zaGFwZVs0XT09PW5bM10sKCk9PmBFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0ICR7cy5zaGFwZVs0XX0pIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyICgke25bM119LmApLEEoaS5zaGFwZVs0XT09PW5bNF0sKCk9PmBFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGR5ICgke2kuc2hhcGVbNF19KSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyICgke25bNF19KS5gKTtsZXQgbz17eDpzLGR5Oml9LGw9e3N0cmlkZXM6YSxwYWQ6cixmaWx0ZXJTaGFwZTpufTtyZXR1cm4gUC5ydW5LZXJuZWwoaXUsbyxsKX12YXIgTFY9TCh7Y29udjNEQmFja3Byb3BGaWx0ZXJfOlBWfSkselY9e2tlcm5lbE5hbWU6emksaW5wdXRzVG9TYXZlOltcInhcIixcImZpbHRlclwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0e2RpbGF0aW9uczphLHN0cmlkZXM6cixwYWQ6c309bjtBKHBzKGEpLCgpPT5gRXJyb3IgaW4gZ3JhZGllbnQgb2YgY29udjNEOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQgaW4gZ3JhZGllbnRzLiBHb3QgZGlsYXRpb25zICcke2F9J2ApO2xldFtpLG9dPXQ7cmV0dXJue3g6KCk9PkNOKGkuc2hhcGUsZSxvLHIscyksZmlsdGVyOigpPT5MVihpLGUsby5zaGFwZSxyLHMpfX19LFdWPXtrZXJuZWxOYW1lOldpLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PnooeXQoZWYocmUobixcImZsb2F0MzJcIikpKSxlKX19fSxCVj17a2VybmVsTmFtZTpCaSxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KHRmKHJlKG4sXCJmbG9hdDMyXCIpKSxlKX19fSxWVj17a2VybmVsTmFtZTpWaSxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQse2F4aXM6cixleGNsdXNpdmU6cyxyZXZlcnNlOml9PW47cmV0dXJue3g6KCk9PntsZXQgbz1ETihbcl0sYS5yYW5rKSxsPVZtKGUscixzLCFpKTtyZXR1cm4gbyE9bnVsbCYmKGw9RGUobCxvKSksbH19fX0sVVY9e2tlcm5lbE5hbWU6VWksaW5wdXRzVG9TYXZlOltcInhcIixcImZpbHRlclwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0e2RpbGF0aW9uczphLHN0cmlkZXM6cixwYWQ6cyxkaW1Sb3VuZGluZ01vZGU6aX09bixvPWE9PW51bGw/WzEsMV06YTtBKHBzKG8pLCgpPT5gRXJyb3IgaW4gZ3JhZGllbnQgb2YgZGVwdGh3aXNlQ29udjJkTmF0aXZlOiBkaWxhdGlvbiByYXRlcyBncmVhdGVyIHRoYW4gMSBhcmUgbm90IHlldCBzdXBwb3J0ZWQuIEdvdCBkaWxhdGlvbnMgJyR7b30nYCk7bGV0W2wsdV09dDtyZXR1cm4gQShsLnJhbms9PT00LCgpPT5gRXJyb3IgaW4gZ3JhZGllbnQgb2YgZGVwdGh3aXNlQ29udjJkTmF0aXZlOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rICR7bC5yYW5rfS5gKSxBKHUucmFuaz09PTQsKCk9PmBFcnJvciBpbiBncmFkaWVudCBvZiBkZXB0aHdpc2VDb252MmROYXRpdmU6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rICR7dS5yYW5rfS5gKSxBKGwuc2hhcGVbM109PT11LnNoYXBlWzJdLCgpPT5gRXJyb3IgaW4gZ3JhZGllbnQgb2YgZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgKCR7bC5zaGFwZVszXX0pIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGZpbHRlciAke3Uuc2hhcGVbMl19LmApLEEoZHIocixvKSwoKT0+YEVycm9yIGluIGdyYWRpZW50IG9mIGRlcHRod2lzZUNvbnYyZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgIDEuIEdvdCBzdHJpZGVzICR7cn0gYW5kIGRpbGF0aW9ucyAnJHtvfScuYCksVG4oXCJkZXB0aHdpc2VDb252MmRcIixzLGkpLHt4OigpPT53VChsLnNoYXBlLGUsdSxyLHMsbyxpKSxmaWx0ZXI6KCk9PnZUKGwsZSx1LnNoYXBlLHIscyxvLGkpfX19LEdWPXtrZXJuZWxOYW1lOkdpLGlucHV0c1RvU2F2ZTpbXCJ4XCIsXCJmaWx0ZXJcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQscz17eDphLGZpbHRlcjpyLGR5OmV9LGk9e3g6YSxmaWx0ZXI6cixkeTplfTtyZXR1cm57eDooKT0+UC5ydW5LZXJuZWwoRGwscyxuKSxmaWx0ZXI6KCk9PlAucnVuS2VybmVsKFJsLGksbil9fX0sSFY9e2tlcm5lbE5hbWU6amksb3V0cHV0c1RvU2F2ZTpbITBdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQsYT17ZHk6ZSx5Om59O3JldHVybnt4OigpPT5QLnJ1bktlcm5lbChjdSxhKX19fSxqVj17a2VybmVsTmFtZTpxaSxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10LGE9eihkbih5dChwdChuKSkpLDIvTWF0aC5zcXJ0KE1hdGguUEkpKTtyZXR1cm57eDooKT0+eihlLGEpfX19LHFWPXtrZXJuZWxOYW1lOktpLG91dHB1dHNUb1NhdmU6WyEwXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KGUsbil9fX0sS1Y9e2tlcm5lbE5hbWU6aHUsaW5wdXRzVG9TYXZlOltcImlucHV0XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue2lucHV0OigpPT5XKGUsbi5zaGFwZSl9fX0sWFY9e2tlcm5lbE5hbWU6WGksaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihlLGRuKG4pKX19fSxZVj17a2VybmVsTmFtZTpZaSxncmFkRnVuYzplPT4oe3g6KCk9PnFlKGUpfSl9LFpWPXtrZXJuZWxOYW1lOlppLGlucHV0c1RvU2F2ZTpbXCJhXCIsXCJiXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W24sYV09dCxyPWN0KG4uc2hhcGUsYS5zaGFwZSk7cmV0dXJue2E6KCk9PntsZXQgcz1oZShlLHJlKGEsXCJmbG9hdDMyXCIpKSxpPUJ0KG4uc2hhcGUscik7cmV0dXJuIGkubGVuZ3RoPjA/VyhmZShzLGkpLG4uc2hhcGUpOnN9LGI6KCk9PntsZXQgcz16KGUscmUobixcImZsb2F0MzJcIikpLGk9QnQoYS5zaGFwZSxyKTtpLmxlbmd0aD4wJiYocz1XKGZlKHMsaSksYS5zaGFwZSkpO2xldCBvPXB0KGEpO3JldHVybiB5dChoZShzLHJlKG8sXCJmbG9hdDMyXCIpKSl9fX19LEpWPXtrZXJuZWxOYW1lOkppLGlucHV0c1RvU2F2ZTpbXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiLFwic2NhbGVcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldHt2YXJpYW5jZUVwc2lsb246YX09bixbcixzLGksb109dCxsPW89PW51bGw/eGUoMSk6byx1PUJ0KHMuc2hhcGUsci5zaGFwZSkscD1bXTtpZihzLnJhbms9PT0xKXtmb3IobGV0IGY9MDtmPHIuc2hhcGUubGVuZ3RoLTE7KytmKXAucHVzaChyLnNoYXBlW2ZdKTtwLnB1c2goMSl9bGV0IGQ9cGUocixzKSxjPXooZSxsKSxoPUptKFgoaSx4ZShhKSkpLG09eih6KHooaCxoKSxoKSx4ZSgtLjUpKTtyZXR1cm57eDooKT0+cy5yYW5rPT09MT9XKHooeihlLE9uKFcoaCxbMSwxLDEscy5zaGFwZVswXV0pLHApKSxsKSxyLnNoYXBlKTpXKHooeihlLGgpLGwpLHIuc2hhcGUpLG1lYW46KCk9PntsZXQgZj16KHooaCx4ZSgtMSkpLGMpO3JldHVybiBzLnJhbms9PT0xJiYoZj1mZShmLHUpKSxXKGYscy5zaGFwZSl9LHZhcmlhbmNlOigpPT57bGV0IGY9eih6KG0sZCksYyk7cmV0dXJuIHMucmFuaz09PTEmJihmPWZlKGYsdSkpLFcoZixzLnNoYXBlKX0sc2NhbGU6KCk9PntsZXQgZj16KGQsaCksZz16KGUsZik7cmV0dXJuIHMucmFuaz09PTEmJihnPWZlKGcsdSkpLFcoZyxzLnNoYXBlKX0sb2Zmc2V0OigpPT57bGV0IGY9ZTtyZXR1cm4gcy5yYW5rPT09MSYmKGY9ZmUoZix1KSksVyhmLHMuc2hhcGUpfX19fSxRVj17a2VybmVsTmFtZTpmdSxpbnB1dHNUb1NhdmU6W1wieFwiLFwiaW5kaWNlc1wiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2Escl09dCx7YXhpczpzLGJhdGNoRGltczppfT1uLG89QWEocyxhLnNoYXBlKVswXSxsPSh1LHAsZCk9PigpPT57bGV0IGM9dS5zaGFwZSxoPXAuc2l6ZSxtPWMuc2xpY2UoMCxvKSxmPW0ubGVuZ3RoLGc9Yy5zbGljZShzLGMubGVuZ3RoKS5zbGljZSgxKSxiPWcubGVuZ3RoLHk9dUkoMCxmKSx4PXVJKGYrMSxmKzErYiksdj1wSShbbSxbaF0sZ10pLEk9VyhkLHYpLE49VyhwLFtoXSksQz1wSShbW2ZdLHkseF0pLF89RGUoSSxDKSxGPXVmKF8sTix1LnNoYXBlW29dKSxEPXB3KEMpO3JldHVybiBGPURlKEYsRCksRn07aWYoaT09PTEpe2xldCB1PWEuc2hhcGVbMF0scD1hLnNwbGl0KHUsMCk7cmV0dXJue3g6KCk9PkF0KHAubWFwKChkLGMpPT5sKGQsci5zbGljZShjLDEpLGUuc2xpY2UoYywxKSkoKSkpLnJlc2hhcGUoYS5zaGFwZSksaW5kaWNlczooKT0+cn19ZWxzZSByZXR1cm57eDpsKGEscixlKSxpbmRpY2VzOigpPT5yfX19O2Z1bmN0aW9uIHVJKGUsdCl7bGV0IG49W107Zm9yKGxldCBhPWU7YTx0OysrYSluLnB1c2goYSk7cmV0dXJuIG59ZnVuY3Rpb24gcEkoZSl7bGV0IHQ9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pZm9yKGxldCBhPTA7YTxlW25dLmxlbmd0aDsrK2EpdC5wdXNoKGVbbl1bYV0pO3JldHVybiB0fXZhciBlVT17a2VybmVsTmFtZTpRaSxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQ7cmV0dXJue2E6KCk9PnFlKG4pLGI6KCk9PnFlKGEpfX19LHRVPXtrZXJuZWxOYW1lOmVvLGdyYWRGdW5jOmU9Pih7eDooKT0+cmUoZSxcImZsb2F0MzJcIil9KX0sblU9e2tlcm5lbE5hbWU6dG8sZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxhVT17a2VybmVsTmFtZTpubyxncmFkRnVuYzplPT4oe3g6KCk9PnFlKGUpfSl9LHJVPXtrZXJuZWxOYW1lOmFvLGdyYWRGdW5jOmU9Pih7eDooKT0+cWUoZSl9KX0sc1U9e2tlcm5lbE5hbWU6cm8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHthbHBoYTpyfT1uLHM9Q24oYSwwKTtyZXR1cm57eDooKT0+bm4ocyxlLHooZSxyKSl9fX0saVU9e2tlcm5lbE5hbWU6aW8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+aGUoZSxYKG4sMSkpfX19LG9VPXtrZXJuZWxOYW1lOnNvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmhlKGUscmUobixcImZsb2F0MzJcIikpfX19LGxVPXtrZXJuZWxOYW1lOnFTLGlucHV0c1RvU2F2ZTpbXSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtheGlzOnJ9PW47cmV0dXJue2xvZ2l0czooKT0+e2xldCBzPWRuKGEpO3JldHVybiBwZShlLHooZmUoZSxyLCEwKSxzKSl9fX19O2Z1bmN0aW9uIHVVKGUsdCxuLGE9NSxyPTEscz0xLGk9LjUpe2xldCBvPXt4OmUseTp0LGR5Om59LGw9e2RlcHRoUmFkaXVzOmEsYmlhczpyLGFscGhhOnMsYmV0YTppfTtyZXR1cm4gUC5ydW5LZXJuZWwoU3UsbyxsKX12YXIgcFU9TCh7bG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb25CYWNrcHJvcF86dVV9KSxjVT17a2VybmVsTmFtZTpvbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQse2RlcHRoUmFkaXVzOnMsYmlhczppLGFscGhhOm8sYmV0YTpsfT1uO3JldHVybnt4OigpPT5wVShhLHIsZSxzLGksbyxsKX19fTtmdW5jdGlvbiBpMihlLHQsbixhKXtyZXR1cm4gdC5yYW5rPG4ucmFuayYmKHQ9Vyh0LG1pKHQuc2hhcGUsYSkpKSxlLnJhbms8bi5yYW5rJiYoZT1XKGUsbWkoZS5zaGFwZSxhKSkpLHt4OigpPT56KGUscmUoSm4obix0KSxlLmR0eXBlKSl9fXZhciBjST17a2VybmVsTmFtZTpsbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldCBhPW4se3JlZHVjdGlvbkluZGljZXM6cn09YSxzPXRbMF0saT10WzFdLG89QWEocixzLnNoYXBlKSxsPWkyKGUsaSxzLG8pO3JldHVybnt4OigpPT5sLngoKX19fSxkVT17a2VybmVsTmFtZTp1byxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQ7cmV0dXJue2E6KCk9PnooZSxyZSgkcihuLGEpLFwiZmxvYXQzMlwiKSksYjooKT0+eihlLHJlKFBsKG4sYSksXCJmbG9hdDMyXCIpKX19fTtmdW5jdGlvbiBoVShlLHQsbixhLHIscyxpKXtsZXQgbz1FKGUsXCJkeVwiLFwibWF4UG9vbDNkR3JhZFwiKSxsPUUodCxcImlucHV0XCIsXCJtYXhQb29sM2RHcmFkXCIpLHU9RShuLFwib3V0cHV0XCIsXCJtYXhQb29sM2RHcmFkXCIpLHA9byxkPWwsYz11LGg9ITE7bC5yYW5rPT09NCYmKGg9ITAscD1XKG8sWzEsby5zaGFwZVswXSxvLnNoYXBlWzFdLG8uc2hhcGVbMl0sby5zaGFwZVszXV0pLGQ9VyhsLFsxLGwuc2hhcGVbMF0sbC5zaGFwZVsxXSxsLnNoYXBlWzJdLGwuc2hhcGVbM11dKSxjPVcodSxbMSx1LnNoYXBlWzBdLHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdXSkpLEEocC5yYW5rPT09NSwoKT0+YEVycm9yIGluIG1heFBvb2wzZEdyYWQ6IGR5IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayAke3AucmFua30uYCksQShkLnJhbms9PT01LCgpPT5gRXJyb3IgaW4gbWF4UG9vbDNkR3JhZDogaW5wdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rICR7ZC5yYW5rfS5gKSxBKGMucmFuaz09PTUsKCk9PmBFcnJvciBpbiBtYXhQb29sM2RHcmFkOiBvdXRwdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rICR7Yy5yYW5rfS5gKSxUbihcIm1heFBvb2wzZEdyYWRcIixzLGkpO2xldCBtPXtkeTpwLGlucHV0OmQsb3V0cHV0OmN9LGY9e2ZpbHRlclNpemU6YSxzdHJpZGVzOnIscGFkOnMsZGltUm91bmRpbmdNb2RlOml9LGc9UC5ydW5LZXJuZWwoQmMsbSxmKTtyZXR1cm4gaD9XKGcsW2cuc2hhcGVbMV0sZy5zaGFwZVsyXSxnLnNoYXBlWzNdLGcuc2hhcGVbNF1dKTpnfXZhciBtVT1MKHttYXhQb29sM2RHcmFkXzpoVX0pLGZVPXtrZXJuZWxOYW1lOk51LGlucHV0c1RvU2F2ZTpbXCJ4XCJdLG91dHB1dHNUb1NhdmU6WyEwXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2Escl09dCx7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkaW1Sb3VuZGluZ01vZGU6bH09bjtyZXR1cm57eDooKT0+bVUoZSxhLHIscyxpLG8sbCl9fX07ZnVuY3Rpb24gZ1UoZSx0LG4sYSxyLHMsaSl7bGV0IG89RShlLFwiZHlcIixcIm1heFBvb2xHcmFkXCIpLGw9RSh0LFwiaW5wdXRcIixcIm1heFBvb2xHcmFkXCIpLHU9RShuLFwib3V0cHV0XCIsXCJtYXhQb29sR3JhZFwiKTtBKGwucmFuaz09PW8ucmFuaywoKT0+YFJhbmsgb2YgaW5wdXQgKCR7bC5yYW5rfSkgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoJHtvLnJhbmt9KWApLEEoby5yYW5rPT09NCwoKT0+YEVycm9yIGluIG1heFBvb2xHcmFkOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtvLnJhbmt9LmApLEEobC5yYW5rPT09NCwoKT0+YEVycm9yIGluIG1heFBvb2xHcmFkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgJHtsLnJhbmt9LmApLFRuKFwibWF4UG9vbEdyYWRcIixzLGkpO2xldCBwPXtkeTpvLGlucHV0Omwsb3V0cHV0OnV9LGQ9e2ZpbHRlclNpemU6YSxzdHJpZGVzOnIscGFkOnMsZGltUm91bmRpbmdNb2RlOml9O3JldHVybiBQLnJ1bktlcm5lbChXYyxwLGQpfXZhciBiVT1MKHttYXhQb29sR3JhZF86Z1V9KSx5VT17a2VybmVsTmFtZTpwbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthLHJdPXQse2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm99PW47cmV0dXJue3g6KCk9PmJVKGUsYSxyLHMsaSxvKX19fSx4VT17a2VybmVsTmFtZTpjbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQse2F4aXM6cn09bixzPUFhKHIsYS5zaGFwZSksaT0kTihhLnNoYXBlLHMpWzFdLG89b3QoaSk7cmV0dXJue3g6KCk9PntsZXQgbD1hLnNoYXBlLnNsaWNlKCk7cy5mb3JFYWNoKHA9PntsW3BdPTF9KTtsZXQgdT1XKGUsbCk7cmV0dXJuIGhlKHoodSxQbihhLnNoYXBlLFwiZmxvYXQzMlwiKSksbyl9fX19LHZVPXtrZXJuZWxOYW1lOmhvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLG91dHB1dHNUb1NhdmU6WyEwXSxncmFkRnVuYzooZSx0LG4pPT57bGV0IGE9bix7YXhpczpyfT1hLFtzLGldPXQsbz1BYShyLHMuc2hhcGUpLGw9aTIoZSxpLHMsbyk7cmV0dXJue3g6KCk9PmwueCgpfX19LHdVPXtrZXJuZWxOYW1lOm1vLGlucHV0c1RvU2F2ZTpbXCJhXCIsXCJiXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W24sYV09dDtyZXR1cm57YTooKT0+eihlLHJlKENzKG4sYSksXCJmbG9hdDMyXCIpKSxiOigpPT56KGUscmUoQ24obixhKSxcImZsb2F0MzJcIikpfX19LGtVPXtrZXJuZWxOYW1lOmZvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXQgYT10WzBdLHtwYWRkaW5nczpyfT1uLHM9ci5tYXAoaT0+aVswXSk7cmV0dXJue3g6KCk9PlZlKGUscyxhLnNoYXBlKX19fSxJVT17a2VybmVsTmFtZTpnbyxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQscj1jdChuLnNoYXBlLGEuc2hhcGUpO3JldHVybnthOigpPT57bGV0IHM9QnQobi5zaGFwZSxyKTtyZXR1cm4gcy5sZW5ndGg+MD9XKGZlKGUscyksbi5zaGFwZSk6ZX0sYjooKT0+e2xldCBzPXooZSx5dCh0cChoZShuLGEpKSkpLGk9QnQoYS5zaGFwZSxyKTtyZXR1cm4gaS5sZW5ndGg+MD9XKGZlKHMsaSksYS5zaGFwZSk6c319fX0sU1U9e2tlcm5lbE5hbWU6Ym8saW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10LHI9Y3Qobi5zaGFwZSxhLnNoYXBlKTtyZXR1cm57YTooKT0+e2xldCBzPXooZSxyZShhLFwiZmxvYXQzMlwiKSksaT1CdChuLnNoYXBlLHIpO3JldHVybiBpLmxlbmd0aD4wP1coZmUocyxpKSxuLnNoYXBlKTpzfSxiOigpPT57bGV0IHM9eihlLHJlKG4sXCJmbG9hdDMyXCIpKSxpPUJ0KGEuc2hhcGUscik7cmV0dXJuIGkubGVuZ3RoPjA/VyhmZShzLGkpLGEuc2hhcGUpOnN9fX19LE5VPXtrZXJuZWxOYW1lOkN1LGdyYWRGdW5jOmU9Pih7eDooKT0+eXQoZSl9KX0sVFU9e2tlcm5lbE5hbWU6eW8saW5wdXRzVG9TYXZlOltcImluZGljZXNcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXQgbj10WzBdO3JldHVybntpbmRpY2VzOigpPT5JdChuLnNoYXBlLFwiZmxvYXQzMlwiKX19fSxDVT17a2VybmVsTmFtZTokdSxncmFkRnVuYzplPT4oe3g6KCk9PnFlKGUpfSl9LEVVPXtrZXJuZWxOYW1lOkR1LHNhdmVBbGxJbnB1dHM6ITAsZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldHtheGlzOmF9PW47cmV0dXJuIGR0KGUsYSkubWFwKHI9PigpPT5yKX19LGRJPXtrZXJuZWxOYW1lOnhvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQsbik9PntsZXQgYT10WzBdLHtwYWRkaW5nczpyfT1uLHM9ci5tYXAoaT0+aVswXSk7cmV0dXJue3g6KCk9PlZlKGUscyxhLnNoYXBlKX19fSxfVT17a2VybmVsTmFtZTp2byxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxvdXRwdXRzVG9TYXZlOlshMF0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhLHJdPXQscz1uLGk9YSxvPWN0KHMuc2hhcGUsaS5zaGFwZSk7cmV0dXJue2E6KCk9PntsZXQgbD1yZShpLFwiZmxvYXQzMlwiKSx1PXooZSx6KGwsdXIocyxwZShsLHhlKDEpKSkpKSxwPUJ0KHMuc2hhcGUsbyk7cmV0dXJuIHAubGVuZ3RoPjAmJih1PWZlKHUscCkpLFcodSxzLnNoYXBlKX0sYjooKT0+e2xldCBsPUNuKHMsMCksdT1ubihsLFFuKHMpLHFlKHMpKSxwPXooZSx6KHIsdSkpLGQ9QnQoaS5zaGFwZSxvKTtyZXR1cm4gZC5sZW5ndGg+MCYmKHA9ZmUocCxkKSksVyhwLGkuc2hhcGUpfX19fSxBVT17a2VybmVsTmFtZTp3byxpbnB1dHNUb1NhdmU6W1wieFwiLFwiYWxwaGFcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbixhXT10LHI9Q24obiwwKTtyZXR1cm57eDooKT0+bm4ocixlLHooZSxhKSksYWxwaGE6KCk9PntsZXQgcz1ubihyLHFlKGUpLHooZSxuKSksaT1CdChhLnNoYXBlLGUuc2hhcGUpO3JldHVybiBpLmxlbmd0aD4wJiYocz1mZShzLGkpKSxXKHMsYS5zaGFwZSl9fX19O2Z1bmN0aW9uIEZVKGUsdCxuKXtsZXQgYT1lLnNoYXBlLnNsaWNlKCk7YVtuXT0xO2xldCByPVcodCxhKSxzPXdjKGUsbiwhMCwhMSksaT13YyhlLG4sITAsITApLG89eihzLGkpO3JldHVybiB6KHIsbyl9ZnVuY3Rpb24gJFUoZSx0LG4pe2xldCBhPWUuc2hhcGUubGVuZ3RoLHI9YS1uLmxlbmd0aCxzPVQuZ2V0QXhlc1Blcm11dGF0aW9uKG4sYSksaT1lO3MhPW51bGwmJihpPURlKGUscykpO2xldCBvPWkuc2hhcGUuc2xpY2UoKSxsPW8uc3BsaWNlKGEtbi5sZW5ndGgsbi5sZW5ndGgpLnJlZHVjZSgoZCxjKT0+ZCpjLDEpO28ucHVzaChsKTtsZXQgdT1pLnJlc2hhcGUobykscD1GVSh1LHQscik7aWYocD1wLnJlc2hhcGUoaS5zaGFwZSkscyE9bnVsbCl7bGV0IGQ9VC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKHMpO3A9RGUocCxkKX1yZXR1cm4gcH12YXIgRFU9e2tlcm5lbE5hbWU6a28saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHtheGlzOnJ9PW4scz1bXTtyZXR1cm4gcj09bnVsbD9zPWEuc2hhcGUubWFwKChpLG8pPT5vKTp0eXBlb2Ygcj09XCJudW1iZXJcIj9zPVtyXTpzPXIse3g6KCk9PiRVKGEsZSxzKX19fSxSVT17a2VybmVsTmFtZTpIaSxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQscj1jdChuLnNoYXBlLGEuc2hhcGUpO3JldHVybnthOigpPT57bGV0IHM9aGUoZSxyZShhLFwiZmxvYXQzMlwiKSksaT1CdChuLnNoYXBlLHIpO3JldHVybiBpLmxlbmd0aD4wP1coZmUocyxpKSxuLnNoYXBlKTpzfSxiOigpPT57bGV0IHM9eihlLHJlKG4sXCJmbG9hdDMyXCIpKSxpPUJ0KGEuc2hhcGUscik7aS5sZW5ndGg+MCYmKHM9VyhmZShzLGkpLGEuc2hhcGUpKTtsZXQgbz1wdChhKTtyZXR1cm4geXQoaGUocyxyZShvLFwiZmxvYXQzMlwiKSkpfX19fSxNVT17a2VybmVsTmFtZTpJbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT5oZShlLHl0KHB0KG4pKSl9fX0sT1U9e2tlcm5lbE5hbWU6Q28saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dCxhPXooQ3Mobiw2KSxqbyhuKSk7cmV0dXJue3g6KCk9PnooZSxyZShhLFwiZmxvYXQzMlwiKSl9fX0sUFU9e2tlcm5lbE5hbWU6U28saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+eihlLHJlKGpvKG4pLFwiZmxvYXQzMlwiKSl9fX0sTFU9e2tlcm5lbE5hbWU6UnUsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+VyhlLG4uc2hhcGUpfX19LHpVPXtrZXJuZWxOYW1lOlRvLGlucHV0c1RvU2F2ZTpbXCJpbWFnZXNcIl0sZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldFthXT10LHI9e2R5OmUsaW1hZ2VzOmF9O3JldHVybntpbWFnZXM6KCk9PlAucnVuS2VybmVsKE91LHIsbil9fX0sV1U9e2tlcm5lbE5hbWU6Tm8saW5wdXRzVG9TYXZlOltcImltYWdlc1wiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQscj17ZHk6ZSxpbWFnZXM6YX07cmV0dXJue2ltYWdlczooKT0+UC5ydW5LZXJuZWwoTXUscixuKX19fSxCVT17a2VybmVsTmFtZTpFbyxncmFkRnVuYzooZSx0LG4pPT57bGV0e2RpbXM6YX09bixyPUFhKGEsZS5zaGFwZSk7cmV0dXJue3g6KCk9PmJhKGUscil9fX0sVlU9e2tlcm5lbE5hbWU6X28sZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxVVT17a2VybmVsTmFtZTpBbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT55dChoZShlLHoodXIobiwxLjUpLDIpKSl9fX0sR1U9e2tlcm5lbE5hbWU6V3UsaW5wdXRzVG9TYXZlOltcImNvbmRpdGlvblwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybntjb25kaXRpb246KCk9PnJlKHFlKG4pLFwiZmxvYXQzMlwiKSx0OigpPT56KGUscmUobixlLmR0eXBlKSksZTooKT0+eihlLHJlKGRkKG4pLGUuZHR5cGUpKX19fSxIVT17a2VybmVsTmFtZTpGbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT57bGV0IGE9Q24obix4ZSgwKSkscj14ZShuMikscz14ZShhMiksaT16KGUscyksbz16KHooZSxyKSxkbihyZShuLFwiZmxvYXQzMlwiKSkpO3JldHVybiBubihhLGksbyl9fX19LGpVPXtrZXJuZWxOYW1lOk1vLG91dHB1dHNUb1NhdmU6WyEwXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KGUseihuLHBlKHhlKDEpLG4pKSl9fX0scVU9e2tlcm5lbE5hbWU6Um8sZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxLVT17a2VybmVsTmFtZTokbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KG9kKHJlKG4sXCJmbG9hdDMyXCIpKSxlKX19fSxYVT17a2VybmVsTmFtZTpEbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KEJtKHJlKG4sXCJmbG9hdDMyXCIpKSxlKX19fSxZVT17a2VybmVsTmFtZTpCdSxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQse2JlZ2luOnIsc2l6ZTpzfT1uLGk9YS5zaGFwZSxbbyxsXT1lMihhLHIscyksdT1bXTtmb3IobGV0IHA9MDtwPGUucmFuaztwKyspdS5wdXNoKFtvW3BdLGlbcF0tb1twXS1sW3BdXSk7cmV0dXJue3g6KCk9PnhhKGUsdSl9fX0sWlU9e2tlcm5lbE5hbWU6em8sb3V0cHV0c1RvU2F2ZTpbITBdLGdyYWRGdW5jOihlLHQsbik9PntsZXRbYV09dCx7ZGltOnJ9PW4scz0hMCxpPXooZSxhKTtyZXR1cm57bG9naXRzOigpPT5wZShpLHooZmUoaSxbcl0scyksYSkpfX19LEpVPXtrZXJuZWxOYW1lOk9vLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PnooZSxoYShuKSl9fX0saEk9e2tlcm5lbE5hbWU6VnUsZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldHtibG9ja1NoYXBlOmEscGFkZGluZ3M6cn09bjtyZXR1cm57eDooKT0+aWQoZSxhLHIpfX19LG1JPXtrZXJuZWxOYW1lOlV1LGdyYWRGdW5jOihlLHQsbik9PntsZXR7YXhpczphfT1uO3JldHVybnt4OigpPT5ldChlLGEpfX19LFFVPXtrZXJuZWxOYW1lOlBvLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmhlKGUseihybihyZShuLFwiZmxvYXQzMlwiKSksMikpfX19LGVHPXtrZXJuZWxOYW1lOnFjLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PnooZSx6KHJlKG4sXCJmbG9hdDMyXCIpLDIpKX19fSx0Rz17a2VybmVsTmFtZTpXbyxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQscj14ZSgyKTtyZXR1cm57YTooKT0+eihlLHoocixwZShuLGEpKSksYjooKT0+eihlLHoocixwZShhLG4pKSl9fX0sbkc9e2tlcm5lbE5hbWU6SXMsZ3JhZEZ1bmM6ZT0+KHt4OigpPT5xZShlKX0pfSxhRz17a2VybmVsTmFtZTpCbyxpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzooZSx0KT0+e2xldFtuLGFdPXQscj1jdChuLnNoYXBlLGEuc2hhcGUpO3JldHVybnthOigpPT57bGV0IHM9ZSxpPUJ0KG4uc2hhcGUscik7cmV0dXJuIGkubGVuZ3RoPjAmJihzPWZlKHMsaSkpLFcocyxuLnNoYXBlKX0sYjooKT0+e2xldCBzPWUsaT1CdChhLnNoYXBlLHIpO3JldHVybiBpLmxlbmd0aD4wJiYocz1mZShzLGkpKSxXKHl0KHMpLGEuc2hhcGUpfX19fSxyRz17a2VybmVsTmFtZTpMbyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQscj1hLnNoYXBlLnNsaWNlKCkse2F4aXM6c309bjtBYShzLGEuc2hhcGUpLmZvckVhY2gobD0+e3JbbF09MX0pO2xldCBpPVcoZSxyKSxvPXooaSxQbihhLnNoYXBlLFwiZmxvYXQzMlwiKSk7cmV0dXJue3g6KCk9Pm99fX0sc0c9e2tlcm5lbE5hbWU6Vm8saW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6KGUsdCk9PntsZXRbbl09dDtyZXR1cm57eDooKT0+aGUoZSxwdChvZChuKSkpfX19LGlHPXtrZXJuZWxOYW1lOlVvLG91dHB1dHNUb1NhdmU6WyEwXSxncmFkRnVuYzooZSx0KT0+e2xldFtuXT10O3JldHVybnt4OigpPT56KHBlKHhlKDEpLHB0KG4pKSxlKX19fSxvRz17a2VybmVsTmFtZTprcyxpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzooZSx0LG4pPT57bGV0W2FdPXQse3JlcHM6cn09bjtyZXR1cm57eDooKT0+e2xldCBzPXFlKGEpO2lmKGEucmFuaz09PTEpZm9yKGxldCBpPTA7aTxyWzBdOysraSlzPVgocyxWZShlLFtpKmEuc2hhcGVbMF1dLFthLnNoYXBlWzBdXSkpO2Vsc2UgaWYoYS5yYW5rPT09Milmb3IobGV0IGk9MDtpPHJbMF07KytpKWZvcihsZXQgbz0wO288clsxXTsrK28pcz1YKHMsVmUoZSxbaSphLnNoYXBlWzBdLG8qYS5zaGFwZVsxXV0sW2Euc2hhcGVbMF0sYS5zaGFwZVsxXV0pKTtlbHNlIGlmKGEucmFuaz09PTMpZm9yKGxldCBpPTA7aTxyWzBdOysraSlmb3IobGV0IG89MDtvPHJbMV07KytvKWZvcihsZXQgbD0wO2w8clsyXTsrK2wpcz1YKHMsVmUoZSxbaSphLnNoYXBlWzBdLG8qYS5zaGFwZVsxXSxsKmEuc2hhcGVbMl1dLFthLnNoYXBlWzBdLGEuc2hhcGVbMV0sYS5zaGFwZVsyXV0pKTtlbHNlIGlmKGEucmFuaz09PTQpZm9yKGxldCBpPTA7aTxyWzBdOysraSlmb3IobGV0IG89MDtvPHJbMV07KytvKWZvcihsZXQgbD0wO2w8clsyXTsrK2wpZm9yKGxldCB1PTA7dTxyWzNdOysrdSlzPVgocyxWZShlLFtpKmEuc2hhcGVbMF0sbyphLnNoYXBlWzFdLGwqYS5zaGFwZVsyXSx1KmEuc2hhcGVbM11dLFthLnNoYXBlWzBdLGEuc2hhcGVbMV0sYS5zaGFwZVsyXSxhLnNoYXBlWzNdXSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBHcmFkaWVudCBmb3IgdGlsZSBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciByYW5rLSR7YS5yYW5rfSB0ZW5zb3JzIHlldC5gKTtyZXR1cm4gc319fX0sbEc9e2tlcm5lbE5hbWU6Q3IsZ3JhZEZ1bmM6KGUsdCxuKT0+e2xldCBhPW4se3Blcm06cn09YSxzPXB3KHIpO3JldHVybnt4OigpPT5EZShlLHMpfX19LHVHPXtrZXJuZWxOYW1lOlh1LGdyYWRGdW5jOihlLHQsbik9PntsZXQgYT1uLHtheGlzOnJ9PWE7cmV0dXJue3ZhbHVlOigpPT5BdChlLHIpfX19LHBHPXtrZXJuZWxOYW1lOlFjLGlucHV0c1RvU2F2ZTpbXCJzZWdtZW50SWRzXCJdLGdyYWRGdW5jOihlLHQpPT57bGV0W25dPXQ7cmV0dXJue3g6KCk9PmNHKGUsbil9fX07ZnVuY3Rpb24gY0coZSx0KXtsZXQgbj1ocih0LHFlKHQpKSxhPW5wKGUsbikscj0kcih0LHhlKDAsXCJpbnQzMlwiKSkscz1hLnJhbmstci5yYW5rO2ZvcihsZXQgbz0wO288czsrK28pcj1HdChyLG8rMSk7cj1fYShyLFBuKGEuc2hhcGUsXCJib29sXCIpKTtsZXQgaT1xZShhKTtyZXR1cm4gbm4ocixhLGkpfXZhciBkRz17a2VybmVsTmFtZTpZdSxncmFkRnVuYzplPT4oe3g6KCk9PnFlKGUpfSl9LGhHPVtzMixwVixjVixkVixoVixtVixmVixnVixiVix5Vix4Vix2VixJVixUVixDVixFVixfVixBVixGViwkVixEVixSVixPVixNVix6VixXVixCVixWVixVVixHVixSVSxIVixqVixxVixLVixYVixaVixZVixKVixRVixlVSx0VSxuVSxhVSxyVSxzVSxpVSxvVSxsVSxjVSxjSSxjSSxkVSxmVSx5VSx4VSx2VSx3VSxrVSxJVSxTVSxOVSxUVSxDVSxFVSxkSSxkSSxfVSxBVSxEVSxNVSxPVSxQVSxMVSx6VSxXVSxCVSxWVSxVVSxHVSxIVSxqVSxxVSxLVSxYVSxZVSxaVSxKVSxoSSxoSSxtSSxtSSxRVSx0RyxlRyxuRyxhRyxyRyxzRyxpRyxvRyxsRyx1RyxwRyxkR107Zm9yKGxldCBlIG9mIGhHKUtTKGUpO1EoKS5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksTHQodGhpcyl9O1EoKS5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFB2KHRoaXMpfTtRKCkucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksTHYodGhpcyl9O1EoKS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFgodGhpcyxlKX07USgpLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxMbSh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseWModGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkaSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx6dih0aGlzLGUpfTtRKCkucHJvdG90eXBlLmFzU2NhbGFyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQSh0aGlzLnNpemU9PT0xLCgpPT5cIlRoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuXCIpLFcodGhpcyxbXSl9O1EoKS5wcm90b3R5cGUuYXNUeXBlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHJlKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuYXMxRD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFcodGhpcyxbdGhpcy5zaXplXSl9O1EoKS5wcm90b3R5cGUuYXMyRD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFcodGhpcyxbZSx0XSl9O1EoKS5wcm90b3R5cGUuYXMzRD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVyh0aGlzLFtlLHQsbl0pfTtRKCkucHJvdG90eXBlLmFzNEQ9ZnVuY3Rpb24oZSx0LG4sYSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVyh0aGlzLFtlLHQsbixhXSl9O1EoKS5wcm90b3R5cGUuYXM1RD1mdW5jdGlvbihlLHQsbixhLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFcodGhpcyxbZSx0LG4sYSxyXSl9O1EoKS5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFd2KHRoaXMpfTtRKCkucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQnYodGhpcyl9O1EoKS5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFZ2KHRoaXMpfTtRKCkucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFV2KHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxHdih0aGlzKX07USgpLnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKGUsdCxuLGEpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHlhKHRoaXMsZSx0LG4sYSl9O1EoKS5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxpZCh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUuYmF0Y2hOb3JtPWZ1bmN0aW9uKGUsdCxuLGEscil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksTnModGhpcyxlLHQsbixhLHIpfTtRKCkucHJvdG90eXBlLmJyb2FkY2FzdFRvPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGFpKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxyZSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxadih0aGlzKX07USgpLnByb3RvdHlwZS5jbGlwQnlWYWx1ZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGFuKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlIGluc3RhbmNlb2YgQ2UmJihlPVtlXSksZXQoW3RoaXMsLi4uZV0sdCl9O1EoKS5wcm90b3R5cGUuY29udjFkPWZ1bmN0aW9uKGUsdCxuLGEscixzKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx6bSh0aGlzLGUsdCxuLGEscixzKX07USgpLnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2U9ZnVuY3Rpb24oZSx0LG4sYSxyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxXbSh0aGlzLGUsdCxuLGEscil9O1EoKS5wcm90b3R5cGUuY29udjJkPWZ1bmN0aW9uKGUsdCxuLGEscixzKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSwkdCh0aGlzLGUsdCxuLGEscixzKX07USgpLnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxvZCh0aGlzKX07USgpLnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQm0odGhpcyl9O1EoKS5wcm90b3R5cGUuY3VtcHJvZD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksd2ModGhpcyxlLHQsbil9O1EoKS5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxWbSh0aGlzLGUsdCxuKX07USgpLnByb3RvdHlwZS5kZXB0aFRvU3BhY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxzdyh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJkPWZ1bmN0aW9uKGUsdCxuLGEscixzKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxUcyh0aGlzLGUsdCxuLGEscixzKX07USgpLnByb3RvdHlwZS5kaWxhdGlvbjJkPWZ1bmN0aW9uKGUsdCxuLGEscil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksaXcodGhpcyxlLHQsbixhLHIpfTtRKCkucHJvdG90eXBlLmRpdk5vTmFuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG93KHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGhlKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuZG90PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGx3KHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksUXUodGhpcyl9O1EoKS5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksSm4odGhpcyxlKX07USgpLnByb3RvdHlwZS5lcmY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxVbSh0aGlzKX07USgpLnByb3RvdHlwZS5ldWNsaWRlYW5Ob3JtPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksY3codGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLmV4cD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGRuKHRoaXMpfTtRKCkucHJvdG90eXBlLmV4cGFuZERpbXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksR3QodGhpcyxlKX07USgpLnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGR3KHRoaXMpfTtRKCkucHJvdG90eXBlLmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGJkKHRoaXMpfTtRKCkucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxXKHRoaXMsW3RoaXMuc2l6ZV0pfTtRKCkucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdHAodGhpcyl9O1EoKS5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksUG0odGhpcyxlKX07USgpLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG5wKHRoaXMsZSx0LG4pfTtRKCkucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSwkcih0aGlzLGUpfTtRKCkucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQ24odGhpcyxlKX07USgpLnByb3RvdHlwZS5pZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQmwodGhpcyl9O1EoKS5wcm90b3R5cGUuaXJmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxhZih0aGlzKX07USgpLnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGh3KHRoaXMpfTtRKCkucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksbXcodGhpcyl9O1EoKS5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxmdyh0aGlzKX07USgpLnByb3RvdHlwZS5sZWFreVJlbHU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdWQodGhpcyxlKX07USgpLnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQ3ModGhpcyxlKX07USgpLnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFBsKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb249ZnVuY3Rpb24oZSx0LG4sYSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZ3codGhpcyxlLHQsbixhKX07USgpLnByb3RvdHlwZS5sb2dTaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksYncodGhpcyl9O1EoKS5wcm90b3R5cGUubG9nU29mdG1heD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxqbSh0aGlzLGUpfTtRKCkucHJvdG90eXBlLmxvZ1N1bUV4cD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGNkKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxRbih0aGlzKX07USgpLnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHBkKHRoaXMpfTtRKCkucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksX2EodGhpcyxlKX07USgpLnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZGQodGhpcyl9O1EoKS5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHFtKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUubG9naWNhbFhvcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx5dyh0aGlzLGUpfTtRKCkucHJvdG90eXBlLm1hdE11bD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksJGUodGhpcyxlLHQsbil9O1EoKS5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbihlLHQsbixhKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxEdCh0aGlzLGUsdCxuLGEpfTtRKCkucHJvdG90eXBlLm1heD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG1hKHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGhyKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUubWVhbj1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEN0KHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5taW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxPbCh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxkcyh0aGlzLGUpfTtRKCkucHJvdG90eXBlLm1pcnJvclBhZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHZ3KHRoaXMsZSx0KX07USgpLnByb3RvdHlwZS5tb2Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksd3codGhpcyxlKX07USgpLnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseih0aGlzLGUpfTtRKCkucHJvdG90eXBlLm5lZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHl0KHRoaXMpfTtRKCkucHJvdG90eXBlLm5vcm09ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGVwKHRoaXMsZSx0LG4pfTtRKCkucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGZpKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKGUsdD0xLG49MCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksTGwodGhpcyxlLHQsbil9O1EoKS5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlYSh0aGlzKX07USgpLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4YSh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUucG9vbD1mdW5jdGlvbihlLHQsbixhLHIscyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksa3codGhpcyxlLHQsbixhLHIscyl9O1EoKS5wcm90b3R5cGUucG93PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHVyKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUucHJlbHU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZmQodGhpcyxlKX07USgpLnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksSXcodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnJlY2lwcm9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxFdyh0aGlzKX07USgpLnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksS2UodGhpcyl9O1EoKS5wcm90b3R5cGUucmVsdTY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxZbSh0aGlzKX07USgpLnByb3RvdHlwZS5yZXNoYXBlQXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVyh0aGlzLGUuc2hhcGUpfTtRKCkucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVyh0aGlzLGUpfTtRKCkucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxDVCh0aGlzLGUsdCxuKX07USgpLnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEVUKHRoaXMsZSx0LG4pfTtRKCkucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksYmEodGhpcyxlKX07USgpLnByb3RvdHlwZS5yZmZ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseWQodGhpcyl9O1EoKS5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxabSh0aGlzKX07USgpLnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEptKHRoaXMpfTtRKCkucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxRbSh0aGlzKX07USgpLnByb3RvdHlwZS5zZXBhcmFibGVDb252MmQ9ZnVuY3Rpb24oZSx0LG4sYSxyLHMpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLF9zKHRoaXMsZSx0LG4sYSxyLHMpfTtRKCkucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxoYSh0aGlzKX07USgpLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksX3codGhpcyl9O1EoKS5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZWYodGhpcyl9O1EoKS5wcm90b3R5cGUuc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRmKHRoaXMpfTtRKCkucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksVmUodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnNvZnRtYXg9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscWEodGhpcyxlKX07USgpLnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEdvKHRoaXMpfTtRKCkucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksbWQodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksTG4odGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxybih0aGlzKX07USgpLnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxwdCh0aGlzKX07USgpLnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxyZih0aGlzLGUpfTtRKCkucHJvdG90eXBlLnNxdWVlemU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksQXModGhpcyxlKX07USgpLnByb3RvdHlwZS5zdGFjaz1mdW5jdGlvbihlLHQpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7bGV0IG49ZSBpbnN0YW5jZW9mIENlP1t0aGlzLGVdOlt0aGlzLC4uLmVdO3JldHVybiBBdChuLHQpfTtRKCkucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksam8odGhpcyxlKX07USgpLnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24oZSx0LG4sYSxyLHMsaSxvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxBdyh0aGlzLGUsdCxuLGEscixzLGksbyl9O1EoKS5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHBlKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZmUodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEZ3KHRoaXMpfTtRKCkucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxjcyh0aGlzKX07USgpLnByb3RvdHlwZS50aWxlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLE9uKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUudG9Cb29sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscmUodGhpcyxcImJvb2xcIil9O1EoKS5wcm90b3R5cGUudG9GbG9hdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHJlKHRoaXMsXCJmbG9hdDMyXCIpfTtRKCkucHJvdG90eXBlLnRvSW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscmUodGhpcyxcImludDMyXCIpfTtRKCkucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxEdyh0aGlzLGUsdCl9O1EoKS5wcm90b3R5cGUudHJhbnNwb3NlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLERlKHRoaXMsZSl9O1EoKS5wcm90b3R5cGUudW5pcXVlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFJ3KHRoaXMsZSl9O1EoKS5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdWYodGhpcyxlLHQpfTtRKCkucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZHQodGhpcyxlKX07USgpLnByb3RvdHlwZS53aGVyZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG5uKGUsdGhpcyx0KX07USgpLnByb3RvdHlwZS56ZXJvc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxxZSh0aGlzKX07dmFyIFhyPWNsYXNzIG8yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCl7c3VwZXIodCksT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsbzIucHJvdG90eXBlKX19LGFyPWNsYXNzIGwyIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCl7c3VwZXIodCksT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsbDIucHJvdG90eXBlKX19LFY9Y2xhc3MgdTIgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSxPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyx1Mi5wcm90b3R5cGUpfX0semU9Y2xhc3MgcDIgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSxPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxwMi5wcm90b3R5cGUpfX0sbUc9Y2xhc3MgYzIgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSxPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxjMi5wcm90b3R5cGUpfX0sZDI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5tYXhFbnRyaWVzPWV8fDEwMCx0aGlzLmNhY2hlPW5ldyBNYXB9Z2V0KGUpe2xldCB0O3JldHVybiB0aGlzLmNhY2hlLmhhcyhlKSYmKHQ9dGhpcy5jYWNoZS5nZXQoZSksdGhpcy5jYWNoZS5kZWxldGUoZSksdGhpcy5jYWNoZS5zZXQoZSx0KSksdH1wdXQoZSx0KXtpZih0aGlzLmNhY2hlLmhhcyhlKSl0aGlzLmNhY2hlLmRlbGV0ZShlKTtlbHNlIGlmKHRoaXMuY2FjaGUuc2l6ZT49dGhpcy5tYXhFbnRyaWVzKXtsZXQgbj10aGlzLmNhY2hlLmtleXMoKS5uZXh0KCkudmFsdWU7dGhpcy5jYWNoZS5kZWxldGUobil9dGhpcy5jYWNoZS5zZXQoZSx0KX1nZXRNYXhFbnRyaWVzKCl7cmV0dXJuIHRoaXMubWF4RW50cmllc31zZXRNYXhFbnRyaWVzKGUpe2lmKGU8MCl0aHJvdyBuZXcgRXJyb3IoYFRoZSBtYXhFbnRyaWVzIG9mIExSVSBjYWNoZXMgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7ZX0uYCk7aWYodGhpcy5tYXhFbnRyaWVzPmUpZm9yKGxldCB0PTA7dDx0aGlzLm1heEVudHJpZXMtZTt0Kyspe2xldCBuPXRoaXMuY2FjaGUua2V5cygpLm5leHQoKS52YWx1ZTt0aGlzLmNhY2hlLmRlbGV0ZShuKX10aGlzLm1heEVudHJpZXM9ZX19O2Z1bmN0aW9uIGJpKGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSl7bGV0IG49W107Zm9yKGxldCBhPTA7YTx0O2ErKyluPW4uY29uY2F0KGUpO3JldHVybiBufWVsc2V7bGV0IG49bmV3IEFycmF5KHQpO3JldHVybiBuLmZpbGwoZSksbn19ZnVuY3Rpb24gdHIoZSx0KXtpZighZSl0aHJvdyBuZXcgbUcodCl9ZnVuY3Rpb24gZkkoZSx0KXtsZXQgbj0wO2ZvcihsZXQgYSBvZiBlKWE9PT10JiZuKys7cmV0dXJuIG59ZnVuY3Rpb24gTW4oZSl7cmV0dXJuIGUubGVuZ3RoPT09MT9lWzBdOmV9ZnVuY3Rpb24gaXQoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTpbZV19ZnVuY3Rpb24gSXIoZSl7bGV0IHQ9ZS5yZXBsYWNlKC8oLikoW0EtWl1bYS16MC05XSspL2csXCIkMV8kMlwiKS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLFwiJDFfJDJcIikudG9Mb3dlckNhc2UoKTtyZXR1cm4gdFswXSE9PVwiX1wiP3Q6XCJwcml2YXRlXCIrdH1mdW5jdGlvbiBKcyhlKXtyZXR1cm4gZS5sZW5ndGg8PTF8fGUuaW5kZXhPZihcIl9cIik9PT0tMT9lOmUucmVwbGFjZSgvW19dKyhcXHd8JCkvZywodCxuKT0+bi50b1VwcGVyQ2FzZSgpKX12YXIgU2E9e307ZnVuY3Rpb24gUXcoZSl7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtsZXQgdD17fTtyZXR1cm4gdC5jbGFzc05hbWU9ZS5nZXRDbGFzc05hbWUoKSx0LmNvbmZpZz1lLmdldENvbmZpZygpLHR9ZnVuY3Rpb24gengoZSl7aWYoIShlPT1udWxsfHx0eXBlb2YgZSE9XCJvYmplY3RcIikpaWYoQXJyYXkuaXNBcnJheShlKSllLmZvckVhY2godD0+engodCkpO2Vsc2V7bGV0IHQ9T2JqZWN0LmtleXMoZSk7Zm9yKGxldCBuIG9mIHQpe2xldCBhPWVbbl07YSE9bnVsbCYmdHlwZW9mIGE9PVwib2JqZWN0XCImJighQXJyYXkuaXNBcnJheShhKSYmYS50eXBlPT09XCJuZGFycmF5XCImJnR5cGVvZiBhLnZhbHVlPT1cIm51bWJlclwiP2Vbbl09YS52YWx1ZTp6eChhKSl9fX1mdW5jdGlvbiB2ZChlLHQ9e30sbj17fSxhPVwib2JqZWN0XCIscj0hMSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2xldCBzPWUsaTtpZihzIGluIG4paT1uW3NdO2Vsc2UgaWYocyBpbiBTYSlpPVNhW3NdO2Vsc2UgaWYoaT10W3NdLGk9PW51bGwpdGhyb3cgbmV3IFYoYFVua25vd24gJHthfTogJHtlfS4gVGhpcyBtYXkgYmUgZHVlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XG4xLiBUaGUgJHthfSBpcyBkZWZpbmVkIGluIFB5dGhvbiwgaW4gd2hpY2ggY2FzZSBpdCBuZWVkcyB0byBiZSBwb3J0ZWQgdG8gVGVuc29yRmxvdy5qcyBvciB5b3VyIEphdmFTY3JpcHQgY29kZS5cbjIuIFRoZSBjdXN0b20gJHthfSBpcyBkZWZpbmVkIGluIEphdmFTY3JpcHQsIGJ1dCBpcyBub3QgcmVnaXN0ZXJlZCBwcm9wZXJseSB3aXRoIHRmLnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcygpLmApO3JldHVybiBpfWVsc2V7bGV0IHM9ZTtpZihzLmNsYXNzTmFtZT09bnVsbHx8cy5jb25maWc9PW51bGwpdGhyb3cgbmV3IFYoYCR7YX06IEltcHJvcGVyIGNvbmZpZyBmb3JtYXQ6ICR7SlNPTi5zdHJpbmdpZnkocyl9LlxuJ2NsYXNzTmFtZScgYW5kICdjb25maWcnIG11c3Qgc2V0LmApO2xldCBpPXMuY2xhc3NOYW1lLG8sbDtpZihpIGluIG4/W28sbF09bltpXTppIGluIFNhP1tvLGxdPVNhLmNsYXNzTmFtZTppIGluIHQmJihbbyxsXT10W2ldKSxvPT1udWxsKXRocm93IG5ldyBWKGBVbmtub3duICR7YX06ICR7aX0uIFRoaXMgbWF5IGJlIGR1ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxuMS4gVGhlICR7YX0gaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGNhc2UgaXQgbmVlZHMgdG8gYmUgcG9ydGVkIHRvIFRlbnNvckZsb3cuanMgb3IgeW91ciBKYXZhU2NyaXB0IGNvZGUuXG4yLiBUaGUgY3VzdG9tICR7YX0gaXMgZGVmaW5lZCBpbiBKYXZhU2NyaXB0LCBidXQgaXMgbm90IHJlZ2lzdGVyZWQgcHJvcGVybHkgd2l0aCB0Zi5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoKS5gKTtpZihsIT1udWxsKXtsZXQgdT17fTtmb3IobGV0IGggb2YgT2JqZWN0LmtleXMoU2EpKXVbaF09U2FbaF07Zm9yKGxldCBoIG9mIE9iamVjdC5rZXlzKG4pKXVbaF09bltoXTtsZXQgcD1zLmNvbmZpZztwLmN1c3RvbU9iamVjdHM9dTtsZXQgZD1PYmplY3QuYXNzaWduKHt9LFNhKTtmb3IobGV0IGggb2YgT2JqZWN0LmtleXMobikpU2FbaF09bltoXTt6eChzLmNvbmZpZyk7bGV0IGM9bChvLHMuY29uZmlnLG4scik7cmV0dXJuIFNhPU9iamVjdC5hc3NpZ24oe30sZCksY31lbHNle2xldCB1PU9iamVjdC5hc3NpZ24oe30sU2EpO2ZvcihsZXQgZCBvZiBPYmplY3Qua2V5cyhuKSlTYVtkXT1uW2RdO2xldCBwPW5ldyBvKHMuY29uZmlnKTtyZXR1cm4gU2E9T2JqZWN0LmFzc2lnbih7fSx1KSxwfX19ZnVuY3Rpb24gZkcoZSx0KXtyZXR1cm4gZTx0Py0xOmU+dD8xOjB9ZnVuY3Rpb24gd2goZSx0KXtyZXR1cm4tMSpmRyhlLHQpfWZ1bmN0aW9uIGFzKGUpe2lmKGU9PW51bGwpcmV0dXJuIGU7bGV0IHQ9W107Zm9yKGxldCBuIG9mIGUpdC5pbmRleE9mKG4pPT09LTEmJnQucHVzaChuKTtyZXR1cm4gdH1mdW5jdGlvbiBnRyhlKXtpZihlPT1udWxsKXRocm93IG5ldyBWKGBJbnZhbGlkIHZhbHVlIGluIG9iajogJHtKU09OLnN0cmluZ2lmeShlKX1gKTtmb3IobGV0IHQgaW4gZSlpZihlLmhhc093blByb3BlcnR5KHQpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEtvKGUsdCxuKXtpZihuIT1udWxsJiZlLmluZGV4T2Yobik8MCl0aHJvdyBuZXcgVihgJHtufSBpcyBub3QgYSB2YWxpZCAke3R9LiAgVmFsaWQgdmFsdWVzIGFyZSAke2V9IG9yIG51bGwvdW5kZWZpbmVkLmApfWZ1bmN0aW9uIGUwKGUsdCxuPTAsYT0xLzApe3JldHVybiB0cihuPj0wKSx0cihhPj1uKSxBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD49biYmZS5sZW5ndGg8PWEmJmUuZXZlcnkocj0+dHlwZW9mIHI9PT10KX1mdW5jdGlvbiB0bihlLHQpe0FycmF5LmlzQXJyYXkoZSk/KHcuYXNzZXJ0KGUubGVuZ3RoPjAsKCk9PmAke3R9IGlzIHVuZXhwZWN0ZWRseSBhbiBlbXB0eSBhcnJheS5gKSxlLmZvckVhY2goKG4sYSk9PnRuKG4sYGVsZW1lbnQgJHthKzF9IG9mICR7dH1gKSkpOncuYXNzZXJ0KE51bWJlci5pc0ludGVnZXIoZSkmJmU+MCwoKT0+YEV4cGVjdGVkICR7dH0gdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290ICR7aDIoZSl9LmApfWZ1bmN0aW9uIGgyKGUpe3JldHVybiBlPT09bnVsbD9cIm51bGxcIjpBcnJheS5pc0FycmF5KGUpP1wiW1wiK2UubWFwKHQ9PmgyKHQpKS5qb2luKFwiLFwiKStcIl1cIjp0eXBlb2YgZT09XCJzdHJpbmdcIj9gXCIke2V9XCJgOmAke2V9YH1mdW5jdGlvbiBiRyhlLHQsbil7bGV0IGE9biE9bnVsbD9uKCk6dy5ub3coKSxyO3JldHVybiguLi5zKT0+e2xldCBpPW4hPW51bGw/bigpOncubm93KCk7cmV0dXJuIGktYTx0fHwoYT1pLHI9ZSguLi5zKSkscn19ZnVuY3Rpb24gbTIoZSl7cmV0dXJuIGU9PT1cInJlbHVcIj9cInJlbHVcIjplPT09XCJsaW5lYXJcIj9cImxpbmVhclwiOmU9PT1cImVsdVwiP1wiZWx1XCI6bnVsbH12YXIgeUc9MDtmdW5jdGlvbiBmMigpe3JldHVybiB5RysrfXZhciBraD17fTtmdW5jdGlvbiBnZihlPVwiXCIpe3JldHVybiBlIGluIGtofHwoa2hbZV09MCksa2hbZV0rPTEsZStraFtlXS50b1N0cmluZygpfXZhciB4Rz1bXCJjaGFubmVsc0ZpcnN0XCIsXCJjaGFubmVsc0xhc3RcIl0sdkc9W1wibmVhcmVzdFwiLFwiYmlsaW5lYXJcIl0sd0c9W1widmFsaWRcIixcInNhbWVcIixcImNhdXNhbFwiXSxrRz1bXCJtYXhcIixcImF2Z1wiXSxJRz1bXCJzdW1cIixcIm11bFwiLFwiY29uY2F0XCIsXCJhdmVcIl0sa2w9bmV3IE1hcDtmdW5jdGlvbiBSdChlKXtLbyh4RyxcIkRhdGFGb3JtYXRcIixlKX1mdW5jdGlvbiBTRyhlKXtLbyh2RyxcIkludGVycG9sYXRpb25Gb3JtYXRcIixlKX1mdW5jdGlvbiB2YShlKXtLbyh3RyxcIlBhZGRpbmdNb2RlXCIsZSl9ZnVuY3Rpb24gZzIoZSl7S28oa0csXCJQb29sTW9kZVwiLGUpfXZhciBwYz1bXSxnST1cIi9cIjtmdW5jdGlvbiByaShlLHQpe3BjLnB1c2goZSk7dHJ5e2xldCBuPXQoKTtyZXR1cm4gcGMucG9wKCksbn1jYXRjaChuKXt0aHJvdyBwYy5wb3AoKSxufX1mdW5jdGlvbiBORygpe3JldHVybiBwYy5sZW5ndGg9PT0wP1wiXCI6cGMuam9pbihnSSkrZ0l9ZnVuY3Rpb24gYjIoZSl7aWYoIXgyKGUpKXRocm93IG5ldyBFcnJvcihcIk5vdCBhIHZhbGlkIHRlbnNvciBuYW1lOiAnXCIrZStcIidcIik7cmV0dXJuIE5HKCkrZX1mdW5jdGlvbiB5MihlKXtpZigheDIoZSkpdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6ICdcIitlK1wiJ1wiKTtrbC5oYXMoZSl8fGtsLnNldChlLDApO2xldCB0PWtsLmdldChlKTtpZihrbC5zZXQoZSxrbC5nZXQoZSkrMSksdD4wKXtsZXQgbj1gJHtlfV8ke3R9YDtyZXR1cm4ga2wuc2V0KG4sMSksbn1lbHNlIHJldHVybiBlfXZhciBURz1uZXcgUmVnRXhwKC9eW0EtWmEtejAtOV1bLUEtWmEtejAtOVxcLl9cXC9dKiQvKTtmdW5jdGlvbiB4MihlKXtyZXR1cm4hIWUubWF0Y2goVEcpfWZ1bmN0aW9uIENHKGUpe3JldHVybiBlPT09cGFyc2VJbnQoZS50b1N0cmluZygpLDEwKX1mdW5jdGlvbiBycyhlLHQsbil7dD09bnVsbCYmKHQ9MCksbj09bnVsbCYmKG49ZS5sZW5ndGgpO2xldCBhPTE7Zm9yKGxldCByPXQ7cjxuOysrcilhKj1lW3JdO3JldHVybiBhfWZ1bmN0aW9uIFVsKGUpe2lmKGUubGVuZ3RoPT09MClyZXR1cm4gTnVtYmVyLk5hTjtsZXQgdD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2xldCBhPWVbbl07YTx0JiYodD1hKX1yZXR1cm4gdH1mdW5jdGlvbiBocyhlKXtpZihlLmxlbmd0aD09PTApcmV0dXJuIE51bWJlci5OYU47bGV0IHQ9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtsZXQgYT1lW25dO2E+dCYmKHQ9YSl9cmV0dXJuIHR9ZnVuY3Rpb24gVWEoZSx0KXtpZih0PGUpdGhyb3cgbmV3IFYoYGVuZCAoJHt0fSkgPCBiZWdpbiAoJHtlfSkgaXMgZm9yYmlkZGVuLmApO2xldCBuPVtdO2ZvcihsZXQgYT1lO2E8dDsrK2Epbi5wdXNoKGEpO3JldHVybiBufXZhciBweDtmdW5jdGlvbiBxdCgpe3JldHVybiBweD09bnVsbCYmKHB4PUR2KCkuZXBzaWxvbigpKSxweH1mdW5jdGlvbiBHYSgpe3JldHVyblwiY2hhbm5lbHNMYXN0XCJ9ZnVuY3Rpb24gaXIoZSx0KXtyZXR1cm4gcmUoZSx0KX1mdW5jdGlvbiB3ZChlLHQ9LTEpe2xldCBuPWUuc2hhcGUuc2xpY2UoKTtyZXR1cm4gdDwwJiYodD1uLmxlbmd0aCt0KzEpLG4uc3BsaWNlKHQsMCwxKSxXKGUsbil9ZnVuY3Rpb24gRUcoZSx0KXtyZXR1cm4gTygoKT0+e2lmKGUuc2hhcGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgVihgcmVwZWF0KCkgZXhwZWN0cyBhIHJhbmstMiB0ZW5zb3IsIGJ1dCByZWNlaXZlZCBhIHJhbmstJHtlLnNoYXBlLmxlbmd0aH0gdGVuc29yLmApO2xldCBuPXdkKGUsMSk7cmV0dXJuIFd4KG4sWzEsdCwxXSl9KX1mdW5jdGlvbiBfRyhlKXtsZXQgdD1bcnMoZS5zaGFwZSldO3JldHVybiBXKGUsdCl9ZnVuY3Rpb24gQUcoZSl7aWYoZS5yYW5rPD0xKXRocm93IG5ldyBWKGBiYXRjaEZsYXR0ZW4gcmVxdWlyZXMgYSBtaW5pbXVtIHJhbmsgb2YgMi4gR290IHJhbms6ICR7ZS5yYW5rfS5gKTtsZXQgdD1bZS5zaGFwZVswXSxycyhlLnNoYXBlLDEpXTtyZXR1cm4gVyhlLHQpfWZ1bmN0aW9uIHNpKGUsdCxuKXtyZXR1cm4gTygoKT0+e3N3aXRjaChlLnJhbmspe2Nhc2UgMTpyZXR1cm4gZ2QoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gbmYoZSxbdCwwXSxbbixlLnNoYXBlWzFdXSk7Y2FzZSAzOnJldHVybiBIbyhlLFt0LDAsMF0sW24sZS5zaGFwZVsxXSxlLnNoYXBlWzJdXSk7Y2FzZSA0OnJldHVybiBXbChlLFt0LDAsMCwwXSxbbixlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXV0pO2Nhc2UgNTpyZXR1cm4gVmUoZSxbdCwwLDAsMCwwXSxbbixlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXSxlLnNoYXBlWzRdXSk7Y2FzZSA2OnJldHVybiBWZShlLFt0LDAsMCwwLDAsMF0sW24sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLGUuc2hhcGVbM10sZS5zaGFwZVs0XSxlLnNoYXBlWzVdXSk7ZGVmYXVsdDp0aHJvdyBuZXcgVihgc2xpY2VBbG9uZ0ZpcnN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiAke2UucmFua31gKX19KX1mdW5jdGlvbiBjeChlLHQsbil7cmV0dXJuIE8oKCk9Pntzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIGdkKGUsdCxuKTtjYXNlIDI6cmV0dXJuIG5mKGUsWzAsdF0sW2Uuc2hhcGVbMF0sbl0pO2Nhc2UgMzpyZXR1cm4gSG8oZSxbMCwwLHRdLFtlLnNoYXBlWzBdLGUuc2hhcGVbMV0sbl0pO2Nhc2UgNDpyZXR1cm4gV2woZSxbMCwwLDAsdF0sW2Uuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdLG5dKTtkZWZhdWx0OnRocm93IG5ldyBWKGBzbGljZUFsb25nTGFzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogJHtlLnJhbmt9YCl9fSl9ZnVuY3Rpb24gSWgoZSx0LG4sYSl7cmV0dXJuIE8oKCk9Pntzd2l0Y2goZS5yYW5rKXtjYXNlIDE6cmV0dXJuIGdkKGUsdCxuKTtjYXNlIDI6c3dpdGNoKGEpe2Nhc2UgMTpyZXR1cm4gc2koZSx0LG4pO2Nhc2UgMjpyZXR1cm4gY3goZSx0LG4pO2RlZmF1bHQ6dGhyb3cgbmV3IFYoYFRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciAke2F9YCl9Y2FzZSAzOnN3aXRjaChhKXtjYXNlIDE6cmV0dXJuIHNpKGUsdCxuKTtjYXNlIDI6cmV0dXJuIEhvKGUsWzAsdCwwXSxbZS5zaGFwZVswXSxuLGUuc2hhcGVbMl1dKTtjYXNlIDM6cmV0dXJuIGN4KGUsdCxuKTtkZWZhdWx0OnRocm93IG5ldyBWKGBUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgJHthfWApfWNhc2UgNDpzd2l0Y2goYSl7Y2FzZSAxOnJldHVybiBzaShlLHQsbik7Y2FzZSAyOnJldHVybiBXbChlLFswLHQsMCwwXSxbZS5zaGFwZVswXSxuLGUuc2hhcGVbMl0sZS5zaGFwZVszXV0pO2Nhc2UgMzpyZXR1cm4gV2woZSxbMCwwLHQsMF0sW2Uuc2hhcGVbMF0sZS5zaGFwZVsxXSxuLGUuc2hhcGVbM11dKTtjYXNlIDQ6cmV0dXJuIGN4KGUsdCxuKTtkZWZhdWx0OnRocm93IG5ldyBWKGBUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgJHthfWApfWRlZmF1bHQ6dGhyb3cgbmV3IFYoYHNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiAke2UucmFua31gKX19KX1mdW5jdGlvbiB0MChlLHQ9LTEpe2xldCBuO3JldHVybiB0PDAmJihuPWVbMF0ucmFuayxuIT09MD90PW46dD0wKSx0PT09ZVswXS5yYW5rJiYodD0tMSksZXQoZSx0KX1mdW5jdGlvbiBiSShlLHQpe3N3aXRjaChlLnJhbmspe2Nhc2UgMTpyZXR1cm4gSnYoW2UsdF0pO2Nhc2UgMjpyZXR1cm4gUXYoW2UsdF0sMCk7Y2FzZSAzOnJldHVybiBldyhbZSx0XSwwKTtjYXNlIDQ6cmV0dXJuIHR3KFtlLHRdLDApO2RlZmF1bHQ6dGhyb3cgbmV3IFYoYGNvbmNhdEFsb25nRmlyc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6ICR7ZS5yYW5rfWApfX1mdW5jdGlvbiBXeChlLHQpe2lmKEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksZS5yYW5rIT09dC5sZW5ndGgpdGhyb3cgbmV3IFYoYFRoZSBsZW5ndGggb2YgaW5wdXQgbiAoJHt0Lmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiBpbnB1dCB4ICgke2UucmFua30pYCk7cmV0dXJuIE9uKGUsdCl9ZnVuY3Rpb24gYmYoZSx0PTAsbj0xLGEscil7cmV0dXJuIFhtKGUsdCxuLGEscil9ZnVuY3Rpb24gb3IoZSx0LG4sYSl7aWYoZS5yYW5rPDJ8fHQucmFuazwyKXRocm93IG5ldyB6ZShgZG90IHJlcXVpcmVzIGJvdGggaW5wdXRzIHRvIGJlIHJhbmsgPj0gMiBidXQgZ290IHggc2hhcGUgPSAke2Uuc2hhcGV9IGFuZCB5IHNoYXBlID0gJHt0LnNoYXBlfWApO2lmKHQucmFuaz49Myl7bGV0IHI9ZS5zaGFwZS5zbGljZSgtMSlbMF0scz10LnNoYXBlLnNsaWNlKC0yKVswXTtpZihyIT09cyl0aHJvdyBuZXcgemUoYElmIHJhbmsgeSA+PSAzLCB0aGVuIHRoZSBzZWNvbmQgbGFzdCBkaW0gb2YgeSBtdXN0IGVxdWFsIHRoZSBsYXN0IGRpbSBvZiB4IGJ1dCBnb3QgeCBzaGFwZSA9ICR7ZS5zaGFwZX0gYW5kICB5IHNoYXBlID0gJHt0LnNoYXBlfWApfWlmKGUucmFuaz09PTImJnQucmFuaz09PTIpcmV0dXJuIFZsLm1hdE11bCh7YTplLGI6dCx0cmFuc3Bvc2VBOiExLHRyYW5zcG9zZUI6ITEsYmlhczphP0J4KGUucmFuayxhLEdhKCkpOm51bGwsYWN0aXZhdGlvbjpufSk7e2xldCByPWUuc2hhcGUuc2xpY2UoKSxzPXIucG9wKCk7ZT1XKGUsWy0xLHNdKTtsZXQgaT10LnNoYXBlLnNsaWNlKCksbz1pLnBvcCgpLGw9aS5wb3AoKSx1PVsuLi5pLG9dLHA9QXJyYXkuZnJvbSh7bGVuZ3RoOnQucmFua30sKGMsaCk9Pmg9PT0wP3QucmFuay0yOmg8PXQucmFuay0yP2gtMTpoKTt0PVcoRGUodCxwKSxbbCwtMV0pO2xldCBkPVsuLi5yLC4uLnVdO3JldHVybiBXKFZsLm1hdE11bCh7YTplLGI6dCx0cmFuc3Bvc2VBOiExLHRyYW5zcG9zZUI6ITEsYmlhczphP0J4KGUucmFuayxhLEdhKCkpOm51bGwsYWN0aXZhdGlvbjpufSksZCl9fWZ1bmN0aW9uIHYyKGUsdCxuKXtyZXR1cm4gTygoKT0+KEFycmF5LmlzQXJyYXkodCk/dD1qZSh0LFwiaW50MzJcIik6dD1yZSh0LFwiaW50MzJcIiksbnAoZSx0LG4pKSl9ZnVuY3Rpb24ga2QoZSl7cmV0dXJuIHooZSxlKX1mdW5jdGlvbiBCeChlLHQsbil7bGV0IGE9dC5zaGFwZTtpZih0LnJhbmshPT0xJiZ0LnJhbmshPT1lKXRocm93IG5ldyBWKGBVbmV4cGVjdGVkIGJpYXMgZGltZW5zaW9uczogJHt0LnJhbmt9OyBleHBlY3RlZCBpdCB0byBiZSAxIG9yICR7ZX1gKTtpZihlPT09NSl7aWYobj09PVwiY2hhbm5lbHNGaXJzdFwiKXJldHVybiBhLmxlbmd0aD09PTE/Vyh0LFsxLGFbMF0sMSwxLDFdKTpXKHQsWzEsYVszXSxhWzBdLGFbMV0sYVsyXV0pO2lmKG49PT1cImNoYW5uZWxzTGFzdFwiKXJldHVybiBhLmxlbmd0aD09PTE/Vyh0LFsxLDEsMSwxLGFbMF1dKTpXKHQsWzFdLmNvbmNhdChhKSl9ZWxzZSBpZihlPT09NCl7aWYobj09PVwiY2hhbm5lbHNGaXJzdFwiKXJldHVybiBhLmxlbmd0aD09PTE/Vyh0LFsxLGFbMF0sMSwxXSk6Vyh0LFsxLGFbMl0sYVswXSxhWzFdXSk7aWYobj09PVwiY2hhbm5lbHNMYXN0XCIpcmV0dXJuIGEubGVuZ3RoPT09MT9XKHQsWzEsMSwxLGFbMF1dKTpXKHQsWzFdLmNvbmNhdChhKSl9ZWxzZSBpZihlPT09Myl7aWYobj09PVwiY2hhbm5lbHNGaXJzdFwiKXJldHVybiBhLmxlbmd0aD09PTE/Vyh0LFsxLGFbMF0sMV0pOlcodCxbMSxhWzFdLGFbMF1dKTtpZihuPT09XCJjaGFubmVsc0xhc3RcIilyZXR1cm4gYS5sZW5ndGg9PT0xP1codCxbMSwxLGFbMF1dKTpXKHQsWzFdLmNvbmNhdChhKSl9ZWxzZSBpZihlPDMpcmV0dXJuIHQ7dGhyb3cgbmV3IFYoYFVuc3VwcG9ydGVkIGlucHV0IHJhbmsgYnkgYmlhc0FkZDogJHt0LnJhbmt9YCl9ZnVuY3Rpb24gS2EoZSx0LG4pe3JldHVybiBPKCgpPT4obj09bnVsbCYmKG49R2EoKSksUnQobiksWChlLEJ4KGUucmFuayx0LG4pKSkpfWZ1bmN0aW9uIEZHKGUsdD0xKXtpZih0IT09MSl0aHJvdyBuZXcgemUoYFN1cHBvcnQgZm9yIGFscGhhIHZhbHVlcyBvdGhlciB0aGFuIDEgKCR7dH0pIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuYCk7cmV0dXJuIFF1KGUpfWZ1bmN0aW9uICRHKGUpe3JldHVybiBPKCgpPT5oZShlLFgoTHQoZSksMSkpKX1mdW5jdGlvbiB3MihlLHQsbixhKXtyZXR1cm4gTygoKT0+UHcoZSx0LG4sYSkpfWZ1bmN0aW9uIERHKGUpe3JldHVybiBPKCgpPT57bGV0IHQ9WCguNSx6KC4yLGUpKTtyZXR1cm4gYW4odCwwLDEpfSl9ZnVuY3Rpb24gSWQoZSx0LG49ITEpe3JldHVybiBuP2UoKTp0KCl9dmFyIFJHPVtcImZhbkluXCIsXCJmYW5PdXRcIixcImZhbkF2Z1wiXSxNRz1bXCJub3JtYWxcIixcInVuaWZvcm1cIixcInRydW5jYXRlZE5vcm1hbFwiXTtmdW5jdGlvbiBPRyhlKXtLbyhSRyxcIkZhbk1vZGVcIixlKX1mdW5jdGlvbiBQRyhlKXtLbyhNRyxcIkRpc3RyaWJ1dGlvblwiLGUpfXZhciAkYT1jbGFzcyBleHRlbmRzIG5lLlNlcmlhbGl6YWJsZXtmcm9tQ29uZmlnVXNlc0N1c3RvbU9iamVjdHMoKXtyZXR1cm4hMX1nZXRDb25maWcoKXtyZXR1cm57fX19LG4wPWNsYXNzIGV4dGVuZHMgJGF7YXBwbHkoZSx0KXtyZXR1cm4gSXQoZSx0KX19O24wLmNsYXNzTmFtZT1cIlplcm9zXCI7bmUucmVnaXN0ZXJDbGFzcyhuMCk7dmFyIHlmPWNsYXNzIGV4dGVuZHMgJGF7YXBwbHkoZSx0KXtyZXR1cm4gUG4oZSx0KX19O3lmLmNsYXNzTmFtZT1cIk9uZXNcIjtuZS5yZWdpc3RlckNsYXNzKHlmKTt2YXIgYTA9Y2xhc3MgZXh0ZW5kcyAkYXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcigpLHR5cGVvZiBlIT1cIm9iamVjdFwiKXRocm93IG5ldyBWKGBFeHBlY3RlZCBhcmd1bWVudCBvZiB0eXBlIENvbnN0YW50Q29uZmlnIGJ1dCBnb3QgJHtlfWApO2lmKGUudmFsdWU9PT12b2lkIDApdGhyb3cgbmV3IFYoYGNvbmZpZyBtdXN0IGhhdmUgdmFsdWUgc2V0IGJ1dCBnb3QgJHtlfWApO3RoaXMudmFsdWU9ZS52YWx1ZX1hcHBseShlLHQpe3JldHVybiBPKCgpPT56KHhlKHRoaXMudmFsdWUpLFBuKGUsdCkpKX1nZXRDb25maWcoKXtyZXR1cm57dmFsdWU6dGhpcy52YWx1ZX19fTthMC5jbGFzc05hbWU9XCJDb25zdGFudFwiO25lLnJlZ2lzdGVyQ2xhc3MoYTApO3ZhciByMD1jbGFzcyBleHRlbmRzICRhe2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5ERUZBVUxUX01JTlZBTD0tLjA1LHRoaXMuREVGQVVMVF9NQVhWQUw9LjA1LHRoaXMubWludmFsPWUubWludmFsfHx0aGlzLkRFRkFVTFRfTUlOVkFMLHRoaXMubWF4dmFsPWUubWF4dmFsfHx0aGlzLkRFRkFVTFRfTUFYVkFMLHRoaXMuc2VlZD1lLnNlZWR9YXBwbHkoZSx0KXtyZXR1cm4gRXMoZSx0aGlzLm1pbnZhbCx0aGlzLm1heHZhbCx0LHRoaXMuc2VlZCl9Z2V0Q29uZmlnKCl7cmV0dXJue21pbnZhbDp0aGlzLm1pbnZhbCxtYXh2YWw6dGhpcy5tYXh2YWwsc2VlZDp0aGlzLnNlZWR9fX07cjAuY2xhc3NOYW1lPVwiUmFuZG9tVW5pZm9ybVwiO25lLnJlZ2lzdGVyQ2xhc3MocjApO3ZhciBzMD1jbGFzcyBleHRlbmRzICRhe2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5ERUZBVUxUX01FQU49MCx0aGlzLkRFRkFVTFRfU1REREVWPS4wNSx0aGlzLm1lYW49ZS5tZWFufHx0aGlzLkRFRkFVTFRfTUVBTix0aGlzLnN0ZGRldj1lLnN0ZGRldnx8dGhpcy5ERUZBVUxUX1NURERFVix0aGlzLnNlZWQ9ZS5zZWVkfWFwcGx5KGUsdCl7aWYodD10fHxcImZsb2F0MzJcIix0IT09XCJmbG9hdDMyXCImJnQhPT1cImludDMyXCIpdGhyb3cgbmV3IHplKGByYW5kb21Ob3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSAke3R9LmApO3JldHVybiBiZihlLHRoaXMubWVhbix0aGlzLnN0ZGRldix0LHRoaXMuc2VlZCl9Z2V0Q29uZmlnKCl7cmV0dXJue21lYW46dGhpcy5tZWFuLHN0ZGRldjp0aGlzLnN0ZGRldixzZWVkOnRoaXMuc2VlZH19fTtzMC5jbGFzc05hbWU9XCJSYW5kb21Ob3JtYWxcIjtuZS5yZWdpc3RlckNsYXNzKHMwKTt2YXIgaTA9Y2xhc3MgZXh0ZW5kcyAkYXtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuREVGQVVMVF9NRUFOPTAsdGhpcy5ERUZBVUxUX1NURERFVj0uMDUsdGhpcy5tZWFuPWUubWVhbnx8dGhpcy5ERUZBVUxUX01FQU4sdGhpcy5zdGRkZXY9ZS5zdGRkZXZ8fHRoaXMuREVGQVVMVF9TVERERVYsdGhpcy5zZWVkPWUuc2VlZH1hcHBseShlLHQpe2lmKHQ9dHx8XCJmbG9hdDMyXCIsdCE9PVwiZmxvYXQzMlwiJiZ0IT09XCJpbnQzMlwiKXRocm93IG5ldyB6ZShgdHJ1bmNhdGVkTm9ybWFsIGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgJHt0fS5gKTtyZXR1cm4gbGYoZSx0aGlzLm1lYW4sdGhpcy5zdGRkZXYsdCx0aGlzLnNlZWQpfWdldENvbmZpZygpe3JldHVybnttZWFuOnRoaXMubWVhbixzdGRkZXY6dGhpcy5zdGRkZXYsc2VlZDp0aGlzLnNlZWR9fX07aTAuY2xhc3NOYW1lPVwiVHJ1bmNhdGVkTm9ybWFsXCI7bmUucmVnaXN0ZXJDbGFzcyhpMCk7dmFyIG8wPWNsYXNzIGV4dGVuZHMgJGF7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLmdhaW49ZS5nYWluIT1udWxsP2UuZ2FpbjoxfWFwcGx5KGUsdCl7cmV0dXJuIE8oKCk9PntpZihlLmxlbmd0aCE9PTJ8fGVbMF0hPT1lWzFdKXRocm93IG5ldyBWKFwiSWRlbnRpdHkgbWF0cml4IGluaXRpYWxpemVyIGNhbiBvbmx5IGJlIHVzZWQgZm9yIDJEIHNxdWFyZSBtYXRyaWNlcy5cIik7cmV0dXJuIHoodGhpcy5nYWluLEdtKGVbMF0pKX0pfWdldENvbmZpZygpe3JldHVybntnYWluOnRoaXMuZ2Fpbn19fTtvMC5jbGFzc05hbWU9XCJJZGVudGl0eVwiO25lLnJlZ2lzdGVyQ2xhc3MobzApO2Z1bmN0aW9uIExHKGUsdD1cImNoYW5uZWxzTGFzdFwiKXtsZXQgbixhO2lmKFJ0KHQpLGUubGVuZ3RoPT09MiluPWVbMF0sYT1lWzFdO2Vsc2UgaWYoWzMsNCw1XS5pbmRleE9mKGUubGVuZ3RoKSE9PS0xKXtpZih0PT09XCJjaGFubmVsc0ZpcnN0XCIpe2xldCByPXJzKGUsMik7bj1lWzFdKnIsYT1lWzBdKnJ9ZWxzZSBpZih0PT09XCJjaGFubmVsc0xhc3RcIil7bGV0IHI9cnMoZSwwLGUubGVuZ3RoLTIpO249ZVtlLmxlbmd0aC0yXSpyLGE9ZVtlLmxlbmd0aC0xXSpyfX1lbHNle2xldCByPXJzKGUpO249TWF0aC5zcXJ0KHIpLGE9TWF0aC5zcXJ0KHIpfXJldHVybltuLGFdfXZhciBCbj1jbGFzcyBleHRlbmRzICRhe2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKCksZS5zY2FsZTwwKXRocm93IG5ldyBWKGBzY2FsZSBtdXN0IGJlIGEgcG9zaXRpdmUgZmxvYXQuIEdvdDogJHtlLnNjYWxlfWApO3RoaXMuc2NhbGU9ZS5zY2FsZT09bnVsbD8xOmUuc2NhbGUsdGhpcy5tb2RlPWUubW9kZT09bnVsbD9cImZhbkluXCI6ZS5tb2RlLE9HKHRoaXMubW9kZSksdGhpcy5kaXN0cmlidXRpb249ZS5kaXN0cmlidXRpb249PW51bGw/XCJub3JtYWxcIjplLmRpc3RyaWJ1dGlvbixQRyh0aGlzLmRpc3RyaWJ1dGlvbiksdGhpcy5zZWVkPWUuc2VlZH1hcHBseShlLHQpe2xldCBuPUxHKGUpLGE9blswXSxyPW5bMV0scz10aGlzLnNjYWxlO2lmKHRoaXMubW9kZT09PVwiZmFuSW5cIj9zLz1NYXRoLm1heCgxLGEpOnRoaXMubW9kZT09PVwiZmFuT3V0XCI/cy89TWF0aC5tYXgoMSxyKTpzLz1NYXRoLm1heCgxLChhK3IpLzIpLHRoaXMuZGlzdHJpYnV0aW9uPT09XCJub3JtYWxcIil7bGV0IGk9TWF0aC5zcXJ0KHMpO2lmKHQ9dHx8XCJmbG9hdDMyXCIsdCE9PVwiZmxvYXQzMlwiJiZ0IT09XCJpbnQzMlwiKXRocm93IG5ldyB6ZShgJHt0aGlzLmdldENsYXNzTmFtZSgpfSBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlICR7dH0uYCk7cmV0dXJuIGxmKGUsMCxpLHQsdGhpcy5zZWVkKX1lbHNle2xldCBpPU1hdGguc3FydCgzKnMpO3JldHVybiBFcyhlLC1pLGksdCx0aGlzLnNlZWQpfX1nZXRDb25maWcoKXtyZXR1cm57c2NhbGU6dGhpcy5zY2FsZSxtb2RlOnRoaXMubW9kZSxkaXN0cmlidXRpb246dGhpcy5kaXN0cmlidXRpb24sc2VlZDp0aGlzLnNlZWR9fX07Qm4uY2xhc3NOYW1lPVwiVmFyaWFuY2VTY2FsaW5nXCI7bmUucmVnaXN0ZXJDbGFzcyhCbik7dmFyIHhmPWNsYXNzIGV4dGVuZHMgQm57Y29uc3RydWN0b3IoZSl7c3VwZXIoe3NjYWxlOjEsbW9kZTpcImZhbkF2Z1wiLGRpc3RyaWJ1dGlvbjpcInVuaWZvcm1cIixzZWVkOmU9PW51bGw/bnVsbDplLnNlZWR9KX1nZXRDbGFzc05hbWUoKXtyZXR1cm4gQm4uY2xhc3NOYW1lfX07eGYuY2xhc3NOYW1lPVwiR2xvcm90VW5pZm9ybVwiO25lLnJlZ2lzdGVyQ2xhc3MoeGYpO3ZhciB2Zj1jbGFzcyBleHRlbmRzIEJue2NvbnN0cnVjdG9yKGUpe3N1cGVyKHtzY2FsZToxLG1vZGU6XCJmYW5BdmdcIixkaXN0cmlidXRpb246XCJub3JtYWxcIixzZWVkOmU9PW51bGw/bnVsbDplLnNlZWR9KX1nZXRDbGFzc05hbWUoKXtyZXR1cm4gQm4uY2xhc3NOYW1lfX07dmYuY2xhc3NOYW1lPVwiR2xvcm90Tm9ybWFsXCI7bmUucmVnaXN0ZXJDbGFzcyh2Zik7dmFyIHdmPWNsYXNzIGV4dGVuZHMgQm57Y29uc3RydWN0b3IoZSl7c3VwZXIoe3NjYWxlOjIsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwibm9ybWFsXCIsc2VlZDplPT1udWxsP251bGw6ZS5zZWVkfSl9Z2V0Q2xhc3NOYW1lKCl7cmV0dXJuIEJuLmNsYXNzTmFtZX19O3dmLmNsYXNzTmFtZT1cIkhlTm9ybWFsXCI7bmUucmVnaXN0ZXJDbGFzcyh3Zik7dmFyIGtmPWNsYXNzIGV4dGVuZHMgQm57Y29uc3RydWN0b3IoZSl7c3VwZXIoe3NjYWxlOjIsbW9kZTpcImZhbkluXCIsZGlzdHJpYnV0aW9uOlwidW5pZm9ybVwiLHNlZWQ6ZT09bnVsbD9udWxsOmUuc2VlZH0pfWdldENsYXNzTmFtZSgpe3JldHVybiBCbi5jbGFzc05hbWV9fTtrZi5jbGFzc05hbWU9XCJIZVVuaWZvcm1cIjtuZS5yZWdpc3RlckNsYXNzKGtmKTt2YXIgSWY9Y2xhc3MgZXh0ZW5kcyBCbntjb25zdHJ1Y3RvcihlKXtzdXBlcih7c2NhbGU6MSxtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJub3JtYWxcIixzZWVkOmU9PW51bGw/bnVsbDplLnNlZWR9KX1nZXRDbGFzc05hbWUoKXtyZXR1cm4gQm4uY2xhc3NOYW1lfX07SWYuY2xhc3NOYW1lPVwiTGVDdW5Ob3JtYWxcIjtuZS5yZWdpc3RlckNsYXNzKElmKTt2YXIgU2Y9Y2xhc3MgZXh0ZW5kcyBCbntjb25zdHJ1Y3RvcihlKXtzdXBlcih7c2NhbGU6MSxtb2RlOlwiZmFuSW5cIixkaXN0cmlidXRpb246XCJ1bmlmb3JtXCIsc2VlZDplPT1udWxsP251bGw6ZS5zZWVkfSl9Z2V0Q2xhc3NOYW1lKCl7cmV0dXJuIEJuLmNsYXNzTmFtZX19O1NmLmNsYXNzTmFtZT1cIkxlQ3VuVW5pZm9ybVwiO25lLnJlZ2lzdGVyQ2xhc3MoU2YpO3ZhciBsMD1jbGFzcyBleHRlbmRzICRhe2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5ERUZBVUxUX0dBSU49MSx0aGlzLkVMRU1FTlRTX1dBUk5fU0xPVz0yZTMsdGhpcy5nYWluPWUuZ2Fpbj09bnVsbD90aGlzLkRFRkFVTFRfR0FJTjplLmdhaW4sdGhpcy5zZWVkPWUuc2VlZH1hcHBseShlLHQpe3JldHVybiBPKCgpPT57aWYoZS5sZW5ndGg8Mil0aHJvdyBuZXcgemUoXCJTaGFwZSBtdXN0IGJlIGF0IGxlYXN0IDJELlwiKTtpZih0IT09XCJpbnQzMlwiJiZ0IT09XCJmbG9hdDMyXCImJnQhPT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlICR7dH0uYCk7dD10O2xldCBuPXcuc2l6ZUZyb21TaGFwZShlLnNsaWNlKDAsLTEpKSxhPWVbZS5sZW5ndGgtMV0scj1uKmE7cj50aGlzLkVMRU1FTlRTX1dBUk5fU0xPVyYmY29uc29sZS53YXJuKGBPcnRob2dvbmFsIGluaXRpYWxpemVyIGlzIGJlaW5nIGNhbGxlZCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgdGhhbiAke3RoaXMuRUxFTUVOVFNfV0FSTl9TTE9XfSAoJHtyfSkgZWxlbWVudHM6IFNsb3duZXNzIG1heSByZXN1bHQuYCk7bGV0IHM9W01hdGgubWF4KGEsbiksTWF0aC5taW4oYSxuKV0saT1iZihzLDAsMSx0LHRoaXMuc2VlZCksbz1Cdy5xcihpLCExKSxsPW9bMF0sdT1vWzFdLmZsYXR0ZW4oKS5zdHJpZGVkU2xpY2UoWzBdLFtNYXRoLm1pbihhLG4pKk1hdGgubWluKGEsbildLFtNYXRoLm1pbihhLG4pKzFdKTtyZXR1cm4gbD16KGwsdS5zaWduKCkpLG48YSYmKGw9bC50cmFuc3Bvc2UoKSkseih4ZSh0aGlzLmdhaW4pLGwucmVzaGFwZShlKSl9KX1nZXRDb25maWcoKXtyZXR1cm57Z2Fpbjp0aGlzLmdhaW4sc2VlZDp0aGlzLnNlZWR9fX07bDAuY2xhc3NOYW1lPVwiT3J0aG9nb25hbFwiO25lLnJlZ2lzdGVyQ2xhc3MobDApO3ZhciB5ST17Y29uc3RhbnQ6XCJDb25zdGFudFwiLGdsb3JvdE5vcm1hbDpcIkdsb3JvdE5vcm1hbFwiLGdsb3JvdFVuaWZvcm06XCJHbG9yb3RVbmlmb3JtXCIsaGVOb3JtYWw6XCJIZU5vcm1hbFwiLGhlVW5pZm9ybTpcIkhlVW5pZm9ybVwiLGlkZW50aXR5OlwiSWRlbnRpdHlcIixsZUN1bk5vcm1hbDpcIkxlQ3VuTm9ybWFsXCIsbGVDdW5Vbmlmb3JtOlwiTGVDdW5Vbmlmb3JtXCIsb25lczpcIk9uZXNcIixvcnRob2dvbmFsOlwiT3J0aG9nb25hbFwiLHJhbmRvbU5vcm1hbDpcIlJhbmRvbU5vcm1hbFwiLHJhbmRvbVVuaWZvcm06XCJSYW5kb21Vbmlmb3JtXCIsdHJ1bmNhdGVkTm9ybWFsOlwiVHJ1bmNhdGVkTm9ybWFsXCIsdmFyaWFuY2VTY2FsaW5nOlwiVmFyaWFuY2VTY2FsaW5nXCIsemVyb3M6XCJaZXJvc1wifTtmdW5jdGlvbiB4SShlLHQ9e30pe3JldHVybiB2ZChlLG5lLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJpbml0aWFsaXplclwiKX1mdW5jdGlvbiBFdChlKXtyZXR1cm4gUXcoZSl9ZnVuY3Rpb24gU3QoZSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2xldCB0PWUgaW4geUk/eUlbZV06ZTtpZih0PT09XCJHbG9yb3ROb3JtYWxcIilyZXR1cm4gbmV3IHZmO2lmKHQ9PT1cIkdsb3JvdFVuaWZvcm1cIilyZXR1cm4gbmV3IHhmO2lmKHQ9PT1cIkhlTm9ybWFsXCIpcmV0dXJuIG5ldyB3ZjtpZih0PT09XCJIZVVuaWZvcm1cIilyZXR1cm4gbmV3IGtmO2lmKHQ9PT1cIkxlQ3VuTm9ybWFsXCIpcmV0dXJuIG5ldyBJZjtpZih0PT09XCJMZUN1blVuaWZvcm1cIilyZXR1cm4gbmV3IFNmO3tsZXQgbj17fTtyZXR1cm4gbi5jbGFzc05hbWU9dCxuLmNvbmZpZz17fSx4SShuKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mICRhP2U6eEkoZSl9ZnVuY3Rpb24gVngoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoZVswXSl9ZnVuY3Rpb24gWmgoZSl7cmV0dXJuIGUubGVuZ3RoPT09MD9bXTpBcnJheS5pc0FycmF5KGVbMF0pP2U6W2VdfWZ1bmN0aW9uIFRlKGUpe2xldCB0O2lmKEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgVihgRXhwZWN0ZWQgVGVuc29yIGxlbmd0aCB0byBiZSAxOyBnb3QgJHtlLmxlbmd0aH1gKTt0PWVbMF19ZWxzZSB0PWU7cmV0dXJuIHR9ZnVuY3Rpb24gSmUoZSl7aWYoQXJyYXkuaXNBcnJheShlKSYmQXJyYXkuaXNBcnJheShlWzBdKSl7aWYoZS5sZW5ndGg9PT0xKXJldHVybiBlPWUsZVswXTt0aHJvdyBuZXcgVihgRXhwZWN0ZWQgZXhhY3RseSAxIFNoYXBlOyBnb3QgJHtlLmxlbmd0aH1gKX1lbHNlIHJldHVybiBlfWZ1bmN0aW9uIEpoKGUpe2xldCB0PTA7Zm9yKGxldCBuIG9mIGUpbi5zaGFwZS5sZW5ndGg9PT0wP3QrPTE6dCs9bi5zaGFwZS5yZWR1Y2UoKGEscik9PmEqcik7cmV0dXJuIHR9dmFyIHZJPVwiVmFyaWFibGVcIixrMj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9XCJmbG9hdDMyXCIsbj12SSxhPSEwLHI9bnVsbCl7dGhpcy5kdHlwZT10PT1udWxsP1wiZmxvYXQzMlwiOnQsdGhpcy5zaGFwZT1lLnNoYXBlLHRoaXMuaWQ9ZjIoKSxuPW49PW51bGw/dkk6bix0aGlzLm9yaWdpbmFsTmFtZT1iMihuKSx0aGlzLm5hbWU9eTIodGhpcy5vcmlnaW5hbE5hbWUpLHRoaXMudHJhaW5hYmxlXz1hLHRoaXMuY29uc3RyYWludD1yLHRoaXMudmFsPU13KGUsdGhpcy50cmFpbmFibGVfLHRoaXMubmFtZSx0aGlzLmR0eXBlKX1yZWFkKCl7cmV0dXJuIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKSx0aGlzLnZhbH13cml0ZShlKXtyZXR1cm4gdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLHpHKHRoaXMudmFsLGUpLHRoaXMudmFsLmlkIT09ZS5pZCYmKHRoaXMudmFsLmFzc2lnbihlKSx0aGlzLmNvbnN0cmFpbnQhPW51bGwmJnRoaXMudmFsLmFzc2lnbih0aGlzLmNvbnN0cmFpbnQuYXBwbHkodGhpcy52YWwpKSksdGhpc31kaXNwb3NlKCl7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpLHRoaXMudmFsLmRpc3Bvc2UoKX1hc3NlcnROb3REaXNwb3NlZCgpe2lmKHRoaXMudmFsLmlzRGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKGBMYXllcnNWYXJpYWJsZSAke3RoaXMubmFtZX0gaXMgYWxyZWFkeSBkaXNwb3NlZC5gKX1nZXQgdHJhaW5hYmxlKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlX31zZXQgdHJhaW5hYmxlKGUpe3RoaXMudHJhaW5hYmxlXz1lLHRoaXMudmFsLnRyYWluYWJsZT1lfX07ZnVuY3Rpb24gekcoZSx0KXtpZihlLnNoYXBlLnRvU3RyaW5nKCkhPT10LnNoYXBlLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiU2hhcGUgbWlzbWF0Y2g6IFwiK0pTT04uc3RyaW5naWZ5KGUuc2hhcGUpK1wiIHZzLiBcIitKU09OLnN0cmluZ2lmeSh0LnNoYXBlKSl9ZnVuY3Rpb24gVXgoZSl7cmV0dXJuIGUubWFwKHQ9PnQucmVhZCgpKX1mdW5jdGlvbiB1MChlKXtlLmZvckVhY2godD0+e3RbMF0ud3JpdGUodFsxXSl9KX12YXIgenQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5kdHlwZT1lLmR0eXBlLHRoaXMuc2hhcGU9ZS5zaGFwZSxlLnNoYXBlIT1udWxsP3RoaXMubmRpbT1lLnNoYXBlLmxlbmd0aDp0aGlzLm5kaW09ZS5uZGltLHRoaXMubWF4TkRpbT1lLm1heE5EaW0sdGhpcy5taW5ORGltPWUubWluTkRpbSx0aGlzLmF4ZXM9ZS5heGVzfHx7fX19LEhhPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscixzLGkpe3RoaXMuZHR5cGU9ZSx0aGlzLnNoYXBlPXQsdGhpcy5zb3VyY2VMYXllcj1uLHRoaXMuaW5wdXRzPWEsdGhpcy5jYWxsQXJncz1yLHRoaXMub3V0cHV0VGVuc29ySW5kZXg9aSx0aGlzLmlkPWYyKCkscyE9bnVsbCYmKHRoaXMub3JpZ2luYWxOYW1lPWIyKHMpLHRoaXMubmFtZT15Mih0aGlzLm9yaWdpbmFsTmFtZSkpLHRoaXMucmFuaz10Lmxlbmd0aH19LFdHPTAsTmY9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmNhbGxBcmdzPXQsdGhpcy5pZD1XRysrLHRoaXMub3V0Ym91bmRMYXllcj1lLm91dGJvdW5kTGF5ZXIsdGhpcy5pbmJvdW5kTGF5ZXJzPWUuaW5ib3VuZExheWVycyx0aGlzLm5vZGVJbmRpY2VzPWUubm9kZUluZGljZXMsdGhpcy50ZW5zb3JJbmRpY2VzPWUudGVuc29ySW5kaWNlcyx0aGlzLmlucHV0VGVuc29ycz1lLmlucHV0VGVuc29ycyx0aGlzLm91dHB1dFRlbnNvcnM9ZS5vdXRwdXRUZW5zb3JzLHRoaXMuaW5wdXRNYXNrcz1lLmlucHV0TWFza3MsdGhpcy5vdXRwdXRNYXNrcz1lLm91dHB1dE1hc2tzLHRoaXMuaW5wdXRTaGFwZXM9ZS5pbnB1dFNoYXBlcyx0aGlzLm91dHB1dFNoYXBlcz1lLm91dHB1dFNoYXBlcztmb3IobGV0IG4gb2YgZS5pbmJvdW5kTGF5ZXJzKW4hPW51bGwmJm4ub3V0Ym91bmROb2Rlcy5wdXNoKHRoaXMpO2Uub3V0Ym91bmRMYXllci5pbmJvdW5kTm9kZXMucHVzaCh0aGlzKX1nZXRDb25maWcoKXtsZXQgZT1bXTtmb3IobGV0IHQgb2YgdGhpcy5pbmJvdW5kTGF5ZXJzKXQhPW51bGw/ZS5wdXNoKHQubmFtZSk6ZS5wdXNoKG51bGwpO3JldHVybntvdXRib3VuZExheWVyOnRoaXMub3V0Ym91bmRMYXllcj90aGlzLm91dGJvdW5kTGF5ZXIubmFtZTpudWxsLGluYm91bmRMYXllcnM6ZSxub2RlSW5kaWNlczp0aGlzLm5vZGVJbmRpY2VzLHRlbnNvckluZGljZXM6dGhpcy50ZW5zb3JJbmRpY2VzfX19LEJHPTAsV2U9Y2xhc3MgZXh0ZW5kcyBuZS5TZXJpYWxpemFibGV7Y29uc3RydWN0b3IoZT17fSl7c3VwZXIoKSx0aGlzLl9jYWxsSG9vaz1udWxsLHRoaXMuX2FkZGVkV2VpZ2h0TmFtZXM9W10sdGhpcy5fc3RhdGVmdWw9ITEsdGhpcy5pZD1CRysrLHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplcj1udWxsLHRoaXMuaW5wdXRTcGVjPW51bGwsdGhpcy5zdXBwb3J0c01hc2tpbmc9ITEsdGhpcy5fdHJhaW5hYmxlV2VpZ2h0cz1bXSx0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzPVtdLHRoaXMuX2xvc3Nlcz1bXSx0aGlzLl91cGRhdGVzPVtdLHRoaXMuX2J1aWx0PSExLHRoaXMuaW5ib3VuZE5vZGVzPVtdLHRoaXMub3V0Ym91bmROb2Rlcz1bXTtsZXQgdD1lLm5hbWU7aWYoIXQpe2xldCBuPXRoaXMuZ2V0Q2xhc3NOYW1lKCk7dD1JcihuKStcIl9cIitnZihuKX1pZih0aGlzLm5hbWU9dCx0aGlzLnRyYWluYWJsZV89ZS50cmFpbmFibGU9PW51bGw/ITA6ZS50cmFpbmFibGUsZS5pbnB1dFNoYXBlIT1udWxsfHxlLmJhdGNoSW5wdXRTaGFwZSE9bnVsbCl7bGV0IG47aWYoZS5iYXRjaElucHV0U2hhcGUhPW51bGwpbj1lLmJhdGNoSW5wdXRTaGFwZTtlbHNlIGlmKGUuaW5wdXRTaGFwZSE9bnVsbCl7bGV0IHI9bnVsbDtlLmJhdGNoU2l6ZSE9bnVsbCYmKHI9ZS5iYXRjaFNpemUpLG49W3JdLmNvbmNhdChlLmlucHV0U2hhcGUpfXRoaXMuYmF0Y2hJbnB1dFNoYXBlPW47bGV0IGE9ZS5kdHlwZTthPT1udWxsJiYoYT1lLmlucHV0RFR5cGUpLGE9PW51bGwmJihhPVwiZmxvYXQzMlwiKSx0aGlzLmR0eXBlPWF9ZS53ZWlnaHRzIT1udWxsP3RoaXMuaW5pdGlhbFdlaWdodHM9ZS53ZWlnaHRzOnRoaXMuaW5pdGlhbFdlaWdodHM9bnVsbCx0aGlzLl9yZWZDb3VudD1udWxsLHRoaXMuZmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD0hMX1zdGF0aWMgbm9kZUtleShlLHQpe3JldHVybiBlLm5hbWUrXCJfaWItXCIrdC50b1N0cmluZygpfWdldE5vZGVBdEluZGV4KGUsdCl7aWYodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPT09MCl0aHJvdyBuZXcgYXIoYFRoZSBsYXllciBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQgYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgJHt0fS5gKTtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg8PWUpdGhyb3cgbmV3IFYoYEFza2VkIHRvIGdldCAke3R9IGF0IG5vZGUgJHtlfSwgYnV0IHRoZSBsYXllciBoYXMgb25seSAke3RoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aH0gaW5ib3VuZCBub2Rlcy5gKTtyZXR1cm4gdGhpcy5pbmJvdW5kTm9kZXNbZV19Z2V0SW5wdXRBdChlKXtyZXR1cm4gTW4odGhpcy5nZXROb2RlQXRJbmRleChlLFwiaW5wdXRcIikuaW5wdXRUZW5zb3JzKX1nZXRPdXRwdXRBdChlKXtyZXR1cm4gTW4odGhpcy5nZXROb2RlQXRJbmRleChlLFwib3V0cHV0XCIpLm91dHB1dFRlbnNvcnMpfWdldCBpbnB1dCgpe2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aD4xKXRocm93IG5ldyBYcihgTGF5ZXIgJHt0aGlzLm5hbWV9IGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzLCBoZW5jZSB0aGUgbm90aW9uIG9mIFwibGF5ZXIgaW5wdXRcIiBpcyBpbGwtZGVmaW5lZC4gVXNlIFxcYGdldElucHV0QXQobm9kZUluZGV4KVxcYCBpbnN0ZWFkLmApO2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aD09PTApdGhyb3cgbmV3IFhyKGBMYXllciAke3RoaXMubmFtZX0gaXMgbm90IGNvbm5lY3RlZCwgbm8gaW5wdXQgdG8gcmV0dXJuLmApO3JldHVybiBNbih0aGlzLmdldE5vZGVBdEluZGV4KDAsXCJpbnB1dFwiKS5pbnB1dFRlbnNvcnMpfWdldCBvdXRwdXQoKXtpZih0aGlzLmluYm91bmROb2Rlcy5sZW5ndGg9PT0wKXRocm93IG5ldyBYcihgTGF5ZXIgJHt0aGlzLm5hbWV9IGhhcyBubyBpbmJvdW5kIG5vZGVzLmApO2lmKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aD4xKXRocm93IG5ldyBYcihgTGF5ZXIgJHt0aGlzLm5hbWV9IGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzLCBoZW5jZSB0aGUgbm90aW9uIG9mIFwibGF5ZXIgb3V0cHV0XCIgaXMgaWxsLWRlZmluZWQuIFVzZSBcXGBnZXRPdXRwdXRBdChub2RlSW5kZXgpXFxgIGluc3RlYWQuYCk7cmV0dXJuIE1uKHRoaXMuZ2V0Tm9kZUF0SW5kZXgoMCxcIm91dHB1dFwiKS5vdXRwdXRUZW5zb3JzKX1nZXQgbG9zc2VzKCl7cmV0dXJuIHRoaXMuX2xvc3Nlc31jYWxjdWxhdGVMb3NzZXMoKXtyZXR1cm4gdGhpcy5sb3NzZXMubWFwKGU9PmUoKSl9Z2V0IHVwZGF0ZXMoKXtyZXR1cm4gdGhpcy5fdXBkYXRlc31nZXQgYnVpbHQoKXtyZXR1cm4gdGhpcy5fYnVpbHR9c2V0IGJ1aWx0KGUpe3RoaXMuX2J1aWx0PWV9Z2V0IHRyYWluYWJsZSgpe3JldHVybiB0aGlzLnRyYWluYWJsZV99c2V0IHRyYWluYWJsZShlKXt0aGlzLl90cmFpbmFibGVXZWlnaHRzLmZvckVhY2godD0+dC50cmFpbmFibGU9ZSksdGhpcy50cmFpbmFibGVfPWV9Z2V0IHRyYWluYWJsZVdlaWdodHMoKXtyZXR1cm4gdGhpcy50cmFpbmFibGVfP3RoaXMuX3RyYWluYWJsZVdlaWdodHMuZmlsdGVyKGU9PmUudHJhaW5hYmxlKTpbXX1zZXQgdHJhaW5hYmxlV2VpZ2h0cyhlKXt0aGlzLl90cmFpbmFibGVXZWlnaHRzPWV9Z2V0IG5vblRyYWluYWJsZVdlaWdodHMoKXtyZXR1cm4gdGhpcy50cmFpbmFibGU/dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5maWx0ZXIoZT0+IWUudHJhaW5hYmxlKS5jb25jYXQodGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyk6dGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyl9c2V0IG5vblRyYWluYWJsZVdlaWdodHMoZSl7dGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cz1lfWdldCB3ZWlnaHRzKCl7cmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKX1nZXQgc3RhdGVmdWwoKXtyZXR1cm4gdGhpcy5fc3RhdGVmdWx9cmVzZXRTdGF0ZXMoKXtpZighdGhpcy5zdGF0ZWZ1bCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCB0aGUgcmVzZXRTdGF0ZXMoKSBtZXRob2Qgb2YgYSBub24tc3RhdGVmdWwgTGF5ZXIgb2JqZWN0LlwiKX1hc3NlcnRJbnB1dENvbXBhdGliaWxpdHkoZSl7bGV0IHQ9aXQoZSk7aWYodGhpcy5pbnB1dFNwZWM9PW51bGx8fHRoaXMuaW5wdXRTcGVjLmxlbmd0aD09PTApcmV0dXJuO2xldCBuPWl0KHRoaXMuaW5wdXRTcGVjKTtpZih0Lmxlbmd0aCE9PW4ubGVuZ3RoKXRocm93IG5ldyBWKGBMYXllciAke3RoaXMubmFtZX0gZXhwZWN0cyAke24ubGVuZ3RofSBpbnB1dHMsIGJ1dCBpdCByZWNlaXZlZCAke3QubGVuZ3RofSBpbnB1dCB0ZW5zb3JzLiBJbnB1dCByZWNlaXZlZDogJHtlfWApO2ZvcihsZXQgYT0wO2E8dC5sZW5ndGg7YSsrKXtsZXQgcj10W2FdLHM9blthXTtpZihzPT1udWxsKWNvbnRpbnVlO2xldCBpPXIucmFuaztpZihzLm5kaW0hPW51bGwmJmkhPT1zLm5kaW0pdGhyb3cgbmV3IFYoYElucHV0ICR7YX0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBleHBlY3RlZCBuZGltPSR7cy5uZGltfSwgZm91bmQgbmRpbT0ke2l9YCk7aWYocy5tYXhORGltIT1udWxsJiZpPnMubWF4TkRpbSl0aHJvdyBuZXcgVihgSW5wdXQgJHthfSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX06IGV4cGVjdGVkIG1heF9uZGltPSR7cy5tYXhORGltfSwgZm91bmQgbmRpbT0ke2l9YCk7aWYocy5taW5ORGltIT1udWxsJiZpPHMubWluTkRpbSl0aHJvdyBuZXcgVihgSW5wdXQgJHthfSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX06IGV4cGVjdGVkIG1pbl9uZGltPSR7cy5taW5ORGltfSwgZm91bmQgbmRpbT0ke2l9LmApO2lmKHMuZHR5cGUhPW51bGwmJnIuZHR5cGUhPT1zLmR0eXBlKXRocm93IG5ldyBWKGBJbnB1dCAke2F9IGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyICR7dGhpcy5uYW1lfSA6IGV4cGVjdGVkIGR0eXBlPSR7cy5kdHlwZX0sIGZvdW5kIGR0eXBlPSR7ci5kdHlwZX0uYCk7aWYocy5heGVzKXtsZXQgbz1yLnNoYXBlO2ZvcihsZXQgbCBpbiBzLmF4ZXMpe2xldCB1PU51bWJlcihsKSxwPXMuYXhlc1tsXSxkPXU+PTA/b1t1XTpvW28ubGVuZ3RoK3VdO2lmKHAhPW51bGwmJltwLG51bGxdLmluZGV4T2YoZCk9PT0tMSl0aHJvdyBuZXcgVihgSW5wdXQgJHthfSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX06IGV4cGVjdGVkIGF4aXMgJHt1fSBvZiBpbnB1dCBzaGFwZSB0byBoYXZlIHZhbHVlICR7cH0gYnV0IGdvdCBzaGFwZSAke299LmApfX1pZihzLnNoYXBlIT1udWxsKWZvcihsZXQgbz0wO288cy5zaGFwZS5sZW5ndGg7KytvKXtsZXQgbD1zLnNoYXBlW29dLHU9ci5zaGFwZVtvXTtpZihsIT1udWxsJiZ1IT1udWxsJiZsIT09dSl0aHJvdyBuZXcgVihgSW5wdXQgJHthfSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX06IGV4cGVjdGVkIHNoYXBlPSR7cy5zaGFwZX0sIGZvdW5kIHNoYXBlPSR7ci5zaGFwZX0uYCl9fX1jYWxsKGUsdCl7cmV0dXJuIGV9aW52b2tlQ2FsbEhvb2soZSx0KXt0aGlzLl9jYWxsSG9vayE9bnVsbCYmdGhpcy5fY2FsbEhvb2soZSx0KX1zZXRDYWxsSG9vayhlKXt0aGlzLl9jYWxsSG9vaz1lfWNsZWFyQ2FsbEhvb2soKXt0aGlzLl9jYWxsSG9vaz1udWxsfWFwcGx5KGUsdCl7dD10fHx7fSx0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7bGV0IG49aXQoZSksYT1HRyhlKSxyPUhHKGUpO2lmKGE9PT1yKXRocm93IG5ldyBWKFwiQXJndW1lbnRzIHRvIGFwcGx5KCkgbXVzdCBiZSBhbGwgU3ltYm9saWNUZW5zb3JzIG9yIGFsbCBUZW5zb3JzXCIpO3JldHVybiByaSh0aGlzLm5hbWUsKCk9PntpZighdGhpcy5idWlsdCl7dGhpcy5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHkoZSk7bGV0IHM9W107Zm9yKGxldCBpIG9mIGl0KGUpKXMucHVzaChpLnNoYXBlKTt0aGlzLmJ1aWxkKE1uKHMpKSx0aGlzLmJ1aWx0PSEwLHRoaXMuaW5pdGlhbFdlaWdodHMmJnRoaXMuc2V0V2VpZ2h0cyh0aGlzLmluaXRpYWxXZWlnaHRzKSx0aGlzLl9yZWZDb3VudD09PW51bGwmJnImJih0aGlzLl9yZWZDb3VudD0xKX1pZih0aGlzLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eShlKSxyKXtsZXQgcz10aGlzLmNhbGwoZSx0KTt0aGlzLnN1cHBvcnRzTWFza2luZyYmdGhpcy5zZXRNYXNrTWV0YWRhdGEoZSxzKTtsZXQgaT1pdChzKSxvPVtdO2ZvcihsZXQgbCBvZiBpKW4uaW5kZXhPZihsKSE9PS0xJiYobD1sLmNsb25lKCkpLG8ucHVzaChsKTtpZihzPU1uKG8pLHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciE9bnVsbCl0aHJvdyBuZXcgemUoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIHN9ZWxzZXtsZXQgcz1WRyhlKSxpPXRoaXMuY29tcHV0ZU91dHB1dFNoYXBlKHMpLG8sbD1VRyhlKTtpZih0aGlzLndhcm5PbkluY29tcGF0aWJsZUlucHV0U2hhcGUoQXJyYXkuaXNBcnJheShlKT9zWzBdOnMpLGkhPW51bGwmJmkubGVuZ3RoPjAmJkFycmF5LmlzQXJyYXkoaVswXSk/bz1pLm1hcCgodSxwKT0+bmV3IEhhKGwsdSx0aGlzLGl0KGUpLHQsdGhpcy5uYW1lLHApKTpvPW5ldyBIYShsLGksdGhpcyxpdChlKSx0LHRoaXMubmFtZSksdGhpcy5hZGRJbmJvdW5kTm9kZShlLG8sbnVsbCxudWxsLHMsaSx0KSx0aGlzLl9yZWZDb3VudCsrLHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciE9bnVsbCl0aHJvdyBuZXcgemUoXCJMYXllciBpbnZvY2F0aW9uIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7cmV0dXJuIG99fSl9d2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZShlKXtpZih0aGlzLmJhdGNoSW5wdXRTaGFwZSE9bnVsbClpZihlLmxlbmd0aCE9PXRoaXMuYmF0Y2hJbnB1dFNoYXBlLmxlbmd0aCljb25zb2xlLndhcm4oYFRoZSByYW5rIG9mIHRoZSBpbnB1dCB0ZW5zb3IgcHJvdmlkZWQgKHNoYXBlOiAke0pTT04uc3RyaW5naWZ5KGUpfSkgZG9lcyBub3QgbWF0Y2ggdGhhdCBvZiB0aGUgYmF0Y2hJbnB1dFNoYXBlICgke0pTT04uc3RyaW5naWZ5KHRoaXMuYmF0Y2hJbnB1dFNoYXBlKX0pIG9mIHRoZSBsYXllciAke3RoaXMubmFtZX1gKTtlbHNle2xldCB0PSExO3RoaXMuYmF0Y2hJbnB1dFNoYXBlLmZvckVhY2goKG4sYSk9PntuIT1udWxsJiZlW2FdIT1udWxsJiZlW2FdIT09biYmKHQ9ITApfSksdCYmY29uc29sZS53YXJuKGBUaGUgc2hhcGUgb2YgdGhlIGlucHV0IHRlbnNvciAoJHtKU09OLnN0cmluZ2lmeShlKX0pIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RhdGlvbiBvZiBsYXllciAke3RoaXMubmFtZX06ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5iYXRjaElucHV0U2hhcGUpfWApfX1nZXQgb3V0cHV0U2hhcGUoKXtpZih0aGlzLmluYm91bmROb2Rlcz09bnVsbHx8dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoPT09MCl0aHJvdyBuZXcgWHIoYFRoZSBsYXllciAke3RoaXMubmFtZX0gaGFzIG5ldmVyIGJlZW4gY2FsbGVkIGFuZCB0aHVzIGhhcyBubyBkZWZpbmVkIG91dHB1dCBzaGFwZS5gKTtsZXQgZT1bXTtmb3IobGV0IHQgb2YgdGhpcy5pbmJvdW5kTm9kZXMpe2xldCBuPUpTT04uc3RyaW5naWZ5KHQub3V0cHV0U2hhcGVzKTtlLmluZGV4T2Yobik9PT0tMSYmZS5wdXNoKG4pfWlmKGUubGVuZ3RoPT09MSl7bGV0IHQ9dGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzO3JldHVybiBBcnJheS5pc0FycmF5KHQpJiZBcnJheS5pc0FycmF5KHRbMF0pJiZ0Lmxlbmd0aD09PTE/dFswXTp0fWVsc2UgdGhyb3cgbmV3IFhyKGBUaGUgbGF5ZXIgJHt0aGlzLm5hbWV9IGhhcyBtdWx0aXBsZSBpbmJvdW5kIG5vZGVzIHdpdGggZGlmZmVyZW50IG91dHB1dCBzaGFwZXMuIEhlbmNlIHRoZSBub3Rpb24gb2YgXCJvdXRwdXQgc2hhcGVcIiBpcyBpbGwtZGVmaW5lZCBmb3IgdGhlIGxheWVyLmApfWNvdW50UGFyYW1zKCl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IGFyKGBZb3UgdHJpZWQgdG8gY2FsbCBjb3VudFBhcmFtcygpIG9uICR7dGhpcy5uYW1lfSwgYnV0IHRoZSBsYXllciBpcyBub3QgYnVpbHQgeWV0LiBCdWlsZCBpdCBmaXJzdCBieSBjYWxsaW5nIGJ1aWxkKGJhdGNoSW5wdXRTaGFwZSkuYCk7cmV0dXJuIEpoKHRoaXMud2VpZ2h0cyl9YnVpbGQoZSl7dGhpcy5idWlsdD0hMH1nZXRXZWlnaHRzKGU9ITEpe3JldHVybiBVeChlP3RoaXMudHJhaW5hYmxlV2VpZ2h0czp0aGlzLndlaWdodHMpfXNldFdlaWdodHMoZSl7TygoKT0+e2xldCB0PXRoaXMud2VpZ2h0cztpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBWKGBZb3UgY2FsbGVkIHNldFdlaWdodHMod2VpZ2h0cykgb24gbGF5ZXIgXCIke3RoaXMubmFtZX1cIiB3aXRoIGEgd2VpZ2h0IGxpc3Qgb2YgbGVuZ3RoICR7ZS5sZW5ndGh9LCBidXQgdGhlIGxheWVyIHdhcyBleHBlY3RpbmcgJHt0Lmxlbmd0aH0gd2VpZ2h0cy4gUHJvdmlkZWQgd2VpZ2h0czogJHtlfS4uLmApO2lmKHQubGVuZ3RoPT09MClyZXR1cm47bGV0IG49W10sYT1VeCh0KTtmb3IobGV0IHI9MDtyPGEubGVuZ3RoOysrcil7bGV0IHM9YVtyXSxpPXRbcl0sbz1lW3JdO2lmKCF3LmFycmF5c0VxdWFsKHMuc2hhcGUsby5zaGFwZSkpdGhyb3cgbmV3IFYoYExheWVyIHdlaWdodCBzaGFwZSAke3Muc2hhcGV9IG5vdCBjb21wYXRpYmxlIHdpdGggcHJvdmlkZWQgd2VpZ2h0IHNoYXBlICR7by5zaGFwZX1gKTtuLnB1c2goW2ksb10pfXUwKG4pfSl9YWRkV2VpZ2h0KGUsdCxuLGEscixzLGksbyl7aWYodGhpcy5fYWRkZWRXZWlnaHROYW1lcy5pbmRleE9mKGUpIT09LTEpdGhyb3cgbmV3IFYoYER1cGxpY2F0ZSB3ZWlnaHQgbmFtZSAke2V9IGZvciBsYXllciAke3RoaXMubmFtZX1gKTt0aGlzLl9hZGRlZFdlaWdodE5hbWVzLnB1c2goZSksbj09bnVsbCYmKG49XCJmbG9hdDMyXCIpLHRoaXMuZmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCYmKGE9byE9bnVsbD9vKCk6U3QoXCJ6ZXJvc1wiKSk7bGV0IGw9YS5hcHBseSh0LG4pLHU9bmV3IGsyKGwsbixlLHMsaSk7cmV0dXJuIGwuZGlzcG9zZSgpLHIhPW51bGwmJnRoaXMuYWRkTG9zcygoKT0+ci5hcHBseSh1LnJlYWQoKSkpLHM9PW51bGwmJihzPSEwKSxzP3RoaXMuX3RyYWluYWJsZVdlaWdodHMucHVzaCh1KTp0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzLnB1c2godSksdX1zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKGUpe3RoaXMuZmFzdFdlaWdodEluaXREdXJpbmdCdWlsZD1lfWFkZExvc3MoZSl7ZT09bnVsbHx8QXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg9PT0wfHwoZT1pdChlKSx0aGlzLl9sb3NzZXMhPT12b2lkIDAmJnRoaXMuX2xvc3NlcyE9PW51bGwmJnRoaXMubG9zc2VzLnB1c2goLi4uZSkpfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtyZXR1cm4gZX1jb21wdXRlTWFzayhlLHQpe2lmKCF0aGlzLnN1cHBvcnRzTWFza2luZyl7aWYodCE9bnVsbClpZihBcnJheS5pc0FycmF5KHQpKXQuZm9yRWFjaChuPT57aWYobiE9bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKGBMYXllciAke3RoaXMubmFtZX0gZG9lcyBub3Qgc3VwcG9ydCBtYXNraW5nLCBidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suYCl9KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYExheWVyICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBzdXBwb3J0IG1hc2tpbmcsIGJ1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay5gKTtyZXR1cm4gbnVsbH1yZXR1cm4gdH1zZXRNYXNrTWV0YWRhdGEoZSx0LG4pe2lmKCF0aGlzLnN1cHBvcnRzTWFza2luZylyZXR1cm47bGV0IGE9dGhpcy5jb21wdXRlTWFzayhlLG4pLHI9aXQodCkscz1pdChhKTtpZihyLmxlbmd0aCE9PXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9IG91dHB1dHMgJHtyLmxlbmd0aH0gdGVuc29ycyBidXQgJHtyLmxlbmd0aH0gbWFza3MgZm9yIHRob3NlIHRlbnNvcnNgKTtmb3IobGV0IGk9MDtpPHIubGVuZ3RoO2krKylyW2ldLmtlcmFzTWFzaz1zW2ldfWFkZEluYm91bmROb2RlKGUsdCxuLGEscixzLGk9bnVsbCl7bGV0IG89aXQoZSk7dD1pdCh0KSxuPWl0KG4pLGE9aXQoYSkscj1aaChyKSxzPVpoKHMpO2xldCBsPVtdLHU9W10scD1bXTtmb3IobGV0IGQgb2YgbylsLnB1c2goZC5zb3VyY2VMYXllciksdS5wdXNoKGQubm9kZUluZGV4KSxwLnB1c2goZC50ZW5zb3JJbmRleCk7bmV3IE5mKHtvdXRib3VuZExheWVyOnRoaXMsaW5ib3VuZExheWVyczpsLG5vZGVJbmRpY2VzOnUsdGVuc29ySW5kaWNlczpwLGlucHV0VGVuc29yczpvLG91dHB1dFRlbnNvcnM6dCxpbnB1dE1hc2tzOm4sb3V0cHV0TWFza3M6YSxpbnB1dFNoYXBlczpyLG91dHB1dFNoYXBlczpzfSxpKTtmb3IobGV0IGQ9MDtkPHQubGVuZ3RoO2QrKyl0W2RdLnNvdXJjZUxheWVyPXRoaXMsdFtkXS5ub2RlSW5kZXg9dGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoLTEsdFtkXS50ZW5zb3JJbmRleD1kfWdldENvbmZpZygpe2xldCBlPXtuYW1lOnRoaXMubmFtZSx0cmFpbmFibGU6dGhpcy50cmFpbmFibGV9O3JldHVybiB0aGlzLmJhdGNoSW5wdXRTaGFwZSE9bnVsbCYmKGUuYmF0Y2hJbnB1dFNoYXBlPXRoaXMuYmF0Y2hJbnB1dFNoYXBlKSx0aGlzLmR0eXBlIT1udWxsJiYoZS5kdHlwZT10aGlzLmR0eXBlKSxlfWRpc3Bvc2VXZWlnaHRzKCl7cmV0dXJuIHRoaXMud2VpZ2h0cy5mb3JFYWNoKGU9PmUuZGlzcG9zZSgpKSx0aGlzLndlaWdodHMubGVuZ3RofWFzc2VydE5vdERpc3Bvc2VkKCl7aWYodGhpcy5fcmVmQ291bnQ9PT0wKXRocm93IG5ldyBFcnJvcihgTGF5ZXIgJyR7dGhpcy5uYW1lfScgaXMgYWxyZWFkeSBkaXNwb3NlZC5gKX1kaXNwb3NlKCl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGlzcG9zZSBMYXllciAke3RoaXMubmFtZX0gYmVjYXVzZSBpdCBoYXMgbm90IGJlZW4gYnVpbHQgeWV0LmApO2lmKHRoaXMuX3JlZkNvdW50PT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkaXNwb3NlIExheWVyICR7dGhpcy5uYW1lfSBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiB1c2VkIHlldC5gKTt0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7bGV0IGU9MDtyZXR1cm4tLXRoaXMuX3JlZkNvdW50PT09MCYmKGU9dGhpcy5kaXNwb3NlV2VpZ2h0cygpKSx7cmVmQ291bnRBZnRlckRpc3Bvc2U6dGhpcy5fcmVmQ291bnQsbnVtRGlzcG9zZWRWYXJpYWJsZXM6ZX19fTtmdW5jdGlvbiBWRyhlKXtlPWl0KGUpO2xldCB0PVtdO2ZvcihsZXQgbiBvZiBlKXQucHVzaChuLnNoYXBlKTtyZXR1cm4gTW4odCl9ZnVuY3Rpb24gVUcoZSl7cmV0dXJuXCJmbG9hdDMyXCJ9ZnVuY3Rpb24gSTIoZSx0LG4pe2lmKCh0PT1udWxsfHxuIT1udWxsJiZuPjApJiYodD1lLnNvdXJjZUxheWVyLG49ZS5ub2RlSW5kZXgpLHQuaW5ib3VuZE5vZGVzLmxlbmd0aD09PTApcmV0dXJuW2VdO3tsZXQgYT10LmluYm91bmROb2Rlc1tuXTtpZihhLmluYm91bmRMYXllcnMubGVuZ3RoPT09MClyZXR1cm4gYS5pbnB1dFRlbnNvcnM7e2xldCByPVtdO2ZvcihsZXQgcz0wO3M8YS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtzKyspe2xldCBpPWEuaW5wdXRUZW5zb3JzW3NdLG89YS5pbmJvdW5kTGF5ZXJzW3NdLGw9YS5ub2RlSW5kaWNlc1tzXSx1PUkyKGksbyxsKTtmb3IobGV0IHAgb2YgdSlyLmluZGV4T2YocCk9PT0tMSYmci5wdXNoKHApfXJldHVybiByfX19ZnVuY3Rpb24gR0coZSl7bGV0IHQ9ITA7Zm9yKGxldCBuIG9mIGl0KGUpKWlmKCEobiBpbnN0YW5jZW9mIEhhKSl7dD0hMTticmVha31yZXR1cm4gdH1mdW5jdGlvbiBIRyhlKXtsZXQgdD0hMDtmb3IobGV0IG4gb2YgaXQoZSkpaWYobiBpbnN0YW5jZW9mIEhhKXt0PSExO2JyZWFrfXJldHVybiB0fXZhciBycD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKHtkdHlwZTplLmR0eXBlLG5hbWU6ZS5uYW1lIT1udWxsP2UubmFtZTpnZihcImlucHV0XCIpLnRvU3RyaW5nKCl9KSxlLmJhdGNoU2l6ZT09bnVsbCYmKGUuYmF0Y2hTaXplPW51bGwpLGUuc3BhcnNlPT1udWxsJiYoZS5zcGFyc2U9ITEpLHRoaXMudHJhaW5hYmxlPSExLHRoaXMuYnVpbHQ9ITAsdGhpcy5zcGFyc2U9ZS5zcGFyc2UsZS5pbnB1dFNoYXBlIT1udWxsJiZlLmJhdGNoSW5wdXRTaGFwZSE9bnVsbCl0aHJvdyBuZXcgVihcIk9ubHkgcHJvdmlkZSB0aGUgaW5wdXRTaGFwZSBPUiBiYXRjaElucHV0U2hhcGUgYXJndW1lbnQgdG8gaW5wdXRMYXllciwgbm90IGJvdGggYXQgdGhlIHNhbWUgdGltZS5cIik7bGV0IHQ9ZS5iYXRjaElucHV0U2hhcGU7aWYodD09bnVsbCl7aWYoZS5pbnB1dFNoYXBlPT1udWxsKXRocm93IG5ldyBWKFwiQW4gSW5wdXRMYXllciBzaG91bGQgYmUgcGFzc2VkIGVpdGhlciBhIGBiYXRjaElucHV0U2hhcGVgIG9yIGFuIGBpbnB1dFNoYXBlYC5cIik7dD1bZS5iYXRjaFNpemVdLmNvbmNhdChlLmlucHV0U2hhcGUpfWVsc2UgaWYoZS5iYXRjaFNpemUhPW51bGwpdGhyb3cgbmV3IFYoXCJDYW5ub3Qgc3BlY2lmeSBiYXRjaFNpemUgaWYgYmF0Y2hJbnB1dFNoYXBlIGlzIHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGFuIElucHV0TGF5ZXIuXCIpO2xldCBuPWUuZHR5cGV8fFwiZmxvYXQzMlwiO3RoaXMuYmF0Y2hJbnB1dFNoYXBlPXQsdGhpcy5kdHlwZT1uLHRoaXMuaW5wdXRTcGVjPVt7c2hhcGU6dH1dO2xldCBhPW5ldyBIYSh0aGlzLmR0eXBlLHRoaXMuYmF0Y2hJbnB1dFNoYXBlLHRoaXMsW10se30sdGhpcy5uYW1lKTthLm5vZGVJbmRleD0wLGEudGVuc29ySW5kZXg9MCxuZXcgTmYoe291dGJvdW5kTGF5ZXI6dGhpcyxpbmJvdW5kTGF5ZXJzOltdLG5vZGVJbmRpY2VzOltdLHRlbnNvckluZGljZXM6W10saW5wdXRUZW5zb3JzOlthXSxvdXRwdXRUZW5zb3JzOlthXSxpbnB1dE1hc2tzOltudWxsXSxvdXRwdXRNYXNrczpbbnVsbF0saW5wdXRTaGFwZXM6W3RdLG91dHB1dFNoYXBlczpbdF19KX1hcHBseShlLHQpe3Rocm93IG5ldyBWKGBDYW5ub3QgcGFzcyBhbnkgaW5wdXQgdG8gYW4gSW5wdXRMYXllcidzIGFwcGx5KCkgbWV0aG9kLiBJbnB1dExheWVyIG5hbWU6ICR7dGhpcy5uYW1lfWApfWRpc3Bvc2UoKXtyZXR1cm57cmVmQ291bnRBZnRlckRpc3Bvc2U6dGhpcy5fcmVmQ291bnQsbnVtRGlzcG9zZWRWYXJpYWJsZXM6MH19Z2V0Q29uZmlnKCl7cmV0dXJue2JhdGNoSW5wdXRTaGFwZTp0aGlzLmJhdGNoSW5wdXRTaGFwZSxkdHlwZTp0aGlzLmR0eXBlLHNwYXJzZTp0aGlzLnNwYXJzZSxuYW1lOnRoaXMubmFtZX19fTtycC5jbGFzc05hbWU9XCJJbnB1dExheWVyXCI7bmUucmVnaXN0ZXJDbGFzcyhycCk7ZnVuY3Rpb24gUzIoZSl7aWYoZS5iYXRjaFNoYXBlPT1udWxsJiZlLnNoYXBlPT1udWxsKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIHRvIElucHV0IGVpdGhlciBhIGBzaGFwZWAgb3IgYSBgYmF0Y2hTaGFwZWAgYXJndW1lbnQuIE5vdGUgdGhhdCBgc2hhcGVgIGRvZXMgbm90IGluY2x1ZGUgdGhlIGJhdGNoIGRpbWVuc2lvbi5cIik7aWYoZS5iYXRjaFNoYXBlIT1udWxsJiZlLnNoYXBlIT1udWxsKXRocm93IG5ldyBWKFwiUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHNoYXBlYCBvciBgYmF0Y2hTaGFwZWAgYXJndW1lbnQgdG8gSW5wdXQsIGJ1dCBub3QgYm90aC5cIik7bGV0IHQ9ZS5iYXRjaFNoYXBlO2Uuc2hhcGUhPW51bGwmJnQ9PW51bGwmJih0PVtudWxsXS5jb25jYXQoZS5zaGFwZSkpO2xldCBuPWUuZHR5cGU7cmV0dXJuIG49PW51bGwmJihuPVwiZmxvYXQzMlwiKSxuZXcgcnAoe2JhdGNoSW5wdXRTaGFwZTp0LG5hbWU6ZS5uYW1lLGR0eXBlOm4sc3BhcnNlOmUuc3BhcnNlfSkuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF19ZnVuY3Rpb24gakcoZSx0KXtpZihlLmR0eXBlPT1udWxsfHxlLmR0eXBlPT09dC5kdHlwZSlyZXR1cm4gdDt0cnl7cmV0dXJuIHJlKHQsZS5kdHlwZSl9Y2F0Y2gobil7dGhyb3cgbmV3IFYoYFRoZSBkdHlwZSBvZiB0aGUgZmVlZCAoJHt0LmR0eXBlfSkgY2FuIG5vdCBiZSBjYXN0IHRvIHRoZSBkdHlwZSBvZiB0aGUga2V5ICcke2UubmFtZX0nICgke2UuZHR5cGV9KS5gKX19dmFyIENsPWNsYXNzIE4ye2NvbnN0cnVjdG9yKHQpe2lmKHRoaXMuaWQyVmFsdWU9e30sdGhpcy5pZDJNYXNrPXt9LHRoaXMubmFtZTJJZD17fSx0IGluc3RhbmNlb2YgTjIpZm9yKGxldCBuIGluIHQuaWQyVmFsdWUpdGhpcy5pZDJWYWx1ZVtuXT10LmlkMlZhbHVlW25dLG4gaW4gdC5pZDJNYXNrJiYodGhpcy5pZDJNYXNrW25dPXQuaWQyTWFza1tuXSk7ZWxzZXtpZih0PT1udWxsKXJldHVybjtmb3IobGV0IG4gb2YgdCl0aGlzLmFkZChuLmtleSxuLnZhbHVlKX19YWRkKHQsbixhKXtpZih0aGlzLmlkMlZhbHVlW3QuaWRdPT1udWxsKXRoaXMuaWQyVmFsdWVbdC5pZF09akcodCxuKSx0aGlzLm5hbWUySWRbdC5uYW1lXT10LmlkLGEhPW51bGwmJih0aGlzLmlkMk1hc2tbdC5pZF09YSk7ZWxzZSB0aHJvdyBuZXcgVihgRHVwbGljYXRlIGtleTogbmFtZT0ke3QubmFtZX0sIGlkPSR7dC5pZH1gKTtyZXR1cm4gdGhpc31hZGRGZWVkKHQpe3RoaXMuYWRkKHQua2V5LHQudmFsdWUpfWhhc0tleSh0KXtyZXR1cm4gdGhpcy5pZDJWYWx1ZVt0LmlkXSE9bnVsbH1uYW1lcygpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hbWUySWQpfWdldFZhbHVlKHQpe2lmKHQgaW5zdGFuY2VvZiBIYSl7aWYodGhpcy5pZDJWYWx1ZVt0LmlkXT09bnVsbCl0aHJvdyBuZXcgVihgTm9uZXhpc3RlbnQga2V5OiAke3QubmFtZX1gKTtyZXR1cm4gdGhpcy5pZDJWYWx1ZVt0LmlkXX1lbHNle2xldCBuPXRoaXMubmFtZTJJZFt0XTtpZihuPT1udWxsKXRocm93IG5ldyBWKGBGZWVkIGRpY3QgaGFzIG5vIFN5bWJvbGljVGVuc29yIG5hbWU6ICR7dH1gKTtyZXR1cm4gdGhpcy5pZDJWYWx1ZVtuXX19Z2V0TWFzayh0KXtpZih0IGluc3RhbmNlb2YgSGEpe2lmKHRoaXMuaWQyVmFsdWVbdC5pZF09PW51bGwpdGhyb3cgbmV3IFYoYE5vbmV4aXN0ZW50IGtleTogJHt0Lm5hbWV9YCk7cmV0dXJuIHRoaXMuaWQyTWFza1t0LmlkXX1lbHNle2xldCBuPXRoaXMubmFtZTJJZFt0XTtpZihuPT1udWxsKXRocm93IG5ldyBWKGBGZWVkIGRpY3QgaGFzIG5vIFN5bWJvbGljVGVuc29yIG5hbWU6ICR7dH1gKTtyZXR1cm4gdGhpcy5pZDJNYXNrW25dfX1kaXNwb3NlTWFza3MoKXt0aGlzLmlkMk1hc2shPW51bGwmJkVlKHRoaXMuaWQyTWFzayl9fSxRaD1uZXcgZDIsZW09bmV3IGQyO2Z1bmN0aW9uIHFHKGUpe1FoIT1udWxsJiZRaC5zZXRNYXhFbnRyaWVzKGUpLGVtIT1udWxsJiZlbS5zZXRNYXhFbnRyaWVzKGUpfWZ1bmN0aW9uIHRjKGUsdCxuLGEpe2xldCByPW49PW51bGw/ITE6bi50cmFpbmluZyxzPUFycmF5LmlzQXJyYXkoZSksaT1zP2U6W2VdLG89aS5tYXAobT0+bS5uYW1lKSxsPVtdLHU9dC5uYW1lcygpO2ZvcihsZXQgbSBvZiBvKXUuaW5kZXhPZihtKSE9PS0xP2wucHVzaCh0LmdldFZhbHVlKG0pKTpsLnB1c2gobnVsbCk7YSE9bnVsbCYmKGEubWF4TnVtVGVuc29ycz0tMS8wLGEubWluTnVtVGVuc29ycz0xLzApO2xldCBwPW8uam9pbihcIixcIikrXCJ8XCIrdC5uYW1lcygpLnNvcnQoKS5qb2luKFwiLFwiKSxkPVFoLmdldChwKSxjO2lmKGQ9PW51bGwpe2xldCBtPUtHKGksdCk7ZD1tLnNvcnRlZCxjPW0ucmVjaXBpZW50Q291bnRzLFFoLnB1dChwLGQpLGVtLnB1dChwLGMpfWM9e30scnx8T2JqZWN0LmFzc2lnbihjLGVtLmdldChwKSk7bGV0IGg9bmV3IENsKHQpO2ZvcihsZXQgbT0wO208ZC5sZW5ndGg7KyttKXtpZihhIT1udWxsKXtsZXQgRj1LaCgpLm51bVRlbnNvcnM7Rj5hLm1heE51bVRlbnNvcnMmJihhLm1heE51bVRlbnNvcnM9RiksRjxhLm1pbk51bVRlbnNvcnMmJihhLm1pbk51bVRlbnNvcnM9Ril9bGV0IGY9ZFttXSxnPWYuc291cmNlTGF5ZXI7aWYoZyBpbnN0YW5jZW9mIHJwKWNvbnRpbnVlO2xldCBiPVtdLHk9W10seD1bXSx2PSExO2ZvcihsZXQgRiBvZiBmLmlucHV0cyl7bGV0IEQ9aC5nZXRWYWx1ZShGKSwkPWguZ2V0TWFzayhGKTtiLnB1c2goRCkseS5wdXNoKCQpLCQhPW51bGwmJih2PSEwKSxyfHwoY1tGLm5hbWVdLS0sY1tGLm5hbWVdPT09MCYmIXQuaGFzS2V5KEYpJiZvLmluZGV4T2YoRi5uYW1lKT09PS0xJiYhRC5pc0Rpc3Bvc2VkJiZGLnNvdXJjZUxheWVyLnN0YXRlZnVsIT09ITAmJngucHVzaChEKSl9diYmKG49bnx8e30sbi5tYXNrPXlbMF0pO2xldCBJPWl0KGcuYXBwbHkoYixuKSksTj1udWxsO2cuc3VwcG9ydHNNYXNraW5nJiYoTj1nLmNvbXB1dGVNYXNrKGIseSkpO2xldCBDPVlHKGYpLF89QXJyYXkuaXNBcnJheShDKT9DOltDXTtmb3IobGV0IEY9MDtGPF8ubGVuZ3RoOysrRil7aC5oYXNLZXkoX1tGXSl8fGguYWRkKF9bRl0sSVtGXSxBcnJheS5pc0FycmF5KE4pP05bMF06Tik7bGV0IEQ9by5pbmRleE9mKF9bRl0ubmFtZSk7RCE9PS0xJiYobFtEXT1JW0ZdKX1yfHxFZSh4KX1yZXR1cm4gaC5kaXNwb3NlTWFza3MoKSxzP2w6bFswXX1mdW5jdGlvbiBLRyhlLHQpe3cuYXNzZXJ0KGUhPW51bGwmJmUubGVuZ3RoPjAsKCk9PlwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGZldGNoLCBnb3Qgbm9uZVwiKTtsZXQgbj1bXSxhPXt9O2lmKGUubGVuZ3RoPT09MSl7bGV0IHI9d0koZVswXSx0KTtuPXIuc29ydGVkLGE9ci5yZWNpcGllbnRNYXB9ZWxzZXtsZXQgcj1uZXcgU2V0O2ZvcihsZXQgcyBvZiBlKXtsZXR7c29ydGVkOmkscmVjaXBpZW50TWFwOm99PXdJKHMsdCk7Zm9yKGxldCBsIG9mIGkpci5oYXMobC5uYW1lKXx8KG4ucHVzaChsKSxyLmFkZChsLm5hbWUpKTtmb3IobGV0IGwgaW4gbylhW2xdPT1udWxsJiYoYVtsXT1uZXcgU2V0KSxvW2xdLmZvckVhY2godT0+YVtsXS5hZGQodSkpfX1yZXR1cm57c29ydGVkOm4scmVjaXBpZW50Q291bnRzOlhHKGEpfX1mdW5jdGlvbiBYRyhlKXtsZXQgdD17fTtmb3IobGV0IG4gaW4gZSl0W25dPWVbbl0uc2l6ZTtyZXR1cm4gdH1mdW5jdGlvbiB3SShlLHQpe2xldCBuPW5ldyBTZXQsYT1bXSxyPXt9O2ZvcihsZXQgbyBvZiB0Lm5hbWVzKCkpbi5hZGQobyk7bGV0IHM9W10saT1bXTtmb3Iocy5wdXNoKGUpO3MubGVuZ3RoPjA7KXtsZXQgbz1zW3MubGVuZ3RoLTFdO2lmKG4uaGFzKG8ubmFtZSkpe3MucG9wKCk7Y29udGludWV9bGV0IGw9aVtpLmxlbmd0aC0xXT09PXMubGVuZ3RoLTE7aWYoby5pbnB1dHMubGVuZ3RoPT09MHx8bClzLnBvcCgpLGEucHVzaChvKSxuLmFkZChvLm5hbWUpLGwmJmkucG9wKCk7ZWxzZXtpLnB1c2gocy5sZW5ndGgtMSk7Zm9yKGxldCB1IG9mIG8uaW5wdXRzKXJbdS5uYW1lXT09bnVsbCYmKHJbdS5uYW1lXT1uZXcgU2V0KSxyW3UubmFtZV0uYWRkKG8ubmFtZSksIW4uaGFzKHUubmFtZSkmJnMucHVzaCh1KX19cmV0dXJue3NvcnRlZDphLHJlY2lwaWVudE1hcDpyfX1mdW5jdGlvbiBZRyhlKXtsZXQgdDtpZihlLnNvdXJjZUxheWVyLmluYm91bmROb2Rlcy5sZW5ndGg9PT0xKXQ9ZS5zb3VyY2VMYXllci5vdXRwdXQ7ZWxzZXtsZXQgbj1udWxsO2ZvcihsZXQgYT0wO2E8ZS5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOysrYSlmb3IobGV0IHIgb2YgZS5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXNbYV0ub3V0cHV0VGVuc29ycylpZihyLmlkPT09ZS5pZCl7bj1hO2JyZWFrfXQ9ZS5zb3VyY2VMYXllci5nZXRPdXRwdXRBdChuKX1yZXR1cm4gdH12YXIgWkc9RygpO1pHLnJlZ2lzdGVyRmxhZyhcIlRPUE9MT0dJQ0FMX1NPUlRfQ0FDSEVfTUFYX0VOVFJJRVNcIiwoKT0+MTAwLHFHKTt2YXIgVDI9e307X2UoVDIse21heE5vcm06KCk9PkpHLG1pbk1heE5vcm06KCk9PnRILG5vbk5lZzooKT0+ZUgsdW5pdE5vcm06KCk9PlFHfSk7ZnVuY3Rpb24gcDAoZSx0KXtyZXR1cm4gTygoKT0+cm4oZmUoeihlLGUpLHQsITApKSl9dmFyIFNkPWNsYXNzIGV4dGVuZHMgbmUuU2VyaWFsaXphYmxle2dldENvbmZpZygpe3JldHVybnt9fX0sYzA9Y2xhc3MgZXh0ZW5kcyBTZHtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuZGVmYXVsdE1heFZhbHVlPTIsdGhpcy5kZWZhdWx0QXhpcz0wLHRoaXMubWF4VmFsdWU9ZS5tYXhWYWx1ZSE9bnVsbD9lLm1heFZhbHVlOnRoaXMuZGVmYXVsdE1heFZhbHVlLHRoaXMuYXhpcz1lLmF4aXMhPW51bGw/ZS5heGlzOnRoaXMuZGVmYXVsdEF4aXN9YXBwbHkoZSl7cmV0dXJuIE8oKCk9PntsZXQgdD1wMChlLHRoaXMuYXhpcyksbj1hbih0LDAsdGhpcy5tYXhWYWx1ZSk7cmV0dXJuIHooZSxoZShuLFgocXQoKSx0KSkpfSl9Z2V0Q29uZmlnKCl7cmV0dXJue21heFZhbHVlOnRoaXMubWF4VmFsdWUsYXhpczp0aGlzLmF4aXN9fX07YzAuY2xhc3NOYW1lPVwiTWF4Tm9ybVwiO25lLnJlZ2lzdGVyQ2xhc3MoYzApO3ZhciBkMD1jbGFzcyBleHRlbmRzIFNke2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5kZWZhdWx0QXhpcz0wLHRoaXMuYXhpcz1lLmF4aXMhPW51bGw/ZS5heGlzOnRoaXMuZGVmYXVsdEF4aXN9YXBwbHkoZSl7cmV0dXJuIE8oKCk9PmhlKGUsWChxdCgpLHAwKGUsdGhpcy5heGlzKSkpKX1nZXRDb25maWcoKXtyZXR1cm57YXhpczp0aGlzLmF4aXN9fX07ZDAuY2xhc3NOYW1lPVwiVW5pdE5vcm1cIjtuZS5yZWdpc3RlckNsYXNzKGQwKTt2YXIgaDA9Y2xhc3MgZXh0ZW5kcyBTZHthcHBseShlKXtyZXR1cm4gS2UoZSl9fTtoMC5jbGFzc05hbWU9XCJOb25OZWdcIjtuZS5yZWdpc3RlckNsYXNzKGgwKTt2YXIgbTA9Y2xhc3MgZXh0ZW5kcyBTZHtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuZGVmYXVsdE1pblZhbHVlPTAsdGhpcy5kZWZhdWx0TWF4VmFsdWU9MSx0aGlzLmRlZmF1bHRSYXRlPTEsdGhpcy5kZWZhdWx0QXhpcz0wLHRoaXMubWluVmFsdWU9ZS5taW5WYWx1ZSE9bnVsbD9lLm1pblZhbHVlOnRoaXMuZGVmYXVsdE1pblZhbHVlLHRoaXMubWF4VmFsdWU9ZS5tYXhWYWx1ZSE9bnVsbD9lLm1heFZhbHVlOnRoaXMuZGVmYXVsdE1heFZhbHVlLHRoaXMucmF0ZT1lLnJhdGUhPW51bGw/ZS5yYXRlOnRoaXMuZGVmYXVsdFJhdGUsdGhpcy5heGlzPWUuYXhpcyE9bnVsbD9lLmF4aXM6dGhpcy5kZWZhdWx0QXhpc31hcHBseShlKXtyZXR1cm4gTygoKT0+e2xldCB0PXAwKGUsdGhpcy5heGlzKSxuPVgoeih0aGlzLnJhdGUsYW4odCx0aGlzLm1pblZhbHVlLHRoaXMubWF4VmFsdWUpKSx6KDEtdGhpcy5yYXRlLHQpKTtyZXR1cm4geihlLGhlKG4sWChxdCgpLHQpKSl9KX1nZXRDb25maWcoKXtyZXR1cm57bWluVmFsdWU6dGhpcy5taW5WYWx1ZSxtYXhWYWx1ZTp0aGlzLm1heFZhbHVlLHJhdGU6dGhpcy5yYXRlLGF4aXM6dGhpcy5heGlzfX19O20wLmNsYXNzTmFtZT1cIk1pbk1heE5vcm1cIjtuZS5yZWdpc3RlckNsYXNzKG0wKTt2YXIga0k9e21heE5vcm06XCJNYXhOb3JtXCIsbWluTWF4Tm9ybTpcIk1pbk1heE5vcm1cIixub25OZWc6XCJOb25OZWdcIix1bml0Tm9ybTpcIlVuaXROb3JtXCJ9O2Z1bmN0aW9uIFh0KGUpe3JldHVybiBRdyhlKX1mdW5jdGlvbiBJSShlLHQ9e30pe3JldHVybiB2ZChlLG5lLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLHQsXCJjb25zdHJhaW50XCIpfWZ1bmN0aW9uIFl0KGUpe2lmKGU9PW51bGwpcmV0dXJuIG51bGw7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2xldCB0PXtjbGFzc05hbWU6ZSBpbiBrST9rSVtlXTplLGNvbmZpZzp7fX07cmV0dXJuIElJKHQpfWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiBTZD9lOklJKGUpfWZ1bmN0aW9uIEpHKGUpe3JldHVybiBuZXcgYzAoZSl9ZnVuY3Rpb24gUUcoZSl7cmV0dXJuIG5ldyBkMChlKX1mdW5jdGlvbiBlSCgpe3JldHVybiBuZXcgaDB9ZnVuY3Rpb24gdEgoZSl7cmV0dXJuIG5ldyBtMChlKX12YXIgQzI9e307X2UoQzIse2NvbnN0YW50OigpPT5ySCxnbG9yb3ROb3JtYWw6KCk9PmNILGdsb3JvdFVuaWZvcm06KCk9PnBILGhlTm9ybWFsOigpPT5kSCxoZVVuaWZvcm06KCk9PmhILGlkZW50aXR5OigpPT5sSCxsZUN1bk5vcm1hbDooKT0+bUgsbGVDdW5Vbmlmb3JtOigpPT5mSCxvbmVzOigpPT5hSCxvcnRob2dvbmFsOigpPT5nSCxyYW5kb21Ob3JtYWw6KCk9PmlILHJhbmRvbVVuaWZvcm06KCk9PnNILHRydW5jYXRlZE5vcm1hbDooKT0+b0gsdmFyaWFuY2VTY2FsaW5nOigpPT51SCx6ZXJvczooKT0+bkh9KTtmdW5jdGlvbiBuSCgpe3JldHVybiBuZXcgbjB9ZnVuY3Rpb24gYUgoKXtyZXR1cm4gbmV3IHlmfWZ1bmN0aW9uIHJIKGUpe3JldHVybiBuZXcgYTAoZSl9ZnVuY3Rpb24gc0goZSl7cmV0dXJuIG5ldyByMChlKX1mdW5jdGlvbiBpSChlKXtyZXR1cm4gbmV3IHMwKGUpfWZ1bmN0aW9uIG9IKGUpe3JldHVybiBuZXcgaTAoZSl9ZnVuY3Rpb24gbEgoZSl7cmV0dXJuIG5ldyBvMChlKX1mdW5jdGlvbiB1SChlKXtyZXR1cm4gbmV3IEJuKGUpfWZ1bmN0aW9uIHBIKGUpe3JldHVybiBuZXcgeGYoZSl9ZnVuY3Rpb24gY0goZSl7cmV0dXJuIG5ldyB2ZihlKX1mdW5jdGlvbiBkSChlKXtyZXR1cm4gbmV3IHdmKGUpfWZ1bmN0aW9uIGhIKGUpe3JldHVybiBuZXcga2YoZSl9ZnVuY3Rpb24gbUgoZSl7cmV0dXJuIG5ldyBJZihlKX1mdW5jdGlvbiBmSChlKXtyZXR1cm4gbmV3IFNmKGUpfWZ1bmN0aW9uIGdIKGUpe3JldHVybiBuZXcgbDAoZSl9dmFyIEUyPXt9O19lKEUyLHtMYXllcjooKT0+V2UsUk5OOigpPT5NcixSTk5DZWxsOigpPT5UZCxhY3RpdmF0aW9uOigpPT5xaixhZGQ6KCk9Pm42LGFscGhhRHJvcG91dDooKT0+ejYsYXZlcmFnZTooKT0+YTYsYXZlcmFnZVBvb2xpbmcxZDooKT0+VDEsYXZlcmFnZVBvb2xpbmcyZDooKT0+QzEsYXZlcmFnZVBvb2xpbmczZDooKT0+RTEsYXZnUG9vbDFkOigpPT5kNixhdmdQb29sMmQ6KCk9Pm02LGF2Z1Bvb2wzZDooKT0+ZzYsYXZnUG9vbGluZzFkOigpPT5oNixhdmdQb29saW5nMmQ6KCk9PmY2LGF2Z1Bvb2xpbmczZDooKT0+YjYsYmF0Y2hOb3JtYWxpemF0aW9uOigpPT51NixiaWRpcmVjdGlvbmFsOigpPT5GNixjYXRlZ29yeUVuY29kaW5nOigpPT5HNixjZW50ZXJDcm9wOigpPT5WNixjb25jYXRlbmF0ZTooKT0+cjYsY29udjFkOigpPT5Maixjb252MmQ6KCk9PnpqLGNvbnYyZFRyYW5zcG9zZTooKT0+V2osY29udjNkOigpPT5Caixjb252M2RUcmFuc3Bvc2U6KCk9PlZqLGNvbnZMc3RtMmQ6KCk9PkM2LGNvbnZMc3RtMmRDZWxsOigpPT5FNixjcm9wcGluZzJEOigpPT5HaixkZW5zZTooKT0+S2osZGVwdGh3aXNlQ29udjJkOigpPT5qaixkb3Q6KCk9Pmw2LGRyb3BvdXQ6KCk9PlhqLGVsdTooKT0+JGosZW1iZWRkaW5nOigpPT50NixmbGF0dGVuOigpPT5aaixnYXVzc2lhbkRyb3BvdXQ6KCk9Pkw2LGdhdXNzaWFuTm9pc2U6KCk9PlA2LGdsb2JhbEF2ZXJhZ2VQb29saW5nMWQ6KCk9Pnk2LGdsb2JhbEF2ZXJhZ2VQb29saW5nMmQ6KCk9Png2LGdsb2JhbE1heFBvb2wxZDooKT0+RDYsZ2xvYmFsTWF4UG9vbDJkOigpPT5SNixnbG9iYWxNYXhQb29saW5nMWQ6KCk9PkFDLGdsb2JhbE1heFBvb2xpbmcyZDooKT0+RkMsZ3J1OigpPT53NixncnVDZWxsOigpPT5rNixpbnB1dDooKT0+ajIsaW5wdXRMYXllcjooKT0+RmosbGF5ZXJOb3JtYWxpemF0aW9uOigpPT5wNixsZWFreVJlTFU6KCk9PlJqLGxzdG06KCk9Pkk2LGxzdG1DZWxsOigpPT5TNixtYXNraW5nOigpPT5XNixtYXhQb29sMWQ6KCk9Pk02LG1heFBvb2wyZDooKT0+TzYsbWF4UG9vbGluZzFkOigpPT4kQyxtYXhQb29saW5nMmQ6KCk9PkRDLG1heFBvb2xpbmczZDooKT0+djYsbWF4aW11bTooKT0+czYsbWluaW11bTooKT0+aTYsbXVsdGlwbHk6KCk9Pm82LHBlcm11dGU6KCk9PmU2LHByZWx1OigpPT5NaixyYW5kb21XaWR0aDooKT0+SDYscmVMVTooKT0+RGoscmVwZWF0VmVjdG9yOigpPT5KaixyZXNjYWxpbmc6KCk9PkI2LHJlc2hhcGU6KCk9PlFqLHJlc2l6aW5nOigpPT5VNixybm46KCk9Pl82LHNlcGFyYWJsZUNvbnYyZDooKT0+VWosc2ltcGxlUk5OOigpPT5ONixzaW1wbGVSTk5DZWxsOigpPT5UNixzb2Z0bWF4OigpPT5PaixzcGF0aWFsRHJvcG91dDFkOigpPT5ZaixzdGFja2VkUk5OQ2VsbHM6KCk9PkE2LHRocmVzaG9sZGVkUmVMVTooKT0+UGosdGltZURpc3RyaWJ1dGVkOigpPT4kNix1cFNhbXBsaW5nMmQ6KCk9PkhqLHplcm9QYWRkaW5nMmQ6KCk9PmM2fSk7YXN5bmMgZnVuY3Rpb24gS3IoZSl7aWYoZT09bnVsbClyZXR1cm47bGV0IHQ9W10sbj1bXSxhPVtdO2ZvcihsZXQgciBpbiBlKXtsZXQgcz1lW3JdO2lmKHR5cGVvZiBzIT1cIm51bWJlclwiKXtsZXQgaT1zO3QucHVzaChpLmRhdGEoKSksbi5wdXNoKHIpLGEucHVzaChpKX19aWYodC5sZW5ndGg+MCl7bGV0IHI9YXdhaXQgUHJvbWlzZS5hbGwodCk7Zm9yKGxldCBzPTA7czxyLmxlbmd0aDsrK3MpZVtuW3NdXT1yW3NdWzBdO0VlKGEpfX1mdW5jdGlvbiBfMihlKXtpZihlIT1udWxsKWZvcihsZXQgdCBpbiBlKXtsZXQgbj1lW3RdO3R5cGVvZiBuIT1cIm51bWJlclwiJiZuLmRpc3Bvc2UoKX19dmFyIFNJOyhmdW5jdGlvbihlKXtlW2UuU0lMRU5UPTBdPVwiU0lMRU5UXCIsZVtlLlZFUkJPU0U9MV09XCJWRVJCT1NFXCJ9KShTSXx8KFNJPXt9KSk7dmFyIGJIPTEyNSxHbD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMudmFsaWRhdGlvbkRhdGE9bnVsbH1zZXRQYXJhbXMoZSl7dGhpcy5wYXJhbXM9ZX1hc3luYyBvbkVwb2NoQmVnaW4oZSx0KXt9YXN5bmMgb25FcG9jaEVuZChlLHQpe31hc3luYyBvbkJhdGNoQmVnaW4oZSx0KXt9YXN5bmMgb25CYXRjaEVuZChlLHQpe31hc3luYyBvblRyYWluQmVnaW4oZSl7fWFzeW5jIG9uVHJhaW5FbmQoZSl7fXNldE1vZGVsKGUpe319LEEyPWNsYXNze2NvbnN0cnVjdG9yKGUsdD0xMCl7ZT09bnVsbCYmKGU9W10pLHRoaXMuY2FsbGJhY2tzPWUsdGhpcy5xdWV1ZUxlbmd0aD10fWFwcGVuZChlKXt0aGlzLmNhbGxiYWNrcy5wdXNoKGUpfXNldFBhcmFtcyhlKXtmb3IobGV0IHQgb2YgdGhpcy5jYWxsYmFja3MpdC5zZXRQYXJhbXMoZSl9c2V0TW9kZWwoZSl7Zm9yKGxldCB0IG9mIHRoaXMuY2FsbGJhY2tzKXQuc2V0TW9kZWwoZSl9YXN5bmMgb25FcG9jaEJlZ2luKGUsdCl7dD09bnVsbCYmKHQ9e30pO2ZvcihsZXQgbiBvZiB0aGlzLmNhbGxiYWNrcylhd2FpdCBuLm9uRXBvY2hCZWdpbihlLHQpfWFzeW5jIG9uRXBvY2hFbmQoZSx0KXt0PT1udWxsJiYodD17fSk7Zm9yKGxldCBuIG9mIHRoaXMuY2FsbGJhY2tzKWF3YWl0IG4ub25FcG9jaEVuZChlLHQpfWFzeW5jIG9uQmF0Y2hCZWdpbihlLHQpe3Q9PW51bGwmJih0PXt9KTtmb3IobGV0IG4gb2YgdGhpcy5jYWxsYmFja3MpYXdhaXQgbi5vbkJhdGNoQmVnaW4oZSx0KX1hc3luYyBvbkJhdGNoRW5kKGUsdCl7dD09bnVsbCYmKHQ9e30pO2ZvcihsZXQgbiBvZiB0aGlzLmNhbGxiYWNrcylhd2FpdCBuLm9uQmF0Y2hFbmQoZSx0KX1hc3luYyBvblRyYWluQmVnaW4oZSl7ZT09bnVsbCYmKGU9e30pO2ZvcihsZXQgdCBvZiB0aGlzLmNhbGxiYWNrcylhd2FpdCB0Lm9uVHJhaW5CZWdpbihlKX1hc3luYyBvblRyYWluRW5kKGUpe2U9PW51bGwmJihlPXt9KTtmb3IobGV0IHQgb2YgdGhpcy5jYWxsYmFja3MpYXdhaXQgdC5vblRyYWluRW5kKGUpfX0seUg9Y2xhc3MgZXh0ZW5kcyBHbHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCl9YXN5bmMgb25FcG9jaEJlZ2luKGUpe3RoaXMuc2Vlbj0wLHRoaXMudG90YWxzPXt9fWFzeW5jIG9uQmF0Y2hFbmQoZSx0KXt0PT1udWxsJiYodD17fSk7bGV0IG49dC5zaXplPT1udWxsPzA6dC5zaXplO3RoaXMuc2Vlbis9bjtmb3IobGV0IGEgaW4gdCl7bGV0IHI9dFthXTtpZih0eXBlb2Ygcj09XCJudW1iZXJcIil0aGlzLnRvdGFscy5oYXNPd25Qcm9wZXJ0eShhKXx8KHRoaXMudG90YWxzW2FdPTApLHRoaXMudG90YWxzW2FdPXRoaXMudG90YWxzW2FdK3IqbjtlbHNle2xldCBzO2EgaW4gdGhpcy50b3RhbHM/cz10aGlzLnRvdGFsc1thXTp0aGlzLnRvdGFsc1thXT0wO2xldCBpPU8oKCk9PlgodGhpcy50b3RhbHNbYV0seihyLG4pKSk7dGhpcy50b3RhbHNbYV09aSxzIT1udWxsJiZzLmRpc3Bvc2UoKX19fWFzeW5jIG9uRXBvY2hFbmQoZSx0KXtpZih0IT1udWxsKWZvcihsZXQgbiBvZiB0aGlzLnBhcmFtcy5tZXRyaWNzKXRoaXMudG90YWxzW25dIT1udWxsJiYodHlwZW9mIHRoaXMudG90YWxzW25dPT1cIm51bWJlclwiP3Rbbl09dGhpcy50b3RhbHNbbl0vdGhpcy5zZWVuOk8oKCk9PntsZXQgYT16KGhlKDEsdGhpcy5zZWVuKSx0aGlzLnRvdGFsc1tuXSk7dFtuXT1hLHRoaXMudG90YWxzW25dLmRpc3Bvc2UoKSxIdCh0W25dKX0pKX19LEYyPWNsYXNzIGV4dGVuZHMgR2x7YXN5bmMgb25UcmFpbkJlZ2luKGUpe3RoaXMuZXBvY2g9W10sdGhpcy5oaXN0b3J5PXt9fWFzeW5jIG9uRXBvY2hFbmQoZSx0KXt0PT1udWxsJiYodD17fSksdGhpcy5lcG9jaC5wdXNoKGUpO2ZvcihsZXQgbiBpbiB0KXRoaXMuaGlzdG9yeVtuXT09bnVsbCYmKHRoaXMuaGlzdG9yeVtuXT1bXSksdGhpcy5oaXN0b3J5W25dLnB1c2godFtuXSl9YXN5bmMgc3luY0RhdGEoKXtsZXQgZT1bXSx0PVtdLG49W107Zm9yKGxldCByIGluIHRoaXMuaGlzdG9yeSl7bGV0IHM9dGhpcy5oaXN0b3J5W3JdO2ZvcihsZXQgaT0wO2k8cy5sZW5ndGg7KytpKWlmKHR5cGVvZiBzW2ldIT1cIm51bWJlclwiKXtsZXQgbz1zW2ldO2UucHVzaChvLmRhdGEoKSksdC5wdXNoKHIpLG4ucHVzaChpKX19bGV0IGE9YXdhaXQgUHJvbWlzZS5hbGwoZSk7Zm9yKGxldCByPTA7cjxhLmxlbmd0aDsrK3IpdGhpcy5oaXN0b3J5W3Rbcl1dW25bcl1dLmRpc3Bvc2UoKSx0aGlzLmhpc3RvcnlbdFtyXV1bbltyXV09YVtyXVswXX19LCQyPWNsYXNzIGV4dGVuZHMgR2x7Y29uc3RydWN0b3IoZSx0KXtpZihzdXBlcigpLHRoaXMuY3VycmVudEVwb2NoPTAsdGhpcy5ub3dGdW5jPWUubm93RnVuYyx0aGlzLm5leHRGcmFtZUZ1bmM9ZS5uZXh0RnJhbWVGdW5jfHxadyx0aGlzLnlpZWxkRXZlcnk9dHx8XCJhdXRvXCIsdGhpcy55aWVsZEV2ZXJ5PT09XCJhdXRvXCImJih0aGlzLnlpZWxkRXZlcnk9YkgpLHRoaXMueWllbGRFdmVyeT09PVwibmV2ZXJcIiYmZS5vbllpZWxkIT1udWxsKXRocm93IG5ldyBFcnJvcihcInlpZWxkRXZlcnkgaXMgYG5ldmVyYCBidXQgeW91IHByb3ZpZGVkIGFuIGBvbllpZWxkYCBjYWxsYmFjay4gRWl0aGVyIGNoYW5nZSBgeWllbGRFdmVyeWAgb3IgcmVtb3ZlIHRoZSBjYWxsYmFja1wiKTt3LmlzTnVtYmVyKHRoaXMueWllbGRFdmVyeSkmJih0aGlzLm1heWJlV2FpdD1iRyh0aGlzLm1heWJlV2FpdC5iaW5kKHRoaXMpLHRoaXMueWllbGRFdmVyeSx0aGlzLm5vd0Z1bmMpKSx0aGlzLnRyYWluQmVnaW49ZS5vblRyYWluQmVnaW4sdGhpcy50cmFpbkVuZD1lLm9uVHJhaW5FbmQsdGhpcy5lcG9jaEJlZ2luPWUub25FcG9jaEJlZ2luLHRoaXMuZXBvY2hFbmQ9ZS5vbkVwb2NoRW5kLHRoaXMuYmF0Y2hCZWdpbj1lLm9uQmF0Y2hCZWdpbix0aGlzLmJhdGNoRW5kPWUub25CYXRjaEVuZCx0aGlzLnlpZWxkPWUub25ZaWVsZH1hc3luYyBtYXliZVdhaXQoZSx0LG4pe2xldCBhPVtdO3RoaXMueWllbGQhPW51bGwmJihhd2FpdCBLcihuKSxhLnB1c2godGhpcy55aWVsZChlLHQsbikpKSxhLnB1c2godGhpcy5uZXh0RnJhbWVGdW5jKCkpLGF3YWl0IFByb21pc2UuYWxsKGEpfWFzeW5jIG9uRXBvY2hCZWdpbihlLHQpe3RoaXMuY3VycmVudEVwb2NoPWUsdGhpcy5lcG9jaEJlZ2luIT1udWxsJiYoYXdhaXQgS3IodCksYXdhaXQgdGhpcy5lcG9jaEJlZ2luKGUsdCkpfWFzeW5jIG9uRXBvY2hFbmQoZSx0KXtsZXQgbj1bXTt0aGlzLmVwb2NoRW5kIT1udWxsJiYoYXdhaXQgS3IodCksbi5wdXNoKHRoaXMuZXBvY2hFbmQoZSx0KSkpLHRoaXMueWllbGRFdmVyeT09PVwiZXBvY2hcIiYmbi5wdXNoKHRoaXMubmV4dEZyYW1lRnVuYygpKSxhd2FpdCBQcm9taXNlLmFsbChuKX1hc3luYyBvbkJhdGNoQmVnaW4oZSx0KXt0aGlzLmJhdGNoQmVnaW4hPW51bGwmJihhd2FpdCBLcih0KSxhd2FpdCB0aGlzLmJhdGNoQmVnaW4oZSx0KSl9YXN5bmMgb25CYXRjaEVuZChlLHQpe2xldCBuPVtdO3RoaXMuYmF0Y2hFbmQhPW51bGwmJihhd2FpdCBLcih0KSxuLnB1c2godGhpcy5iYXRjaEVuZChlLHQpKSksdGhpcy55aWVsZEV2ZXJ5PT09XCJiYXRjaFwiP24ucHVzaCh0aGlzLm5leHRGcmFtZUZ1bmMoKSk6dy5pc051bWJlcih0aGlzLnlpZWxkRXZlcnkpJiZuLnB1c2godGhpcy5tYXliZVdhaXQodGhpcy5jdXJyZW50RXBvY2gsZSx0KSksYXdhaXQgUHJvbWlzZS5hbGwobil9YXN5bmMgb25UcmFpbkJlZ2luKGUpe3RoaXMudHJhaW5CZWdpbiE9bnVsbCYmKGF3YWl0IEtyKGUpLGF3YWl0IHRoaXMudHJhaW5CZWdpbihlKSl9YXN5bmMgb25UcmFpbkVuZChlKXt0aGlzLnRyYWluRW5kIT1udWxsJiYoYXdhaXQgS3IoZSksYXdhaXQgdGhpcy50cmFpbkVuZChlKSl9fTtmdW5jdGlvbiBEMihlLHQpe3JldHVybiBlPT1udWxsJiYoZT17fSksZSBpbnN0YW5jZW9mIEdsP1tlXTpBcnJheS5pc0FycmF5KGUpJiZlWzBdaW5zdGFuY2VvZiBHbD9lOml0KGUpLm1hcChuPT5uZXcgJDIobix0KSl9dmFyIGYwPWNsYXNzIEphe2NvbnN0cnVjdG9yKCl7fXN0YXRpYyByZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3IodCxuKXt3LmFzc2VydCh0Pj0wJiZOdW1iZXIuaXNJbnRlZ2VyKHQpLCgpPT5gVmVyYm9zaXR5IGxldmVsIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIgPj0gMCwgYnV0IGdvdCAke3R9YCksSmEuY2hlY2tGb3JEdXBsaWNhdGUobiksSmEuY29uc3RydWN0b3JzW3RdPT1udWxsJiYoSmEuY29uc3RydWN0b3JzW3RdPVtdKSxKYS5jb25zdHJ1Y3RvcnNbdF0ucHVzaChuKX1zdGF0aWMgY2hlY2tGb3JEdXBsaWNhdGUodCl7Zm9yKGxldCBuIGluIEphLmNvbnN0cnVjdG9ycylKYS5jb25zdHJ1Y3RvcnNbK25dLmZvckVhY2goYT0+e2lmKGE9PT10KXRocm93IG5ldyBWKFwiRHVwbGljYXRlIGNhbGxiYWNrIGNvbnN0cnVjdG9yLlwiKX0pfXN0YXRpYyBjbGVhcigpe0phLmNvbnN0cnVjdG9ycz17fX1zdGF0aWMgY3JlYXRlQ2FsbGJhY2tzKHQpe2xldCBuPVtdO2ZvcihsZXQgYSBpbiBKYS5jb25zdHJ1Y3RvcnMpe2xldCByPSthO3Q+PXImJm4ucHVzaCguLi5KYS5jb25zdHJ1Y3RvcnNbcl0pfXJldHVybiBuLm1hcChhPT5uZXcgYSl9fTtmMC5jb25zdHJ1Y3RvcnM9e307ZnVuY3Rpb24gUjIoZSx0LG4sYSxyLHMsaSxvLGwpe2xldCB1PW5ldyBGMixwPVtuZXcgeUgsLi4uZjAuY3JlYXRlQ2FsbGJhY2tzKHQpXTtlIT1udWxsJiZwLnB1c2goLi4uZSkscC5wdXNoKHUpO2xldCBkPW5ldyBBMihwKTtyZXR1cm4gZC5zZXRQYXJhbXMoe2Vwb2NoczpuLGluaXRpYWxFcG9jaDphLHNhbXBsZXM6cixzdGVwczpzLGJhdGNoU2l6ZTppLHZlcmJvc2U6dCxkb1ZhbGlkYXRpb246byxtZXRyaWNzOmx9KSx7Y2FsbGJhY2tMaXN0OmQsaGlzdG9yeTp1fX1mdW5jdGlvbiBCYShlLHQ9e30sbj0hMSl7cmV0dXJuIHZkKGUsbmUuU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcImxheWVyXCIsbil9ZnVuY3Rpb24gdG0oZSx0KXtyZXR1cm4gTygoKT0+e2UuZHR5cGUhPT1cImZsb2F0MzJcIiYmKGU9cmUoZSxcImZsb2F0MzJcIikpO2xldCBuPWZlKGtkKGUpLHQsITApLGE9eW4obi5zaGFwZSxxdCgpKSxyPXJuKGhyKG4sYSkpO3JldHVybiBoZShlLHIpfSl9ZnVuY3Rpb24gWG8oZSx0KXtyZXR1cm4gTygoKT0+Q3Qoa2QocGUodCxlKSksLTEpKX1mdW5jdGlvbiBUZihlLHQpe3JldHVybiBPKCgpPT5DdChMdChwZSh0LGUpKSwtMSkpfWZ1bmN0aW9uIHNwKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1wZShlLHQpLGE9YW4oTHQoZSkscXQoKSxOdW1iZXIuTUFYX1ZBTFVFKSxyPUx0KGhlKG4sYSkpO3JldHVybiB6KDEwMCxDdChyLC0xKSl9KX1mdW5jdGlvbiB4SChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49YW4odCxxdCgpLE51bWJlci5NQVhfVkFMVUUpLGE9UW4oWCgxLG4pKSxyPWFuKGUscXQoKSxOdW1iZXIuTUFYX1ZBTFVFKSxzPVFuKFgoMSxyKSk7cmV0dXJuIEN0KGtkKHBlKGEscykpLC0xKX0pfWZ1bmN0aW9uIHZIKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1ocigwLHBlKDEseihlLHQpKSk7cmV0dXJuIEN0KGtkKG4pLC0xKX0pfWZ1bmN0aW9uIHdIKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1ocigwLHBlKDEseihlLHQpKSk7cmV0dXJuIEN0KG4sLTEpfSl9ZnVuY3Rpb24ga0goZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPWZlKHooZSx0KSwtMSksYT1tYSh6KHBlKDEsZSksdCksLTEpO3JldHVybiBocigwLFgoMSxwZShhLG4pKSl9KX1mdW5jdGlvbiBJSChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49TWF0aC5sb2coMiksYT1wZSh0LGUpLHI9cGUoWChhLEdvKHooLTIsYSkpKSxuKTtyZXR1cm4gQ3QociwtMSl9KX1mdW5jdGlvbiBrYyhlLHQsbj0hMSl7cmV0dXJuIE8oKCk9PntpZihuKXQ9cWEodCk7ZWxzZXtsZXQgYT1mZSh0LHQuc2hhcGUubGVuZ3RoLTEsITApO3Q9aGUodCxhKX1yZXR1cm4gdD1hbih0LHF0KCksMS1xdCgpKSx5dChmZSh6KHJlKGUsXCJmbG9hdDMyXCIpLFFuKHQpKSx0LnNoYXBlLmxlbmd0aC0xKSl9KX1mdW5jdGlvbiBubShlLHQsbj0hMSl7cmV0dXJuIE8oKCk9PntsZXQgYT1yZSh0cChfRyhlKSksXCJpbnQzMlwiKTt0PWFuKHQscXQoKSwxLXF0KCkpO2xldCByPXQuc2hhcGUscz1XKExsKGEscltyLmxlbmd0aC0xXSkscik7cmV0dXJuIGtjKHMsdCxuKX0pfWZ1bmN0aW9uIFNIKGUsdCl7aWYoIXcuYXJyYXlzRXF1YWwoZS5zaGFwZSx0LnNoYXBlKSl0aHJvdyBuZXcgVihgbG9naXRzIGFuZCBsYWJlbHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLCBidXQgZ290IHNoYXBlcyAke0pTT04uc3RyaW5naWZ5KGUuc2hhcGUpfSBhbmQgJHtKU09OLnN0cmluZ2lmeSh0LnNoYXBlKX1gKTtyZXR1cm4gTygoKT0+e2xldCBuPUtlKHQpLGE9eXQoTHQodCkpO3JldHVybiBYKHBlKG4seih0LGUpKSxwZChkbihhKSkpfSl9ZnVuY3Rpb24gQ2YoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuO3JldHVybiBuPWFuKHQscXQoKSwxLXF0KCkpLG49UW4oaGUobixwZSgxLG4pKSksQ3QoU0goZSxuKSwtMSl9KX1mdW5jdGlvbiBOSChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49YW4oZSxxdCgpLDEpLGE9YW4odCxxdCgpLDEpO3JldHVybiBmZSh6KGUsUW4oaGUobixhKSkpLC0xKX0pfWZ1bmN0aW9uIFRIKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1RbihYKHF0KCksdCkpO3JldHVybiBDdChwZSh0LHooZSxuKSksLTEpfSl9ZnVuY3Rpb24gZzAoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPXRtKGUsLTEpLGE9dG0odCwtMSkscj16KG4sYSk7cmV0dXJuIHl0KGZlKHIsLTEpKX0pfXZhciBhbT17bWVhblNxdWFyZWRFcnJvcjpYbyxtZWFuQWJzb2x1dGVFcnJvcjpUZixtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I6c3AsbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yOnhILHNxdWFyZWRIaW5nZTp2SCxoaW5nZTp3SCxjYXRlZ29yaWNhbEhpbmdlOmtILGxvZ2Nvc2g6SUgsY2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6a2Msc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHk6bm0sYmluYXJ5Q3Jvc3NlbnRyb3B5OkNmLGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2U6TkgscG9pc3NvbjpUSCxjb3NpbmVQcm94aW1pdHk6ZzB9O2Z1bmN0aW9uIGR4KGUpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtpZihlIGluIGFtKXJldHVybiBhbVtlXTtsZXQgdD1gVW5rbm93biBsb3NzICR7ZX1gO3Rocm93IGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNvZnRtYXhjcm9zc2VudHJvcHlcIikmJih0PWBVbmtub3duIGxvc3MgJHtlfS4gVXNlIFwiY2F0ZWdvcmljYWxDcm9zc2VudHJvcHlcIiBhcyB0aGUgc3RyaW5nIG5hbWUgZm9yIHRmLmxvc3Nlcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5YCksbmV3IFYodCl9ZWxzZSByZXR1cm4gZX1mdW5jdGlvbiBiMChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49eiguNSxlYSh0KSksYT1pcihDbih0LG4pLGUuZHR5cGUpO3JldHVybiBDdChKbihlLGEpLC0xKX0pfWZ1bmN0aW9uIHkwKGUsdCl7cmV0dXJuIE8oKCk9PmlyKEpuKGRpKGUsLTEpLGRpKHQsLTEpKSxcImZsb2F0MzJcIikpfWZ1bmN0aW9uIE0yKGUsdCl7cmV0dXJuIE8oKCk9PnJlKGZlKF9hKEpuKGUsMSksSm4odCwxKSkpLFwiZmxvYXQzMlwiKSl9ZnVuY3Rpb24gQ0goZSx0KXtyZXR1cm4gTygoKT0+cmUoZmUoX2EoSm4oZSwxKSxKbih0LDApKSksXCJmbG9hdDMyXCIpKX1mdW5jdGlvbiBFSChlLHQpe3JldHVybiBPKCgpPT5yZShmZShfYShKbihlLDApLEpuKHQsMSkpKSxcImZsb2F0MzJcIikpfWZ1bmN0aW9uIE8yKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1NMihlLHQpLGE9RUgoZSx0KSxyPVgobixhKTtyZXR1cm4gcmUobm4oQ24ociwwKSxoZShuLHIpLDApLFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIF9IKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1NMihlLHQpLGE9Q0goZSx0KSxyPVgobixhKTtyZXR1cm4gcmUobm4oQ24ociwwKSxoZShuLHIpLDApLFwiZmxvYXQzMlwiKX0pfWZ1bmN0aW9uIFAyKGUsdCl7cmV0dXJuIENmKGUsdCl9ZnVuY3Rpb24gTDIoZSx0KXtyZXR1cm4gZS5yYW5rPT09dC5yYW5rJiYoZT1BcyhlLFtlLnJhbmstMV0pKSx0PWRpKHQsLTEpLHQuZHR5cGUhPT1lLmR0eXBlJiYodD1yZSh0LGUuZHR5cGUpKSxyZShKbihlLHQpLFwiZmxvYXQzMlwiKX1mdW5jdGlvbiBBSChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49ZS5zdWIodCkuc3F1YXJlKCkuc3VtKCksYT1lLnN1YihlLm1lYW4oKSkuc3F1YXJlKCkuc3VtKCk7cmV0dXJuIHhlKDEpLnN1YihuLmRpdihhKSl9KX12YXIgRkg9WG8sJEg9WG8sREg9VGYsUkg9VGYsTUg9c3AsT0g9c3AseDA9a2MsUEg9ZzAsejI9bm0scm09e2JpbmFyeUFjY3VyYWN5OmIwLGNhdGVnb3JpY2FsQWNjdXJhY3k6eTAscHJlY2lzaW9uOk8yLGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OngwLHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5OnoyLG1zZTpGSCxNU0U6JEgsbWFlOkRILE1BRTpSSCxtYXBlOk1ILE1BUEU6T0gsY29zaW5lOlBIfTtmdW5jdGlvbiBMSChlKXtpZih0eXBlb2YgZT09XCJzdHJpbmdcIiYmZSBpbiBybSlyZXR1cm4gcm1bZV07aWYodHlwZW9mIGUhPVwic3RyaW5nXCImJmUhPW51bGwpcmV0dXJuIGU7dGhyb3cgbmV3IFYoYFVua25vd24gbWV0cmljICR7ZX1gKX1mdW5jdGlvbiBTaChlKXtpZih0cihlIT09bnVsbCxgVW5rbm93biBMb3NzT3JNZXRyaWNGbiAke2V9YCksdHlwZW9mIGU9PVwic3RyaW5nXCIpcmV0dXJuIGU7e2xldCB0O2ZvcihsZXQgbiBvZiBPYmplY3Qua2V5cyhhbSkpaWYoYW1bbl09PT1lKXt0PW47YnJlYWt9aWYodCE9PXZvaWQgMClyZXR1cm4gdDtmb3IobGV0IG4gb2YgT2JqZWN0LmtleXMocm0pKWlmKHJtW25dPT09ZSl7dD1uO2JyZWFrfXJldHVybiB0IT09dm9pZCAwP3Q6ZS5uYW1lfX1mdW5jdGlvbiB6SChlKXtsZXQgdD17QWRhZ3JhZDooKT0+WHMuYWRhZ3JhZCguMDEpLEFkYWRlbHRhOigpPT5Ycy5hZGFkZWx0YSgxLC45NSxxdCgpKSxBZGFtOigpPT5Ycy5hZGFtKC4wMDEsLjksLjk5OSxxdCgpKSxBZGFtYXg6KCk9PlhzLmFkYW1heCguMDAyLC45LC45OTkscXQoKSwwKSxSTVNQcm9wOigpPT5Ycy5ybXNwcm9wKC4wMDEsLjksMCxxdCgpKSxTR0Q6KCk9PlhzLnNnZCguMDEpfTtpZih0LmFkYWdyYWQ9dC5BZGFncmFkLHQuYWRhZGVsdGE9dC5BZGFkZWx0YSx0LmFkYW09dC5BZGFtLHQuYWRhbWF4PXQuQWRhbWF4LHQucm1zcHJvcD10LlJNU1Byb3AsdC5zZ2Q9dC5TR0QsZSBpbiB0KXJldHVybiB0W2VdKCk7dGhyb3cgbmV3IFYoYFVua25vd24gT3B0aW1pemVyICR7ZX1gKX1mdW5jdGlvbiBOSShlLHQsbj0hMSl7aWYoZT09bnVsbHx8dHlwZW9mIGUhPVwib2JqZWN0XCJ8fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSE9PU9iamVjdC5wcm90b3R5cGV8fCFHeChlKSl0aHJvdyBuZXcgRXJyb3IoXCJVc2VyLWRlZmluZWQgbWV0YWRhdGEgaXMgZXhwZWN0ZWQgdG8gYmUgYSBKU09OIG9iamVjdCwgYnV0IGlzIG5vdC5cIik7aWYobil7bGV0IGE9SlNPTi5zdHJpbmdpZnkoZSk7YS5sZW5ndGg+MTA0ODU3NiYmY29uc29sZS53YXJuKGBVc2VyLWRlZmluZWQgbWV0YWRhdGEgb2YgbW9kZWwgXCIke3R9XCIgaXMgdG9vIGxhcmdlIGluIHNpemUgKGxlbmd0aD0ke2EubGVuZ3RofSB3aGVuIHNlcmlhbGl6ZWQpLiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gc3RvcmUgc3VjaCBsYXJnZSBvYmplY3RzIGluIHVzZXItZGVmaW5lZCBtZXRhZGF0YS4gUGxlYXNlIG1ha2Ugc3VyZSBpdHMgc2VyaWFsaXplZCBsZW5ndGggaXMgPD0gMTA0ODU3Ni5gKX19ZnVuY3Rpb24gR3goZSl7aWYoZT09PW51bGwpcmV0dXJuITA7aWYodHlwZW9mIGU9PVwib2JqZWN0XCIpaWYoT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpPT09T2JqZWN0LnByb3RvdHlwZSl7bGV0IHQ9T2JqZWN0LmtleXMoZSk7Zm9yKGxldCBuIG9mIHQpaWYodHlwZW9mIG4hPVwic3RyaW5nXCJ8fCFHeChlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1lbHNlIGlmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgdCBvZiBlKWlmKCFHeCh0KSlyZXR1cm4hMTtyZXR1cm4hMH1lbHNlIHJldHVybiExO2Vsc2V7bGV0IHQ9dHlwZW9mIGU7cmV0dXJuIHQ9PT1cInN0cmluZ1wifHx0PT09XCJudW1iZXJcInx8dD09PVwiYm9vbGVhblwifX1mdW5jdGlvbiBXSChlLHQsbixhPWNvbnNvbGUubG9nKXtsZXQgcj1WSChlKSxzPVtcIkxheWVyICh0eXBlKVwiLFwiSW5wdXQgU2hhcGVcIixcIk91dHB1dCBzaGFwZVwiLFwiUGFyYW0gI1wiXTtyPyh0PXR8fDkwLG49bnx8Wy4zMiwuNjEsLjg5LDFdKToodD10fHwxMTUsbj1ufHxbLjI0LC40OCwuNywuOCwxXSksbltuLmxlbmd0aC0xXTw9MSYmKG49bi5tYXAocD0+TWF0aC5mbG9vcih0KnApKSk7bGV0IGk7aWYoIXIpe3MucHVzaChcIlJlY2VpdmVzIGlucHV0c1wiKSxpPVtdO2ZvcihsZXQgcCBpbiBlLm5vZGVzQnlEZXB0aClpLnB1c2goLi4uZS5ub2Rlc0J5RGVwdGhbcF0pfWEoXCJfXCIucmVwZWF0KHQpKSxzbShzLG4sYSksYShcIj1cIi5yZXBlYXQodCkpO2xldCBvPWUubGF5ZXJzO2ZvcihsZXQgcD0wO3A8by5sZW5ndGg7KytwKXI/VUgob1twXSxuLGEpOkdIKG9bcF0sbixpLGEpLGEoKHA9PT1vLmxlbmd0aC0xP1wiPVwiOlwiX1wiKS5yZXBlYXQodCkpO2UuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKTtsZXQgbD1CSChlKSx1PUpoKGUubm9uVHJhaW5hYmxlV2VpZ2h0cyk7YShgVG90YWwgcGFyYW1zOiAke2wrdX1gKSxhKGBUcmFpbmFibGUgcGFyYW1zOiAke2x9YCksYShgTm9uLXRyYWluYWJsZSBwYXJhbXM6ICR7dX1gKSxhKFwiX1wiLnJlcGVhdCh0KSl9ZnVuY3Rpb24gQkgoZSl7bGV0IHQ7cmV0dXJuIGUuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyE9bnVsbD90PUpoKGUuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cyk6dD1KaChlLnRyYWluYWJsZVdlaWdodHMpLHR9ZnVuY3Rpb24gVkgoZSl7bGV0IHQ9ITAsbj1bXSxhPVtdO2ZvcihsZXQgciBpbiBlLm5vZGVzQnlEZXB0aCluLnB1c2goZS5ub2Rlc0J5RGVwdGhbcl0pO2ZvcihsZXQgciBvZiBuKXtpZihyLmxlbmd0aD4xfHxyLmxlbmd0aD09PTEmJnJbMF0uaW5ib3VuZExheWVycy5sZW5ndGg+MSl7dD0hMTticmVha31hLnB1c2goLi4ucil9aWYodClmb3IobGV0IHIgb2YgZS5sYXllcnMpe2xldCBzPSExO2ZvcihsZXQgaSBvZiByLmluYm91bmROb2RlcylpZihhLmluZGV4T2YoaSkhPT0tMSlpZihzKXt0PSExO2JyZWFrfWVsc2Ugcz0hMDtpZighdClicmVha31yZXR1cm4gdH1mdW5jdGlvbiBzbShlLHQsbj1jb25zb2xlLmxvZyl7bGV0IGE9XCJcIjtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilyPjAmJihhPWEuc2xpY2UoMCxhLmxlbmd0aC0xKStcIiBcIiksYSs9ZVtyXSxhPWEuc2xpY2UoMCx0W3JdKSxhKz1cIiBcIi5yZXBlYXQodFtyXS1hLmxlbmd0aCk7bihhKX1mdW5jdGlvbiBVSChlLHQsbil7bGV0IGEscjt0cnl7cj1lLmluYm91bmROb2Rlcy5tYXAobD0+SlNPTi5zdHJpbmdpZnkobC5pbnB1dFNoYXBlcykpLmpvaW4oXCIsXCIpfWNhdGNoKGwpe3I9XCJtdWx0aXBsZVwifXRyeXthPUpTT04uc3RyaW5naWZ5KGUub3V0cHV0U2hhcGUpfWNhdGNoKGwpe2E9XCJtdWx0aXBsZVwifWxldCBzPWUubmFtZSxpPWUuZ2V0Q2xhc3NOYW1lKCksbz1bYCR7c30gKCR7aX0pYCxyLGEsZS5jb3VudFBhcmFtcygpLnRvU3RyaW5nKCldO3NtKG8sdCxuKX1mdW5jdGlvbiBHSChlLHQsbixhKXtsZXQgcixzO3RyeXtzPWUuaW5ib3VuZE5vZGVzLm1hcChkPT5KU09OLnN0cmluZ2lmeShkLmlucHV0U2hhcGVzKSkuam9pbihcIixcIil9Y2F0Y2goZCl7cz1cIm11bHRpcGxlXCJ9dHJ5e3I9SlNPTi5zdHJpbmdpZnkoZS5vdXRwdXRTaGFwZSl9Y2F0Y2goZCl7cj1cIm11bHRpcGxlXCJ9bGV0IGk9W107Zm9yKGxldCBkIG9mIGUuaW5ib3VuZE5vZGVzKWlmKCEobiE9bnVsbCYmbi5sZW5ndGg+MCYmbi5pbmRleE9mKGQpPT09LTEpKWZvcihsZXQgYz0wO2M8ZC5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsrK2Mpe2xldCBoPWQuaW5ib3VuZExheWVyc1tjXS5uYW1lLG09ZC5ub2RlSW5kaWNlc1tjXSxmPWQudGVuc29ySW5kaWNlc1tjXTtpLnB1c2goYCR7aH1bJHttfV1bJHtmfV1gKX1sZXQgbz1lLm5hbWUsbD1lLmdldENsYXNzTmFtZSgpLHU9aS5sZW5ndGg9PT0wP1wiXCI6aVswXSxwPVtgJHtvfSAoJHtsfSlgLHMscixlLmNvdW50UGFyYW1zKCkudG9TdHJpbmcoKSx1XTtzbShwLHQsYSk7Zm9yKGxldCBkPTE7ZDxpLmxlbmd0aDsrK2Qpc20oW1wiXCIsXCJcIixcIlwiLFwiXCIsaVtkXV0sdCxhKX1mdW5jdGlvbiBXMihlLHQsbil7cmV0dXJuKGU9PT1cImluYm91bmROb2Rlc1wifHxlPT09XCJvdXRwdXRMYXllcnNcInx8ZT09PVwiaW5wdXRMYXllcnNcIikmJnQ9PT0wJiZ0eXBlb2Ygbj09XCJzdHJpbmdcIn1mdW5jdGlvbiBJYyhlLHQpe2lmKGU9PT1udWxsKXJldHVybiBudWxsO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXJldHVybiBKcyhlKTtpZih0eXBlb2YgZT09XCJudW1iZXJcInx8dHlwZW9mIGU9PVwiYm9vbGVhblwiKXJldHVybiBlO2lmKGUgaW5zdGFuY2VvZiBBcnJheSl7bGV0IG49W10sYT1lLmxlbmd0aDtmb3IobGV0IHI9MDtyPGE7KytyKXtsZXQgcz1lW3JdO1cyKHQscixzKT9uLnB1c2gocyk6bi5wdXNoKEljKHMsdCkpfXJldHVybiBufWVsc2V7bGV0IG49e307Zm9yKGxldCBhIG9mIE9iamVjdC5rZXlzKGUpKXtsZXQgcj1lW2FdO2lmKGE9PT1cIm5hbWVcIiYmdHlwZW9mIHI9PVwic3RyaW5nXCIpblthXT1yO2Vsc2V7bGV0IHM9SnMoYSk7bltzXT1JYyhyLHMpfX1yZXR1cm4gbn19ZnVuY3Rpb24gSHgoZSx0KXtpZihlPT1udWxsKXJldHVybiBudWxsO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXJldHVybiBJcihlKTtpZih0eXBlb2YgZT09XCJudW1iZXJcInx8dHlwZW9mIGU9PVwiYm9vbGVhblwiKXJldHVybiBlO2lmKGUgaW5zdGFuY2VvZiBBcnJheSl7bGV0IG49W10sYT1lLmxlbmd0aDtmb3IobGV0IHI9MDtyPGE7KytyKXtsZXQgcz1lW3JdO1cyKHQscixzKT9uLnB1c2gocyk6bi5wdXNoKEh4KHMsdCkpfXJldHVybiBufWVsc2V7bGV0IG49e307Zm9yKGxldCBhIG9mIE9iamVjdC5rZXlzKGUpKXtsZXQgcj1lW2FdLHM9SXIoYSk7KGE9PT1cIm5hbWVcInx8YT09PVwiY2xhc3NOYW1lXCIpJiZ0eXBlb2Ygcj09XCJzdHJpbmdcIj9uW3NdPXI6bltzXT1IeChyLGEpfXJldHVybiBufX12YXIgdjA9XCI0LjIyLjBcIixISD1lPT57bGV0IHQ9T2JqZWN0LmtleXMoZSk7aWYodC5sZW5ndGg9PT0wKXJldHVybiExO2xldCBuPXRbMF0uc3BsaXQoXCIvXCIpO3JldHVybiFpc05hTihwYXJzZUludChuW24ubGVuZ3RoLTFdLDEwKSl9LGpIPWNsYXNzIFFhIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IodCl7aWYoc3VwZXIoe30pLHRoaXMuY29udGFpbmVyTm9kZXM9bmV3IFNldCx0aGlzLm5hbWU9dC5uYW1lLHRoaXMubmFtZT09bnVsbCl7bGV0IHk9dGhpcy5nZXRDbGFzc05hbWUoKS50b0xvd2VyQ2FzZSgpO3RoaXMubmFtZT1nZih5KX1pZih0aGlzLnN1cHBvcnRzTWFza2luZz0hMSx0aGlzLnRyYWluYWJsZV89ITAsQXJyYXkuaXNBcnJheSh0LmlucHV0cyk/dGhpcy5pbnB1dHM9dC5pbnB1dHMuc2xpY2UoKTp0aGlzLmlucHV0cz1bdC5pbnB1dHNdLEFycmF5LmlzQXJyYXkodC5vdXRwdXRzKT90aGlzLm91dHB1dHM9dC5vdXRwdXRzLnNsaWNlKCk6dGhpcy5vdXRwdXRzPVt0Lm91dHB1dHNdLGFzKHRoaXMuaW5wdXRzKS5sZW5ndGghPT10aGlzLmlucHV0cy5sZW5ndGgpdGhyb3cgbmV3IFYoYFRoZSBsaXN0IG9mIGlucHV0cyBwYXNzZWQgdG8gdGhlIG1vZGVsIGlzIHJlZHVuZGFudC4gQWxsIGlucHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6ICR7dGhpcy5pbnB1dHMubWFwKHk9PnkubmFtZSl9YCk7YXModGhpcy5vdXRwdXRzKS5sZW5ndGghPT10aGlzLm91dHB1dHMubGVuZ3RoJiZjb25zb2xlLndhcm4oYFRoZSBsaXN0IG9mIG91dHB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyByZWR1bmRhbnQuIEFsbCBvdXRwdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogJHt0aGlzLm91dHB1dHMubWFwKHk9PnkubmFtZSl9YCksdGhpcy5pbnB1dExheWVycz1bXSx0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXM9W10sdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXM9W10sdGhpcy5vdXRwdXRMYXllcnM9W10sdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcz1bXSx0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXM9W10sdGhpcy5sYXllcnM9W10sdGhpcy5pbnRlcm5hbENvbnRhaW5lclJlZnM9W107Zm9yKGxldCB5IG9mIHRoaXMub3V0cHV0cyl7bGV0IHg9eS5zb3VyY2VMYXllcix2PXkubm9kZUluZGV4LEk9eS50ZW5zb3JJbmRleDt0aGlzLm91dHB1dExheWVycy5wdXNoKHgpLHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaCh2KSx0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMucHVzaChJKX1mb3IobGV0IHkgb2YgdGhpcy5pbnB1dHMpe2xldCB4PXkuc291cmNlTGF5ZXIsdj15Lm5vZGVJbmRleCxJPXkudGVuc29ySW5kZXg7dHIodj09PTAsXCJpbnB1dCBsYXllciBoYXMgPjEgbm9kZXNcIiksdHIoST09PTAsXCJpbnB1dCBsYXllciBoYXMgPjEgdGVuc29yc1wiKSx0aGlzLmlucHV0TGF5ZXJzLnB1c2goeCksdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzLnB1c2godiksdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXMucHVzaChJKX10aGlzLmlucHV0TmFtZXM9W10sdGhpcy5vdXRwdXROYW1lcz1bXSx0aGlzLmZlZWRJbnB1dFNoYXBlcz1bXSx0aGlzLmZlZWRJbnB1dE5hbWVzPVtdLHRoaXMuZmVlZE91dHB1dE5hbWVzPVtdO2ZvcihsZXQgeT0wO3k8dGhpcy5pbnB1dExheWVycy5sZW5ndGg7eSsrKXtsZXQgeD10aGlzLmlucHV0TGF5ZXJzW3ldO2lmKCEoeCBpbnN0YW5jZW9mIHJwKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnB1dCBsYXllcnMgdG8gYSBMYXllcnNNb2RlbCBtdXN0IGJlIElucHV0TGF5ZXIgb2JqZWN0cy4gUmVjZWl2ZWQgaW5wdXRzOiAke3QuaW5wdXRzfS4gSW5wdXQgJHt5fSAoMC1iYXNlZCkgb3JpZ2luYXRlcyBmcm9tIGxheWVyIHR5cGUgJHt4LmdldENsYXNzTmFtZSgpfS5gKTt0aGlzLmlucHV0TmFtZXMucHVzaCh4Lm5hbWUpLHRoaXMuZmVlZElucHV0U2hhcGVzLnB1c2goeC5iYXRjaElucHV0U2hhcGUpLHRoaXMuZmVlZElucHV0TmFtZXMucHVzaCh4Lm5hbWUpfWZvcihsZXQgeSBvZiB0aGlzLm91dHB1dExheWVycyl0aGlzLm91dHB1dE5hbWVzLnB1c2goeS5uYW1lKTt0aGlzLmludGVybmFsSW5wdXRTaGFwZXM9dGhpcy5pbnB1dHMubWFwKHk9Pnkuc2hhcGUpLHRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXM9dGhpcy5vdXRwdXRzLm1hcCh5PT55LnNoYXBlKTtsZXQgbj17fSxhPXt9LHI9e30scz17fSxpPXt9LG89W10sbD0oeSx4LHYsSSxOLEMpPT57KEk9PW51bGx8fE49PW51bGx8fEM9PW51bGwpJiYoST15LnNvdXJjZUxheWVyLE49eS5ub2RlSW5kZXgsQz15LnRlbnNvckluZGV4KTtsZXQgXz1JLmluYm91bmROb2Rlc1tOXTtpZih2LmluZGV4T2YoXykhPT0tMSl0aHJvdyBuZXcgYXIoYFRoZSB0ZW5zb3IgJHt5Lm5hbWV9IGF0IGxheWVyIFwiJHtJLm5hbWV9XCIgaXMgcGFydCBvZiBhIGN5Y2xlLmApO2lmKHguaW5kZXhPZihfKSE9PS0xKXJldHVybjt0aGlzLmNvbnRhaW5lck5vZGVzLmFkZChRYS5ub2RlS2V5KEksTikpLEkuaWQgaW4gaXx8KGlbSS5pZF09T2JqZWN0LmtleXMoaSkubGVuZ3RoKSx2LmluZGV4T2YoXyk9PT0tMSYmdi5wdXNoKF8pO2xldCBGPV8uaW5ib3VuZExheWVycy5sZW5ndGg7Zm9yKGxldCBEPTA7RDxGO0QrKyl7bGV0ICQ9Xy5pbnB1dFRlbnNvcnNbRF0sUz1fLmluYm91bmRMYXllcnNbRF0sTT1fLm5vZGVJbmRpY2VzW0RdLEI9Xy50ZW5zb3JJbmRpY2VzW0RdO2woJCx4LHYsUyxNLEIpfWZvcih4LnB1c2goXyk7di5pbmRleE9mKF8pPj0wOyl2LnNwbGljZSh2LmluZGV4T2YoXyksMSk7by5wdXNoKF8pfSx1PVtdLHA9W107Zm9yKGxldCB5IG9mIHRoaXMub3V0cHV0cylsKHksdSxwKTtsZXQgZD1vLnNsaWNlKCkucmV2ZXJzZSgpO2ZvcihsZXQgeSBvZiBkKXthW3kuaWRdPXkseS5pZCBpbiBufHwoblt5LmlkXT0wKTtsZXQgeD1uW3kuaWRdLHY9clt5Lm91dGJvdW5kTGF5ZXIuaWRdPT1udWxsPzA6clt5Lm91dGJvdW5kTGF5ZXIuaWRdO3g9TWF0aC5tYXgoeCx2KSxyW3kub3V0Ym91bmRMYXllci5pZF09eCxzW3kub3V0Ym91bmRMYXllci5pZF09eS5vdXRib3VuZExheWVyLG5beS5pZF09eDtmb3IobGV0IEk9MDtJPHkuaW5ib3VuZExheWVycy5sZW5ndGg7SSsrKXtsZXQgTj15LmluYm91bmRMYXllcnNbSV0sQz15Lm5vZGVJbmRpY2VzW0ldLF89Ti5pbmJvdW5kTm9kZXNbQ10sRj1uW18uaWRdPT1udWxsPzA6bltfLmlkXTtuW18uaWRdPU1hdGgubWF4KHgrMSxGKSxhW18uaWRdPV99fWxldCBjPXt9O2ZvcihsZXQgeSBpbiBuKXtsZXQgeD1uW3ldO3ggaW4gY3x8KGNbeF09W10pLGNbeF0ucHVzaChhW3ldKX1sZXQgaD17fTtmb3IobGV0IHkgaW4gcil7bGV0IHg9clt5XTt4IGluIGh8fChoW3hdPVtdKSxoW3hdLnB1c2goc1t5XSl9bGV0IG09T2JqZWN0LmtleXMoaCkubWFwKHk9PnBhcnNlSW50KHksMTApKS5zb3J0KHdoKTt0aGlzLmxheWVycz1bXTtmb3IobGV0IHkgb2YgbSl7bGV0IHg9aFt5XTt4LnNvcnQoKHYsSSk9PntsZXQgTj1pW3YuaWRdLEM9aVtJLmlkXTtyZXR1cm4gTjxDPy0xOk4+Qz8xOjB9KTtmb3IobGV0IHYgb2YgeCl2IGluc3RhbmNlb2YgUWEmJnRoaXMuaW50ZXJuYWxDb250YWluZXJSZWZzLnB1c2godiksdGhpcy5sYXllcnMucHVzaCh2KX10aGlzLmxheWVyc0J5RGVwdGg9aCxtPU9iamVjdC5rZXlzKGMpLm1hcCh5PT5wYXJzZUludCh5LDEwKSkuc29ydCh3aCk7bGV0IGY9dGhpcy5pbnB1dHMuc2xpY2UoKSxnPVtdO2ZvcihsZXQgeSBvZiBtKWZvcihsZXQgeCBvZiBjW3ldKXtsZXQgdj14Lm91dGJvdW5kTGF5ZXI7aWYodiE9bnVsbCl7Zm9yKGxldCBJIG9mIHguaW5wdXRUZW5zb3JzKWlmKGYuaW5kZXhPZihJKT09PS0xKXRocm93IG5ldyBhcihgR3JhcGggZGlzY29ubmVjdGVkOiBjYW5ub3Qgb2J0YWluIHZhbHVlIGZvciB0ZW5zb3IgJHtJfSBhdCBsYXllciBcIiR7di5uYW1lfVwiLiBUaGUgZm9sbG93aW5nIHByZXZpb3VzIGxheWVycyB3ZXJlIGFjY2Vzc2VkIHdpdGhvdXQgaXNzdWU6ICR7Z31gKTtmb3IobGV0IEkgb2YgeC5vdXRwdXRUZW5zb3JzKWYucHVzaChJKTtnLnB1c2godi5uYW1lKX19dGhpcy5ub2Rlc0J5RGVwdGg9YztsZXQgYj10aGlzLmxheWVycy5tYXAoeT0+eS5uYW1lKTtmb3IobGV0IHkgb2YgYil7bGV0IHg9Yi5maWx0ZXIodj0+dj09PXkpLmxlbmd0aDtpZih4IT09MSl0aHJvdyBuZXcgYXIoYFRoZSBuYW1lIFwiJHt5fVwiIGlzIHVzZWQgJHt4fSB0aW1lcyBpbiB0aGUgbW9kZWwuIEFsbCBsYXllciBuYW1lcyBzaG91bGQgYmUgdW5pcXVlLiBMYXllciBuYW1lczogYCtKU09OLnN0cmluZ2lmeShiKSl9dGhpcy5vdXRib3VuZE5vZGVzPVtdLHRoaXMuaW5ib3VuZE5vZGVzPVtdLG5ldyBOZih7b3V0Ym91bmRMYXllcjp0aGlzLGluYm91bmRMYXllcnM6W10sbm9kZUluZGljZXM6W10sdGVuc29ySW5kaWNlczpbXSxpbnB1dFRlbnNvcnM6dGhpcy5pbnB1dHMsb3V0cHV0VGVuc29yczp0aGlzLm91dHB1dHMsaW5wdXRNYXNrczp0aGlzLmlucHV0cy5tYXAoeT0+bnVsbCksb3V0cHV0TWFza3M6dGhpcy5vdXRwdXRzLm1hcCh5PT5udWxsKSxpbnB1dFNoYXBlczp0aGlzLmlucHV0cy5tYXAoeT0+eS5zaGFwZSksb3V0cHV0U2hhcGVzOnRoaXMub3V0cHV0cy5tYXAoeT0+eS5zaGFwZSl9KSx0aGlzLmJ1aWx0PSEwLHRoaXMuX3JlZkNvdW50PTF9YXNzZXJ0Tm90RGlzcG9zZWQoKXtpZih0aGlzLl9yZWZDb3VudD09PTApdGhyb3cgbmV3IEVycm9yKGBDb250YWluZXIgJyR7dGhpcy5uYW1lfScgaXMgYWxyZWFkeSBkaXNwb3NlZC5gKX1kaXNwb3NlKCl7dGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO2xldCB0PXtyZWZDb3VudEFmdGVyRGlzcG9zZTpudWxsLG51bURpc3Bvc2VkVmFyaWFibGVzOjB9O2lmKC0tdGhpcy5fcmVmQ291bnQ9PT0wKXtmb3IobGV0IG4gb2YgdGhpcy5sYXllcnMpdC5udW1EaXNwb3NlZFZhcmlhYmxlcys9bi5kaXNwb3NlKCkubnVtRGlzcG9zZWRWYXJpYWJsZXM7Zm9yKGxldCBuIG9mIHRoaXMuaW50ZXJuYWxDb250YWluZXJSZWZzKXQubnVtRGlzcG9zZWRWYXJpYWJsZXMrPW4uZGlzcG9zZSgpLm51bURpc3Bvc2VkVmFyaWFibGVzfXJldHVybiB0LnJlZkNvdW50QWZ0ZXJEaXNwb3NlPXRoaXMuX3JlZkNvdW50LHR9Z2V0IHRyYWluYWJsZSgpe3JldHVybiB0aGlzLnRyYWluYWJsZV99c2V0IHRyYWluYWJsZSh0KXt0aGlzLmxheWVycy5mb3JFYWNoKG49PntuLl90cmFpbmFibGVXZWlnaHRzLmZvckVhY2goYT0+YS50cmFpbmFibGU9dCl9KSx0aGlzLnRyYWluYWJsZV89dH1nZXQgdHJhaW5hYmxlV2VpZ2h0cygpe2lmKHRoaXMuX3RyYWluYWJsZVdlaWdodHMubGVuZ3RoPjApdGhyb3cgbmV3IFYoXCJDb250YWluZXIgaW5zdGFuY2UgdW5leHBlY3RlZGx5IGNvbnRhaW5zIF90cmFpbmFibGVXZWlnaHRzLlRoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBhIENvbnRhaW5lciBhcmUgYSB1bmlvbiBvZiB0aGUgdHJhaW5hYmxlIHdlaWdodHMgb2YgaXRzIGNvbnNpdHVlbnQgTGF5ZXJzLiBJdHMgb3duIF90cmFpbmFibGVXZWlnaHRzIG11c3QgcmVtYWluIGFuIGVtcHR5IEFycmF5LlwiKTtpZighdGhpcy50cmFpbmFibGUpcmV0dXJuW107bGV0IHQ9W107Zm9yKGxldCBuIG9mIHRoaXMubGF5ZXJzKXQ9dC5jb25jYXQobi50cmFpbmFibGVXZWlnaHRzKTtyZXR1cm4gdH1nZXQgbm9uVHJhaW5hYmxlV2VpZ2h0cygpe2xldCB0PVtdO2ZvcihsZXQgbiBvZiB0aGlzLmxheWVycyl0LnB1c2goLi4ubi5ub25UcmFpbmFibGVXZWlnaHRzKTtpZighdGhpcy50cmFpbmFibGUpe2xldCBuPVtdO2ZvcihsZXQgYSBvZiB0aGlzLmxheWVycyluLnB1c2goLi4uYS50cmFpbmFibGVXZWlnaHRzKTtyZXR1cm4gbi5jb25jYXQodCl9cmV0dXJuIHR9Z2V0IHdlaWdodHMoKXtyZXR1cm4gdGhpcy50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLm5vblRyYWluYWJsZVdlaWdodHMpfWxvYWRXZWlnaHRzKHQsbj0hMCl7bGV0IGE9e30scj0wLHM9SEgodCk7cyYmdGhpcy5wYXJzZVdlaWdodHModCk7Zm9yKGxldCBvIG9mIHRoaXMubGF5ZXJzKWZvcihsZXRbbCx1XW9mIG8ud2VpZ2h0cy5lbnRyaWVzKCkpe2xldCBwPXM/YCR7dS5uYW1lLnNwbGl0KFwiL1wiKS5zbGljZSgwLC0xKS5qb2luKFwiL1wiKStcIi9cIn0ke2x9YDp1Lm9yaWdpbmFsTmFtZTtpZihhW3BdIT1udWxsKXRocm93IG5ldyBWKGBEdXBsaWNhdGUgd2VpZ2h0IG5hbWU6ICR7cH1gKTthW3BdPXUscisrfWxldCBpPVtdO2ZvcihsZXQgbyBpbiB0KXtsZXQgbD1vO2lmKGFbb109PW51bGwpe2xldCB1PW8uc3BsaXQoXCIvXCIpO2w9dS5zbGljZSgwLC0yKS5jb25jYXQoW3VbdS5sZW5ndGgtMV1dKS5qb2luKFwiL1wiKX1pZihhW2xdIT1udWxsKWkucHVzaChbYVtsXSx0W29dXSk7ZWxzZSBpZihuKXRocm93IG5ldyBWKGBQcm92aWRlZCB3ZWlnaHQgZGF0YSBoYXMgbm8gdGFyZ2V0IHZhcmlhYmxlOiAke299YCk7ZGVsZXRlIGFbbF19aWYobil7bGV0IG89W107Zm9yKGxldCBsIGluIGEpby5wdXNoKGwpO2lmKG8ubGVuZ3RoPjApdGhyb3cgbmV3IFYoYCR7by5sZW5ndGh9IG9mICR7cn0gd2VpZ2h0cyBhcmUgbm90IHNldDogJHtvfWApfXUwKGkpfXBhcnNlV2VpZ2h0cyh0KXtmb3IobGV0IG4gaW4gT2JqZWN0LmtleXModCkpe2xldCBhPW4uc3BsaXQoXCIvXCIpLHI9W1widmFyc1wiLFwibGF5ZXJfY2hlY2twb2ludF9kZXBlbmRlbmNpZXNcIl0scz1hLm1hcChpPT5pLnN0YXJ0c1dpdGgoXCJfXCIpP2kuc2xpY2UoMSk6aSkuZmlsdGVyKGk9PiFyLmluY2x1ZGVzKGkpKS5qb2luKFwiL1wiKTtzIT09biYmKHRbc109dFtuXSxkZWxldGUgdFtuXSl9fXVwZGF0ZWRDb25maWcoKXtsZXQgdD10aGlzLmdldENvbmZpZygpLG49e307cmV0dXJuIG4uY2xhc3NOYW1lPXRoaXMuZ2V0Q2xhc3NOYW1lKCksbi5jb25maWc9dCxuLmtlcmFzVmVyc2lvbj1gdGZqcy1sYXllcnMgJHt2MH1gLG4uYmFja2VuZD1cIlRlbnNvckZsb3cuanNcIixufXRvSlNPTih0LG49ITApe2xldCBhPUh4KHRoaXMudXBkYXRlZENvbmZpZygpKTtyZXR1cm4gbj9KU09OLnN0cmluZ2lmeShhKTphfWNhbGwodCxuKXtyZXR1cm4gTygoKT0+e3Q9aXQodCk7bGV0IGE9bmV3IENsO2ZvcihsZXQgcj0wO3I8dGhpcy5pbnB1dHMubGVuZ3RoOysrcilhLmFkZCh0aGlzLmlucHV0c1tyXSx0W3JdKTtyZXR1cm4gdGModGhpcy5vdXRwdXRzLGEsbil9KX1jb21wdXRlTWFzayh0LG4pe3JldHVybiBPKCgpPT57dD1pdCh0KTtsZXQgYTtyZXR1cm4gbj09bnVsbD9hPWJpKG51bGwsdC5sZW5ndGgpOmE9aXQobiksdGhpcy5ydW5JbnRlcm5hbEdyYXBoKHQsYSlbMV19KX1jb21wdXRlT3V0cHV0U2hhcGUodCl7bGV0IG49WmgodCk7aWYobi5sZW5ndGghPT10aGlzLmlucHV0TGF5ZXJzLmxlbmd0aCl0aHJvdyBuZXcgVihgSW52YWxpZCBpbnB1dFNoYXBlIGFyZ3VtZW50ICR7dH06IG1vZGVsIGhhcyAke3RoaXMuaW5wdXRMYXllcnMubGVuZ3RofSB0ZW5zb3IgaW5wdXRzLmApO2xldCBhPXt9O2ZvcihsZXQgbz0wO288bi5sZW5ndGg7bysrKXtsZXQgbD10aGlzLmlucHV0TGF5ZXJzW29dLHU9bltvXSxwPWwubmFtZStcIl8wXzBcIjthW3BdPXV9bGV0IHI9T2JqZWN0LmtleXModGhpcy5ub2Rlc0J5RGVwdGgpLm1hcChvPT5wYXJzZUludChvLDEwKSkuc29ydCh3aCk7aWYoci5sZW5ndGg+MSlmb3IobGV0IG8gb2Ygcil7bGV0IGw9dGhpcy5ub2Rlc0J5RGVwdGhbb107Zm9yKGxldCB1IG9mIGwpe2xldCBwPXUub3V0Ym91bmRMYXllcjtpZih0aGlzLmlucHV0TGF5ZXJzLm1hcChmPT5mLmlkKS5pbmRleE9mKHAuaWQpIT09LTEpY29udGludWU7bGV0IGQ9W107Zm9yKGxldCBmPTA7Zjx1LmluYm91bmRMYXllcnMubGVuZ3RoO2YrKyl7bGV0IGc9dS5pbmJvdW5kTGF5ZXJzW2ZdLGI9dS5ub2RlSW5kaWNlc1tmXSx5PXUudGVuc29ySW5kaWNlc1tmXSx4PWAke2cubmFtZX1fJHtifV8ke3l9YCx2PWFbeF07ZC5wdXNoKHYpfWxldCBjPXAuY29tcHV0ZU91dHB1dFNoYXBlKE1uKGQpKSxoPVpoKGMpLG09cC5pbmJvdW5kTm9kZXMuaW5kZXhPZih1KTtmb3IobGV0IGY9MDtmPGgubGVuZ3RoO2YrKyl7bGV0IGc9YCR7cC5uYW1lfV8ke219XyR7Zn1gO2FbZ109aFtmXX19fWxldCBzPVtdLGk9W107Zm9yKGxldCBvPTA7bzx0aGlzLm91dHB1dExheWVycy5sZW5ndGg7bysrKXtsZXQgbD10aGlzLm91dHB1dExheWVyc1tvXSx1PXRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbb10scD10aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbb10sZD1gJHtsLm5hbWV9XyR7dX1fJHtwfWA7aS5wdXNoKGQpfWZvcihsZXQgbz0wO288aS5sZW5ndGg7bysrKXtsZXQgbD1pW29dO3RyKGwgaW4gYSkscy5wdXNoKGFbbF0pfXJldHVybiBNbihzKX1ydW5JbnRlcm5hbEdyYXBoKHQsbil7bj09bnVsbCYmKG49YmkobnVsbCx0Lmxlbmd0aCkpO2xldCBhPXt9O2ZvcihsZXQgbD0wO2w8dGhpcy5pbnB1dHMubGVuZ3RoOysrbCl7bGV0IHU9dGhpcy5pbnB1dHNbbF0scD10W2xdLGQ9bltsXTthW3UuaWRdPVtwLGRdfWxldCByPU9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKS5tYXAobD0+cGFyc2VJbnQobCwxMCkpLnNvcnQod2gpO2ZvcihsZXQgbCBvZiByKXtsZXQgdT10aGlzLm5vZGVzQnlEZXB0aFtsXTtmb3IobGV0IHAgb2YgdSl7bGV0IGQ9cC5vdXRib3VuZExheWVyLGM9cC5pbnB1dFRlbnNvcnMsaD1wLm91dHB1dFRlbnNvcnMsbT1uZXcgQXJyYXk7Zm9yKGxldCBmIG9mIGMpZi5pZCBpbiBhJiZtLnB1c2goYVtmLmlkXSk7aWYobS5sZW5ndGg9PT1jLmxlbmd0aCl7bGV0IGY9e30sZyxiLHkseDtpZihwLmNhbGxBcmdzIT1udWxsJiYoZj1wLmNhbGxBcmdzKSxtLmxlbmd0aD09PTEpe2xldFt2LEldPW1bMF07Zi5tYXNrPT1udWxsJiYoZi5tYXNrPUkpLHk9aXQoZC5jYWxsKHYsZikpLHg9aXQoZC5jb21wdXRlTWFzayh2LEkpKSxnPVt2XSxiPVtJXX1lbHNlIGc9bS5tYXAodj0+dlswXSksYj1tLm1hcCh2PT52WzFdKSxmLm1hc2s9PW51bGwmJihmLm1hc2s9YikseT1pdChkLmNhbGwoZyxmKSkseD1pdChkLmNvbXB1dGVNYXNrKGcsYikpO2lmKGQuYWN0aXZpdHlSZWd1bGFyaXplcil0aHJvdyBuZXcgemUoXCJMYXllcnNNb2RlbCBpbnZvY2F0aW9uIHdpdGggY29uY3JldGUgVGVuc29yIHZhbHVlKHMpIGluIHRoZSBwcmVzZW5jZSBvZiBhY3Rpdml0eSByZWd1bGFyaXplcihzKSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7Zm9yKGxldCB2PTA7djxoLmxlbmd0aDsrK3Ype2xldCBJPWhbdl0sTj15W3ZdLEM9eFt2XTthW0kuaWRdPVtOLENdfX19fWxldCBzPVtdLGk9W10sbz1bXTtmb3IobGV0IGwgb2YgdGhpcy5vdXRwdXRzKXt0cihsLmlkIGluIGEsYENvdWxkIG5vdCBjb21wdXRlIG91dHB1dCAke2wubmFtZX0gOiAke2wuaWR9YCk7bGV0W3UscF09YVtsLmlkXTtvLnB1c2godS5zaGFwZSkscy5wdXNoKHUpLGkucHVzaChwKX1yZXR1cm5bcyxpLG9dfWJ1aWxkTm9kZUNvbnZlcnNpb25NYXAodCl7bGV0IG49e30sYTtmb3IobGV0IHIgb2YgdGhpcy5sYXllcnMpe2E9ciBpbnN0YW5jZW9mIFFhPzE6MDtmb3IobGV0IHM9MDtzPHIuaW5ib3VuZE5vZGVzLmxlbmd0aDtzKyspe2xldCBpPVFhLm5vZGVLZXkocixzKTt0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhpKSYmKG5baV09YSxhKz0xKX19cmV0dXJuIG59Z2V0TGF5ZXIodCxuKXtpZihuIT1udWxsKXJldHVybiB0aGlzLmZpbmRMYXllcihuKTtpZih0PT1udWxsKXRocm93IG5ldyBWKFwiUHJvdmlkZSBlaXRoZXIgYSBsYXllciBuYW1lIG9yIGxheWVyIGluZGV4XCIpO2lmKHR5cGVvZiB0PT1cIm51bWJlclwiKXJldHVybiB0aGlzLmZpbmRMYXllcih0KTtmb3IobGV0IGEgb2YgdGhpcy5sYXllcnMpaWYoYS5uYW1lPT09dClyZXR1cm4gYTt0aHJvdyBuZXcgVihgTm8gc3VjaCBsYXllcjogJHt0fWApfWZpbmRMYXllcih0KXtpZih0aGlzLmxheWVycy5sZW5ndGg8PXQpdGhyb3cgbmV3IFYoYFdhcyBhc2tlZCB0byByZXRyaWV2ZSBsYXllciBhdCBpbmRleCAke3R9LCBidXQgbW9kZWwgb25seSBoYXMgJHt0aGlzLmxheWVycy5sZW5ndGh9IGxheWVyKHMpLmApO3JldHVybiB0aGlzLmxheWVyc1t0XX1jYWxjdWxhdGVMb3NzZXMoKXtyZXR1cm4gTygoKT0+e2xldCB0PVtdO2ZvcihsZXQgbiBvZiB0aGlzLmxheWVycylmb3IobGV0IGE9MDthPG4uaW5ib3VuZE5vZGVzLmxlbmd0aDsrK2Epe2xldCByPVFhLm5vZGVLZXkobixhKTt0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhyKSYmdC5wdXNoKC4uLm4uY2FsY3VsYXRlTG9zc2VzKCkpfXJldHVybiB0fSl9Z2V0Q29uZmlnKCl7bGV0IHQ9e25hbWU6dGhpcy5uYW1lfSxuPXRoaXMuYnVpbGROb2RlQ29udmVyc2lvbk1hcCh0aGlzLmxheWVycyksYT1bXTtmb3IobGV0IGkgb2YgdGhpcy5sYXllcnMpe2xldCBvPWkuZ2V0Q2xhc3NOYW1lKCksbD1pLmdldENvbmZpZygpLHU9W107Zm9yKGxldCBkPTA7ZDxpLmluYm91bmROb2Rlcy5sZW5ndGg7ZCsrKXtsZXQgYz1pLmluYm91bmROb2Rlc1tkXSxoPVFhLm5vZGVLZXkoaSxkKSxtPXt9O2lmKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKGgpKXtpZihjLmNhbGxBcmdzKXRyeXtKU09OLnN0cmluZ2lmeShjLmNhbGxBcmdzKSxtPWMuY2FsbEFyZ3N9Y2F0Y2goZil7Y29uc29sZS53YXJuKGBMYXllciAke2kubmFtZX0gd2FzIHBhc3NlZCBub24tc2VyaWFsaXphYmxlIGtleXdvcmQgYXJndW1lbnRzOiAke2MuY2FsbEFyZ3N9LiBUaGV5IHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBzZXJpYWxpemVkIG1vZGVsIChhbmQgdGh1cyB3aWxsIGJlIG1pc3NpbmcgYXQgZGVzZXJpYWxpemF0aW9uIHRpbWUpLmApLG09e319aWYoYy5pbmJvdW5kTGF5ZXJzLmxlbmd0aD4wKXtsZXQgZj1bXTtmb3IobGV0IGc9MDtnPGMuaW5ib3VuZExheWVycy5sZW5ndGg7ZysrKXtsZXQgYj1jLmluYm91bmRMYXllcnNbZ10seT1jLm5vZGVJbmRpY2VzW2ddLHg9Yy50ZW5zb3JJbmRpY2VzW2ddLHY9UWEubm9kZUtleShiLHkpLEk9blt2XTtJPT1udWxsJiYoST0wKSxmLnB1c2goW2IubmFtZSxJLHgsbV0pfXUucHVzaChmKX19fWxldCBwPXt9O3AubmFtZT1pLm5hbWUscC5jbGFzc05hbWU9byxwLmNvbmZpZz1sLHAuaW5ib3VuZE5vZGVzPXUsYS5wdXNoKHApfXQubGF5ZXJzPWE7bGV0IHI9W107Zm9yKGxldCBpPTA7aTx0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aDtpKyspe2xldCBvPXRoaXMuaW5wdXRMYXllcnNbaV0sbD10aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXNbaV0sdT1RYS5ub2RlS2V5KG8sbCk7aWYoIXRoaXMuY29udGFpbmVyTm9kZXMuaGFzKHUpKWNvbnRpbnVlO2xldCBwPW5bdV07cD09bnVsbCYmKHA9MCk7bGV0IGQ9dGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXNbaV07ci5wdXNoKFtvLm5hbWUscCxkXSl9dC5pbnB1dExheWVycz1yO2xldCBzPVtdO2ZvcihsZXQgaT0wO2k8dGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoO2krKyl7bGV0IG89dGhpcy5vdXRwdXRMYXllcnNbaV0sbD10aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW2ldLHU9UWEubm9kZUtleShvLGwpO2lmKCF0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyh1KSljb250aW51ZTtsZXQgcD1uW3VdO3A9PW51bGwmJihwPTApO2xldCBkPXRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tpXTtzLnB1c2goW28ubmFtZSxwLGRdKX1yZXR1cm4gdC5vdXRwdXRMYXllcnM9cyx0fXN0YXRpYyBmcm9tQ29uZmlnKHQsbixhPXt9LHI9ITEpe2xldCBzPXt9LGk9e307ZnVuY3Rpb24gbyhnLGIpe2cubmFtZSBpbiBpP2lbZy5uYW1lXS5wdXNoKGIpOmlbZy5uYW1lXT1bYl19ZnVuY3Rpb24gbChnLGIpe2xldCB5PVtdLHg7Zm9yKGxldCB2IG9mIGIpe2xldCBJPXZbMF0sTj12WzFdLEM9dlsyXTtpZih4PXZbM109PW51bGw/e306dlszXSwhKEkgaW4gcykpe28oZyxiKTtyZXR1cm59bGV0IF89c1tJXTtpZihfLmluYm91bmROb2Rlcy5sZW5ndGg8PU4pe28oZyxiKTtyZXR1cm59bGV0IEY9Xy5pbmJvdW5kTm9kZXNbTl07eS5wdXNoKEYub3V0cHV0VGVuc29yc1tDXSl9eS5sZW5ndGg+MCYmZy5hcHBseShNbih5KSx4KX1mdW5jdGlvbiB1KGcpe2xldCBiPWcubmFtZSx5PUJhKGcsbi5jdXN0b21PYmplY3RzIT1udWxsP24uY3VzdG9tT2JqZWN0czp7fSk7eS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHIpLHNbYl09eSxnLmluYm91bmROb2Rlcy5mb3JFYWNoKHg9PntpZighKHggaW5zdGFuY2VvZiBBcnJheSkpdGhyb3cgbmV3IFYoYENvcnJ1cHRlZCBjb25maWd1cmF0aW9uLCBleHBlY3RlZCBhcnJheSBmb3Igbm9kZURhdGE6ICR7eH1gKTtvKHkseCl9KX1sZXQgcD1uLm5hbWUsZD1uLmxheWVycztmb3IobGV0IGcgb2YgZCl1KGcpO2Zvcig7IWdHKGkpOylmb3IobGV0IGcgb2YgZCl7bGV0IGI9c1tnLm5hbWVdO2lmKGIubmFtZSBpbiBpKXtsZXQgeT1pW2IubmFtZV07ZGVsZXRlIGlbYi5uYW1lXTtmb3IobGV0IHggb2YgeSlsKGIseCl9fWxldCBjPVtdLGg9W10sbT1uLmlucHV0TGF5ZXJzO2ZvcihsZXQgZyBvZiBtKXtsZXQgYj1nWzBdLHk9Z1sxXSx4PWdbMl07dHIoYiBpbiBzKTtsZXQgdj1zW2JdLmluYm91bmROb2Rlc1t5XS5vdXRwdXRUZW5zb3JzO2MucHVzaCh2W3hdKX1sZXQgZj1uLm91dHB1dExheWVycztmb3IobGV0IGcgb2YgZil7bGV0IGI9Z1swXSx5PWdbMV0seD1nWzJdO3RyKGIgaW4gcyk7bGV0IHY9c1tiXS5pbmJvdW5kTm9kZXNbeV0ub3V0cHV0VGVuc29ycztoLnB1c2godlt4XSl9cmV0dXJuIG5ldyB0KHtpbnB1dHM6YyxvdXRwdXRzOmgsbmFtZTpwfSl9Z2V0IHN0YXRlZnVsKCl7aWYodGhpcy5fc3RhdGVmdWwpdGhyb3cgbmV3IFYoXCJDb250YWluZXIgaW5zdGFuY2UgdW5leHBlY3RlZGx5IGhhcyBfc3RhdGVmdWwgPSB0cnVlLiBUaGUgc3RhdGVmdWxuZXNzIG9mIGEgQ29udGFpbmVyIGlzIGRldGVybWluZWQgYnkgdGhlIExheWVycyBpdCBjb250YWlucy4gSXRzIF9zdGF0ZWZ1bCBwcm9wZXJ0eSBtdXN0IHJlbWFpbiB0aGUgZGVmYXVsdCBmYWxzZS5cIik7Zm9yKGxldCB0IG9mIHRoaXMubGF5ZXJzKWlmKHQuc3RhdGVmdWwpcmV0dXJuITA7cmV0dXJuITF9cmVzZXRTdGF0ZXMoKXtPKCgpPT57dGhpcy5sYXllcnMuZm9yRWFjaCh0PT57dC5zdGF0ZWZ1bCYmdC5yZXNldFN0YXRlcygpfSl9KX19O2Z1bmN0aW9uIHFIKGUsdCxuKXtsZXQgYT10Lmxlbmd0aDtpZihlPT1udWxsfHxBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD09PTApcmV0dXJuIHQubWFwKHI9Pm51bGwpO2lmKGE9PT0xKXJldHVybiBBcnJheS5pc0FycmF5KGUpJiZlLmxlbmd0aD09PTE/ZTp0eXBlb2YgZT09XCJvYmplY3RcIiYmdFswXWluIGU/W2VbdFswXV1dOltlXTtpZihBcnJheS5pc0FycmF5KGUpKXtpZihlLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlZCAke259IGlzIGFuIGFycmF5IG9mICR7ZS5sZW5ndGh9IGVsZW1lbnQocyksIGJ1dCB0aGUgbW9kZWwgaGFzICR7YX0gb3V0cHV0cy4gTWFrZSBzdXJlIGEgc2V0IG9mIHdlaWdodHMgaXMgcHJvdmlkZWQgZm9yIGVhY2ggbW9kZWwgb3V0cHV0LmApO3JldHVybiBlfWVsc2UgaWYodHlwZW9mIGU9PVwib2JqZWN0XCImJk9iamVjdC5rZXlzKGUpLmxlbmd0aD4wJiZ0eXBlb2YgZVtPYmplY3Qua2V5cyhlKVswXV09PVwib2JqZWN0XCIpe2xldCByPVtdO3JldHVybiB0LmZvckVhY2gocz0+e3MgaW4gZT9yLnB1c2goZVtzXSk6ci5wdXNoKG51bGwpfSkscn1lbHNlIHRocm93IG5ldyBFcnJvcihgVGhlIG1vZGVsIGhhcyBtdWx0aXBsZSAoJHthfSkgb3V0cHV0cywgc28gJHtufSBtdXN0IGJlIGVpdGhlciBhbiBhcnJheSB3aXRoICR7YX0gZWxlbWVudHMgb3IgYW4gb2JqZWN0IHdpdGggJHt0fSBrZXlzLiBQcm92aWRlZCAke259IG5vdCB1bmRlcnN0b29kOiAke0pTT04uc3RyaW5naWZ5KGUpfWApfWZ1bmN0aW9uIEIyKGUsdCl7cmV0dXJuIHFIKGUsdCxcImNsYXNzV2VpZ2h0XCIpfWFzeW5jIGZ1bmN0aW9uIFYyKGUsdCxuLGEpe2lmKHQhPW51bGx8fGEhPW51bGwpdGhyb3cgbmV3IEVycm9yKFwiU3VwcG9ydCBzYW1wbGVXZWlnaHQgaXMgbm90IGltcGxlbWVudGVkIHlldFwiKTtpZihuIT1udWxsKXtsZXQgcj1PKCgpPT57aWYoZS5zaGFwZS5sZW5ndGg9PT0xKXJldHVybiBzcihlKTtpZihlLnNoYXBlLmxlbmd0aD09PTIpe2lmKGUuc2hhcGVbMV0+MSlyZXR1cm4gZGkoZSwxKTtpZihlLnNoYXBlWzFdPT09MSlyZXR1cm4gVyhlLFtlLnNoYXBlWzBdXSk7dGhyb3cgbmV3IEVycm9yKGBFbmNvdW50ZXJlZCB1bmV4cGVjdGVkIGxhc3QtZGltZW5zaW9uIHNpemUgKCR7ZS5zaGFwZVsxXX0pIGR1cmluZyBoYW5kbGluZyBvZiBjbGFzcyB3ZWlnaHRzLiBUaGUgc2l6ZSBpcyBleHBlY3RlZCB0byBiZSA+PSAxLmApfWVsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJhbmsgb2YgdGFyZ2V0ICh5KSB0ZW5zb3IgKCR7ZS5yYW5rfSkgZHVyaW5nIGhhbmRsaW5nIG9mIGNsYXNzIHdlaWdodHMuIFRoZSByYW5rIGlzIGV4cGVjdGVkIHRvIGJlIDEgb3IgMi5gKX0pLHM9QXJyYXkuZnJvbShhd2FpdCByLmRhdGEoKSk7RWUocik7bGV0IGk9W107cmV0dXJuIHMuZm9yRWFjaChvPT57aWYobltvXT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYGNsYXNzV2VpZ2h0IG11c3QgY29udGFpbiBhbGwgY2xhc3NlcyBpbiB0aGUgdHJhaW5pbmcgZGF0YS4gVGhlIGNsYXNzICR7b30gZXhpc3RzIGluIHRoZSBkYXRhIGJ1dCBub3QgaW4gY2xhc3NXZWlnaHRgKTtpLnB1c2gobltvXSl9KSxqZShpLFwiZmxvYXQzMlwiKX1lbHNlIHJldHVybiBudWxsfWZ1bmN0aW9uIEtIKGUsdCl7cmV0dXJuIHooZSx0KX12YXIgWEg9MzI7ZnVuY3Rpb24gVTIoZSx0KXtsZXQgbixhLHI9dDtuPXIueHMsYT1yLnlzLHcuYXNzZXJ0KG4hPW51bGwmJmEhPW51bGwsKCk9PmBBIERhdGFzZXQgaXRlcmF0b3IgZm9yIGZpdERhdGFzZXQoKSBpcyBleHBlY3RlZCB0byBnZW5lcmF0ZSBvYmplY3RzIG9mIHRoZSBmb3JtIFxcYHt4czogeFZhbCwgeXM6IHlWYWx9XFxgLCB3aGVyZSB0aGUgdHdvIHZhbHVlcyBtYXkgYmUgXFxgdGYuVGVuc29yXFxgLCBhbiBhcnJheSBvZiBUZW5zb3JzLCBvciBhIG1hcCBvZiBzdHJpbmcgdG8gVGVuc29yLiAgVGhlIHByb3ZpZGVkIERhdGFzZXQgaW5zdGVhZCBnZW5lcmF0ZXMgJHt0fWApO2xldCBzPVRJKFwiaW5wdXRcIixlLmlucHV0TmFtZXMsbiksaT1USShcIm91dHB1dFwiLGUub3V0cHV0TmFtZXMsYSksbz1zWzBdLnNoYXBlWzBdO3cuYXNzZXJ0KHMubGVuZ3RoPT09ZS5pbnB1dHMubGVuZ3RoLCgpPT5gTGF5ZXJzTW9kZWwgaGFzICR7ZS5pbnB1dHMubGVuZ3RofSBpbnB1dHMsIGJ1dCB0aGUgZGF0YXNldCBwcm92aWRlcyAke3MubGVuZ3RofSBpbnB1dHMuICAoRXhwZWN0ZWQgaW5wdXQga2V5czogJHtKU09OLnN0cmluZ2lmeShlLmlucHV0TmFtZXMpfSlgKSx3LmFzc2VydChpLmxlbmd0aD09PWUub3V0cHV0cy5sZW5ndGgsKCk9PmBMYXllcnNNb2RlbCBoYXMgJHtlLm91dHB1dHMubGVuZ3RofSBvdXRwdXRzLCBidXQgdGhlIGRhdGFzZXQgcHJvdmlkZXMgJHtpLmxlbmd0aH0gb3V0cHV0cy4gIChFeHBlY3RlZCBvdXRwdXQga2V5czogJHtKU09OLnN0cmluZ2lmeShlLm91dHB1dE5hbWVzKX0pYCk7Zm9yKGxldCBsPTA7bDxzLmxlbmd0aDtsKyspdy5hc3NlcnQoc1tsXS5zaGFwZVswXT09PW8sKCk9PmBCYXRjaCBzaXplIG1pc21hdGNoOiBpbnB1dCAke2UuaW5wdXROYW1lc1tsXX0gaGFzICR7c1tsXS5zaGFwZVswXX07IGV4cGVjdGVkICAke299IGJhc2VkIG9uIGlucHV0ICR7ZS5pbnB1dE5hbWVzWzBdfS5gKTtmb3IobGV0IGw9MDtsPGkubGVuZ3RoO2wrKyl3LmFzc2VydChpW2xdLnNoYXBlWzBdPT09bywoKT0+YEJhdGNoIHNpemUgbWlzbWF0Y2g6IG91dHB1dCAke2Uub3V0cHV0TmFtZXNbbF19IGhhcyAke2lbbF0uc2hhcGVbMF19OyBleHBlY3RlZCAgJHtvfSBiYXNlZCBvbiBpbnB1dCAke2UuaW5wdXROYW1lc1swXX0uYCk7cmV0dXJue3hzOnMseXM6aX19ZnVuY3Rpb24gVEkoZSx0LG4pe2lmKG4gaW5zdGFuY2VvZiBDZSlyZXR1cm5bbl07aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gdy5hc3NlcnQobi5sZW5ndGg9PT10Lmxlbmd0aCwoKT0+YFJlY2VpdmVkIGFuIGFycmF5IG9mICR7bi5sZW5ndGh9IFRlbnNvcnMsIGJ1dCBleHBlY3RlZCAke3QubGVuZ3RofSB0byBtYXRjaCB0aGUgJHtlfSBrZXlzICR7dH0uYCksbjt7bGV0IGE9W107Zm9yKGxldCByIG9mIHQpe2lmKG5bcl09PW51bGwpdGhyb3cgbmV3IFYoYFRoZSBmZWF0dXJlIGRhdGEgZ2VuZXJhdGVkIGJ5IHRoZSBkYXRhc2V0IGxhY2tzIHRoZSByZXF1aXJlZCAke2V9IGtleSAnJHtyfScuYCk7YS5wdXNoKG5bcl0pfXJldHVybiBhfX1mdW5jdGlvbiBZSChlKXtpZihlLmxlbmd0aD09PTMpdGhyb3cgbmV3IHplKFwiVmFsaWRhdGlvbiB3aXRoIHNhbXBsZSB3ZWlnaHRzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybnt4czplWzBdLHlzOmVbMV19fWFzeW5jIGZ1bmN0aW9uIFpIKGUsdCxuKXtsZXQgYT1uLmJhdGNoZXNQZXJFcG9jaCE9bnVsbDtpZih3LmFzc2VydChlLm9wdGltaXplciE9bnVsbCwoKT0+XCJZb3UgbXVzdCBjb21waWxlIGEgbW9kZWwgYmVmb3JlIHRyYWluaW5nL3Rlc3RpbmcuIFVzZSBMYXllcnNNb2RlbC5jb21waWxlKG1vZGVsQ29tcGlsZUNvbmZpZykuXCIpLHcuYXNzZXJ0KG4hPW51bGwsKCk9PlwiRm9yIGZpdERhdGFzZXQoKSwgdGhlIDJuZCBhcmd1bWVudCAoY29uZmlnKSBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGlzIGNhbGwuXCIpLHcuYXNzZXJ0KG4uZXBvY2hzIT1udWxsJiZuLmVwb2Nocz4wJiZOdW1iZXIuaXNJbnRlZ2VyKG4uZXBvY2hzKSwoKT0+YEZvciBmaXREYXRhc2V0KCksIGNvbmZpZy5lcG9jaHMgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290ICR7bi5lcG9jaHN9YCksdy5hc3NlcnQoIWF8fG4uYmF0Y2hlc1BlckVwb2NoPjAmJk51bWJlci5pc0ludGVnZXIobi5iYXRjaGVzUGVyRXBvY2gpLCgpPT5gRm9yIGZpdERhdGFzZXQoKSwgY29uZmlnLmJhdGNoZXNQZXJFcG9jaCBpcyBleHBlY3RlZCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkLCBidXQgZ290ICR7bi5iYXRjaGVzUGVyRXBvY2h9YCksdy5hc3NlcnQobi52YWxpZGF0aW9uU3BsaXQ9PW51bGwsKCk9PlwiYHZhbGlkYXRpb25TcGxpdGAgaXMgbm90IHN1cHBvcnRlZCBieSBgZml0RGF0YXNldCgpYC4gVXNlIHZhbGlkYXRpb25EYXRhIGluc3RlYWQuXCIpLGUuaXNUcmFpbmluZyl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RhcnQgdHJhaW5pbmcgYmVjYXVzZSBhbm90aGVyIGZpdCgpIGNhbGwgaXMgb25nb2luZy5cIik7ZS5pc1RyYWluaW5nPSEwO3RyeXtsZXQgcj1uLnZhbGlkYXRpb25EYXRhIT1udWxsLHMsaTtpZihyKWlmKENJKG4udmFsaWRhdGlvbkRhdGEpKXcuYXNzZXJ0KG4udmFsaWRhdGlvbkJhdGNoZXM9PW51bGx8fG4udmFsaWRhdGlvbkJhdGNoZXM+MCYmTnVtYmVyLmlzSW50ZWdlcihuLnZhbGlkYXRpb25CYXRjaGVzKSwoKT0+YEZvciBmaXREYXRhc2V0KCkgd2l0aCBkYXRhc2V0LWJhc2VkIHZhbGlkYXRpb24sIGNvbmZpZy52YWxpZGF0aW9uQmF0Y2hlcyBpcyBleHBlY3RlZCBub3QgdG8gYmUgcHJvdmlkZWQsIG9yIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke24udmFsaWRhdGlvbkJhdGNoZXN9YCk7ZWxzZXtsZXQgZz1ZSChuLnZhbGlkYXRpb25EYXRhKTtzPWcueHMsaT1nLnlzfWxldCBvPWUubWFrZVRyYWluRnVuY3Rpb24oKSxsPWUuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpLHU7cj91PWwuc2xpY2UoKS5jb25jYXQobC5tYXAoZz0+XCJ2YWxfXCIrZykpOnU9bC5zbGljZSgpO2xldCBwPUQyKG4uY2FsbGJhY2tzLG4ueWllbGRFdmVyeSksZD1uLnZlcmJvc2U9PW51bGw/MTpuLnZlcmJvc2Use2NhbGxiYWNrTGlzdDpjLGhpc3Rvcnk6aH09UjIocCxkLG4uZXBvY2hzLG51bGwsbnVsbCxKSCh0LG4pLG51bGwscix1KTtjLnNldE1vZGVsKGUpLGUuaGlzdG9yeT1oLGF3YWl0IGMub25UcmFpbkJlZ2luKCksZS5zdG9wVHJhaW5pbmdfPSExO2xldCBtPW4uaW5pdGlhbEVwb2NoPT1udWxsPzA6bi5pbml0aWFsRXBvY2gsZj1hd2FpdCB0Lml0ZXJhdG9yKCk7Zm9yKDttPG4uZXBvY2hzOyl7bGV0IGc9e307YXdhaXQgYy5vbkVwb2NoQmVnaW4obSk7bGV0IGI9MCx5PTA7Zm9yKGF8fChmPWF3YWl0IHQuaXRlcmF0b3IoKSk7IWF8fGI8bi5iYXRjaGVzUGVyRXBvY2g7KXtsZXQgeD1hd2FpdCBmLm5leHQoKTtpZihhJiZ4LmRvbmUpe2NvbnNvbGUud2FybihgWW91IHByb3ZpZGVkIFxcYGJhdGNoZXNQZXJFcG9jaFxcYCBhcyAke24uYmF0Y2hlc1BlckVwb2NofSwgYnV0IHlvdXIgZGF0YXNldCBpdGVyYXRvciByYW4gb3V0IG9mIGRhdGEgYWZ0ZXIgJHtifSBiYXRjaGVzOyBpbnRlcnJ1cHRpbmcgdHJhaW5pbmcuIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgXFxgYmF0Y2hlc1BlckVwb2NoICogZXBvY2hzXFxgIGJhdGNoZXMgKGluIHRoaXMgY2FzZSwgJHtuLmJhdGNoZXNQZXJFcG9jaCpuLmVwb2Noc30gYmF0Y2hlcykuIFlvdSBtYXkgbmVlZCB0byB1c2UgdGhlIHJlcGVhdCgpIGZ1bmN0aW9uIHdoZW4gYnVpbGRpbmcgeW91ciBkYXRhc2V0LmApO2JyZWFrfWlmKHgudmFsdWUhPW51bGwpe2xldHt4czp2LHlzOkl9PVUyKGUseC52YWx1ZSksTj17fTtOLmJhdGNoPXksTi5zaXplPXZbMF0uc2hhcGVbMF0sYXdhaXQgYy5vbkJhdGNoQmVnaW4oeSxOKTtsZXQgQz1bXTtpZihuLmNsYXNzV2VpZ2h0IT1udWxsKXtsZXQgRD1CMihuLmNsYXNzV2VpZ2h0LGUub3V0cHV0TmFtZXMpO2ZvcihsZXQgJD0wOyQ8RC5sZW5ndGg7KyskKUMucHVzaChhd2FpdCBWMihJWyRdLG51bGwsRFskXSkpfWxldCBfPXYuY29uY2F0KEkpLmNvbmNhdChDKSxGPW8oXyk7RWUoXyk7Zm9yKGxldCBEPTA7RDxsLmxlbmd0aDsrK0Qpe2xldCAkPWxbRF0sUz1GW0RdO05bJF09UyxIdChTKX1hd2FpdCBjLm9uQmF0Y2hFbmQoeSxOKSxfMihOKSx5KyssYisrfWlmKGE/Yj49bi5iYXRjaGVzUGVyRXBvY2g6eC5kb25lKXtpZihyKXtsZXQgdjtDSShuLnZhbGlkYXRpb25EYXRhKT92PWl0KGF3YWl0IGUuZXZhbHVhdGVEYXRhc2V0KG4udmFsaWRhdGlvbkRhdGEse2JhdGNoZXM6bi52YWxpZGF0aW9uQmF0Y2hlc30pKTp2PWl0KGUuZXZhbHVhdGUocyxpLHtiYXRjaFNpemU6bi52YWxpZGF0aW9uQmF0Y2hTaXplPT1udWxsP1hIOm4udmFsaWRhdGlvbkJhdGNoU2l6ZSx2ZXJib3NlOjB9KSk7Zm9yKGxldCBJPTA7STxlLm1ldHJpY3NOYW1lcy5sZW5ndGg7KytJKWdbYHZhbF8ke2UubWV0cmljc05hbWVzW0ldfWBdPXZbSV19YnJlYWt9aWYoZS5zdG9wVHJhaW5pbmdfKWJyZWFrfWlmKGF3YWl0IGMub25FcG9jaEVuZChtLGcpLG0rKyxlLnN0b3BUcmFpbmluZ18pYnJlYWt9cmV0dXJuIGF3YWl0IGMub25UcmFpbkVuZCgpLGF3YWl0IGUuaGlzdG9yeS5zeW5jRGF0YSgpLGUuaGlzdG9yeX1maW5hbGx5e2UuaXNUcmFpbmluZz0hMX19ZnVuY3Rpb24gSkgoZSx0KXtsZXQgbj1udWxsO3JldHVybiB0LmJhdGNoZXNQZXJFcG9jaCE9bnVsbD9uPXQuYmF0Y2hlc1BlckVwb2NoOk51bWJlci5pc0Zpbml0ZShlLnNpemUpJiYobj1lLnNpemUpLG59ZnVuY3Rpb24gQ0koZSl7cmV0dXJuIHR5cGVvZiBlLml0ZXJhdG9yPT1cImZ1bmN0aW9uXCJ9ZnVuY3Rpb24gUUgoZSl7cmV0dXJuIHR5cGVvZiBlLm5leHQ9PVwiZnVuY3Rpb25cIn1hc3luYyBmdW5jdGlvbiBlaihlLHQsbil7bj1ufHx7fTtsZXQgYT1uLmJhdGNoZXMhPW51bGwscj1lLnRlc3RGdW5jdGlvbixzPVtdO2lmKG4udmVyYm9zZT4wKXRocm93IG5ldyB6ZShcIlZlcmJvc2UgbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTt3LmFzc2VydCghYXx8bi5iYXRjaGVzPjAmJk51bWJlci5pc0ludGVnZXIobi5iYXRjaGVzKSwoKT0+YFRlc3QgbG9vcCBleHBlY3RzIFxcYGJhdGNoZXNcXGAgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShuLmJhdGNoZXMpfWApO2xldCBpPVFIKHQpP3Q6YXdhaXQgdC5pdGVyYXRvcigpLG89MCxsPTA7Zm9yKDshYXx8bDxuLmJhdGNoZXM7KXtsZXQgdT1hd2FpdCBpLm5leHQoKTtpZihzPU8oKCk9PntpZih1LnZhbHVlKXtsZXR7eHM6cCx5czpkfT1VMihlLHUudmFsdWUpLGM9cC5jb25jYXQoZCksaD1PKCgpPT5yKGMpKTtpZihFZShjKSxsPT09MClmb3IobGV0IGY9MDtmPGgubGVuZ3RoOysrZilzLnB1c2goeGUoMCkpO2xldCBtPWNbMF0uc2hhcGVbMF07Zm9yKGxldCBmPTA7ZjxoLmxlbmd0aDsrK2Ype2xldCBnPWhbZl0sYj1zW2ZdO3NbZl09TygoKT0+WChzW2ZdLHoobSxnKSkpLGw+MCYmRWUoYil9RWUoaCksbys9bSwrK2x9cmV0dXJuIHN9KSx1LmRvbmUpe2EmJmNvbnNvbGUud2FybihgWW91ciBkYXRhc2V0IGl0ZXJhdG9yIHJhbiBvdXQgb2YgZGF0YSBkdXJpbmcgZXZhbHVhdGVEYXRhc2V0KCkuIEludGVycnVwdGluZyBldmFsdXRpb24uIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgXFxgYmF0Y2hlc1xcYCBiYXRjaGVzIChpbiB0aGlzIGNhc2UsICR7bi5iYXRjaGVzfSBiYXRjaGVzKS4gWW91IG1heSBuZWVkIHRvIHVzZSB0aGUgcmVwZWF0KCkgZnVuY3Rpb24gd2hlbiBidWlsZGluZyB5b3VyIGRhdGFzZXQuYCk7YnJlYWt9fWZvcihsZXQgdT0wO3U8cy5sZW5ndGg7Kyt1KXtsZXQgcD1zW3VdO3NbdV09aGUoc1t1XSxvKSxFZShwKX1yZXR1cm4gTW4ocyl9ZnVuY3Rpb24gaHgoZSl7dy5hc3NlcnQoZT4wJiZOdW1iZXIuaXNJbnRlZ2VyKGUpLCgpPT5gYmF0Y2hTaXplIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke2V9YCl9ZnVuY3Rpb24gWHAoZSx0LG4pe3JldHVybiBlPT1udWxsP1tudWxsXTpBcnJheS5pc0FycmF5KGUpP2UubWFwKGE9PnNpKGEsdCxuLXQpKTpzaShlLHQsbi10KX1mdW5jdGlvbiBqeChlLHQpe3JldHVybiBPKCgpPT5lPT1udWxsP251bGw6QXJyYXkuaXNBcnJheShlKT9lLm1hcChuPT5qeChuLHQpKTp2MihlLHQuZHR5cGU9PT1cImludDMyXCI/dDpyZSh0LFwiaW50MzJcIikpKX1mdW5jdGlvbiBteChlLHQpe2xldCBuPVtdLGE9MCxyPW51bGw7Zm9yKDthPGU7KXI9YSt0LHI+PWUmJihyPWUpLG4ucHVzaChbYSxyXSksYT1yO3JldHVybiBufWZ1bmN0aW9uIEcyKGUpe2xldCB0PVtdO2UgaW5zdGFuY2VvZiBDZSYmKGU9W2VdKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbil7bGV0IGE9ZVtuXTtpZihhLnJhbms9PT0xKXQucHVzaCh3ZChhLDEpKTtlbHNle2lmKGEucmFuaz09PTApdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdGVuc29yIHRvIGJlIGF0IGxlYXN0IDFELCBidXQgcmVjZWl2ZWQgYSAwRCB0ZW5zb3IgKHNjYWxhcikuXCIpO3QucHVzaChhKX19cmV0dXJuIHR9ZnVuY3Rpb24gUGEoZSx0KXtpZihlPT1udWxsKXJldHVybjtsZXQgbj1bXTtpZih0IGluc3RhbmNlb2YgQ2Upbi5wdXNoKHQuaWQpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0KSl0LmZvckVhY2gocj0+bi5wdXNoKHIuaWQpKTtlbHNlIGlmKHQhPW51bGwpZm9yKGxldCByIGluIHQpe2xldCBzPXRbcl07bi5wdXNoKHMuaWQpfWxldCBhPVtdO2lmKGUgaW5zdGFuY2VvZiBDZSluLmluZGV4T2YoZS5pZCk9PT0tMSYmYS5wdXNoKGUpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKSllLmZvckVhY2gocj0+e24uaW5kZXhPZihyLmlkKT09PS0xJiZhLnB1c2gocil9KTtlbHNlIGlmKGUhPW51bGwpZm9yKGxldCByIGluIGUpe2xldCBzPWVbcl07bi5pbmRleE9mKHMuaWQpPT09LTEmJmEucHVzaChzKX1hLmZvckVhY2gocj0+e3IuaXNEaXNwb3NlZHx8ci5kaXNwb3NlKCl9KX1mdW5jdGlvbiB0aihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIENlfWZ1bmN0aW9uIHF4KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpfWZ1bmN0aW9uIEVJKGUpe3JldHVybiF0aihlKSYmIXF4KGUpfWZ1bmN0aW9uIF9JKGUsdCxuLGE9ITAscj1cIlwiKXtpZih0PT1udWxsfHx0Lmxlbmd0aD09PTApe2lmKGUhPW51bGwpe2xldCBpPSExO2lmKHF4KGUpJiZlLmxlbmd0aD4wKWk9ITA7ZWxzZSBpZihFSShlKSl7Zm9yKGxldCBvIGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eShvKSl7aT0hMDticmVha319ZWxzZSBpPSEwO2lmKGkpdGhyb3cgbmV3IFYoYEVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgJHtyfSBleHBlY3RlZCBubyBkYXRhLCBidXQgZ290ICR7ZX1gKX1yZXR1cm5bXX1pZihlPT1udWxsKXJldHVybiB0Lm1hcChpPT5udWxsKTtsZXQgcztpZihFSShlKSl7ZT1lLHM9W107Zm9yKGxldCBpIG9mIHQpe2lmKGVbaV09PW51bGwpdGhyb3cgbmV3IFYoYE5vIGRhdGEgcHJvdmlkZWQgZm9yIFwiJHtpfVwiLiBOZWVkIGRhdGEgZm9yIGVhY2gga2V5IGluOiAke3R9YCk7cy5wdXNoKGVbaV0pfX1lbHNlIGlmKHF4KGUpKXtpZihlPWUsZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgVihgRXJyb3Igd2hlbiBjaGVja2luZyBtb2RlbCAke3J9OiB0aGUgQXJyYXkgb2YgVGVuc29ycyB0aGF0IHlvdSBhcmUgcGFzc2luZyB0byB5b3VyIG1vZGVsIGlzIG5vdCB0aGUgc2l6ZSB0aGUgbW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSAke3QubGVuZ3RofSBUZW5zb3IocyksIGJ1dCBpbnN0ZWFkIGdvdCB0aGUgZm9sbG93aW5nIGxpc3Qgb2YgVGVuc29yKHMpOiAke2V9YCk7cz1lfWVsc2V7aWYoZT1lLHQubGVuZ3RoPjEpdGhyb3cgbmV3IFYoYFRoZSBtb2RlbCAke3J9IGV4cGVjdHMgJHt0Lmxlbmd0aH0gVGVuc29yKHMpLCBidXQgb25seSByZWNlaXZlZCBvbmUgVGVuc29yLiBGb3VuZDogVGVuc29yIHdpdGggc2hhcGUgJHtlLnNoYXBlfWApO3M9W2VdfWlmKHM9RzIocyksbiE9bnVsbClmb3IobGV0IGk9MDtpPHQubGVuZ3RoOysraSl7aWYobltpXT09bnVsbCljb250aW51ZTtsZXQgbz1zW2ldO2lmKG8uc2hhcGUubGVuZ3RoIT09bltpXS5sZW5ndGgpdGhyb3cgbmV3IFYoYEVycm9yIHdoZW4gY2hlY2tpbmcgJHtyfTogZXhwZWN0ZWQgJHt0W2ldfSB0byBoYXZlICR7bltpXS5sZW5ndGh9IGRpbWVuc2lvbihzKS4gYnV0IGdvdCBhcnJheSB3aXRoIHNoYXBlICR7by5zaGFwZX1gKTtmb3IobGV0IGw9MDtsPG5baV0ubGVuZ3RoOysrbCl7aWYobD09PTAmJiFhKWNvbnRpbnVlO2xldCB1PW8uc2hhcGVbbF0scD1uW2ldW2xdO2lmKHAhPW51bGwmJnA+PTAmJnUhPT1wKXRocm93IG5ldyBWKGAke3J9IGV4cGVjdGVkIGEgYmF0Y2ggb2YgZWxlbWVudHMgd2hlcmUgZWFjaCBleGFtcGxlIGhhcyBzaGFwZSBbJHtuW2ldLnNsaWNlKDEsbltpXS5sZW5ndGgpfV0gKGkuZS4sdGVuc29yIHNoYXBlIFsqLCR7bltpXS5zbGljZSgxLG5baV0ubGVuZ3RoKX1dKSBidXQgdGhlICR7cn0gcmVjZWl2ZWQgYW4gaW5wdXQgd2l0aCAke28uc2hhcGVbMF19IGV4YW1wbGVzLCBlYWNoIHdpdGggc2hhcGUgWyR7by5zaGFwZS5zbGljZSgxLG8uc2hhcGUubGVuZ3RoKX1dICh0ZW5zb3Igc2hhcGUgWyR7by5zaGFwZX1dKWApfX1yZXR1cm4gc31mdW5jdGlvbiBuaihlLHQsbil7bGV0IGE9YXMoZS5tYXAocz0+cy5zaGFwZVswXSkpO2Euc29ydCgpO2xldCByPWFzKHQubWFwKHM9PnMuc2hhcGVbMF0pKTtpZihyLnNvcnQoKSxhLmxlbmd0aD4xKXRocm93IG5ldyBWKGBBbGwgaW5wdXQgVGVuc29ycyAoeCkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMuIEdvdCBhcnJheSBzaGFwZXM6ICR7SlNPTi5zdHJpbmdpZnkoZS5tYXAocz0+cy5zaGFwZSkpfWApO2lmKHIubGVuZ3RoPjEpdGhyb3cgbmV3IFYoYEFsbCB0YXJnZXQgVGVuc29ycyAoeSkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMuIEdvdCBhcnJheSBzaGFwZXM6ICR7SlNPTi5zdHJpbmdpZnkodC5tYXAocz0+cy5zaGFwZSkpfWApO2lmKGEubGVuZ3RoPjAmJnIubGVuZ3RoPjAmJiF3LmFycmF5c0VxdWFsKGEscikpdGhyb3cgbmV3IFYoYElucHV0IFRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMgYXMgdGFyZ2V0IFRlbnNvcnMuIEZvdW5kICR7YVswXX0gaW5wdXQgc2FtcGxlKHMpIGFuZCAke3JbMF19IHRhcmdldCBzYW1wbGUocykuYCl9ZnVuY3Rpb24gYWooZSx0LG4pe2xldCBhPVtYbyxDZixrY107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipe2xldCBzPWVbcl0saT10W3JdLG89bltyXTtpZihpIT1udWxsKXtpZihpPT09a2MmJnMuc2hhcGVbcy5zaGFwZS5sZW5ndGgtMV09PT0xKXRocm93IG5ldyBWKGBZb3UgYXJlIHBhc3NpbmcgYSB0YXJnZXQgYXJyYXkgb2Ygc2hhcGUgJHtzLnNoYXBlfSB3aGlsZSB1c2luZyBhIGxvc3MgJ2NhdGVnb3JpY2FsX2Nyb3NzZW50cm9weScuICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknZXhwZWN0cyB0YXJnZXRzIHRvIGJlIGJpbmFyeSBtYXRyaWNlcyAoMXMgYW5kIDBzKSBvZiBzaGFwZSBbc2FtcGxlcywgY2xhc3Nlc10uYCk7aWYoYS5pbmRleE9mKGkpIT09LTEpe2xldCBsPXMuc2hhcGUuc2xpY2UoMSksdT1vLnNsaWNlKDEpO2ZvcihsZXQgcD0wO3A8bC5sZW5ndGg7KytwKXtsZXQgZD1sW3BdLGM9dVtwXTtpZihjIT1udWxsJiZkIT09Yyl0aHJvdyBuZXcgVihgQSB0YXJnZXQgVGVuc29yIHdpdGggc2hhcGUgJHtzLnNoYXBlfSB3YXMgcGFzc2VkIGZvciBhbiBvdXRwdXQgb2Ygc2hhcGUgJHtvfSwgd2hpbGUgdXNpbmcgYSBsb3NzIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0YXJnZXRzIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGUgYXMgdGhlIG91dHB1dC5gKX19fX19ZnVuY3Rpb24gQUkoZSx0LG4sYT0hMCxyPVwiXCIpe2xldCBzO2lmKEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IFYoYEVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgJHtyfTogdGhlIEFycmF5IG9mIFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIHRoZSBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlICR7dC5sZW5ndGh9IFRlbnNvcihzKSwgYnV0IGluc3RlYWQgZ290ICR7ZS5sZW5ndGh9IFRlbnNvcnMocykuYCk7cz1lfWVsc2V7aWYodC5sZW5ndGg+MSl0aHJvdyBuZXcgVihgVGhlIG1vZGVsIGV4cGVjdHMgJHt0Lmxlbmd0aH0gJHtyfSBUZW5zb3JzLCBidXQgb25seSByZWNlaXZlZCBvbmUgVGVuc29yLiBGb3VuZDogYXJyYXkgd2l0aCBzaGFwZSAke0pTT04uc3RyaW5naWZ5KGUuc2hhcGUpfS5gKTtzPVtlXX1pZihuIT1udWxsKWZvcihsZXQgaT0wO2k8dC5sZW5ndGg7KytpKXtpZihuW2ldPT1udWxsKWNvbnRpbnVlO2xldCBvPXNbaV07aWYoby5zaGFwZS5sZW5ndGghPT1uW2ldLmxlbmd0aCl0aHJvdyBuZXcgVihgRXJyb3Igd2hlbiBjaGVja2luZyAke3J9OiBleHBlY3RlZCAke3RbaV19IHRvIGhhdmUgJHtuW2ldLmxlbmd0aH0gZGltZW5zaW9uKHMpLCBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgJHtKU09OLnN0cmluZ2lmeShvLnNoYXBlKX1gKTtmb3IobGV0IGw9MDtsPG5baV0ubGVuZ3RoOysrbCl7aWYobD09PTAmJiFhKWNvbnRpbnVlO2xldCB1PW8uc2hhcGVbbF0scD1uW2ldW2xdO2lmKHAhPW51bGwmJnAhPT11KXRocm93IG5ldyBWKGBFcnJvciB3aGVuIGNoZWNraW5nICR7cn06IGV4cGVjdGVkICR7dFtpXX0gdG8gaGF2ZSBzaGFwZSAke0pTT04uc3RyaW5naWZ5KG5baV0pfSBidXQgZ290IGFycmF5IHdpdGggc2hhcGUgJHtKU09OLnN0cmluZ2lmeShvLnNoYXBlKX0uYCl9fX1mdW5jdGlvbiByaihlLHQpe2lmKGU9PW51bGx8fEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoPT09MClyZXR1cm4gdC5tYXAoYT0+W10pO2xldCBuO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wifHx0eXBlb2YgZT09XCJmdW5jdGlvblwiKW49W2VdO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlKXx8dHlwZW9mIGU9PVwib2JqZWN0XCIpbj1lO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgVHlwZSBvZiBtZXRyaWNzIGFyZ3VtZW50IG5vdCB1bmRlcnN0b29kLiBFeHBlY3RlZCBhbiBzdHJpbmcsZnVuY3Rpb24sIEFycmF5LCBvciBPYmplY3QsIGZvdW5kOiAke2V9YCk7aWYoQXJyYXkuaXNBcnJheShuKSlyZXR1cm4gdC5tYXAoYT0+bik7e2xldCBhPVtdO2ZvcihsZXQgciBvZiB0KXtsZXQgcz1uLmhhc093blByb3BlcnR5KHIpP25bcl06W107QXJyYXkuaXNBcnJheShzKXx8KHM9W3NdKSxhLnB1c2gocyl9cmV0dXJuIGF9fXZhciBzaj1cImxheWVycy1tb2RlbFwiLEVyPWNsYXNzIGV4dGVuZHMgakh7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5pc1RyYWluaW5nPSExfXN1bW1hcnkoZSx0LG49Y29uc29sZS5sb2cpe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBWKFwiVGhpcyBtb2RlbCBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQsIHRodXMgaXRzIHdlaWdodHMgaGF2ZSBub3QgYmVlbiBjcmVhdGVkIHlldC4gU28gbm8gc3VtbWFyeSBjYW4gYmUgZGlzcGxheWVkLiBCdWlsZCB0aGUgbW9kZWwgZmlyc3QgKGUuZy4sIGJ5IGNhbGxpbmcgaXQgb24gc29tZSB0ZXN0IGRhdGEpLlwiKTtXSCh0aGlzLGUsdCxuKX1jb21waWxlKGUpe2lmKGUubG9zcz09bnVsbCYmKGUubG9zcz1bXSksdGhpcy5sb3NzPWUubG9zcyx0eXBlb2YgZS5vcHRpbWl6ZXI9PVwic3RyaW5nXCIpdGhpcy5vcHRpbWl6ZXJfPXpIKGUub3B0aW1pemVyKSx0aGlzLmlzT3B0aW1pemVyT3duZWQ9ITA7ZWxzZXtpZighKGUub3B0aW1pemVyIGluc3RhbmNlb2YgUnIpKXRocm93IG5ldyBWKFwiVXNlci1kZWZpbmVkIG9wdGltaXplciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHRmLk9wdGltaXplci5cIik7dGhpcy5vcHRpbWl6ZXJfPWUub3B0aW1pemVyLHRoaXMuaXNPcHRpbWl6ZXJPd25lZD0hMX1sZXQgdD1bXTtpZighQXJyYXkuaXNBcnJheShlLmxvc3MpJiZ0eXBlb2YgZS5sb3NzIT1cInN0cmluZ1wiJiZ0eXBlb2YgZS5sb3NzIT1cImZ1bmN0aW9uXCIpe2UubG9zcz1lLmxvc3M7Zm9yKGxldCBzIGluIGUubG9zcylpZih0aGlzLm91dHB1dE5hbWVzLmluZGV4T2Yocyk9PT0tMSl0aHJvdyBuZXcgVihgVW5rbm93biBlbnRyeSBpbiBsb3NzIGRpY3Rpb25hcnk6IFwiJHtzfVwiLiBPbmx5IGV4cGVjdGVkIHRoZSBmb2xsb3dpbmcga2V5czogJHt0aGlzLm91dHB1dE5hbWVzfWApO2ZvcihsZXQgcyBvZiB0aGlzLm91dHB1dE5hbWVzKWUubG9zc1tzXT09bnVsbCYmY29uc29sZS53YXJuKGBPdXRwdXQgXCIke3N9XCIgaXMgbWlzc2luZyBmcm9tIGxvc3MgZGljdGlvbmFyeS4gV2UgYXNzdW1lIHRoaXMgd2FzIGRvbmUgb24gcHVycG9zZSwgYW5kIHdlIHdpbGwgbm90IGJlIGV4cGVjdGluZyBkYXRhIHRvIGJlIHBhc3NlZCB0byAke3N9IGR1cmluZyB0cmFpbmluZ2ApLHQucHVzaChkeChlLmxvc3Nbc10pKX1lbHNlIGlmKEFycmF5LmlzQXJyYXkoZS5sb3NzKSl7aWYoZS5sb3NzLmxlbmd0aCE9PXRoaXMub3V0cHV0cy5sZW5ndGgpdGhyb3cgbmV3IFYoYFdoZW4gcGFzc2luZyBhbiBBcnJheSBhcyBsb3NzLCBpdCBzaG91bGQgaGF2ZSBvbmUgZW50cnkgcGVyIG1vZGVsIG91dHB1dC4gVGhlIG1vZGVsIGhhcyAke3RoaXMub3V0cHV0cy5sZW5ndGh9IG91dHB1dChzKSwgYnV0IHlvdSBwYXNzZWQgbG9zcz0ke2UubG9zc30uYCk7dD1lLmxvc3MubWFwKHM9PmR4KHMpKX1lbHNle2xldCBzPWR4KGUubG9zcyk7dGhpcy5vdXRwdXRzLmZvckVhY2goaT0+e3QucHVzaChzKX0pfXRoaXMubG9zc0Z1bmN0aW9ucz10LHRoaXMuZmVlZE91dHB1dE5hbWVzPVtdLHRoaXMuZmVlZE91dHB1dFNoYXBlcz1bXSx0aGlzLmZlZWRMb3NzRm5zPVtdO2ZvcihsZXQgcz0wO3M8dGhpcy5vdXRwdXRzLmxlbmd0aDsrK3Mpe2xldCBpPXRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbc10sbz10aGlzLm91dHB1dE5hbWVzW3NdO3RoaXMuZmVlZE91dHB1dE5hbWVzLnB1c2gobyksdGhpcy5mZWVkT3V0cHV0U2hhcGVzLnB1c2goaSksdGhpcy5mZWVkTG9zc0Zucy5wdXNoKHRoaXMubG9zc0Z1bmN0aW9uc1tzXSl9bGV0IG49W107dGhpcy5tZXRyaWNzPWUubWV0cmljcyx0aGlzLm1ldHJpY3NOYW1lcz1bXCJsb3NzXCJdLHRoaXMubWV0cmljc1RlbnNvcnM9W10scmkoXCJsb3NzXCIsKCk9Pntmb3IobGV0IHM9MDtzPHRoaXMub3V0cHV0cy5sZW5ndGg7KytzKXtpZihuLmluZGV4T2YocykhPT0tMSljb250aW51ZTtsZXQgaT10aGlzLmxvc3NGdW5jdGlvbnNbc107dGhpcy5vdXRwdXRzLmxlbmd0aD4xJiYodGhpcy5tZXRyaWNzVGVuc29ycy5wdXNoKFtpLHNdKSx0aGlzLm1ldHJpY3NOYW1lcy5wdXNoKHRoaXMub3V0cHV0TmFtZXNbc10rXCJfbG9zc1wiKSl9fSk7bGV0IGE9cmooZS5tZXRyaWNzLHRoaXMub3V0cHV0TmFtZXMpLHI9KHMsaSxvKT0+e3RoaXMub3V0cHV0TmFtZXMubGVuZ3RoPjEmJihpPXRoaXMub3V0cHV0TmFtZXNbc10rXCJfXCIraSksdGhpcy5tZXRyaWNzTmFtZXMucHVzaChpKSx0aGlzLm1ldHJpY3NUZW5zb3JzLnB1c2goW28sc10pfTtyaShcIm1ldHJpY1wiLCgpPT57Zm9yKGxldCBzPTA7czx0aGlzLm91dHB1dHMubGVuZ3RoOysrcyl7aWYobi5pbmRleE9mKHMpIT09LTEpY29udGludWU7bGV0IGk9YVtzXTsobz0+e2xldCBsPVwiXCIsdSxwLGQ7Zm9yKGxldCBjIG9mIG8pe2lmKHR5cGVvZiBjPT1cInN0cmluZ1wiJiZbXCJhY2N1cmFjeVwiLFwiYWNjXCIsXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YoYykhPT0tMSl7bGV0IG09dGhpcy5pbnRlcm5hbE91dHB1dFNoYXBlc1tzXTttW20ubGVuZ3RoLTFdPT09MXx8dGhpcy5sb3NzRnVuY3Rpb25zW3NdPT09Q2Y/W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKGMpIT09LTE/cD1iMDpbXCJjcm9zc2VudHJvcHlcIixcImNlXCJdLmluZGV4T2YoYykhPT0tMSYmKHA9UDIpOnRoaXMubG9zc0Z1bmN0aW9uc1tzXT09PW5tP1tcImFjY3VyYWN5XCIsXCJhY2NcIl0uaW5kZXhPZihjKSE9PS0xP3A9TDI6W1wiY3Jvc3NlbnRyb3B5XCIsXCJjZVwiXS5pbmRleE9mKGMpIT09LTEmJihwPXoyKTpbXCJhY2N1cmFjeVwiLFwiYWNjXCJdLmluZGV4T2YoYykhPT0tMT9wPXkwOltcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihjKSE9PS0xJiYocD14MCk7bGV0IGY7W1wiYWNjdXJhY3lcIixcImFjY1wiXS5pbmRleE9mKGMpIT09LTE/Zj1cImFjY1wiOltcImNyb3NzZW50cm9weVwiLFwiY2VcIl0uaW5kZXhPZihjKSE9PS0xJiYoZj1cImNlXCIpLGQ9cCx1PWwrZn1lbHNlIGQ9TEgoYyksdT1sK1NoKGMpO2xldCBoO3JpKHUsKCk9PntoPWR9KSxyKHMsdSxoKX19KShpKX19KSx0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHM9dGhpcy50cmFpbmFibGVXZWlnaHRzfWNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCl7dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzIT1udWxsJiZ0aGlzLnRyYWluYWJsZVdlaWdodHMubGVuZ3RoIT09dGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLmxlbmd0aCYmY29uc29sZS53YXJuKFwiRGlzY3JlcGFuY3kgYmV0d2VlbiB0cmFpbmFibGV3ZWlnaHRzIGFuZCBjb2xsZWN0ZWQgdHJhaW5hYmxlIHdlaWdodHMuIERpZCB5b3Ugc2V0IGBtb2RlbC50cmFpbmFibGVgIHdpdGhvdXQgY2FsbGluZyBgbW9kZWwuY29tcGlsZSgpYCBhZnRlcndhcmRzP1wiKX1ldmFsdWF0ZShlLHQsbj17fSl7bGV0IGE9bi5iYXRjaFNpemU9PW51bGw/MzI6bi5iYXRjaFNpemU7aHgoYSk7bGV0IHI9dGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhWFkoZSx0LCEwLGEpO3RyeXtsZXQgcz1yWzBdLmNvbmNhdChyWzFdKTt0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKTtsZXQgaT10aGlzLnRlc3RGdW5jdGlvbixvPXRoaXMudGVzdExvb3AoaSxzLGEsbi52ZXJib3NlLG4uc3RlcHMpO3JldHVybiBNbihvKX1maW5hbGx5e1BhKHJbMF0sZSksUGEoclsxXSx0KX19YXN5bmMgZXZhbHVhdGVEYXRhc2V0KGUsdCl7cmV0dXJuIHRoaXMubWFrZVRlc3RGdW5jdGlvbigpLGVqKHRoaXMsZSx0KX1jaGVja051bVNhbXBsZXMoZSx0LG4sYT1cInN0ZXBzXCIpe2xldCByO2lmKG4hPW51bGwpe2lmKHI9bnVsbCx0IT1udWxsKXRocm93IG5ldyBWKGBJZiAke2F9IGlzIHNldCwgYmF0Y2hTaXplIG11c3QgYmUgbnVsbCBvciB1bmRlZmluZWQuR290IGJhdGNoU2l6ZSA9ICR7dH1gKX1lbHNlIGlmKGUhPW51bGwpQXJyYXkuaXNBcnJheShlKT9yPWVbMF0uc2hhcGVbMF06cj1lLnNoYXBlWzBdO2Vsc2UgdGhyb3cgbmV3IFYoYEVpdGhlciB0aGUgaW5wdXQgZGF0YSBzaG91bGQgaGF2ZSBhIGRlZmluZWQgc2hhcGUsIG9yICR7YX0gc2hvdWQgYmUgc3BlY2lmaWVkLmApO3JldHVybiByfWV4ZWN1dGUoZSx0KXtpZihBcnJheS5pc0FycmF5KHQpJiZ0Lmxlbmd0aD09PTApdGhyb3cgbmV3IFYoXCJgb3V0cHV0c2AgaXMgYW4gZW1wdHkgQXJyYXksIHdoaWNoIGlzIG5vdCBhbGxvd2VkLlwiKTtsZXQgbj1BcnJheS5pc0FycmF5KHQpLGE9bj90Olt0XSxyPXRoaXMucmV0cmlldmVTeW1ib2xpY1RlbnNvcnMoYSkscz1uZXcgQ2w7aWYoZSBpbnN0YW5jZW9mIENlJiYoZT1bZV0pLEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09dGhpcy5pbnB1dHMubGVuZ3RoKXRocm93IG5ldyBWKGBUaGUgbnVtYmVyIG9mIGlucHV0cyBwcm92aWRlZCAoJHtlLmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgaW5wdXRzIG9mIHRoaXMgbW9kZWwgKCR7dGhpcy5pbnB1dHMubGVuZ3RofSkuYCk7Zm9yKGxldCBvPTA7bzx0aGlzLmlucHV0cy5sZW5ndGg7KytvKXMuYWRkKHRoaXMuaW5wdXRzW29dLGVbb10pfWVsc2UgZm9yKGxldCBvIG9mIHRoaXMuaW5wdXRzKXtsZXQgbD1lW28ubmFtZV07aWYobD09bnVsbCl0aHJvdyBuZXcgVihgTm8gdmFsdWUgaXMgcHJvdmlkZWQgZm9yIHRoZSBtb2RlbCdzIGlucHV0ICR7by5uYW1lfWApO3MuYWRkKG8sbCl9bGV0IGk9dGMocixzKTtyZXR1cm4gbj9pOmlbMF19cmV0cmlldmVTeW1ib2xpY1RlbnNvcnMoZSl7bGV0IHQ9YmkobnVsbCxlLmxlbmd0aCksbj1lLmxlbmd0aDtmb3IobGV0IGEgb2YgdGhpcy5sYXllcnMpe2xldCByPUFycmF5LmlzQXJyYXkoYS5vdXRwdXQpP2Eub3V0cHV0OlthLm91dHB1dF0scz1yLm1hcChpPT5pLm5hbWUpO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7KytpKXtsZXQgbz1zLmluZGV4T2YoZVtpXSk7aWYobyE9PS0xJiYodFtpXT1yW29dLG4tLSksbj09PTApYnJlYWt9aWYobj09PTApYnJlYWt9aWYobj4wKXtsZXQgYT1bXTt0aHJvdyB0LmZvckVhY2goKHIscyk9PntyPT1udWxsJiZhLnB1c2goZVtzXSl9KSxuZXcgVihgQ2Fubm90IGZpbmQgU3ltYm9saWNUZW5zb3JzIGZvciBvdXRwdXQgbmFtZShzKTogJHtKU09OLnN0cmluZ2lmeShhKX1gKX1yZXR1cm4gdH1wcmVkaWN0TG9vcChlLHQ9MzIsbj0hMSl7cmV0dXJuIE8oKCk9PntsZXQgYT10aGlzLmNoZWNrTnVtU2FtcGxlcyhlKTtpZihuKXRocm93IG5ldyB6ZShcIlZlcmJvc2UgcHJlZGljdExvb3AoKSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtsZXQgcj1teChhLHQpLHM9dGhpcy5vdXRwdXRzLm1hcChpPT5bXSk7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDsrK2kpTygoKT0+e2xldCBvPXJbaV1bMF0sbD1yW2ldWzFdLHU9WHAoZSxvLGwpLHA9W107aWYoQXJyYXkuaXNBcnJheSh1KSlmb3IobGV0IGM9MDtjPHUubGVuZ3RoOysrYylwLnB1c2goe2tleTp0aGlzLmlucHV0c1tjXSx2YWx1ZTp1W2NdfSk7ZWxzZSBwLnB1c2goe2tleTp0aGlzLmlucHV0c1swXSx2YWx1ZTp1fSk7bGV0IGQ9bmV3IENsKHApO3JldHVybiB0Yyh0aGlzLm91dHB1dHMsZCl9KS5mb3JFYWNoKChvLGwpPT5zW2xdLnB1c2gobykpO3JldHVybiBNbihzLm1hcChpPT5ldChpLDApKSl9KX1wcmVkaWN0KGUsdD17fSl7bGV0IG49RzIoZSk7QUkobix0aGlzLmlucHV0TmFtZXMsdGhpcy5mZWVkSW5wdXRTaGFwZXMsITEpO3RyeXtsZXQgYT10LmJhdGNoU2l6ZT09bnVsbD8zMjp0LmJhdGNoU2l6ZTtyZXR1cm4gaHgoYSksdGhpcy5wcmVkaWN0TG9vcChuLGEpfWZpbmFsbHl7UGEobixlKX19cHJlZGljdE9uQmF0Y2goZSl7QUkoZSx0aGlzLmlucHV0TmFtZXMsdGhpcy5mZWVkSW5wdXRTaGFwZXMsITApO2xldCB0PShBcnJheS5pc0FycmF5KGUpP2VbMF06ZSkuc2hhcGVbMF07cmV0dXJuIHRoaXMucHJlZGljdExvb3AoZSx0KX1zdGFuZGFyZGl6ZVVzZXJEYXRhWFkoZSx0LG49ITAsYSl7aWYodGhpcy5vcHRpbWl6ZXJfPT1udWxsKXRocm93IG5ldyBhcihcIllvdSBtdXN0IGNvbXBpbGUgYSBtb2RlbCBiZWZvcmUgdHJhaW5pbmcvdGVzdGluZy4gVXNlIExheWVyc01vZGVsLmNvbXBpbGUobW9kZWxDb21waWxlQXJncykuXCIpO2xldCByPVtdO2ZvcihsZXQgcz0wO3M8dGhpcy5mZWVkT3V0cHV0U2hhcGVzLmxlbmd0aDsrK3Mpe2xldCBpPXRoaXMuZmVlZE91dHB1dFNoYXBlc1tzXTt0aGlzLmZlZWRMb3NzRm5zW3NdPT09bm0/ci5wdXNoKGkuc2xpY2UoMCxpLmxlbmd0aC0xKS5jb25jYXQoWzFdKSk6ci5wdXNoKGkpfWlmKGU9X0koZSx0aGlzLmZlZWRJbnB1dE5hbWVzLHRoaXMuZmVlZElucHV0U2hhcGVzLCExLFwiaW5wdXRcIiksdD1fSSh0LHRoaXMuZmVlZE91dHB1dE5hbWVzLHIsITEsXCJ0YXJnZXRcIiksbmooZSx0LG51bGwpLGFqKHQsdGhpcy5mZWVkTG9zc0Zucyx0aGlzLmZlZWRPdXRwdXRTaGFwZXMpLHRoaXMuc3RhdGVmdWwmJmEhPW51bGwmJmE+MCYmZVswXS5zaGFwZVswXSVhIT09MCl0aHJvdyBuZXcgVihgSW4gYSBzdGF0ZWZ1bCBuZXR3b3JrLCB5b3Ugc2hvdWxkIG9ubHkgcGFzcyBpbnB1dHMgd2l0aCBhIG51bWJlciBvZiBzYW1wbGVzIHRoYXQgaXMgZGl2aXNpYmxlIGJ5IHRoZSBiYXRjaCBzaXplICR7YX0uIEZvdW5kOiAke2VbMF0uc2hhcGVbMF19IHNhbXBsZShzKS5gKTtyZXR1cm5bZSx0XX1hc3luYyBzdGFuZGFyZGl6ZVVzZXJEYXRhKGUsdCxuLGEscj0hMCxzKXtsZXRbaSxvXT10aGlzLnN0YW5kYXJkaXplVXNlckRhdGFYWShlLHQscixzKTtpZihuIT1udWxsKXRocm93IG5ldyBFcnJvcihcInNhbXBsZSB3ZWlnaHQgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2xldCBsPW51bGw7aWYoYSE9bnVsbCl7bGV0IHU9QjIoYSx0aGlzLm91dHB1dE5hbWVzKTtsPVtdO2ZvcihsZXQgcD0wO3A8dS5sZW5ndGg7KytwKWwucHVzaChhd2FpdCBWMihvW3BdLG51bGwsdVtwXSkpfXJldHVybltpLG8sbF19dGVzdExvb3AoZSx0LG4sYT0wLHIpe3JldHVybiBPKCgpPT57bGV0IHM9dGhpcy5jaGVja051bVNhbXBsZXModCxuLHIsXCJzdGVwc1wiKSxpPVtdO2lmKGE+MCl0aHJvdyBuZXcgemUoXCJWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC5cIik7aWYociE9bnVsbCl0aHJvdyBuZXcgemUoXCJzdGVwcyBtb2RlIGluIHRlc3RMb29wKCkgaXMgbm90IGltcGxlbWVudGVkIHlldFwiKTt7bGV0IG89bXgocyxuKSxsPWplKFVhKDAscykpO2ZvcihsZXQgdT0wO3U8by5sZW5ndGg7Kyt1KXtsZXQgcD1vW3VdWzBdLGQ9b1t1XVsxXSxjPXNpKGwscCxkLXApLGg9angodCxjKSxtPWUoaCk7aWYodT09PTApZm9yKGxldCBmPTA7ZjxtLmxlbmd0aDsrK2YpaS5wdXNoKHhlKDApKTtmb3IobGV0IGY9MDtmPG0ubGVuZ3RoOysrZil7bGV0IGc9bVtmXTtpW2ZdPVgoaVtmXSx6KGQtcCxnKSl9fWZvcihsZXQgdT0wO3U8aS5sZW5ndGg7Kyt1KWlbdV09aGUoaVt1XSxzKX1yZXR1cm4gaX0pfWdldERlZHVwZWRNZXRyaWNzTmFtZXMoKXtsZXQgZT10aGlzLm1ldHJpY3NOYW1lcyx0PVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKXtsZXQgYT1lW25dLHI9YTtpZihmSShlLGEpPjEpe2xldCBzPWZJKGUuc2xpY2UoMCxuKSxhKTtyKz1gXyR7c31gfXQucHVzaChyKX1yZXR1cm4gdH1tYWtlVHJhaW5GdW5jdGlvbigpe3JldHVybiBlPT57bGV0IHQ9W10sbj1lLnNsaWNlKDAsdGhpcy5pbnB1dHMubGVuZ3RoKSxhPWUuc2xpY2UodGhpcy5pbnB1dHMubGVuZ3RoLHRoaXMuaW5wdXRzLmxlbmd0aCt0aGlzLm91dHB1dHMubGVuZ3RoKSxyPWUuc2xpY2UodGhpcy5pbnB1dHMubGVuZ3RoK3RoaXMub3V0cHV0cy5sZW5ndGgsdGhpcy5pbnB1dHMubGVuZ3RoK3RoaXMub3V0cHV0cy5sZW5ndGgqMikscz1bXSxpPSgpPT57bGV0IGw9W107Zm9yKGxldCBjPTA7Yzx0aGlzLmlucHV0cy5sZW5ndGg7KytjKWwucHVzaCh7a2V5OnRoaXMuaW5wdXRzW2NdLHZhbHVlOm5bY119KTtsZXQgdT1uZXcgQ2wobCkscD10Yyh0aGlzLm91dHB1dHMsdSx7dHJhaW5pbmc6ITB9KSxkO2ZvcihsZXQgYz0wO2M8dGhpcy5sb3NzRnVuY3Rpb25zLmxlbmd0aDsrK2Mpe2xldCBoPXRoaXMubG9zc0Z1bmN0aW9uc1tjXSxtPWgoYVtjXSxwW2NdKTtyW2NdIT1udWxsJiYobT1LSChtLHJbY10pKTtsZXQgZj1DdChtKTt0LnB1c2goZiksYz09PTA/ZD1tOmQ9WChkLG0pfWZvcihsZXQgYz0wO2M8dGhpcy5tZXRyaWNzVGVuc29ycy5sZW5ndGg7KytjKXtsZXQgaDtpZih0aGlzLm91dHB1dHMubGVuZ3RoPjEmJmM8dGhpcy5vdXRwdXRzLmxlbmd0aCloPXRbY107ZWxzZXtsZXQgbT10aGlzLm1ldHJpY3NUZW5zb3JzW2NdWzBdLGY9dGhpcy5tZXRyaWNzVGVuc29yc1tjXVsxXTtoPUN0KG0oYVtmXSxwW2ZdKSl9SHQoaCkscy5wdXNoKGgpfXJldHVybiBkPUN0KGQpLHRoaXMuY2FsY3VsYXRlTG9zc2VzKCkuZm9yRWFjaChjPT57ZD1YKGQsYyl9KSxkfSxvPXRoaXMuY29sbGVjdGVkVHJhaW5hYmxlV2VpZ2h0cy5tYXAobD0+bC5yZWFkKCkpO3JldHVyblt0aGlzLm9wdGltaXplcl8ubWluaW1pemUoaSwhMCxvKV0uY29uY2F0KHMpfX1tYWtlVGVzdEZ1bmN0aW9uKCl7dGhpcy50ZXN0RnVuY3Rpb249ZT0+TygoKT0+e2xldCB0PVtdLG4sYT1lLnNsaWNlKDAsdGhpcy5pbnB1dHMubGVuZ3RoKSxyPWUuc2xpY2UodGhpcy5pbnB1dHMubGVuZ3RoLHRoaXMuaW5wdXRzLmxlbmd0aCt0aGlzLm91dHB1dHMubGVuZ3RoKSxzPVtdO2ZvcihsZXQgbD0wO2w8dGhpcy5pbnB1dHMubGVuZ3RoOysrbClzLnB1c2goe2tleTp0aGlzLmlucHV0c1tsXSx2YWx1ZTphW2xdfSk7bGV0IGk9bmV3IENsKHMpLG89dGModGhpcy5vdXRwdXRzLGkpO2ZvcihsZXQgbD0wO2w8dGhpcy5sb3NzRnVuY3Rpb25zLmxlbmd0aDsrK2wpe2xldCB1PXRoaXMubG9zc0Z1bmN0aW9uc1tsXSxwPUN0KHUocltsXSxvW2xdKSk7bD09PTA/bj1wOm49WChuLHApLHQucHVzaChuKX1mb3IobGV0IGw9MDtsPHRoaXMubWV0cmljc1RlbnNvcnMubGVuZ3RoOysrbCl7bGV0IHU9dGhpcy5tZXRyaWNzVGVuc29yc1tsXVswXSxwPXRoaXMubWV0cmljc1RlbnNvcnNbbF1bMV0sZD1DdCh1KHJbcF0sb1twXSkpO3QucHVzaChkKX1yZXR1cm4gdH0pfWFzeW5jIGZpdChlLHQsbj17fSl7aWYodGhpcy5pc1RyYWluaW5nKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdGFydCB0cmFpbmluZyBiZWNhdXNlIGFub3RoZXIgZml0KCkgY2FsbCBpcyBvbmdvaW5nLlwiKTt0aGlzLmlzVHJhaW5pbmc9ITA7bGV0IGEscixzLGksbyxsLHUscCxkO3RyeXtsZXQgYz1uLmJhdGNoU2l6ZT09bnVsbD8zMjpuLmJhdGNoU2l6ZTtoeChjKTtsZXQgaD1hd2FpdCB0aGlzLnN0YW5kYXJkaXplVXNlckRhdGEoZSx0LG4uc2FtcGxlV2VpZ2h0LG4uY2xhc3NXZWlnaHQsITEsYyk7YT1oWzBdLHI9aFsxXSxkPWhbMl07bGV0IG09ITEsZjtpZihuLnZhbGlkYXRpb25EYXRhIT1udWxsJiZuLnZhbGlkYXRpb25EYXRhLmxlbmd0aD4wKXtpZihtPSEwLG4udmFsaWRhdGlvbkRhdGEubGVuZ3RoPT09MilvPW4udmFsaWRhdGlvbkRhdGFbMF0sbD1uLnZhbGlkYXRpb25EYXRhWzFdO2Vsc2UgdGhyb3cgbi52YWxpZGF0aW9uRGF0YS5sZW5ndGg9PT0zP25ldyB6ZShcInZhbGlkYXRpb25EYXRhIGluY2x1ZGluZyBzYW1wbGUgd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik6bmV3IFYoYFdoZW4gcGFzc2luZyB2YWxpZGF0aW9uIGRhdGEsIGl0IG11c3QgY29udGFpbiAyICh2YWxYLCB2YWxZKSBvciAzICh2YWxYLCB2YWxZLCB2YWxTYW1wbGVXZWlnaHQpIGl0ZW1zOyAke24udmFsaWRhdGlvbkRhdGF9IGlzIGludmFsaWQuYCk7bGV0IE49YXdhaXQgdGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhKG8sbCxudWxsLG51bGwsITAsYyk7dT1OWzBdLHA9TlsxXSxmPXUuY29uY2F0KHApfWVsc2UgaWYobi52YWxpZGF0aW9uU3BsaXQhPW51bGwmJm4udmFsaWRhdGlvblNwbGl0PjAmJm4udmFsaWRhdGlvblNwbGl0PDEpe209ITA7bGV0IE49TWF0aC5mbG9vcihhWzBdLnNoYXBlWzBdKigxLW4udmFsaWRhdGlvblNwbGl0KSksQz1hWzBdLnNoYXBlWzBdO3U9WHAoYSxOLEMpLHM9YSxhPVhwKGEsMCxOKSxwPVhwKHIsTixDKSxpPXIscj1YcChyLDAsTiksZj11LmNvbmNhdChwKX1lbHNlIG4udmFsaWRhdGlvblN0ZXBzIT1udWxsJiYobT0hMCk7bGV0IGc9YS5jb25jYXQocikuY29uY2F0KGQpO3RoaXMuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKTtsZXQgYj10aGlzLm1ha2VUcmFpbkZ1bmN0aW9uKCkseT10aGlzLmdldERlZHVwZWRNZXRyaWNzTmFtZXMoKSx4LHY7bT8odGhpcy5tYWtlVGVzdEZ1bmN0aW9uKCkseD10aGlzLnRlc3RGdW5jdGlvbix2PXkuc2xpY2UoKS5jb25jYXQoeS5tYXAoTj0+XCJ2YWxfXCIrTikpKTooeD1udWxsLGY9W10sdj15LnNsaWNlKCkpO2xldCBJPUQyKG4uY2FsbGJhY2tzLG4ueWllbGRFdmVyeSk7cmV0dXJuIGF3YWl0IHRoaXMuZml0TG9vcChiLGcseSxjLG4uZXBvY2hzLG4udmVyYm9zZSxJLHgsZixuLnNodWZmbGUsdixuLmluaXRpYWxFcG9jaCxudWxsLG51bGwpfWZpbmFsbHl7dGhpcy5pc1RyYWluaW5nPSExLFBhKGEsZSksUGEocix0KSxQYShzLGUpLFBhKGksdCksUGEodSxvKSxQYShwLGwpLGQhPW51bGwmJkVlKGQpfX1hc3luYyBmaXRMb29wKGUsdCxuLGEscixzLGksbyxsLHUscCxkLGMsaCl7YT09bnVsbCYmKGE9MzIpLHI9PW51bGwmJihyPTEpLHU9PW51bGwmJih1PSEwKSxkPT1udWxsJiYoZD0wKTtsZXQgbT0hMTtpZihvIT1udWxsJiZsIT1udWxsJiYobT0hMCksaCE9bnVsbCYmKG09ITAsYz09bnVsbCkpdGhyb3cgbmV3IFYoXCJDYW4gb25seSB1c2UgYHZhbGlkYXRpb25TdGVwc2Agd2hlbiBkb2luZyBzdGVwLXdpc2UgdHJhaW5pbmcsIGkuZS4sIGBzdGVwc1BlckVwb2NoYCBtdXN0IGJlIHNldC5cIik7bGV0IGY9dGhpcy5jaGVja051bVNhbXBsZXModCxhLGMsXCJzdGVwc19wZXJfZXBvY2hcIiksZztmIT1udWxsJiYoZz1VYSgwLGYpKSxzPT1udWxsJiYocz0xKTtsZXR7Y2FsbGJhY2tMaXN0OmIsaGlzdG9yeTp5fT1SMihpLHMscixkLGYsYyxhLG0scCk7Yi5zZXRNb2RlbCh0aGlzKSx0aGlzLmhpc3Rvcnk9eSxhd2FpdCBiLm9uVHJhaW5CZWdpbigpLHRoaXMuc3RvcFRyYWluaW5nXz0hMTtmb3IobGV0IHg9ZDt4PHI7Kyt4KXthd2FpdCBiLm9uRXBvY2hCZWdpbih4KTtsZXQgdj17fTtpZihjIT1udWxsKXRocm93IG5ldyB6ZShcInN0ZXBzUGVyRXBvY2ggbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTt7aWYodT09PVwiYmF0Y2hcIil0aHJvdyBuZXcgemUoXCJiYXRjaCBzaHVmZmxpbmcgaXMgbm90IGltcGxlbW5ldGVkIHlldFwiKTt1JiZ3LnNodWZmbGUoZyk7bGV0IEk9amUoZyksTj1teChmLGEpO2ZvcihsZXQgQz0wO0M8Ti5sZW5ndGg7KytDKXtsZXQgXz17fTtpZihhd2FpdCBiLm9uQmF0Y2hCZWdpbihDLF8pLE8oKCk9PntsZXQgRj1OW0NdWzBdLEQ9TltDXVsxXSwkPXNpKEksRixELUYpO18uYmF0Y2g9QyxfLnNpemU9RC1GO2xldCBTPWp4KHQsJCksTT1lKFMpO2ZvcihsZXQgQj0wO0I8bi5sZW5ndGg7KytCKXtsZXQgVT1uW0JdLEg9TVtCXTtfW1VdPUgsSHQoSCl9aWYoQz09PU4ubGVuZ3RoLTEmJm0pe2xldCBCPXRoaXMudGVzdExvb3AobyxsLGEpO2ZvcihsZXQgVT0wO1U8bi5sZW5ndGg7KytVKXtsZXQgSD1uW1VdLHE9QltVXTtIdChxKSx2W1widmFsX1wiK0hdPXF9fX0pLGF3YWl0IGIub25CYXRjaEVuZChDLF8pLF8yKF8pLHRoaXMuc3RvcFRyYWluaW5nXylicmVha31JLmRpc3Bvc2UoKX1pZihhd2FpdCBiLm9uRXBvY2hFbmQoeCx2KSx0aGlzLnN0b3BUcmFpbmluZ18pYnJlYWt9cmV0dXJuIGF3YWl0IGIub25UcmFpbkVuZCgpLGF3YWl0IHRoaXMuaGlzdG9yeS5zeW5jRGF0YSgpLHRoaXMuaGlzdG9yeX1hc3luYyBmaXREYXRhc2V0KGUsdCl7cmV0dXJuIFpIKHRoaXMsZSx0KX1hc3luYyB0cmFpbk9uQmF0Y2goZSx0KXtsZXQgbj1hd2FpdCB0aGlzLnN0YW5kYXJkaXplVXNlckRhdGEoZSx0KSxhPW5bMF0scj1uWzFdLHM9dGhpcy5tYWtlVHJhaW5GdW5jdGlvbigpKGEuY29uY2F0KHIpKSxpPVtdO2ZvcihsZXQgbyBvZiBzKXtsZXQgbD1hd2FpdCBvLmRhdGEoKTtpLnB1c2gobFswXSl9cmV0dXJuIEVlKHMpLFBhKG5bMF0sZSksUGEoblsxXSx0KSxNbihpKX1nZXROYW1lZFdlaWdodHMoZSl7bGV0IHQ9W10sbj1lIT1udWxsJiZlLnRyYWluYWJsZU9ubHksYT1uP3RoaXMudHJhaW5hYmxlV2VpZ2h0czp0aGlzLndlaWdodHMscj10aGlzLmdldFdlaWdodHMobik7Zm9yKGxldCBzPTA7czxhLmxlbmd0aDsrK3MpbiYmIWFbc10udHJhaW5hYmxlfHx0LnB1c2goe25hbWU6YVtzXS5vcmlnaW5hbE5hbWUsdGVuc29yOnJbc119KTtyZXR1cm4gdH1zZXQgc3RvcFRyYWluaW5nKGUpe3RoaXMuc3RvcFRyYWluaW5nXz1lfWdldCBzdG9wVHJhaW5pbmcoKXtyZXR1cm4gdGhpcy5zdG9wVHJhaW5pbmdffWdldCBvcHRpbWl6ZXIoKXtyZXR1cm4gdGhpcy5vcHRpbWl6ZXJffXNldCBvcHRpbWl6ZXIoZSl7dGhpcy5vcHRpbWl6ZXJfIT09ZSYmKHRoaXMub3B0aW1pemVyXz1lLHRoaXMuaXNPcHRpbWl6ZXJPd25lZD0hMSl9ZGlzcG9zZSgpe2xldCBlPXN1cGVyLmRpc3Bvc2UoKTtpZihlLnJlZkNvdW50QWZ0ZXJEaXNwb3NlPT09MCYmdGhpcy5vcHRpbWl6ZXIhPW51bGwmJnRoaXMuaXNPcHRpbWl6ZXJPd25lZCl7bGV0IHQ9S2goKS5udW1UZW5zb3JzO3RoaXMub3B0aW1pemVyXy5kaXNwb3NlKCksZS5udW1EaXNwb3NlZFZhcmlhYmxlcys9dC1LaCgpLm51bVRlbnNvcnN9cmV0dXJuIGV9Z2V0TG9zc0lkZW50aWZpZXJzKCl7bGV0IGU7aWYodHlwZW9mIHRoaXMubG9zcz09XCJzdHJpbmdcIillPUlyKHRoaXMubG9zcyk7ZWxzZSBpZihBcnJheS5pc0FycmF5KHRoaXMubG9zcykpe2ZvcihsZXQgdCBvZiB0aGlzLmxvc3MpaWYodHlwZW9mIHQhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiU2VyaWFsaXphdGlvbiBvZiBub24tc3RyaW5nIGxvc3MgaXMgbm90IHN1cHBvcnRlZC5cIik7ZT10aGlzLmxvc3MubWFwKHQ9PklyKHQpKX1lbHNle2xldCB0PU9iamVjdC5rZXlzKHRoaXMubG9zcyk7ZT17fTtsZXQgbj10aGlzLmxvc3M7Zm9yKGxldCBhIG9mIHQpaWYodHlwZW9mIG5bYV09PVwic3RyaW5nXCIpZVthXT1JcihuW2FdKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlNlcmlhbGl6YXRpb24gb2Ygbm9uLXN0cmluZyBsb3NzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpfXJldHVybiBlfWdldE1ldHJpY0lkZW50aWZpZXJzKCl7aWYodHlwZW9mIHRoaXMubWV0cmljcz09XCJzdHJpbmdcInx8dHlwZW9mIHRoaXMubWV0cmljcz09XCJmdW5jdGlvblwiKXJldHVybltJcihTaCh0aGlzLm1ldHJpY3MpKV07aWYoQXJyYXkuaXNBcnJheSh0aGlzLm1ldHJpY3MpKXJldHVybiB0aGlzLm1ldHJpY3MubWFwKGU9PklyKFNoKGUpKSk7e2xldCBlPXt9O2ZvcihsZXQgdCBpbiB0aGlzLm1ldHJpY3MpZVt0XT1JcihTaCh0aGlzLm1ldHJpY3NbdF0pKTtyZXR1cm4gZX19Z2V0VHJhaW5pbmdDb25maWcoKXtyZXR1cm57bG9zczp0aGlzLmdldExvc3NJZGVudGlmaWVycygpLG1ldHJpY3M6dGhpcy5nZXRNZXRyaWNJZGVudGlmaWVycygpLG9wdGltaXplcl9jb25maWc6e2NsYXNzX25hbWU6dGhpcy5vcHRpbWl6ZXIuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOnRoaXMub3B0aW1pemVyLmdldENvbmZpZygpfX19bG9hZFRyYWluaW5nQ29uZmlnKGUpe2lmKGUud2VpZ2h0ZWRfbWV0cmljcyE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIHdlaWdodF9tZXRyaWNzIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtpZihlLmxvc3Nfd2VpZ2h0cyE9bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGxvc3Nfd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7aWYoZS5zYW1wbGVfd2VpZ2h0X21vZGUhPW51bGwpdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBzYW1wbGVfd2VpZ2h0X21vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2xldCB0PUljKGUub3B0aW1pemVyX2NvbmZpZyksbj1CYSh0KSxhO2lmKHR5cGVvZiBlLmxvc3M9PVwic3RyaW5nXCIpYT1KcyhlLmxvc3MpO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlLmxvc3MpKWE9ZS5sb3NzLm1hcChzPT5KcyhzKSk7ZWxzZSBpZihlLmxvc3MhPW51bGwpe2E9e307Zm9yKGxldCBzIGluIGUubG9zcylhW3NdPUpzKGUubG9zc1tzXSl9bGV0IHI7aWYoQXJyYXkuaXNBcnJheShlLm1ldHJpY3MpKXI9ZS5tZXRyaWNzLm1hcChzPT5KcyhzKSk7ZWxzZSBpZihlLm1ldHJpY3MhPW51bGwpe3I9e307Zm9yKGxldCBzIGluIGUubWV0cmljcylyW3NdPUpzKGUubWV0cmljc1tzXSl9dGhpcy5jb21waWxlKHtsb3NzOmEsbWV0cmljczpyLG9wdGltaXplcjpufSl9YXN5bmMgc2F2ZShlLHQpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgcj1qdC5nZXRTYXZlSGFuZGxlcnMoZSk7aWYoci5sZW5ndGg9PT0wKXRocm93IG5ldyBWKGBDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICcke2V9J2ApO2lmKHIubGVuZ3RoPjEpdGhyb3cgbmV3IFYoYEZvdW5kIG1vcmUgdGhhbiBvbmUgKCR7ci5sZW5ndGh9KSBzYXZlIGhhbmRsZXJzIGZvciBVUkwgJyR7ZX0nYCk7ZT1yWzBdfWlmKGUuc2F2ZT09bnVsbCl0aHJvdyBuZXcgVihcIkxheWVyc01vZGVsLnNhdmUoKSBjYW5ub3QgcHJvY2VlZCBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgZG9lcyBub3QgaGF2ZSB0aGUgYHNhdmVgIGF0dHJpYnV0ZSBkZWZpbmVkLlwiKTtsZXQgbj1hd2FpdCBqdC5lbmNvZGVXZWlnaHRzKHRoaXMuZ2V0TmFtZWRXZWlnaHRzKHQpKSxhPXttb2RlbFRvcG9sb2d5OnRoaXMudG9KU09OKG51bGwsITEpLGZvcm1hdDpzaixnZW5lcmF0ZWRCeTpgVGVuc29yRmxvdy5qcyB0ZmpzLWxheWVycyB2JHt2MH1gLGNvbnZlcnRlZEJ5Om51bGx9O2lmKHQhPW51bGwmJnQuaW5jbHVkZU9wdGltaXplciYmdGhpcy5vcHRpbWl6ZXIhPW51bGwpe2EudHJhaW5pbmdDb25maWc9dGhpcy5nZXRUcmFpbmluZ0NvbmZpZygpO2xldCByPVwib3B0aW1pemVyXCIse2RhdGE6cyxzcGVjczppfT1hd2FpdCBqdC5lbmNvZGVXZWlnaHRzKGF3YWl0IHRoaXMub3B0aW1pemVyLmdldFdlaWdodHMoKSxyKTtuLnNwZWNzLnB1c2goLi4uaSksbi5kYXRhPWp0LmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKFtuLmRhdGEsc10pfXJldHVybiB0aGlzLnVzZXJEZWZpbmVkTWV0YWRhdGEhPW51bGwmJihOSSh0aGlzLnVzZXJEZWZpbmVkTWV0YWRhdGEsdGhpcy5uYW1lLCEwKSxhLnVzZXJEZWZpbmVkTWV0YWRhdGE9dGhpcy51c2VyRGVmaW5lZE1ldGFkYXRhKSxhLndlaWdodERhdGE9bi5kYXRhLGEud2VpZ2h0U3BlY3M9bi5zcGVjcyxlLnNhdmUoYSl9c2V0VXNlckRlZmluZWRNZXRhZGF0YShlKXtOSShlLHRoaXMubmFtZSksdGhpcy51c2VyRGVmaW5lZE1ldGFkYXRhPWV9Z2V0VXNlckRlZmluZWRNZXRhZGF0YSgpe3JldHVybiB0aGlzLnVzZXJEZWZpbmVkTWV0YWRhdGF9fTtFci5jbGFzc05hbWU9XCJNb2RlbFwiO25lLnJlZ2lzdGVyQ2xhc3MoRXIpO3ZhciBIMj1jbGFzcyBleHRlbmRzIEVye307SDIuY2xhc3NOYW1lPVwiRnVuY3Rpb25hbFwiO25lLnJlZ2lzdGVyQ2xhc3MoSDIpO2FzeW5jIGZ1bmN0aW9uIGlqKGUsdCl7XCJtb2RlbFRvcG9sb2d5XCJpbiBlfHwoZT17bW9kZWxUb3BvbG9neTplfSksZT1lO2xldCBuPWUubW9kZWxUb3BvbG9neTtuLm1vZGVsX2NvbmZpZyE9bnVsbCYmKG49bi5tb2RlbF9jb25maWcpO2xldCBhPUljKG4pLHI9QmEoYSx0KTtpZihlLndlaWdodHNNYW5pZmVzdCE9bnVsbCl7bGV0IHM9YXdhaXQganQubG9hZFdlaWdodHMoZS53ZWlnaHRzTWFuaWZlc3QsZS5wYXRoUHJlZml4LHIud2VpZ2h0cy5tYXAobz0+by5vcmlnaW5hbE5hbWUpKSxpPXt9O2ZvcihsZXQgbyBvZiByLndlaWdodHMpaVtvLm9yaWdpbmFsTmFtZV09c1tvLm9yaWdpbmFsTmFtZV07ci5sb2FkV2VpZ2h0cyhpKSxFZShzKX1yZXR1cm4gcn1hc3luYyBmdW5jdGlvbiBvaihlLHQpe2lmKHQ9PW51bGwmJih0PXt9KSx0eXBlb2YgZT09XCJzdHJpbmdcIil7bGV0IG49anQuZ2V0TG9hZEhhbmRsZXJzKGUsdCk7aWYobi5sZW5ndGg9PT0wKW4ucHVzaChqdC5icm93c2VySFRUUFJlcXVlc3QoZSx0KSk7ZWxzZSBpZihuLmxlbmd0aD4xKXRocm93IG5ldyBWKGBGb3VuZCBtb3JlIHRoYW4gb25lICgke24ubGVuZ3RofSkgbG9hZCBoYW5kbGVycyBmb3IgVVJMICcke2V9J2ApO2U9blswXX1yZXR1cm4gbGooZSx2b2lkIDAsdCl9YXN5bmMgZnVuY3Rpb24gbGooZSx0LG4pe2lmKG49PW51bGwmJihuPXt9KSxlLmxvYWQ9PW51bGwpdGhyb3cgbmV3IFYoXCJDYW5ub3QgcHJvY2VlZCB3aXRoIG1vZGVsIGxvYWRpbmcgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBsb2FkYCBtZXRob2QgaW1wbGVtZW50ZWQuXCIpO2xldCBhPWF3YWl0IGUubG9hZCgpLHI9YS5tb2RlbFRvcG9sb2d5O3IubW9kZWxfY29uZmlnIT1udWxsJiYocj1yLm1vZGVsX2NvbmZpZyk7bGV0IHM9bi5zdHJpY3Q9PW51bGw/ITA6bi5zdHJpY3QsaT1hLndlaWdodERhdGEhPW51bGwmJmEud2VpZ2h0U3BlY3MhPW51bGwmJnMsbz1CYShJYyhyKSx0LGkpLGw9YS50cmFpbmluZ0NvbmZpZztpZihsIT1udWxsJiZvLmxvYWRUcmFpbmluZ0NvbmZpZyhsKSxhLnVzZXJEZWZpbmVkTWV0YWRhdGEhPW51bGwmJm8uc2V0VXNlckRlZmluZWRNZXRhZGF0YShhLnVzZXJEZWZpbmVkTWV0YWRhdGEpLGEud2VpZ2h0RGF0YSE9bnVsbCl7aWYoYS53ZWlnaHRTcGVjcz09bnVsbCl0aHJvdyBuZXcgVihcIkxheWVyc01vZGVsIGFydGlmYWN0cyBjb250YWlucyB3ZWlnaHQgZGF0YSwgYnV0IG5vdCB3ZWlnaHQgc3BlY3MuIFRoZXJlZm9yZSBsb2FkaW5nIG9mIHdlaWdodHMgY2Fubm90IHByb2NlZWQuXCIpO2xldHttb2RlbFdlaWdodHM6dSxvcHRpbWl6ZXJXZWlnaHRzOnB9PXVqKGEud2VpZ2h0RGF0YSxhLndlaWdodFNwZWNzKTtvLmxvYWRXZWlnaHRzKHUscyksby5vcHRpbWl6ZXIhPW51bGwmJnAubGVuZ3RoPjAmJmF3YWl0IG8ub3B0aW1pemVyLnNldFdlaWdodHMocCksRWUodSksRWUocC5tYXAoZD0+ZC50ZW5zb3IpKX1yZXR1cm4gb31mdW5jdGlvbiB1aihlLHQpe2xldCBuPWp0LmRlY29kZVdlaWdodHMoZSx0KSxhPXt9LHI9W107cmV0dXJuIHQuZm9yRWFjaChzPT57cy5ncm91cD09PVwib3B0aW1pemVyXCI/ci5wdXNoKHtuYW1lOnMubmFtZSx0ZW5zb3I6bltzLm5hbWVdfSk6YVtzLm5hbWVdPW5bcy5uYW1lXX0pLHttb2RlbFdlaWdodHM6YSxvcHRpbWl6ZXJXZWlnaHRzOnJ9fXZhciBFZj1jbGFzcyBLeCBleHRlbmRzIEVye2NvbnN0cnVjdG9yKHQpe2lmKHN1cGVyKHtpbnB1dHM6W10sb3V0cHV0czpbXX0pLHQ9dHx8e30sdGhpcy50cmFpbmFibGU9ITAsdGhpcy5idWlsdD0hMSx0aGlzLm5hbWU9dC5uYW1lIT1udWxsP3QubmFtZTpnZihcInNlcXVlbnRpYWxfXCIpLHQubGF5ZXJzIT1udWxsKWZvcihsZXQgbiBvZiB0LmxheWVycyl0aGlzLmFkZChuKX1jaGVja1NoYXBlKHQpe2lmKHQuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF0uc2hhcGUuc29tZShuPT5uPDApKXRocm93IG5ldyBWKGBOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgYWRkaW5nIGxheWVyICR7dC5uYW1lfSB3aXRoIGlucHV0IHNoYXBlIFske3QuaW5ib3VuZE5vZGVzWzBdLmlucHV0VGVuc29yc1swXS5zaGFwZX1dYCl9YWRkKHQpe2xldCBuPXQgaW5zdGFuY2VvZiBLeHx8dCBpbnN0YW5jZW9mIEVyLGE7aWYobil7aWYoYT10LGEub3V0cHV0cy5sZW5ndGghPT0xKXRocm93IG5ldyBWKFwiQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gRm9yIG11bHRpLW91dHB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpO2lmKGEuaW5wdXRzLmxlbmd0aCE9PTEpdGhyb3cgbmV3IFYoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBpbnB1dCB0ZW5zb3IuIEZvciBtdWx0aS1pbnB1dCBsYXllcnMsIHVzZSB0aGUgZnVuY3Rpb25hbCBBUEkuXCIpfWlmKHRoaXMub3V0cHV0cy5sZW5ndGg9PT0wKXtpZih0LmluYm91bmROb2Rlcy5sZW5ndGg9PT0wKXtpZih0LmJhdGNoSW5wdXRTaGFwZT09bnVsbCl0aHJvdyBuZXcgVihcIlRoZSBmaXJzdCBsYXllciBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgbXVzdCBnZXQgYW4gYGlucHV0U2hhcGVgIG9yIGBiYXRjaElucHV0U2hhcGVgIGFyZ3VtZW50LlwiKTtsZXQgcj1TMih7YmF0Y2hTaGFwZTp0LmJhdGNoSW5wdXRTaGFwZSxkdHlwZTp0LmR0eXBlLG5hbWU6dC5uYW1lK1wiX2lucHV0XCJ9KTt0LmFwcGx5KHIpfWlmKG4pdGhpcy5vdXRwdXRzPWEub3V0cHV0cyx0aGlzLmlucHV0cz1hLmlucHV0cztlbHNle2lmKHQuaW5ib3VuZE5vZGVzLmxlbmd0aCE9PTEpdGhyb3cgbmV3IFYoYEEgbGF5ZXIgYWRkZWQgdG8gYSBTZXF1ZW50aWFsIG1vZGVsIG11c3Qgbm90IGFscmVhZHkgYmUgY29ubmVjdGVkIHNvbWV3aGVyZSBlbHNlLiBMYXllcnNNb2RlbCByZWNlaXZlZCBsYXllciAke3QubmFtZX0gd2hpY2ggaGFzICR7dC5pbmJvdW5kTm9kZXMubGVuZ3RofSBwcmUtZXhpc3RpbmcgaW5ib3VuZCBjb25uZWN0aW9ucy5gKTtpZih0LmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzLmxlbmd0aCE9PTEpdGhyb3cgbmV3IFYoXCJBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCBzaG91bGQgaGF2ZSBhIHNpbmdsZSBvdXRwdXQgdGVuc29yLiBGb3IgbXVsdGktb3V0cHV0IGxheWVycywgdXNlIHRoZSBmdW5jdGlvbmFsIEFQSS5cIik7dGhpcy5jaGVja1NoYXBlKHQpLHRoaXMub3V0cHV0cz1bdC5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXV0sdGhpcy5pbnB1dHM9STIodGhpcy5vdXRwdXRzWzBdKX10aGlzLmluYm91bmROb2Rlcz1bXSxuZXcgTmYoe291dGJvdW5kTGF5ZXI6dGhpcyxpbmJvdW5kTGF5ZXJzOltdLG5vZGVJbmRpY2VzOltdLHRlbnNvckluZGljZXM6W10saW5wdXRUZW5zb3JzOnRoaXMuaW5wdXRzLG91dHB1dFRlbnNvcnM6dGhpcy5vdXRwdXRzLGlucHV0TWFza3M6YmkobnVsbCx0aGlzLmlucHV0cy5sZW5ndGgpLG91dHB1dE1hc2tzOltudWxsXSxpbnB1dFNoYXBlczp0aGlzLmlucHV0cy5tYXAocj0+ci5zaGFwZSksb3V0cHV0U2hhcGVzOnRoaXMub3V0cHV0c1swXS5zaGFwZX0pfWVsc2V7bGV0IHI9dC5hcHBseSh0aGlzLm91dHB1dHNbMF0pO2lmKEFycmF5LmlzQXJyYXkocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsIHNob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuIEZvciBtdWx0aS1vdXRwdXQgbGF5ZXJzLCB1c2UgdGhlIGZ1bmN0aW9uYWwgQVBJLlwiKTt0aGlzLmNoZWNrU2hhcGUodCksdGhpcy5vdXRwdXRzPVtyXSx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzPXRoaXMub3V0cHV0cyx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXM9W3RoaXMub3V0cHV0c1swXS5zaGFwZV19dGhpcy5sYXllcnMucHVzaCh0KSx0aGlzLmJ1aWx0PSExfXBvcCgpe2lmKHRoaXMubGF5ZXJzLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZXJlIGFyZSBubyBsYXllcnMgaW4gdGhlIG1vZGVsLlwiKTtpZih0aGlzLmxheWVycy5wb3AoKSx0aGlzLmxheWVycy5sZW5ndGg9PT0wKXRoaXMub3V0cHV0cz1bXSx0aGlzLmluYm91bmROb2Rlcz1bXSx0aGlzLm91dGJvdW5kTm9kZXM9W107ZWxzZXtsZXQgdD10aGlzLmxheWVycy5sZW5ndGgtMTt0aGlzLmxheWVyc1t0XS5vdXRib3VuZE5vZGVzPVtdLHRoaXMub3V0cHV0cz1bdGhpcy5sYXllcnNbdF0ub3V0cHV0XSx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzPXRoaXMub3V0cHV0cyx0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXM9W3RoaXMub3V0cHV0c1swXS5zaGFwZV19fWNhbGwodCxuKXtyZXR1cm4gdGhpcy5tb2RlbD09bnVsbCYmdGhpcy5idWlsZCgpLHRoaXMubW9kZWwuY2FsbCh0LG4pfWJ1aWxkKHQpe2lmKEplKHQpLHRoaXMuaW5wdXRzLmxlbmd0aD09PTB8fHRoaXMub3V0cHV0cy5sZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTZXF1ZW50aWFsIG1vZGVsIGNhbm5vdCBiZSBidWlsdDogbW9kZWwgaXMgZW1wdHkuIEFkZCBzb21lIGxheWVycyBmaXJzdC5cIik7dGhpcy5tb2RlbD1uZXcgRXIoe2lucHV0czp0aGlzLmlucHV0cyxvdXRwdXRzOnRoaXMub3V0cHV0c1swXSxuYW1lOnRoaXMubmFtZStcIl9tb2RlbFwifSksdGhpcy5tb2RlbC50cmFpbmFibGU9dGhpcy50cmFpbmFibGUsdGhpcy5zdXBwb3J0c01hc2tpbmc9dGhpcy5tb2RlbC5zdXBwb3J0c01hc2tpbmcsdGhpcy5pbnB1dExheWVycz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzLHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLmlucHV0TGF5ZXJzTm9kZUluZGljZXMsdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXM9dGhpcy5tb2RlbC5pbnB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5vdXRwdXRMYXllcnM9dGhpcy5tb2RlbC5vdXRwdXRMYXllcnMsdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc05vZGVJbmRpY2VzLHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcz10aGlzLm1vZGVsLm91dHB1dExheWVyc1RlbnNvckluZGljZXMsdGhpcy5ub2Rlc0J5RGVwdGg9dGhpcy5tb2RlbC5ub2Rlc0J5RGVwdGgsdGhpcy5jb250YWluZXJOb2Rlcz10aGlzLm1vZGVsLmNvbnRhaW5lck5vZGVzLHRoaXMub3V0cHV0TmFtZXM9dGhpcy5tb2RlbC5vdXRwdXROYW1lcyx0aGlzLmlucHV0TmFtZXM9dGhpcy5tb2RlbC5pbnB1dE5hbWVzLHRoaXMuYnVpbHQ9ITB9Y291bnRQYXJhbXMoKXtyZXR1cm4gdGhpcy5idWlsdHx8dGhpcy5idWlsZCgpLHN1cGVyLmNvdW50UGFyYW1zKCl9c3VtbWFyeSh0LG4sYT1jb25zb2xlLmxvZyl7dGhpcy5idWlsdHx8dGhpcy5idWlsZCgpLHN1cGVyLnN1bW1hcnkodCxuLGEpfXNldFdlaWdodHModCl7dGhpcy5tb2RlbD09bnVsbCYmdGhpcy5idWlsZCgpLHRoaXMubW9kZWwuc2V0V2VpZ2h0cyh0KX1ldmFsdWF0ZSh0LG4sYT17fSl7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IGFyKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm4gdGhpcy5tb2RlbC5ldmFsdWF0ZSh0LG4sYSl9YXN5bmMgZXZhbHVhdGVEYXRhc2V0KHQsbil7aWYoIXRoaXMuYnVpbHQpdGhyb3cgbmV3IGFyKFwiVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSBiZWluZyB1c2VkLlwiKTtyZXR1cm4gdGhpcy5tb2RlbC5ldmFsdWF0ZURhdGFzZXQodCxuKX1wcmVkaWN0KHQsbj17fSl7cmV0dXJuIHRoaXMubW9kZWw9PW51bGwmJnRoaXMuYnVpbGQoKSx0aGlzLm1vZGVsLnByZWRpY3QodCxuKX1wcmVkaWN0T25CYXRjaCh0KXtyZXR1cm4gdGhpcy5tb2RlbD09bnVsbCYmdGhpcy5idWlsZCgpLHRoaXMubW9kZWwucHJlZGljdE9uQmF0Y2godCl9Y29tcGlsZSh0KXt0aGlzLmJ1aWxkKCksdGhpcy5tb2RlbC5jb21waWxlKHQpLHRoaXMub3B0aW1pemVyXz10aGlzLm1vZGVsLm9wdGltaXplcix0aGlzLmlzT3B0aW1pemVyT3duZWQ9dGhpcy5tb2RlbC5pc09wdGltaXplck93bmVkLHRoaXMubG9zcz10aGlzLm1vZGVsLmxvc3MsdGhpcy5tZXRyaWNzPXRoaXMubW9kZWwubWV0cmljcyx0aGlzLm1ldHJpY3NUZW5zb3JzPXRoaXMubW9kZWwubWV0cmljc1RlbnNvcnMsdGhpcy5tZXRyaWNzTmFtZXM9dGhpcy5tb2RlbC5tZXRyaWNzTmFtZXN9Z2V0IG9wdGltaXplcigpe3JldHVybiB0aGlzLm1vZGVsPT1udWxsP3ZvaWQgMDp0aGlzLm1vZGVsLm9wdGltaXplcn1zZXQgb3B0aW1pemVyKHQpe3RoaXMubW9kZWwub3B0aW1pemVyPXR9YXN5bmMgZml0KHQsbixhPXt9KXtpZighdGhpcy5idWlsdCl0aHJvdyBuZXcgYXIoXCJUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuXCIpO3JldHVybiB0aGlzLm1vZGVsLmZpdCh0LG4sYSl9YXN5bmMgZml0RGF0YXNldCh0LG4pe2lmKCF0aGlzLmJ1aWx0KXRocm93IG5ldyBhcihcIlRoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC5cIik7cmV0dXJuIHRoaXMubW9kZWwuZml0RGF0YXNldCh0LG4pfWFzeW5jIHRyYWluT25CYXRjaCh0LG4pe3JldHVybiB0aGlzLm1vZGVsLnRyYWluT25CYXRjaCh0LG4pfXN0YXRpYyBmcm9tQ29uZmlnKHQsbixhPXt9LHI9ITEpe2xldCBzLGk9e307aWYobiBpbnN0YW5jZW9mIEFycmF5KXtpZihuWzBdLmNsYXNzTmFtZT09bnVsbHx8blswXS5jbGFzc05hbWU9PT1cIk1lcmdlXCIpdGhyb3cgbmV3IFYoXCJMZWdhY3kgc2VyaWFsaXphdGlvbiBmb3JtYXQgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO3M9bn1lbHNlIHcuYXNzZXJ0KG4ubGF5ZXJzIT1udWxsLCgpPT5cIldoZW4gdGhlIGNvbmZpZyBkYXRhIGZvciBhIFNlcXVlbnRpYWwgbW9kZWwgaXMgbm90IGFuIEFycmF5LCBpdCBtdXN0IGJlIGFuIE9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSAnbGF5ZXJzJyBmaWVsZC5cIikscz1uLmxheWVycyxkZWxldGUgbi5sYXllcnMsaT1uO2xldCBvPW5ldyB0KGkpO2lmKCEobyBpbnN0YW5jZW9mIEt4KSl0aHJvdyBuZXcgemUoYFNlcXVlbnRpYWwuZnJvbUNvbmZpZyBjYWxsZWQgb24gbm9uLVNlcXVlbnRpYWwgaW5wdXQ6ICR7b31gKTtmb3IobGV0IGwgb2Ygcyl7bGV0IHU9QmEobCx2b2lkIDAscik7ciYmdS5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKCEwKSxvLmFkZCh1KX1yZXR1cm4gb31zZXQgc3RvcFRyYWluaW5nKHQpe2lmKHRoaXMubW9kZWw9PW51bGwpdGhyb3cgbmV3IFYoXCJDYW5ub3Qgc2V0IHRoZSBzdG9wVHJhaW5pbmcgcHJvcGVydHkgb2YgYSBzZXF1ZW50aWFsIG1vZGVsIGJlZm9yZSBpdCBpcyBjb21waWxlZC5cIik7dGhpcy5tb2RlbC5zdG9wVHJhaW5pbmc9dH1nZXQgc3RvcFRyYWluaW5nKCl7aWYodGhpcy5tb2RlbD09bnVsbCl0aHJvdyBuZXcgVihcIkNhbm5vdCBnZXQgdGhlIHN0b3BUcmFpbmluZyBwcm9wZXJ0eSBvZiBhIHNlcXVlbnRpYWwgbW9kZWwgYmVmb3JlIGl0IGlzIGNvbXBpbGVkLlwiKTtyZXR1cm4gdGhpcy5tb2RlbC5zdG9wVHJhaW5pbmd9Z2V0Q29uZmlnKCl7bGV0IHQ9W107Zm9yKGxldCBuIG9mIHRoaXMubGF5ZXJzKXtsZXQgYT17fTthLmNsYXNzTmFtZT1uLmdldENsYXNzTmFtZSgpLGEuY29uZmlnPW4uZ2V0Q29uZmlnKCksdC5wdXNoKGEpfXJldHVybntuYW1lOnRoaXMubmFtZSxsYXllcnM6dH19fTtFZi5jbGFzc05hbWU9XCJTZXF1ZW50aWFsXCI7bmUucmVnaXN0ZXJDbGFzcyhFZik7ZnVuY3Rpb24gcGooZSl7cmV0dXJuIG5ldyBFcihlKX1mdW5jdGlvbiBjaihlKXtyZXR1cm4gbmV3IEVmKGUpfWZ1bmN0aW9uIGoyKGUpe3JldHVybiBTMihlKX1mdW5jdGlvbiBkaihlLHQpe2YwLnJlZ2lzdGVyQ2FsbGJhY2tDb25zdHJ1Y3RvcihlLHQpfXZhciB4bj1jbGFzcyBleHRlbmRzIG5lLlNlcmlhbGl6YWJsZXtnZXRDb25maWcoKXtyZXR1cm57fX19LHEyPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSx0PTEpe3JldHVybiBGRyhlLHQpfX07cTIuY2xhc3NOYW1lPVwiZWx1XCI7bmUucmVnaXN0ZXJDbGFzcyhxMik7dmFyIEsyPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSl7cmV0dXJuIFFtKGUpfX07SzIuY2xhc3NOYW1lPVwic2VsdVwiO25lLnJlZ2lzdGVyQ2xhc3MoSzIpO3ZhciBYMj1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiBLZShlKX19O1gyLmNsYXNzTmFtZT1cInJlbHVcIjtuZS5yZWdpc3RlckNsYXNzKFgyKTt2YXIgWTI9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gTygoKT0+ZHMoNixLZShlKSkpfX07WTIuY2xhc3NOYW1lPVwicmVsdTZcIjtuZS5yZWdpc3RlckNsYXNzKFkyKTt2YXIgWjI9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gZX19O1oyLmNsYXNzTmFtZT1cImxpbmVhclwiO25lLnJlZ2lzdGVyQ2xhc3MoWjIpO3ZhciBKMj1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiBoYShlKX19O0oyLmNsYXNzTmFtZT1cInNpZ21vaWRcIjtuZS5yZWdpc3RlckNsYXNzKEoyKTt2YXIgUTI9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gREcoZSl9fTtRMi5jbGFzc05hbWU9XCJoYXJkU2lnbW9pZFwiO25lLnJlZ2lzdGVyQ2xhc3MoUTIpO3ZhciBlQz1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiBHbyhlKX19O2VDLmNsYXNzTmFtZT1cInNvZnRwbHVzXCI7bmUucmVnaXN0ZXJDbGFzcyhlQyk7dmFyIHRDPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSl7cmV0dXJuICRHKGUpfX07dEMuY2xhc3NOYW1lPVwic29mdHNpZ25cIjtuZS5yZWdpc3RlckNsYXNzKHRDKTt2YXIgbkM9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlKXtyZXR1cm4gY3MoZSl9fTtuQy5jbGFzc05hbWU9XCJ0YW5oXCI7bmUucmVnaXN0ZXJDbGFzcyhuQyk7dmFyIHcwPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSx0PS0xKXtyZXR1cm4gcWEoZSx0KX19O3cwLmNsYXNzTmFtZT1cInNvZnRtYXhcIjtuZS5yZWdpc3RlckNsYXNzKHcwKTt2YXIgYUM9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlLHQ9LTEpe3JldHVybiBqbShlLHQpfX07YUMuY2xhc3NOYW1lPVwibG9nU29mdG1heFwiO25lLnJlZ2lzdGVyQ2xhc3MoYUMpO3ZhciByQz1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiBPKCgpPT5PKCgpPT57bGV0IHQ9TWF0aC5zcXJ0KDIpLG49eiguNSxYKDEsVW0oaGUoZSx0KSkpKTtyZXR1cm4geihlLG4pfSkpfX07ckMuY2xhc3NOYW1lPVwiZ2VsdVwiO25lLnJlZ2lzdGVyQ2xhc3MockMpO3ZhciBzQz1jbGFzcyBleHRlbmRzIHhue2FwcGx5KGUpe3JldHVybiBPKCgpPT56KC41LHooZSxYKDEsY3MoeihybihoZSgyLE1hdGguUEkpKSxYKGUseiguMDQ0NzE1LHVyKGUsMykpKSkpKSkpKX19O3NDLmNsYXNzTmFtZT1cImdlbHVfbmV3XCI7bmUucmVnaXN0ZXJDbGFzcyhzQyk7dmFyIGlDPWNsYXNzIGV4dGVuZHMgeG57YXBwbHkoZSl7cmV0dXJuIE8oKCk9PnooZSxjcyhHbyhlKSkpKX19O2lDLmNsYXNzTmFtZT1cIm1pc2hcIjtuZS5yZWdpc3RlckNsYXNzKGlDKTt2YXIgb0M9Y2xhc3MgZXh0ZW5kcyB4bnthcHBseShlLHQ9MSl7cmV0dXJuIE8oKCk9PnooaGEoeihlLHQpKSxlKSl9fTtvQy5jbGFzc05hbWU9XCJzd2lzaFwiO25lLnJlZ2lzdGVyQ2xhc3Mob0MpO2Z1bmN0aW9uIG1zKGUpe3JldHVybiBlLmdldENsYXNzTmFtZSgpfWZ1bmN0aW9uIGZ4KGUsdD17fSl7cmV0dXJuIHZkKGUsbmUuU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcImFjdGl2YXRpb25cIil9ZnVuY3Rpb24gZnMoZSl7aWYoZT09bnVsbCl7bGV0IHQ9e307cmV0dXJuIHQuY2xhc3NOYW1lPVwibGluZWFyXCIsdC5jb25maWc9e30sZngodCl9aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2xldCB0PXt9O3JldHVybiB0LmNsYXNzTmFtZT1lLHQuY29uZmlnPXt9LGZ4KHQpfWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiB4bj9lOmZ4KGUpfWZ1bmN0aW9uIGswKGUpe2lmKGUhPW51bGwmJnR5cGVvZiBlIT1cIm9iamVjdFwiKXRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgdG8gTDFMMiByZWd1bGFyaXplcidzIGNvbnN0cnVjdG9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke2V9YCl9dmFyIGxDPWNsYXNzIGV4dGVuZHMgbmUuU2VyaWFsaXphYmxle30sTmQ9Y2xhc3MgZXh0ZW5kcyBsQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcigpLGswKGUpLHRoaXMubDE9ZT09bnVsbHx8ZS5sMT09bnVsbD8uMDE6ZS5sMSx0aGlzLmwyPWU9PW51bGx8fGUubDI9PW51bGw/LjAxOmUubDIsdGhpcy5oYXNMMT10aGlzLmwxIT09MCx0aGlzLmhhc0wyPXRoaXMubDIhPT0wfWFwcGx5KGUpe3JldHVybiBPKCgpPT57bGV0IHQ9SXQoWzFdKTtyZXR1cm4gdGhpcy5oYXNMMSYmKHQ9WCh0LGZlKHoodGhpcy5sMSxMdChlKSkpKSksdGhpcy5oYXNMMiYmKHQ9WCh0LGZlKHoodGhpcy5sMixrZChlKSkpKSksVyh0LFtdKX0pfWdldENvbmZpZygpe3JldHVybntsMTp0aGlzLmwxLGwyOnRoaXMubDJ9fXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7cmV0dXJuIG5ldyBlKHtsMTp0LmwxLGwyOnQubDJ9KX19O05kLmNsYXNzTmFtZT1cIkwxTDJcIjtuZS5yZWdpc3RlckNsYXNzKE5kKTtmdW5jdGlvbiBoaihlKXtyZXR1cm4gazAoZSksbmV3IE5kKHtsMTplIT1udWxsP2UubDE6bnVsbCxsMjowfSl9ZnVuY3Rpb24gbWooZSl7cmV0dXJuIGswKGUpLG5ldyBOZCh7bDI6ZSE9bnVsbD9lLmwyOm51bGwsbDE6MH0pfXZhciBGST17bDFsMjpcIkwxTDJcIn07ZnVuY3Rpb24gZnQoZSl7cmV0dXJuIFF3KGUpfWZ1bmN0aW9uICRJKGUsdD17fSl7cmV0dXJuIHZkKGUsbmUuU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsdCxcInJlZ3VsYXJpemVyXCIpfWZ1bmN0aW9uIE50KGUpe2lmKGU9PW51bGwpcmV0dXJuIG51bGw7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2xldCB0PXtjbGFzc05hbWU6ZSBpbiBGST9GSVtlXTplLGNvbmZpZzp7fX07cmV0dXJuICRJKHQpfWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiBsQz9lOiRJKGUpfXZhciBJMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGU9PW51bGw/e306ZSksdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsZSE9bnVsbCYmKHRoaXMubWF4VmFsdWU9ZS5tYXhWYWx1ZSl9Y2FsbChlLHQpe2U9VGUoZSk7bGV0IG49S2UoZSk7cmV0dXJuIHRoaXMubWF4VmFsdWUhPW51bGwmJihuPWFuKG4sMCx0aGlzLm1heFZhbHVlKSksbn1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9e21heFZhbHVlOnRoaXMubWF4VmFsdWV9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07STAuY2xhc3NOYW1lPVwiUmVMVVwiO25lLnJlZ2lzdGVyQ2xhc3MoSTApO3ZhciBTMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGU9PW51bGw/e306ZSksdGhpcy5ERUZBVUxUX0FMUEhBPS4zLGU9PW51bGwmJihlPXt9KSx0aGlzLmFscGhhPWUuYWxwaGE9PW51bGw/dGhpcy5ERUZBVUxUX0FMUEhBOmUuYWxwaGF9Y2FsbChlLHQpe2xldCBuPVRlKGUpO3JldHVybiB1ZChuLHRoaXMuYWxwaGEpfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtyZXR1cm4gZX1nZXRDb25maWcoKXtsZXQgZT17YWxwaGE6dGhpcy5hbHBoYX0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtTMC5jbGFzc05hbWU9XCJMZWFreVJlTFVcIjtuZS5yZWdpc3RlckNsYXNzKFMwKTt2YXIgTjA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlPT1udWxsP3t9OmUpLHRoaXMuREVGQVVMVF9BTFBIQV9JTklUSUFMSVpFUj1cInplcm9zXCIsZT09bnVsbCYmKGU9e30pLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMuYWxwaGFJbml0aWFsaXplcj1TdChlLmFscGhhSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9BTFBIQV9JTklUSUFMSVpFUiksdGhpcy5hbHBoYVJlZ3VsYXJpemVyPU50KGUuYWxwaGFSZWd1bGFyaXplciksdGhpcy5hbHBoYUNvbnN0cmFpbnQ9WXQoZS5hbHBoYUNvbnN0cmFpbnQpLGUuc2hhcmVkQXhlcz09bnVsbCl0aGlzLnNoYXJlZEF4ZXM9bnVsbDtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZS5zaGFyZWRBeGVzKSl0aGlzLnNoYXJlZEF4ZXM9ZS5zaGFyZWRBeGVzO2Vsc2UgaWYodHlwZW9mIGUuc2hhcmVkQXhlcz09XCJudW1iZXJcIil0aGlzLnNoYXJlZEF4ZXM9W2Uuc2hhcmVkQXhlc107ZWxzZSB0aHJvdyBuZXcgVihgRXhwZWN0ZWQgc2hhcmVkQXhlcyB0byBiZSBhIG51bWJlciBvciBhbiBhcnJheSBvZiBudW1iZXJzLCBidXQgZ290ICR7ZS5zaGFyZWRBeGVzfWApfWJ1aWxkKGUpe2U9SmUoZSk7bGV0IHQ9ZS5zbGljZSgxKTtpZih0aGlzLnNoYXJlZEF4ZXMhPW51bGwpZm9yKGxldCBhIG9mIHRoaXMuc2hhcmVkQXhlcyl0W2EtMV09MTt0aGlzLmFscGhhPXRoaXMuYWRkV2VpZ2h0KFwiYWxwaGFcIix0LFwiZmxvYXQzMlwiLHRoaXMuYWxwaGFJbml0aWFsaXplcix0aGlzLmFscGhhUmVndWxhcml6ZXIsITAsdGhpcy5hbHBoYUNvbnN0cmFpbnQpO2xldCBuPXt9O2lmKHRoaXMuc2hhcmVkQXhlcyE9bnVsbClmb3IobGV0IGE9MTthPGUubGVuZ3RoOysrYSluW2FdPWVbYV07dGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTplLmxlbmd0aCxheGVzOm59KV0sdGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7cmV0dXJuIGU9VGUoZSksZmQoZSx0aGlzLmFscGhhLnJlYWQoKSl9Z2V0Q29uZmlnKCl7bGV0IGU9e2FscGhhSW5pdGlhbGl6ZXI6RXQodGhpcy5hbHBoYUluaXRpYWxpemVyKSxhbHBoYVJlZ3VsYXJpemVyOmZ0KHRoaXMuYWxwaGFSZWd1bGFyaXplciksYWxwaGFDb25zdHJhaW50Olh0KHRoaXMuYWxwaGFDb25zdHJhaW50KSxzaGFyZWRBeGVzOnRoaXMuc2hhcmVkQXhlc30sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtOMC5jbGFzc05hbWU9XCJQUmVMVVwiO25lLnJlZ2lzdGVyQ2xhc3MoTjApO3ZhciBUMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKGU9PW51bGw/e306ZSksdGhpcy5ERUZBVUxUX0FMUEhBPTEsZT09bnVsbCYmKGU9e30pLGUuYWxwaGEhPW51bGwmJmUuYWxwaGEhPT10aGlzLkRFRkFVTFRfQUxQSEEpdGhyb3cgbmV3IHplKGBOb24tZGVmYXVsdCBhbHBoYSB2YWx1ZSAoJHtlLmFscGhhfSkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgRUxVIGxheWVyIHlldC5gKTt0aGlzLmFscGhhPWUuYWxwaGE9PW51bGw/dGhpcy5ERUZBVUxUX0FMUEhBOmUuYWxwaGF9Y2FsbChlLHQpe2xldCBuPVRlKGUpO3JldHVybiBRdShuKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9e2FscGhhOnRoaXMuYWxwaGF9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07VDAuY2xhc3NOYW1lPVwiRUxVXCI7bmUucmVnaXN0ZXJDbGFzcyhUMCk7dmFyIEMwPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZT09bnVsbD97fTplKSx0aGlzLkRFRkFVTFRfVEhFVEE9MSxlPT1udWxsJiYoZT17fSksdGhpcy50aGV0YT1lLnRoZXRhPT1udWxsP3RoaXMuREVGQVVMVF9USEVUQTplLnRoZXRhfWNhbGwoZSx0KXtsZXQgbj1UZShlKTtyZXR1cm4geihuLHJlKENuKG4sdGhpcy50aGV0YSksXCJmbG9hdDMyXCIpKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9e3RoZXRhOnRoaXMudGhldGF9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07QzAuY2xhc3NOYW1lPVwiVGhyZXNob2xkZWRSZUxVXCI7bmUucmVnaXN0ZXJDbGFzcyhDMCk7dmFyIEUwPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZT09bnVsbD97fTplKSx0aGlzLkRFRkFVTFRfQVhJUz0xLGU9PW51bGwmJihlPXt9KSx0aGlzLnNvZnRtYXg9bmV3IHcwKCkuYXBwbHksdGhpcy5heGlzPWUuYXhpcz09bnVsbD90aGlzLkRFRkFVTFRfQVhJUzplLmF4aXN9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49VGUoZSksYT10Lm1hc2s7aWYoYSE9bnVsbCl7bGV0IHI9eihwZShQbihuLnNoYXBlKSxyZShhLG4uZHR5cGUpKSx4ZSgtMWU5KSk7bj1YKG4scil9cmV0dXJuIHRoaXMuYXhpcyBpbnN0YW5jZW9mIEFycmF5P3RoaXMuYXhpcy5sZW5ndGg+MT9kbihwZShuLGNkKG4sdGhpcy5heGlzLCEwKSkpOnRoaXMuc29mdG1heChuLHRoaXMuYXhpc1swXSk6dGhpcy5zb2Z0bWF4KG4sdGhpcy5heGlzKX0pfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtyZXR1cm4gZX1nZXRDb25maWcoKXtsZXQgZT17YXhpczp0aGlzLmF4aXN9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07RTAuY2xhc3NOYW1lPVwiU29mdG1heFwiO25lLnJlZ2lzdGVyQ2xhc3MoRTApO2Z1bmN0aW9uIEZsKGUsdCxuKXtpZih0eXBlb2YgZT09XCJudW1iZXJcIilyZXR1cm4gYmkoZSx0KTtpZihlLmxlbmd0aCE9PXQpdGhyb3cgbmV3IFYoYFRoZSAke259IGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciBvciB0dXBsZSBvZiAke3R9IGludGVnZXJzLiBSZWNlaXZlZDogJHtlLmxlbmd0aH0gZWxlbWVudHMuYCk7Zm9yKGxldCBhPTA7YTx0OysrYSl7bGV0IHI9ZVthXTtpZighQ0cocikpdGhyb3cgbmV3IFYoYFRoZSAke259IGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciBvciB0dXBsZSBvZiAke3R9IGludGVnZXJzLiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShlKX0gaW5jbHVkaW5nIGEgbm9uLWludGVnZXIgbnVtYmVyICR7cn1gKX1yZXR1cm4gZX1mdW5jdGlvbiBWYShlLHQsbixhLHI9MSl7aWYoZT09bnVsbClyZXR1cm4gZTtsZXQgcz10Kyh0LTEpKihyLTEpLGk7cmV0dXJuIG49PT1cInNhbWVcIj9pPWU6aT1lLXMrMSxNYXRoLmZsb29yKChpK2EtMSkvYSl9ZnVuY3Rpb24gbnIoZSx0LG4sYSl7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZihhPT09XCJ2YWxpZFwiKWU9ZSp0K2hzKFtuLXQsMF0pO2Vsc2UgaWYoYT09PVwic2FtZVwiKWU9ZSp0O2Vsc2UgdGhyb3cgbmV3IFYoYFVuc3VwcG9ydCBwYWRkaW5nIG1vZGU6ICR7YX0uYCk7cmV0dXJuIGV9ZnVuY3Rpb24gXzAoZSx0KXtyZXR1cm4gTygoKT0+KFJ0KHQpLHQ9PT1cImNoYW5uZWxzRmlyc3RcIj9EZShlLFswLDIsMywxXSk6ZSkpfWZ1bmN0aW9uIHVDKGUsdCl7cmV0dXJuIE8oKCk9PihSdCh0KSx0PT09XCJjaGFubmVsc0ZpcnN0XCI/RGUoZSxbMCwyLDMsNCwxXSk6ZSkpfWZ1bmN0aW9uIGZqKGUsdCxuLGE9MSxyPVwidmFsaWRcIixzLGk9MSl7cmV0dXJuIE8oKCk9PntpZihzPT1udWxsJiYocz1HYSgpKSxSdChzKSxlLnNoYXBlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFYoYFRoZSBpbnB1dCBvZiBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzICR7ZS5zaGFwZS5sZW5ndGh9IGluc3RlYWQuYCk7aWYodC5zaGFwZS5sZW5ndGghPT0zKXRocm93IG5ldyBWKGBUaGUga2VybmVsIGZvciBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzICR7dC5zaGFwZS5sZW5ndGh9IGluc3RlYWRgKTtpZihuIT1udWxsJiZuLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IFYoYFRoZSBiaWFzIGZvciBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMSwgYnV0IGlzICR7bi5zaGFwZS5sZW5ndGh9IGluc3RlYWRgKTtpZihzPT09XCJjaGFubmVsc0ZpcnN0XCImJihlPURlKGUsWzAsMiwxXSkpLHI9PT1cImNhdXNhbFwiKXRocm93IG5ldyB6ZShcIlRoZSBzdXBwb3J0IGZvciBDQVVTQUwgcGFkZGluZyBtb2RlIGluIGNvbnYxZFdpdGhCaWFzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2xldCBvPXptKGUsdCxhLHI9PT1cInNhbWVcIj9cInNhbWVcIjpcInZhbGlkXCIsXCJOV0NcIixpKTtyZXR1cm4gbiE9bnVsbCYmKG89S2EobyxuKSksb30pfWZ1bmN0aW9uIERJKGUsdCxuLGE9WzEsMV0scj1cInZhbGlkXCIscyxpLG89bnVsbCl7cmV0dXJuIE8oKCk9PntpZihzPT1udWxsJiYocz1HYSgpKSxSdChzKSxlLnJhbmshPT0zJiZlLnJhbmshPT00KXRocm93IG5ldyBWKGBjb252MmRXaXRoQmlhc0FjdGl2YXRpb24gZXhwZWN0cyBpbnB1dCB0byBiZSBvZiByYW5rIDMgb3IgNCwgYnV0IHJlY2VpdmVkICR7ZS5yYW5rfS5gKTtpZih0LnJhbmshPT0zJiZ0LnJhbmshPT00KXRocm93IG5ldyBWKGBjb252MmRXaXRoQmlhc0FjdGl2YXRpb24gZXhwZWN0cyBrZXJuZWwgdG8gYmUgb2YgcmFuayAzIG9yIDQsIGJ1dCByZWNlaXZlZCAke2UucmFua30uYCk7bGV0IGw9XzAoZSxzKTtpZihyPT09XCJjYXVzYWxcIil0aHJvdyBuZXcgemUoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252MWRXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gbD1WbC5jb252MmQoe3g6bCxmaWx0ZXI6dCxzdHJpZGVzOmEscGFkOnI9PT1cInNhbWVcIj9cInNhbWVcIjpcInZhbGlkXCIsZGlsYXRpb25zOmksZGF0YUZvcm1hdDpcIk5IV0NcIixiaWFzOm4sYWN0aXZhdGlvbjpvfSkscz09PVwiY2hhbm5lbHNGaXJzdFwiJiYobD1EZShsLFswLDMsMSwyXSkpLGx9KX1mdW5jdGlvbiBnaihlLHQsbixhPVsxLDEsMV0scj1cInZhbGlkXCIscyxpKXtyZXR1cm4gTygoKT0+e2lmKHM9PW51bGwmJihzPUdhKCkpLFJ0KHMpLGUucmFuayE9PTQmJmUucmFuayE9PTUpdGhyb3cgbmV3IFYoYGNvbnYzZFdpdGhCaWFzIGV4cGVjdHMgaW5wdXQgdG8gYmUgb2YgcmFuayA0IG9yIDUsIGJ1dCByZWNlaXZlZCAke2UucmFua30uYCk7aWYodC5yYW5rIT09NCYmdC5yYW5rIT09NSl0aHJvdyBuZXcgVihgY29udjNkV2l0aEJpYXMgZXhwZWN0cyBrZXJuZWwgdG8gYmUgb2YgcmFuayA0IG9yIDUsIGJ1dCByZWNlaXZlZCAke2UucmFua30uYCk7bGV0IG89dUMoZSxzKTtpZihyPT09XCJjYXVzYWxcIil0aHJvdyBuZXcgemUoXCJUaGUgc3VwcG9ydCBmb3IgQ0FVU0FMIHBhZGRpbmcgbW9kZSBpbiBjb252M2RXaXRoQmlhcyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LlwiKTtyZXR1cm4gbz1hdyhvLHQsYSxyPT09XCJzYW1lXCI/XCJzYW1lXCI6XCJ2YWxpZFwiLFwiTkRIV0NcIixpKSxuIT1udWxsJiYobz1LYShvLG4pKSxzPT09XCJjaGFubmVsc0ZpcnN0XCImJihvPURlKG8sWzAsNCwxLDIsM10pKSxvfSl9dmFyIHBDPWNsYXNzIGNDIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IodCxuKXtpZihzdXBlcihuKSx0aGlzLmJpYXM9bnVsbCx0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLGNDLnZlcmlmeUFyZ3MobiksdGhpcy5yYW5rPXQsdG4odGhpcy5yYW5rLFwicmFua1wiKSx0aGlzLnJhbmshPT0xJiZ0aGlzLnJhbmshPT0yJiZ0aGlzLnJhbmshPT0zKXRocm93IG5ldyB6ZShgQ29udm9sdXRpb24gbGF5ZXIgZm9yIHJhbmsgb3RoZXIgdGhhbiAxLCAyLCBvciAzICgke3RoaXMucmFua30pIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuYCk7aWYodGhpcy5rZXJuZWxTaXplPUZsKG4ua2VybmVsU2l6ZSx0LFwia2VybmVsU2l6ZVwiKSx0aGlzLnN0cmlkZXM9Rmwobi5zdHJpZGVzPT1udWxsPzE6bi5zdHJpZGVzLHQsXCJzdHJpZGVzXCIpLHRoaXMucGFkZGluZz1uLnBhZGRpbmc9PW51bGw/XCJ2YWxpZFwiOm4ucGFkZGluZyx2YSh0aGlzLnBhZGRpbmcpLHRoaXMuZGF0YUZvcm1hdD1uLmRhdGFGb3JtYXQ9PW51bGw/XCJjaGFubmVsc0xhc3RcIjpuLmRhdGFGb3JtYXQsUnQodGhpcy5kYXRhRm9ybWF0KSx0aGlzLmFjdGl2YXRpb249ZnMobi5hY3RpdmF0aW9uKSx0aGlzLnVzZUJpYXM9bi51c2VCaWFzPT1udWxsPyEwOm4udXNlQmlhcyx0aGlzLmJpYXNJbml0aWFsaXplcj1TdChuLmJpYXNJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLHRoaXMuYmlhc0NvbnN0cmFpbnQ9WXQobi5iaWFzQ29uc3RyYWludCksdGhpcy5iaWFzUmVndWxhcml6ZXI9TnQobi5iaWFzUmVndWxhcml6ZXIpLHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplcj1OdChuLmFjdGl2aXR5UmVndWxhcml6ZXIpLHRoaXMuZGlsYXRpb25SYXRlPUZsKG4uZGlsYXRpb25SYXRlPT1udWxsPzE6bi5kaWxhdGlvblJhdGUsdCxcImRpbGF0aW9uUmF0ZVwiKSx0aGlzLnJhbms9PT0xJiZBcnJheS5pc0FycmF5KHRoaXMuZGlsYXRpb25SYXRlKSYmdGhpcy5kaWxhdGlvblJhdGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgVihgZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgYSBzaW5nbGUgbnVtYmVyIGZvciAxRCBjb252b2x1dGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kaWxhdGlvblJhdGUpfWApO2lmKHRoaXMucmFuaz09PTIpe2lmKHR5cGVvZiB0aGlzLmRpbGF0aW9uUmF0ZT09XCJudW1iZXJcIil0aGlzLmRpbGF0aW9uUmF0ZT1bdGhpcy5kaWxhdGlvblJhdGUsdGhpcy5kaWxhdGlvblJhdGVdO2Vsc2UgaWYodGhpcy5kaWxhdGlvblJhdGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgVihgZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgdHdvIG51bWJlcnMgZm9yIDJEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRpbGF0aW9uUmF0ZSl9YCl9ZWxzZSBpZih0aGlzLnJhbms9PT0zKXtpZih0eXBlb2YgdGhpcy5kaWxhdGlvblJhdGU9PVwibnVtYmVyXCIpdGhpcy5kaWxhdGlvblJhdGU9W3RoaXMuZGlsYXRpb25SYXRlLHRoaXMuZGlsYXRpb25SYXRlLHRoaXMuZGlsYXRpb25SYXRlXTtlbHNlIGlmKHRoaXMuZGlsYXRpb25SYXRlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFYoYGRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFycmF5IG9mIHRocmVlIG51bWJlcnMgZm9yIDNEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRpbGF0aW9uUmF0ZSl9YCl9fXN0YXRpYyB2ZXJpZnlBcmdzKHQpe2lmKHRyKFwia2VybmVsU2l6ZVwiaW4gdCxcInJlcXVpcmVkIGtleSAna2VybmVsU2l6ZScgbm90IGluIGNvbmZpZ1wiKSx0eXBlb2YgdC5rZXJuZWxTaXplIT1cIm51bWJlclwiJiYhZTAodC5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwzKSl0aHJvdyBuZXcgVihgQmFzZUNvbnYgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgbnVtYmVyW10gd2l0aCBsZW5ndGggMSwgMiwgb3IgMywgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodC5rZXJuZWxTaXplKX0uYCl9Z2V0Q29uZmlnKCl7bGV0IHQ9e2tlcm5lbFNpemU6dGhpcy5rZXJuZWxTaXplLHN0cmlkZXM6dGhpcy5zdHJpZGVzLHBhZGRpbmc6dGhpcy5wYWRkaW5nLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0LGRpbGF0aW9uUmF0ZTp0aGlzLmRpbGF0aW9uUmF0ZSxhY3RpdmF0aW9uOm1zKHRoaXMuYWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsYmlhc0luaXRpYWxpemVyOkV0KHRoaXMuYmlhc0luaXRpYWxpemVyKSxiaWFzUmVndWxhcml6ZXI6ZnQodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6ZnQodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxiaWFzQ29uc3RyYWludDpYdCh0aGlzLmJpYXNDb25zdHJhaW50KX0sbj1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LG4pLHR9fSxfZj1jbGFzcyBkQyBleHRlbmRzIHBDe2NvbnN0cnVjdG9yKHQsbil7c3VwZXIodCxuKSx0aGlzLmtlcm5lbD1udWxsLGRDLnZlcmlmeUFyZ3MobiksdGhpcy5maWx0ZXJzPW4uZmlsdGVycyx0bih0aGlzLmZpbHRlcnMsXCJmaWx0ZXJzXCIpLHRoaXMua2VybmVsSW5pdGlhbGl6ZXI9U3Qobi5rZXJuZWxJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksdGhpcy5rZXJuZWxDb25zdHJhaW50PVl0KG4ua2VybmVsQ29uc3RyYWludCksdGhpcy5rZXJuZWxSZWd1bGFyaXplcj1OdChuLmtlcm5lbFJlZ3VsYXJpemVyKX1idWlsZCh0KXt0PUplKHQpO2xldCBuPXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPzE6dC5sZW5ndGgtMTtpZih0W25dPT1udWxsKXRocm93IG5ldyBWKGBUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0IHNob3VsZCBiZSBkZWZpbmVkLiBGb3VuZCAke3Rbbl19YCk7bGV0IGE9dFtuXSxyPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW2EsdGhpcy5maWx0ZXJzXSk7dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixyLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy51c2VCaWFzJiYodGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLG51bGwsdGhpcy5iaWFzSW5pdGlhbGl6ZXIsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCkpLHRoaXMuaW5wdXRTcGVjPVt7bmRpbTp0aGlzLnJhbmsrMixheGVzOntbbl06YX19XSx0aGlzLmJ1aWx0PSEwfWNhbGwodCxuKXtyZXR1cm4gTygoKT0+e3Q9VGUodCk7bGV0IGEscj10aGlzLmJpYXM9PW51bGw/bnVsbDp0aGlzLmJpYXMucmVhZCgpLHM9bTIodGhpcy5hY3RpdmF0aW9uLmdldENsYXNzTmFtZSgpKTtpZihzIT1udWxsJiZ0aGlzLnJhbms9PT0yKWE9REkodCx0aGlzLmtlcm5lbC5yZWFkKCkscix0aGlzLnN0cmlkZXMsdGhpcy5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdCx0aGlzLmRpbGF0aW9uUmF0ZSxzKTtlbHNle2lmKHRoaXMucmFuaz09PTEpYT1maih0LHRoaXMua2VybmVsLnJlYWQoKSxyLHRoaXMuc3RyaWRlc1swXSx0aGlzLnBhZGRpbmcsdGhpcy5kYXRhRm9ybWF0LHRoaXMuZGlsYXRpb25SYXRlWzBdKTtlbHNlIGlmKHRoaXMucmFuaz09PTIpYT1ESSh0LHRoaXMua2VybmVsLnJlYWQoKSxyLHRoaXMuc3RyaWRlcyx0aGlzLnBhZGRpbmcsdGhpcy5kYXRhRm9ybWF0LHRoaXMuZGlsYXRpb25SYXRlKTtlbHNlIGlmKHRoaXMucmFuaz09PTMpYT1naih0LHRoaXMua2VybmVsLnJlYWQoKSxyLHRoaXMuc3RyaWRlcyx0aGlzLnBhZGRpbmcsdGhpcy5kYXRhRm9ybWF0LHRoaXMuZGlsYXRpb25SYXRlKTtlbHNlIHRocm93IG5ldyB6ZShcImNvbnZvbHV0aW9ucyBncmVhdGVyIHRoYW4gM0QgYXJlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3RoaXMuYWN0aXZhdGlvbiE9bnVsbCYmKGE9dGhpcy5hY3RpdmF0aW9uLmFwcGx5KGEpKX1yZXR1cm4gYX0pfWNvbXB1dGVPdXRwdXRTaGFwZSh0KXt0PUplKHQpO2xldCBuPVtdLGE9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIj90LnNsaWNlKDEsdC5sZW5ndGgtMSk6dC5zbGljZSgyKTtmb3IobGV0IHM9MDtzPGEubGVuZ3RoOysrcyl7bGV0IGk9VmEoYVtzXSx0aGlzLmtlcm5lbFNpemVbc10sdGhpcy5wYWRkaW5nLHRoaXMuc3RyaWRlc1tzXSx0eXBlb2YgdGhpcy5kaWxhdGlvblJhdGU9PVwibnVtYmVyXCI/dGhpcy5kaWxhdGlvblJhdGU6dGhpcy5kaWxhdGlvblJhdGVbc10pO24ucHVzaChpKX1sZXQgcj1bdFswXV07cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCI/KHI9ci5jb25jYXQobiksci5wdXNoKHRoaXMuZmlsdGVycykpOihyLnB1c2godGhpcy5maWx0ZXJzKSxyPXIuY29uY2F0KG4pKSxyfWdldENvbmZpZygpe2xldCB0PXtmaWx0ZXJzOnRoaXMuZmlsdGVycyxrZXJuZWxJbml0aWFsaXplcjpFdCh0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpmdCh0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50Olh0KHRoaXMua2VybmVsQ29uc3RyYWludCl9LG49c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24odCxuKSx0fXN0YXRpYyB2ZXJpZnlBcmdzKHQpe2lmKCEoXCJmaWx0ZXJzXCJpbiB0KXx8dHlwZW9mIHQuZmlsdGVycyE9XCJudW1iZXJcInx8dC5maWx0ZXJzPDEpdGhyb3cgbmV3IFYoYENvbnZvbHV0aW9uIGxheWVyIGV4cGVjdGVkIGNvbmZpZy5maWx0ZXJzIHRvIGJlIGEgJ251bWJlcicgPiAwIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeSh0LmZpbHRlcnMpfWApfX0sQWY9Y2xhc3MgaEMgZXh0ZW5kcyBfZntjb25zdHJ1Y3Rvcih0KXtzdXBlcigyLHQpLGhDLnZlcmlmeUFyZ3ModCl9Z2V0Q29uZmlnKCl7bGV0IHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIGRlbGV0ZSB0LnJhbmssdH1zdGF0aWMgdmVyaWZ5QXJncyh0KXtpZih0eXBlb2YgdC5rZXJuZWxTaXplIT1cIm51bWJlclwiJiYhZTAodC5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwyKSl0aHJvdyBuZXcgVihgQ29udjJEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEgb3IgMiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodC5rZXJuZWxTaXplKX0uYCl9fTtBZi5jbGFzc05hbWU9XCJDb252MkRcIjtuZS5yZWdpc3RlckNsYXNzKEFmKTt2YXIgRmY9Y2xhc3MgbUMgZXh0ZW5kcyBfZntjb25zdHJ1Y3Rvcih0KXtzdXBlcigzLHQpLG1DLnZlcmlmeUFyZ3ModCl9Z2V0Q29uZmlnKCl7bGV0IHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIGRlbGV0ZSB0LnJhbmssdH1zdGF0aWMgdmVyaWZ5QXJncyh0KXtpZih0eXBlb2YgdC5rZXJuZWxTaXplIT1cIm51bWJlclwiJiYhKEFycmF5LmlzQXJyYXkodC5rZXJuZWxTaXplKSYmKHQua2VybmVsU2l6ZS5sZW5ndGg9PT0xfHx0Lmtlcm5lbFNpemUubGVuZ3RoPT09MykpKXRocm93IG5ldyBWKGBDb252M0QgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0Lmtlcm5lbFNpemUpfS5gKX19O0ZmLmNsYXNzTmFtZT1cIkNvbnYzRFwiO25lLnJlZ2lzdGVyQ2xhc3MoRmYpO3ZhciBBMD1jbGFzcyBleHRlbmRzIEFme2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKGUpLHRoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06NH0pXSx0aGlzLnBhZGRpbmchPT1cInNhbWVcIiYmdGhpcy5wYWRkaW5nIT09XCJ2YWxpZFwiKXRocm93IG5ldyBWKGBDb252MkRUcmFuc3Bvc2UgY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlcyAnc2FtZScgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCBwYWRkaW5nIG1vZGUgJHt0aGlzLnBhZGRpbmd9YCl9YnVpbGQoZSl7aWYoZT1KZShlKSxlLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFYoXCJJbnB1dCBzaG91bGQgaGF2ZSByYW5rIDQ7IFJlY2VpdmVkIGlucHV0IHNoYXBlOiBcIitKU09OLnN0cmluZ2lmeShlKSk7bGV0IHQ9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/MTplLmxlbmd0aC0xO2lmKGVbdF09PW51bGwpdGhyb3cgbmV3IFYoXCJUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZC4gRm91bmQgYE5vbmVgLlwiKTtsZXQgbj1lW3RdLGE9dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbdGhpcy5maWx0ZXJzLG5dKTt0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLGEsXCJmbG9hdDMyXCIsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy51c2VCaWFzJiYodGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLFwiZmxvYXQzMlwiLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjQsYXhlczp7W3RdOm59fSldLHRoaXMuYnVpbHQ9ITB9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49VGUoZSk7aWYobi5zaGFwZS5sZW5ndGghPT00KXRocm93IG5ldyBWKGBDb252MkRUcmFuc3Bvc2UuY2FsbCgpIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIHJhbmstNCwgYnV0IHJlY2VpdmVkIGEgdGVuc29yIG9mIHJhbmstJHtuLnNoYXBlLmxlbmd0aH1gKTtsZXQgYT1uLnNoYXBlLHI9YVswXSxzLGk7dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/KHM9MixpPTMpOihzPTEsaT0yKTtsZXQgbz1hW3NdLGw9YVtpXSx1PXRoaXMua2VybmVsU2l6ZVswXSxwPXRoaXMua2VybmVsU2l6ZVsxXSxkPXRoaXMuc3RyaWRlc1swXSxjPXRoaXMuc3RyaWRlc1sxXSxoPW5yKG8sZCx1LHRoaXMucGFkZGluZyksbT1ucihsLGMscCx0aGlzLnBhZGRpbmcpLGY9W3IsaCxtLHRoaXMuZmlsdGVyc107dGhpcy5kYXRhRm9ybWF0IT09XCJjaGFubmVsc0xhc3RcIiYmKG49RGUobixbMCwyLDMsMV0pKTtsZXQgZz1XbShuLHRoaXMua2VybmVsLnJlYWQoKSxmLHRoaXMuc3RyaWRlcyx0aGlzLnBhZGRpbmcpO3JldHVybiB0aGlzLmRhdGFGb3JtYXQhPT1cImNoYW5uZWxzTGFzdFwiJiYoZz1EZShnLFswLDMsMSwyXSkpLHRoaXMuYmlhcyE9bnVsbCYmKGc9S2EoZyx0aGlzLmJpYXMucmVhZCgpLHRoaXMuZGF0YUZvcm1hdCkpLHRoaXMuYWN0aXZhdGlvbiE9bnVsbCYmKGc9dGhpcy5hY3RpdmF0aW9uLmFwcGx5KGcpKSxnfSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9ZS5zbGljZSgpLG4sYSxyO3RoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPyhuPTEsYT0yLHI9Myk6KG49MyxhPTEscj0yKTtsZXQgcz10aGlzLmtlcm5lbFNpemVbMF0saT10aGlzLmtlcm5lbFNpemVbMV0sbz10aGlzLnN0cmlkZXNbMF0sbD10aGlzLnN0cmlkZXNbMV07cmV0dXJuIHRbbl09dGhpcy5maWx0ZXJzLHRbYV09bnIodFthXSxvLHMsdGhpcy5wYWRkaW5nKSx0W3JdPW5yKHRbcl0sbCxpLHRoaXMucGFkZGluZyksdH1nZXRDb25maWcoKXtsZXQgZT1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gZGVsZXRlIGUuZGlsYXRpb25SYXRlLGV9fTtBMC5jbGFzc05hbWU9XCJDb252MkRUcmFuc3Bvc2VcIjtuZS5yZWdpc3RlckNsYXNzKEEwKTt2YXIgRjA9Y2xhc3MgZXh0ZW5kcyBGZntjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjV9KV0sdGhpcy5wYWRkaW5nIT09XCJzYW1lXCImJnRoaXMucGFkZGluZyE9PVwidmFsaWRcIil0aHJvdyBuZXcgVihgQ29udjNEVHJhbnNwb3NlIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IHBhZGRpbmcgbW9kZXMgJ3NhbWUnIGFuZCAndmFsaWQnLCBidXQgcmVjZWl2ZWQgcGFkZGluZyBtb2RlICR7dGhpcy5wYWRkaW5nfWApfWJ1aWxkKGUpe2lmKGU9SmUoZSksZS5sZW5ndGghPT01KXRocm93IG5ldyBWKFwiSW5wdXQgc2hvdWxkIGhhdmUgcmFuayA1OyBSZWNlaXZlZCBpbnB1dCBzaGFwZTogXCIrSlNPTi5zdHJpbmdpZnkoZSkpO2xldCB0PXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPzE6ZS5sZW5ndGgtMTtpZihlW3RdPT1udWxsKXRocm93IG5ldyBWKFwiVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQuIEZvdW5kIGBOb25lYC5cIik7bGV0IG49ZVt0XSxhPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycyxuXSk7dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixhLFwiZmxvYXQzMlwiLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy5maWx0ZXJzXSxcImZsb2F0MzJcIix0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KSksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTo1LGF4ZXM6e1t0XTpufX0pXSx0aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpO2lmKG4uc2hhcGUubGVuZ3RoIT09NSl0aHJvdyBuZXcgVihgQ29udjNEVHJhbnNwb3NlLmNhbGwoKSBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSByYW5rLTQsIGJ1dCByZWNlaXZlZCBhIHRlbnNvciBvZiByYW5rLSR7bi5zaGFwZS5sZW5ndGh9YCk7bGV0IGE9bi5zaGFwZSxyPWFbMF0scyxpLG87dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/KG89MixzPTMsaT00KToobz0xLHM9MixpPTMpO2xldCBsPWFbb10sdT1hW3NdLHA9YVtpXSxkPXRoaXMua2VybmVsU2l6ZVswXSxjPXRoaXMua2VybmVsU2l6ZVsxXSxoPXRoaXMua2VybmVsU2l6ZVsyXSxtPXRoaXMuc3RyaWRlc1swXSxmPXRoaXMuc3RyaWRlc1sxXSxnPXRoaXMuc3RyaWRlc1syXSxiPW5yKGwsbSxkLHRoaXMucGFkZGluZykseT1ucih1LGYsYyx0aGlzLnBhZGRpbmcpLHg9bnIocCxnLGgsdGhpcy5wYWRkaW5nKSx2PVtyLGIseSx4LHRoaXMuZmlsdGVyc107dGhpcy5kYXRhRm9ybWF0IT09XCJjaGFubmVsc0xhc3RcIiYmKG49RGUobixbMCwyLDMsNCwxXSkpO2xldCBJPXJ3KG4sdGhpcy5rZXJuZWwucmVhZCgpLHYsdGhpcy5zdHJpZGVzLHRoaXMucGFkZGluZyk7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdCE9PVwiY2hhbm5lbHNMYXN0XCImJihJPURlKEksWzAsNCwxLDIsM10pKSx0aGlzLmJpYXMhPT1udWxsJiYoST1LYShJLHRoaXMuYmlhcy5yZWFkKCksdGhpcy5kYXRhRm9ybWF0KSksdGhpcy5hY3RpdmF0aW9uIT09bnVsbCYmKEk9dGhpcy5hY3RpdmF0aW9uLmFwcGx5KEkpKSxJfSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9ZS5zbGljZSgpLG4sYSxyLHM7dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/KG49MSxhPTIscj0zLHM9NCk6KG49NCxhPTEscj0yLHM9Myk7bGV0IGk9dGhpcy5rZXJuZWxTaXplWzBdLG89dGhpcy5rZXJuZWxTaXplWzFdLGw9dGhpcy5rZXJuZWxTaXplWzJdLHU9dGhpcy5zdHJpZGVzWzBdLHA9dGhpcy5zdHJpZGVzWzFdLGQ9dGhpcy5zdHJpZGVzWzJdO3JldHVybiB0W25dPXRoaXMuZmlsdGVycyx0W2FdPW5yKHRbYV0sdSxpLHRoaXMucGFkZGluZyksdFtyXT1ucih0W3JdLHAsbyx0aGlzLnBhZGRpbmcpLHRbc109bnIodFtzXSxkLGwsdGhpcy5wYWRkaW5nKSx0fWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpO3JldHVybiBkZWxldGUgZS5kaWxhdGlvblJhdGUsZX19O0YwLmNsYXNzTmFtZT1cIkNvbnYzRFRyYW5zcG9zZVwiO25lLnJlZ2lzdGVyQ2xhc3MoRjApO3ZhciBmQz1jbGFzcyBleHRlbmRzIF9me2NvbnN0cnVjdG9yKGUsdCl7aWYoc3VwZXIoZSx0KSx0aGlzLkRFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSPVwiZ2xvcm90VW5pZm9ybVwiLHRoaXMuREVGQVVMVF9QT0lOVFdJU0VfSU5JVElBTElaRVI9XCJnbG9yb3RVbmlmb3JtXCIsdGhpcy5kZXB0aHdpc2VLZXJuZWw9bnVsbCx0aGlzLnBvaW50d2lzZUtlcm5lbD1udWxsLHQuZmlsdGVycz09bnVsbCl0aHJvdyBuZXcgVihcIlRoZSBgZmlsdGVyc2AgY29uZmlndXJhdGlvbiBmaWVsZCBpcyByZXF1aXJlZCBieSBTZXBhcmFibGVDb252LCBidXQgaXMgdW5zcGVjaWZpZWQuXCIpO2lmKHQua2VybmVsSW5pdGlhbGl6ZXIhPW51bGx8fHQua2VybmVsUmVndWxhcml6ZXIhPW51bGx8fHQua2VybmVsQ29uc3RyYWludCE9bnVsbCl0aHJvdyBuZXcgVihcIkZpZWxkcyBrZXJuZWxJbml0aWFsaXplciwga2VybmVsUmVndWxhcml6ZXIgYW5kIGtlcm5lbENvbnN0cmFpbnQgYXJlIGludmFsaWQgZm9yIFNlcGFyYWJsZUNvbnYyRC4gVXNlIGRlcHRod2lzZUluaXRpYWxpemVyLCBkZXB0aHdpc2VSZWd1bGFyaXplciwgZGVwdGh3aXNlQ29uc3RyYWludCwgcG9pbnR3aXNlSW5pdGlhbGl6ZXIsIHBvaW50d2lzZVJlZ3VsYXJpemVyIGFuZCBwb2ludHdpc2VDb25zdHJhaW50IGluc3RlYWQuXCIpO2lmKHQucGFkZGluZyE9bnVsbCYmdC5wYWRkaW5nIT09XCJzYW1lXCImJnQucGFkZGluZyE9PVwidmFsaWRcIil0aHJvdyBuZXcgVihgU2VwYXJhYmxlQ29udiR7dGhpcy5yYW5rfUQgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzOiAnc2FtZScgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHQucGFkZGluZyl9YCk7dGhpcy5kZXB0aE11bHRpcGxpZXI9dC5kZXB0aE11bHRpcGxpZXI9PW51bGw/MTp0LmRlcHRoTXVsdGlwbGllcix0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyPVN0KHQuZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9ERVBUSFdJU0VfSU5JVElBTElaRVIpLHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXI9TnQodC5kZXB0aHdpc2VSZWd1bGFyaXplciksdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50PVl0KHQuZGVwdGh3aXNlQ29uc3RyYWludCksdGhpcy5wb2ludHdpc2VJbml0aWFsaXplcj1TdCh0LmRlcHRod2lzZUluaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfUE9JTlRXSVNFX0lOSVRJQUxJWkVSKSx0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyPU50KHQucG9pbnR3aXNlUmVndWxhcml6ZXIpLHRoaXMucG9pbnR3aXNlQ29uc3RyYWludD1ZdCh0LnBvaW50d2lzZUNvbnN0cmFpbnQpfWJ1aWxkKGUpe2lmKGU9SmUoZSksZS5sZW5ndGg8dGhpcy5yYW5rKzIpdGhyb3cgbmV3IFYoYElucHV0cyB0byBTZXBhcmFibGVDb252JHt0aGlzLnJhbmt9RCBzaG91bGQgaGF2ZSByYW5rICR7dGhpcy5yYW5rKzJ9LCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGU6ICR7SlNPTi5zdHJpbmdpZnkoZSl9YCk7bGV0IHQ9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/MTplLmxlbmd0aC0xO2lmKGVbdF09PW51bGx8fGVbdF08MCl0aHJvdyBuZXcgVihgVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dHMgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBmb3VuZCAke0pTT04uc3RyaW5naWZ5KGVbdF0pfWApO2xldCBuPWVbdF0sYT10aGlzLmtlcm5lbFNpemUuY29uY2F0KFtuLHRoaXMuZGVwdGhNdWx0aXBsaWVyXSkscj1bXTtmb3IobGV0IGk9MDtpPHRoaXMucmFuazsrK2kpci5wdXNoKDEpO3IucHVzaChuKnRoaXMuZGVwdGhNdWx0aXBsaWVyLHRoaXMuZmlsdGVycyk7bGV0IHM9ITA7dGhpcy5kZXB0aHdpc2VLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJkZXB0aHdpc2Vfa2VybmVsXCIsYSxcImZsb2F0MzJcIix0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyLHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIscyx0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpLHRoaXMucG9pbnR3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicG9pbnR3aXNlX2tlcm5lbFwiLHIsXCJmbG9hdDMyXCIsdGhpcy5wb2ludHdpc2VJbml0aWFsaXplcix0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyLHMsdGhpcy5wb2ludHdpc2VDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnNdLFwiZmxvYXQzMlwiLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLHMsdGhpcy5iaWFzQ29uc3RyYWludCk6dGhpcy5iaWFzPW51bGwsdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTp0aGlzLnJhbmsrMixheGVzOntbdF06bn19KV0sdGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntlPVRlKGUpO2xldCBuO2lmKHRoaXMucmFuaz09PTEpdGhyb3cgbmV3IHplKFwiMUQgc2VwYXJhYmxlIGNvbnZvbHV0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO3JldHVybiB0aGlzLnJhbms9PT0yJiYodGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCImJihlPURlKGUsWzAsMiwzLDFdKSksbj1fcyhlLHRoaXMuZGVwdGh3aXNlS2VybmVsLnJlYWQoKSx0aGlzLnBvaW50d2lzZUtlcm5lbC5yZWFkKCksdGhpcy5zdHJpZGVzLHRoaXMucGFkZGluZyx0aGlzLmRpbGF0aW9uUmF0ZSxcIk5IV0NcIikpLHRoaXMudXNlQmlhcyYmKG49S2Eobix0aGlzLmJpYXMucmVhZCgpLHRoaXMuZGF0YUZvcm1hdCkpLHRoaXMuYWN0aXZhdGlvbiE9bnVsbCYmKG49dGhpcy5hY3RpdmF0aW9uLmFwcGx5KG4pKSx0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIiYmKG49RGUobixbMCwzLDEsMl0pKSxufSl9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIGRlbGV0ZSBlLnJhbmssZGVsZXRlIGUua2VybmVsSW5pdGlhbGl6ZXIsZGVsZXRlIGUua2VybmVsUmVndWxhcml6ZXIsZGVsZXRlIGUua2VybmVsQ29uc3RyYWludCxlLmRlcHRod2lzZUluaXRpYWxpemVyPUV0KHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpLGUucG9pbnR3aXNlSW5pdGlhbGl6ZXI9RXQodGhpcy5wb2ludHdpc2VJbml0aWFsaXplciksZS5kZXB0aHdpc2VSZWd1bGFyaXplcj1mdCh0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyKSxlLnBvaW50d2lzZVJlZ3VsYXJpemVyPWZ0KHRoaXMucG9pbnR3aXNlUmVndWxhcml6ZXIpLGUuZGVwdGh3aXNlQ29uc3RyYWludD1YdCh0aGlzLmRlcHRod2lzZUNvbnN0cmFpbnQpLGUucG9pbnR3aXNlQ29uc3RyYWludD1YdCh0aGlzLnBvaW50d2lzZUNvbnN0cmFpbnQpLGV9fTtmQy5jbGFzc05hbWU9XCJTZXBhcmFibGVDb252XCI7dmFyICQwPWNsYXNzIGV4dGVuZHMgZkN7Y29uc3RydWN0b3IoZSl7c3VwZXIoMixlKX19OyQwLmNsYXNzTmFtZT1cIlNlcGFyYWJsZUNvbnYyRFwiO25lLnJlZ2lzdGVyQ2xhc3MoJDApO3ZhciBEMD1jbGFzcyBnQyBleHRlbmRzIF9me2NvbnN0cnVjdG9yKHQpe3N1cGVyKDEsdCksZ0MudmVyaWZ5QXJncyh0KSx0aGlzLmlucHV0U3BlYz1be25kaW06M31dfWdldENvbmZpZygpe2xldCB0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBkZWxldGUgdC5yYW5rLGRlbGV0ZSB0LmRhdGFGb3JtYXQsdH1zdGF0aWMgdmVyaWZ5QXJncyh0KXtpZih0eXBlb2YgdC5rZXJuZWxTaXplIT1cIm51bWJlclwiJiYhZTAodC5rZXJuZWxTaXplLFwibnVtYmVyXCIsMSwxKSl0aHJvdyBuZXcgVihgQ29udjFEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggbGVuZ3RoIDEsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHQua2VybmVsU2l6ZSl9LmApfX07RDAuY2xhc3NOYW1lPVwiQ29udjFEXCI7bmUucmVnaXN0ZXJDbGFzcyhEMCk7dmFyIFIwPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdHlwZW9mIGUuY3JvcHBpbmc9PVwibnVtYmVyXCI/dGhpcy5jcm9wcGluZz1bW2UuY3JvcHBpbmcsZS5jcm9wcGluZ10sW2UuY3JvcHBpbmcsZS5jcm9wcGluZ11dOnR5cGVvZiBlLmNyb3BwaW5nWzBdPT1cIm51bWJlclwiP3RoaXMuY3JvcHBpbmc9W1tlLmNyb3BwaW5nWzBdLGUuY3JvcHBpbmdbMF1dLFtlLmNyb3BwaW5nWzFdLGUuY3JvcHBpbmdbMV1dXTp0aGlzLmNyb3BwaW5nPWUuY3JvcHBpbmcsdGhpcy5kYXRhRm9ybWF0PWUuZGF0YUZvcm1hdD09PXZvaWQgMD9cImNoYW5uZWxzTGFzdFwiOmUuZGF0YUZvcm1hdCx0aGlzLmlucHV0U3BlYz1be25kaW06NH1dfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/W2VbMF0sZVsxXSxlWzJdLXRoaXMuY3JvcHBpbmdbMF1bMF0tdGhpcy5jcm9wcGluZ1swXVsxXSxlWzNdLXRoaXMuY3JvcHBpbmdbMV1bMF0tdGhpcy5jcm9wcGluZ1sxXVsxXV06W2VbMF0sZVsxXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sZVsyXS10aGlzLmNyb3BwaW5nWzFdWzBdLXRoaXMuY3JvcHBpbmdbMV1bMV0sZVszXV19Y2FsbChlLHQpe3JldHVybiBPKCgpPT57aWYoZT1UZShlKSx0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiKXtsZXQgbj1JaChlLHRoaXMuY3JvcHBpbmdbMF1bMF0sZS5zaGFwZVsxXS10aGlzLmNyb3BwaW5nWzBdWzBdLXRoaXMuY3JvcHBpbmdbMF1bMV0sMik7cmV0dXJuIEloKG4sdGhpcy5jcm9wcGluZ1sxXVswXSxlLnNoYXBlWzJdLXRoaXMuY3JvcHBpbmdbMV1bMV0tdGhpcy5jcm9wcGluZ1sxXVswXSwzKX1lbHNle2xldCBuPUloKGUsdGhpcy5jcm9wcGluZ1swXVswXSxlLnNoYXBlWzJdLXRoaXMuY3JvcHBpbmdbMF1bMF0tdGhpcy5jcm9wcGluZ1swXVsxXSwzKTtyZXR1cm4gSWgobix0aGlzLmNyb3BwaW5nWzFdWzBdLGUuc2hhcGVbM10tdGhpcy5jcm9wcGluZ1sxXVsxXS10aGlzLmNyb3BwaW5nWzFdWzBdLDQpfX0pfWdldENvbmZpZygpe2xldCBlPXtjcm9wcGluZzp0aGlzLmNyb3BwaW5nLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O1IwLmNsYXNzTmFtZT1cIkNyb3BwaW5nMkRcIjtuZS5yZWdpc3RlckNsYXNzKFIwKTt2YXIgTTA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLkRFRkFVTFRfU0laRT1bMiwyXSx0aGlzLmlucHV0U3BlYz1be25kaW06NH1dLHRoaXMuc2l6ZT1lLnNpemU9PW51bGw/dGhpcy5ERUZBVUxUX1NJWkU6ZS5zaXplLHRoaXMuZGF0YUZvcm1hdD1lLmRhdGFGb3JtYXQ9PW51bGw/XCJjaGFubmVsc0xhc3RcIjplLmRhdGFGb3JtYXQsUnQodGhpcy5kYXRhRm9ybWF0KSx0aGlzLmludGVycG9sYXRpb249ZS5pbnRlcnBvbGF0aW9uPT1udWxsP1wibmVhcmVzdFwiOmUuaW50ZXJwb2xhdGlvbixTRyh0aGlzLmludGVycG9sYXRpb24pfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtpZih0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIil7bGV0IHQ9ZVsyXT09bnVsbD9udWxsOnRoaXMuc2l6ZVswXSplWzJdLG49ZVszXT09bnVsbD9udWxsOnRoaXMuc2l6ZVsxXSplWzNdO3JldHVybltlWzBdLGVbMV0sdCxuXX1lbHNle2xldCB0PWVbMV09PW51bGw/bnVsbDp0aGlzLnNpemVbMF0qZVsxXSxuPWVbMl09PW51bGw/bnVsbDp0aGlzLnNpemVbMV0qZVsyXTtyZXR1cm5bZVswXSx0LG4sZVszXV19fWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpLGE9bi5zaGFwZTtpZih0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIil7bj1EZShuLFswLDIsMywxXSk7bGV0IHI9dGhpcy5zaXplWzBdKmFbMl0scz10aGlzLnNpemVbMV0qYVszXSxpPXRoaXMuaW50ZXJwb2xhdGlvbj09PVwibmVhcmVzdFwiP1puLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihuLFtyLHNdKTpabi5yZXNpemVCaWxpbmVhcihuLFtyLHNdKTtyZXR1cm4gRGUoaSxbMCwzLDEsMl0pfWVsc2V7bGV0IHI9dGhpcy5zaXplWzBdKmFbMV0scz10aGlzLnNpemVbMV0qYVsyXTtyZXR1cm4gdGhpcy5pbnRlcnBvbGF0aW9uPT09XCJuZWFyZXN0XCI/Wm4ucmVzaXplTmVhcmVzdE5laWdoYm9yKG4sW3Isc10pOlpuLnJlc2l6ZUJpbGluZWFyKG4sW3Isc10pfX0pfWdldENvbmZpZygpe2xldCBlPXtzaXplOnRoaXMuc2l6ZSxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdCxpbnRlcnBvbGF0aW9uOnRoaXMuaW50ZXJwb2xhdGlvbn0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtNMC5jbGFzc05hbWU9XCJVcFNhbXBsaW5nMkRcIjtuZS5yZWdpc3RlckNsYXNzKE0wKTtmdW5jdGlvbiBiaihlLHQsbj1bMSwxXSxhPVwidmFsaWRcIixyLHMpe3JldHVybiBPKCgpPT57cj09bnVsbCYmKHI9R2EoKSksUnQocik7bGV0IGk9XzAoZSxyKTtpZihlLnJhbmshPT00KXRocm93IG5ldyBWKGBJbnB1dCBmb3IgZGVwdGh3aXNlQ29udjJkIGlzIHJlcXVpcmVkIHRvIGJlIDQtRCwgYnV0IGlzIGluc3RlYWQgJHtlLnJhbmt9LURgKTtpZih0LnJhbmshPT00KXRocm93IG5ldyBWKGBkZXB0aHdpc2VLZXJuZWwgaXMgcmVxdWlyZWQgdG8gYmUgNC1ELCBidXQgaXMgaW5zdGVhZCAke3QucmFua30tRGApO3JldHVybiBpPVRzKGksdCxuLGE9PT1cInNhbWVcIj9cInNhbWVcIjpcInZhbGlkXCIsXCJOSFdDXCIscykscj09PVwiY2hhbm5lbHNGaXJzdFwiJiYoaT1EZShpLFswLDMsMSwyXSkpLGl9KX12YXIgTzA9Y2xhc3MgZXh0ZW5kcyBwQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcigyLGUpLHRoaXMuZGVwdGh3aXNlS2VybmVsPW51bGwsdGhpcy5kZXB0aE11bHRpcGxpZXI9ZS5kZXB0aE11bHRpcGxpZXI9PW51bGw/MTplLmRlcHRoTXVsdGlwbGllcix0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyPVN0KGUuZGVwdGh3aXNlSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpLHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludD1ZdChlLmRlcHRod2lzZUNvbnN0cmFpbnQpLHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXI9TnQoZS5kZXB0aHdpc2VSZWd1bGFyaXplcil9YnVpbGQoZSl7aWYoZT1KZShlKSxlLmxlbmd0aDw0KXRocm93IG5ldyBWKGBJbnB1dHMgdG8gRGVwdGh3aXNlQ29udjJEIHNob3VsZCBoYXZlIHJhbmsgNC4gUmVjZWl2ZWQgaW5wdXQgc2hhcGU6ICR7SlNPTi5zdHJpbmdpZnkoZSl9LmApO2xldCB0PXRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiPzE6MztpZihlW3RdPT1udWxsfHxlW3RdPDApdGhyb3cgbmV3IFYoYFRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgYmUgZGVmaW5lZCwgYnV0IGlzIG5vdCAoJHtlW3RdfSkuYCk7bGV0IG49ZVt0XSxhPVt0aGlzLmtlcm5lbFNpemVbMF0sdGhpcy5rZXJuZWxTaXplWzFdLG4sdGhpcy5kZXB0aE11bHRpcGxpZXJdO3RoaXMuZGVwdGh3aXNlS2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwiZGVwdGh3aXNlX2tlcm5lbFwiLGEsbnVsbCx0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyLHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIsITAsdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50KSx0aGlzLnVzZUJpYXM/dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFtuKnRoaXMuZGVwdGhNdWx0aXBsaWVyXSxudWxsLHRoaXMuYmlhc0luaXRpYWxpemVyLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpOnRoaXMuYmlhcz1udWxsLHRoaXMuYnVpbHQ9ITB9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57ZT1UZShlKTtsZXQgbj1iaihlLHRoaXMuZGVwdGh3aXNlS2VybmVsLnJlYWQoKSx0aGlzLnN0cmlkZXMsdGhpcy5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdCxudWxsKTtyZXR1cm4gdGhpcy51c2VCaWFzJiYobj1LYShuLHRoaXMuYmlhcy5yZWFkKCksdGhpcy5kYXRhRm9ybWF0KSksdGhpcy5hY3RpdmF0aW9uIT1udWxsJiYobj10aGlzLmFjdGl2YXRpb24uYXBwbHkobikpLG59KX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtsZXQgdD10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9lWzJdOmVbMV0sbj10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9lWzNdOmVbMl0sYT10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9lWzFdKnRoaXMuZGVwdGhNdWx0aXBsaWVyOmVbM10qdGhpcy5kZXB0aE11bHRpcGxpZXIscj1WYSh0LHRoaXMua2VybmVsU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKSxzPVZhKG4sdGhpcy5rZXJuZWxTaXplWzFdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMV0pO3JldHVybiB0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9bZVswXSxhLHIsc106W2VbMF0scixzLGFdfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpO3JldHVybiBlLmRlcHRoTXVsdGlwbGllcj10aGlzLmRlcHRoTXVsdGlwbGllcixlLmRlcHRod2lzZUluaXRpYWxpemVyPUV0KHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIpLGUuZGVwdGh3aXNlUmVndWxhcml6ZXI9ZnQodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciksZS5kZXB0aHdpc2VDb25zdHJhaW50PVh0KHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpLGV9fTtPMC5jbGFzc05hbWU9XCJEZXB0aHdpc2VDb252MkRcIjtuZS5yZWdpc3RlckNsYXNzKE8wKTtmdW5jdGlvbiBiQyhlLHQsbixhKXtpZihBcnJheS5pc0FycmF5KGUpKXtpZih0IT1udWxsfHxuIT1udWxsKXRocm93IG5ldyBWKFwiV2hlbiBpbnB1dHMgaXMgYW4gYXJyYXksIG5laXRoZXIgaW5pdGlhbFN0YXRlIG9yIGNvbnN0YW50cyBzaG91bGQgYmUgcHJvdmlkZWRcIik7YSE9bnVsbCYmKG49ZS5zbGljZShlLmxlbmd0aC1hLGUubGVuZ3RoKSxlPWUuc2xpY2UoMCxlLmxlbmd0aC1hKSksZS5sZW5ndGg+MSYmKHQ9ZS5zbGljZSgxLGUubGVuZ3RoKSksZT1lWzBdfWZ1bmN0aW9uIHIocyl7cmV0dXJuIHM9PW51bGx8fEFycmF5LmlzQXJyYXkocyk/czpbc119cmV0dXJuIHQ9cih0KSxuPXIobikse2lucHV0czplLGluaXRpYWxTdGF0ZTp0LGNvbnN0YW50czpufX1mdW5jdGlvbiB5QyhlLHQsbixhPSExLHIscyxpPSExLG89ITEpe3JldHVybiBPKCgpPT57bGV0IGw9dC5zaGFwZS5sZW5ndGg7aWYobDwzKXRocm93IG5ldyBWKGBJbnB1dCBzaG91bGQgYmUgYXQgbGVhc3QgM0QsIGJ1dCBpcyAke2x9RC5gKTtsZXQgdT1bMSwwXS5jb25jYXQoVWEoMixsKSk7aWYodD1EZSh0LHUpLHMhPW51bGwpdGhyb3cgbmV3IHplKFwiVGhlIHJubigpIGZ1bmN0b2luIG9mIHRoZSBkZWVwbGVhcm4uanMgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0IGNvbnN0YW50cyB5ZXQuXCIpO2kmJmNvbnNvbGUud2FybihcIkJhY2tlbmQgcm5uKCk6IHRoZSB1bnJvbGwgPSB0cnVlIG9wdGlvbiBpcyBub3QgYXBwbGljYWJsZSB0byB0aGUgaW1wZXJhdGl2ZSBkZWVwbGVhcm4uanMgYmFja2VuZC5cIiksciE9bnVsbCYmKHI9cmUocmUocixcImJvb2xcIiksXCJmbG9hdDMyXCIpLHIucmFuaz09PWwtMSYmKHI9R3QociwtMSkpLHI9RGUocix1KSksYSYmKHQ9YmEodCwwKSxyIT1udWxsJiYocj1iYShyLDApKSk7bGV0IHA9W10sZCxjPW4saD10LnNoYXBlWzBdLG09ZHQodCksZjtyIT1udWxsJiYoZj1kdChyKSk7Zm9yKGxldCBiPTA7YjxoOysrYil7bGV0IHk9bVtiXSx4PU8oKCk9PmUoeSxjKSk7aWYocj09bnVsbClkPXhbMF0sYz14WzFdO2Vsc2V7bGV0IHY9TygoKT0+e2xldCBJPWZbYl0sTj1wZShlYShJKSxJKSxDPVgoeih4WzBdLEkpLHooY1swXSxOKSksXz1jLm1hcCgoRixEKT0+WCh6KHhbMV1bRF0sSSkseihGLE4pKSk7cmV0dXJue291dHB1dDpDLG5ld1N0YXRlczpffX0pO2Q9di5vdXRwdXQsYz12Lm5ld1N0YXRlc31vJiZwLnB1c2goZCl9bGV0IGc7cmV0dXJuIG8mJihnPUF0KHAsMSkpLFtkLGcsY119KX12YXIgTXI9Y2xhc3MgeEMgZXh0ZW5kcyBXZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KTtsZXQgbjtpZih0LmNlbGw9PW51bGwpdGhyb3cgbmV3IFYoXCJjZWxsIHByb3BlcnR5IGlzIG1pc3NpbmcgZm9yIHRoZSBjb25zdHJ1Y3RvciBvZiBSTk4uXCIpO2lmKEFycmF5LmlzQXJyYXkodC5jZWxsKT9uPW5ldyBSZih7Y2VsbHM6dC5jZWxsfSk6bj10LmNlbGwsbi5zdGF0ZVNpemU9PW51bGwpdGhyb3cgbmV3IFYoXCJUaGUgUk5OIGNlbGwgc2hvdWxkIGhhdmUgYW4gYXR0cmlidXRlIGBzdGF0ZVNpemVgICh0dXBsZSBvZiBpbnRlZ2Vycywgb25lIGludGVnZXIgcGVyIFJOTiBzdGF0ZSkuXCIpO3RoaXMuY2VsbD1uLHRoaXMucmV0dXJuU2VxdWVuY2VzPXQucmV0dXJuU2VxdWVuY2VzPT1udWxsPyExOnQucmV0dXJuU2VxdWVuY2VzLHRoaXMucmV0dXJuU3RhdGU9dC5yZXR1cm5TdGF0ZT09bnVsbD8hMTp0LnJldHVyblN0YXRlLHRoaXMuZ29CYWNrd2FyZHM9dC5nb0JhY2t3YXJkcz09bnVsbD8hMTp0LmdvQmFja3dhcmRzLHRoaXMuX3N0YXRlZnVsPXQuc3RhdGVmdWw9PW51bGw/ITE6dC5zdGF0ZWZ1bCx0aGlzLnVucm9sbD10LnVucm9sbD09bnVsbD8hMTp0LnVucm9sbCx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjN9KV0sdGhpcy5zdGF0ZVNwZWM9bnVsbCx0aGlzLnN0YXRlc189bnVsbCx0aGlzLm51bUNvbnN0YW50cz1udWxsLHRoaXMua2VwdFN0YXRlcz1bXX1nZXRTdGF0ZXMoKXtpZih0aGlzLnN0YXRlc189PW51bGwpe2xldCB0PUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MTtyZXR1cm4gVWEoMCx0KS5tYXAobj0+bnVsbCl9ZWxzZSByZXR1cm4gdGhpcy5zdGF0ZXNffXNldFN0YXRlcyh0KXt0aGlzLnN0YXRlc189dH1jb21wdXRlT3V0cHV0U2hhcGUodCl7VngodCkmJih0PXRbMF0pLHQ9dDtsZXQgbj10aGlzLmNlbGwuc3RhdGVTaXplO0FycmF5LmlzQXJyYXkobil8fChuPVtuXSk7bGV0IGE9blswXSxyO2lmKHRoaXMucmV0dXJuU2VxdWVuY2VzP3I9W3RbMF0sdFsxXSxhXTpyPVt0WzBdLGFdLHRoaXMucmV0dXJuU3RhdGUpe2xldCBzPVtdO2ZvcihsZXQgaSBvZiBuKXMucHVzaChbdFswXSxpXSk7cmV0dXJuW3JdLmNvbmNhdChzKX1lbHNlIHJldHVybiByfWNvbXB1dGVNYXNrKHQsbil7cmV0dXJuIE8oKCk9PntBcnJheS5pc0FycmF5KG4pJiYobj1uWzBdKTtsZXQgYT10aGlzLnJldHVyblNlcXVlbmNlcz9uOm51bGw7aWYodGhpcy5yZXR1cm5TdGF0ZSl7bGV0IHI9dGhpcy5zdGF0ZXMubWFwKHM9Pm51bGwpO3JldHVyblthXS5jb25jYXQocil9ZWxzZSByZXR1cm4gYX0pfWdldCBzdGF0ZXMoKXtpZih0aGlzLnN0YXRlc189PW51bGwpe2xldCB0PUFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGg6MSxuPVtdO2ZvcihsZXQgYT0wO2E8dDsrK2Epbi5wdXNoKG51bGwpO3JldHVybiBufWVsc2UgcmV0dXJuIHRoaXMuc3RhdGVzX31zZXQgc3RhdGVzKHQpe3RoaXMuc3RhdGVzXz10fWJ1aWxkKHQpe2lmKHRoaXMubnVtQ29uc3RhbnRzIT1udWxsKXRocm93IG5ldyB6ZShcIkNvbnN0YW50cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBSTk4geWV0LlwiKTtWeCh0KSYmKHQ9dFswXSksdD10O2xldCBuPXRoaXMuc3RhdGVmdWw/dFswXTpudWxsLGE9dC5zbGljZSgyKTt0aGlzLmlucHV0U3BlY1swXT1uZXcgenQoe3NoYXBlOltuLG51bGwsLi4uYV19KTtsZXQgcj1bdFswXV0uY29uY2F0KHQuc2xpY2UoMikpO3RoaXMuY2VsbC5idWlsZChyKTtsZXQgcztpZihBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3M9dGhpcy5jZWxsLnN0YXRlU2l6ZTpzPVt0aGlzLmNlbGwuc3RhdGVTaXplXSx0aGlzLnN0YXRlU3BlYyE9bnVsbCl7aWYoIXcuYXJyYXlzRXF1YWwodGhpcy5zdGF0ZVNwZWMubWFwKGk9Pmkuc2hhcGVbaS5zaGFwZS5sZW5ndGgtMV0pLHMpKXRocm93IG5ldyBWKGBBbiBpbml0aWFsU3RhdGUgd2FzIHBhc3NlZCB0aGF0IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggY2VsbC5zdGF0ZVNpemUuIFJlY2VpdmVkIHN0YXRlU3BlYz0ke3RoaXMuc3RhdGVTcGVjfTsgSG93ZXZlciBjZWxsLnN0YXRlU2l6ZSBpcyAke3RoaXMuY2VsbC5zdGF0ZVNpemV9YCl9ZWxzZSB0aGlzLnN0YXRlU3BlYz1zLm1hcChpPT5uZXcgenQoe3NoYXBlOltudWxsLGldfSkpO3RoaXMuc3RhdGVmdWwmJnRoaXMucmVzZXRTdGF0ZXMoKX1yZXNldFN0YXRlcyh0LG49ITEpe08oKCk9PntpZighdGhpcy5zdGF0ZWZ1bCl0aHJvdyBuZXcgWHIoXCJDYW5ub3QgY2FsbCByZXNldFN0YXRlcygpIG9uIGFuIFJOTiBMYXllciB0aGF0IGlzIG5vdCBzdGF0ZWZ1bC5cIik7bGV0IGE9dGhpcy5pbnB1dFNwZWNbMF0uc2hhcGVbMF07aWYoYT09bnVsbCl0aHJvdyBuZXcgVihcIklmIGFuIFJOTiBpcyBzdGF0ZWZ1bCwgaXQgbmVlZHMgdG8ga25vdyBpdHMgYmF0Y2ggc2l6ZS4gU3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBvZiB5b3VyIGlucHV0IHRlbnNvcnM6IFxcbi0gSWYgdXNpbmcgYSBTZXF1ZW50aWFsIG1vZGVsLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5IHBhc3NpbmcgYSBgYmF0Y2hJbnB1dFNoYXBlYCBvcHRpb24gdG8geW91ciBmaXJzdCBsYXllci5cXG4tIElmIHVzaW5nIHRoZSBmdW5jdGlvbmFsIEFQSSwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSBwYXNzaW5nIGEgYGJhdGNoU2hhcGVgIG9wdGlvbiB0byB5b3VyIElucHV0IGxheWVyLlwiKTtpZih0aGlzLnN0YXRlc189PW51bGwpQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLnN0YXRlc189dGhpcy5jZWxsLnN0YXRlU2l6ZS5tYXAocj0+SXQoW2Escl0pKTp0aGlzLnN0YXRlc189W0l0KFthLHRoaXMuY2VsbC5zdGF0ZVNpemVdKV07ZWxzZSBpZih0PT1udWxsKUVlKHRoaXMuc3RhdGVzXyksdGhpcy5rZXB0U3RhdGVzIT1udWxsJiYoRWUodGhpcy5rZXB0U3RhdGVzKSx0aGlzLmtlcHRTdGF0ZXM9W10pLEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSk/dGhpcy5zdGF0ZXNfPXRoaXMuY2VsbC5zdGF0ZVNpemUubWFwKHI9Pkl0KFthLHJdKSk6dGhpcy5zdGF0ZXNfWzBdPUl0KFthLHRoaXMuY2VsbC5zdGF0ZVNpemVdKTtlbHNle2lmKEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksdC5sZW5ndGghPT10aGlzLnN0YXRlc18ubGVuZ3RoKXRocm93IG5ldyBWKGBMYXllciAke3RoaXMubmFtZX0gZXhwZWN0cyAke3RoaXMuc3RhdGVzXy5sZW5ndGh9IHN0YXRlKHMpLCBidXQgaXQgcmVjZWl2ZWQgJHt0Lmxlbmd0aH0gc3RhdGUgdmFsdWUocykuIElucHV0IHJlY2VpdmVkOiAke3R9YCk7bj09PSEwP3RoaXMua2VwdFN0YXRlcy5wdXNoKHRoaXMuc3RhdGVzXy5zbGljZSgpKTpFZSh0aGlzLnN0YXRlc18pO2ZvcihsZXQgcj0wO3I8dGhpcy5zdGF0ZXNfLmxlbmd0aDsrK3Ipe2xldCBzPXRbcl0saT1BcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemVbcl06dGhpcy5jZWxsLnN0YXRlU2l6ZSxvPVthLGldO2lmKCF3LmFycmF5c0VxdWFsKHMuc2hhcGUsbykpdGhyb3cgbmV3IFYoYFN0YXRlICR7cn0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBleHBlY3RlZCBzaGFwZT0ke299LCByZWNlaXZlZCBzaGFwZT0ke3Muc2hhcGV9YCk7dGhpcy5zdGF0ZXNfW3JdPXN9fXRoaXMuc3RhdGVzXz10aGlzLnN0YXRlc18ubWFwKHI9Pkh0KHIuY2xvbmUoKSkpfSl9YXBwbHkodCxuKXtsZXQgYT1uPT1udWxsP251bGw6bi5pbml0aWFsU3RhdGUscj1uPT1udWxsP251bGw6bi5jb25zdGFudHM7bj09bnVsbCYmKG49e30pO2xldCBzPWJDKHQsYSxyLHRoaXMubnVtQ29uc3RhbnRzKTt0PXMuaW5wdXRzLGE9cy5pbml0aWFsU3RhdGUscj1zLmNvbnN0YW50cztsZXQgaT1bXSxvPVtdO2lmKGEhPW51bGwpe24uaW5pdGlhbFN0YXRlPWEsaT1pLmNvbmNhdChhKSx0aGlzLnN0YXRlU3BlYz1bXTtmb3IobGV0IGwgb2YgYSl0aGlzLnN0YXRlU3BlYy5wdXNoKG5ldyB6dCh7c2hhcGU6bC5zaGFwZX0pKTtvPW8uY29uY2F0KHRoaXMuc3RhdGVTcGVjKX1pZihyIT1udWxsJiYobi5jb25zdGFudHM9cixpPWkuY29uY2F0KHIpLHRoaXMubnVtQ29uc3RhbnRzPXIubGVuZ3RoKSxpWzBdaW5zdGFuY2VvZiBIYSl7bGV0IGw9W3RdLmNvbmNhdChpKSx1PXRoaXMuaW5wdXRTcGVjLmNvbmNhdChvKSxwPXRoaXMuaW5wdXRTcGVjO3RoaXMuaW5wdXRTcGVjPXU7bGV0IGQ9c3VwZXIuYXBwbHkobCxuKTtyZXR1cm4gdGhpcy5pbnB1dFNwZWM9cCxkfWVsc2UgcmV0dXJuIHN1cGVyLmFwcGx5KHQsbil9Y2FsbCh0LG4pe3JldHVybiBPKCgpPT57bGV0IGE9bj09bnVsbD9udWxsOm4ubWFzayxyPW49PW51bGw/bnVsbDpuLnRyYWluaW5nLHM9bj09bnVsbD9udWxsOm4uaW5pdGlhbFN0YXRlO3Q9VGUodCkscz09bnVsbCYmKHRoaXMuc3RhdGVmdWw/cz10aGlzLnN0YXRlc186cz10aGlzLmdldEluaXRpYWxTdGF0ZSh0KSk7bGV0IGk9QXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLmNlbGwuc3RhdGVTaXplLmxlbmd0aDoxO2lmKHMubGVuZ3RoIT09aSl0aHJvdyBuZXcgVihgUk5OIExheWVyIGhhcyAke2l9IHN0YXRlKHMpIGJ1dCB3YXMgcGFzc2VkICR7cy5sZW5ndGh9IGluaXRpYWwgc3RhdGUocykuYCk7dGhpcy51bnJvbGwmJmNvbnNvbGUud2FybihcIklnbm9yaW5nIHVucm9sbCA9IHRydWUgZm9yIFJOTiBsYXllciwgZHVlIHRvIGltcGVyYXRpdmUgYmFja2VuZC5cIik7bGV0IG89e3RyYWluaW5nOnJ9LGw9eUMoKGgsbSk9PntsZXQgZj10aGlzLmNlbGwuY2FsbChbaF0uY29uY2F0KG0pLG8pO3JldHVybltmWzBdLGYuc2xpY2UoMSldfSx0LHMsdGhpcy5nb0JhY2t3YXJkcyxhLG51bGwsdGhpcy51bnJvbGwsdGhpcy5yZXR1cm5TZXF1ZW5jZXMpLHU9bFswXSxwPWxbMV0sZD1sWzJdO3RoaXMuc3RhdGVmdWwmJnRoaXMucmVzZXRTdGF0ZXMoZCxyKTtsZXQgYz10aGlzLnJldHVyblNlcXVlbmNlcz9wOnU7cmV0dXJuIHRoaXMucmV0dXJuU3RhdGU/W2NdLmNvbmNhdChkKTpjfSl9Z2V0SW5pdGlhbFN0YXRlKHQpe3JldHVybiBPKCgpPT57bGV0IG49SXQodC5zaGFwZSk7cmV0dXJuIG49ZmUobixbMSwyXSksbj13ZChuKSxBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpP3RoaXMuY2VsbC5zdGF0ZVNpemUubWFwKGE9PmE+MT9XeChuLFsxLGFdKTpuKTp0aGlzLmNlbGwuc3RhdGVTaXplPjE/W1d4KG4sWzEsdGhpcy5jZWxsLnN0YXRlU2l6ZV0pXTpbbl19KX1nZXQgdHJhaW5hYmxlV2VpZ2h0cygpe3JldHVybiB0aGlzLnRyYWluYWJsZT90aGlzLmNlbGwudHJhaW5hYmxlV2VpZ2h0czpbXX1nZXQgbm9uVHJhaW5hYmxlV2VpZ2h0cygpe3JldHVybiB0aGlzLnRyYWluYWJsZT90aGlzLmNlbGwubm9uVHJhaW5hYmxlV2VpZ2h0czp0aGlzLmNlbGwud2VpZ2h0c31zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHQpe3N1cGVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodCksdGhpcy5jZWxsIT1udWxsJiZ0aGlzLmNlbGwuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh0KX1nZXRDb25maWcoKXtsZXQgdD1zdXBlci5nZXRDb25maWcoKSxuPXtyZXR1cm5TZXF1ZW5jZXM6dGhpcy5yZXR1cm5TZXF1ZW5jZXMscmV0dXJuU3RhdGU6dGhpcy5yZXR1cm5TdGF0ZSxnb0JhY2t3YXJkczp0aGlzLmdvQmFja3dhcmRzLHN0YXRlZnVsOnRoaXMuc3RhdGVmdWwsdW5yb2xsOnRoaXMudW5yb2xsfTt0aGlzLm51bUNvbnN0YW50cyE9bnVsbCYmKG4ubnVtQ29uc3RhbnRzPXRoaXMubnVtQ29uc3RhbnRzKTtsZXQgYT10aGlzLmNlbGwuZ2V0Q29uZmlnKCk7cmV0dXJuIHRoaXMuZ2V0Q2xhc3NOYW1lKCk9PT14Qy5jbGFzc05hbWUmJihuLmNlbGw9e2NsYXNzTmFtZTp0aGlzLmNlbGwuZ2V0Q2xhc3NOYW1lKCksY29uZmlnOmF9KSxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx0KSxuKX1zdGF0aWMgZnJvbUNvbmZpZyh0LG4sYT17fSl7bGV0IHI9bi5jZWxsLHM9QmEocixhKTtyZXR1cm4gbmV3IHQoT2JqZWN0LmFzc2lnbihuLHtjZWxsOnN9KSl9fTtNci5jbGFzc05hbWU9XCJSTk5cIjtuZS5yZWdpc3RlckNsYXNzKE1yKTt2YXIgVGQ9Y2xhc3MgZXh0ZW5kcyBXZXt9LCRmPWNsYXNzIGV4dGVuZHMgVGR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5ERUZBVUxUX0FDVElWQVRJT049XCJ0YW5oXCIsdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUj1cImdsb3JvdE5vcm1hbFwiLHRoaXMuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVI9XCJvcnRob2dvbmFsXCIsdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLHRoaXMudW5pdHM9ZS51bml0cyx0bih0aGlzLnVuaXRzLFwidW5pdHNcIiksdGhpcy5hY3RpdmF0aW9uPWZzKGUuYWN0aXZhdGlvbj09bnVsbD90aGlzLkRFRkFVTFRfQUNUSVZBVElPTjplLmFjdGl2YXRpb24pLHRoaXMudXNlQmlhcz1lLnVzZUJpYXM9PW51bGw/ITA6ZS51c2VCaWFzLHRoaXMua2VybmVsSW5pdGlhbGl6ZXI9U3QoZS5rZXJuZWxJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcj1TdChlLnJlY3VycmVudEluaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKSx0aGlzLmJpYXNJbml0aWFsaXplcj1TdChlLmJpYXNJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLHRoaXMua2VybmVsUmVndWxhcml6ZXI9TnQoZS5rZXJuZWxSZWd1bGFyaXplciksdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplcj1OdChlLnJlY3VycmVudFJlZ3VsYXJpemVyKSx0aGlzLmJpYXNSZWd1bGFyaXplcj1OdChlLmJpYXNSZWd1bGFyaXplciksdGhpcy5rZXJuZWxDb25zdHJhaW50PVl0KGUua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50PVl0KGUucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy5iaWFzQ29uc3RyYWludD1ZdChlLmJpYXNDb25zdHJhaW50KSx0aGlzLmRyb3BvdXQ9VWwoWzEsaHMoWzAsZS5kcm9wb3V0PT1udWxsPzA6ZS5kcm9wb3V0XSldKSx0aGlzLnJlY3VycmVudERyb3BvdXQ9VWwoWzEsaHMoWzAsZS5yZWN1cnJlbnREcm9wb3V0PT1udWxsPzA6ZS5yZWN1cnJlbnREcm9wb3V0XSldKSx0aGlzLmRyb3BvdXRGdW5jPWUuZHJvcG91dEZ1bmMsdGhpcy5zdGF0ZVNpemU9dGhpcy51bml0cyx0aGlzLmRyb3BvdXRNYXNrPW51bGwsdGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsfWJ1aWxkKGUpe2U9SmUoZSksdGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbZVtlLmxlbmd0aC0xXSx0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLFt0aGlzLnVuaXRzLHRoaXMudW5pdHNdLG51bGwsdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcix0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCEwLHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy51c2VCaWFzP3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy51bml0c10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2lmKGU9ZSxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IFYoYFNpbXBsZVJOTkNlbGwgZXhwZWN0cyAyIGlucHV0IFRlbnNvcnMsIGdvdCAke2UubGVuZ3RofS5gKTtsZXQgbj1lWzFdO2U9ZVswXTtsZXQgYT10LnRyYWluaW5nPT1udWxsPyExOnQudHJhaW5pbmc7MDx0aGlzLmRyb3BvdXQmJnRoaXMuZHJvcG91dDwxJiZ0aGlzLmRyb3BvdXRNYXNrPT1udWxsJiYodGhpcy5kcm9wb3V0TWFzaz1ncyh7b25lczooKT0+ZWEoZSkscmF0ZTp0aGlzLmRyb3BvdXQsdHJhaW5pbmc6YSxkcm9wb3V0RnVuYzp0aGlzLmRyb3BvdXRGdW5jfSkpLDA8dGhpcy5yZWN1cnJlbnREcm9wb3V0JiZ0aGlzLnJlY3VycmVudERyb3BvdXQ8MSYmdGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaz09bnVsbCYmKHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9Z3Moe29uZXM6KCk9PmVhKG4pLHJhdGU6dGhpcy5yZWN1cnJlbnREcm9wb3V0LHRyYWluaW5nOmEsZHJvcG91dEZ1bmM6dGhpcy5kcm9wb3V0RnVuY30pKTtsZXQgcixzPXRoaXMuZHJvcG91dE1hc2ssaT10aGlzLnJlY3VycmVudERyb3BvdXRNYXNrO3MhPW51bGw/cj1vcih6KGUscyksdGhpcy5rZXJuZWwucmVhZCgpKTpyPW9yKGUsdGhpcy5rZXJuZWwucmVhZCgpKSx0aGlzLmJpYXMhPW51bGwmJihyPUthKHIsdGhpcy5iaWFzLnJlYWQoKSkpLGkhPW51bGwmJihuPXoobixpKSk7bGV0IG89WChyLG9yKG4sdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpKSk7cmV0dXJuIHRoaXMuYWN0aXZhdGlvbiE9bnVsbCYmKG89dGhpcy5hY3RpdmF0aW9uLmFwcGx5KG8pKSxbbyxvXX0pfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjptcyh0aGlzLmFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOkV0KHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOkV0KHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpFdCh0aGlzLmJpYXNJbml0aWFsaXplciksa2VybmVsUmVndWxhcml6ZXI6ZnQodGhpcy5rZXJuZWxSZWd1bGFyaXplcikscmVjdXJyZW50UmVndWxhcml6ZXI6ZnQodGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciksYmlhc1JlZ3VsYXJpemVyOmZ0KHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxhY3Rpdml0eVJlZ3VsYXJpemVyOmZ0KHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksa2VybmVsQ29uc3RyYWludDpYdCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHJlY3VycmVudENvbnN0cmFpbnQ6WHQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxiaWFzQ29uc3RyYWludDpYdCh0aGlzLmJpYXNDb25zdHJhaW50KSxkcm9wb3V0OnRoaXMuZHJvcG91dCxyZWN1cnJlbnREcm9wb3V0OnRoaXMucmVjdXJyZW50RHJvcG91dH07cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx0KX19OyRmLmNsYXNzTmFtZT1cIlNpbXBsZVJOTkNlbGxcIjtuZS5yZWdpc3RlckNsYXNzKCRmKTt2YXIgUDA9Y2xhc3MgZXh0ZW5kcyBNcntjb25zdHJ1Y3RvcihlKXtlLmNlbGw9bmV3ICRmKGUpLHN1cGVyKGUpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuY2VsbC5kcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5kcm9wb3V0TWFzayksdGhpcy5jZWxsLmRyb3BvdXRNYXNrPW51bGwpLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO2xldCBuPXQ9PW51bGw/bnVsbDp0Lm1hc2ssYT10PT1udWxsP251bGw6dC50cmFpbmluZyxyPXQ9PW51bGw/bnVsbDp0LmluaXRpYWxTdGF0ZTtyZXR1cm4gc3VwZXIuY2FsbChlLHttYXNrOm4sdHJhaW5pbmc6YSxpbml0aWFsU3RhdGU6cn0pfSl9c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gbmV3IGUodCl9fTtQMC5jbGFzc05hbWU9XCJTaW1wbGVSTk5cIjtuZS5yZWdpc3RlckNsYXNzKFAwKTt2YXIgRGY9Y2xhc3MgZXh0ZW5kcyBUZHtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIix0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT049XCJoYXJkU2lnbW9pZFwiLHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIix0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIixlLnJlc2V0QWZ0ZXIpdGhyb3cgbmV3IFYoXCJHUlVDZWxsIGRvZXMgbm90IHN1cHBvcnQgcmVzZXRfYWZ0ZXIgcGFyYW1ldGVyIHNldCB0byB0cnVlLlwiKTt0aGlzLnVuaXRzPWUudW5pdHMsdG4odGhpcy51bml0cyxcInVuaXRzXCIpLHRoaXMuYWN0aXZhdGlvbj1mcyhlLmFjdGl2YXRpb249PT12b2lkIDA/dGhpcy5ERUZBVUxUX0FDVElWQVRJT046ZS5hY3RpdmF0aW9uKSx0aGlzLnJlY3VycmVudEFjdGl2YXRpb249ZnMoZS5yZWN1cnJlbnRBY3RpdmF0aW9uPT09dm9pZCAwP3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTjplLnJlY3VycmVudEFjdGl2YXRpb24pLHRoaXMudXNlQmlhcz1lLnVzZUJpYXM9PW51bGw/ITA6ZS51c2VCaWFzLHRoaXMua2VybmVsSW5pdGlhbGl6ZXI9U3QoZS5rZXJuZWxJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcj1TdChlLnJlY3VycmVudEluaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKSx0aGlzLmJpYXNJbml0aWFsaXplcj1TdChlLmJpYXNJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLHRoaXMua2VybmVsUmVndWxhcml6ZXI9TnQoZS5rZXJuZWxSZWd1bGFyaXplciksdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplcj1OdChlLnJlY3VycmVudFJlZ3VsYXJpemVyKSx0aGlzLmJpYXNSZWd1bGFyaXplcj1OdChlLmJpYXNSZWd1bGFyaXplciksdGhpcy5rZXJuZWxDb25zdHJhaW50PVl0KGUua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50PVl0KGUucmVjdXJyZW50Q29uc3RyYWludCksdGhpcy5iaWFzQ29uc3RyYWludD1ZdChlLmJpYXNDb25zdHJhaW50KSx0aGlzLmRyb3BvdXQ9VWwoWzEsaHMoWzAsZS5kcm9wb3V0PT1udWxsPzA6ZS5kcm9wb3V0XSldKSx0aGlzLnJlY3VycmVudERyb3BvdXQ9VWwoWzEsaHMoWzAsZS5yZWN1cnJlbnREcm9wb3V0PT1udWxsPzA6ZS5yZWN1cnJlbnREcm9wb3V0XSldKSx0aGlzLmRyb3BvdXRGdW5jPWUuZHJvcG91dEZ1bmMsdGhpcy5pbXBsZW1lbnRhdGlvbj1lLmltcGxlbWVudGF0aW9uLHRoaXMuc3RhdGVTaXplPXRoaXMudW5pdHMsdGhpcy5kcm9wb3V0TWFzaz1udWxsLHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9bnVsbH1idWlsZChlKXtlPUplKGUpO2xldCB0PWVbZS5sZW5ndGgtMV07dGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbdCx0aGlzLnVuaXRzKjNdLG51bGwsdGhpcy5rZXJuZWxJbml0aWFsaXplcix0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCEwLHRoaXMua2VybmVsQ29uc3RyYWludCksdGhpcy5yZWN1cnJlbnRLZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJyZWN1cnJlbnRfa2VybmVsXCIsW3RoaXMudW5pdHMsdGhpcy51bml0cyozXSxudWxsLHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIsdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwhMCx0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcz90aGlzLmJpYXM9dGhpcy5hZGRXZWlnaHQoXCJiaWFzXCIsW3RoaXMudW5pdHMqM10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KTp0aGlzLmJpYXM9bnVsbCx0aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2lmKGU9ZSxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IFYoYEdSVUNlbGwgZXhwZWN0cyAyIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCAke2UubGVuZ3RofS5gKTtsZXQgbj10LnRyYWluaW5nPT1udWxsPyExOnQudHJhaW5pbmcsYT1lWzFdO2U9ZVswXSwwPHRoaXMuZHJvcG91dCYmdGhpcy5kcm9wb3V0PDEmJnRoaXMuZHJvcG91dE1hc2s9PW51bGwmJih0aGlzLmRyb3BvdXRNYXNrPWdzKHtvbmVzOigpPT5lYShlKSxyYXRlOnRoaXMuZHJvcG91dCx0cmFpbmluZzpuLGNvdW50OjMsZHJvcG91dEZ1bmM6dGhpcy5kcm9wb3V0RnVuY30pKSwwPHRoaXMucmVjdXJyZW50RHJvcG91dCYmdGhpcy5yZWN1cnJlbnREcm9wb3V0PDEmJnRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9PW51bGwmJih0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrPWdzKHtvbmVzOigpPT5lYShhKSxyYXRlOnRoaXMucmVjdXJyZW50RHJvcG91dCx0cmFpbmluZzpuLGNvdW50OjMsZHJvcG91dEZ1bmM6dGhpcy5kcm9wb3V0RnVuY30pKTtsZXQgcj10aGlzLmRyb3BvdXRNYXNrLHM9dGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzayxpLG8sbDswPHRoaXMuZHJvcG91dCYmdGhpcy5kcm9wb3V0PDEmJihlPXooZSxyWzBdKSk7bGV0IHU9b3IoZSx0aGlzLmtlcm5lbC5yZWFkKCkpO3RoaXMudXNlQmlhcyYmKHU9S2EodSx0aGlzLmJpYXMucmVhZCgpKSksMDx0aGlzLnJlY3VycmVudERyb3BvdXQmJnRoaXMucmVjdXJyZW50RHJvcG91dDwxJiYoYT16KGEsc1swXSkpO2xldCBwPXRoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSxbZCxjXT1MbihwLFsyKnRoaXMudW5pdHMsdGhpcy51bml0c10scC5yYW5rLTEpLGg9b3IoYSxkKSxbbSxmLGddPUxuKHUsMyx1LnJhbmstMSksW2IseV09TG4oaCwyLGgucmFuay0xKTtpPXRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShYKG0sYikpLG89dGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KFgoZix5KSk7bGV0IHg9b3IoeihvLGEpLGMpO2w9dGhpcy5hY3RpdmF0aW9uLmFwcGx5KFgoZyx4KSk7bGV0IHY9WCh6KGksYSkseihYKDEseXQoaSkpLGwpKTtyZXR1cm5bdix2XX0pfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9e3VuaXRzOnRoaXMudW5pdHMsYWN0aXZhdGlvbjptcyh0aGlzLmFjdGl2YXRpb24pLHJlY3VycmVudEFjdGl2YXRpb246bXModGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSx1c2VCaWFzOnRoaXMudXNlQmlhcyxrZXJuZWxJbml0aWFsaXplcjpFdCh0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxyZWN1cnJlbnRJbml0aWFsaXplcjpFdCh0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxiaWFzSW5pdGlhbGl6ZXI6RXQodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLGtlcm5lbFJlZ3VsYXJpemVyOmZ0KHRoaXMua2VybmVsUmVndWxhcml6ZXIpLHJlY3VycmVudFJlZ3VsYXJpemVyOmZ0KHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLGJpYXNSZWd1bGFyaXplcjpmdCh0aGlzLmJpYXNSZWd1bGFyaXplciksYWN0aXZpdHlSZWd1bGFyaXplcjpmdCh0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLGtlcm5lbENvbnN0cmFpbnQ6WHQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxyZWN1cnJlbnRDb25zdHJhaW50Olh0KHRoaXMucmVjdXJyZW50Q29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6WHQodGhpcy5iaWFzQ29uc3RyYWludCksZHJvcG91dDp0aGlzLmRyb3BvdXQscmVjdXJyZW50RHJvcG91dDp0aGlzLnJlY3VycmVudERyb3BvdXQsaW1wbGVtZW50YXRpb246dGhpcy5pbXBsZW1lbnRhdGlvbixyZXNldEFmdGVyOiExfTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHQpfX07RGYuY2xhc3NOYW1lPVwiR1JVQ2VsbFwiO25lLnJlZ2lzdGVyQ2xhc3MoRGYpO3ZhciBMMD1jbGFzcyBleHRlbmRzIE1ye2NvbnN0cnVjdG9yKGUpe2UuaW1wbGVtZW50YXRpb249PT0wJiZjb25zb2xlLndhcm4oXCJgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byBgaW1wbGVtZW50YXRpb249MWAuIFBsZWFzZSB1cGRhdGUgeW91ciBsYXllciBjYWxsLlwiKSxlLmNlbGw9bmV3IERmKGUpLHN1cGVyKGUpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuY2VsbC5kcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5kcm9wb3V0TWFzayksdGhpcy5jZWxsLmRyb3BvdXRNYXNrPW51bGwpLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO2xldCBuPXQ9PW51bGw/bnVsbDp0Lm1hc2ssYT10PT1udWxsP251bGw6dC50cmFpbmluZyxyPXQ9PW51bGw/bnVsbDp0LmluaXRpYWxTdGF0ZTtyZXR1cm4gc3VwZXIuY2FsbChlLHttYXNrOm4sdHJhaW5pbmc6YSxpbml0aWFsU3RhdGU6cn0pfSl9c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gdC5pbXBsbWVudGF0aW9uPT09MCYmKHQuaW1wbGVtZW50YXRpb249MSksbmV3IGUodCl9fTtMMC5jbGFzc05hbWU9XCJHUlVcIjtuZS5yZWdpc3RlckNsYXNzKEwwKTt2YXIgQ2Q9Y2xhc3MgZXh0ZW5kcyBUZHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLkRFRkFVTFRfQUNUSVZBVElPTj1cInRhbmhcIix0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT049XCJoYXJkU2lnbW9pZFwiLHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI9XCJnbG9yb3ROb3JtYWxcIix0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSPVwib3J0aG9nb25hbFwiLHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSPVwiemVyb3NcIix0aGlzLnVuaXRzPWUudW5pdHMsdG4odGhpcy51bml0cyxcInVuaXRzXCIpLHRoaXMuYWN0aXZhdGlvbj1mcyhlLmFjdGl2YXRpb249PT12b2lkIDA/dGhpcy5ERUZBVUxUX0FDVElWQVRJT046ZS5hY3RpdmF0aW9uKSx0aGlzLnJlY3VycmVudEFjdGl2YXRpb249ZnMoZS5yZWN1cnJlbnRBY3RpdmF0aW9uPT09dm9pZCAwP3RoaXMuREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTjplLnJlY3VycmVudEFjdGl2YXRpb24pLHRoaXMudXNlQmlhcz1lLnVzZUJpYXM9PW51bGw/ITA6ZS51c2VCaWFzLHRoaXMua2VybmVsSW5pdGlhbGl6ZXI9U3QoZS5rZXJuZWxJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcj1TdChlLnJlY3VycmVudEluaXRpYWxpemVyfHx0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKSx0aGlzLmJpYXNJbml0aWFsaXplcj1TdChlLmJpYXNJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpLHRoaXMudW5pdEZvcmdldEJpYXM9ZS51bml0Rm9yZ2V0Qmlhcyx0aGlzLmtlcm5lbFJlZ3VsYXJpemVyPU50KGUua2VybmVsUmVndWxhcml6ZXIpLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXI9TnQoZS5yZWN1cnJlbnRSZWd1bGFyaXplciksdGhpcy5iaWFzUmVndWxhcml6ZXI9TnQoZS5iaWFzUmVndWxhcml6ZXIpLHRoaXMua2VybmVsQ29uc3RyYWludD1ZdChlLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMucmVjdXJyZW50Q29uc3RyYWludD1ZdChlLnJlY3VycmVudENvbnN0cmFpbnQpLHRoaXMuYmlhc0NvbnN0cmFpbnQ9WXQoZS5iaWFzQ29uc3RyYWludCksdGhpcy5kcm9wb3V0PVVsKFsxLGhzKFswLGUuZHJvcG91dD09bnVsbD8wOmUuZHJvcG91dF0pXSksdGhpcy5yZWN1cnJlbnREcm9wb3V0PVVsKFsxLGhzKFswLGUucmVjdXJyZW50RHJvcG91dD09bnVsbD8wOmUucmVjdXJyZW50RHJvcG91dF0pXSksdGhpcy5kcm9wb3V0RnVuYz1lLmRyb3BvdXRGdW5jLHRoaXMuaW1wbGVtZW50YXRpb249ZS5pbXBsZW1lbnRhdGlvbix0aGlzLnN0YXRlU2l6ZT1bdGhpcy51bml0cyx0aGlzLnVuaXRzXSx0aGlzLmRyb3BvdXRNYXNrPW51bGwsdGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaz1udWxsfWJ1aWxkKGUpe3ZhciB0O2U9SmUoZSk7bGV0IG49ZVtlLmxlbmd0aC0xXTt0aGlzLmtlcm5lbD10aGlzLmFkZFdlaWdodChcImtlcm5lbFwiLFtuLHRoaXMudW5pdHMqNF0sbnVsbCx0aGlzLmtlcm5lbEluaXRpYWxpemVyLHRoaXMua2VybmVsUmVndWxhcml6ZXIsITAsdGhpcy5rZXJuZWxDb25zdHJhaW50KSx0aGlzLnJlY3VycmVudEtlcm5lbD10aGlzLmFkZFdlaWdodChcInJlY3VycmVudF9rZXJuZWxcIixbdGhpcy51bml0cyx0aGlzLnVuaXRzKjRdLG51bGwsdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplcix0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCEwLHRoaXMucmVjdXJyZW50Q29uc3RyYWludCk7bGV0IGE7aWYodGhpcy51c2VCaWFzKXtpZih0aGlzLnVuaXRGb3JnZXRCaWFzKXtsZXQgcj10aGlzLmJpYXNJbml0aWFsaXplcixzPXRoaXMudW5pdHM7YT1uZXcodD1jbGFzcyBleHRlbmRzICRhe2FwcGx5KGksbyl7bGV0IGw9ci5hcHBseShbc10pLHU9bmV3IHlmKCkuYXBwbHkoW3NdKSxwPXIuYXBwbHkoW3MqMl0pO3JldHVybiBiSShiSShsLHUpLHApfX0sdC5jbGFzc05hbWU9XCJDdXN0b21Jbml0XCIsdCl9ZWxzZSBhPXRoaXMuYmlhc0luaXRpYWxpemVyO3RoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy51bml0cyo0XSxudWxsLGEsdGhpcy5iaWFzUmVndWxhcml6ZXIsITAsdGhpcy5iaWFzQ29uc3RyYWludCl9ZWxzZSB0aGlzLmJpYXM9bnVsbDt0aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPXQudHJhaW5pbmc9PW51bGw/ITE6dC50cmFpbmluZztpZihlPWUsZS5sZW5ndGghPT0zKXRocm93IG5ldyBWKGBMU1RNQ2VsbCBleHBlY3RzIDMgaW5wdXQgVGVuc29ycyAoaW5wdXRzLCBoLCBjKSwgZ290ICR7ZS5sZW5ndGh9LmApO2xldCBhPWVbMV0scj1lWzJdO2U9ZVswXSwwPHRoaXMuZHJvcG91dCYmdGhpcy5kcm9wb3V0PDEmJnRoaXMuZHJvcG91dE1hc2s9PW51bGwmJih0aGlzLmRyb3BvdXRNYXNrPWdzKHtvbmVzOigpPT5lYShlKSxyYXRlOnRoaXMuZHJvcG91dCx0cmFpbmluZzpuLGNvdW50OjQsZHJvcG91dEZ1bmM6dGhpcy5kcm9wb3V0RnVuY30pKSwwPHRoaXMucmVjdXJyZW50RHJvcG91dCYmdGhpcy5yZWN1cnJlbnREcm9wb3V0PDEmJnRoaXMucmVjdXJyZW50RHJvcG91dE1hc2s9PW51bGwmJih0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrPWdzKHtvbmVzOigpPT5lYShhKSxyYXRlOnRoaXMucmVjdXJyZW50RHJvcG91dCx0cmFpbmluZzpuLGNvdW50OjQsZHJvcG91dEZ1bmM6dGhpcy5kcm9wb3V0RnVuY30pKTtsZXQgcz10aGlzLmRyb3BvdXRNYXNrLGk9dGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzayxvLGwsdSxwOzA8dGhpcy5kcm9wb3V0JiZ0aGlzLmRyb3BvdXQ8MSYmKGU9eihlLHNbMF0pKTtsZXQgZD1vcihlLHRoaXMua2VybmVsLnJlYWQoKSk7MDx0aGlzLnJlY3VycmVudERyb3BvdXQmJnRoaXMucmVjdXJyZW50RHJvcG91dDwxJiYoYT16KGEsaVswXSkpLGQ9WChkLG9yKGEsdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpKSksdGhpcy51c2VCaWFzJiYoZD1LYShkLHRoaXMuYmlhcy5yZWFkKCkpKTtsZXRbYyxoLG0sZl09TG4oZCw0LGQucmFuay0xKTtvPXRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShjKSxsPXRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShoKSx1PVgoeihsLHIpLHoobyx0aGlzLmFjdGl2YXRpb24uYXBwbHkobSkpKSxwPXRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseShmKTtsZXQgZz16KHAsdGhpcy5hY3RpdmF0aW9uLmFwcGx5KHUpKTtyZXR1cm5bZyxnLHVdfSl9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCksdD17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOm1zKHRoaXMuYWN0aXZhdGlvbikscmVjdXJyZW50QWN0aXZhdGlvbjptcyh0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLHVzZUJpYXM6dGhpcy51c2VCaWFzLGtlcm5lbEluaXRpYWxpemVyOkV0KHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLHJlY3VycmVudEluaXRpYWxpemVyOkV0KHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLGJpYXNJbml0aWFsaXplcjpFdCh0aGlzLmJpYXNJbml0aWFsaXplciksdW5pdEZvcmdldEJpYXM6dGhpcy51bml0Rm9yZ2V0QmlhcyxrZXJuZWxSZWd1bGFyaXplcjpmdCh0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxyZWN1cnJlbnRSZWd1bGFyaXplcjpmdCh0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6ZnQodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6ZnQodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50Olh0KHRoaXMua2VybmVsQ29uc3RyYWludCkscmVjdXJyZW50Q29uc3RyYWludDpYdCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLGJpYXNDb25zdHJhaW50Olh0KHRoaXMuYmlhc0NvbnN0cmFpbnQpLGRyb3BvdXQ6dGhpcy5kcm9wb3V0LHJlY3VycmVudERyb3BvdXQ6dGhpcy5yZWN1cnJlbnREcm9wb3V0LGltcGxlbWVudGF0aW9uOnRoaXMuaW1wbGVtZW50YXRpb259O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSksdCl9fTtDZC5jbGFzc05hbWU9XCJMU1RNQ2VsbFwiO25lLnJlZ2lzdGVyQ2xhc3MoQ2QpO3ZhciB6MD1jbGFzcyBleHRlbmRzIE1ye2NvbnN0cnVjdG9yKGUpe2UuaW1wbGVtZW50YXRpb249PT0wJiZjb25zb2xlLndhcm4oXCJgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byBgaW1wbGVtZW50YXRpb249MWAuIFBsZWFzZSB1cGRhdGUgeW91ciBsYXllciBjYWxsLlwiKSxlLmNlbGw9bmV3IENkKGUpLHN1cGVyKGUpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuY2VsbC5kcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5kcm9wb3V0TWFzayksdGhpcy5jZWxsLmRyb3BvdXRNYXNrPW51bGwpLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpO2xldCBuPXQ9PW51bGw/bnVsbDp0Lm1hc2ssYT10PT1udWxsP251bGw6dC50cmFpbmluZyxyPXQ9PW51bGw/bnVsbDp0LmluaXRpYWxTdGF0ZTtyZXR1cm4gc3VwZXIuY2FsbChlLHttYXNrOm4sdHJhaW5pbmc6YSxpbml0aWFsU3RhdGU6cn0pfSl9c3RhdGljIGZyb21Db25maWcoZSx0KXtyZXR1cm4gdC5pbXBsbWVudGF0aW9uPT09MCYmKHQuaW1wbGVtZW50YXRpb249MSksbmV3IGUodCl9fTt6MC5jbGFzc05hbWU9XCJMU1RNXCI7bmUucmVnaXN0ZXJDbGFzcyh6MCk7dmFyIFJmPWNsYXNzIGV4dGVuZHMgVGR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5jZWxscz1lLmNlbGxzfWdldCBzdGF0ZVNpemUoKXtsZXQgZT1bXTtmb3IobGV0IHQgb2YgdGhpcy5jZWxscy5zbGljZSgpLnJldmVyc2UoKSlBcnJheS5pc0FycmF5KHQuc3RhdGVTaXplKT9lLnB1c2goLi4udC5zdGF0ZVNpemUpOmUucHVzaCh0LnN0YXRlU2l6ZSk7cmV0dXJuIGV9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57ZT1lO2xldCBuPWUuc2xpY2UoMSksYT1bXTtmb3IobGV0IGkgb2YgdGhpcy5jZWxscy5zbGljZSgpLnJldmVyc2UoKSlBcnJheS5pc0FycmF5KGkuc3RhdGVTaXplKT9hLnB1c2gobi5zcGxpY2UoMCxpLnN0YXRlU2l6ZS5sZW5ndGgpKTphLnB1c2gobi5zcGxpY2UoMCwxKSk7YS5yZXZlcnNlKCk7bGV0IHI9W10scztmb3IobGV0IGk9MDtpPHRoaXMuY2VsbHMubGVuZ3RoOysraSl7bGV0IG89dGhpcy5jZWxsc1tpXTtuPWFbaV0saT09PTA/cz1bZVswXV0uY29uY2F0KG4pOnM9W3NbMF1dLmNvbmNhdChuKSxzPW8uY2FsbChzLHQpLHIucHVzaChzLnNsaWNlKDEpKX1uPVtdO2ZvcihsZXQgaSBvZiByLnNsaWNlKCkucmV2ZXJzZSgpKW4ucHVzaCguLi5pKTtyZXR1cm5bc1swXV0uY29uY2F0KG4pfSl9YnVpbGQoZSl7VngoZSkmJihlPWVbMF0pLGU9ZTtsZXQgdDt0aGlzLmNlbGxzLmZvckVhY2goKG4sYSk9PntyaShgUk5OQ2VsbF8ke2F9YCwoKT0+e24uYnVpbGQoZSksQXJyYXkuaXNBcnJheShuLnN0YXRlU2l6ZSk/dD1uLnN0YXRlU2l6ZVswXTp0PW4uc3RhdGVTaXplLGU9W2VbMF0sdF19KX0pLHRoaXMuYnVpbHQ9ITB9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCksdD1hPT4oe2NsYXNzTmFtZTphLmdldENsYXNzTmFtZSgpLGNvbmZpZzphLmdldENvbmZpZygpfSksbj17Y2VsbHM6dGhpcy5jZWxscy5tYXAodCl9O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSksbil9c3RhdGljIGZyb21Db25maWcoZSx0LG49e30pe2xldCBhPVtdO2ZvcihsZXQgciBvZiB0LmNlbGxzKWEucHVzaChCYShyLG4pKTtyZXR1cm4gbmV3IGUoe2NlbGxzOmF9KX1nZXQgdHJhaW5hYmxlV2VpZ2h0cygpe2lmKCF0aGlzLnRyYWluYWJsZSlyZXR1cm5bXTtsZXQgZT1bXTtmb3IobGV0IHQgb2YgdGhpcy5jZWxscyllLnB1c2goLi4udC50cmFpbmFibGVXZWlnaHRzKTtyZXR1cm4gZX1nZXQgbm9uVHJhaW5hYmxlV2VpZ2h0cygpe2xldCBlPVtdO2ZvcihsZXQgdCBvZiB0aGlzLmNlbGxzKWUucHVzaCguLi50Lm5vblRyYWluYWJsZVdlaWdodHMpO2lmKCF0aGlzLnRyYWluYWJsZSl7bGV0IHQ9W107Zm9yKGxldCBuIG9mIHRoaXMuY2VsbHMpdC5wdXNoKC4uLm4udHJhaW5hYmxlV2VpZ2h0cyk7cmV0dXJuIHQuY29uY2F0KGUpfXJldHVybiBlfWdldFdlaWdodHMoKXtsZXQgZT1bXTtmb3IobGV0IHQgb2YgdGhpcy5jZWxscyllLnB1c2goLi4udC53ZWlnaHRzKTtyZXR1cm4gVXgoZSl9c2V0V2VpZ2h0cyhlKXtsZXQgdD1bXTtmb3IobGV0IG4gb2YgdGhpcy5jZWxscyl7bGV0IGE9bi53ZWlnaHRzLmxlbmd0aCxyPWUuc3BsaWNlKGEpO2ZvcihsZXQgcz0wO3M8bi53ZWlnaHRzLmxlbmd0aDsrK3MpdC5wdXNoKFtuLndlaWdodHNbc10scltzXV0pfXUwKHQpfX07UmYuY2xhc3NOYW1lPVwiU3RhY2tlZFJOTkNlbGxzXCI7bmUucmVnaXN0ZXJDbGFzcyhSZik7ZnVuY3Rpb24gZ3MoZSl7bGV0e29uZXM6dCxyYXRlOm4sdHJhaW5pbmc6YT0hMSxjb3VudDpyPTEsZHJvcG91dEZ1bmM6c309ZSxpPSgpPT5zIT1udWxsP3ModCgpLG4pOncyKHQoKSxuKSxvPSgpPT5JZChpLHQsYSk7cmV0dXJuIXJ8fHI8PTE/SHQobygpLmNsb25lKCkpOkFycmF5KHIpLmZpbGwodm9pZCAwKS5tYXAobykubWFwKGw9Pkh0KGwuY2xvbmUoKSkpfXZhciB5aj1mdW5jdGlvbihlLHQpe3ZhciBuPXt9O2Zvcih2YXIgYSBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGEpJiZ0LmluZGV4T2YoYSk8MCYmKG5bYV09ZVthXSk7aWYoZSE9bnVsbCYmdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM9PVwiZnVuY3Rpb25cIilmb3IodmFyIHI9MCxhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7cjxhLmxlbmd0aDtyKyspdC5pbmRleE9mKGFbcl0pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLGFbcl0pJiYoblthW3JdXT1lW2Fbcl1dKTtyZXR1cm4gbn0sdkM9Y2xhc3MgZXh0ZW5kcyBNcntjb25zdHJ1Y3RvcihlKXtpZihlLnVucm9sbCl0aHJvdyBuZXcgemUoXCJVbnJvbGxpbmcgaXMgbm90IHBvc3NpYmxlIHdpdGggY29udm9sdXRpb25hbCBSTk5zLlwiKTtpZihBcnJheS5pc0FycmF5KGUuY2VsbCkpdGhyb3cgbmV3IHplKFwiSXQgaXMgbm90IHBvc3NpYmxlIGF0IHRoZSBtb21lbnQgdG8gc3RhY2sgY29udm9sdXRpb25hbCBjZWxscy5cIik7c3VwZXIoZSksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTo1fSldfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2lmKHRoaXMuY2VsbC5kcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5kcm9wb3V0TWFzayksdGhpcy5jZWxsLmRyb3BvdXRNYXNrPW51bGwpLHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayE9bnVsbCYmKEVlKHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayksdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrPW51bGwpLHQmJnQuY29uc3RhbnRzKXRocm93IG5ldyBWKFwiQ29udlJOTjJEIGNlbGwgZG9lcyBub3Qgc3VwcG9ydCBjb25zdGFudHNcIik7bGV0IG49dD09bnVsbD9udWxsOnQubWFzayxhPXQ9PW51bGw/bnVsbDp0LnRyYWluaW5nLHI9dD09bnVsbD9udWxsOnQuaW5pdGlhbFN0YXRlO3JldHVybiBzdXBlci5jYWxsKGUse21hc2s6bix0cmFpbmluZzphLGluaXRpYWxTdGF0ZTpyfSl9KX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7bGV0IHQ9dGhpcy5jb21wdXRlU2luZ2xlT3V0cHV0U2hhcGUoZSk7cmV0dXJuIHRoaXMucmV0dXJuU2VxdWVuY2VzfHwodD1bdFswXSwuLi50LnNsaWNlKDIpXSksdGhpcy5yZXR1cm5TdGF0ZSYmKHQ9W3QsLi4uQXJyYXkoMikuZmlsbChbZVswXSwuLi50LnNsaWNlKC0zKV0pXSksdH1nZXRJbml0aWFsU3RhdGUoZSl7cmV0dXJuIE8oKCk9PntsZXR7c3RhdGVTaXplOnR9PXRoaXMuY2VsbCxuPWUuc2hhcGUsYT10aGlzLmNvbXB1dGVTaW5nbGVPdXRwdXRTaGFwZShuKSxyPVthWzBdLC4uLmEuc2xpY2UoMildLHM9SXQocik7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/QXJyYXkodC5sZW5ndGgpLmZpbGwocyk6W3NdfSl9cmVzZXRTdGF0ZXMoZSx0PSExKXtPKCgpPT57aWYoIXRoaXMuc3RhdGVmdWwpdGhyb3cgbmV3IFhyKFwiQ2Fubm90IGNhbGwgcmVzZXRTdGF0ZXMoKSBvbiBhbiBSTk4gTGF5ZXIgdGhhdCBpcyBub3Qgc3RhdGVmdWwuXCIpO2xldCBuPXRoaXMuaW5wdXRTcGVjWzBdLnNoYXBlLGE9dGhpcy5jb21wdXRlU2luZ2xlT3V0cHV0U2hhcGUobikscj1bYVswXSwuLi5hLnNsaWNlKDIpXTtpZihuWzBdPT1udWxsKXRocm93IG5ldyBWKFwiSWYgYW4gUk5OIGlzIHN0YXRlZnVsLCBpdCBuZWVkcyB0byBrbm93IGl0cyBiYXRjaCBzaXplLiBTcGVjaWZ5IHRoZSBiYXRjaCBzaXplIG9mIHlvdXIgaW5wdXQgdGVuc29yczogXFxuLSBJZiB1c2luZyBhIFNlcXVlbnRpYWwgbW9kZWwsIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgcGFzc2luZyBhIGBiYXRjaElucHV0U2hhcGVgIG9wdGlvbiB0byB5b3VyIGZpcnN0IGxheWVyLlxcbi0gSWYgdXNpbmcgdGhlIGZ1bmN0aW9uYWwgQVBJLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5IHBhc3NpbmcgYSBgYmF0Y2hTaGFwZWAgb3B0aW9uIHRvIHlvdXIgSW5wdXQgbGF5ZXIuXCIpO2lmKHRoaXMuZ2V0U3RhdGVzKCk9PW51bGwpQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLnN0YXRlc189dGhpcy5jZWxsLnN0YXRlU2l6ZS5tYXAoKCk9Pkl0KHIpKTp0aGlzLnN0YXRlc189W0l0KHIpXTtlbHNlIGlmKGU9PW51bGwpRWUodGhpcy5zdGF0ZXNfKSx0aGlzLmtlcHRTdGF0ZXMhPW51bGwmJihFZSh0aGlzLmtlcHRTdGF0ZXMpLHRoaXMua2VwdFN0YXRlcz1bXSksQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKT90aGlzLnN0YXRlc189dGhpcy5jZWxsLnN0YXRlU2l6ZS5tYXAoKCk9Pkl0KHIpKTp0aGlzLnN0YXRlc19bMF09SXQocik7ZWxzZXtpZihBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLGUubGVuZ3RoIT09dGhpcy5zdGF0ZXNfLmxlbmd0aCl0aHJvdyBuZXcgVihgTGF5ZXIgJHt0aGlzLm5hbWV9IGV4cGVjdHMgJHt0aGlzLnN0YXRlc18ubGVuZ3RofSBzdGF0ZShzKSwgYnV0IGl0IHJlY2VpdmVkICR7ZS5sZW5ndGh9IHN0YXRlIHZhbHVlKHMpLiBJbnB1dCByZWNlaXZlZDogJHtlfWApO3Q/dGhpcy5rZXB0U3RhdGVzLnB1c2godGhpcy5zdGF0ZXNfLnNsaWNlKCkpOkVlKHRoaXMuc3RhdGVzXyk7Zm9yKGxldCBzPTA7czx0aGlzLnN0YXRlc18ubGVuZ3RoOysrcyl7bGV0IGk9ZVtzXSxvPXI7aWYoIXcuYXJyYXlzRXF1YWwoaS5zaGFwZSxvKSl0aHJvdyBuZXcgVihgU3RhdGUgJHtzfSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX06IGV4cGVjdGVkIHNoYXBlPSR7b30sIHJlY2VpdmVkIHNoYXBlPSR7aS5zaGFwZX1gKTt0aGlzLnN0YXRlc19bc109aX19dGhpcy5zdGF0ZXNfPXRoaXMuc3RhdGVzXy5tYXAocz0+SHQocy5jbG9uZSgpKSl9KX1jb21wdXRlU2luZ2xlT3V0cHV0U2hhcGUoZSl7bGV0e2RhdGFGb3JtYXQ6dCxmaWx0ZXJzOm4sa2VybmVsU2l6ZTphLHBhZGRpbmc6cixzdHJpZGVzOnMsZGlsYXRpb25SYXRlOml9PXRoaXMuY2VsbCxvPXQ9PT1cImNoYW5uZWxzRmlyc3RcIixsPWVbbz8zOjJdLHU9ZVtvPzQ6M10scD1WYShsLGFbMF0scixzWzBdLGlbMF0pLGQ9VmEodSxhWzFdLHIsc1sxXSxpWzFdKTtyZXR1cm5bLi4uZS5zbGljZSgwLDIpLC4uLm8/W24scCxkXTpbcCxkLG5dXX19O3ZDLmNsYXNzTmFtZT1cIkNvbnZSTk4yRFwiO3ZhciBNZj1jbGFzcyBleHRlbmRzIENke2NvbnN0cnVjdG9yKGUpe2xldHtmaWx0ZXJzOnQsa2VybmVsU2l6ZTpuLHN0cmlkZXM6YSxwYWRkaW5nOnIsZGF0YUZvcm1hdDpzLGRpbGF0aW9uUmF0ZTppfT1lO3N1cGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7dW5pdHM6dH0pKSx0aGlzLmZpbHRlcnM9dCx0bih0aGlzLmZpbHRlcnMsXCJmaWx0ZXJzXCIpLHRoaXMua2VybmVsU2l6ZT1GbChuLDIsXCJrZXJuZWxTaXplXCIpLHRoaXMua2VybmVsU2l6ZS5mb3JFYWNoKG89PnRuKG8sXCJrZXJuZWxTaXplXCIpKSx0aGlzLnN0cmlkZXM9RmwoYXx8MSwyLFwic3RyaWRlc1wiKSx0aGlzLnN0cmlkZXMuZm9yRWFjaChvPT50bihvLFwic3RyaWRlc1wiKSksdGhpcy5wYWRkaW5nPXJ8fFwidmFsaWRcIix2YSh0aGlzLnBhZGRpbmcpLHRoaXMuZGF0YUZvcm1hdD1zfHxcImNoYW5uZWxzTGFzdFwiLFJ0KHRoaXMuZGF0YUZvcm1hdCksdGhpcy5kaWxhdGlvblJhdGU9RmwoaXx8MSwyLFwiZGlsYXRpb25SYXRlXCIpLHRoaXMuZGlsYXRpb25SYXRlLmZvckVhY2gobz0+dG4obyxcImRpbGF0aW9uUmF0ZVwiKSl9YnVpbGQoZSl7dmFyIHQ7ZT1KZShlKTtsZXQgbj10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj8xOmUubGVuZ3RoLTE7aWYoZVtuXT09bnVsbCl0aHJvdyBuZXcgVihgVGhlIGNoYW5uZWwgZGltZW5zaW9uIG9mIHRoZSBpbnB1dCBzaG91bGQgYmUgZGVmaW5lZC4gRm91bmQgJHtlW25dfWApO2xldCBhPWVbbl0scj00LHM9dGhpcy5rZXJuZWxTaXplLmNvbmNhdChbYSx0aGlzLmZpbHRlcnMqcl0pO3RoaXMua2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwia2VybmVsXCIscyxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpO2xldCBpPXRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycyx0aGlzLmZpbHRlcnMqcl0pO2lmKHRoaXMucmVjdXJyZW50S2VybmVsPXRoaXMuYWRkV2VpZ2h0KFwicmVjdXJyZW50X2tlcm5lbFwiLGksbnVsbCx0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIsITAsdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSx0aGlzLnVzZUJpYXMpe2xldCBvO2lmKHRoaXMudW5pdEZvcmdldEJpYXMpe2xldCBsPXRoaXMuYmlhc0luaXRpYWxpemVyLHU9dGhpcy5maWx0ZXJzO289bmV3KHQ9Y2xhc3MgZXh0ZW5kcyAkYXthcHBseShwLGQpe2xldCBjPWwuYXBwbHkoW3VdKSxoPVBuKFt1XSksbT1sLmFwcGx5KFt1KjJdKTtyZXR1cm4gdDAoW2MsaCxtXSl9fSx0LmNsYXNzTmFtZT1cIkN1c3RvbUluaXRcIix0KX1lbHNlIG89dGhpcy5iaWFzSW5pdGlhbGl6ZXI7dGhpcy5iaWFzPXRoaXMuYWRkV2VpZ2h0KFwiYmlhc1wiLFt0aGlzLmZpbHRlcnMqcl0sbnVsbCxvLHRoaXMuYmlhc1JlZ3VsYXJpemVyLCEwLHRoaXMuYmlhc0NvbnN0cmFpbnQpfXRoaXMuYnVpbHQ9ITB9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57aWYoZS5sZW5ndGghPT0zKXRocm93IG5ldyBWKGBDb252TFNUTTJEQ2VsbCBleHBlY3RzIDMgaW5wdXQgVGVuc29ycyAoaW5wdXRzLCBoLCBjKSwgZ290ICR7ZS5sZW5ndGh9LmApO2xldCBuPXQudHJhaW5pbmd8fCExLGE9ZVswXSxyPWVbMV0scz1lWzJdLGk9NDswPHRoaXMuZHJvcG91dCYmdGhpcy5kcm9wb3V0PDEmJnRoaXMuZHJvcG91dE1hc2s9PW51bGwmJih0aGlzLmRyb3BvdXRNYXNrPWdzKHtvbmVzOigpPT5lYShhKSxyYXRlOnRoaXMuZHJvcG91dCx0cmFpbmluZzpuLGNvdW50OmksZHJvcG91dEZ1bmM6dGhpcy5kcm9wb3V0RnVuY30pKTtsZXQgbz10aGlzLmRyb3BvdXRNYXNrLGw9KFosSixlZSk9PiFKfHwhSltlZV0/Wjp6KEpbZWVdLFopLHU9bChhLG8sMCkscD1sKGEsbywxKSxkPWwoYSxvLDIpLGM9bChhLG8sMyk7MDx0aGlzLnJlY3VycmVudERyb3BvdXQmJnRoaXMucmVjdXJyZW50RHJvcG91dDwxJiZ0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrPT1udWxsJiYodGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzaz1ncyh7b25lczooKT0+ZWEocikscmF0ZTp0aGlzLnJlY3VycmVudERyb3BvdXQsdHJhaW5pbmc6bixjb3VudDppLGRyb3BvdXRGdW5jOnRoaXMuZHJvcG91dEZ1bmN9KSk7bGV0IGg9dGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzayxtPWwocixoLDApLGY9bChyLGgsMSksZz1sKHIsaCwyKSxiPWwocixoLDMpLHk9MyxbeCx2LEksTl09TG4odGhpcy5rZXJuZWwucmVhZCgpLGkseSksW0MsXyxGLERdPXRoaXMudXNlQmlhcz9Mbih0aGlzLmJpYXMucmVhZCgpLGkpOltudWxsLG51bGwsbnVsbCxudWxsXTt1PXRoaXMuaW5wdXRDb252KHUseCxDLHRoaXMucGFkZGluZykscD10aGlzLmlucHV0Q29udihwLHYsXyx0aGlzLnBhZGRpbmcpLGQ9dGhpcy5pbnB1dENvbnYoZCxJLEYsdGhpcy5wYWRkaW5nKSxjPXRoaXMuaW5wdXRDb252KGMsTixELHRoaXMucGFkZGluZyk7bGV0WyQsUyxNLEJdPUxuKHRoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSxpLHkpO209dGhpcy5yZWN1cnJlbnRDb252KG0sJCksZj10aGlzLnJlY3VycmVudENvbnYoZixTKSxnPXRoaXMucmVjdXJyZW50Q29udihnLE0pLGI9dGhpcy5yZWN1cnJlbnRDb252KGIsQik7bGV0IFU9dGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KFgodSxtKSksSD10aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoWChwLGYpKSxxPVgoeihILHMpLHooVSx0aGlzLmFjdGl2YXRpb24uYXBwbHkoWChkLGcpKSkpLEs9eih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoWChjLGIpKSx0aGlzLmFjdGl2YXRpb24uYXBwbHkocSkpO3JldHVybltLLEsscV19KX1nZXRDb25maWcoKXtsZXQgZT1zdXBlci5nZXRDb25maWcoKSx7dW5pdHM6dH09ZSxuPXlqKGUsW1widW5pdHNcIl0pLGE9e2ZpbHRlcnM6dGhpcy5maWx0ZXJzLGtlcm5lbFNpemU6dGhpcy5rZXJuZWxTaXplLHBhZGRpbmc6dGhpcy5wYWRkaW5nLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0LGRpbGF0aW9uUmF0ZTp0aGlzLmRpbGF0aW9uUmF0ZSxzdHJpZGVzOnRoaXMuc3RyaWRlc307cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSxhKX1pbnB1dENvbnYoZSx0LG4sYSl7bGV0IHI9JHQoZSx0LHRoaXMuc3RyaWRlcyxhfHxcInZhbGlkXCIsdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/XCJOQ0hXXCI6XCJOSFdDXCIsdGhpcy5kaWxhdGlvblJhdGUpO3JldHVybiBuP0thKHIsbix0aGlzLmRhdGFGb3JtYXQpOnJ9cmVjdXJyZW50Q29udihlLHQpe3JldHVybiAkdChlLHQsMSxcInNhbWVcIix0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9cIk5DSFdcIjpcIk5IV0NcIil9fTtNZi5jbGFzc05hbWU9XCJDb252TFNUTTJEQ2VsbFwiO25lLnJlZ2lzdGVyQ2xhc3MoTWYpO3ZhciBXMD1jbGFzcyBleHRlbmRzIHZDe2NvbnN0cnVjdG9yKGUpe2xldCB0PW5ldyBNZihlKTtzdXBlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZSkse2NlbGw6dH0pKX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQpe3JldHVybiBuZXcgZSh0KX19O1cwLmNsYXNzTmFtZT1cIkNvbnZMU1RNMkRcIjtuZS5yZWdpc3RlckNsYXNzKFcwKTt2YXIgT2Y9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnJhdGU9TWF0aC5tYXgoTWF0aC5taW4oZS5yYXRlLDEpLDApLHRoaXMubm9pc2VTaGFwZT1lLm5vaXNlU2hhcGUsdGhpcy5zZWVkPWUuc2VlZCx0aGlzLnN1cHBvcnRzTWFza2luZz0hMH1nZXROb2lzZVNoYXBlKGUpe2lmKHRoaXMubm9pc2VTaGFwZT09bnVsbClyZXR1cm4gdGhpcy5ub2lzZVNoYXBlO2xldCB0PWUuc2hhcGUsbj1bXTtmb3IobGV0IGE9MDthPHRoaXMubm9pc2VTaGFwZS5sZW5ndGg7KythKW4ucHVzaCh0aGlzLm5vaXNlU2hhcGVbYV09PW51bGw/dFthXTp0aGlzLm5vaXNlU2hhcGVbYV0pO3JldHVybiBufWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KTtsZXQgbj1UZShlKTtpZigwPHRoaXMucmF0ZSYmdGhpcy5yYXRlPDEpe2xldCBhPXQudHJhaW5pbmc9PW51bGw/ITE6dC50cmFpbmluZyxyPXRoaXMuZ2V0Tm9pc2VTaGFwZShuKTtyZXR1cm4gSWQoKCk9PncyKG4sdGhpcy5yYXRlLHIsdGhpcy5zZWVkKSwoKT0+bixhKX1yZXR1cm4gZX0pfWdldENvbmZpZygpe2xldCBlPXtyYXRlOnRoaXMucmF0ZSxub2lzZVNoYXBlOnRoaXMubm9pc2VTaGFwZSxzZWVkOnRoaXMuc2VlZH0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9ZGlzcG9zZSgpe3JldHVybiBzdXBlci5kaXNwb3NlKCl9fTtPZi5jbGFzc05hbWU9XCJEcm9wb3V0XCI7bmUucmVnaXN0ZXJDbGFzcyhPZik7dmFyIEIwPWNsYXNzIGV4dGVuZHMgT2Z7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5pbnB1dFNwZWM9W3tuZGltOjN9XX1nZXROb2lzZVNoYXBlKGUpe2xldCB0PWUuc2hhcGU7cmV0dXJuW3RbMF0sMSx0WzJdXX19O0IwLmNsYXNzTmFtZT1cIlNwYXRpYWxEcm9wb3V0MURcIjtuZS5yZWdpc3RlckNsYXNzKEIwKTt2YXIgVjA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLmFjdGl2YXRpb249bnVsbCx0aGlzLnVzZUJpYXM9ITAsdGhpcy5rZXJuZWw9bnVsbCx0aGlzLmJpYXM9bnVsbCx0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSPVwiZ2xvcm90Tm9ybWFsXCIsdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVI9XCJ6ZXJvc1wiLGUuYmF0Y2hJbnB1dFNoYXBlPT1udWxsJiZlLmlucHV0U2hhcGU9PW51bGwmJmUuaW5wdXREaW0hPW51bGwpe2xldCB0PW51bGw7ZS5iYXRjaFNpemUhPW51bGwmJih0PWUuYmF0Y2hTaXplKSx0aGlzLmJhdGNoSW5wdXRTaGFwZT1bdCxlLmlucHV0RGltXX10aGlzLnVuaXRzPWUudW5pdHMsdG4odGhpcy51bml0cyxcInVuaXRzXCIpLHRoaXMuYWN0aXZhdGlvbj1mcyhlLmFjdGl2YXRpb24pLGUudXNlQmlhcyE9bnVsbCYmKHRoaXMudXNlQmlhcz1lLnVzZUJpYXMpLHRoaXMua2VybmVsSW5pdGlhbGl6ZXI9U3QoZS5rZXJuZWxJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUiksdGhpcy5iaWFzSW5pdGlhbGl6ZXI9U3QoZS5iaWFzSW5pdGlhbGl6ZXJ8fHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKSx0aGlzLmtlcm5lbENvbnN0cmFpbnQ9WXQoZS5rZXJuZWxDb25zdHJhaW50KSx0aGlzLmJpYXNDb25zdHJhaW50PVl0KGUuYmlhc0NvbnN0cmFpbnQpLHRoaXMua2VybmVsUmVndWxhcml6ZXI9TnQoZS5rZXJuZWxSZWd1bGFyaXplciksdGhpcy5iaWFzUmVndWxhcml6ZXI9TnQoZS5iaWFzUmVndWxhcml6ZXIpLHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplcj1OdChlLmFjdGl2aXR5UmVndWxhcml6ZXIpLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMuaW5wdXRTcGVjPVt7bWluTkRpbToyfV19YnVpbGQoZSl7ZT1KZShlKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3RoaXMua2VybmVsPT1udWxsJiYodGhpcy5rZXJuZWw9dGhpcy5hZGRXZWlnaHQoXCJrZXJuZWxcIixbdCx0aGlzLnVuaXRzXSxudWxsLHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsdGhpcy5rZXJuZWxSZWd1bGFyaXplciwhMCx0aGlzLmtlcm5lbENvbnN0cmFpbnQpLHRoaXMudXNlQmlhcyYmKHRoaXMuYmlhcz10aGlzLmFkZFdlaWdodChcImJpYXNcIixbdGhpcy51bml0c10sbnVsbCx0aGlzLmJpYXNJbml0aWFsaXplcix0aGlzLmJpYXNSZWd1bGFyaXplciwhMCx0aGlzLmJpYXNDb25zdHJhaW50KSkpLHRoaXMuaW5wdXRTcGVjPVt7bWluTkRpbToyLGF4ZXM6e1stMV06dH19XSx0aGlzLmJ1aWx0PSEwfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0PWUuc2xpY2UoKTtyZXR1cm4gdFt0Lmxlbmd0aC0xXT10aGlzLnVuaXRzLHR9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57dGhpcy5pbnZva2VDYWxsSG9vayhlLHQpO2xldCBuPVRlKGUpLGE9bTIodGhpcy5hY3RpdmF0aW9uLmdldENsYXNzTmFtZSgpKSxyO3JldHVybiBhIT1udWxsP3I9b3Iobix0aGlzLmtlcm5lbC5yZWFkKCksYSx0aGlzLmJpYXM/dGhpcy5iaWFzLnJlYWQoKTpudWxsKToocj1vcihuLHRoaXMua2VybmVsLnJlYWQoKSksdGhpcy5iaWFzIT1udWxsJiYocj1LYShyLHRoaXMuYmlhcy5yZWFkKCkpKSx0aGlzLmFjdGl2YXRpb24hPW51bGwmJihyPXRoaXMuYWN0aXZhdGlvbi5hcHBseShyKSkpLHJ9KX1nZXRDb25maWcoKXtsZXQgZT17dW5pdHM6dGhpcy51bml0cyxhY3RpdmF0aW9uOm1zKHRoaXMuYWN0aXZhdGlvbiksdXNlQmlhczp0aGlzLnVzZUJpYXMsa2VybmVsSW5pdGlhbGl6ZXI6RXQodGhpcy5rZXJuZWxJbml0aWFsaXplciksYmlhc0luaXRpYWxpemVyOkV0KHRoaXMuYmlhc0luaXRpYWxpemVyKSxrZXJuZWxSZWd1bGFyaXplcjpmdCh0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxiaWFzUmVndWxhcml6ZXI6ZnQodGhpcy5iaWFzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6ZnQodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxrZXJuZWxDb25zdHJhaW50Olh0KHRoaXMua2VybmVsQ29uc3RyYWludCksYmlhc0NvbnN0cmFpbnQ6WHQodGhpcy5iaWFzQ29uc3RyYWludCl9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07VjAuY2xhc3NOYW1lPVwiRGVuc2VcIjtuZS5yZWdpc3RlckNsYXNzKFYwKTt2YXIgVTA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtlPWV8fHt9LHN1cGVyKGUpLHRoaXMuaW5wdXRTcGVjPVt7bWluTkRpbTozfV0sdGhpcy5kYXRhRm9ybWF0PWUuZGF0YUZvcm1hdH1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtmb3IobGV0IHQgb2YgZS5zbGljZSgxKSlpZih0PT1udWxsKXRocm93IG5ldyBWKGBUaGUgc2hhcGUgb2YgdGhlIGlucHV0IHRvIFwiRmxhdHRlblwiIGlzIG5vdCBmdWxseSBkZWZpbmVkIChnb3QgJHtlLnNsaWNlKDEpfSkuIE1ha2Ugc3VyZSB0byBwYXNzIGEgY29tcGxldGUgXCJpbnB1dF9zaGFwZVwiIG9yIFwiYmF0Y2hfaW5wdXRfc2hhcGVcIiBhcmd1bWVudCB0byB0aGUgZmlyc3QgbGF5ZXIgaW4geW91ciBtb2RlbC5gKTtyZXR1cm5bZVswXSxycyhlLDEpXX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmludm9rZUNhbGxIb29rKGUsdCk7bGV0IG49VGUoZSk7aWYodGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCImJm4ucmFuaz4xKXtsZXQgYT1bMF07Zm9yKGxldCByPTI7cjxuLnJhbms7KytyKWEucHVzaChyKTthLnB1c2goMSksbj1EZShuLGEpfXJldHVybiBBRyhuKX0pfWdldENvbmZpZygpe2xldCBlPXt9O3RoaXMuZGF0YUZvcm1hdCE9bnVsbCYmKGUuZGF0YUZvcm1hdD10aGlzLmRhdGFGb3JtYXQpO2xldCB0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O1UwLmNsYXNzTmFtZT1cIkZsYXR0ZW5cIjtuZS5yZWdpc3RlckNsYXNzKFUwKTt2YXIgRzA9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLmFjdGl2YXRpb249ZnMoZS5hY3RpdmF0aW9uKX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pnt0aGlzLmludm9rZUNhbGxIb29rKGUsdCk7bGV0IG49VGUoZSk7cmV0dXJuIHRoaXMuYWN0aXZhdGlvbi5hcHBseShuKX0pfWdldENvbmZpZygpe2xldCBlPXthY3RpdmF0aW9uOm1zKHRoaXMuYWN0aXZhdGlvbil9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07RzAuY2xhc3NOYW1lPVwiQWN0aXZhdGlvblwiO25lLnJlZ2lzdGVyQ2xhc3MoRzApO3ZhciBIMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMubj1lLm4sdGhpcy5pbnB1dFNwZWM9W3tuZGltOjJ9XX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuW2VbMF0sdGhpcy5uLGVbMV1dfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+KGU9VGUoZSksRUcoZSx0aGlzLm4pKSl9Z2V0Q29uZmlnKCl7bGV0IGU9e246dGhpcy5ufSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O0gwLmNsYXNzTmFtZT1cIlJlcGVhdFZlY3RvclwiO25lLnJlZ2lzdGVyQ2xhc3MoSDApO3ZhciBqMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMudGFyZ2V0U2hhcGU9ZS50YXJnZXRTaGFwZTtmb3IobGV0IHQ9MDt0PHRoaXMudGFyZ2V0U2hhcGUubGVuZ3RoOysrdCl0aGlzLmlzVW5rbm93bih0aGlzLnRhcmdldFNoYXBlW3RdKSYmKHRoaXMudGFyZ2V0U2hhcGVbdF09bnVsbCl9aXNVbmtub3duKGUpe3JldHVybiBlPDB8fGU9PW51bGx9Zml4VW5rbm93bkRpbWVuc2lvbihlLHQpe2xldCBuPVwiVG90YWwgc2l6ZSBvZiBuZXcgYXJyYXkgbXVzdCBiZSB1bmNoYW5nZWQuXCIsYT10LnNsaWNlKCkscj0xLHM9bnVsbDtmb3IobGV0IG89MDtvPGEubGVuZ3RoOysrbyl7bGV0IGw9YVtvXTtpZih0aGlzLmlzVW5rbm93bihsKSlpZihzPT09bnVsbClzPW87ZWxzZSB0aHJvdyBuZXcgVihcIkNhbiBvbmx5IHNwZWNpZml5IG9uZSB1bmtub3duIGRpbWVuc2lvbi5cIik7ZWxzZSByKj1sfWxldCBpPXJzKGUpO2lmKHMhPT1udWxsKXtpZihyPT09MHx8aSVyIT09MCl0aHJvdyBuZXcgVihuKTthW3NdPWkvcn1lbHNlIGlmKGkhPT1yKXRocm93IG5ldyBWKG4pO3JldHVybiBhfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtsZXQgdD0hMTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZih0aGlzLmlzVW5rbm93bihlW25dKSl7dD0hMDticmVha31yZXR1cm4gdD9lLnNsaWNlKDAsMSkuY29uY2F0KHRoaXMudGFyZ2V0U2hhcGUpOmUuc2xpY2UoMCwxKS5jb25jYXQodGhpcy5maXhVbmtub3duRGltZW5zaW9uKGUuc2xpY2UoMSksdGhpcy50YXJnZXRTaGFwZSkpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KTtsZXQgbj1UZShlKSxhPW4uc2hhcGUscj1hLnNsaWNlKDAsMSkuY29uY2F0KHRoaXMuZml4VW5rbm93bkRpbWVuc2lvbihhLnNsaWNlKDEpLHRoaXMudGFyZ2V0U2hhcGUpKTtyZXR1cm4gVyhuLHIpfSl9Z2V0Q29uZmlnKCl7bGV0IGU9e3RhcmdldFNoYXBlOnRoaXMudGFyZ2V0U2hhcGV9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07ajAuY2xhc3NOYW1lPVwiUmVzaGFwZVwiO25lLnJlZ2lzdGVyQ2xhc3MoajApO3ZhciBxMD1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKGUpLGUuZGltcz09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkIGBkaW1zYCBpcyBtaXNzaW5nIGR1cmluZyBQZXJtdXRlIGNvbnN0cnVjdG9yIGNhbGwuXCIpO2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpdGhyb3cgbmV3IEVycm9yKGBQZXJtdXRlIGNvbnN0cnVjdG9yIHJlcXVpcmVzIFxcYGRpbXNcXGAgdG8gYmUgYW4gQXJyYXksIGJ1dCByZWNlaXZlZCAke2UuZGltc30gaW5zdGVhZC5gKTtsZXQgdD1VYSgxLGUuZGltcy5sZW5ndGgrMSk7aWYoIXcuYXJyYXlzRXF1YWwoZS5kaW1zLnNsaWNlKCkuc29ydCgpLHQpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGVybXV0YXRpb24gYGRpbXNgOiBcIitKU09OLnN0cmluZ2lmeShlLmRpbXMpK1wiIGBkaW1zYCBtdXN0IGNvbnRhaW4gY29uc2VjdXRpdmUgaW50ZWdlcnMgc3RhcnRpbmcgZnJvbSAxLlwiKTt0aGlzLmRpbXM9ZS5kaW1zLHRoaXMuZGltc0luY2x1ZGluZ0JhdGNoPVswXS5jb25jYXQodGhpcy5kaW1zKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOnRoaXMuZGltcy5sZW5ndGgrMX0pXX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtsZXQgdD1lLnNsaWNlKCk7cmV0dXJuIHRoaXMuZGltcy5mb3JFYWNoKChuLGEpPT57dFthKzFdPWVbbl19KSx0fWNhbGwoZSx0KXtyZXR1cm4gRGUoVGUoZSksdGhpcy5kaW1zSW5jbHVkaW5nQmF0Y2gpfWdldENvbmZpZygpe2xldCBlPXtkaW1zOnRoaXMuZGltc30sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtxMC5jbGFzc05hbWU9XCJQZXJtdXRlXCI7bmUucmVnaXN0ZXJDbGFzcyhxMCk7dmFyIEswPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZT09bnVsbD97fTplKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCxlIT1udWxsP3RoaXMubWFza1ZhbHVlPWUubWFza1ZhbHVlPT1udWxsPzA6ZS5tYXNrVmFsdWU6dGhpcy5tYXNrVmFsdWU9MH1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCksdD17bWFza1ZhbHVlOnRoaXMubWFza1ZhbHVlfTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LGUpLHR9Y29tcHV0ZU1hc2soZSx0KXtsZXQgbj1UZShlKTtyZXR1cm4geWMoZmkobix0aGlzLm1hc2tWYWx1ZSksLTEpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e3RoaXMuaW52b2tlQ2FsbEhvb2soZSx0KTtsZXQgbj1UZShlKSxhPXljKGZpKG4sdGhpcy5tYXNrVmFsdWUpLC0xLCEwKTtyZXR1cm4geihuLHJlKGEsbi5kdHlwZSkpfSl9fTtLMC5jbGFzc05hbWU9XCJNYXNraW5nXCI7bmUucmVnaXN0ZXJDbGFzcyhLMCk7dmFyIFgwPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoZSksdGhpcy5lbWJlZGRpbmdzPW51bGwsdGhpcy5ERUZBVUxUX0VNQkVERElOR1NfSU5JVElBTElaRVI9XCJyYW5kb21Vbmlmb3JtXCIsZS5iYXRjaElucHV0U2hhcGU9PW51bGwmJmUuaW5wdXRTaGFwZT09bnVsbCl7bGV0IHQ9bnVsbDtlLmJhdGNoU2l6ZSE9bnVsbCYmKHQ9ZS5iYXRjaFNpemUpLGUuaW5wdXRMZW5ndGg9PW51bGw/dGhpcy5iYXRjaElucHV0U2hhcGU9W3QsbnVsbF06dGhpcy5iYXRjaElucHV0U2hhcGU9W3RdLmNvbmNhdChpdChlLmlucHV0TGVuZ3RoKSl9dGhpcy5pbnB1dERpbT1lLmlucHV0RGltLHRuKHRoaXMuaW5wdXREaW0sXCJpbnB1dERpbVwiKSx0aGlzLm91dHB1dERpbT1lLm91dHB1dERpbSx0bih0aGlzLm91dHB1dERpbSxcIm91dHB1dERpbVwiKSx0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplcj1TdChlLmVtYmVkZGluZ3NJbml0aWFsaXplcnx8dGhpcy5ERUZBVUxUX0VNQkVERElOR1NfSU5JVElBTElaRVIpLHRoaXMuZW1iZWRkaW5nc1JlZ3VsYXJpemVyPU50KGUuZW1iZWRkaW5nc1JlZ3VsYXJpemVyKSx0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXI9TnQoZS5hY3Rpdml0eVJlZ3VsYXJpemVyKSx0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50PVl0KGUuZW1iZWRkaW5nc0NvbnN0cmFpbnQpLHRoaXMubWFza1plcm89ZS5tYXNrWmVybyx0aGlzLnN1cHBvcnRzTWFza2luZz1lLm1hc2taZXJvLHRoaXMuaW5wdXRMZW5ndGg9ZS5pbnB1dExlbmd0aH1idWlsZChlKXt0aGlzLmVtYmVkZGluZ3M9dGhpcy5hZGRXZWlnaHQoXCJlbWJlZGRpbmdzXCIsW3RoaXMuaW5wdXREaW0sdGhpcy5vdXRwdXREaW1dLHRoaXMuZHR5cGUsdGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIsdGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIsITAsdGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksdGhpcy5idWlsdD0hMH13YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlKGUpe31jb21wdXRlTWFzayhlLHQpe3JldHVybiBPKCgpPT50aGlzLm1hc2taZXJvPyhlPVRlKGUpLGZpKGUscWUoZSkpKTpudWxsKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7aWYoZT1KZShlKSx0aGlzLmlucHV0TGVuZ3RoPT1udWxsKXJldHVyblsuLi5lLHRoaXMub3V0cHV0RGltXTtsZXQgdD1pdCh0aGlzLmlucHV0TGVuZ3RoKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoLTEpdGhyb3cgbmV3IFYoYFwiaW5wdXRMZW5ndGhcIiBpcyAke3RoaXMuaW5wdXRMZW5ndGh9LCBidXQgcmVjZWl2ZWQgaW5wdXQgc2hhcGUgaGFzIHNoYXBlICR7ZX1gKTt7bGV0IG49MDtmb3IobGV0IGE9MDthPHQubGVuZ3RoOysrYSl7bGV0IHI9dFthXSxzPWVbYSsxXTtpZihyIT1udWxsJiZzIT1udWxsJiZyIT09cyl0aHJvdyBuZXcgVihgXCJpbnB1dExlbmd0aFwiIGlzICR7dGhpcy5pbnB1dExlbmd0aH0sIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZSBoYXMgc2hhcGUgJHtlfWApO3I9PW51bGwmJih0W25dPXMpLG4rK319cmV0dXJuW2VbMF0sLi4udCx0aGlzLm91dHB1dERpbV19Y2FsbChlLHQpe3JldHVybiBPKCgpPT57dGhpcy5pbnZva2VDYWxsSG9vayhlLHQpO2xldCBuPVRlKGUpO24uZHR5cGUhPT1cImludDMyXCImJihuPWlyKG4sXCJpbnQzMlwiKSk7bGV0IGE9djIodGhpcy5lbWJlZGRpbmdzLnJlYWQoKSxXKG4sW24uc2l6ZV0pKTtyZXR1cm4gVyhhLEplKHRoaXMuY29tcHV0ZU91dHB1dFNoYXBlKG4uc2hhcGUpKSl9KX1nZXRDb25maWcoKXtsZXQgZT17aW5wdXREaW06dGhpcy5pbnB1dERpbSxvdXRwdXREaW06dGhpcy5vdXRwdXREaW0sZW1iZWRkaW5nc0luaXRpYWxpemVyOkV0KHRoaXMuZW1iZWRkaW5nc0luaXRpYWxpemVyKSxlbWJlZGRpbmdzUmVndWxhcml6ZXI6ZnQodGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIpLGFjdGl2aXR5UmVndWxhcml6ZXI6ZnQodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxlbWJlZGRpbmdzQ29uc3RyYWludDpYdCh0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50KSxtYXNrWmVybzp0aGlzLm1hc2taZXJvLGlucHV0TGVuZ3RoOnRoaXMuaW5wdXRMZW5ndGh9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX07WDAuY2xhc3NOYW1lPVwiRW1iZWRkaW5nXCI7bmUucmVnaXN0ZXJDbGFzcyhYMCk7dmFyIFlvPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZXx8e30pLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwfW1lcmdlRnVuY3Rpb24oZSl7dGhyb3cgbmV3IHplfWNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUoZSx0KXtpZihlPT1udWxsfHx0PT1udWxsKXJldHVybiBudWxsO2lmKGUubGVuZ3RoPHQubGVuZ3RoKXJldHVybiB0aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUodCxlKTtpZih0Lmxlbmd0aD09PTApcmV0dXJuIGU7bGV0IG49ZS5zbGljZSgwLGUubGVuZ3RoLXQubGVuZ3RoKTtmb3IobGV0IGE9MDthPHQubGVuZ3RoOysrYSl7bGV0IHI9ZVtlLmxlbmd0aC10Lmxlbmd0aCthXSxzPXRbYV07aWYocj09bnVsbHx8cz09bnVsbHx8cjwwfHxzPDApbi5wdXNoKG51bGwpO2Vsc2UgaWYocj09PTEpbi5wdXNoKHMpO2Vsc2UgaWYocz09PTEpbi5wdXNoKHIpO2Vsc2V7aWYociE9PXMpdGhyb3cgbmV3IFYoXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiK0pTT04uc3RyaW5naWZ5KGUpK1wiIFwiK0pTT04uc3RyaW5naWZ5KHQpKTtuLnB1c2gocil9fXJldHVybiBufWJ1aWxkKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkmJiFBcnJheS5pc0FycmF5KGVbMF0pJiYoZT1bSmUoZSldKSxlPWUsZS5sZW5ndGg8Mil0aHJvdyBuZXcgVihgQSBtZXJnZSBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGFuIEFycmF5IG9mIGF0IGxlYXN0IDIgaW5wdXRzLiBHb3QgJHtlLmxlbmd0aH0gaW5wdXQocykuYCk7bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpciE9bnVsbCYmclswXSE9PW51bGwmJnQucHVzaChyWzBdKTtpZih0PWFzKHQpLHQubGVuZ3RoPjEpdGhyb3cgbmV3IFYoYENhbiBub3QgbWVyZ2UgdGVuc29ycyB3aXRoIGRpZmZlcmVudCBiYXRjaCBzaXplcy4gR290IHRlbnNvcnMgd2l0aCBzaGFwZXM6ICR7SlNPTi5zdHJpbmdpZnkoZSl9LmApO2xldCBuPWVbMF09PW51bGw/bnVsbDplWzBdLnNsaWNlKDEpO2ZvcihsZXQgcj0xO3I8ZS5sZW5ndGg7KytyKXtsZXQgcz1lW3JdPT1udWxsP251bGw6ZVtyXS5zbGljZSgxKTtuPXRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZShuLHMpfWxldCBhPWUubWFwKHI9PnIubGVuZ3RoKTtlLmluZGV4T2YobnVsbCk9PT0tMSYmYXMoYSkubGVuZ3RoPT09MT90aGlzLnJlc2hhcGVSZXF1aXJlZD0hMTp0aGlzLnJlc2hhcGVSZXF1aXJlZD0hMH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntpZihlPWUsdGhpcy5yZXNoYXBlUmVxdWlyZWQpe2xldCBuPVtdLGE9ZS5tYXAocj0+ci5yYW5rKTtpZihhLmluZGV4T2YobnVsbCk9PT0tMSl7bGV0IHI9aHMoYSk7Zm9yKGxldCBzIG9mIGUpe2xldCBpPXMucmFuaztmb3IobGV0IG89MDtvPHItaTsrK28pcz13ZChzLDEpO24ucHVzaChzKX1yZXR1cm4gdGhpcy5tZXJnZUZ1bmN0aW9uKG4pfWVsc2V7bGV0IHI9ITE7Zm9yKGxldCBvIG9mIGUpe2xldCBsPW8ucmFuaztpZihsPT1udWxsKXtsZXQgdT1vLnNoYXBlLHA9dVswXSxkPXUuc2xpY2UoMSkuY29uY2F0KFtwXSksYz1XKG8sW3BdLmNvbmNhdChycyh1LnNsaWNlKDEpKSkpO2M9RGUoYyxbMSwwXSksYz1XKGMsZCksbi5wdXNoKGMpLHI9ITB9ZWxzZSBpZihsPjEpe2xldCB1PVVhKDEsbCkuY29uY2F0KFswXSk7bi5wdXNoKERlKG8sdSkpLHI9ITB9ZWxzZSBuLnB1c2gobyl9bGV0IHM9dGhpcy5tZXJnZUZ1bmN0aW9uKG4pLGk9cy5yYW5rO2lmKHIpe2lmKGk9PW51bGwpe2xldCBvPXMuc2hhcGUsbD1vLmxlbmd0aCx1PW9bbC0xXSxwPVt1XS5jb25jYXQoby5zbGljZSgwLG8ubGVuZ3RoLTEpKTtzPVcoRGUoVyhzLFstMSx1XSksWzEsMF0pLHApfWVsc2UgaWYoaT4xKXtsZXQgbz1baS0xXS5jb25jYXQoVWEoMCxpLTEpKTtzPURlKHMsbyl9fXJldHVybiBzfX1lbHNlIHJldHVybiB0aGlzLm1lcmdlRnVuY3Rpb24oZSl9KX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1lO2xldCB0O2VbMF09PW51bGw/dD1udWxsOnQ9ZVswXS5zbGljZSgxKTtmb3IobGV0IGE9MTthPGUubGVuZ3RoOysrYSl7bGV0IHI9ZVthXT09bnVsbD9udWxsOmVbYV0uc2xpY2UoMSk7dD10aGlzLmNvbXB1dGVFbGVtZW50d2lzZU9wT3V0cHV0U2hhcGUodCxyKX1sZXQgbj1bXTtmb3IobGV0IGEgb2YgZSlhIT1udWxsJiZhWzBdIT09bnVsbCYmbi5wdXNoKGFbMF0pO3JldHVybiBuPWFzKG4pLG4ubGVuZ3RoPT09MT90PW4uY29uY2F0KHQpOnQ9W251bGxdLmNvbmNhdCh0KSx0fWNvbXB1dGVNYXNrKGUsdCl7cmV0dXJuIE8oKCk9PntpZih0PT1udWxsKXJldHVybiBudWxsO2lmKCFBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBWKFwiYG1hc2tgIHNob3VsZCBiZSBhbiBBcnJheVwiKTtpZighQXJyYXkuaXNBcnJheShlKSl0aHJvdyBuZXcgVihcImBpbnB1dHNgIHNob3VsZCBiZSBhbiBBcnJheVwiKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBWKGBUaGUgQXJyYXkgJ2lucHV0cycgYW5kICdtYXNrJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBsZW5ndGgsIGJ1dCBoYXZlIGRpZmZlcmVudCBsZW5ndGhzICgke2UubGVuZ3RofSB2cyAke3QubGVuZ3RofSlgKTtpZih0LmV2ZXJ5KGE9PmE9PW51bGwpKXJldHVybiBudWxsO3Q9dC5tYXAoYT0+YT09bnVsbD9hOkd0KGEsMCkpO2xldCBuPXRbMF07Zm9yKGxldCBhPTE7YTx0Lmxlbmd0aC0xOysrYSluPV9hKG4sdFthXSk7cmV0dXJuIG59KX19LFkwPWNsYXNzIGV4dGVuZHMgWW97Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9bWVyZ2VGdW5jdGlvbihlKXtyZXR1cm4gTygoKT0+e2xldCB0PWVbMF0uY2xvbmUoKTtmb3IobGV0IG49MTtuPGUubGVuZ3RoOysrbil0PVgodCxlW25dKTtyZXR1cm4gdH0pfX07WTAuY2xhc3NOYW1lPVwiQWRkXCI7bmUucmVnaXN0ZXJDbGFzcyhZMCk7dmFyIFowPWNsYXNzIGV4dGVuZHMgWW97Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9bWVyZ2VGdW5jdGlvbihlKXtyZXR1cm4gTygoKT0+e2xldCB0PWVbMF0uY2xvbmUoKTtmb3IobGV0IG49MTtuPGUubGVuZ3RoOysrbil0PXoodCxlW25dKTtyZXR1cm4gdH0pfX07WjAuY2xhc3NOYW1lPVwiTXVsdGlwbHlcIjtuZS5yZWdpc3RlckNsYXNzKFowKTt2YXIgSjA9Y2xhc3MgZXh0ZW5kcyBZb3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1tZXJnZUZ1bmN0aW9uKGUpe3JldHVybiBPKCgpPT57bGV0IHQ9ZVswXS5jbG9uZSgpO2ZvcihsZXQgbj0xO248ZS5sZW5ndGg7KytuKXQ9WCh0LGVbbl0pO3JldHVybiB6KDEvZS5sZW5ndGgsdCl9KX19O0owLmNsYXNzTmFtZT1cIkF2ZXJhZ2VcIjtuZS5yZWdpc3RlckNsYXNzKEowKTt2YXIgUTA9Y2xhc3MgZXh0ZW5kcyBZb3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1tZXJnZUZ1bmN0aW9uKGUpe3JldHVybiBPKCgpPT57bGV0IHQ9ZVswXTtmb3IobGV0IG49MTtuPGUubGVuZ3RoOysrbil0PWhyKHQsZVtuXSk7cmV0dXJuIHR9KX19O1EwLmNsYXNzTmFtZT1cIk1heGltdW1cIjtuZS5yZWdpc3RlckNsYXNzKFEwKTt2YXIgZTE9Y2xhc3MgZXh0ZW5kcyBZb3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1tZXJnZUZ1bmN0aW9uKGUpe3JldHVybiBPKCgpPT57bGV0IHQ9ZVswXTtmb3IobGV0IG49MTtuPGUubGVuZ3RoOysrbil0PWRzKHQsZVtuXSk7cmV0dXJuIHR9KX19O2UxLmNsYXNzTmFtZT1cIk1pbmltdW1cIjtuZS5yZWdpc3RlckNsYXNzKGUxKTt2YXIgdDE9Y2xhc3MgZXh0ZW5kcyBZb3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLkRFRkFVTFRfQVhJUz0tMSxlPT1udWxsJiYoZT17fSksdGhpcy5heGlzPWUuYXhpcz09bnVsbD90aGlzLkRFRkFVTFRfQVhJUzplLmF4aXMsdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsdGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITF9YnVpbGQoZSl7aWYoIShBcnJheS5pc0FycmF5KGUpJiZBcnJheS5pc0FycmF5KGVbMF0pKXx8ZS5sZW5ndGg9PT0xKXRocm93IG5ldyBWKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGF0IGxlYXN0IDIgaW5wdXRzXCIpO2U9ZTtsZXQgdD0hMDtmb3IobGV0IGEgb2YgZSlpZihhIT1udWxsKXt0PSExO2JyZWFrfWlmKHQpcmV0dXJuO2xldCBuPVtdO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7KythKXtsZXQgcj1lW2FdLnNsaWNlKCk7ci5zcGxpY2UodGhpcy5heGlzLDEpO2xldCBzPSExO2ZvcihsZXQgaSBvZiBuKWlmKHcuYXJyYXlzRXF1YWwoaSxyKSl7cz0hMDticmVha31zfHxuLnB1c2gocil9aWYobi5sZW5ndGg+MSl0aHJvdyBuZXcgVihcIkEgYENvbmNhdGVuYXRlYCBsYXllciByZXF1aXJlcyBpbnB1dHMgd2l0aCBtYXRjaGluZyBzaGFwZXMgZXhjZXB0IGZvciB0aGUgY29uY2F0IGF4aXMuIEdvdCBpbnB1dCBzaGFwZXM6IFwiK0pTT04uc3RyaW5naWZ5KGUpKX1tZXJnZUZ1bmN0aW9uKGUpe3JldHVybiBPKCgpPT50MChlLHRoaXMuYXhpcykpfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtpZighKEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoZVswXSkpKXRocm93IG5ldyBWKFwiQSBgQ29uY2F0ZW5hdGVgIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYSBsaXN0IG9mIGlucHV0cy5cIik7bGV0IHQ9ZSxuPXRbMF0uc2xpY2UoKSxhPXRoaXMuYXhpczwwP24ubGVuZ3RoK3RoaXMuYXhpczp0aGlzLmF4aXM7Zm9yKGxldCByIG9mIHQuc2xpY2UoMSkpe2lmKG5bYV09PW51bGx8fHJbYV09PW51bGwpe25bYV09bnVsbDticmVha31uW2FdKz1yW2FdfXJldHVybiBufWNvbXB1dGVNYXNrKGUsdCl7aWYodD09bnVsbClyZXR1cm4gbnVsbDtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVihcImBtYXNrYCBzaG91bGQgYmUgYW4gYXJyYXkgZm9yIENvbmNhdGVuYXRlXCIpO2lmKCFBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBWKFwiYGlucHV0c2Agc2hvdWxkIGJlIGFuIGFycmF5IGZvciBDb25jYXRlbmF0ZVwiKTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBWKGBNaXNtYXRjaCBpbiB0aGUgbGVuZ3RoIG9mIG1hc2sgKCR7dC5sZW5ndGh9KSBhbmQgdGhlIGxlZ250aCBvZiBpbnB1dHMgKCR7ZS5sZW5ndGh9KWApO3JldHVybiBPKCgpPT57bGV0IG49ITA7aWYodC5mb3JFYWNoKHM9PntpZihzIT1udWxsKXtuPSExO3JldHVybn19KSxuKXJldHVybiBudWxsO2xldCBhPVtdO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7KytzKXRbc109PW51bGw/YS5wdXNoKHJlKGVhKGVbc10pLFwiYm9vbFwiKSk6dFtzXS5yYW5rPGVbc10ucmFuaz9hLnB1c2goR3QodFtzXSwtMSkpOmEucHVzaCh0W3NdKTtsZXQgcj1ldChhLHRoaXMuYXhpcyk7cmV0dXJuIExtKHIsLTEsITEpfSl9Z2V0Q29uZmlnKCl7bGV0IGU9e2F4aXM6dGhpcy5heGlzfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O3QxLmNsYXNzTmFtZT1cIkNvbmNhdGVuYXRlXCI7bmUucmVnaXN0ZXJDbGFzcyh0MSk7ZnVuY3Rpb24gWXAoZSx0KXtmb3IoO2U8MDspZSs9dDtyZXR1cm4gZX1mdW5jdGlvbiB4aihlLHQsbil7aWYoZS5zaGFwZS5sZW5ndGg+M3x8dC5zaGFwZS5sZW5ndGg+Myl0aHJvdyBuZXcgemUoXCJiYXRjaERvdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0XCIpO2lmKHcuYXNzZXJ0KGUuc2hhcGUubGVuZ3RoPj0yLCgpPT5gYmF0Y2hEb3QgcmVxdWlyZXMgdGhlIHJhbmsgb2YgeCB0byBiZSA+PSAyLCBidXQgZ290ICR7ZS5zaGFwZS5sZW5ndGh9YCksdy5hc3NlcnQoZS5zaGFwZS5sZW5ndGg+PTIsKCk9PmBiYXRjaERvdCByZXF1aXJlcyB0aGUgcmFuayBvZiB5IHRvIGJlID49IDIsIGJ1dCBnb3QgJHt0LnNoYXBlLmxlbmd0aH1gKSx0eXBlb2Ygbj09XCJudW1iZXJcIiYmKG49W24sbl0pLGUuZHR5cGU9PT1cImNvbXBsZXg2NFwifHx0LmR0eXBlPT09XCJjb21wbGV4NjRcIil0aHJvdyBuZXcgemUoXCJiYXRjaERvdCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGNvbXBsZXg2NC10eXBlIFRlbnNvcnMgeWV0LlwiKTtsZXQgYT1lLnNoYXBlLmxlbmd0aCxyPXQuc2hhcGUubGVuZ3RoO249PW51bGwmJihuPVthLTEsci0yXSk7bGV0IHM9bjtyZXR1cm4gTygoKT0+e2xldCBpO2lmKGE+cil7aT1hLXI7bGV0IGw9W107Zm9yKGxldCB1PTA7dTxpOysrdSlsLnB1c2goMSk7dD1XKHQsdC5zaGFwZS5jb25jYXQobCkpfWVsc2UgaWYocj5hKXtpPXItYTtsZXQgbD1bXTtmb3IobGV0IHU9MDt1PGk7Kyt1KWwucHVzaCgxKTtlPVcoZSxlLnNoYXBlLmNvbmNhdChsKSl9ZWxzZSBpPTA7bGV0IG87aWYoZS5zaGFwZS5sZW5ndGg9PT0yJiZ0LnNoYXBlLmxlbmd0aD09PTIpc1swXT09PXNbMV0/bz1mZSh6KGUsdCksc1swXSk6bz1mZSh6KERlKGUsWzEsMF0pLHQpLHNbMV0pO2Vsc2V7bGV0IGw9c1swXSE9PWUuc2hhcGUubGVuZ3RoLTEsdT1zWzFdPT09dC5zaGFwZS5sZW5ndGgtMTtvPSRlKGUsdCxsLHUpfWlmKGk+MCl7bGV0IGw7YT5yP2w9YStyLTM6bD1hLTE7bGV0IHU9W107Zm9yKGxldCBwPWw7cDxsK2k7KytwKXUucHVzaChwKTtvPUFzKG8sdSl9cmV0dXJuIG8uc2hhcGUubGVuZ3RoPT09MSYmKG89R3QobywxKSksb30pfXZhciBuMT1jbGFzcyBleHRlbmRzIFlve2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuYXhlcz1lLmF4ZXMsdGhpcy5ub3JtYWxpemU9ZS5ub3JtYWxpemU9PW51bGw/ITE6ZS5ub3JtYWxpemUsdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsdGhpcy5yZXNoYXBlUmVxdWlyZWQ9ITF9YnVpbGQoZSl7dy5hc3NlcnQoQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg9PT0yJiZBcnJheS5pc0FycmF5KGVbMF0pJiZBcnJheS5pc0FycmF5KGVbMV0pLCgpPT5cIkEgYERvdGAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgZXhhY3RseSAyIGlucHV0cy5cIik7bGV0IHQ9ZVswXSxuPWVbMV07aWYodC5sZW5ndGg+M3x8bi5sZW5ndGg+Myl0aHJvdyBuZXcgemUoXCJEb3QgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldC5cIik7bGV0IGE9dGhpcy5pbnRlcnByZXRBeGVzKHQsbik7aWYodFthWzBdXSE9PW5bYVsxXV0pdGhyb3cgbmV3IFYoYERpbWVuc2lvbiBpbmNvbXBhdGliaWxpdHk6ICR7dFthWzBdXX0gIT09ICR7blthWzFdXX1gKX1tZXJnZUZ1bmN0aW9uKGUpe2lmKGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgVihgQSBcXGBEb3RcXGAgbGF5ZXIgbXVzdCBiZSBjYWxsZWQgb24gZXhhY3RseSAyIGlucHV0cywgYnV0IHJlY2VpdmVkICR7ZS5sZW5ndGh9IGlucHV0KHMpLmApO2xldCB0PWVbMF0sbj1lWzFdLGE7cmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5heGVzKT9hPXRoaXMuYXhlcy5tYXAoKHIscyk9PllwKHIsZVtzXS5zaGFwZS5sZW5ndGgpKTphPVtZcCh0aGlzLmF4ZXMsdC5zaGFwZS5sZW5ndGgpLFlwKHRoaXMuYXhlcyxuLnNoYXBlLmxlbmd0aCldLHRoaXMubm9ybWFsaXplJiYodD10bSh0LGFbMF0pLG49dG0obixhWzFdKSkseGoodCxuLGEpfWludGVycHJldEF4ZXMoZSx0KXtsZXQgbjtyZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmF4ZXMpP249dGhpcy5heGVzOm49W1lwKHRoaXMuYXhlcyxlLmxlbmd0aCksWXAodGhpcy5heGVzLHQubGVuZ3RoKV0sbn1jb21wdXRlT3V0cHV0U2hhcGUoZSl7dy5hc3NlcnQoQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg9PT0yJiZBcnJheS5pc0FycmF5KGVbMF0pJiZBcnJheS5pc0FycmF5KGVbMV0pLCgpPT5cIkEgYERvdGAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgZXhhY3RseSAyIGlucHV0cy5cIik7bGV0IHQ9ZVswXS5zbGljZSgpLG49ZVsxXS5zbGljZSgpO2lmKHQubGVuZ3RoPjN8fG4ubGVuZ3RoPjMpdGhyb3cgbmV3IHplKFwiRG90IGxheWVyIGRvZXMgbm90IHN1cHBvcnQgdGVuc29ycyBvZiA0RCBvciBoaWdoZXIgcmFuayB5ZXQuXCIpO2xldCBhPXRoaXMuaW50ZXJwcmV0QXhlcyh0LG4pO3Quc3BsaWNlKGFbMF0sMSksbi5zcGxpY2UoYVsxXSwxKSxuLnNwbGljZSgwLDEpO2xldCByPXQuY29uY2F0KG4pO3JldHVybiByLmxlbmd0aD09PTEmJnIucHVzaCgxKSxyfWNvbXB1dGVNYXNrKGUsdCl7cmV0dXJuIG51bGx9Z2V0Q29uZmlnKCl7bGV0IGU9e2F4ZXM6dGhpcy5heGVzLG5vcm1hbGl6ZTp0aGlzLm5vcm1hbGl6ZX0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fTtuMS5jbGFzc05hbWU9XCJEb3RcIjtuZS5yZWdpc3RlckNsYXNzKG4xKTt2YXIgYTE9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnN1cHBvcnRzTWFza2luZz0hMCx0aGlzLnN0ZGRldj1lLnN0ZGRldn1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCksdD17c3RkZGV2OnRoaXMuc3RkZGV2fTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LGUpLHR9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57dGhpcy5pbnZva2VDYWxsSG9vayhlLHQpO2xldCBuPVRlKGUpO3JldHVybiBJZCgoKT0+WChiZihuLnNoYXBlLDAsdGhpcy5zdGRkZXYpLG4pLCgpPT5uLHQudHJhaW5pbmd8fCExKX0pfX07YTEuY2xhc3NOYW1lPVwiR2F1c3NpYW5Ob2lzZVwiO25lLnJlZ2lzdGVyQ2xhc3MoYTEpO3ZhciByMT1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMucmF0ZT1lLnJhdGV9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe3JldHVybiBlfWdldENvbmZpZygpe2xldCBlPXN1cGVyLmdldENvbmZpZygpLHQ9e3JhdGU6dGhpcy5yYXRlfTtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LGUpLHR9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57dGhpcy5pbnZva2VDYWxsSG9vayhlLHQpO2xldCBuPVRlKGUpO3JldHVybiB0aGlzLnJhdGU+MCYmdGhpcy5yYXRlPDE/SWQoKCk9PntsZXQgYT1NYXRoLnNxcnQodGhpcy5yYXRlLygxLXRoaXMucmF0ZSkpO3JldHVybiB6KG4sYmYobi5zaGFwZSwxLGEpKX0sKCk9Pm4sdC50cmFpbmluZ3x8ITEpOm59KX19O3IxLmNsYXNzTmFtZT1cIkdhdXNzaWFuRHJvcG91dFwiO25lLnJlZ2lzdGVyQ2xhc3MocjEpO3ZhciBzMT1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMucmF0ZT1lLnJhdGUsdGhpcy5ub2lzZVNoYXBlPWUubm9pc2VTaGFwZX1fZ2V0Tm9pc2VTaGFwZShlKXtyZXR1cm4gdGhpcy5ub2lzZVNoYXBlfHxUZShlKS5zaGFwZX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGV9Z2V0Q29uZmlnKCl7bGV0IGU9c3VwZXIuZ2V0Q29uZmlnKCksdD17cmF0ZTp0aGlzLnJhdGV9O3JldHVybiBPYmplY3QuYXNzaWduKHQsZSksdH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntpZih0aGlzLnJhdGU8MSYmdGhpcy5yYXRlPjApe2xldCBuPXRoaXMuX2dldE5vaXNlU2hhcGUoZSk7cmV0dXJuIElkKCgpPT57bGV0IGE9VGUoZSkscj0tMS42NzMyNjMyNDIzNTQzNzcyKjEuMDUwNzAwOTg3MzU1NDgwNSxzPSRyKEVzKG4pLHRoaXMucmF0ZSk7cz1pcihzLFwiZmxvYXQzMlwiKTtsZXQgaT0oKDEtdGhpcy5yYXRlKSooMSt0aGlzLnJhdGUqcioqMikpKiotLjUsbz0taSpyKnRoaXMucmF0ZSxsPVgoeihhLHMpLHooWChzLC0xKSxyKSk7cmV0dXJuIFgoeihsLGkpLG8pfSwoKT0+VGUoZSksdC50cmFpbmluZ3x8ITEpfXJldHVybiBlfSl9fTtzMS5jbGFzc05hbWU9XCJBbHBoYURyb3BvdXRcIjtuZS5yZWdpc3RlckNsYXNzKHMxKTtmdW5jdGlvbiBTYyhlLHQsbixhLHIscz0uMDAxKXtsZXQgaTtpZihlLnJhbms9PT0yKWk9cXYoZSx0LG4sYSxyLHMpO2Vsc2UgaWYoZS5yYW5rPT09MylpPUt2KGUsdCxuLGEscixzKTtlbHNlIGlmKGUucmFuaz09PTQpaT1YdihlLHQsbixhLHIscyk7ZWxzZSB0aHJvdyBuZXcgemUoYGJhdGNoTm9ybWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGFycmF5IG9mIHJhbmsgJHtlLnJhbmt9IHlldGApO3JldHVybiBpfWZ1bmN0aW9uIHZqKGUsdCxuLGEscj0uMDAxKXtyZXR1cm4gTygoKT0+e2xldCBzPWhkKGUsYSksaT1zLm1lYW4sbz1zLnZhcmlhbmNlO3JldHVybltTYyhlLGksbyxuLHQsciksaSxvXX0pfWZ1bmN0aW9uIHdqKGUsdCxuLGEscj0uMDAxKXtyZXR1cm4gTygoKT0+e2xldCBzPWhkKGUsYSksaT1zLm1lYW4sbz1zLnZhcmlhbmNlLGw9W107Zm9yKGxldCBoIG9mIFVhKDAsZS5yYW5rKSlhLmluZGV4T2YoaCkhPT0tMT9sLnB1c2goMSk6bC5wdXNoKGUuc2hhcGVbaF0pO2xldCB1PVcoaSxsKSxwPVcobyxsKSxkPXQ9PW51bGw/bnVsbDpXKHQsbCksYz1uPT1udWxsP251bGw6VyhuLGwpO3JldHVybltTYyhlLHUscCxjLGQsciksaSxvXX0pfWZ1bmN0aW9uIGtqKGUsdCxuLGEscj0uMDAxKXtyZXR1cm4gdy5hcnJheXNFcXVhbChhLnNsaWNlKCkuc29ydCgpLFVhKDAsZS5yYW5rLTEpKT92aihlLHQsbixhLHIpOndqKGUsdCxuLGEscil9dmFyIGkxPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7ZT09bnVsbCYmKGU9e30pLHN1cGVyKGUpLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwLHRoaXMuYXhpcz1lLmF4aXM9PW51bGw/LTE6ZS5heGlzLHRoaXMubW9tZW50dW09ZS5tb21lbnR1bT09bnVsbD8uOTk6ZS5tb21lbnR1bSx0aGlzLmVwc2lsb249ZS5lcHNpbG9uPT1udWxsPy4wMDE6ZS5lcHNpbG9uLHRoaXMuY2VudGVyPWUuY2VudGVyPT1udWxsPyEwOmUuY2VudGVyLHRoaXMuc2NhbGU9ZS5zY2FsZT09bnVsbD8hMDplLnNjYWxlLHRoaXMuYmV0YUluaXRpYWxpemVyPVN0KGUuYmV0YUluaXRpYWxpemVyfHxcInplcm9zXCIpLHRoaXMuZ2FtbWFJbml0aWFsaXplcj1TdChlLmdhbW1hSW5pdGlhbGl6ZXJ8fFwib25lc1wiKSx0aGlzLm1vdmluZ01lYW5Jbml0aWFsaXplcj1TdChlLm1vdmluZ01lYW5Jbml0aWFsaXplcnx8XCJ6ZXJvc1wiKSx0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXI9U3QoZS5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyfHxcIm9uZXNcIiksdGhpcy5iZXRhQ29uc3RyYWludD1ZdChlLmJldGFDb25zdHJhaW50KSx0aGlzLmdhbW1hQ29uc3RyYWludD1ZdChlLmdhbW1hQ29uc3RyYWludCksdGhpcy5iZXRhUmVndWxhcml6ZXI9TnQoZS5iZXRhUmVndWxhcml6ZXIpLHRoaXMuZ2FtbWFSZWd1bGFyaXplcj1OdChlLmdhbW1hUmVndWxhcml6ZXIpfWJ1aWxkKGUpe2U9SmUoZSk7bGV0IHQ9dGhpcy5heGlzPj0wP3RoaXMuYXhpczp0aGlzLmF4aXMrZS5sZW5ndGgsbj1lW3RdO2lmKG49PW51bGwpdGhyb3cgbmV3IFYoYEF4aXMgJHt0fSBvZiBpbnB1dCB0ZW5zb3Igc2hvdWxkIGhhdmUgYSBkZWZpbmVkIGRpbWVuc2lvbiBidXQgdGhlIGxheWVyIHJlY2VpdmVkIGFuIGlucHV0IHdpdGggc2hhcGUgJHtKU09OLnN0cmluZ2lmeShlKX0uYCk7dGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTplLmxlbmd0aCxheGVzOntbdF06bn19KV07bGV0IGE9W25dO3RoaXMuc2NhbGUmJih0aGlzLmdhbW1hPXRoaXMuYWRkV2VpZ2h0KFwiZ2FtbWFcIixhLG51bGwsdGhpcy5nYW1tYUluaXRpYWxpemVyLHRoaXMuZ2FtbWFSZWd1bGFyaXplciwhMCx0aGlzLmdhbW1hQ29uc3RyYWludCkpLHRoaXMuY2VudGVyJiYodGhpcy5iZXRhPXRoaXMuYWRkV2VpZ2h0KFwiYmV0YVwiLGEsbnVsbCx0aGlzLmJldGFJbml0aWFsaXplcix0aGlzLmJldGFSZWd1bGFyaXplciwhMCx0aGlzLmJldGFDb25zdHJhaW50KSksdGhpcy5tb3ZpbmdNZWFuPXRoaXMuYWRkV2VpZ2h0KFwibW92aW5nX21lYW5cIixhLG51bGwsdGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIsbnVsbCwhMSksdGhpcy5tb3ZpbmdWYXJpYW5jZT10aGlzLmFkZFdlaWdodChcIm1vdmluZ192YXJpYW5jZVwiLGEsbnVsbCx0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIsbnVsbCwhMSksdGhpcy5idWlsdD0hMH1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj10LnRyYWluaW5nPT1udWxsPyExOnQudHJhaW5pbmcsYT1UZShlKSxyPWEuc2hhcGUscz1yLmxlbmd0aCxpPVVhKDAscyksbz10aGlzLmF4aXM+PTA/dGhpcy5heGlzOnRoaXMuYXhpcytzO2kuc3BsaWNlKG8sMSk7bGV0IGw9YmkoMSxzKTtsW29dPXJbb107bGV0IHU9aS5zbGljZSgpO3Uuc29ydCgpO2xldCBwPSF3LmFycmF5c0VxdWFsKHUsVWEoMCxzKS5zbGljZSgwLHMtMSkpLGQ9KCk9PntpZihwKXtsZXQgZz1XKHRoaXMubW92aW5nTWVhbi5yZWFkKCksbCksYj1XKHRoaXMubW92aW5nVmFyaWFuY2UucmVhZCgpLGwpLHk9dGhpcy5jZW50ZXI/Vyh0aGlzLmJldGEucmVhZCgpLGwpOm51bGwseD10aGlzLnNjYWxlP1codGhpcy5nYW1tYS5yZWFkKCksbCk6bnVsbDtyZXR1cm4gU2MoYSxnLGIseSx4LHRoaXMuZXBzaWxvbil9ZWxzZSByZXR1cm4gU2MoYSx0aGlzLm1vdmluZ01lYW4ucmVhZCgpLHRoaXMubW92aW5nVmFyaWFuY2UucmVhZCgpLHRoaXMuYmV0YT09bnVsbD9udWxsOnRoaXMuYmV0YS5yZWFkKCksdGhpcy5nYW1tYT09bnVsbD9udWxsOnRoaXMuZ2FtbWEucmVhZCgpLHRoaXMuZXBzaWxvbil9O2lmKCFuKXJldHVybiBkKCk7bGV0W2MsaCxtXT1raihhLHRoaXMuZ2FtbWEucmVhZCgpLHRoaXMuYmV0YS5yZWFkKCksaSx0aGlzLmVwc2lsb24pLGY9KGcsYix5KT0+e08oKCk9PntsZXQgeD0xLXksdj1nLnJlYWQoKSxJPXoocGUodixiKSx4KTtnLndyaXRlKHBlKHYsSSkpfSl9O3JldHVybiBmKHRoaXMubW92aW5nTWVhbixoLHRoaXMubW9tZW50dW0pLGYodGhpcy5tb3ZpbmdWYXJpYW5jZSxtLHRoaXMubW9tZW50dW0pLGN9KX1nZXRDb25maWcoKXtsZXQgZT17YXhpczp0aGlzLmF4aXMsbW9tZW50dW06dGhpcy5tb21lbnR1bSxlcHNpbG9uOnRoaXMuZXBzaWxvbixjZW50ZXI6dGhpcy5jZW50ZXIsc2NhbGU6dGhpcy5zY2FsZSxiZXRhSW5pdGlhbGl6ZXI6RXQodGhpcy5iZXRhSW5pdGlhbGl6ZXIpLGdhbW1hSW5pdGlhbGl6ZXI6RXQodGhpcy5nYW1tYUluaXRpYWxpemVyKSxtb3ZpbmdNZWFuSW5pdGlhbGl6ZXI6RXQodGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIpLG1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXI6RXQodGhpcy5tb3ZpbmdWYXJpYW5jZUluaXRpYWxpemVyKSxiZXRhUmVndWxhcml6ZXI6ZnQodGhpcy5iZXRhUmVndWxhcml6ZXIpLGdhbW1hUmVndWxhcml6ZXI6ZnQodGhpcy5nYW1tYVJlZ3VsYXJpemVyKSxiZXRhQ29uc3RyYWludDpYdCh0aGlzLmJldGFDb25zdHJhaW50KSxnYW1tYUNvbnN0cmFpbnQ6WHQodGhpcy5nYW1tYUNvbnN0cmFpbnQpfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O2kxLmNsYXNzTmFtZT1cIkJhdGNoTm9ybWFsaXphdGlvblwiO25lLnJlZ2lzdGVyQ2xhc3MoaTEpO3ZhciBvMT1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe2lmKGU9PW51bGwmJihlPXt9KSxzdXBlcihlKSx0aGlzLmF4aXM9ZS5heGlzPT1udWxsPy0xOmUuYXhpcyx0eXBlb2YgdGhpcy5heGlzPT1cIm51bWJlclwiKXtpZighTnVtYmVyLmlzSW50ZWdlcih0aGlzLmF4aXMpKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYXhpcyB0byBiZSBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQgJHt0aGlzLmF4aXN9YCl9ZWxzZSBpZihBcnJheS5pc0FycmF5KHRoaXMuYXhpcykpe2ZvcihsZXQgdCBvZiB0aGlzLmF4aXMpaWYoIU51bWJlci5pc0ludGVnZXIodCkpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBheGlzIHRvIGJlIGFuIGFycmF5IG9mIGludGVnZXJzLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmF4aXMpfWApfWVsc2UgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBheGlzIHRvIGJlIGFuIGludGVnZXIgb3IgYW4gYXJyYXkgb2YgaW50ZWdlcnMsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHRoaXMuYXhpcyl9YCk7dGhpcy5lcHNpbG9uPWUuZXBzaWxvbj09bnVsbD8uMDAxOmUuZXBzaWxvbix0aGlzLmNlbnRlcj1lLmNlbnRlcj09bnVsbD8hMDplLmNlbnRlcix0aGlzLnNjYWxlPWUuc2NhbGU9PW51bGw/ITA6ZS5zY2FsZSx0aGlzLmJldGFJbml0aWFsaXplcj1TdChlLmJldGFJbml0aWFsaXplcnx8XCJ6ZXJvc1wiKSx0aGlzLmdhbW1hSW5pdGlhbGl6ZXI9U3QoZS5nYW1tYUluaXRpYWxpemVyfHxcIm9uZXNcIiksdGhpcy5iZXRhUmVndWxhcml6ZXI9TnQoZS5iZXRhUmVndWxhcml6ZXIpLHRoaXMuZ2FtbWFSZWd1bGFyaXplcj1OdChlLmdhbW1hUmVndWxhcml6ZXIpLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwfWJ1aWxkKGUpe2U9SmUoZSk7bGV0IHQ9ZS5sZW5ndGg7dHlwZW9mIHRoaXMuYXhpcz09XCJudW1iZXJcIiYmKHRoaXMuYXhpcz1bdGhpcy5heGlzXSk7Zm9yKGxldCByPTA7cjx0aGlzLmF4aXMubGVuZ3RoOysrcil0aGlzLmF4aXNbcl08MCYmKHRoaXMuYXhpc1tyXSs9dCk7Zm9yKGxldCByIG9mIHRoaXMuYXhpcylpZihyPDB8fHI+PXQpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF4aXM6ICR7cn1gKTtpZih0aGlzLmF4aXMubGVuZ3RoIT09YXModGhpcy5heGlzKS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBkdXBsaWNhdGUgYXhlcyBpbjogJHt0aGlzLmF4aXN9YCk7bGV0IG49dGhpcy5heGlzLm1hcChyPT5lW3JdKSxhPSEwO3RoaXMuc2NhbGU/dGhpcy5nYW1tYT10aGlzLmFkZFdlaWdodChcImdhbW1hXCIsbixcImZsb2F0MzJcIix0aGlzLmdhbW1hSW5pdGlhbGl6ZXIsdGhpcy5nYW1tYVJlZ3VsYXJpemVyLGEpOnRoaXMuZ2FtbWE9bnVsbCx0aGlzLmNlbnRlcj90aGlzLmJldGE9dGhpcy5hZGRXZWlnaHQoXCJiZXRhXCIsbixcImZsb2F0MzJcIix0aGlzLmJldGFJbml0aWFsaXplcix0aGlzLmJldGFSZWd1bGFyaXplcixhKTp0aGlzLmJldGE9bnVsbCx0aGlzLmJ1aWx0PSEwfWNhbGwoZSx0KXtsZXQgbj1UZShlKSxhPW4uc2hhcGUscj1hLmxlbmd0aDtyZXR1cm4gTygoKT0+e2xldHttZWFuOnMsdmFyaWFuY2U6aX09aGQobix0aGlzLmF4aXMsITApLG89YmkoMSxyKTtmb3IobGV0IGggb2YgdGhpcy5heGlzKW9baF09YVtoXTtsZXQgbD1oPT5oIT1udWxsJiZoLnNoYXBlLmxlbmd0aCE9PXI/VyhoLG8pOmgsdT10aGlzLnNjYWxlP2wodGhpcy5nYW1tYS5yZWFkKCkpOm51bGwscD10aGlzLmNlbnRlcj9sKHRoaXMuYmV0YS5yZWFkKCkpOm51bGwsZD1bXSxjPVtdO2ZvcihsZXQgaD0wO2g8cjsrK2gpdGhpcy5heGlzLmluZGV4T2YoaCkhPT0tMT8oZC5wdXNoKGFbaF0pLGMucHVzaCgxKSk6KGQucHVzaCgxKSxjLnB1c2goYVtoXSkpO3JldHVybiBzPU9uKHMsZCksaT1PbihpLGQpLHUhPW51bGwmJih1PU9uKHUsYykpLHAhPW51bGwmJihwPU9uKHAsYykpLFNjKG4scyxpLHAsdSx0aGlzLmVwc2lsb24pfSl9Z2V0Q29uZmlnKCl7bGV0IGU9e2F4aXM6dGhpcy5heGlzLGVwc2lsb246dGhpcy5lcHNpbG9uLGNlbnRlcjp0aGlzLmNlbnRlcixzY2FsZTp0aGlzLnNjYWxlLGJldGFJbml0aWFsaXplcjpFdCh0aGlzLmJldGFJbml0aWFsaXplciksZ2FtbWFJbml0aWFsaXplcjpFdCh0aGlzLmdhbW1hSW5pdGlhbGl6ZXIpLGJldGFSZWd1bGFyaXplcjpmdCh0aGlzLmJldGFSZWd1bGFyaXplciksZ2FtbWFSZWd1bGFyaXplcjpmdCh0aGlzLmdhbW1hUmVndWxhcml6ZXIpfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O28xLmNsYXNzTmFtZT1cIkxheWVyTm9ybWFsaXphdGlvblwiO25lLnJlZ2lzdGVyQ2xhc3MobzEpO2Z1bmN0aW9uIElqKGUsdCxuKXtyZXR1cm4gTygoKT0+e2lmKGUucmFuayE9PTQpdGhyb3cgbmV3IFYoYHRlbXBvcmFsUGFkZGluZyBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSA0LUQsIGJ1dCByZWNlaXZlZCBhICR7ZS5yYW5rfS1EIHRlbnNvci5gKTtpZih0PT1udWxsJiYodD1bWzEsMV0sWzEsMV1dKSx0Lmxlbmd0aCE9PTJ8fHRbMF0ubGVuZ3RoIT09Mnx8dFsxXS5sZW5ndGghPT0yKXRocm93IG5ldyBWKFwic3BhdGlhbDJkUGFkZGluZyBleHBlY3RzIGBwYWRkaW5nYCB0byBiZSBhbiBBcnJheSBvZiB0d28gQXJyYXlzLCBlYWNoIG9mIHdoaWNoIGlzIGFuIEFycmF5IG9mIHR3byBpbnRlZ2Vycy5cIik7aWYobj09bnVsbCYmKG49R2EoKSksbiE9PVwiY2hhbm5lbHNMYXN0XCImJm4hPT1cImNoYW5uZWxzRmlyc3RcIil0aHJvdyBuZXcgVihgVW5rbm93biBkYXRhIGZvcm1hdDogJHtufS4gU3VwcG9ydGVkIGRhdGEgZm9ybWF0cyBhcmUgJ2NoYW5uZWxzTGFzdCcgYW5kICdjaGFubmVsc0ZpcnN0LmApO2xldCBhO3JldHVybiBuPT09XCJjaGFubmVsc0ZpcnN0XCI/YT1bWzAsMF0sWzAsMF0sdFswXSx0WzFdXTphPVtbMCwwXSx0WzBdLHRbMV0sWzAsMF1dLHhhKGUsYSl9KX12YXIgbDE9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihlPT1udWxsJiYoZT17fSksc3VwZXIoZSksdGhpcy5kYXRhRm9ybWF0PWUuZGF0YUZvcm1hdD09bnVsbD9HYSgpOmUuZGF0YUZvcm1hdCxlLnBhZGRpbmc9PW51bGwpdGhpcy5wYWRkaW5nPVtbMSwxXSxbMSwxXV07ZWxzZSBpZih0eXBlb2YgZS5wYWRkaW5nPT1cIm51bWJlclwiKXRoaXMucGFkZGluZz1bW2UucGFkZGluZyxlLnBhZGRpbmddLFtlLnBhZGRpbmcsZS5wYWRkaW5nXV07ZWxzZXtpZihlLnBhZGRpbmc9ZS5wYWRkaW5nLGUucGFkZGluZy5sZW5ndGghPT0yKXRocm93IG5ldyBWKGBaZXJvUGFkZGluZzJEIGV4cGVjdHMgcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtJHtlLnBhZGRpbmcubGVuZ3RofSBhcnJheS5gKTtsZXQgdCxuO2lmKHR5cGVvZiBlLnBhZGRpbmdbMF09PVwibnVtYmVyXCIpdD1bZS5wYWRkaW5nWzBdLGUucGFkZGluZ1swXV0sbj1bZS5wYWRkaW5nWzFdLGUucGFkZGluZ1sxXV07ZWxzZXtpZihlLnBhZGRpbmc9ZS5wYWRkaW5nLGUucGFkZGluZ1swXS5sZW5ndGghPT0yKXRocm93IG5ldyBWKGBaZXJvUGFkZGluZzJEIGV4cGVjdHMgaGVpZ2h0IHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLSR7ZS5wYWRkaW5nWzBdLmxlbmd0aH0gYXJyYXkuYCk7aWYodD1lLnBhZGRpbmdbMF0sZS5wYWRkaW5nWzFdLmxlbmd0aCE9PTIpdGhyb3cgbmV3IFYoYFplcm9QYWRkaW5nMkQgZXhwZWN0cyB3aWR0aCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGJ1dCByZWNlaXZlZCBhIGxlbmd0aC0ke2UucGFkZGluZ1sxXS5sZW5ndGh9IGFycmF5LmApO249ZS5wYWRkaW5nWzFdfXRoaXMucGFkZGluZz1bdCxuXX10aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjR9KV19Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQsbjtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/KGVbMl0hPW51bGwmJmVbMl0+PTA/dD1lWzJdK3RoaXMucGFkZGluZ1swXVswXSt0aGlzLnBhZGRpbmdbMF1bMV06dD1udWxsLGVbM10hPW51bGwmJmVbM10+PTA/bj1lWzNdK3RoaXMucGFkZGluZ1sxXVswXSt0aGlzLnBhZGRpbmdbMV1bMV06bj1udWxsLFtlWzBdLGVbMV0sdCxuXSk6KGVbMV0hPW51bGwmJmVbMV0+PTA/dD1lWzFdK3RoaXMucGFkZGluZ1swXVswXSt0aGlzLnBhZGRpbmdbMF1bMV06dD1udWxsLGVbMl0hPW51bGwmJmVbMl0+PTA/bj1lWzJdK3RoaXMucGFkZGluZ1sxXVswXSt0aGlzLnBhZGRpbmdbMV1bMV06bj1udWxsLFtlWzBdLHQsbixlWzNdXSl9Y2FsbChlLHQpe3JldHVybiBPKCgpPT5JaihUZShlKSx0aGlzLnBhZGRpbmcsdGhpcy5kYXRhRm9ybWF0KSl9Z2V0Q29uZmlnKCl7bGV0IGU9e3BhZGRpbmc6dGhpcy5wYWRkaW5nLGRhdGFGb3JtYXQ6dGhpcy5kYXRhRm9ybWF0fSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O2wxLmNsYXNzTmFtZT1cIlplcm9QYWRkaW5nMkRcIjtuZS5yZWdpc3RlckNsYXNzKGwxKTtmdW5jdGlvbiBQZihlLHQsbixhLHIscyl7cmV0dXJuIE8oKCk9PntSdChyKSxnMihzKSx2YShhKSxuPT1udWxsJiYobj1bMSwxXSksYT09bnVsbCYmKGE9XCJ2YWxpZFwiKSxyPT1udWxsJiYocj1HYSgpKSxzPT1udWxsJiYocz1cIm1heFwiKSxlPV8wKGUscik7bGV0IGksbz1hPT09XCJzYW1lXCI/XCJzYW1lXCI6XCJ2YWxpZFwiO3JldHVybiBzPT09XCJtYXhcIj9pPUR0KGUsdCxuLG8pOmk9eWEoZSx0LG4sbykscj09PVwiY2hhbm5lbHNGaXJzdFwiJiYoaT1EZShpLFswLDMsMSwyXSkpLGl9KX1mdW5jdGlvbiB3QyhlLHQsbixhLHIscyl7cmV0dXJuIE8oKCk9PntSdChyKSxnMihzKSx2YShhKSxuPT1udWxsJiYobj1bMSwxLDFdKSxhPT1udWxsJiYoYT1cInZhbGlkXCIpLHI9PW51bGwmJihyPUdhKCkpLHM9PW51bGwmJihzPVwibWF4XCIpLGU9dUMoZSxyKTtsZXQgaSxvPWE9PT1cInNhbWVcIj9cInNhbWVcIjpcInZhbGlkXCI7cmV0dXJuIHM9PT1cIm1heFwiP2k9eHcoZSx0LG4sbyk6aT1qdihlLHQsbixvKSxyPT09XCJjaGFubmVsc0ZpcnN0XCImJihpPURlKGksWzAsNCwxLDIsM10pKSxpfSl9dmFyIGtDPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoZS5wb29sU2l6ZT09bnVsbCYmKGUucG9vbFNpemU9Miksc3VwZXIoZSksdHlwZW9mIGUucG9vbFNpemU9PVwibnVtYmVyXCIpdGhpcy5wb29sU2l6ZT1bZS5wb29sU2l6ZV07ZWxzZSBpZihBcnJheS5pc0FycmF5KGUucG9vbFNpemUpJiZlLnBvb2xTaXplLmxlbmd0aD09PTEmJnR5cGVvZiBlLnBvb2xTaXplWzBdPT1cIm51bWJlclwiKXRoaXMucG9vbFNpemU9ZS5wb29sU2l6ZTtlbHNlIHRocm93IG5ldyBWKGBwb29sU2l6ZSBmb3IgMUQgY29udm9sdXRpb25hbCBsYXllciBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIEFycmF5IG9mIGEgc2luZ2xlIG51bWJlciwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoZS5wb29sU2l6ZSl9YCk7aWYodG4odGhpcy5wb29sU2l6ZSxcInBvb2xTaXplXCIpLGUuc3RyaWRlcz09bnVsbCl0aGlzLnN0cmlkZXM9dGhpcy5wb29sU2l6ZTtlbHNlIGlmKHR5cGVvZiBlLnN0cmlkZXM9PVwibnVtYmVyXCIpdGhpcy5zdHJpZGVzPVtlLnN0cmlkZXNdO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShlLnN0cmlkZXMpJiZlLnN0cmlkZXMubGVuZ3RoPT09MSYmdHlwZW9mIGUuc3RyaWRlc1swXT09XCJudW1iZXJcIil0aGlzLnN0cmlkZXM9ZS5zdHJpZGVzO2Vsc2UgdGhyb3cgbmV3IFYoYHN0cmlkZXMgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGUuc3RyaWRlcyl9YCk7dG4odGhpcy5zdHJpZGVzLFwic3RyaWRlc1wiKSx0aGlzLnBhZGRpbmc9ZS5wYWRkaW5nPT1udWxsP1widmFsaWRcIjplLnBhZGRpbmcsdmEodGhpcy5wYWRkaW5nKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjN9KV19Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9VmEoZVsxXSx0aGlzLnBvb2xTaXplWzBdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMF0pO3JldHVybltlWzBdLHQsZVsyXV19Y2FsbChlLHQpe3JldHVybiBPKCgpPT57dGhpcy5pbnZva2VDYWxsSG9vayhlLHQpLGU9d2QoVGUoZSksMik7bGV0IG49dGhpcy5wb29saW5nRnVuY3Rpb24oVGUoZSksW3RoaXMucG9vbFNpemVbMF0sMV0sW3RoaXMuc3RyaWRlc1swXSwxXSx0aGlzLnBhZGRpbmcsXCJjaGFubmVsc0xhc3RcIik7cmV0dXJuIEFzKG4sWzJdKX0pfWdldENvbmZpZygpe2xldCBlPXtwb29sU2l6ZTp0aGlzLnBvb2xTaXplLHBhZGRpbmc6dGhpcy5wYWRkaW5nLHN0cmlkZXM6dGhpcy5zdHJpZGVzfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19LHUxPWNsYXNzIGV4dGVuZHMga0N7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9cG9vbGluZ0Z1bmN0aW9uKGUsdCxuLGEscil7cmV0dXJuIFJ0KHIpLHZhKGEpLFBmKGUsdCxuLGEscixcIm1heFwiKX19O3UxLmNsYXNzTmFtZT1cIk1heFBvb2xpbmcxRFwiO25lLnJlZ2lzdGVyQ2xhc3ModTEpO3ZhciBwMT1jbGFzcyBleHRlbmRzIGtDe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfXBvb2xpbmdGdW5jdGlvbihlLHQsbixhLHIpe3JldHVybiBSdChyKSx2YShhKSxQZihlLHQsbixhLHIsXCJhdmdcIil9fTtwMS5jbGFzc05hbWU9XCJBdmVyYWdlUG9vbGluZzFEXCI7bmUucmVnaXN0ZXJDbGFzcyhwMSk7dmFyIElDPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7aWYoZS5wb29sU2l6ZT09bnVsbCYmKGUucG9vbFNpemU9WzIsMl0pLHN1cGVyKGUpLHRoaXMucG9vbFNpemU9QXJyYXkuaXNBcnJheShlLnBvb2xTaXplKT9lLnBvb2xTaXplOltlLnBvb2xTaXplLGUucG9vbFNpemVdLGUuc3RyaWRlcz09bnVsbCl0aGlzLnN0cmlkZXM9dGhpcy5wb29sU2l6ZTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZS5zdHJpZGVzKSl7aWYoZS5zdHJpZGVzLmxlbmd0aCE9PTIpdGhyb3cgbmV3IFYoYElmIHRoZSBzdHJpZGVzIHByb3BlcnR5IG9mIGEgMkQgcG9vbGluZyBsYXllciBpcyBhbiBBcnJheSwgaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGxlbmd0aCBvZiAyLCBidXQgcmVjZWl2ZWQgbGVuZ3RoICR7ZS5zdHJpZGVzLmxlbmd0aH0uYCk7dGhpcy5zdHJpZGVzPWUuc3RyaWRlc31lbHNlIHRoaXMuc3RyaWRlcz1bZS5zdHJpZGVzLGUuc3RyaWRlc107dG4odGhpcy5wb29sU2l6ZSxcInBvb2xTaXplXCIpLHRuKHRoaXMuc3RyaWRlcyxcInN0cmlkZXNcIiksdGhpcy5wYWRkaW5nPWUucGFkZGluZz09bnVsbD9cInZhbGlkXCI6ZS5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdD1lLmRhdGFGb3JtYXQ9PW51bGw/XCJjaGFubmVsc0xhc3RcIjplLmRhdGFGb3JtYXQsUnQodGhpcy5kYXRhRm9ybWF0KSx2YSh0aGlzLnBhZGRpbmcpLHRoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06NH0pXX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtsZXQgdD10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9lWzJdOmVbMV0sbj10aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9lWzNdOmVbMl07cmV0dXJuIHQ9VmEodCx0aGlzLnBvb2xTaXplWzBdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMF0pLG49VmEobix0aGlzLnBvb2xTaXplWzFdLHRoaXMucGFkZGluZyx0aGlzLnN0cmlkZXNbMV0pLHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNGaXJzdFwiP1tlWzBdLGVbMV0sdCxuXTpbZVswXSx0LG4sZVszXV19Y2FsbChlLHQpe3JldHVybiBPKCgpPT4odGhpcy5pbnZva2VDYWxsSG9vayhlLHQpLHRoaXMucG9vbGluZ0Z1bmN0aW9uKFRlKGUpLHRoaXMucG9vbFNpemUsdGhpcy5zdHJpZGVzLHRoaXMucGFkZGluZyx0aGlzLmRhdGFGb3JtYXQpKSl9Z2V0Q29uZmlnKCl7bGV0IGU9e3Bvb2xTaXplOnRoaXMucG9vbFNpemUscGFkZGluZzp0aGlzLnBhZGRpbmcsc3RyaWRlczp0aGlzLnN0cmlkZXMsZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX0sYzE9Y2xhc3MgZXh0ZW5kcyBJQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1wb29saW5nRnVuY3Rpb24oZSx0LG4sYSxyKXtyZXR1cm4gUnQociksdmEoYSksUGYoZSx0LG4sYSxyLFwibWF4XCIpfX07YzEuY2xhc3NOYW1lPVwiTWF4UG9vbGluZzJEXCI7bmUucmVnaXN0ZXJDbGFzcyhjMSk7dmFyIGQxPWNsYXNzIGV4dGVuZHMgSUN7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9cG9vbGluZ0Z1bmN0aW9uKGUsdCxuLGEscil7cmV0dXJuIFJ0KHIpLHZhKGEpLFBmKGUsdCxuLGEscixcImF2Z1wiKX19O2QxLmNsYXNzTmFtZT1cIkF2ZXJhZ2VQb29saW5nMkRcIjtuZS5yZWdpc3RlckNsYXNzKGQxKTt2YXIgU0M9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihlLnBvb2xTaXplPT1udWxsJiYoZS5wb29sU2l6ZT1bMiwyLDJdKSxzdXBlcihlKSx0aGlzLnBvb2xTaXplPUFycmF5LmlzQXJyYXkoZS5wb29sU2l6ZSk/ZS5wb29sU2l6ZTpbZS5wb29sU2l6ZSxlLnBvb2xTaXplLGUucG9vbFNpemVdLGUuc3RyaWRlcz09bnVsbCl0aGlzLnN0cmlkZXM9dGhpcy5wb29sU2l6ZTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZS5zdHJpZGVzKSl7aWYoZS5zdHJpZGVzLmxlbmd0aCE9PTMpdGhyb3cgbmV3IFYoYElmIHRoZSBzdHJpZGVzIHByb3BlcnR5IG9mIGEgM0QgcG9vbGluZyBsYXllciBpcyBhbiBBcnJheSwgaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGxlbmd0aCBvZiAzLCBidXQgcmVjZWl2ZWQgbGVuZ3RoICR7ZS5zdHJpZGVzLmxlbmd0aH0uYCk7dGhpcy5zdHJpZGVzPWUuc3RyaWRlc31lbHNlIHRoaXMuc3RyaWRlcz1bZS5zdHJpZGVzLGUuc3RyaWRlcyxlLnN0cmlkZXNdO3RuKHRoaXMucG9vbFNpemUsXCJwb29sU2l6ZVwiKSx0bih0aGlzLnN0cmlkZXMsXCJzdHJpZGVzXCIpLHRoaXMucGFkZGluZz1lLnBhZGRpbmc9PW51bGw/XCJ2YWxpZFwiOmUucGFkZGluZyx0aGlzLmRhdGFGb3JtYXQ9ZS5kYXRhRm9ybWF0PT1udWxsP1wiY2hhbm5lbHNMYXN0XCI6ZS5kYXRhRm9ybWF0LFJ0KHRoaXMuZGF0YUZvcm1hdCksdmEodGhpcy5wYWRkaW5nKSx0aGlzLmlucHV0U3BlYz1bbmV3IHp0KHtuZGltOjV9KV19Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVsyXTplWzFdLG49dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVszXTplWzJdLGE9dGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0ZpcnN0XCI/ZVs0XTplWzNdO3JldHVybiB0PVZhKHQsdGhpcy5wb29sU2l6ZVswXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzBdKSxuPVZhKG4sdGhpcy5wb29sU2l6ZVsxXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzFdKSxhPVZhKGEsdGhpcy5wb29sU2l6ZVsyXSx0aGlzLnBhZGRpbmcsdGhpcy5zdHJpZGVzWzJdKSx0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzRmlyc3RcIj9bZVswXSxlWzFdLHQsbixhXTpbZVswXSx0LG4sYSxlWzRdXX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9Pih0aGlzLmludm9rZUNhbGxIb29rKGUsdCksdGhpcy5wb29saW5nRnVuY3Rpb24oVGUoZSksdGhpcy5wb29sU2l6ZSx0aGlzLnN0cmlkZXMsdGhpcy5wYWRkaW5nLHRoaXMuZGF0YUZvcm1hdCkpKX1nZXRDb25maWcoKXtsZXQgZT17cG9vbFNpemU6dGhpcy5wb29sU2l6ZSxwYWRkaW5nOnRoaXMucGFkZGluZyxzdHJpZGVzOnRoaXMuc3RyaWRlcyxkYXRhRm9ybWF0OnRoaXMuZGF0YUZvcm1hdH0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9fSxoMT1jbGFzcyBleHRlbmRzIFNDe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfXBvb2xpbmdGdW5jdGlvbihlLHQsbixhLHIpe3JldHVybiBSdChyKSx2YShhKSx3QyhlLHQsbixhLHIsXCJtYXhcIil9fTtoMS5jbGFzc05hbWU9XCJNYXhQb29saW5nM0RcIjtuZS5yZWdpc3RlckNsYXNzKGgxKTt2YXIgbTE9Y2xhc3MgZXh0ZW5kcyBTQ3tjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1wb29saW5nRnVuY3Rpb24oZSx0LG4sYSxyKXtyZXR1cm4gUnQociksdmEoYSksd0MoZSx0LG4sYSxyLFwiYXZnXCIpfX07bTEuY2xhc3NOYW1lPVwiQXZlcmFnZVBvb2xpbmczRFwiO25lLnJlZ2lzdGVyQ2xhc3MobTEpO3ZhciBOQz1jbGFzcyBleHRlbmRzIFdle2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuaW5wdXRTcGVjPVtuZXcgenQoe25kaW06M30pXX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuW2VbMF0sZVsyXV19Y2FsbChlLHQpe3Rocm93IG5ldyB6ZX19LGYxPWNsYXNzIGV4dGVuZHMgTkN7Y29uc3RydWN0b3IoZSl7c3VwZXIoZXx8e30pfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpO3JldHVybiBDdChuLDEpfSl9fTtmMS5jbGFzc05hbWU9XCJHbG9iYWxBdmVyYWdlUG9vbGluZzFEXCI7bmUucmVnaXN0ZXJDbGFzcyhmMSk7dmFyIGcxPWNsYXNzIGV4dGVuZHMgTkN7Y29uc3RydWN0b3IoZSl7c3VwZXIoZXx8e30pfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpO3JldHVybiBtYShuLDEpfSl9fTtnMS5jbGFzc05hbWU9XCJHbG9iYWxNYXhQb29saW5nMURcIjtuZS5yZWdpc3RlckNsYXNzKGcxKTt2YXIgVEM9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLmRhdGFGb3JtYXQ9ZS5kYXRhRm9ybWF0PT1udWxsP1wiY2hhbm5lbHNMYXN0XCI6ZS5kYXRhRm9ybWF0LFJ0KHRoaXMuZGF0YUZvcm1hdCksdGhpcy5pbnB1dFNwZWM9W25ldyB6dCh7bmRpbTo0fSldfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtyZXR1cm4gZT1lLHRoaXMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCI/W2VbMF0sZVszXV06W2VbMF0sZVsxXV19Y2FsbChlLHQpe3Rocm93IG5ldyB6ZX1nZXRDb25maWcoKXtsZXQgZT17ZGF0YUZvcm1hdDp0aGlzLmRhdGFGb3JtYXR9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfX0sYjE9Y2xhc3MgZXh0ZW5kcyBUQ3tjYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKTtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIj9DdChuLFsxLDJdKTpDdChuLFsyLDNdKX0pfX07YjEuY2xhc3NOYW1lPVwiR2xvYmFsQXZlcmFnZVBvb2xpbmcyRFwiO25lLnJlZ2lzdGVyQ2xhc3MoYjEpO3ZhciB5MT1jbGFzcyBleHRlbmRzIFRDe2NhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpO3JldHVybiB0aGlzLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiP21hKG4sWzEsMl0pOm1hKG4sWzIsM10pfSl9fTt5MS5jbGFzc05hbWU9XCJHbG9iYWxNYXhQb29saW5nMkRcIjtuZS5yZWdpc3RlckNsYXNzKHkxKTt2YXIgQ0M9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLmxheWVyPWUubGF5ZXJ9YnVpbGQoZSl7dGhpcy5idWlsdD0hMH1nZXQgdHJhaW5hYmxlKCl7cmV0dXJuIHRoaXMubGF5ZXIhPW51bGw/dGhpcy5sYXllci50cmFpbmFibGU6ITF9c2V0IHRyYWluYWJsZShlKXt0aGlzLmxheWVyIT1udWxsJiYodGhpcy5sYXllci50cmFpbmFibGU9ZSl9Z2V0IHRyYWluYWJsZVdlaWdodHMoKXtyZXR1cm4gdGhpcy5sYXllci50cmFpbmFibGVXZWlnaHRzfWdldCBub25UcmFpbmFibGVXZWlnaHRzKCl7cmV0dXJuIHRoaXMubGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0c31nZXQgdXBkYXRlcygpe3JldHVybiB0aGlzLmxheWVyLl91cGRhdGVzfWdldCBsb3NzZXMoKXtyZXR1cm4gdGhpcy5sYXllci5sb3NzZXN9Z2V0V2VpZ2h0cygpe3JldHVybiB0aGlzLmxheWVyLmdldFdlaWdodHMoKX1zZXRXZWlnaHRzKGUpe3RoaXMubGF5ZXIuc2V0V2VpZ2h0cyhlKX1nZXRDb25maWcoKXtsZXQgZT17bGF5ZXI6e2NsYXNzTmFtZTp0aGlzLmxheWVyLmdldENsYXNzTmFtZSgpLGNvbmZpZzp0aGlzLmxheWVyLmdldENvbmZpZygpfX0sdD1zdXBlci5nZXRDb25maWcoKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHQpLGV9c2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChlKXtzdXBlci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKGUpLHRoaXMubGF5ZXIhPW51bGwmJnRoaXMubGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChlKX1zdGF0aWMgZnJvbUNvbmZpZyhlLHQsbj17fSl7bGV0IGE9dC5sYXllcixyPUJhKGEsbik7ZGVsZXRlIHQubGF5ZXI7bGV0IHM9e2xheWVyOnJ9O3JldHVybiBPYmplY3QuYXNzaWduKHMsdCksbmV3IGUocyl9fSx4MT1jbGFzcyBleHRlbmRzIENDe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpLHRoaXMuc3VwcG9ydHNNYXNraW5nPSEwfWJ1aWxkKGUpe2lmKGU9SmUoZSksZS5sZW5ndGg8Myl0aHJvdyBuZXcgVihgVGltZURpc3RyaWJ1dGVkIGxheWVyIGV4cGVjdHMgYW4gaW5wdXQgc2hhcGUgPj0gM0QsIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZSAke0pTT04uc3RyaW5naWZ5KGUpfWApO3RoaXMuaW5wdXRTcGVjPVt7c2hhcGU6ZX1dO2xldCB0PVtlWzBdXS5jb25jYXQoZS5zbGljZSgyKSk7dGhpcy5sYXllci5idWlsdHx8KHRoaXMubGF5ZXIuYnVpbGQodCksdGhpcy5sYXllci5idWlsdD0hMCksc3VwZXIuYnVpbGQoZSl9Y29tcHV0ZU91dHB1dFNoYXBlKGUpe2U9SmUoZSk7bGV0IHQ9W2VbMF1dLmNvbmNhdChlLnNsaWNlKDIpKSxuPXRoaXMubGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKHQpLGE9ZVsxXTtyZXR1cm5bblswXSxhXS5jb25jYXQobi5zbGljZSgxKSl9Y2FsbChlLHQpe3JldHVybiBPKCgpPT4oZT1UZShlKSx5QygobixhKT0+W1RlKHRoaXMubGF5ZXIuY2FsbChuLHQpKSxbXV0sZSxbXSwhMSxudWxsLG51bGwsITEsITApWzFdKSl9fTt4MS5jbGFzc05hbWU9XCJUaW1lRGlzdHJpYnV0ZWRcIjtuZS5yZWdpc3RlckNsYXNzKHgxKTtmdW5jdGlvbiBTaihlKXtLbyhJRyxcIkJpZGlyZWN0aW9uYWxNZXJnZU1vZGVcIixlKX12YXIgTmo9XCJjb25jYXRcIix2MT1jbGFzcyBleHRlbmRzIENDe2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2xldCB0PWUubGF5ZXIuZ2V0Q29uZmlnKCksbj17fTtuLmNsYXNzTmFtZT1lLmxheWVyLmdldENsYXNzTmFtZSgpLG4uY29uZmlnPXQsdGhpcy5mb3J3YXJkTGF5ZXI9QmEobiksdC5nb0JhY2t3YXJkcz10LmdvQmFja3dhcmRzIT09ITA7bGV0IGE9e307aWYoYS5jbGFzc05hbWU9ZS5sYXllci5nZXRDbGFzc05hbWUoKSxhLmNvbmZpZz10LHRoaXMuYmFja3dhcmRMYXllcj1CYShhKSx0aGlzLmZvcndhcmRMYXllci5uYW1lPVwiZm9yd2FyZF9cIit0aGlzLmZvcndhcmRMYXllci5uYW1lLHRoaXMuYmFja3dhcmRMYXllci5uYW1lPVwiYmFja3dhcmRfXCIrdGhpcy5iYWNrd2FyZExheWVyLm5hbWUsdGhpcy5tZXJnZU1vZGU9ZS5tZXJnZU1vZGU9PT12b2lkIDA/Tmo6ZS5tZXJnZU1vZGUsU2oodGhpcy5tZXJnZU1vZGUpLGUud2VpZ2h0cyl0aHJvdyBuZXcgemUoXCJ3ZWlnaHRzIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkIGZvciBCaWRpcmVjdGlvbmFsIGxheWVyIHlldC5cIik7dGhpcy5fc3RhdGVmdWw9ZS5sYXllci5zdGF0ZWZ1bCx0aGlzLnJldHVyblNlcXVlbmNlcz1lLmxheWVyLnJldHVyblNlcXVlbmNlcyx0aGlzLnJldHVyblN0YXRlPWUubGF5ZXIucmV0dXJuU3RhdGUsdGhpcy5zdXBwb3J0c01hc2tpbmc9ITAsdGhpcy5fdHJhaW5hYmxlPSEwLHRoaXMuaW5wdXRTcGVjPWUubGF5ZXIuaW5wdXRTcGVjLHRoaXMubnVtQ29uc3RhbnRzPW51bGx9Z2V0IHRyYWluYWJsZSgpe3JldHVybiB0aGlzLl90cmFpbmFibGV9c2V0IHRyYWluYWJsZShlKXt0aGlzLl90cmFpbmFibGU9ZSx0aGlzLmZvcndhcmRMYXllciE9bnVsbCYmKHRoaXMuZm9yd2FyZExheWVyLnRyYWluYWJsZT1lKSx0aGlzLmJhY2t3YXJkTGF5ZXIhPW51bGwmJih0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlPWUpfWdldFdlaWdodHMoKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIuZ2V0V2VpZ2h0cygpLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIuZ2V0V2VpZ2h0cygpKX1zZXRXZWlnaHRzKGUpe2xldCB0PWUubGVuZ3RoLG49TWF0aC5mbG9vcih0LzIpO3RoaXMuZm9yd2FyZExheWVyLnNldFdlaWdodHMoZS5zbGljZSgwLG4pKSx0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0V2VpZ2h0cyhlLnNsaWNlKG4pKX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7bGV0IHQ9dGhpcy5mb3J3YXJkTGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKGUpO0FycmF5LmlzQXJyYXkodCkmJkFycmF5LmlzQXJyYXkodFswXSl8fCh0PVt0XSksdD10O2xldCBuLGEscjtyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZSYmKHI9dC5zbGljZSgxKSksbj10WzBdLG49bix0aGlzLm1lcmdlTW9kZT09PVwiY29uY2F0XCI/KG5bbi5sZW5ndGgtMV0qPTIsYT1bbl0pOnRoaXMubWVyZ2VNb2RlPT1udWxsP2E9W24sbi5zbGljZSgpXTphPVtuXSx0aGlzLnJldHVyblN0YXRlP3RoaXMubWVyZ2VNb2RlPT1udWxsP2EuY29uY2F0KHIpLmNvbmNhdChyLnNsaWNlKCkpOltuXS5jb25jYXQocikuY29uY2F0KHIuc2xpY2UoKSk6TW4oYSl9YXBwbHkoZSx0KXtsZXQgbj10PT1udWxsP251bGw6dC5pbml0aWFsU3RhdGUsYT10PT1udWxsP251bGw6dC5jb25zdGFudHM7dD09bnVsbCYmKHQ9e30pO2xldCByPWJDKGUsbixhLHRoaXMubnVtQ29uc3RhbnRzKTtpZihlPXIuaW5wdXRzLG49ci5pbml0aWFsU3RhdGUsYT1yLmNvbnN0YW50cyxBcnJheS5pc0FycmF5KGUpJiYobj1lLnNsaWNlKDEpLGU9ZVswXSksKG49PW51bGx8fG4ubGVuZ3RoPT09MCkmJmE9PW51bGwpcmV0dXJuIHN1cGVyLmFwcGx5KGUsdCk7bGV0IHM9W10saT1bXTtpZihuIT1udWxsKXtsZXQgbD1uLmxlbmd0aDtpZihsJTI+MCl0aHJvdyBuZXcgVihcIldoZW4gcGFzc2luZyBgaW5pdGlhbFN0YXRlYCB0byBhIEJpZHJlY3Rpb25hbCBSTk4sIHRoZSBzdGF0ZSBzaG91bGQgYmUgYW4gQXJyYXkgY29udGFpbmluZyB0aGUgc3RhdGVzIG9mIHRoZSB1bmRlcmx5aW5nIFJOTnMuXCIpO3QuaW5pdGlhbFN0YXRlPW4scy5wdXNoKC4uLm4pO2xldCB1PW4ubWFwKHA9Pm5ldyB6dCh7c2hhcGU6cC5zaGFwZX0pKTt0aGlzLmZvcndhcmRMYXllci5zdGF0ZVNwZWM9dS5zbGljZSgwLGwvMiksdGhpcy5iYWNrd2FyZExheWVyLnN0YXRlU3BlYz11LnNsaWNlKGwvMiksaS5wdXNoKC4uLnUpfWlmKGEhPW51bGwpdGhyb3cgbmV3IHplKFwiU3VwcG9ydCBmb3IgY29uc3RhbnRzIGluIEJpZGlyZWN0aW9uYWwgbGF5ZXJzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXCIpO2xldCBvPXNbMF1pbnN0YW5jZW9mIEhhO2ZvcihsZXQgbCBvZiBzKWlmKGwgaW5zdGFuY2VvZiBIYSE9PW8pdGhyb3cgbmV3IFYoXCJUaGUgaW5pdGlhbCBzdGF0ZSBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgY2Fubm90IGJlIHNwZWNpZmllZCBhcyBhIG1peCBvZiBzeW1ib2xpYyBhbmQgbm9uLXN5bWJvbGljIHRlbnNvcnNcIik7aWYobyl7bGV0IGw9W2VdLmNvbmNhdChzKSx1PXRoaXMuaW5wdXRTcGVjLmNvbmNhdChpKSxwPXRoaXMuaW5wdXRTcGVjO3RoaXMuaW5wdXRTcGVjPXU7bGV0IGQ9c3VwZXIuYXBwbHkobCx0KTtyZXR1cm4gdGhpcy5pbnB1dFNwZWM9cCxkfWVsc2UgcmV0dXJuIHN1cGVyLmFwcGx5KGUsdCl9Y2FsbChlLHQpe3JldHVybiBPKCgpPT57bGV0IG49dC5pbml0aWFsU3RhdGUsYSxyO2lmKG49PW51bGwpYT10aGlzLmZvcndhcmRMYXllci5jYWxsKGUsdCkscj10aGlzLmJhY2t3YXJkTGF5ZXIuY2FsbChlLHQpO2Vsc2V7bGV0IG89bi5zbGljZSgwLG4ubGVuZ3RoLzIpLGw9bi5zbGljZShuLmxlbmd0aC8yKTthPXRoaXMuZm9yd2FyZExheWVyLmNhbGwoZSxPYmplY3QuYXNzaWduKHQse2luaXRpYWxTdGF0ZTpvfSkpLHI9dGhpcy5iYWNrd2FyZExheWVyLmNhbGwoZSxPYmplY3QuYXNzaWduKHQse2luaXRpYWxTdGF0ZTpsfSkpfWxldCBzO3RoaXMucmV0dXJuU3RhdGUmJihBcnJheS5pc0FycmF5KGEpJiYocz1hLnNsaWNlKDEpLmNvbmNhdChyLnNsaWNlKDEpKSksYT1hWzBdLHI9clswXSksdGhpcy5yZXR1cm5TZXF1ZW5jZXMmJihyPWJhKHIsMSkpO2xldCBpO3JldHVybiB0aGlzLm1lcmdlTW9kZT09PVwiY29uY2F0XCI/aT10MChbYSxyXSk6dGhpcy5tZXJnZU1vZGU9PT1cInN1bVwiP2k9WChhLHIpOnRoaXMubWVyZ2VNb2RlPT09XCJhdmVcIj9pPXooLjUsWChhLHIpKTp0aGlzLm1lcmdlTW9kZT09PVwibXVsXCI/aT16KGEscik6dGhpcy5tZXJnZU1vZGU9PW51bGwmJihpPVthLHJdKSx0aGlzLnJldHVyblN0YXRlP3RoaXMubWVyZ2VNb2RlPT1udWxsP2kuY29uY2F0KHMpOltpXS5jb25jYXQocyk6aX0pfXJlc2V0U3RhdGVzKGUpe3RoaXMuZm9yd2FyZExheWVyLnJlc2V0U3RhdGVzKCksdGhpcy5iYWNrd2FyZExheWVyLnJlc2V0U3RhdGVzKCl9YnVpbGQoZSl7cmkodGhpcy5mb3J3YXJkTGF5ZXIubmFtZSwoKT0+e3RoaXMuZm9yd2FyZExheWVyLmJ1aWxkKGUpfSkscmkodGhpcy5iYWNrd2FyZExheWVyLm5hbWUsKCk9Pnt0aGlzLmJhY2t3YXJkTGF5ZXIuYnVpbGQoZSl9KSx0aGlzLmJ1aWx0PSEwfWNvbXB1dGVNYXNrKGUsdCl7QXJyYXkuaXNBcnJheSh0KSYmKHQ9dFswXSk7bGV0IG47aWYodGhpcy5yZXR1cm5TZXF1ZW5jZXM/dGhpcy5tZXJnZU1vZGU9PW51bGw/bj1bdCx0XTpuPXQ6dGhpcy5tZXJnZU1vZGU9PW51bGw/bj1bbnVsbCxudWxsXTpuPW51bGwsdGhpcy5yZXR1cm5TdGF0ZSl7bGV0IGE9dGhpcy5mb3J3YXJkTGF5ZXIuc3RhdGVzLm1hcChyPT5udWxsKTtyZXR1cm4gQXJyYXkuaXNBcnJheShuKT9uLmNvbmNhdChhKS5jb25jYXQoYSk6W25dLmNvbmNhdChhKS5jb25jYXQoYSl9ZWxzZSByZXR1cm4gbn1nZXQgdHJhaW5hYmxlV2VpZ2h0cygpe3JldHVybiB0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlV2VpZ2h0cyl9Z2V0IG5vblRyYWluYWJsZVdlaWdodHMoKXtyZXR1cm4gdGhpcy5mb3J3YXJkTGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5iYWNrd2FyZExheWVyLm5vblRyYWluYWJsZVdlaWdodHMpfXNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQoZSl7c3VwZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChlKSx0aGlzLmZvcndhcmRMYXllciE9bnVsbCYmdGhpcy5mb3J3YXJkTGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChlKSx0aGlzLmJhY2t3YXJkTGF5ZXIhPW51bGwmJnRoaXMuYmFja3dhcmRMYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKGUpfWdldENvbmZpZygpe2xldCBlPXttZXJnZU1vZGU6dGhpcy5tZXJnZU1vZGV9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfXN0YXRpYyBmcm9tQ29uZmlnKGUsdCl7bGV0IG49QmEodC5sYXllcik7aWYoZGVsZXRlIHQubGF5ZXIsdC5udW1Db25zdGFudHMhPW51bGwpdGhyb3cgbmV3IHplKFwiRGVzZXJpYWxpemF0aW9uIG9mIGEgQmlkaXJlY3Rpb25hbCBsYXllciB3aXRoIG51bUNvbnN0YW50cyBwcmVzZW50IGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtsZXQgYT10O3JldHVybiBhLmxheWVyPW4sbmV3IGUoYSl9fTt2MS5jbGFzc05hbWU9XCJCaWRpcmVjdGlvbmFsXCI7bmUucmVnaXN0ZXJDbGFzcyh2MSk7dmFyIHcxPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5zY2FsZT1lLnNjYWxlLGUub2Zmc2V0P3RoaXMub2Zmc2V0PWUub2Zmc2V0OnRoaXMub2Zmc2V0PTB9Z2V0Q29uZmlnKCl7bGV0IGU9e3NjYWxlOnRoaXMuc2NhbGUsb2Zmc2V0OnRoaXMub2Zmc2V0fSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PihlPVRlKGUpLGUuZHR5cGUhPT1cImZsb2F0MzJcIiYmKGU9aXIoZSxcImZsb2F0MzJcIikpLFgoeihlLHRoaXMuc2NhbGUpLHRoaXMub2Zmc2V0KSkpfX07dzEuY2xhc3NOYW1lPVwiUmVzY2FsaW5nXCI7bmUucmVnaXN0ZXJDbGFzcyh3MSk7dmFye3Jlc2l6ZUJpbGluZWFyOlRqLGNyb3BBbmRSZXNpemU6Q2p9PVpuLGsxPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5oZWlnaHQ9ZS5oZWlnaHQsdGhpcy53aWR0aD1lLndpZHRofWNlbnRlckNyb3AoZSx0LG4sYSxyLHMsaSxvKXtyZXR1cm4gTygoKT0+e2xldCBsLHU9ITEscD10L3MsZD1uL2ksYz0oYSt0KS9zLGg9KHIrbikvaSxtPVtwLGQsYyxoXSxmPVtdO2UucmFuaz09PTM/KHU9ITAsbD1BdChbZV0pKTpsPWU7Zm9yKGxldCB4PTA7eDxsLnNoYXBlWzBdO3grKylmLnB1c2gobSk7bGV0IGc9Ym4oZixbZi5sZW5ndGgsNF0pLGI9Z2koMCxmLmxlbmd0aCwxLFwiaW50MzJcIikseT1DaihsLGcsYixbYSxyXSxcIm5lYXJlc3RcIik7cmV0dXJuIGlyKHU/VGUoZHQoeSkpOnksbyl9KX11cHNpemUoZSx0LG4sYSl7cmV0dXJuIE8oKCk9PntsZXQgcj1UaihlLFt0LG5dKTtyZXR1cm4gaXIocixhKX0pfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPVRlKGUpLGE9bi5kdHlwZSxyPW4uc2hhcGUscz1yW3IubGVuZ3RoLTNdLGk9cltyLmxlbmd0aC0yXSxvPTA7cyE9PXRoaXMuaGVpZ2h0JiYobz1NYXRoLmZsb29yKChzLXRoaXMuaGVpZ2h0KS8yKSk7bGV0IGw9MDtyZXR1cm4gaSE9PXRoaXMud2lkdGgmJihsPU1hdGguZmxvb3IoKGktdGhpcy53aWR0aCkvMiksbD09PTAmJihsPTEpKSxvPj0wJiZsPj0wP3RoaXMuY2VudGVyQ3JvcChuLG8sbCx0aGlzLmhlaWdodCx0aGlzLndpZHRoLHMsaSxhKTp0aGlzLnVwc2l6ZShlLHRoaXMuaGVpZ2h0LHRoaXMud2lkdGgsYSl9KX1nZXRDb25maWcoKXtsZXQgZT17aGVpZ2h0OnRoaXMuaGVpZ2h0LHdpZHRoOnRoaXMud2lkdGh9LHQ9c3VwZXIuZ2V0Q29uZmlnKCk7cmV0dXJuIE9iamVjdC5hc3NpZ24oZSx0KSxlfWNvbXB1dGVPdXRwdXRTaGFwZShlKXtlPUplKGUpO2xldCB0PWUubGVuZ3RoLTMsbj1lLmxlbmd0aC0yO3JldHVybiBlW3RdPXRoaXMuaGVpZ2h0LGVbbl09dGhpcy53aWR0aCxlfX07azEuY2xhc3NOYW1lPVwiQ2VudGVyQ3JvcFwiO25lLnJlZ2lzdGVyQ2xhc3MoazEpO2Z1bmN0aW9uIEVqKGUsdCxuLGEpe2xldCByPVRlKGUpO2lmKHIuZHR5cGUhPT1cImludDMyXCImJihyPWlyKHIsXCJpbnQzMlwiKSksdD09PVwiaW50XCIpcmV0dXJuIHI7bGV0IHM9ci5zaGFwZTtpZihyLnJhbms9PT0wJiYocj1HdChyLC0xKSksdD09PVwib25lSG90XCImJnIuc2hhcGVbci5zaGFwZS5sZW5ndGgtMV0hPT0xJiYocj1HdChyLC0xKSksci5yYW5rPjIpdGhyb3cgbmV3IFYoYFdoZW4gb3V0cHV0TW9kZSBpcyBub3QgaW50LCBtYXhpbXVtIG91dHB1dCByYW5rIGlzIDIgUmVjZWl2ZWQgb3V0cHV0TW9kZSAke3R9IGFuZCBpbnB1dCBzaGFwZSAke3N9IHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBvdXRwdXQgcmFuayAke3IucmFua30uYCk7bGV0IGk9W1wibXVsdGlIb3RcIixcIm9uZUhvdFwiXS5pbmNsdWRlcyh0KSxvPXIsbDtpZih0eXBlb2YgYSE9XCJ1bmRlZmluZWRcIiYmdD09PVwiY291bnRcIj9sPVhoKG8sYSxuLGkpOmw9WGgobyxbXSxuLGkpLHQhPT1cInRmSWRmXCIpcmV0dXJuIGw7aWYoYSlyZXR1cm4geihsLGEpO3Rocm93IG5ldyBWKFwiV2hlbiBvdXRwdXRNb2RlIGlzICd0ZklkZicsIHdlaWdodHMgbXVzdCBiZSBwcm92aWRlZC5cIil9dmFyIEkxPWNsYXNzIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSksdGhpcy5udW1Ub2tlbnM9ZS5udW1Ub2tlbnMsZS5vdXRwdXRNb2RlP3RoaXMub3V0cHV0TW9kZT1lLm91dHB1dE1vZGU6dGhpcy5vdXRwdXRNb2RlPVwibXVsdGlIb3RcIn1nZXRDb25maWcoKXtsZXQgZT17bnVtVG9rZW5zOnRoaXMubnVtVG9rZW5zLG91dHB1dE1vZGU6dGhpcy5vdXRwdXRNb2RlfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7cmV0dXJuIGU9SmUoZSksZT09bnVsbD9bdGhpcy5udW1Ub2tlbnNdOnRoaXMub3V0cHV0TW9kZT09PVwib25lSG90XCImJmVbZS5sZW5ndGgtMV0hPT0xPyhlLnB1c2godGhpcy5udW1Ub2tlbnMpLGUpOihlW2UubGVuZ3RoLTFdPXRoaXMubnVtVG9rZW5zLGUpfWNhbGwoZSx0KXtyZXR1cm4gTygoKT0+e2U9VGUoZSksZS5kdHlwZSE9PVwiaW50MzJcIiYmKGU9aXIoZSxcImludDMyXCIpKTtsZXQgbjtpZih0eXBlb2YgdC5jb3VudFdlaWdodHMhPVwidW5kZWZpbmVkXCIpe2lmKHRoaXMub3V0cHV0TW9kZSE9PVwiY291bnRcIil0aHJvdyBuZXcgVihgY291bnRXZWlnaHRzIGlzIG5vdCB1c2VkIHdoZW4gb3V0cHV0TW9kZSAhPT0gY291bnQuXG4gICAgICAgICAgICAgIFJlY2VpdmVkIGNvdW50V2VpZ2h0cz0ke3QuY291bnRXZWlnaHRzfWApO249VGUodC5jb3VudFdlaWdodHMpfWxldCBhPW1hKGUpLHI9T2woZSkscz1Dbih0aGlzLm51bVRva2VucyxhKS5idWZmZXJTeW5jKCkuZ2V0KDApLGk9JHIociwwKS5idWZmZXJTeW5jKCkuZ2V0KDApO2lmKCEocyYmaSkpdGhyb3cgbmV3IFYoYElucHV0IHZhbHVlcyBtdXN0IGJlIGJldHdlZW4gMCA8IHZhbHVlcyA8PSBudW1Ub2tlbnMgd2l0aCBudW1Ub2tlbnM9JHt0aGlzLm51bVRva2Vuc31gKTtyZXR1cm4gRWooZSx0aGlzLm91dHB1dE1vZGUsdGhpcy5udW1Ub2tlbnMsbil9KX19O0kxLmNsYXNzTmFtZT1cIkNhdGVnb3J5RW5jb2RpbmdcIjtuZS5yZWdpc3RlckNsYXNzKEkxKTt2YXIgX2o9W1wiYmlsaW5lYXJcIixcIm5lYXJlc3RcIl0sUkk9bmV3IFNldChfaiksUzE9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLmhlaWdodD1lLmhlaWdodCx0aGlzLndpZHRoPWUud2lkdGgsZS5pbnRlcnBvbGF0aW9uKWlmKFJJLmhhcyhlLmludGVycG9sYXRpb24pKXRoaXMuaW50ZXJwb2xhdGlvbj1lLmludGVycG9sYXRpb247ZWxzZSB0aHJvdyBuZXcgVihgSW52YWxpZCBpbnRlcnBvbGF0aW9uIHBhcmFtZXRlcjogJHtlLmludGVycG9sYXRpb259IGlzIG5vdCBpbXBsZW1lbnRlZGApO2Vsc2UgdGhpcy5pbnRlcnBvbGF0aW9uPVwiYmlsaW5lYXJcIjt0aGlzLmNyb3BUb0FzcGVjdFJhdGlvPSEhZS5jcm9wVG9Bc3BlY3RSYXRpb31jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtsZXQgdD1lWzJdO3JldHVyblt0aGlzLmhlaWdodCx0aGlzLndpZHRoLHRdfWdldENvbmZpZygpe2xldCBlPXtoZWlnaHQ6dGhpcy5oZWlnaHQsd2lkdGg6dGhpcy53aWR0aCxpbnRlcnBvbGF0aW9uOnRoaXMuaW50ZXJwb2xhdGlvbixjcm9wVG9Bc3BlY3RSYXRpbzp0aGlzLmNyb3BUb0FzcGVjdFJhdGlvfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1bdGhpcy5oZWlnaHQsdGhpcy53aWR0aF07aWYodGhpcy5pbnRlcnBvbGF0aW9uPT09XCJiaWxpbmVhclwiKXJldHVybiBabi5yZXNpemVCaWxpbmVhcihlLG4sIXRoaXMuY3JvcFRvQXNwZWN0UmF0aW8pO2lmKHRoaXMuaW50ZXJwb2xhdGlvbj09PVwibmVhcmVzdFwiKXJldHVybiBabi5yZXNpemVOZWFyZXN0TmVpZ2hib3IoZSxuLCF0aGlzLmNyb3BUb0FzcGVjdFJhdGlvKTt0aHJvdyBuZXcgRXJyb3IoYEludGVycG9sYXRpb24gaXMgJHt0aGlzLmludGVycG9sYXRpb259IGJ1dCBvbmx5ICR7Wy4uLlJJXX0gYXJlIHN1cHBvcnRlZGApfSl9fTtTMS5jbGFzc05hbWU9XCJSZXNpemluZ1wiO25lLnJlZ2lzdGVyQ2xhc3MoUzEpO3ZhciBFQz1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnNlZWQ9ZX1uZXh0KCl7aWYodGhpcy5zZWVkIT09dm9pZCAwKXJldHVybiB0aGlzLnNlZWQrK319O0VDLmNsYXNzTmFtZT1cIlJhbmRvbVNlZWRcIjt2YXIgX0M9Y2xhc3MgZXh0ZW5kcyBXZXtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLnJhbmRvbUdlbmVyYXRvcj1uZXcgRUMoZS5zZWVkKX1nZXRDb25maWcoKXtsZXQgZT17c2VlZDp0aGlzLnJhbmRvbUdlbmVyYXRvci5zZWVkfSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX19O19DLmNsYXNzTmFtZT1cIkJhc2VSYW5kb21MYXllclwiO3ZhciBBaj1bXCJiaWxpbmVhclwiLFwibmVhcmVzdFwiXSxNST1uZXcgU2V0KEFqKSxOMT1jbGFzcyBleHRlbmRzIF9De2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2xldHtmYWN0b3I6dCxpbnRlcnBvbGF0aW9uOm49XCJiaWxpbmVhclwifT1lO2lmKHRoaXMuZmFjdG9yPXQsQXJyYXkuaXNBcnJheSh0aGlzLmZhY3RvcikmJnRoaXMuZmFjdG9yLmxlbmd0aD09PTIpdGhpcy53aWR0aExvd2VyPXRoaXMuZmFjdG9yWzBdLHRoaXMud2lkdGhVcHBlcj10aGlzLmZhY3RvclsxXTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KHRoaXMuZmFjdG9yKSYmdGhpcy5mYWN0b3I+MCl0aGlzLndpZHRoTG93ZXI9LXRoaXMuZmFjdG9yLHRoaXMud2lkdGhVcHBlcj10aGlzLmZhY3RvcjtlbHNlIHRocm93IG5ldyBWKGBJbnZhbGlkIGZhY3RvcjogJHt0aGlzLmZhY3Rvcn0uIE11c3QgYmUgcG9zaXRpdmUgbnVtYmVyIG9yIHR1cGxlIG9mIDIgbnVtYmVyc2ApO2lmKHRoaXMud2lkdGhMb3dlcjwtMXx8dGhpcy53aWR0aFVwcGVyPC0xKXRocm93IG5ldyBWKGBmYWN0b3IgbXVzdCBoYXZlIHZhbHVlcyBsYXJnZXIgdGhhbiAtMS4gR290OiAke3RoaXMuZmFjdG9yfWApO2lmKHRoaXMud2lkdGhVcHBlcjx0aGlzLndpZHRoTG93ZXIpdGhyb3cgbmV3IFYoYGZhY3RvciBjYW5ub3QgaGF2ZSB1cHBlciBib3VuZCBsZXNzIHRoYW4gbG93ZXIgYm91bmQuXG4gICAgICAgIEdvdCB1cHBlciBib3VuZDogJHt0aGlzLndpZHRoVXBwZXJ9LlxuICAgICAgICBHb3QgbG93ZXIgYm91bmQ6ICR7dGhpcy53aWR0aExvd2VyfVxuICAgICAgYCk7aWYobilpZihNSS5oYXMobikpdGhpcy5pbnRlcnBvbGF0aW9uPW47ZWxzZSB0aHJvdyBuZXcgVihgSW52YWxpZCBpbnRlcnBvbGF0aW9uIHBhcmFtZXRlcjogJHtufSBpcyBub3QgaW1wbGVtZW50ZWRgKX1nZXRDb25maWcoKXtsZXQgZT17ZmFjdG9yOnRoaXMuZmFjdG9yLGludGVycG9sYXRpb246dGhpcy5pbnRlcnBvbGF0aW9ufSx0PXN1cGVyLmdldENvbmZpZygpO3JldHVybiBPYmplY3QuYXNzaWduKGUsdCksZX1jb21wdXRlT3V0cHV0U2hhcGUoZSl7ZT1KZShlKTtsZXQgdD1lWzJdO3JldHVyblt0aGlzLmltZ0hlaWdodCwtMSx0XX1jYWxsKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1UZShlKTt0aGlzLmltZ0hlaWdodD1uLnNoYXBlW24uc2hhcGUubGVuZ3RoLTNdO2xldCBhPW4uc2hhcGVbbi5zaGFwZS5sZW5ndGgtMl07dGhpcy53aWR0aEZhY3Rvcj1FcyhbMV0sMSt0aGlzLndpZHRoTG93ZXIsMSt0aGlzLndpZHRoVXBwZXIsXCJmbG9hdDMyXCIsdGhpcy5yYW5kb21HZW5lcmF0b3IubmV4dCgpKTtsZXQgcj10aGlzLndpZHRoRmFjdG9yLmRhdGFTeW5jKClbMF0qYTtyPU1hdGgucm91bmQocik7bGV0IHM9W3RoaXMuaW1nSGVpZ2h0LHJdO3N3aXRjaCh0aGlzLmludGVycG9sYXRpb24pe2Nhc2VcImJpbGluZWFyXCI6cmV0dXJuIFpuLnJlc2l6ZUJpbGluZWFyKGUscyk7Y2FzZVwibmVhcmVzdFwiOnJldHVybiBabi5yZXNpemVOZWFyZXN0TmVpZ2hib3IoZSxzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW50ZXJwb2xhdGlvbiBpcyAke3RoaXMuaW50ZXJwb2xhdGlvbn1cbiAgICAgICAgICBidXQgb25seSAke1suLi5NSV19IGFyZSBzdXBwb3J0ZWRgKX19KX19O04xLmNsYXNzTmFtZT1cIlJhbmRvbVdpZHRoXCI7bmUucmVnaXN0ZXJDbGFzcyhOMSk7ZnVuY3Rpb24gRmooZSl7cmV0dXJuIG5ldyBycChlKX1mdW5jdGlvbiAkaihlKXtyZXR1cm4gbmV3IFQwKGUpfWZ1bmN0aW9uIERqKGUpe3JldHVybiBuZXcgSTAoZSl9ZnVuY3Rpb24gUmooZSl7cmV0dXJuIG5ldyBTMChlKX1mdW5jdGlvbiBNaihlKXtyZXR1cm4gbmV3IE4wKGUpfWZ1bmN0aW9uIE9qKGUpe3JldHVybiBuZXcgRTAoZSl9ZnVuY3Rpb24gUGooZSl7cmV0dXJuIG5ldyBDMChlKX1mdW5jdGlvbiBMaihlKXtyZXR1cm4gbmV3IEQwKGUpfWZ1bmN0aW9uIHpqKGUpe3JldHVybiBuZXcgQWYoZSl9ZnVuY3Rpb24gV2ooZSl7cmV0dXJuIG5ldyBBMChlKX1mdW5jdGlvbiBCaihlKXtyZXR1cm4gbmV3IEZmKGUpfWZ1bmN0aW9uIFZqKGUpe3JldHVybiBuZXcgRjAoZSl9ZnVuY3Rpb24gVWooZSl7cmV0dXJuIG5ldyAkMChlKX1mdW5jdGlvbiBHaihlKXtyZXR1cm4gbmV3IFIwKGUpfWZ1bmN0aW9uIEhqKGUpe3JldHVybiBuZXcgTTAoZSl9ZnVuY3Rpb24gamooZSl7cmV0dXJuIG5ldyBPMChlKX1mdW5jdGlvbiBxaihlKXtyZXR1cm4gbmV3IEcwKGUpfWZ1bmN0aW9uIEtqKGUpe3JldHVybiBuZXcgVjAoZSl9ZnVuY3Rpb24gWGooZSl7cmV0dXJuIG5ldyBPZihlKX1mdW5jdGlvbiBZaihlKXtyZXR1cm4gbmV3IEIwKGUpfWZ1bmN0aW9uIFpqKGUpe3JldHVybiBuZXcgVTAoZSl9ZnVuY3Rpb24gSmooZSl7cmV0dXJuIG5ldyBIMChlKX1mdW5jdGlvbiBRaihlKXtyZXR1cm4gbmV3IGowKGUpfWZ1bmN0aW9uIGU2KGUpe3JldHVybiBuZXcgcTAoZSl9ZnVuY3Rpb24gdDYoZSl7cmV0dXJuIG5ldyBYMChlKX1mdW5jdGlvbiBuNihlKXtyZXR1cm4gbmV3IFkwKGUpfWZ1bmN0aW9uIGE2KGUpe3JldHVybiBuZXcgSjAoZSl9ZnVuY3Rpb24gcjYoZSl7cmV0dXJuIG5ldyB0MShlKX1mdW5jdGlvbiBzNihlKXtyZXR1cm4gbmV3IFEwKGUpfWZ1bmN0aW9uIGk2KGUpe3JldHVybiBuZXcgZTEoZSl9ZnVuY3Rpb24gbzYoZSl7cmV0dXJuIG5ldyBaMChlKX1mdW5jdGlvbiBsNihlKXtyZXR1cm4gbmV3IG4xKGUpfWZ1bmN0aW9uIHU2KGUpe3JldHVybiBuZXcgaTEoZSl9ZnVuY3Rpb24gcDYoZSl7cmV0dXJuIG5ldyBvMShlKX1mdW5jdGlvbiBjNihlKXtyZXR1cm4gbmV3IGwxKGUpfWZ1bmN0aW9uIFQxKGUpe3JldHVybiBuZXcgcDEoZSl9ZnVuY3Rpb24gZDYoZSl7cmV0dXJuIFQxKGUpfWZ1bmN0aW9uIGg2KGUpe3JldHVybiBUMShlKX1mdW5jdGlvbiBDMShlKXtyZXR1cm4gbmV3IGQxKGUpfWZ1bmN0aW9uIG02KGUpe3JldHVybiBDMShlKX1mdW5jdGlvbiBmNihlKXtyZXR1cm4gQzEoZSl9ZnVuY3Rpb24gRTEoZSl7cmV0dXJuIG5ldyBtMShlKX1mdW5jdGlvbiBnNihlKXtyZXR1cm4gRTEoZSl9ZnVuY3Rpb24gYjYoZSl7cmV0dXJuIEUxKGUpfWZ1bmN0aW9uIHk2KGUpe3JldHVybiBuZXcgZjEoZSl9ZnVuY3Rpb24geDYoZSl7cmV0dXJuIG5ldyBiMShlKX1mdW5jdGlvbiBBQyhlKXtyZXR1cm4gbmV3IGcxKGUpfWZ1bmN0aW9uIEZDKGUpe3JldHVybiBuZXcgeTEoZSl9ZnVuY3Rpb24gJEMoZSl7cmV0dXJuIG5ldyB1MShlKX1mdW5jdGlvbiBEQyhlKXtyZXR1cm4gbmV3IGMxKGUpfWZ1bmN0aW9uIHY2KGUpe3JldHVybiBuZXcgaDEoZSl9ZnVuY3Rpb24gdzYoZSl7cmV0dXJuIG5ldyBMMChlKX1mdW5jdGlvbiBrNihlKXtyZXR1cm4gbmV3IERmKGUpfWZ1bmN0aW9uIEk2KGUpe3JldHVybiBuZXcgejAoZSl9ZnVuY3Rpb24gUzYoZSl7cmV0dXJuIG5ldyBDZChlKX1mdW5jdGlvbiBONihlKXtyZXR1cm4gbmV3IFAwKGUpfWZ1bmN0aW9uIFQ2KGUpe3JldHVybiBuZXcgJGYoZSl9ZnVuY3Rpb24gQzYoZSl7cmV0dXJuIG5ldyBXMChlKX1mdW5jdGlvbiBFNihlKXtyZXR1cm4gbmV3IE1mKGUpfWZ1bmN0aW9uIF82KGUpe3JldHVybiBuZXcgTXIoZSl9ZnVuY3Rpb24gQTYoZSl7cmV0dXJuIG5ldyBSZihlKX1mdW5jdGlvbiBGNihlKXtyZXR1cm4gbmV3IHYxKGUpfWZ1bmN0aW9uICQ2KGUpe3JldHVybiBuZXcgeDEoZSl9dmFyIEQ2PUFDLFI2PUZDLE02PSRDLE82PURDO2Z1bmN0aW9uIFA2KGUpe3JldHVybiBuZXcgYTEoZSl9ZnVuY3Rpb24gTDYoZSl7cmV0dXJuIG5ldyByMShlKX1mdW5jdGlvbiB6NihlKXtyZXR1cm4gbmV3IHMxKGUpfWZ1bmN0aW9uIFc2KGUpe3JldHVybiBuZXcgSzAoZSl9ZnVuY3Rpb24gQjYoZSl7cmV0dXJuIG5ldyB3MShlKX1mdW5jdGlvbiBWNihlKXtyZXR1cm4gbmV3IGsxKGUpfWZ1bmN0aW9uIFU2KGUpe3JldHVybiBuZXcgUzEoZSl9ZnVuY3Rpb24gRzYoZSl7cmV0dXJuIG5ldyBJMShlKX1mdW5jdGlvbiBINihlKXtyZXR1cm4gbmV3IE4xKGUpfXZhciBSQz17fTtfZShSQyx7TUFQRTooKT0+bnEsTVNFOigpPT5zcSxiaW5hcnlBY2N1cmFjeTooKT0+ajYsYmluYXJ5Q3Jvc3NlbnRyb3B5OigpPT5xNixjYXRlZ29yaWNhbEFjY3VyYWN5OigpPT5YNixjYXRlZ29yaWNhbENyb3NzZW50cm9weTooKT0+WTYsY29zaW5lUHJveGltaXR5OigpPT5RNixtYXBlOigpPT5hcSxtZWFuQWJzb2x1dGVFcnJvcjooKT0+ZXEsbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yOigpPT50cSxtZWFuU3F1YXJlZEVycm9yOigpPT5ycSxtc2U6KCk9PmlxLHByZWNpc2lvbjooKT0+WjYscjJTY29yZTooKT0+b3EscmVjYWxsOigpPT5KNixzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5OigpPT5LNn0pO2Z1bmN0aW9uIGo2KGUsdCl7cmV0dXJuIGIwKGUsdCl9ZnVuY3Rpb24gcTYoZSx0KXtyZXR1cm4gUDIoZSx0KX1mdW5jdGlvbiBLNihlLHQpe3JldHVybiBMMihlLHQpfWZ1bmN0aW9uIFg2KGUsdCl7cmV0dXJuIHkwKGUsdCl9ZnVuY3Rpb24gWTYoZSx0KXtyZXR1cm4geDAoZSx0KX1mdW5jdGlvbiBaNihlLHQpe3JldHVybiBPMihlLHQpfWZ1bmN0aW9uIEo2KGUsdCl7cmV0dXJuIF9IKGUsdCl9ZnVuY3Rpb24gUTYoZSx0KXtyZXR1cm4gZzAoZSx0KX1mdW5jdGlvbiBlcShlLHQpe3JldHVybiBUZihlLHQpfWZ1bmN0aW9uIHRxKGUsdCl7cmV0dXJuIHNwKGUsdCl9ZnVuY3Rpb24gbnEoZSx0KXtyZXR1cm4gc3AoZSx0KX1mdW5jdGlvbiBhcShlLHQpe3JldHVybiBzcChlLHQpfWZ1bmN0aW9uIHJxKGUsdCl7cmV0dXJuIFhvKGUsdCl9ZnVuY3Rpb24gc3EoZSx0KXtyZXR1cm4gWG8oZSx0KX1mdW5jdGlvbiBpcShlLHQpe3JldHVybiBYbyhlLHQpfWZ1bmN0aW9uIG9xKGUsdCl7cmV0dXJuIEFIKGUsdCl9dmFyIE1DPXt9O19lKE1DLHttb2RlbEZyb21KU09OOigpPT5pan0pO3ZhciBPQz17fTtfZShPQyx7bDE6KCk9PnVxLGwxbDI6KCk9PmxxLGwyOigpPT5wcX0pO2Z1bmN0aW9uIGxxKGUpe3JldHVybiBuZXcgTmQoZSl9ZnVuY3Rpb24gdXEoZSl7cmV0dXJuIGhqKGUpfWZ1bmN0aW9uIHBxKGUpe3JldHVybiBtaihlKX12YXIgUEM9Y2xhc3MgZXh0ZW5kcyBHbHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5tb2RlbD1udWxsfXNldE1vZGVsKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEVyKSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbCBtdXN0IGJlIGEgTGF5ZXJzTW9kZWwsIG5vdCBzb21lIG90aGVyIENvbnRhaW5lclwiKTt0aGlzLm1vZGVsPWV9fTtmdW5jdGlvbiBOaChlLHQpe3JldHVybiBlPHR9ZnVuY3Rpb24gT0koZSx0KXtyZXR1cm4gZT50fXZhciBMQz1jbGFzcyBleHRlbmRzIFBDe2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKCksZT09bnVsbCYmKGU9e30pLGUucmVzdG9yZUJlc3RXZWlnaHRzKXRocm93IG5ldyB6ZShcInJlc3RvcmVCZXN0V2VpZ2h0cyA9IFRydWUgaXMgbm90IGltcGxlbWVudGVkIGluIEVhcmx5U3RvcHBpbmcgeWV0LlwiKTt0aGlzLm1vbml0b3I9ZS5tb25pdG9yfHxcInZhbF9sb3NzXCIsdGhpcy5taW5EZWx0YT1NYXRoLmFicyhlLm1pbkRlbHRhfHwwKSx0aGlzLnBhdGllbmNlPWUucGF0aWVuY2V8fDAsdGhpcy52ZXJib3NlPWUudmVyYm9zZXx8MCx0aGlzLm1vZGU9ZS5tb2RlfHxcImF1dG9cIix0aGlzLmJhc2VsaW5lPWUuYmFzZWxpbmUsW1wiYXV0b1wiLFwibWluXCIsXCJtYXhcIl0uaW5kZXhPZih0aGlzLm1vZGUpPT09LTEmJihjb25zb2xlLndhcm4oYEVhcmx5U3RvcHBpbmcgbW9kZSAnJHt0aGlzLm1vZGV9JyBpcyBpbnZhbGlkLiBGYWxsaW5nIGJhY2sgdG8gbW9kZSAnYXV0bycuYCksdGhpcy5tb2RlPVwiYXV0b1wiKSx0aGlzLm1vZGU9PT1cIm1pblwiP3RoaXMubW9uaXRvckZ1bmM9Tmg6dGhpcy5tb2RlPT09XCJtYXhcIj90aGlzLm1vbml0b3JGdW5jPU9JOnRoaXMubW9uaXRvci5pbmRleE9mKFwiYWNjXCIpIT09LTE/dGhpcy5tb25pdG9yRnVuYz1PSTp0aGlzLm1vbml0b3JGdW5jPU5oLHRoaXMubW9uaXRvckZ1bmM9PT1OaCYmKHRoaXMubWluRGVsdGEqPS0xKX1hc3luYyBvblRyYWluQmVnaW4oZSl7dGhpcy53YWl0PTAsdGhpcy5zdG9wcGVkRXBvY2g9MCx0aGlzLmJhc2VsaW5lIT1udWxsP3RoaXMuYmVzdD10aGlzLmJhc2VsaW5lOnRoaXMuYmVzdD10aGlzLm1vbml0b3JGdW5jPT09Tmg/MS8wOi0xLzB9YXN5bmMgb25FcG9jaEVuZChlLHQpe2F3YWl0IEtyKHQpO2xldCBuPXRoaXMuZ2V0TW9uaXRvclZhbHVlKHQpO24hPW51bGwmJih0aGlzLm1vbml0b3JGdW5jKG4tdGhpcy5taW5EZWx0YSx0aGlzLmJlc3QpPyh0aGlzLmJlc3Q9bix0aGlzLndhaXQ9MCk6KHRoaXMud2FpdCsrLHRoaXMud2FpdD49dGhpcy5wYXRpZW5jZSYmKHRoaXMuc3RvcHBlZEVwb2NoPWUsdGhpcy5tb2RlbC5zdG9wVHJhaW5pbmc9ITApKSl9YXN5bmMgb25UcmFpbkVuZChlKXt0aGlzLnN0b3BwZWRFcG9jaD4wJiZ0aGlzLnZlcmJvc2UmJmNvbnNvbGUubG9nKGBFcG9jaCAke3RoaXMuc3RvcHBlZEVwb2NofTogZWFybHkgc3RvcHBpbmcuYCl9Z2V0TW9uaXRvclZhbHVlKGUpe2U9PW51bGwmJihlPXt9KTtsZXQgdD1lW3RoaXMubW9uaXRvcl07cmV0dXJuIHQ9PW51bGwmJmNvbnNvbGUud2FybihgTWV0cmljIGZvciBFYXJseVN0b3BwaW5nICR7dGhpcy5tb25pdG9yfSBpcyBub3QgYXZhaWxhYmxlLiBBdmFpbGFibGUgbWV0cmljcyBhcmU6ICR7T2JqZWN0LmtleXMoZSl9YCksdH19O2Z1bmN0aW9uIGNxKGUpe3JldHVybiBuZXcgTEMoZSl9dmFyIGRxPXtlYXJseVN0b3BwaW5nOmNxfSxocT1HKCk7aHEucmVnaXN0ZXJGbGFnKFwiS0VFUF9JTlRFUk1FRElBVEVfVEVOU09SU1wiLCgpPT4hMSxlPT57ZSYmY29uc29sZS53YXJuKFwiS2VlcCBpbnRlcm1lZGlhdGUgdGVuc29ycyBpcyBPTi4gVGhpcyB3aWxsIHByaW50IHRoZSB2YWx1ZXMgb2YgYWxsIGludGVybWVkaWF0ZSB0ZW5zb3JzIGR1cmluZyBtb2RlbCBpbmZlcmVuY2UuIE5vdCBhbGwgbW9kZWxzIHN1cHBvcnQgdGhpcyBtb2RlLiBGb3IgZGV0YWlscywgY2hlY2sgZTJlL2JlbmNobWFya3MvIG1vZGVsX2NvbmZpZy5qcy4gVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuXCIpfSk7dmFyIHFuOyhmdW5jdGlvbihlKXtlW2UuRFRfSU5WQUxJRD0wXT1cIkRUX0lOVkFMSURcIixlW2UuRFRfRkxPQVQ9MV09XCJEVF9GTE9BVFwiLGVbZS5EVF9ET1VCTEU9Ml09XCJEVF9ET1VCTEVcIixlW2UuRFRfSU5UMzI9M109XCJEVF9JTlQzMlwiLGVbZS5EVF9VSU5UOD00XT1cIkRUX1VJTlQ4XCIsZVtlLkRUX0lOVDE2PTVdPVwiRFRfSU5UMTZcIixlW2UuRFRfSU5UOD02XT1cIkRUX0lOVDhcIixlW2UuRFRfU1RSSU5HPTddPVwiRFRfU1RSSU5HXCIsZVtlLkRUX0NPTVBMRVg2ND04XT1cIkRUX0NPTVBMRVg2NFwiLGVbZS5EVF9JTlQ2ND05XT1cIkRUX0lOVDY0XCIsZVtlLkRUX0JPT0w9MTBdPVwiRFRfQk9PTFwiLGVbZS5EVF9RSU5UOD0xMV09XCJEVF9RSU5UOFwiLGVbZS5EVF9RVUlOVDg9MTJdPVwiRFRfUVVJTlQ4XCIsZVtlLkRUX1FJTlQzMj0xM109XCJEVF9RSU5UMzJcIixlW2UuRFRfQkZMT0FUMTY9MTRdPVwiRFRfQkZMT0FUMTZcIixlW2UuRFRfUUlOVDE2PTE1XT1cIkRUX1FJTlQxNlwiLGVbZS5EVF9RVUlOVDE2PTE2XT1cIkRUX1FVSU5UMTZcIixlW2UuRFRfVUlOVDE2PTE3XT1cIkRUX1VJTlQxNlwiLGVbZS5EVF9DT01QTEVYMTI4PTE4XT1cIkRUX0NPTVBMRVgxMjhcIixlW2UuRFRfSEFMRj0xOV09XCJEVF9IQUxGXCIsZVtlLkRUX1JFU09VUkNFPTIwXT1cIkRUX1JFU09VUkNFXCIsZVtlLkRUX1ZBUklBTlQ9MjFdPVwiRFRfVkFSSUFOVFwiLGVbZS5EVF9VSU5UMzI9MjJdPVwiRFRfVUlOVDMyXCIsZVtlLkRUX1VJTlQ2ND0yM109XCJEVF9VSU5UNjRcIixlW2UuRFRfRkxPQVRfUkVGPTEwMV09XCJEVF9GTE9BVF9SRUZcIixlW2UuRFRfRE9VQkxFX1JFRj0xMDJdPVwiRFRfRE9VQkxFX1JFRlwiLGVbZS5EVF9JTlQzMl9SRUY9MTAzXT1cIkRUX0lOVDMyX1JFRlwiLGVbZS5EVF9VSU5UOF9SRUY9MTA0XT1cIkRUX1VJTlQ4X1JFRlwiLGVbZS5EVF9JTlQxNl9SRUY9MTA1XT1cIkRUX0lOVDE2X1JFRlwiLGVbZS5EVF9JTlQ4X1JFRj0xMDZdPVwiRFRfSU5UOF9SRUZcIixlW2UuRFRfU1RSSU5HX1JFRj0xMDddPVwiRFRfU1RSSU5HX1JFRlwiLGVbZS5EVF9DT01QTEVYNjRfUkVGPTEwOF09XCJEVF9DT01QTEVYNjRfUkVGXCIsZVtlLkRUX0lOVDY0X1JFRj0xMDldPVwiRFRfSU5UNjRfUkVGXCIsZVtlLkRUX0JPT0xfUkVGPTExMF09XCJEVF9CT09MX1JFRlwiLGVbZS5EVF9RSU5UOF9SRUY9MTExXT1cIkRUX1FJTlQ4X1JFRlwiLGVbZS5EVF9RVUlOVDhfUkVGPTExMl09XCJEVF9RVUlOVDhfUkVGXCIsZVtlLkRUX1FJTlQzMl9SRUY9MTEzXT1cIkRUX1FJTlQzMl9SRUZcIixlW2UuRFRfQkZMT0FUMTZfUkVGPTExNF09XCJEVF9CRkxPQVQxNl9SRUZcIixlW2UuRFRfUUlOVDE2X1JFRj0xMTVdPVwiRFRfUUlOVDE2X1JFRlwiLGVbZS5EVF9RVUlOVDE2X1JFRj0xMTZdPVwiRFRfUVVJTlQxNl9SRUZcIixlW2UuRFRfVUlOVDE2X1JFRj0xMTddPVwiRFRfVUlOVDE2X1JFRlwiLGVbZS5EVF9DT01QTEVYMTI4X1JFRj0xMThdPVwiRFRfQ09NUExFWDEyOF9SRUZcIixlW2UuRFRfSEFMRl9SRUY9MTE5XT1cIkRUX0hBTEZfUkVGXCIsZVtlLkRUX1JFU09VUkNFX1JFRj0xMjBdPVwiRFRfUkVTT1VSQ0VfUkVGXCIsZVtlLkRUX1ZBUklBTlRfUkVGPTEyMV09XCJEVF9WQVJJQU5UX1JFRlwiLGVbZS5EVF9VSU5UMzJfUkVGPTEyMl09XCJEVF9VSU5UMzJfUkVGXCIsZVtlLkRUX1VJTlQ2NF9SRUY9MTIzXT1cIkRUX1VJTlQ2NF9SRUZcIn0pKHFufHwocW49e30pKTt2YXIgUEk7KGZ1bmN0aW9uKGUpe2xldCB0OyhmdW5jdGlvbihuKXtuW24uTEVHQUNZPTBdPVwiTEVHQUNZXCIsbltuLlYxPTFdPVwiVjFcIixuW24uVjI9Ml09XCJWMlwifSkodD1lLkNoZWNrcG9pbnRGb3JtYXRWZXJzaW9ufHwoZS5DaGVja3BvaW50Rm9ybWF0VmVyc2lvbj17fSkpfSkoUEl8fChQST17fSkpO3ZhciBfMT17fTtmdW5jdGlvbiBtcShlLHQpe2xldCBuPXt0Zk9wTmFtZTplLGNhdGVnb3J5OlwiY3VzdG9tXCIsaW5wdXRzOltdLGF0dHJzOltdLGN1c3RvbUV4ZWN1dG9yOnR9O18xW2VdPW59ZnVuY3Rpb24gekMoZSl7cmV0dXJuIF8xW2VdfWZ1bmN0aW9uIGZxKGUpe2RlbGV0ZSBfMVtlXX1mdW5jdGlvbiBrKGUsdCxuLGEscil7bGV0IHM9dC5pbnB1dFBhcmFtc1tlXTtpZihzJiZzLmlucHV0SW5kZXhTdGFydCE9PXZvaWQgMCl7bGV0IG89cy5pbnB1dEluZGV4U3RhcnQsbD1zLmlucHV0SW5kZXhFbmQ9PT0wP3ZvaWQgMDpzLmlucHV0SW5kZXhFbmQ9PT12b2lkIDA/bysxOnMuaW5wdXRJbmRleEVuZCx1PW88MD90LmlucHV0TmFtZXMubGVuZ3RoK286bztpZihzLnR5cGU9PT1cInRlbnNvclwiKXJldHVybiBwbih0LmlucHV0TmFtZXNbdV0sbixhLHIpO2lmKHMudHlwZT09PVwidGVuc29yc1wiKXtsZXQgYz10LmlucHV0cy5zbGljZShvLGwpO3JldHVybiB0LmlucHV0TmFtZXMuc2xpY2UobyxsKS5maWx0ZXIoKGgsbSk9Pnt2YXIgZjtyZXR1cm4oKGY9Y1ttXSk9PT1udWxsfHxmPT09dm9pZCAwP3ZvaWQgMDpmLm9wKSE9PVwiTm9PcFwifSkubWFwKGg9PnBuKGgsbixhLHIpKX1sZXQgcD1wbih0LmlucHV0TmFtZXNbdV0sbixhLHIpLGQ9cC5kYXRhU3luYygpO3JldHVybiBzLnR5cGU9PT1cIm51bWJlclwiP2RbMF06dy50b05lc3RlZEFycmF5KHAuc2hhcGUsZCl9bGV0IGk9dC5hdHRyUGFyYW1zW2VdO3JldHVybiBpJiZpLnZhbHVlfWZ1bmN0aW9uIHBuKGUsdCxuLGEpe2xldFtyLHNdPVhuKGUsbik7aWYoYSE9bnVsbCl7bGV0IG89YS5nZXRIYXNoVGFibGVIYW5kbGVCeU5hbWUocik7aWYobyE9bnVsbClyZXR1cm4gb31sZXQgaT1uLmN1cnJlbnRDb250ZXh0SWRzLmZpbmQobz0+ISF0W2ltKHIsbyldKTtyZXR1cm4gaSE9PXZvaWQgMD90W2ltKHIsaSldW3NdOnZvaWQgMH1mdW5jdGlvbiBMSShlLHQsbil7cmV0dXJuIHRbaW0oZSxuLmN1cnJlbnRDb250ZXh0SWQpXX1mdW5jdGlvbiBTcihlLHQpe2xldFtuLGEscl09WG4oZSx0KTtyZXR1cm5baW0obix0JiZ0LmN1cnJlbnRDb250ZXh0SWQpLGEscl19ZnVuY3Rpb24gaW0oZSx0KXtyZXR1cm4gdD9gJHtlfS0ke3R9YDplfWZ1bmN0aW9uIFhuKGUsdCl7aWYoZT09PVwiXCIpcmV0dXJuW1wiXCIsMCx2b2lkIDBdO2xldCBuPXQhPW51bGwmJnQucGFyc2VOb2RlTmFtZUNhY2hlIT1udWxsO2lmKG4pe2xldCBzPXQucGFyc2VOb2RlTmFtZUNhY2hlLmdldChlKTtpZihzIT1udWxsKXJldHVybiBzfWxldCBhPWUuc3BsaXQoXCI6XCIpLHI7aWYoYS5sZW5ndGg9PT0xKXI9W2UsMCx2b2lkIDBdO2Vsc2V7bGV0IHM9YVswXSxpPWEubGVuZ3RoPT09Mz9hWzFdOnZvaWQgMCxvPU51bWJlcihhW2EubGVuZ3RoLTFdKTtyPVtzLG8saV19cmV0dXJuIG4mJnQucGFyc2VOb2RlTmFtZUNhY2hlLnNldChlLHIpLHJ9ZnVuY3Rpb24gTWgoZSx0LG4pe2xldCBhPWsoXCJwYWRcIixlLHQsbik7aWYoYT09PVwiZXhwbGljaXRcIil7YT1rKFwiZXhwbGljaXRQYWRkaW5nc1wiLGUsdCxuKTtsZXQgcj1bWzAsMF0sWzAsMF0sWzAsMF0sWzAsMF1dO2ZvcihsZXQgcz0wO3M8NDtzKyspcltzXVswXT1hW3MqMl0scltzXVsxXT1hW3MqMisxXTtyZXR1cm4gcn1yZXR1cm4gYX1mdW5jdGlvbiBOcihlKXtyZXR1cm4gZS5rZXB0P2U6c3IoZSl9dmFyIFdDPXt9O19lKFdDLHtqc29uOigpPT5ncX0pO3ZhciBncT1be3RmT3BOYW1lOlwiQWRkXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWRkVjJcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBZGROXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiQmlhc0FkZFwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3ViXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVhbERpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRpdk5vTmFuXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JEaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNdWxcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNYXhpbXVtXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWluaW11bVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlBvd1wiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxdWFyZWREaWZmZXJlbmNlXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTW9kXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JNb2RcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sQkM9e307X2UoQkMse2pzb246KCk9PmJxfSk7dmFyIGJxPVt7dGZPcE5hbWU6XCJBYnNcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFjb3NcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFzaW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkF0YW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkF0YW4yXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ2VpbFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ2xpcEJ5VmFsdWVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiY2xpcFZhbHVlTWluXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwiY2xpcFZhbHVlTWF4XCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNvbXBsZXhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJyZWFsXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW1hZ1wiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb21wbGV4QWJzXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb3NcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNvc2hcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRXhwXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGbG9vclwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9nXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJJbWFnXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRvdXRcIixuYW1lOlwib3V0cHV0VHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOZWdcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlYWxcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVG91dFwiLG5hbWU6XCJvdXRwdXRUeXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlByZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImFscGhhXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJlbHU2XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaWdtb2lkXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxcnRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJzcXJ0XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXVhcmVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRhblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGFuaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2lnblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUm91bmRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cG0xXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2cxcFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVjaXByb2NhbFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU29mdHBsdXNcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFzaW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBY29zaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkVyZlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVha3lSZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWxwaGFcIixuYW1lOlwiYWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4yfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJJc05hblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiSXNGaW5pdGVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIklzSW5mXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sVkM9e307X2UoVkMse2pzb246KCk9PnlxfSk7dmFyIHlxPVt7dGZPcE5hbWU6XCJFbXB0eVRlbnNvckxpc3RcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3N0YXJ0OjEsbmFtZTpcIm1heE51bUVsZW1lbnRzXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkxvb3BDb25kXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTd2l0Y2hcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJkYXRhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJNZXJnZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIkVudGVyXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZnJhbWVfbmFtZVwiLG5hbWU6XCJmcmFtZU5hbWVcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJpc19jb25zdGFudFwiLG5hbWU6XCJpc0NvbnN0YW50XCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJFeGl0XCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk5leHRJdGVyYXRpb25cIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X3NoYXBlXCIsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZHluYW1pY19zaXplXCIsbmFtZTpcImR5bmFtaWNTaXplXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImNsZWFyX2FmdGVyX3JlYWRcIixuYW1lOlwiY2xlYXJBZnRlclJlYWRcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiaWRlbnRpY2FsX2VsZW1lbnRfc2hhcGVzXCIsbmFtZTpcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwidGVuc29yX2FycmF5X25hbWVcIixuYW1lOlwibmFtZVwiLHR5cGU6XCJzdHJpbmdcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVdyaXRlVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlSZWFkVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5R2F0aGVyVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiZWxlbWVudF9zaGFwZVwiLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNjYXR0ZXJWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheUNvbmNhdFYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcImVsZW1lbnRfc2hhcGVfZXhjZXB0MFwiLG5hbWU6XCJlbGVtZW50U2hhcGVFeGNlcHQwXCIsdHlwZTpcInNoYXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5U3BsaXRWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJsZW5ndGhzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNpemVWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlDbG9zZVYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTdGF0ZWxlc3NJZlwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImNvbmRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLGVuZDowLG5hbWU6XCJhcmdzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwidGhlbl9icmFuY2hcIixuYW1lOlwidGhlbkJyYW5jaFwiLHR5cGU6XCJmdW5jXCJ9LHt0Zk5hbWU6XCJlbHNlX2JyYW5jaFwiLG5hbWU6XCJlbHNlQnJhbmNoXCIsdHlwZTpcImZ1bmNcIn1dfSx7dGZPcE5hbWU6XCJJZlwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImNvbmRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLGVuZDowLG5hbWU6XCJhcmdzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwidGhlbl9icmFuY2hcIixuYW1lOlwidGhlbkJyYW5jaFwiLHR5cGU6XCJmdW5jXCJ9LHt0Zk5hbWU6XCJlbHNlX2JyYW5jaFwiLG5hbWU6XCJlbHNlQnJhbmNoXCIsdHlwZTpcImZ1bmNcIn1dfSx7dGZPcE5hbWU6XCJTdGF0ZWxlc3NXaGlsZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcImFyZ3NcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJjb25kXCIsbmFtZTpcImNvbmRcIix0eXBlOlwiZnVuY1wifSx7dGZOYW1lOlwiYm9keVwiLG5hbWU6XCJib2R5XCIsdHlwZTpcImZ1bmNcIn1dfSx7dGZPcE5hbWU6XCJXaGlsZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcImFyZ3NcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJjb25kXCIsbmFtZTpcImNvbmRcIix0eXBlOlwiZnVuY1wifSx7dGZOYW1lOlwiYm9keVwiLG5hbWU6XCJib2R5XCIsdHlwZTpcImZ1bmNcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0U2NhdHRlclwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RTY2F0dGVyVjJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3N0YXJ0OjMsbmFtZTpcIm51bUVsZW1lbnRzXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RHYXRoZXJcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0R2V0SXRlbVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckxpc3RJZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGV4XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdFNldEl0ZW1cIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRleFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0UmVzZXJ2ZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7c3RhcnQ6MSxuYW1lOlwibnVtRWxlbWVudHNcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdEZyb21UZW5zb3JcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0U3RhY2tcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcIm51bV9lbGVtZW50c1wiLG5hbWU6XCJudW1FbGVtZW50c1wiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RTcGxpdFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7c3RhcnQ6MixuYW1lOlwibGVuZ3Roc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RDb25jYXRcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfc2hhcGVcIixuYW1lOlwiZWxlbWVudFNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X2R0eXBlXCIsbmFtZTpcImVsZW1lbnREVHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRlbnNvckxpc3RDb25jYXRWMlwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckxpc3RJZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9zaGFwZVwiLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdFBvcEJhY2tcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZWxlbWVudF9kdHlwZVwiLG5hbWU6XCJlbGVtZW50RFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0UHVzaEJhY2tcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JMaXN0SWRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVsZW1lbnRfZHR5cGVcIixuYW1lOlwiZWxlbWVudERUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yTGlzdExlbmd0aFwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckxpc3RJZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JMaXN0UmVzaXplXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yTGlzdElkXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJcIn1dfV0sVUM9e307X2UoVUMse2pzb246KCk9PnhxfSk7dmFyIHhxPVt7dGZPcE5hbWU6XCJBdmdQb29sXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImtzaXplXCIsbmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4UG9vbFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJleHBsaWNpdF9wYWRkaW5nc1wiLG5hbWU6XCJleHBsaWNpdFBhZGRpbmdzXCIsdHlwZTpcIm51bWJlcltdXCIsZGVmYXVsdFZhbHVlOltdLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4UG9vbFdpdGhBcmdtYXhcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImtzaXplXCIsbmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcImluY2x1ZGVfYmF0Y2hfaW5faW5kZXhcIixuYW1lOlwiaW5jbHVkZUJhdGNoSW5JbmRleFwiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkF2Z1Bvb2wzRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heFBvb2wzRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNvbnYxRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVcIixuYW1lOlwic3RyaWRlXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5XQ1wifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImRpbGF0aW9uXCIsbmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfV19LHt0Zk9wTmFtZTpcIkNvbnYyRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcInVzZUN1ZG5uT25HcHVcIixuYW1lOlwidXNlQ3Vkbm5PbkdwdVwiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLGRlZmF1bHRWYWx1ZTpcIk5IV0NcIn0se3RmTmFtZTpcImV4cGxpY2l0X3BhZGRpbmdzXCIsbmFtZTpcImV4cGxpY2l0UGFkZGluZ3NcIix0eXBlOlwibnVtYmVyW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiX0Z1c2VkQ29udjJEXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLGVuZDowLG5hbWU6XCJhcmdzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwibnVtX2FyZ3NcIixuYW1lOlwibnVtQXJnc1wiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZXhwbGljaXRfcGFkZGluZ3NcIixuYW1lOlwiZXhwbGljaXRQYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbXX0se3RmTmFtZTpcInVzZV9jdWRubl9vbl9ncHVcIixuYW1lOlwidXNlQ3Vkbm5PbkdwdVwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiEwfSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCIsZGVmYXVsdFZhbHVlOlsxLDEsMSwxXX0se3RmTmFtZTpcImZ1c2VkX29wc1wiLG5hbWU6XCJmdXNlZE9wc1wiLHR5cGU6XCJzdHJpbmdbXVwiLGRlZmF1bHRWYWx1ZTpbXX0se3RmTmFtZTpcImVwc2lsb25cIixuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MWUtNH0se3RmTmFtZTpcImxlYWt5cmVsdV9hbHBoYVwiLG5hbWU6XCJsZWFreXJlbHVBbHBoYVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjJ9XX0se3RmT3BOYW1lOlwiQ29udjJEQmFja3Byb3BJbnB1dFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDoyLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MCxuYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZXhwbGljaXRfcGFkZGluZ3NcIixuYW1lOlwiZXhwbGljaXRQYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbXX0se3RmTmFtZTpcImRpbGF0aW9uc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRGVwdGh3aXNlQ29udjJkXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImlucHV0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJleHBsaWNpdF9wYWRkaW5nc1wiLG5hbWU6XCJleHBsaWNpdFBhZGRpbmdzXCIsdHlwZTpcIm51bWJlcltdXCIsZGVmYXVsdFZhbHVlOltdfSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZXhwbGljaXRfcGFkZGluZ3NcIixuYW1lOlwiZXhwbGljaXRQYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbXX0se3RmTmFtZTpcImRpbGF0aW9uc1wiLG5hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJGdXNlZERlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixlbmQ6MCxuYW1lOlwiYXJnc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm51bV9hcmdzXCIsbmFtZTpcIm51bUFyZ3NcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbMSwxLDEsMV19LHt0Zk5hbWU6XCJmdXNlZF9vcHNcIixuYW1lOlwiZnVzZWRPcHNcIix0eXBlOlwic3RyaW5nW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJleHBsaWNpdF9wYWRkaW5nc1wiLG5hbWU6XCJleHBsaWNpdFBhZGRpbmdzXCIsdHlwZTpcIm51bWJlcltdXCIsZGVmYXVsdFZhbHVlOltdfV19LHt0Zk9wTmFtZTpcIkNvbnYzRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRGlsYXRpb24yRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInJhdGVzXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9XX1dLEdDPXt9O19lKEdDLHtqc29uOigpPT52cX0pO3ZhciB2cT1be3RmT3BOYW1lOlwiRmlsbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MSxuYW1lOlwidmFsdWVcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJMaW5TcGFjZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzdGFydFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcInN0b3BcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJudW1cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiT25lSG90XCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkZXB0aFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcIm9uVmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHtzdGFydDozLG5hbWU6XCJvZmZWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJPbmVzXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJPbmVzTGlrZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlJhbmRvbVN0YW5kYXJkTm9ybWFsXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcIlRcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJhbmRvbVVuaWZvcm1cIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwibWludmFsXCIsbmFtZTpcIm1pbnZhbFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcIm1heHZhbFwiLG5hbWU6XCJtYXh2YWxcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwic2VlZFwiLG5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwic2VlZDJcIixuYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJUXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSYW5kb21Vbmlmb3JtSW50XCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1pbnZhbFwiLG5hbWU6XCJtaW52YWxcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJtYXh2YWxcIixuYW1lOlwibWF4dmFsXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwic2VlZFwiLG5hbWU6XCJzZWVkXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwic2VlZDJcIixuYW1lOlwic2VlZDJcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjAsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJhbmdlXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInN0YXJ0XCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwic3RvcFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcInN0ZXBcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XSxhdHRyczpbe3RmTmFtZTpcIlRpZHhcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUcnVuY2F0ZWROb3JtYWxcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwibWVhbnNcIixuYW1lOlwibWVhblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInN0ZGRldlwiLG5hbWU6XCJzdGREZXZcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJzZWVkXCIsbmFtZTpcInNlZWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJzZWVkMlwiLG5hbWU6XCJzZWVkMlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJUXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJaZXJvc1wiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiWmVyb3NMaWtlXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJNdWx0aW5vbWlhbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJsb2dpdHNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJudW1TYW1wbGVzXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzZWVkXCIsbmFtZTpcInNlZWRcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJzZWVkMlwiLG5hbWU6XCJzZWVkMlwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcIm91dHB1dF9kdHlwZVwiLG5hbWU6XCJvdXRwdXRfZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfV0sSEM9e307X2UoSEMse2pzb246KCk9PndxfSk7dmFyIHdxPVt7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblYyXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY29yZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJtYXhPdXRwdXRTaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MyxuYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjNcIixjYXRlZ29yeTpcImR5bmFtaWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJib3hlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjb3Jlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm1heE91dHB1dFNpemVcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDozLG5hbWU6XCJpb3VUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDo0LG5hbWU6XCJzY29yZVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblY0XCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY29yZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJtYXhPdXRwdXRTaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MyxuYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6NCxuYW1lOlwic2NvcmVUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUX3RocmVzaG9sZFwiLG5hbWU6XCJ0aHJlc2hvbGRcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJwYWRfdG9fbWF4X291dHB1dF9zaXplXCIsbmFtZTpcInBhZFRvTWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjMsbmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjQsbmFtZTpcInNjb3JlVGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6NSxuYW1lOlwic29mdE5tc1NpZ21hXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIldoZXJlXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxpc3REaWZmXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGpDPXt9O19lKGpDLHtqc29uOigpPT5rcX0pO3ZhciBrcT1be3RmT3BOYW1lOlwiTG93ZXJCb3VuZFwiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNvcnRlZFNlcXVlbmNlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwidmFsdWVzXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlRvcEtWMlwiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJrXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzb3J0ZWRcIixuYW1lOlwic29ydGVkXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJVcHBlckJvdW5kXCIsY2F0ZWdvcnk6XCJldmFsdWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic29ydGVkU2VxdWVuY2VcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiVW5pcXVlXCIsY2F0ZWdvcnk6XCJldmFsdWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJVbmlxdWVWMlwiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19XSxxQz17fTtfZShxQyx7anNvbjooKT0+SXF9KTt2YXIgSXE9W3t0Zk9wTmFtZTpcIlBsYWNlaG9sZGVyV2l0aERlZmF1bHRcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiZGVmYXVsdFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic2hhcGVcIixuYW1lOlwic2hhcGVcIix0eXBlOlwic2hhcGVcIn0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiUGxhY2Vob2xkZXJcIixjYXRlZ29yeTpcImdyYXBoXCIsYXR0cnM6W3t0Zk5hbWU6XCJzaGFwZVwiLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJDb25zdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIn0se3RmT3BOYW1lOlwiSWRlbnRpdHlcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJJZGVudGl0eU5cIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiU25hcHNob3RcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJSYW5rXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2l6ZVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNoYXBlXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2hhcGVOXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIlByaW50XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkYXRhXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwibWVzc2FnZVwiLG5hbWU6XCJtZXNzYWdlXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZmlyc3RfblwiLG5hbWU6XCJmaXJzdE5cIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwic3VtbWFyaXplXCIsbmFtZTpcInN1bW1hcml6ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6M31dfSx7dGZPcE5hbWU6XCJOb09wXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbXX0se3RmT3BOYW1lOlwiU3RvcEdyYWRpZW50XCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiRmFrZVF1YW50V2l0aE1pbk1heFZhcnNcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwibWluXCIsbmFtZTpcIm1pblwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcIm1heFwiLG5hbWU6XCJtYXhcIix0eXBlOlwibnVtYmVyXCJ9XX1dLEtDPXt9O19lKEtDLHtqc29uOigpPT5TcX0pO3ZhciBTcT1be3RmT3BOYW1lOlwiSGFzaFRhYmxlXCIsY2F0ZWdvcnk6XCJoYXNoX3RhYmxlXCIsaW5wdXRzOltdLGF0dHJzOlt7dGZOYW1lOlwic2hhcmVkX25hbWVcIixuYW1lOlwic2hhcmVkTmFtZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcInVzZV9ub2RlX25hbWVfc2hhcmluZ1wiLG5hbWU6XCJ1c2VOb2RlTmFtZVNoYXJpbmdcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwia2V5X2R0eXBlXCIsbmFtZTpcImtleURUeXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJ2YWx1ZV9kdHlwZVwiLG5hbWU6XCJ2YWx1ZURUeXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiSGFzaFRhYmxlVjJcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W10sYXR0cnM6W3t0Zk5hbWU6XCJzaGFyZWRfbmFtZVwiLG5hbWU6XCJzaGFyZWROYW1lXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwidXNlX25vZGVfbmFtZV9zaGFyaW5nXCIsbmFtZTpcInVzZU5vZGVOYW1lU2hhcmluZ1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJrZXlfZHR5cGVcIixuYW1lOlwia2V5RFR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcInZhbHVlX2R0eXBlXCIsbmFtZTpcInZhbHVlRFR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJMb29rdXBUYWJsZUltcG9ydFwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRhYmxlSGFuZGxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia2V5c1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVGluXCIsbmFtZTpcInRJblwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRvdXRcIixuYW1lOlwidE91dFwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb29rdXBUYWJsZUltcG9ydFYyXCIsY2F0ZWdvcnk6XCJoYXNoX3RhYmxlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGFibGVIYW5kbGVcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJrZXlzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwidmFsdWVzXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUaW5cIixuYW1lOlwidEluXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVG91dFwiLG5hbWU6XCJ0T3V0XCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvb2t1cFRhYmxlRmluZFwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRhYmxlSGFuZGxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia2V5c1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVGluXCIsbmFtZTpcInRJblwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRvdXRcIixuYW1lOlwidE91dFwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb29rdXBUYWJsZUZpbmRWMlwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRhYmxlSGFuZGxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia2V5c1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVGluXCIsbmFtZTpcInRJblwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRvdXRcIixuYW1lOlwidE91dFwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb29rdXBUYWJsZVNpemVcIixjYXRlZ29yeTpcImhhc2hfdGFibGVcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0YWJsZUhhbmRsZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJMb29rdXBUYWJsZVNpemVWMlwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRhYmxlSGFuZGxlXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkluaXRpYWxpemVUYWJsZVwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRhYmxlSGFuZGxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia2V5c1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJJbml0aWFsaXplVGFibGVWMlwiLGNhdGVnb3J5OlwiaGFzaF90YWJsZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRhYmxlSGFuZGxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwia2V5c1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfV0sWEM9e307X2UoWEMse2pzb246KCk9Pk5xfSk7dmFyIE5xPVt7dGZPcE5hbWU6XCJSZXNpemVCaWxpbmVhclwiLGNhdGVnb3J5OlwiaW1hZ2VcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbWFnZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFsaWduX2Nvcm5lcnNcIixuYW1lOlwiYWxpZ25Db3JuZXJzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImhhbGZfcGl4ZWxfY2VudGVyc1wiLG5hbWU6XCJoYWxmUGl4ZWxDZW50ZXJzXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVzaXplTmVhcmVzdE5laWdoYm9yXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImltYWdlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWxpZ25fY29ybmVyc1wiLG5hbWU6XCJhbGlnbkNvcm5lcnNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiaGFsZl9waXhlbF9jZW50ZXJzXCIsbmFtZTpcImhhbGZQaXhlbENlbnRlcnNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDcm9wQW5kUmVzaXplXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImltYWdlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJib3hJbmRcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJjcm9wU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtZXRob2RcIixuYW1lOlwibWV0aG9kXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZXh0cmFwb2xhdGlvbl92YWx1ZVwiLG5hbWU6XCJleHRyYXBvbGF0aW9uVmFsdWVcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiSW1hZ2VQcm9qZWN0aXZlVHJhbnNmb3JtVjNcIixjYXRlZ29yeTpcImltYWdlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW1hZ2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwidHJhbnNmb3Jtc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm91dHB1dFNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDozLG5hbWU6XCJmaWxsVmFsdWVcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImludGVycG9sYXRpb25cIixuYW1lOlwiaW50ZXJwb2xhdGlvblwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImZpbGxfbW9kZVwiLG5hbWU6XCJmaWxsTW9kZVwiLHR5cGU6XCJzdHJpbmdcIn1dfV0sWUM9e307X2UoWUMse2pzb246KCk9PlRxfSk7dmFyIFRxPVt7dGZPcE5hbWU6XCJFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk5vdEVxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiR3JlYXRlclwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkdyZWF0ZXJFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxlc3NcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZXNzRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2dpY2FsQW5kXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbE5vdFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbE9yXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2VsZWN0XCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2VsZWN0VjJcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJjb25kaXRpb25cIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJCaXR3aXNlQW5kXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9XX1dLFpDPXt9O19lKFpDLHtqc29uOigpPT5DcX0pO3ZhciBDcT1be3RmT3BOYW1lOlwiX0Z1c2VkTWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixlbmQ6MCxuYW1lOlwiYXJnc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm51bV9hcmdzXCIsbmFtZTpcIm51bUFyZ3NcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJmdXNlZF9vcHNcIixuYW1lOlwiZnVzZWRPcHNcIix0eXBlOlwic3RyaW5nW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjFlLTR9LHt0Zk5hbWU6XCJ0cmFuc3Bvc2VfYVwiLG5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJ0cmFuc3Bvc2VfYlwiLG5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJsZWFreXJlbHVfYWxwaGFcIixuYW1lOlwibGVha3lyZWx1QWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4yfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNYXRNdWxcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInRyYW5zcG9zZV9hXCIsbmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcInRyYW5zcG9zZV9iXCIsbmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQmF0Y2hNYXRNdWxcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFkal94XCIsbmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcImFkal95XCIsbmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQmF0Y2hNYXRNdWxWMlwiLGNhdGVnb3J5OlwibWF0cmljZXNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWRqX3hcIixuYW1lOlwidHJhbnNwb3NlQVwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwiYWRqX3lcIixuYW1lOlwidHJhbnNwb3NlQlwiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUcmFuc3Bvc2VcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInBlcm1cIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFaW5zdW1cIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcImVxdWF0aW9uXCIsbmFtZTpcImVxdWF0aW9uXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiTlwiLG5hbWU6XCJuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToyfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIk1hdHJpeEJhbmRQYXJ0XCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJudW1Mb3dlclwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcIm51bVVwcGVyXCIsdHlwZTpcInRlbnNvclwifV19XSxKQz17fTtfZShKQyx7anNvbjooKT0+RXF9KTt2YXIgRXE9W3t0Zk9wTmFtZTpcIkV1Y2xpZGVhbk5vcm1cIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX1dfSx7dGZPcE5hbWU6XCJGdXNlZEJhdGNoTm9ybVwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY2FsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm9mZnNldFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcIm1lYW5cIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDo0LG5hbWU6XCJ2YXJpYW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZXBzaWxvblwiLG5hbWU6XCJlcHNpbG9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMDAxfSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRnVzZWRCYXRjaE5vcm1WMlwiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY2FsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm9mZnNldFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcIm1lYW5cIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDo0LG5hbWU6XCJ2YXJpYW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZXBzaWxvblwiLG5hbWU6XCJlcHNpbG9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMDAxfSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRnVzZWRCYXRjaE5vcm1WM1wiLGNhdGVnb3J5Olwibm9ybWFsaXphdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY2FsZVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcIm9mZnNldFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcIm1lYW5cIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDo0LG5hbWU6XCJ2YXJpYW5jZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZXBzaWxvblwiLG5hbWU6XCJlcHNpbG9uXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouMDAxfSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTFJOXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZGVwdGhfcmFkaXVzXCIsbmFtZTpcInJhZGl1c1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6NX0se3RmTmFtZTpcImJpYXNcIixuYW1lOlwiYmlhc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmTmFtZTpcImFscGhhXCIsbmFtZTpcImFscGhhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwiYmV0YVwiLG5hbWU6XCJiZXRhXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTouNX1dfSx7dGZPcE5hbWU6XCJTb2Z0bWF4XCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJMb2dTb2Z0bWF4XCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfV0sUUM9e307X2UoUUMse2pzb246KCk9Pl9xfSk7dmFyIF9xPVt7dGZPcE5hbWU6XCJCaW5jb3VudFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJ3ZWlnaHRzXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkRlbnNlQmluY291bnRcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwid2VpZ2h0c1wiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYmluYXJ5X291dHB1dFwiLG5hbWU6XCJiaW5hcnlPdXRwdXRcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk1heFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJNZWFuXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk1pblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJTdW1cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQWxsXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFueVwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBcmdNYXhcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIkFyZ01pblwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiUHJvZFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ3VtcHJvZFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImV4Y2x1c2l2ZVwiLG5hbWU6XCJleGNsdXNpdmVcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwicmV2ZXJzZVwiLG5hbWU6XCJyZXZlcnNlXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJDdW1zdW1cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJleGNsdXNpdmVcIixuYW1lOlwiZXhjbHVzaXZlXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcInJldmVyc2VcIixuYW1lOlwicmV2ZXJzZVwiLHR5cGU6XCJib29sXCJ9XX1dLGVFPXt9O19lKGVFLHtqc29uOigpPT5BcX0pO3ZhciBBcT1be3RmT3BOYW1lOlwiQ29uY2F0VjJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLGVuZDotMSxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9LHtzdGFydDotMSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiTlwiLG5hbWU6XCJuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToyfV19LHt0Zk9wTmFtZTpcIkNvbmNhdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjEsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7c3RhcnQ6MCxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiTlwiLG5hbWU6XCJuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToyfV19LHt0Zk9wTmFtZTpcIkdhdGhlclYyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV0sYXR0cnM6W3t0Zk5hbWU6XCJiYXRjaF9kaW1zXCIsbmFtZTpcImJhdGNoRGltc1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJHYXRoZXJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLG5hbWU6XCJ2YWxpZGF0ZUluZGljZXNcIix0eXBlOlwiYm9vbFwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZXZlcnNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImRpbXNcIix0eXBlOlwiYm9vbFtdXCJ9XX0se3RmT3BOYW1lOlwiUmV2ZXJzZVYyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTbGljZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiZWdpblwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlN0cmlkZWRTbGljZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiZWdpblwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiZW5kXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDozLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImJlZ2luX21hc2tcIixuYW1lOlwiYmVnaW5NYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwiZW5kX21hc2tcIixuYW1lOlwiZW5kTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcIm5ld19heGlzX21hc2tcIixuYW1lOlwibmV3QXhpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJlbGxpcHNpc19tYXNrXCIsbmFtZTpcImVsbGlwc2lzTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInNocmlua19heGlzX21hc2tcIixuYW1lOlwic2hyaW5rQXhpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiUGFja1wiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiVW5wYWNrXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJudW1cIixuYW1lOlwibnVtXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJUaWxlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInJlcHNcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTcGxpdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHtzdGFydDoxLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJudW1fc3BsaXRcIixuYW1lOlwibnVtT3JTaXplU3BsaXRzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfV19LHt0Zk9wTmFtZTpcIlNwbGl0VlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJudW1PclNpemVTcGxpdHNcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9XX0se3RmT3BOYW1lOlwiU2NhdHRlck5kXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiR2F0aGVyTmRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTcGFyc2VUb0RlbnNlXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic3BhcnNlSW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcIm91dHB1dFNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJzcGFyc2VWYWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJkZWZhdWx0VmFsdWVcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInZhbGlkYXRlX2luZGljZXNcIixuYW1lOlwidmFsaWRhdGVJbmRpY2VzXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITEsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvclNjYXR0ZXJVcGRhdGVcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwidmFsdWVzXCIsdHlwZTpcInRlbnNvclwifV19XSx0RT17fTtfZSh0RSx7anNvbjooKT0+RnF9KTt2YXIgRnE9W3t0Zk9wTmFtZTpcIlNwYXJzZUZpbGxFbXB0eVJvd3NcIixjYXRlZ29yeTpcInNwYXJzZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJkZW5zZVNoYXBlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZGVmYXVsdFZhbHVlXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNwYXJzZVJlc2hhcGVcIixjYXRlZ29yeTpcInNwYXJzZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImlucHV0SW5kaWNlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImlucHV0U2hhcGVcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJuZXdTaGFwZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcGFyc2VTZWdtZW50TWVhblwiLGNhdGVnb3J5Olwic3BhcnNlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiZGF0YVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJzZWdtZW50SWRzXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNwYXJzZVNlZ21lbnRTdW1cIixjYXRlZ29yeTpcInNwYXJzZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwic2VnbWVudElkc1wiLHR5cGU6XCJ0ZW5zb3JcIn1dfV0sbkU9e307X2UobkUse2pzb246KCk9PiRxfSk7dmFyICRxPVt7dGZPcE5hbWU6XCJGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJJRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiUkZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmZ0X2xlbmd0aFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiSVJGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZmdF9sZW5ndGhcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19XSxhRT17fTtfZShhRSx7anNvbjooKT0+RHF9KTt2YXIgRHE9W3t0Zk9wTmFtZTpcIlN0YXRpY1JlZ2V4UmVwbGFjZVwiLGNhdGVnb3J5Olwic3RyaW5nXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW5wdXRcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInBhdHRlcm5cIixuYW1lOlwicGF0dGVyblwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcInJld3JpdGVcIixuYW1lOlwicmV3cml0ZVwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcInJlcGxhY2VfZ2xvYmFsXCIsbmFtZTpcInJlcGxhY2VHbG9iYWxcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIlN0cmluZ05HcmFtc1wiLGNhdGVnb3J5Olwic3RyaW5nXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiZGF0YVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImRhdGFTcGxpdHNcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInNlcGFyYXRvclwiLG5hbWU6XCJzZXBhcmF0b3JcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJuZ3JhbV93aWR0aHNcIixuYW1lOlwibkdyYW1XaWR0aHNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcImxlZnRfcGFkXCIsbmFtZTpcImxlZnRQYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJyaWdodF9wYWRcIixuYW1lOlwicmlnaHRQYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJwYWRfd2lkdGhcIixuYW1lOlwicGFkV2lkdGhcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJwcmVzZXJ2ZV9zaG9ydF9zZXF1ZW5jZXNcIixuYW1lOlwicHJlc2VydmVTaG9ydFNlcXVlbmNlc1wiLHR5cGU6XCJib29sXCJ9XSxvdXRwdXRzOltcIm5ncmFtc1wiLFwibmdyYW1zX3NwbGl0c1wiXX0se3RmT3BOYW1lOlwiU3RyaW5nU3BsaXRcIixjYXRlZ29yeTpcInN0cmluZ1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImlucHV0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZGVsaW1pdGVyXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJza2lwX2VtcHR5XCIsbmFtZTpcInNraXBFbXB0eVwiLHR5cGU6XCJib29sXCJ9XSxvdXRwdXRzOltcImluZGljZXNcIixcInZhbHVlc1wiLFwic2hhcGVcIl19LHt0Zk9wTmFtZTpcIlN0cmluZ1RvSGFzaEJ1Y2tldEZhc3RcIixjYXRlZ29yeTpcInN0cmluZ1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImlucHV0XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJudW1fYnVja2V0c1wiLG5hbWU6XCJudW1CdWNrZXRzXCIsdHlwZTpcIm51bWJlclwifV19XSxyRT17fTtfZShyRSx7anNvbjooKT0+UnF9KTt2YXIgUnE9W3t0Zk9wTmFtZTpcIkNhc3RcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiU3JjVFwiLG5hbWU6XCJzZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJEc3RUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiRXhwYW5kRGltc1wiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJNaXJyb3JQYWRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInBhZGRpbmdcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwibW9kZVwiLG5hbWU6XCJtb2RlXCIsdHlwZTpcInN0cmluZ1wifV19LHt0Zk9wTmFtZTpcIlBhZFwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicGFkZGluZ1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJjb25zdGFudF92YWx1ZVwiLG5hbWU6XCJjb25zdGFudFZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlBhZFYyXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwYWRkaW5nXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJjb25zdGFudFZhbHVlXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlJlc2hhcGVcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRW5zdXJlU2hhcGVcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3F1ZWV6ZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsdGZEZXByZWNhdGVkTmFtZTpcInNxdWVlemVfZGltc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3BhY2VUb0JhdGNoTkRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJsb2NrU2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInBhZGRpbmdzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiQmF0Y2hUb1NwYWNlTkRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJsb2NrU2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImNyb3BzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiRGVwdGhUb1NwYWNlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImJsb2NrX3NpemVcIixuYW1lOlwiYmxvY2tTaXplXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIn1dfSx7dGZPcE5hbWU6XCJCcm9hZGNhc3RUb1wiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOltdfSx7dGZPcE5hbWU6XCJCcm9hZGNhc3RBcmdzXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInMwXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiczFcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbXX1dLHpJPWNsYXNze3N0YXRpYyBnZXQgSW5zdGFuY2UoKXtyZXR1cm4gdGhpcy5faW5zdGFuY2V8fCh0aGlzLl9pbnN0YW5jZT1uZXcgdGhpcyl9Y29uc3RydWN0b3IoKXtsZXQgZT1bV0MsQkMsVkMsVUMsR0MsSEMsakMscUMsS0MsWEMsWUMsWkMsSkMsUUMsZUUsdEUsbkUsYUUsckVdLHQ9W10uY29uY2F0KC4uLmUubWFwKG49Pm4uanNvbikpO3RoaXMub3BNYXBwZXJzPXQucmVkdWNlKChuLGEpPT4oblthLnRmT3BOYW1lXT1hLG4pLHt9KX10cmFuc2Zvcm1HcmFwaChlLHQ9e30pe2xldCBuPWUubm9kZSxhPVtdLHI9W10scz1bXSxpPW4ucmVkdWNlKChtLGYpPT4obVtmLm5hbWVdPXRoaXMubWFwTm9kZShmKSxmLm9wLnN0YXJ0c1dpdGgoXCJQbGFjZWhvbGRlclwiKT9hLnB1c2gobVtmLm5hbWVdKTpmLm9wPT09XCJDb25zdFwiP3IucHVzaChtW2YubmFtZV0pOihmLmlucHV0PT1udWxsfHxmLmlucHV0Lmxlbmd0aD09PTApJiZzLnB1c2gobVtmLm5hbWVdKSxtKSx7fSksbz1bXSxsPVtdLHU9e30scD17fTt0IT1udWxsJiYodT10aGlzLm1hcFNpZ25hdHVyZUVudHJpZXModC5pbnB1dHMpLHA9dGhpcy5tYXBTaWduYXR1cmVFbnRyaWVzKHQub3V0cHV0cykpO2xldCBkPU9iamVjdC5rZXlzKGkpO2QuZm9yRWFjaChtPT57bGV0IGY9aVttXTtmLmlucHV0TmFtZXMuZm9yRWFjaCgoZyxiKT0+e2xldFt5LCx4XT1TcihnKSx2PWlbeV07aWYodi5vdXRwdXRzIT1udWxsKXtsZXQgST12Lm91dHB1dHMuaW5kZXhPZih4KTtpZihJIT09LTEpe2xldCBOPWAke3l9OiR7SX1gO2YuaW5wdXROYW1lc1tiXT1OfX1mLmlucHV0cy5wdXNoKHYpLHYuY2hpbGRyZW4ucHVzaChmKX0pfSksT2JqZWN0LmtleXMocCkubGVuZ3RoPT09MD9kLmZvckVhY2gobT0+e2xldCBmPWlbbV07Zi5jaGlsZHJlbi5sZW5ndGg9PT0wJiZsLnB1c2goZil9KTpPYmplY3Qua2V5cyhwKS5mb3JFYWNoKG09PntsZXRbZl09U3IobSksZz1pW2ZdO2chPW51bGwmJihnLnNpZ25hdHVyZUtleT1wW21dLGwucHVzaChnKSl9KSxPYmplY3Qua2V5cyh1KS5sZW5ndGg+MD9PYmplY3Qua2V5cyh1KS5mb3JFYWNoKG09PntsZXRbZl09U3IobSksZz1pW2ZdO2cmJihnLnNpZ25hdHVyZUtleT11W21dLG8ucHVzaChnKSl9KTpvPWE7bGV0IGM9e307ZS5saWJyYXJ5IT1udWxsJiZlLmxpYnJhcnkuZnVuY3Rpb24hPW51bGwmJihjPWUubGlicmFyeS5mdW5jdGlvbi5yZWR1Y2UoKG0sZik9PihtW2Yuc2lnbmF0dXJlLm5hbWVdPXRoaXMubWFwRnVuY3Rpb24oZiksbSkse30pKTtsZXQgaD17bm9kZXM6aSxpbnB1dHM6byxvdXRwdXRzOmwsd2VpZ2h0czpyLHBsYWNlaG9sZGVyczphLHNpZ25hdHVyZTp0LGZ1bmN0aW9uczpjfTtyZXR1cm4gcy5sZW5ndGg+MCYmKGguaW5pdE5vZGVzPXMpLGh9bWFwU2lnbmF0dXJlRW50cmllcyhlKXtyZXR1cm4gT2JqZWN0LmtleXMoZXx8e30pLnJlZHVjZSgodCxuKT0+KHRbZVtuXS5uYW1lXT1uLHQpLHt9KX1tYXBOb2RlKGUpe2xldCB0PXpDKGUub3ApfHx0aGlzLm9wTWFwcGVyc1tlLm9wXXx8e307ZS5hdHRyPT1udWxsJiYoZS5hdHRyPXt9KTtsZXQgbj17bmFtZTplLm5hbWUsb3A6ZS5vcCxjYXRlZ29yeTp0LmNhdGVnb3J5LGlucHV0TmFtZXM6KGUuaW5wdXR8fFtdKS5tYXAoYT0+YS5zdGFydHNXaXRoKFwiXlwiKT9hLnNsaWNlKDEpOmEpLGlucHV0czpbXSxjaGlsZHJlbjpbXSxpbnB1dFBhcmFtczp7fSxhdHRyUGFyYW1zOnt9LHJhd0F0dHJzOmUuYXR0cixvdXRwdXRzOnQub3V0cHV0c307cmV0dXJuIHQuaW5wdXRzIT1udWxsJiYobi5pbnB1dFBhcmFtcz10LmlucHV0cy5yZWR1Y2UoKGEscik9PihhW3IubmFtZV09e3R5cGU6ci50eXBlLGlucHV0SW5kZXhTdGFydDpyLnN0YXJ0LGlucHV0SW5kZXhFbmQ6ci5lbmR9LGEpLHt9KSksdC5hdHRycyE9bnVsbCYmKG4uYXR0clBhcmFtcz10LmF0dHJzLnJlZHVjZSgoYSxyKT0+e2xldCBzPXIudHlwZSxpO3N3aXRjaChyLnR5cGUpe2Nhc2VcInN0cmluZ1wiOmk9WHgoZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSxpPT09dm9pZCAwJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihpPVh4KGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJzdHJpbmdbXVwiOmk9bnYoZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSxpPT09dm9pZCAwJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihpPW52KGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJudW1iZXJcIjppPVp4KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZXx8MCksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1aeChlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwibnVtYmVyW11cIjppPXR2KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT10dihlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiYm9vbFwiOmk9WXgoZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSxpPT09dm9pZCAwJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihpPVl4KGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJib29sW11cIjppPXJ2KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1ydihlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwic2hhcGVcIjppPWV2KGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1ldihlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwic2hhcGVbXVwiOmk9YXYoZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSxpPT09dm9pZCAwJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihpPWF2KGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJkdHlwZVwiOmk9SngoZS5hdHRyLHIudGZOYW1lLHIuZGVmYXVsdFZhbHVlKSxpPT09dm9pZCAwJiZyLnRmRGVwcmVjYXRlZE5hbWUmJihpPUp4KGUuYXR0cixyLnRmRGVwcmVjYXRlZE5hbWUsci5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJkdHlwZVtdXCI6aT1ReChlLmF0dHIsci50Zk5hbWUsci5kZWZhdWx0VmFsdWUpLGk9PT12b2lkIDAmJnIudGZEZXByZWNhdGVkTmFtZSYmKGk9UXgoZS5hdHRyLHIudGZEZXByZWNhdGVkTmFtZSxyLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcImZ1bmNcIjppPVdJKGUuYXR0cixyLnRmTmFtZSxyLmRlZmF1bHRWYWx1ZSksaT09PXZvaWQgMCYmci50ZkRlcHJlY2F0ZWROYW1lJiYoaT1XSShlLmF0dHIsci50ZkRlcHJlY2F0ZWROYW1lLHIuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwidGVuc29yXCI6Y2FzZVwidGVuc29yc1wiOmJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJhbSB0eXBlOiAke3IudHlwZX0gZm9yIG9wOiAke2Uub3B9YCl9cmV0dXJuIGFbci5uYW1lXT17dmFsdWU6aSx0eXBlOnN9LGF9LHt9KSksbn1tYXBGdW5jdGlvbihlKXtsZXQgdD1lLm5vZGVEZWYsbj1bXSxhPVtdLHI9e307dCE9bnVsbCYmKHI9dC5yZWR1Y2UoKHUscCk9Pih1W3AubmFtZV09dGhpcy5tYXBOb2RlKHApLHAub3A9PT1cIkNvbnN0XCImJmEucHVzaCh1W3AubmFtZV0pLHUpLHt9KSk7bGV0IHM9W10saT1bXTtlLnNpZ25hdHVyZS5pbnB1dEFyZy5mb3JFYWNoKHU9PntsZXRbcF09U3IodS5uYW1lKSxkPXtuYW1lOnAsb3A6XCJQbGFjZWhvbGRlclwiLGlucHV0czpbXSxpbnB1dE5hbWVzOltdLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dFBhcmFtczp7fSxhdHRyUGFyYW1zOntkdHlwZTp7dmFsdWU6QTEodS50eXBlKSx0eXBlOlwiZHR5cGVcIn19LGNoaWxkcmVuOltdfTtkLnNpZ25hdHVyZUtleT11Lm5hbWUscy5wdXNoKGQpLHJbcF09ZH0pLE9iamVjdC5rZXlzKHIpLmZvckVhY2godT0+e2xldCBwPXJbdV07cC5pbnB1dE5hbWVzLmZvckVhY2goKGQsYyk9PntsZXRbaCwsbV09U3IoZCksZj1yW2hdO2lmKGYub3V0cHV0cyE9bnVsbCl7bGV0IGc9Zi5vdXRwdXRzLmluZGV4T2YobSk7aWYoZyE9PS0xKXtsZXQgYj1gJHtofToke2d9YDtwLmlucHV0TmFtZXNbY109Yn19cC5pbnB1dHMucHVzaChmKSxmLmNoaWxkcmVuLnB1c2gocCl9KX0pO2xldCBvPWUucmV0O2Uuc2lnbmF0dXJlLm91dHB1dEFyZy5mb3JFYWNoKHU9PntsZXRbcCxkXT1TcihvW3UubmFtZV0pLGM9cltwXTtjIT1udWxsJiYoYy5kZWZhdWx0T3V0cHV0PWQsaS5wdXNoKGMpKX0pO2xldCBsPXRoaXMubWFwQXJnc1RvU2lnbmF0dXJlKGUpO3JldHVybntub2RlczpyLGlucHV0czpzLG91dHB1dHM6aSx3ZWlnaHRzOmEscGxhY2Vob2xkZXJzOm4sc2lnbmF0dXJlOmx9fW1hcEFyZ3NUb1NpZ25hdHVyZShlKXtyZXR1cm57bWV0aG9kTmFtZTplLnNpZ25hdHVyZS5uYW1lLGlucHV0czplLnNpZ25hdHVyZS5pbnB1dEFyZy5yZWR1Y2UoKHQsbik9Pih0W24ubmFtZV09dGhpcy5tYXBBcmdUb1RlbnNvckluZm8obiksdCkse30pLG91dHB1dHM6ZS5zaWduYXR1cmUub3V0cHV0QXJnLnJlZHVjZSgodCxuKT0+KHRbbi5uYW1lXT10aGlzLm1hcEFyZ1RvVGVuc29ySW5mbyhuLGUucmV0KSx0KSx7fSl9fW1hcEFyZ1RvVGVuc29ySW5mbyhlLHQpe2xldCBuPWUubmFtZTtyZXR1cm4gdCE9bnVsbCYmKG49dFtuXSkse25hbWU6bixkdHlwZTplLnR5cGV9fX07ZnVuY3Rpb24gTXEoZSl7bGV0IHQ9RygpLmdsb2JhbDtpZih0eXBlb2YgdC5hdG9iIT1cInVuZGVmaW5lZFwiKXJldHVybiB0LmF0b2IoZSk7aWYodHlwZW9mIEJ1ZmZlciE9XCJ1bmRlZmluZWRcIilyZXR1cm4gbmV3IEJ1ZmZlcihlLFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSBiYXNlNjQgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlzc2luZyBidWlsdC1pbiBhdG9iKCkgb3IgQnVmZmVyKClcIil9ZnVuY3Rpb24gc0UoZSx0KXtsZXQgbj1BcnJheS5pc0FycmF5KGUpP1N0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlKTpNcShlKTtyZXR1cm4gdD9uOm4udG9Mb3dlckNhc2UoKX1mdW5jdGlvbiBYeChlLHQsbixhPSExKXtsZXQgcj1lW3RdO3JldHVybiByIT1udWxsP3NFKHIucyxhKTpufWZ1bmN0aW9uIFl4KGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhP2EuYjpufWZ1bmN0aW9uIFp4KGUsdCxuKXtsZXQgYT1lW3RdfHx7fSxyPWEuaSE9bnVsbD9hLmk6YS5mIT1udWxsP2EuZjpuO3JldHVybiB0eXBlb2Ygcj09XCJudW1iZXJcIj9yOnBhcnNlSW50KHIsMTApfWZ1bmN0aW9uIEExKGUpe3N3aXRjaCh0eXBlb2YgZT09XCJzdHJpbmdcIiYmKGU9cW5bZV0pLGUpe2Nhc2UgcW4uRFRfRkxPQVQ6Y2FzZSBxbi5EVF9IQUxGOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgcW4uRFRfSU5UMzI6Y2FzZSBxbi5EVF9JTlQ2NDpjYXNlIHFuLkRUX0lOVDg6Y2FzZSBxbi5EVF9VSU5UODpyZXR1cm5cImludDMyXCI7Y2FzZSBxbi5EVF9CT09MOnJldHVyblwiYm9vbFwiO2Nhc2UgcW4uRFRfRE9VQkxFOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgcW4uRFRfU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBxbi5EVF9DT01QTEVYNjQ6Y2FzZSBxbi5EVF9DT01QTEVYMTI4OnJldHVyblwiY29tcGxleDY0XCI7ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gV0koZSx0LG4pe2xldCBhPWVbdF07cmV0dXJuIGEmJmEuZnVuYz9hLmZ1bmMubmFtZTpufWZ1bmN0aW9uIEp4KGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhJiZhLnR5cGU/QTEoYS50eXBlKTpufWZ1bmN0aW9uIFF4KGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhJiZhLmxpc3QmJmEubGlzdC50eXBlP2EubGlzdC50eXBlLm1hcChyPT5BMShyKSk6bn1mdW5jdGlvbiBpRShlKXtpZighZS51bmtub3duUmFuaylyZXR1cm4gZS5kaW0hPW51bGw/ZS5kaW0ubWFwKHQ9PnR5cGVvZiB0LnNpemU9PVwibnVtYmVyXCI/dC5zaXplOnBhcnNlSW50KHQuc2l6ZSwxMCkpOltdfWZ1bmN0aW9uIGV2KGUsdCxuKXtsZXQgYT1lW3RdO3JldHVybiBhJiZhLnNoYXBlP2lFKGEuc2hhcGUpOm59ZnVuY3Rpb24gdHYoZSx0LG4pe2xldCBhPWVbdF07cmV0dXJuIGE/KChhLmxpc3QuZiYmYS5saXN0LmYubGVuZ3RoP2EubGlzdC5mOmEubGlzdC5pKXx8W10pLm1hcChyPT50eXBlb2Ygcj09XCJudW1iZXJcIj9yOnBhcnNlSW50KHIsMTApKTpufWZ1bmN0aW9uIG52KGUsdCxuLGE9ITEpe2xldCByPWVbdF07cmV0dXJuIHImJnIubGlzdCYmci5saXN0LnM/ci5saXN0LnMubWFwKHM9PnNFKHMsYSkpOm59ZnVuY3Rpb24gYXYoZSx0LG4pe2xldCBhPWVbdF07cmV0dXJuIGEmJmEubGlzdCYmYS5saXN0LnNoYXBlP2EubGlzdC5zaGFwZS5tYXAocj0+aUUocikpOm59ZnVuY3Rpb24gcnYoZSx0LG4pe2xldCBhPWVbdF07cmV0dXJuIGEmJmEubGlzdCYmYS5saXN0LmI/YS5saXN0LmI6bn12YXIgT3E9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMubm9kZT1lLHRoaXMudGVuc29yTWFwPXQsdGhpcy5jb250ZXh0PW4sdGhpcy5pbnB1dHM9W10sdGhpcy5hdHRycz17fSx0aGlzLmlucHV0cz1lLmlucHV0TmFtZXMubWFwKGE9PnRoaXMuZ2V0SW5wdXQoYSkpLGUucmF3QXR0cnMhPW51bGwmJih0aGlzLmF0dHJzPU9iamVjdC5rZXlzKGUucmF3QXR0cnMpLnJlZHVjZSgoYSxyKT0+KGFbcl09dGhpcy5nZXRBdHRyKHIpLGEpLHt9KSl9Z2V0SW5wdXQoZSl7cmV0dXJuIHBuKGUsdGhpcy50ZW5zb3JNYXAsdGhpcy5jb250ZXh0KX1nZXRBdHRyKGUsdCl7bGV0IG49dGhpcy5ub2RlLnJhd0F0dHJzW2VdO2lmKG4udGVuc29yIT1udWxsKXJldHVybiBwbihlLHRoaXMudGVuc29yTWFwLHRoaXMuY29udGV4dCk7aWYobi5pIT1udWxsfHxuLmYhPW51bGwpcmV0dXJuIFp4KHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG4ucyE9bnVsbClyZXR1cm4gWHgodGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobi5iIT1udWxsKXJldHVybiBZeCh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihuLnNoYXBlIT1udWxsKXJldHVybiBldih0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihuLnR5cGUhPW51bGwpcmV0dXJuIEp4KHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG4ubGlzdCE9bnVsbCl7aWYobi5saXN0LmkhPW51bGx8fG4ubGlzdC5mIT1udWxsKXJldHVybiB0dih0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihuLmxpc3QucyE9bnVsbClyZXR1cm4gbnYodGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobi5saXN0LnNoYXBlIT1udWxsKXJldHVybiBhdih0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihuLmxpc3QuYiE9bnVsbClyZXR1cm4gcnYodGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobi5saXN0LnR5cGUhPW51bGwpcmV0dXJuIFF4KHRoaXMubm9kZS5yYXdBdHRycyxlLHQpfXJldHVybiB0fX0sb249e307X2Uob24se09QX1NDT1BFX1NVRkZJWDooKT0+RnYsYWJzOigpPT5MdCxhY29zOigpPT5QdixhY29zaDooKT0+THYsYWRkOigpPT5YLGFkZE46KCk9PnZOLGFsbDooKT0+TG0sYW55OigpPT55YyxhcmdNYXg6KCk9PmRpLGFyZ01pbjooKT0+enYsYXNpbjooKT0+V3YsYXNpbmg6KCk9PkJ2LGF0YW46KCk9PlZ2LGF0YW4yOigpPT5VdixhdGFuaDooKT0+R3YsYXZnUG9vbDooKT0+eWEsYXZnUG9vbDNkOigpPT5qdixiYXNpY0xTVE1DZWxsOigpPT5TTixiYXRjaE5vcm06KCk9Pk5zLGJhdGNoTm9ybTJkOigpPT5xdixiYXRjaE5vcm0zZDooKT0+S3YsYmF0Y2hOb3JtNGQ6KCk9Plh2LGJhdGNoVG9TcGFjZU5EOigpPT5pZCxiaW5jb3VudDooKT0+WXYsYml0d2lzZUFuZDooKT0+Tk4sYm9vbGVhbk1hc2tBc3luYzooKT0+bVQsYnJvYWRjYXN0QXJnczooKT0+VE4sYnJvYWRjYXN0VG86KCk9PmFpLGJ1ZmZlcjooKT0+T2UsY2FzdDooKT0+cmUsY2VpbDooKT0+WnYsY2xpcEJ5VmFsdWU6KCk9PmFuLGNsb25lOigpPT5zcixjb21wbGV4OigpPT5fcixjb25jYXQ6KCk9PmV0LGNvbmNhdDFkOigpPT5Kdixjb25jYXQyZDooKT0+UXYsY29uY2F0M2Q6KCk9PmV3LGNvbmNhdDRkOigpPT50dyxjb252MWQ6KCk9PnptLGNvbnYyZDooKT0+JHQsY29udjJkVHJhbnNwb3NlOigpPT5XbSxjb252M2Q6KCk9PmF3LGNvbnYzZFRyYW5zcG9zZTooKT0+cncsY29zOigpPT5vZCxjb3NoOigpPT5CbSxjb3NpbmVXaW5kb3c6KCk9PnBmLGN1bXByb2Q6KCk9PndjLGN1bXN1bTooKT0+Vm0sZGVuc2VCaW5jb3VudDooKT0+WGgsZGVwdGhUb1NwYWNlOigpPT5zdyxkZXB0aHdpc2VDb252MmQ6KCk9PlRzLGRpYWc6KCk9PkVOLGRpbGF0aW9uMmQ6KCk9Pml3LGRpdjooKT0+aGUsZGl2Tm9OYW46KCk9Pm93LGRvdDooKT0+bHcsZHJvcG91dDooKT0+UHcsZWluc3VtOigpPT5acyxlbHU6KCk9PlF1LGVuY2xvc2luZ1Bvd2VyT2ZUd286KCk9Pkx3LGVuc3VyZVNoYXBlOigpPT5BTixlcXVhbDooKT0+Sm4sZXJmOigpPT5VbSxldWNsaWRlYW5Ob3JtOigpPT5jdyxleHA6KCk9PmRuLGV4cGFuZERpbXM6KCk9Pkd0LGV4cG0xOigpPT5kdyxleWU6KCk9PkdtLGZmdDooKT0+YmQsZmlsbDooKT0+eW4sZmxvb3I6KCk9PnRwLGZsb29yRGl2OigpPT5QbSxmdXNlZDooKT0+VmwsZ2F0aGVyOigpPT5ucCxnYXRoZXJORDooKT0+eVQsZ3JlYXRlcjooKT0+Q24sZ3JlYXRlckVxdWFsOigpPT4kcixpZmZ0OigpPT5CbCxpbWFnOigpPT5sZCxpbWFnZTooKT0+Wm4saW5Ub3BLQXN5bmM6KCk9PnhULGlyZmZ0OigpPT5hZixpc0Zpbml0ZTooKT0+aHcsaXNJbmY6KCk9Pm13LGlzTmFOOigpPT5mdyxsZWFreVJlbHU6KCk9PnVkLGxlc3M6KCk9PlBsLGxlc3NFcXVhbDooKT0+Q3MsbGluYWxnOigpPT5CdyxsaW5zcGFjZTooKT0+TU4sbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246KCk9Pmd3LGxvZzooKT0+UW4sbG9nMXA6KCk9PnBkLGxvZ1NpZ21vaWQ6KCk9PmJ3LGxvZ1NvZnRtYXg6KCk9PmptLGxvZ1N1bUV4cDooKT0+Y2QsbG9naWNhbEFuZDooKT0+X2EsbG9naWNhbE5vdDooKT0+ZGQsbG9naWNhbE9yOigpPT5xbSxsb2dpY2FsWG9yOigpPT55dyxsb3NzZXM6KCk9PkZULGxvd2VyQm91bmQ6KCk9PlBOLG1hdE11bDooKT0+JGUsbWF4OigpPT5tYSxtYXhQb29sOigpPT5EdCxtYXhQb29sM2Q6KCk9Pnh3LG1heFBvb2xXaXRoQXJnbWF4OigpPT5MTixtYXhpbXVtOigpPT5ocixtZWFuOigpPT5DdCxtZXNoZ3JpZDooKT0+ek4sbWluOigpPT5PbCxtaW5pbXVtOigpPT5kcyxtaXJyb3JQYWQ6KCk9PnZ3LG1vZDooKT0+d3csbW9tZW50czooKT0+aGQsbW92aW5nQXZlcmFnZTooKT0+ZlQsbXVsOigpPT56LG11bHRpUk5OQ2VsbDooKT0+V04sbXVsdGlub21pYWw6KCk9PkJOLG5lZzooKT0+eXQsbm9ybTooKT0+ZXAsbm90RXF1YWw6KCk9PmZpLG9uZUhvdDooKT0+TGwsb25lczooKT0+UG4sb25lc0xpa2U6KCk9PmVhLG9wOigpPT5MLG91dGVyUHJvZHVjdDooKT0+Vk4scGFkOigpPT54YSxwYWQxZDooKT0+VU4scGFkMmQ6KCk9PkdOLHBhZDNkOigpPT5ITixwYWQ0ZDooKT0+ak4scG9vbDooKT0+a3cscG93OigpPT51cixwcmVsdTooKT0+ZmQscHJpbnQ6KCk9Pk92LHByb2Q6KCk9Pkl3LHJhZ2dlZEdhdGhlcjooKT0+cU4scmFnZ2VkUmFuZ2U6KCk9PktOLHJhZ2dlZFRlbnNvclRvVGVuc29yOigpPT5YTixyYW5kOigpPT5ZTixyYW5kb21HYW1tYTooKT0+ZVQscmFuZG9tTm9ybWFsOigpPT5YbSxyYW5kb21TdGFuZGFyZE5vcm1hbDooKT0+dFQscmFuZG9tVW5pZm9ybTooKT0+RXMscmFuZG9tVW5pZm9ybUludDooKT0+blQscmFuZ2U6KCk9PmdpLHJlYWw6KCk9PnpsLHJlY2lwcm9jYWw6KCk9PkV3LHJlbHU6KCk9PktlLHJlbHU2OigpPT5ZbSxyZXNoYXBlOigpPT5XLHJldmVyc2U6KCk9PmJhLHJldmVyc2UxZDooKT0+YVQscmV2ZXJzZTJkOigpPT5yVCxyZXZlcnNlM2Q6KCk9PnNULHJldmVyc2U0ZDooKT0+aVQscmZmdDooKT0+eWQscm91bmQ6KCk9PlptLHJzcXJ0OigpPT5KbSxzY2FsYXI6KCk9PnhlLHNjYXR0ZXJORDooKT0+Z1Qsc2VhcmNoU29ydGVkOigpPT5LbSxzZWx1OigpPT5RbSxzZXBhcmFibGVDb252MmQ6KCk9Pl9zLHNldGRpZmYxZEFzeW5jOigpPT5vVCxzaWdtb2lkOigpPT5oYSxzaWduOigpPT5fdyxzaWduYWw6KCk9PkFULHNpbjooKT0+ZWYsc2luaDooKT0+dGYsc2xpY2U6KCk9PlZlLHNsaWNlMWQ6KCk9PmdkLHNsaWNlMmQ6KCk9Pm5mLHNsaWNlM2Q6KCk9PkhvLHNsaWNlNGQ6KCk9PldsLHNvZnRtYXg6KCk9PnFhLHNvZnRwbHVzOigpPT5HbyxzcGFjZVRvQmF0Y2hORDooKT0+bWQsc3BhcnNlOigpPT4kVCxzcGFyc2VUb0RlbnNlOigpPT5iVCxzcGVjdHJhbDooKT0+X1Qsc3BsaXQ6KCk9PkxuLHNxcnQ6KCk9PnJuLHNxdWFyZTooKT0+cHQsc3F1YXJlZERpZmZlcmVuY2U6KCk9PnJmLHNxdWVlemU6KCk9PkFzLHN0YWNrOigpPT5BdCxzdGVwOigpPT5qbyxzdHJpZGVkU2xpY2U6KCk9PkF3LHN0cmluZzooKT0+RFQsc3ViOigpPT5wZSxzdW06KCk9PmZlLHRhbjooKT0+RncsdGFuaDooKT0+Y3MsdGVuc29yOigpPT5ibix0ZW5zb3IxZDooKT0+amUsdGVuc29yMmQ6KCk9PkVhLHRlbnNvcjNkOigpPT54ZCx0ZW5zb3I0ZDooKT0+RmEsdGVuc29yNWQ6KCk9PmxULHRlbnNvcjZkOigpPT51VCx0ZW5zb3JTY2F0dGVyVXBkYXRlOigpPT5jVCx0aWxlOigpPT5Pbix0b3BrOigpPT5Edyx0cmFuc3Bvc2U6KCk9PkRlLHRydW5jYXRlZE5vcm1hbDooKT0+bGYsdW5pcXVlOigpPT5Sdyx1bnNvcnRlZFNlZ21lbnRTdW06KCk9PnVmLHVuc3RhY2s6KCk9PmR0LHVwcGVyQm91bmQ6KCk9PmRULHZhcmlhYmxlOigpPT5Ndyx3aGVyZTooKT0+bm4sd2hlcmVBc3luYzooKT0+T3csemVyb3M6KCk9Pkl0LHplcm9zTGlrZTooKT0+cWV9KTt2YXIgUHE9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkJpYXNBZGRcIjpjYXNlXCJBZGRWMlwiOmNhc2VcIkFkZFwiOnJldHVyblthLmFkZChrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkFkZE5cIjpyZXR1cm5bYS5hZGROKGsoXCJ0ZW5zb3JzXCIsZSx0LG4pKV07Y2FzZVwiRmxvb3JNb2RcIjpjYXNlXCJNb2RcIjpyZXR1cm5bYS5tb2QoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJNdWxcIjpyZXR1cm5bYS5tdWwoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJSZWFsRGl2XCI6Y2FzZVwiRGl2XCI6cmV0dXJuW2EuZGl2KGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiRGl2Tm9OYW5cIjpyZXR1cm5bYS5kaXZOb05hbihrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkZsb29yRGl2XCI6cmV0dXJuW2EuZmxvb3JEaXYoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJTdWJcIjpyZXR1cm5bYS5zdWIoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJNaW5pbXVtXCI6cmV0dXJuW2EubWluaW11bShrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIk1heGltdW1cIjpyZXR1cm5bYS5tYXhpbXVtKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiUG93XCI6cmV0dXJuW2EucG93KGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiU3F1YXJlZERpZmZlcmVuY2VcIjpyZXR1cm5bYS5zcXVhcmVkRGlmZmVyZW5jZShrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LExxPShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJBYnNcIjpjYXNlXCJDb21wbGV4QWJzXCI6cmV0dXJuW2EuYWJzKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQWNvc1wiOnJldHVyblthLmFjb3MoayhcInhcIixlLHQsbikpXTtjYXNlXCJBY29zaFwiOnJldHVyblthLmFjb3NoKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQXNpblwiOnJldHVyblthLmFzaW4oayhcInhcIixlLHQsbikpXTtjYXNlXCJBc2luaFwiOnJldHVyblthLmFzaW5oKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQXRhblwiOnJldHVyblthLmF0YW4oayhcInhcIixlLHQsbikpXTtjYXNlXCJBdGFuMlwiOnJldHVyblthLmF0YW4yKGsoXCJ4XCIsZSx0LG4pLGsoXCJ5XCIsZSx0LG4pKV07Y2FzZVwiQXRhbmhcIjpyZXR1cm5bYS5hdGFuaChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkNlaWxcIjpyZXR1cm5bYS5jZWlsKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiQ29tcGxleFwiOnJldHVyblthLmNvbXBsZXgoayhcInJlYWxcIixlLHQsbiksayhcImltYWdcIixlLHQsbikpXTtjYXNlXCJDb3NcIjpyZXR1cm5bYS5jb3MoayhcInhcIixlLHQsbikpXTtjYXNlXCJDb3NoXCI6cmV0dXJuW2EuY29zaChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkVsdVwiOnJldHVyblthLmVsdShrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkVyZlwiOnJldHVyblthLmVyZihrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkV4cFwiOnJldHVyblthLmV4cChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkV4cG0xXCI6cmV0dXJuW2EuZXhwbTEoayhcInhcIixlLHQsbikpXTtjYXNlXCJGbG9vclwiOnJldHVyblthLmZsb29yKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiTG9nXCI6cmV0dXJuW2EubG9nKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiTG9nMXBcIjpyZXR1cm5bYS5sb2cxcChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIkltYWdcIjpyZXR1cm5bYS5pbWFnKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiTmVnXCI6cmV0dXJuW2EubmVnKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiUmVjaXByb2NhbFwiOnJldHVyblthLnJlY2lwcm9jYWwoayhcInhcIixlLHQsbikpXTtjYXNlXCJSZWFsXCI6cmV0dXJuW2EucmVhbChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlJlbHVcIjpyZXR1cm5bYS5yZWx1KGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiUm91bmRcIjpyZXR1cm5bYS5yb3VuZChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlNlbHVcIjpyZXR1cm5bYS5zZWx1KGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiU2lnbW9pZFwiOnJldHVyblthLnNpZ21vaWQoayhcInhcIixlLHQsbikpXTtjYXNlXCJTaW5cIjpyZXR1cm5bYS5zaW4oayhcInhcIixlLHQsbikpXTtjYXNlXCJTaWduXCI6cmV0dXJuW2Euc2lnbihrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlNpbmhcIjpyZXR1cm5bYS5zaW5oKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiU29mdHBsdXNcIjpyZXR1cm5bYS5zb2Z0cGx1cyhrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlNxcnRcIjpyZXR1cm5bYS5zcXJ0KGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiU3F1YXJlXCI6cmV0dXJuW2Euc3F1YXJlKGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiVGFuaFwiOnJldHVyblthLnRhbmgoayhcInhcIixlLHQsbikpXTtjYXNlXCJUYW5cIjpyZXR1cm5bYS50YW4oayhcInhcIixlLHQsbikpXTtjYXNlXCJDbGlwQnlWYWx1ZVwiOnJldHVyblthLmNsaXBCeVZhbHVlKGsoXCJ4XCIsZSx0LG4pLGsoXCJjbGlwVmFsdWVNaW5cIixlLHQsbiksayhcImNsaXBWYWx1ZU1heFwiLGUsdCxuKSldO2Nhc2VcIlJlbHU2XCI6cmV0dXJuW2EucmVsdTYoayhcInhcIixlLHQsbikpXTtjYXNlXCJSc3FydFwiOnJldHVyblthLnJzcXJ0KHBuKGUuaW5wdXROYW1lc1swXSx0LG4pKV07Y2FzZVwiTGVha3lSZWx1XCI6cmV0dXJuW2EubGVha3lSZWx1KGsoXCJ4XCIsZSx0LG4pLGsoXCJhbHBoYVwiLGUsdCxuKSldO2Nhc2VcIlByZWx1XCI6cmV0dXJuW2EucHJlbHUoayhcInhcIixlLHQsbiksayhcImFscGhhXCIsZSx0LG4pKV07Y2FzZVwiSXNOYW5cIjpyZXR1cm5bYS5pc05hTihwbihlLmlucHV0TmFtZXNbMF0sdCxuKSldO2Nhc2VcIklzSW5mXCI6cmV0dXJuW2EuaXNJbmYocG4oZS5pbnB1dE5hbWVzWzBdLHQsbikpXTtjYXNlXCJJc0Zpbml0ZVwiOnJldHVyblthLmlzRmluaXRlKHBuKGUuaW5wdXROYW1lc1swXSx0LG4pKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX07ZnVuY3Rpb24gQ2EoZSx0LG49XCJcIil7aWYoISh0eXBlb2YgZT09XCJudW1iZXJcInx8dHlwZW9mIHQ9PVwibnVtYmVyXCIpKXt3LmFzc2VydChlLmxlbmd0aD09PXQubGVuZ3RoLCgpPT5uK2AgU2hhcGVzICR7ZX0gYW5kICR7dH0gbXVzdCBtYXRjaGApO2ZvcihsZXQgYT0wO2E8ZS5sZW5ndGg7YSsrKXtsZXQgcj1lW2FdLHM9dFthXTt3LmFzc2VydChyPDB8fHM8MHx8cj09PXMsKCk9Pm4rYCBTaGFwZXMgJHtlfSBhbmQgJHt0fSBtdXN0IG1hdGNoYCl9fX1mdW5jdGlvbiBCSShlKXtyZXR1cm4hKHR5cGVvZiBlPT1cIm51bWJlclwifHxlLnNvbWUodD0+dDwwKSl9ZnVuY3Rpb24gWnAoZSx0LG4pe2xldCBhPXN2KGUsbikscj0hQkkoYSk7aWYociYmdC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gY2FsY3VsYXRlIGVsZW1lbnRzIG9mIGFuIGVtcHR5IGxpc3Qgd2l0aCBub24tZnVsbHktZGVmaW5lZCBlbGVtZW50U2hhcGU6ICR7YX1gKTtpZihyJiZ0LmZvckVhY2gocz0+e2E9c3Yocy5zaGFwZSxhKX0pLCFCSShhKSl0aHJvdyBuZXcgRXJyb3IoYE5vbi1mdWxseS1kZWZpbmVkIGVsZW1lbnRTaGFwZTogJHthfWApO3JldHVybiBhfWZ1bmN0aW9uIHN2KGUsdCl7aWYodHlwZW9mIGU9PVwibnVtYmVyXCIpcmV0dXJuIHQ7aWYodHlwZW9mIHQ9PVwibnVtYmVyXCIpcmV0dXJuIGU7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSByYW5rcyBkdXJpbmcgbWVyZ2U6ICR7ZX0gdnMuICR7dH1gKTtsZXQgbj1bXTtmb3IobGV0IGE9MDthPGUubGVuZ3RoOysrYSl7bGV0IHI9ZVthXSxzPXRbYV07aWYocj49MCYmcz49MCYmciE9PXMpdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBhdGlibGUgc2hhcGUgZHVyaW5nIG1lcmdlOiAke2V9IHZzLiAke3R9YCk7blthXT1yPj0wP3I6c31yZXR1cm4gbn12YXIgenE9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyLHMsaSl7dGhpcy5uYW1lPWUsdGhpcy5kdHlwZT10LHRoaXMubWF4U2l6ZT1uLHRoaXMuZWxlbWVudFNoYXBlPWEsdGhpcy5pZGVudGljYWxFbGVtZW50U2hhcGVzPXIsdGhpcy5keW5hbWljU2l6ZT1zLHRoaXMuY2xlYXJBZnRlclJlYWQ9aSx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSExLHRoaXMuaWRUZW5zb3I9eGUoMCksSHQodGhpcy5pZFRlbnNvcil9Z2V0IGlkKCl7cmV0dXJuIHRoaXMuaWRUZW5zb3IuaWR9Z2V0IGNsb3NlZCgpe3JldHVybiB0aGlzLmNsb3NlZF99Y2xlYXJBbmRDbG9zZShlKXt0aGlzLnRlbnNvcnMuZm9yRWFjaCh0PT57KGU9PW51bGx8fCFlLmhhcyh0LnRlbnNvci5pZCkpJiZ0LnRlbnNvci5kaXNwb3NlKCl9KSx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSEwLHRoaXMuaWRUZW5zb3IuZGlzcG9zZSgpfXNpemUoKXtyZXR1cm4gdGhpcy50ZW5zb3JzLmxlbmd0aH1yZWFkKGUpe2lmKHRoaXMuY2xvc2VkXyl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5gKTtpZihlPDB8fGU+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gcmVhZCBmcm9tIGluZGV4ICR7ZX0sIGJ1dCBhcnJheSBzaXplIGlzOiAke3RoaXMuc2l6ZSgpfWApO2xldCB0PXRoaXMudGVuc29yc1tlXTtpZih0LmNsZWFyZWQpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX06IENvdWxkIG5vdCByZWFkIGluZGV4ICR7ZX0gdHdpY2UgYmVjYXVzZSBpdCB3YXMgY2xlYXJlZCBhZnRlciBhIHByZXZpb3VzIHJlYWQgKHBlcmhhcHMgdHJ5IHNldHRpbmcgY2xlYXJfYWZ0ZXJfcmVhZCA9IGZhbHNlPykuYCk7cmV0dXJuIHRoaXMuY2xlYXJBZnRlclJlYWQmJih0LmNsZWFyZWQ9ITApLHQucmVhZD0hMCx0LnRlbnNvcn1yZWFkTWFueShlKXtyZXR1cm4gZS5tYXAodD0+dGhpcy5yZWFkKHQpKX13cml0ZShlLHQpe2lmKHRoaXMuY2xvc2VkXyl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5gKTtpZihlPDB8fCF0aGlzLmR5bmFtaWNTaXplJiZlPj10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKGBUcmllZCB0byB3cml0ZSB0byBpbmRleCAke2V9LCBidXQgYXJyYXkgaXMgbm90IHJlc2l6ZWFibGUgYW5kIHNpemUgaXM6ICR7dGhpcy5tYXhTaXplfWApO2xldCBuPXRoaXMudGVuc29yc1tlXXx8e307aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX06IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCAke2V9LFxuICAgICAgICAgIGJlY2F1c2UgdGhlIHZhbHVlIGR0eXBlIGlzICR7dC5kdHlwZX0sIGJ1dCBUZW5zb3JBcnJheSBkdHlwZSBpcyAke3RoaXMuZHR5cGV9LmApO2lmKHRoaXMuc2l6ZSgpPT09MCYmKHRoaXMuZWxlbWVudFNoYXBlPT1udWxsfHx0aGlzLmVsZW1lbnRTaGFwZS5sZW5ndGg9PT0wKSYmKHRoaXMuZWxlbWVudFNoYXBlPXQuc2hhcGUpLENhKHRoaXMuZWxlbWVudFNoYXBlLHQuc2hhcGUsYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfTogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4ICR7ZX0uYCksbi5yZWFkKXRocm93IG5ldyBFcnJvcihgVGVuc29yQXJyYXkgJHt0aGlzLm5hbWV9OiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggJHtlfSwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHJlYWQuYCk7aWYobi53cml0dGVuKXRocm93IG5ldyBFcnJvcihgVGVuc29yQXJyYXkgJHt0aGlzLm5hbWV9OiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggJHtlfSwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW4uYCk7bi50ZW5zb3I9dCxIdCh0KSxuLndyaXR0ZW49ITAsdGhpcy50ZW5zb3JzW2VdPW59d3JpdGVNYW55KGUsdCl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfTogY291bGQgbm90IHdyaXRlIG11bHRpcGxlIHRlbnNvcnMsYmVjYXVzZSB0aGUgaW5kZXggc2l6ZTogJHtlLmxlbmd0aH0gaXMgbm90IHRoZSBzYW1lIGFzIHRlbnNvcnMgc2l6ZTogJHt0Lmxlbmd0aH0uYCk7ZS5mb3JFYWNoKChuLGEpPT50aGlzLndyaXRlKG4sdFthXSkpfWdhdGhlcihlLHQpe2lmKHQmJnQhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihgVGVuc29yQXJyYXkgZHR5cGUgaXMgJHt0aGlzLmR0eXBlfSBidXQgZ2F0aGVyIHJlcXVlc3RlZCBkdHlwZSAke3R9YCk7aWYoZSllPWUuc2xpY2UoMCx0aGlzLnNpemUoKSk7ZWxzZXtlPVtdO2ZvcihsZXQgYT0wO2E8dGhpcy5zaXplKCk7YSsrKWUucHVzaChhKX1pZihlLmxlbmd0aD09PTApcmV0dXJuIGJuKFtdLFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtsZXQgbj10aGlzLnJlYWRNYW55KGUpO3JldHVybiBDYSh0aGlzLmVsZW1lbnRTaGFwZSxuWzBdLnNoYXBlLFwiVGVuc29yQXJyYXkgc2hhcGUgbWlzbWF0Y2g6IFwiKSxBdChuLDApfWNvbmNhdChlKXtpZihlJiZlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5IGR0eXBlIGlzICR7dGhpcy5kdHlwZX0gYnV0IGNvbmNhdCByZXF1ZXN0ZWQgZHR5cGUgJHtlfWApO2lmKHRoaXMuc2l6ZSgpPT09MClyZXR1cm4gYm4oW10sWzBdLmNvbmNhdCh0aGlzLmVsZW1lbnRTaGFwZSkpO2xldCB0PVtdO2ZvcihsZXQgYT0wO2E8dGhpcy5zaXplKCk7YSsrKXQucHVzaChhKTtsZXQgbj10aGlzLnJlYWRNYW55KHQpO3JldHVybiBDYSh0aGlzLmVsZW1lbnRTaGFwZSxuWzBdLnNoYXBlLGBUZW5zb3JBcnJheSBzaGFwZSBtaXNtYXRjaDogdGVuc29yIGFycmF5IHNoYXBlICgke3RoaXMuZWxlbWVudFNoYXBlfSkgdnMgZmlyc3QgdGVuc29yIHNoYXBlICgke25bMF0uc2hhcGV9KWApLGV0KG4sMCl9c2NhdHRlcihlLHQpe2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihgVGVuc29yQXJyYXkgZHR5cGUgaXMgJHt0aGlzLmR0eXBlfSBidXQgdGVuc29yIGhhcyBkdHlwZSAke3QuZHR5cGV9YCk7aWYoZS5sZW5ndGghPT10LnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbGVuKGluZGljZXMpID09IHRlbnNvci5zaGFwZVswXSwgYnV0IHNhdzogJHtlLmxlbmd0aH0gdnMuICR7dC5zaGFwZVswXX1gKTtsZXQgbj1NYXRoLm1heCguLi5lKTtpZighdGhpcy5keW5hbWljU2l6ZSYmbj49dGhpcy5tYXhTaXplKXRocm93IG5ldyBFcnJvcihgTWF4IGluZGV4IG11c3QgYmUgPCBhcnJheSBzaXplICgke259ICB2cy4gJHt0aGlzLm1heFNpemV9KWApO3RoaXMud3JpdGVNYW55KGUsZHQodCwwKSl9c3BsaXQoZSx0KXtpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5IGR0eXBlIGlzICR7dGhpcy5kdHlwZX0gYnV0IHRlbnNvciBoYXMgZHR5cGUgJHt0LmR0eXBlfWApO2xldCBuPTAsYT1lLm1hcChvPT4obis9byxuKSk7aWYobiE9PXQuc2hhcGVbMF0pdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBzdW0gb2YgbGVuZ3RocyB0byBiZSBlcXVhbCB0b1xuICAgICAgICAgIHRlbnNvci5zaGFwZVswXSwgYnV0IHN1bSBvZiBsZW5ndGhzIGlzXG4gICAgICAgICR7bn0sIGFuZCB0ZW5zb3IncyBzaGFwZSBpczogJHt0LnNoYXBlfWApO2lmKCF0aGlzLmR5bmFtaWNTaXplJiZlLmxlbmd0aCE9PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5J3Mgc2l6ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHNpemUgb2YgbGVuZ3RocyAoJHt0aGlzLm1heFNpemV9IHZzLiAke2UubGVuZ3RofSksIGFuZCB0aGUgVGVuc29yQXJyYXkgaXMgbm90IG1hcmtlZCBhcyBkeW5hbWljYWxseSByZXNpemVhYmxlYCk7bGV0IHI9bj09PTA/MDp0LnNpemUvbixzPVtdO08oKCk9Pnt0PVcodCxbMSxuLHJdKTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyl7bGV0IGw9WzAsbz09PTA/MDphW28tMV0sMF0sdT1bMSxlW29dLHJdO3Nbb109VyhWZSh0LGwsdSksdGhpcy5lbGVtZW50U2hhcGUpfXJldHVybiBzfSk7bGV0IGk9W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDtvKyspaVtvXT1vO3RoaXMud3JpdGVNYW55KGkscyl9fSxMZj1jbGFzcyBpdntnZXQgaWQoKXtyZXR1cm4gdGhpcy5pZFRlbnNvci5pZH1jb25zdHJ1Y3Rvcih0LG4sYSxyPS0xKXt0aGlzLnRlbnNvcnM9dCx0aGlzLmVsZW1lbnRTaGFwZT1uLHRoaXMuZWxlbWVudER0eXBlPWEsdCE9bnVsbCYmdC5mb3JFYWNoKHM9PntpZihhIT09cy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHthfSwgYnV0IGxpc3QgZWxlbWVudHMgJHtzLmR0eXBlfWApO0NhKG4scy5zaGFwZSxcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKSxIdChzKX0pLHRoaXMuaWRUZW5zb3I9eGUoMCksdGhpcy5tYXhOdW1FbGVtZW50cz1yLEh0KHRoaXMuaWRUZW5zb3IpfWNvcHkoKXtyZXR1cm4gbmV3IGl2KFsuLi50aGlzLnRlbnNvcnNdLHRoaXMuZWxlbWVudFNoYXBlLHRoaXMuZWxlbWVudER0eXBlKX1jbGVhckFuZENsb3NlKHQpe3RoaXMudGVuc29ycy5mb3JFYWNoKG49PnsodD09bnVsbHx8IXQuaGFzKG4uaWQpKSYmbi5kaXNwb3NlKCl9KSx0aGlzLnRlbnNvcnMubGVuZ3RoPTAsdGhpcy5pZFRlbnNvci5kaXNwb3NlKCl9c2l6ZSgpe3JldHVybiB0aGlzLnRlbnNvcnMubGVuZ3RofXN0YWNrKHQsbixhPS0xKXtpZihuIT09dGhpcy5lbGVtZW50RHR5cGUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7bn0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7dGhpcy5lbGVtZW50RHR5cGV9YCk7aWYoYSE9PS0xJiZ0aGlzLnRlbnNvcnMubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoYE9wZXJhdGlvbiBleHBlY3RlZCBhIGxpc3Qgd2l0aCAke2F9IGVsZW1lbnRzIGJ1dCBnb3QgYSBsaXN0IHdpdGggJHt0aGlzLnRlbnNvcnMubGVuZ3RofSBlbGVtZW50cy5gKTtDYSh0LHRoaXMuZWxlbWVudFNoYXBlLFwiVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogXCIpO2xldCByPVpwKHRoaXMuZWxlbWVudFNoYXBlLHRoaXMudGVuc29ycyx0KTtyZXR1cm4gTygoKT0+e2xldCBzPXRoaXMudGVuc29ycy5tYXAoaT0+VyhpLHIpKTtyZXR1cm4gQXQocywwKX0pfXBvcEJhY2sodCxuKXtpZihuIT09dGhpcy5lbGVtZW50RHR5cGUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7bn0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7dGhpcy5lbGVtZW50RHR5cGV9YCk7aWYodGhpcy5zaXplKCk9PT0wKXRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBwb3AgZnJvbSBhbiBlbXB0eSBsaXN0LlwiKTtsZXQgYT1acCh0aGlzLmVsZW1lbnRTaGFwZSx0aGlzLnRlbnNvcnMsdCkscj10aGlzLnRlbnNvcnMucG9wKCk7cmV0dXJuIHIua2VwdD0hMSxDYShyLnNoYXBlLHQsXCJUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiBcIiksVyhyLGEpfXB1c2hCYWNrKHQpe2lmKHQuZHR5cGUhPT10aGlzLmVsZW1lbnREdHlwZSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHt0LmR0eXBlfSwgYnV0IGxpc3QgZWxlbWVudHMgJHt0aGlzLmVsZW1lbnREdHlwZX1gKTtpZihDYSh0LnNoYXBlLHRoaXMuZWxlbWVudFNoYXBlLFwiVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogXCIpLHRoaXMubWF4TnVtRWxlbWVudHM9PT10aGlzLnNpemUoKSl0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gcHVzaCBlbGVtZW50IGludG8gYSBmdWxsIGxpc3QuXCIpO0h0KHQpLHRoaXMudGVuc29ycy5wdXNoKHQpfXJlc2l6ZSh0KXtpZih0PDApdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JMaXN0UmVzaXplIGV4cGVjdHMgc2l6ZSB0byBiZSBub24tbmVnYXRpdmUuIEdvdDogJHt0fWApO2lmKHRoaXMubWF4TnVtRWxlbWVudHMhPT0tMSYmdD50aGlzLm1heE51bUVsZW1lbnRzKXRocm93IG5ldyBFcnJvcihgVGVuc29yTGlzdFJlc2l6ZSBpbnB1dCBzaXplICR7dH0gaXMgZ3JlYXRlciBtYXhOdW1FbGVtZW50ICR7dGhpcy5tYXhOdW1FbGVtZW50c30uYCk7bGV0IG49bmV3IGl2KFtdLHRoaXMuZWxlbWVudFNoYXBlLHRoaXMuZWxlbWVudER0eXBlLHRoaXMubWF4TnVtRWxlbWVudHMpO24udGVuc29ycy5sZW5ndGg9dDtmb3IobGV0IGE9MDthPE1hdGgubWluKHRoaXMudGVuc29ycy5sZW5ndGgsdCk7KythKW4udGVuc29yc1thXT10aGlzLnRlbnNvcnNbYV07cmV0dXJuIG59Z2V0SXRlbSh0LG4sYSl7aWYoYSE9PXRoaXMuZWxlbWVudER0eXBlKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIHR5cGVzOyBvcCBlbGVtZW50cyAke2F9LCBidXQgbGlzdCBlbGVtZW50cyAke3RoaXMuZWxlbWVudER0eXBlfWApO2lmKHQ8MHx8dD50aGlzLnRlbnNvcnMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIGFjY2VzcyBlbGVtZW50ICR7dH0gaW4gYSBsaXN0IHdpdGggJHt0aGlzLnRlbnNvcnMubGVuZ3RofSBlbGVtZW50cy5gKTtpZih0aGlzLnRlbnNvcnNbdF09PW51bGwpdGhyb3cgbmV3IEVycm9yKGBlbGVtZW50IGF0IGluZGV4ICR7dH0gaXMgbnVsbC5gKTtDYSh0aGlzLnRlbnNvcnNbdF0uc2hhcGUsbixcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKTtsZXQgcj1acCh0aGlzLmVsZW1lbnRTaGFwZSx0aGlzLnRlbnNvcnMsbik7cmV0dXJuIFcodGhpcy50ZW5zb3JzW3RdLHIpfXNldEl0ZW0odCxuKXtpZihuLmR0eXBlIT09dGhpcy5lbGVtZW50RHR5cGUpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7bi5kdHlwZX0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7dGhpcy5lbGVtZW50RHR5cGV9YCk7aWYodDwwfHx0aGlzLm1heE51bUVsZW1lbnRzIT09LTEmJnQ+PXRoaXMubWF4TnVtRWxlbWVudHMpdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gc2V0IGVsZW1lbnQgJHt0fSBpbiBhIGxpc3Qgd2l0aCBtYXggJHt0aGlzLm1heE51bUVsZW1lbnRzfSBlbGVtZW50cy5gKTtDYSh0aGlzLmVsZW1lbnRTaGFwZSxuLnNoYXBlLFwiVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogXCIpLEh0KG4pLHRoaXMudGVuc29yc1t0XSE9bnVsbCYmKHRoaXMudGVuc29yc1t0XS5rZXB0PSExKSx0aGlzLnRlbnNvcnNbdF09bn1nYXRoZXIodCxuLGEpe2lmKG4hPT10aGlzLmVsZW1lbnREdHlwZSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHtufSwgYnV0IGxpc3QgZWxlbWVudHMgJHt0aGlzLmVsZW1lbnREdHlwZX1gKTtDYSh0aGlzLmVsZW1lbnRTaGFwZSxhLFwiVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogXCIpLHQ9dC5zbGljZSgwLHRoaXMuc2l6ZSgpKTtsZXQgcj1acCh0aGlzLmVsZW1lbnRTaGFwZSx0aGlzLnRlbnNvcnMsYSk7cmV0dXJuIHQubGVuZ3RoPT09MD9ibihbXSxbMF0uY29uY2F0KHIpKTpPKCgpPT57bGV0IHM9dC5tYXAoaT0+Vyh0aGlzLnRlbnNvcnNbaV0scikpO3JldHVybiBBdChzLDApfSl9Y29uY2F0KHQsbil7aWYodCYmdCE9PXRoaXMuZWxlbWVudER0eXBlKXRocm93IG5ldyBFcnJvcihgVGVuc29yTGlzdCBkdHlwZSBpcyAke3RoaXMuZWxlbWVudER0eXBlfSBidXQgY29uY2F0IHJlcXVlc3RlZCBkdHlwZSAke3R9YCk7Q2EodGhpcy5lbGVtZW50U2hhcGUsbixcIlRlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6IFwiKTtsZXQgYT1acCh0aGlzLmVsZW1lbnRTaGFwZSx0aGlzLnRlbnNvcnMsbik7cmV0dXJuIHRoaXMuc2l6ZSgpPT09MD9ibihbXSxbMF0uY29uY2F0KGEpKTpPKCgpPT57bGV0IHI9dGhpcy50ZW5zb3JzLm1hcChzPT5XKHMsYSkpO3JldHVybiBldChyLDApfSl9fTtmdW5jdGlvbiBXcShlLHQsbil7bGV0IGE9ZS5kdHlwZTtpZihlLnNoYXBlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihgVGVuc29yIG11c3QgYmUgYXQgbGVhc3QgYSB2ZWN0b3IsIGJ1dCBzYXcgc2hhcGU6ICR7ZS5zaGFwZX1gKTtpZihlLmR0eXBlIT09bil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHtlLmR0eXBlfSwgYnV0IGxpc3QgZWxlbWVudHMgJHtufWApO2xldCByPWUuc2hhcGUuc2xpY2UoMSk7Q2Eocix0LFwiVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogXCIpO2xldCBzPWR0KGUpO3JldHVybiBuZXcgTGYocyx0LGEpfWZ1bmN0aW9uIEJxKGUsdCxuLGEpe3JldHVybiBuZXcgTGYoW10sZSx0LGEpfWZ1bmN0aW9uIFZxKGUsdCxuLGEpe2lmKHQubGVuZ3RoIT09ZS5zaGFwZVswXSl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGxlbihpbmRpY2VzKSA9PSB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzYXc6ICR7dC5sZW5ndGh9IHZzLiAke2Uuc2hhcGVbMF19YCk7bGV0IHI9TWF0aC5tYXgoLi4udCk7aWYoYSE9bnVsbCYmYSE9PS0xJiZyPj1hKXRocm93IG5ldyBFcnJvcihgTWF4IGluZGV4IG11c3QgYmUgPCBhcnJheSBzaXplICgke3J9ICB2cy4gJHthfSlgKTtsZXQgcz1uZXcgTGYoW10sbixlLmR0eXBlLGEpLGk9ZHQoZSwwKTtyZXR1cm4gdC5mb3JFYWNoKChvLGwpPT57cy5zZXRJdGVtKG8saVtsXSl9KSxzfWZ1bmN0aW9uIFVxKGUsdCxuKXtsZXQgYT0wLHI9dC5tYXAocD0+KGErPXAsYSkpO2lmKGEhPT1lLnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3VtIG9mIGxlbmd0aHMgdG8gYmUgZXF1YWwgdG9cbiAgICAgICAgICB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzdW0gb2YgbGVuZ3RocyBpc1xuICAgICAgICAke2F9LCBhbmQgdGVuc29yJ3Mgc2hhcGUgaXM6ICR7ZS5zaGFwZX1gKTtsZXQgcz1lLnNoYXBlLnNsaWNlKDEpLGk9c3YocyxuKSxvPWE9PT0wPzA6ZS5zaXplL2EsbD1PKCgpPT57bGV0IHA9W107ZT1XKGUsWzEsYSxvXSk7Zm9yKGxldCBkPTA7ZDx0Lmxlbmd0aDsrK2Qpe2xldCBjPVswLGQ9PT0wPzA6cltkLTFdLDBdLGg9WzEsdFtkXSxvXTtwW2RdPVcoVmUoZSxjLGgpLGkpfXJldHVybiBlLmRpc3Bvc2UoKSxwfSksdT1uZXcgTGYoW10sbixlLmR0eXBlLHQubGVuZ3RoKTtmb3IobGV0IHA9MDtwPGwubGVuZ3RoO3ArKyl1LnNldEl0ZW0ocCxsW3BdKTtyZXR1cm4gdX12YXIgR3E9YXN5bmMoZSx0LG4pPT57c3dpdGNoKGUub3Ape2Nhc2VcIklmXCI6Y2FzZVwiU3RhdGVsZXNzSWZcIjp7bGV0IGE9ayhcInRoZW5CcmFuY2hcIixlLHQsbikscj1rKFwiZWxzZUJyYW5jaFwiLGUsdCxuKSxzPWsoXCJjb25kXCIsZSx0LG4pLGk9ayhcImFyZ3NcIixlLHQsbik7cmV0dXJuKGF3YWl0IHMuZGF0YSgpKVswXT9uLmZ1bmN0aW9uTWFwW2FdLmV4ZWN1dGVGdW5jdGlvbkFzeW5jKGksbi50ZW5zb3JBcnJheU1hcCxuLnRlbnNvckxpc3RNYXApOm4uZnVuY3Rpb25NYXBbcl0uZXhlY3V0ZUZ1bmN0aW9uQXN5bmMoaSxuLnRlbnNvckFycmF5TWFwLG4udGVuc29yTGlzdE1hcCl9Y2FzZVwiV2hpbGVcIjpjYXNlXCJTdGF0ZWxlc3NXaGlsZVwiOntsZXQgYT1rKFwiYm9keVwiLGUsdCxuKSxyPWsoXCJjb25kXCIsZSx0LG4pLHM9ayhcImFyZ3NcIixlLHQsbiksaT1hd2FpdCBuLmZ1bmN0aW9uTWFwW3JdLmV4ZWN1dGVGdW5jdGlvbkFzeW5jKHMsbi50ZW5zb3JBcnJheU1hcCxuLnRlbnNvckxpc3RNYXApLG89cy5tYXAocD0+cC5pZCksbD1hd2FpdCBpWzBdLmRhdGEoKTtpLmZvckVhY2gocD0+eyFwLmtlcHQmJm8uaW5kZXhPZihwLmlkKT09PS0xJiZwLmRpc3Bvc2UoKX0pO2xldCB1PXM7Zm9yKDtsWzBdOyl7bGV0IHA9dTt1PWF3YWl0IG4uZnVuY3Rpb25NYXBbYV0uZXhlY3V0ZUZ1bmN0aW9uQXN5bmModSxuLnRlbnNvckFycmF5TWFwLG4udGVuc29yTGlzdE1hcCk7bGV0IGQ9dS5tYXAoaD0+aC5pZCk7cC5mb3JFYWNoKGg9PnshaC5rZXB0JiZvLmluZGV4T2YoaC5pZCk9PT0tMSYmZC5pbmRleE9mKGguaWQpPT09LTEmJmguZGlzcG9zZSgpfSk7bGV0IGM9YXdhaXQgbi5mdW5jdGlvbk1hcFtyXS5leGVjdXRlRnVuY3Rpb25Bc3luYyh1LG4udGVuc29yQXJyYXlNYXAsbi50ZW5zb3JMaXN0TWFwKTtsPWF3YWl0IGNbMF0uZGF0YSgpLGMuZm9yRWFjaChoPT57IWgua2VwdCYmby5pbmRleE9mKGguaWQpPT09LTEmJmQuaW5kZXhPZihoLmlkKT09PS0xJiZoLmRpc3Bvc2UoKX0pfXJldHVybiB1fWNhc2VcIkxvb3BDb25kXCI6e2xldCBhPWsoXCJwcmVkXCIsZSx0LG4pO3JldHVybltOcihhKV19Y2FzZVwiU3dpdGNoXCI6e2xldCBhPWsoXCJwcmVkXCIsZSx0LG4pLHI9ayhcImRhdGFcIixlLHQsbik7cmV0dXJuIHIua2VwdHx8KHI9TnIocikpLChhd2FpdCBhLmRhdGEoKSlbMF0/W3ZvaWQgMCxyXTpbcix2b2lkIDBdfWNhc2VcIk1lcmdlXCI6e2xldCBhPWUuaW5wdXROYW1lcy5maW5kKHI9PnBuKHIsdCxuKSE9PXZvaWQgMCk7aWYoYSl7bGV0IHI9cG4oYSx0LG4pO3JldHVybltOcihyKV19cmV0dXJufWNhc2VcIkVudGVyXCI6e2xldCBhPWsoXCJmcmFtZU5hbWVcIixlLHQsbikscj1rKFwidGVuc29yXCIsZSx0LG4pO3JldHVybiBuLmVudGVyRnJhbWUoYSksW05yKHIpXX1jYXNlXCJFeGl0XCI6e2xldCBhPWsoXCJ0ZW5zb3JcIixlLHQsbik7cmV0dXJuIG4uZXhpdEZyYW1lKCksW05yKGEpXX1jYXNlXCJOZXh0SXRlcmF0aW9uXCI6e2xldCBhPWsoXCJ0ZW5zb3JcIixlLHQsbik7cmV0dXJuIG4ubmV4dEl0ZXJhdGlvbigpLFtOcihhKV19Y2FzZVwiVGVuc29yQXJyYXlWM1wiOntsZXQgYT1rKFwic2l6ZVwiLGUsdCxuKSxyPWsoXCJkdHlwZVwiLGUsdCxuKSxzPWsoXCJlbGVtZW50U2hhcGVcIixlLHQsbiksaT1rKFwiZHluYW1pY1NpemVcIixlLHQsbiksbz1rKFwiY2xlYXJBZnRlclJlYWRcIixlLHQsbiksbD1rKFwiaWRlbnRpY2FsRWxlbWVudFNoYXBlc1wiLGUsdCxuKSx1PWsoXCJuYW1lXCIsZSx0LG4pLHA9bmV3IHpxKHUscixhLHMsbCxpLG8pO3JldHVybiBuLmFkZFRlbnNvckFycmF5KHApLFtwLmlkVGVuc29yLHhlKDEpXX1jYXNlXCJUZW5zb3JBcnJheVdyaXRlVjNcIjp7bGV0IGE9ayhcInRlbnNvckFycmF5SWRcIixlLHQsbikscj1rKFwiaW5kZXhcIixlLHQsbikscz1rKFwidGVuc29yXCIsZSx0LG4pLGk9bi5nZXRUZW5zb3JBcnJheShhLmlkKTtyZXR1cm4gaS53cml0ZShyLHMpLFtpLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JBcnJheVJlYWRWM1wiOntsZXQgYT1rKFwidGVuc29yQXJyYXlJZFwiLGUsdCxuKSxyPWsoXCJpbmRleFwiLGUsdCxuKTtyZXR1cm5bbi5nZXRUZW5zb3JBcnJheShhLmlkKS5yZWFkKHIpXX1jYXNlXCJUZW5zb3JBcnJheUdhdGhlclYzXCI6e2xldCBhPWsoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LG4pLHI9ayhcImluZGljZXNcIixlLHQsbikscz1rKFwiZHR5cGVcIixlLHQsbik7cmV0dXJuW24uZ2V0VGVuc29yQXJyYXkoYS5pZCkuZ2F0aGVyKHIscyldfWNhc2VcIlRlbnNvckFycmF5U2NhdHRlclYzXCI6e2xldCBhPWsoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LG4pLHI9ayhcImluZGljZXNcIixlLHQsbikscz1rKFwidGVuc29yXCIsZSx0LG4pLGk9bi5nZXRUZW5zb3JBcnJheShhLmlkKTtyZXR1cm4gaS5zY2F0dGVyKHIscyksW2kuaWRUZW5zb3JdfWNhc2VcIlRlbnNvckFycmF5Q29uY2F0VjNcIjp7bGV0IGE9ayhcInRlbnNvckFycmF5SWRcIixlLHQsbikscj1uLmdldFRlbnNvckFycmF5KGEuaWQpLHM9ayhcImR0eXBlXCIsZSx0LG4pO3JldHVybltyLmNvbmNhdChzKV19Y2FzZVwiVGVuc29yQXJyYXlTcGxpdFYzXCI6e2xldCBhPWsoXCJ0ZW5zb3JBcnJheUlkXCIsZSx0LG4pLHI9ayhcInRlbnNvclwiLGUsdCxuKSxzPWsoXCJsZW5ndGhzXCIsZSx0LG4pLGk9bi5nZXRUZW5zb3JBcnJheShhLmlkKTtyZXR1cm4gaS5zcGxpdChzLHIpLFtpLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JBcnJheVNpemVWM1wiOntsZXQgYT1rKFwidGVuc29yQXJyYXlJZFwiLGUsdCxuKSxyPW4uZ2V0VGVuc29yQXJyYXkoYS5pZCk7cmV0dXJuW3hlKHIuc2l6ZSgpLFwiaW50MzJcIildfWNhc2VcIlRlbnNvckFycmF5Q2xvc2VWM1wiOntsZXQgYT1rKFwidGVuc29yQXJyYXlJZFwiLGUsdCxuKSxyPW4uZ2V0VGVuc29yQXJyYXkoYS5pZCk7cmV0dXJuIHIuY2xlYXJBbmRDbG9zZSgpLFtyLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JMaXN0U2V0SXRlbVwiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9ayhcImluZGV4XCIsZSx0LG4pLHM9ayhcInRlbnNvclwiLGUsdCxuKSxpPW4uZ2V0VGVuc29yTGlzdChhLmlkKTtyZXR1cm4gaS5zZXRJdGVtKHIscyksW2kuaWRUZW5zb3JdfWNhc2VcIlRlbnNvckxpc3RHZXRJdGVtXCI6e2xldCBhPWsoXCJ0ZW5zb3JMaXN0SWRcIixlLHQsbikscj1rKFwiaW5kZXhcIixlLHQsbikscz1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pLGk9ayhcImVsZW1lbnREVHlwZVwiLGUsdCxuKTtyZXR1cm5bbi5nZXRUZW5zb3JMaXN0KGEuaWQpLmdldEl0ZW0ocixzLGkpXX1jYXNlXCJUZW5zb3JMaXN0U2NhdHRlclYyXCI6Y2FzZVwiVGVuc29yTGlzdFNjYXR0ZXJcIjp7bGV0IGE9ayhcImluZGljZXNcIixlLHQsbikscj1rKFwidGVuc29yXCIsZSx0LG4pLHM9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKSxpPWsoXCJudW1FbGVtZW50c1wiLGUsdCxuKSxvPVZxKHIsYSxzLGkpO3JldHVybiBuLmFkZFRlbnNvckxpc3QobyksW28uaWRUZW5zb3JdfWNhc2VcIlRlbnNvckxpc3RSZXNlcnZlXCI6Y2FzZVwiRW1wdHlUZW5zb3JMaXN0XCI6e2xldCBhPWsoXCJlbGVtZW50U2hhcGVcIixlLHQsbikscj1rKFwiZWxlbWVudERUeXBlXCIsZSx0LG4pLHM7ZS5vcD09PVwiVGVuc29yTGlzdFJlc2VydmVcIj9zPVwibnVtRWxlbWVudHNcIjpzPVwibWF4TnVtRWxlbWVudHNcIjtsZXQgaT1rKHMsZSx0LG4pLG89ZS5vcD09PVwiVGVuc29yTGlzdFJlc2VydmVcIj8tMTppLGw9QnEoYSxyLGksbyk7cmV0dXJuIG4uYWRkVGVuc29yTGlzdChsKSxbbC5pZFRlbnNvcl19Y2FzZVwiVGVuc29yTGlzdEdhdGhlclwiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9ayhcImluZGljZXNcIixlLHQsbikscz1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pLGk9ayhcImVsZW1lbnREVHlwZVwiLGUsdCxuKTtyZXR1cm5bbi5nZXRUZW5zb3JMaXN0KGEuaWQpLmdhdGhlcihyLGkscyldfWNhc2VcIlRlbnNvckxpc3RTdGFja1wiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9ayhcImVsZW1lbnRTaGFwZVwiLGUsdCxuKSxzPWsoXCJlbGVtZW50RFR5cGVcIixlLHQsbiksaT1rKFwibnVtRWxlbWVudHNcIixlLHQsbik7cmV0dXJuW24uZ2V0VGVuc29yTGlzdChhLmlkKS5zdGFjayhyLHMsaSldfWNhc2VcIlRlbnNvckxpc3RGcm9tVGVuc29yXCI6e2xldCBhPWsoXCJ0ZW5zb3JcIixlLHQsbikscj1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pLHM9ayhcImVsZW1lbnREVHlwZVwiLGUsdCxuKSxpPVdxKGEscixzKTtyZXR1cm4gbi5hZGRUZW5zb3JMaXN0KGkpLFtpLmlkVGVuc29yXX1jYXNlXCJUZW5zb3JMaXN0Q29uY2F0XCI6Y2FzZVwiVGVuc29yTGlzdENvbmNhdFYyXCI6e2xldCBhPWsoXCJ0ZW5zb3JMaXN0SWRcIixlLHQsbikscj1uLmdldFRlbnNvckxpc3QoYS5pZCkscz1rKFwiZHR5cGVcIixlLHQsbiksaT1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pO3JldHVybltyLmNvbmNhdChzLGkpXX1jYXNlXCJUZW5zb3JMaXN0UHVzaEJhY2tcIjp7bGV0IGE9ayhcInRlbnNvckxpc3RJZFwiLGUsdCxuKSxyPWsoXCJ0ZW5zb3JcIixlLHQsbikscz1uLmdldFRlbnNvckxpc3QoYS5pZCk7cmV0dXJuIHMucHVzaEJhY2sociksW3MuaWRUZW5zb3JdfWNhc2VcIlRlbnNvckxpc3RQb3BCYWNrXCI6e2xldCBhPWsoXCJ0ZW5zb3JMaXN0SWRcIixlLHQsbikscj1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pLHM9ayhcImVsZW1lbnREVHlwZVwiLGUsdCxuKTtyZXR1cm5bbi5nZXRUZW5zb3JMaXN0KGEuaWQpLnBvcEJhY2socixzKV19Y2FzZVwiVGVuc29yTGlzdFNwbGl0XCI6e2xldCBhPWsoXCJ0ZW5zb3JcIixlLHQsbikscj1rKFwiZWxlbWVudFNoYXBlXCIsZSx0LG4pLHM9ayhcImxlbmd0aHNcIixlLHQsbiksaT1VcShhLHMscik7cmV0dXJuIG4uYWRkVGVuc29yTGlzdChpKSxbaS5pZFRlbnNvcl19Y2FzZVwiVGVuc29yTGlzdExlbmd0aFwiOntsZXQgYT1rKFwidGVuc29yTGlzdElkXCIsZSx0LG4pLHI9bi5nZXRUZW5zb3JMaXN0KGEuaWQpO3JldHVyblt4ZShyLnNpemUoKSxcImludDMyXCIpXX1jYXNlXCJUZW5zb3JMaXN0UmVzaXplXCI6e2xldCBhPWsoXCJ0ZW5zb3JMaXN0SWRcIixlLHQsbikscj1rKFwic2l6ZVwiLGUsdCxuKSxzPW4uZ2V0VGVuc29yTGlzdChhLmlkKS5yZXNpemUocik7cmV0dXJuIG4uYWRkVGVuc29yTGlzdChzKSxbcy5pZFRlbnNvcl19ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX07ZnVuY3Rpb24gVkkoZSx0LG4pe2xldFthLHJdPWsoXCJmdXNlZE9wc1wiLGUsdCxuKSxzPWE9PT1cImJpYXNhZGRcIixpPSFzLG89cj09PVwicHJlbHVcIixsPWE9PT1cImZ1c2VkYmF0Y2hub3JtXCIsdT1rKFwibnVtQXJnc1wiLGUsdCxuKTtpZihzKXtpZihvJiZ1IT09Mil0aHJvdyBuZXcgRXJyb3IoXCJGdXNlZENvbnYyZCBhbmQgRGVwdGh3aXNlQ29udjJkIHdpdGggQmlhc0FkZCBhbmQgUHJlbHUgbXVzdCBoYXZlIHR3byBleHRyYSBhcmd1bWVudHM6IGJpYXMgYW5kIGFscGhhLlwiKTtpZighbyYmcyYmdSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRnVzZWRDb252MmQgYW5kIERlcHRod2lzZUNvbnYyZCB3aXRoIEJpYXNBZGQgbXVzdCBoYXZlIG9uZSBleHRyYSBhcmd1bWVudDogYmlhcy5cIil9aWYobCl0aHJvdyBuZXcgRXJyb3IoXCJGdXNlZENvbnYyZCBhbmQgRGVwdGh3aXNlQ29udjJkIHdpdGggRnVzZWRCYXRjaE5vcm0gaXMgbm90IHN1cHBvcnRlZFwiKTtsZXQgcD1rKFwic3RyaWRlc1wiLGUsdCxuKSxkPU1oKGUsdCxuKSxjPWsoXCJkYXRhRm9ybWF0XCIsZSx0LG4pLnRvVXBwZXJDYXNlKCksaD1rKFwiZGlsYXRpb25zXCIsZSx0LG4pLFttLGZdPWsoXCJhcmdzXCIsZSx0LG4pO2kmJihmPW0sbT12b2lkIDApO2xldCBnPWsoXCJsZWFreXJlbHVBbHBoYVwiLGUsdCxuKTtyZXR1cm57c3RyaWRlOnAscGFkOmQsZGF0YUZvcm1hdDpjLGRpbGF0aW9uczpoLGJpYXNBcmc6bSxwcmVsdUFyZzpmLGFjdGl2YXRpb25GdW5jOnIsbGVha3lyZWx1QWxwaGE6Z319dmFyIEhxPShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJDb252MURcIjp7bGV0IHI9ayhcInN0cmlkZVwiLGUsdCxuKSxzPWsoXCJwYWRcIixlLHQsbiksaT1rKFwiZGF0YUZvcm1hdFwiLGUsdCxuKS50b1VwcGVyQ2FzZSgpLG89ayhcImRpbGF0aW9uXCIsZSx0LG4pO3JldHVyblthLmNvbnYxZChrKFwieFwiLGUsdCxuKSxrKFwiZmlsdGVyXCIsZSx0LG4pLHIscyxpLG8pXX1jYXNlXCJDb252MkRcIjp7bGV0IHI9ayhcInN0cmlkZXNcIixlLHQsbikscz1NaChlLHQsbiksaT1rKFwiZGF0YUZvcm1hdFwiLGUsdCxuKS50b1VwcGVyQ2FzZSgpLG89ayhcImRpbGF0aW9uc1wiLGUsdCxuKTtyZXR1cm5bYS5jb252MmQoayhcInhcIixlLHQsbiksayhcImZpbHRlclwiLGUsdCxuKSxbclsxXSxyWzJdXSxzLGksW29bMV0sb1syXV0pXX1jYXNlXCJfRnVzZWRDb252MkRcIjp7bGV0e3N0cmlkZTpyLHBhZDpzLGRhdGFGb3JtYXQ6aSxkaWxhdGlvbnM6byxiaWFzQXJnOmwscHJlbHVBcmc6dSxhY3RpdmF0aW9uRnVuYzpwLGxlYWt5cmVsdUFscGhhOmR9PVZJKGUsdCxuKTtyZXR1cm5bYS5mdXNlZC5jb252MmQoe3g6ayhcInhcIixlLHQsbiksZmlsdGVyOmsoXCJmaWx0ZXJcIixlLHQsbiksc3RyaWRlczpbclsxXSxyWzJdXSxwYWQ6cyxkYXRhRm9ybWF0OmksZGlsYXRpb25zOltvWzFdLG9bMl1dLGJpYXM6bCxhY3RpdmF0aW9uOnAscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czp1LGxlYWt5cmVsdUFscGhhOmR9KV19Y2FzZVwiRnVzZWREZXB0aHdpc2VDb252MmROYXRpdmVcIjp7bGV0e3N0cmlkZTpyLHBhZDpzLGRhdGFGb3JtYXQ6aSxkaWxhdGlvbnM6byxiaWFzQXJnOmwscHJlbHVBcmc6dSxhY3RpdmF0aW9uRnVuYzpwLGxlYWt5cmVsdUFscGhhOmR9PVZJKGUsdCxuKTtyZXR1cm5bYS5mdXNlZC5kZXB0aHdpc2VDb252MmQoe3g6ayhcInhcIixlLHQsbiksZmlsdGVyOmsoXCJmaWx0ZXJcIixlLHQsbiksc3RyaWRlczpbclsxXSxyWzJdXSxwYWQ6cyxkYXRhRm9ybWF0OmksZGlsYXRpb25zOltvWzFdLG9bMl1dLGJpYXM6bCxhY3RpdmF0aW9uOnAscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czp1LGxlYWt5cmVsdUFscGhhOmR9KV19Y2FzZVwiQ29udjJEQmFja3Byb3BJbnB1dFwiOmNhc2VcIkNvbnYyZFRyYW5zcG9zZVwiOntsZXQgcj1rKFwib3V0cHV0U2hhcGVcIixlLHQsbikscz1rKFwic3RyaWRlc1wiLGUsdCxuKSxpPU1oKGUsdCxuKTtyZXR1cm5bYS5jb252MmRUcmFuc3Bvc2UoayhcInhcIixlLHQsbiksayhcImZpbHRlclwiLGUsdCxuKSxyLFtzWzFdLHNbMl1dLGkpXX1jYXNlXCJEZXB0aHdpc2VDb252MmROYXRpdmVcIjpjYXNlXCJEZXB0aHdpc2VDb252MmRcIjp7bGV0IHI9ayhcInN0cmlkZXNcIixlLHQsbikscz1NaChlLHQsbiksaT1rKFwiZGlsYXRpb25zXCIsZSx0LG4pLG89ayhcImRhdGFGb3JtYXRcIixlLHQsbikudG9VcHBlckNhc2UoKTtyZXR1cm5bYS5kZXB0aHdpc2VDb252MmQoayhcImlucHV0XCIsZSx0LG4pLGsoXCJmaWx0ZXJcIixlLHQsbiksW3JbMV0sclsyXV0scyxvLFtpWzFdLGlbMl1dKV19Y2FzZVwiQ29udjNEXCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9ayhcInBhZFwiLGUsdCxuKSxpPWsoXCJkYXRhRm9ybWF0XCIsZSx0LG4pLnRvVXBwZXJDYXNlKCksbz1rKFwiZGlsYXRpb25zXCIsZSx0LG4pO3JldHVyblthLmNvbnYzZChrKFwieFwiLGUsdCxuKSxrKFwiZmlsdGVyXCIsZSx0LG4pLFtyWzFdLHJbMl0sclszXV0scyxpLFtvWzFdLG9bMl0sb1szXV0pXX1jYXNlXCJBdmdQb29sXCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9ayhcInBhZFwiLGUsdCxuKSxpPWsoXCJrZXJuZWxTaXplXCIsZSx0LG4pO3JldHVyblthLmF2Z1Bvb2woayhcInhcIixlLHQsbiksW2lbMV0saVsyXV0sW3JbMV0sclsyXV0scyldfWNhc2VcIk1heFBvb2xcIjp7bGV0IHI9ayhcInN0cmlkZXNcIixlLHQsbikscz1rKFwicGFkXCIsZSx0LG4pLGk9ayhcImtlcm5lbFNpemVcIixlLHQsbik7cmV0dXJuW2EubWF4UG9vbChrKFwieFwiLGUsdCxuKSxbaVsxXSxpWzJdXSxbclsxXSxyWzJdXSxzKV19Y2FzZVwiTWF4UG9vbFdpdGhBcmdtYXhcIjp7bGV0IHI9ayhcInN0cmlkZXNcIixlLHQsbikscz1rKFwicGFkXCIsZSx0LG4pLGk9ayhcImtlcm5lbFNpemVcIixlLHQsbiksbz1rKFwiaW5jbHVkZUJhdGNoSW5JbmRleFwiLGUsdCxuKSx7cmVzdWx0OmwsaW5kZXhlczp1fT1hLm1heFBvb2xXaXRoQXJnbWF4KGsoXCJ4XCIsZSx0LG4pLFtpWzFdLGlbMl1dLFtyWzFdLHJbMl1dLHMsbyk7cmV0dXJuW2wsdV19Y2FzZVwiQXZnUG9vbDNEXCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9ayhcInBhZFwiLGUsdCxuKSxpPWsoXCJrZXJuZWxTaXplXCIsZSx0LG4pO3JldHVyblthLmF2Z1Bvb2wzZChrKFwieFwiLGUsdCxuKSxbaVsxXSxpWzJdLGlbM11dLFtyWzFdLHJbMl0sclszXV0scyldfWNhc2VcIk1heFBvb2wzRFwiOntsZXQgcj1rKFwic3RyaWRlc1wiLGUsdCxuKSxzPWsoXCJwYWRcIixlLHQsbiksaT1rKFwia2VybmVsU2l6ZVwiLGUsdCxuKTtyZXR1cm5bYS5tYXhQb29sM2QoayhcInhcIixlLHQsbiksW2lbMV0saVsyXSxpWzNdXSxbclsxXSxyWzJdLHJbM11dLHMpXX1jYXNlXCJEaWxhdGlvbjJEXCI6e2xldCByPWsoXCJzdHJpZGVzXCIsZSx0LG4pLHM9ayhcInBhZFwiLGUsdCxuKSxpPWsoXCJkaWxhdGlvbnNcIixlLHQsbiksbz1yWzFdLGw9clsyXSx1PWlbMV0scD1pWzJdO3JldHVyblthLmRpbGF0aW9uMmQoayhcInhcIixlLHQsbiksayhcImZpbHRlclwiLGUsdCxuKSxbbyxsXSxzLFt1LHBdLFwiTkhXQ1wiKV19ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sanE9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkZpbGxcIjp7bGV0IHI9ayhcInNoYXBlXCIsZSx0LG4pLHM9ayhcImR0eXBlXCIsZSx0LG4pLGk9ayhcInZhbHVlXCIsZSx0LG4pO3JldHVyblthLmZpbGwocixpLHMpXX1jYXNlXCJMaW5TcGFjZVwiOntsZXQgcj1rKFwic3RhcnRcIixlLHQsbikscz1rKFwic3RvcFwiLGUsdCxuKSxpPWsoXCJudW1cIixlLHQsbik7cmV0dXJuW2EubGluc3BhY2UocixzLGkpXX1jYXNlXCJNdWx0aW5vbWlhbFwiOntsZXQgcj1rKFwibG9naXRzXCIsZSx0LG4pLHM9ayhcIm51bVNhbXBsZXNcIixlLHQsbiksaT1rKFwic2VlZFwiLGUsdCxuKTtyZXR1cm5bYS5tdWx0aW5vbWlhbChyLHMsaSldfWNhc2VcIk9uZUhvdFwiOntsZXQgcj1rKFwiaW5kaWNlc1wiLGUsdCxuKSxzPWsoXCJkZXB0aFwiLGUsdCxuKSxpPWsoXCJvblZhbHVlXCIsZSx0LG4pLG89ayhcIm9mZlZhbHVlXCIsZSx0LG4pLGw9ayhcImR0eXBlXCIsZSx0LG4pO3JldHVyblthLm9uZUhvdChyLHMsaSxvLGwpXX1jYXNlXCJPbmVzXCI6cmV0dXJuW2Eub25lcyhrKFwic2hhcGVcIixlLHQsbiksayhcImR0eXBlXCIsZSx0LG4pKV07Y2FzZVwiT25lc0xpa2VcIjpyZXR1cm5bYS5vbmVzTGlrZShrKFwieFwiLGUsdCxuKSldO2Nhc2VcIlJhbmRvbVN0YW5kYXJkTm9ybWFsXCI6cmV0dXJuW2EucmFuZG9tU3RhbmRhcmROb3JtYWwoayhcInNoYXBlXCIsZSx0LG4pLGsoXCJkdHlwZVwiLGUsdCxuKSxrKFwic2VlZFwiLGUsdCxuKSldO2Nhc2VcIlJhbmRvbVVuaWZvcm1cIjpyZXR1cm5bYS5yYW5kb21Vbmlmb3JtKGsoXCJzaGFwZVwiLGUsdCxuKSxrKFwibWludmFsXCIsZSx0LG4pLGsoXCJtYXh2YWxcIixlLHQsbiksayhcImR0eXBlXCIsZSx0LG4pKV07Y2FzZVwiUmFuZG9tVW5pZm9ybUludFwiOnJldHVyblthLnJhbmRvbVVuaWZvcm1JbnQoayhcInNoYXBlXCIsZSx0LG4pLGsoXCJtaW52YWxcIixlLHQsbiksayhcIm1heHZhbFwiLGUsdCxuKSxrKFwic2VlZFwiLGUsdCxuKSldO2Nhc2VcIlJhbmdlXCI6e2xldCByPWsoXCJzdGFydFwiLGUsdCxuKSxzPWsoXCJzdG9wXCIsZSx0LG4pLGk9ayhcInN0ZXBcIixlLHQsbik7cmV0dXJuW2EucmFuZ2UocixzLGksayhcImR0eXBlXCIsZSx0LG4pKV19Y2FzZVwiVHJ1bmNhdGVkTm9ybWFsXCI6e2xldCByPWsoXCJzaGFwZVwiLGUsdCxuKSxzPWsoXCJtZWFuXCIsZSx0LG4pLGk9ayhcInN0ZERldlwiLGUsdCxuKSxvPWsoXCJzZWVkXCIsZSx0LG4pO3JldHVyblthLnRydW5jYXRlZE5vcm1hbChyLHMsaSxrKFwiZHR5cGVcIixlLHQsbiksbyldfWNhc2VcIlplcm9zXCI6cmV0dXJuW2EuemVyb3MoayhcInNoYXBlXCIsZSx0LG4pLGsoXCJkdHlwZVwiLGUsdCxuKSldO2Nhc2VcIlplcm9zTGlrZVwiOnJldHVyblthLnplcm9zTGlrZShrKFwieFwiLGUsdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19O2Z1bmN0aW9uIGd4KGUsdCxuKXtsZXQgYT1rKFwiYm94ZXNcIixlLHQsbikscj1rKFwic2NvcmVzXCIsZSx0LG4pLHM9ayhcIm1heE91dHB1dFNpemVcIixlLHQsbiksaT1rKFwiaW91VGhyZXNob2xkXCIsZSx0LG4pLG89ayhcInNjb3JlVGhyZXNob2xkXCIsZSx0LG4pLGw9ayhcInNvZnRObXNTaWdtYVwiLGUsdCxuKTtyZXR1cm57Ym94ZXM6YSxzY29yZXM6cixtYXhPdXRwdXRTaXplOnMsaW91VGhyZXNob2xkOmksc2NvcmVUaHJlc2hvbGQ6byxzb2Z0Tm1zU2lnbWE6bH19dmFyIHFxPWFzeW5jKGUsdCxuLGEscj1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiTm9uTWF4U3VwcHJlc3Npb25WNVwiOntsZXR7Ym94ZXM6cyxzY29yZXM6aSxtYXhPdXRwdXRTaXplOm8saW91VGhyZXNob2xkOmwsc2NvcmVUaHJlc2hvbGQ6dSxzb2Z0Tm1zU2lnbWE6cH09Z3goZSx0LG4pLGQ9YXdhaXQgci5pbWFnZS5ub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZUFzeW5jKHMsaSxvLGwsdSxwKTtyZXR1cm5bZC5zZWxlY3RlZEluZGljZXMsZC5zZWxlY3RlZFNjb3Jlc119Y2FzZVwiTm9uTWF4U3VwcHJlc3Npb25WNFwiOntsZXR7Ym94ZXM6cyxzY29yZXM6aSxtYXhPdXRwdXRTaXplOm8saW91VGhyZXNob2xkOmwsc2NvcmVUaHJlc2hvbGQ6dX09Z3goZSx0LG4pLHA9ayhcInBhZFRvTWF4T3V0cHV0U2l6ZVwiLGUsdCxuKSxkPWF3YWl0IHIuaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb25QYWRkZWRBc3luYyhzLGksbyxsLHUscCk7cmV0dXJuW2Quc2VsZWN0ZWRJbmRpY2VzLGQudmFsaWRPdXRwdXRzXX1jYXNlXCJOb25NYXhTdXBwcmVzc2lvblYzXCI6Y2FzZVwiTm9uTWF4U3VwcHJlc3Npb25WMlwiOntsZXR7Ym94ZXM6cyxzY29yZXM6aSxtYXhPdXRwdXRTaXplOm8saW91VGhyZXNob2xkOmwsc2NvcmVUaHJlc2hvbGQ6dX09Z3goZSx0LG4pO3JldHVyblthd2FpdCByLmltYWdlLm5vbk1heFN1cHByZXNzaW9uQXN5bmMocyxpLG8sbCx1KV19Y2FzZVwiV2hlcmVcIjp7bGV0IHM9ci5jYXN0KGsoXCJjb25kaXRpb25cIixlLHQsbiksXCJib29sXCIpLGk9W2F3YWl0IHIud2hlcmVBc3luYyhzKV07cmV0dXJuIHMuZGlzcG9zZSgpLGl9Y2FzZVwiTGlzdERpZmZcIjpyZXR1cm4gci5zZXRkaWZmMWRBc3luYyhrKFwieFwiLGUsdCxuKSxrKFwieVwiLGUsdCxuKSk7ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sS3E9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkxvd2VyQm91bmRcIjp7bGV0IHI9ayhcInNvcnRlZFNlcXVlbmNlXCIsZSx0LG4pLHM9ayhcInZhbHVlc1wiLGUsdCxuKTtyZXR1cm5bYS5sb3dlckJvdW5kKHIscyldfWNhc2VcIlRvcEtWMlwiOntsZXQgcj1rKFwieFwiLGUsdCxuKSxzPWsoXCJrXCIsZSx0LG4pLGk9ayhcInNvcnRlZFwiLGUsdCxuKSxvPWEudG9wayhyLHMsaSk7cmV0dXJuW28udmFsdWVzLG8uaW5kaWNlc119Y2FzZVwiVXBwZXJCb3VuZFwiOntsZXQgcj1rKFwic29ydGVkU2VxdWVuY2VcIixlLHQsbikscz1rKFwidmFsdWVzXCIsZSx0LG4pO3JldHVyblthLnVwcGVyQm91bmQocixzKV19Y2FzZVwiVW5pcXVlXCI6e2xldCByPWsoXCJ4XCIsZSx0LG4pLHM9YS51bmlxdWUocik7cmV0dXJuW3MudmFsdWVzLHMuaW5kaWNlc119Y2FzZVwiVW5pcXVlVjJcIjp7bGV0IHI9ayhcInhcIixlLHQsbikscz1rKFwiYXhpc1wiLGUsdCxuKSxpPWEudW5pcXVlKHIscyk7cmV0dXJuW2kudmFsdWVzLGkuaW5kaWNlc119ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sWHE9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkNvbnN0XCI6cmV0dXJuIHRbZS5uYW1lXTtjYXNlXCJQbGFjZWhvbGRlcldpdGhEZWZhdWx0XCI6bGV0IHI9ayhcImRlZmF1bHRcIixlLHQsbik7cmV0dXJuW3BuKGUubmFtZSx0LG4pfHxyXTtjYXNlXCJQbGFjZWhvbGRlclwiOnJldHVybltwbihlLm5hbWUsdCxuKV07Y2FzZVwiSWRlbnRpdHlcIjpjYXNlXCJTdG9wR3JhZGllbnRcIjpjYXNlXCJGYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiOntsZXQgcD1rKFwieFwiLGUsdCxuKTtyZXR1cm5bTnIocCldfWNhc2VcIklkZW50aXR5TlwiOnJldHVybiBrKFwieFwiLGUsdCxuKS5tYXAocD0+TnIocCkpO2Nhc2VcIlNuYXBzaG90XCI6bGV0IHM9ayhcInhcIixlLHQsbik7cmV0dXJuW05yKHMpXTtjYXNlXCJTaGFwZVwiOnJldHVyblthLnRlbnNvcjFkKGsoXCJ4XCIsZSx0LG4pLnNoYXBlLFwiaW50MzJcIildO2Nhc2VcIlNoYXBlTlwiOnJldHVybiBrKFwieFwiLGUsdCxuKS5tYXAocD0+YS50ZW5zb3IxZChwLnNoYXBlKSk7Y2FzZVwiU2l6ZVwiOnJldHVyblthLnNjYWxhcihrKFwieFwiLGUsdCxuKS5zaXplLFwiaW50MzJcIildO2Nhc2VcIlJhbmtcIjpyZXR1cm5bYS5zY2FsYXIoayhcInhcIixlLHQsbikucmFuayxcImludDMyXCIpXTtjYXNlXCJOb09wXCI6cmV0dXJuW2Euc2NhbGFyKDEpXTtjYXNlXCJQcmludFwiOmxldCBpPWsoXCJ4XCIsZSx0LG4pLG89ayhcImRhdGFcIixlLHQsbiksbD1rKFwibWVzc2FnZVwiLGUsdCxuKSx1PWsoXCJzdW1tYXJpemVcIixlLHQsbik7Y29uc29sZS53YXJuKFwiVGhlIGdyYXBoIGhhcyBhIHRmLnByaW50KCkgb3BlcmF0aW9uLHVzdWFsbHkgdXNlZCBmb3IgZGVidWdnaW5nLCB3aGljaCBzbG93cyBkb3duIHBlcmZvcm1hbmNlLlwiKSxjb25zb2xlLmxvZyhsKTtmb3IobGV0IHA9MDtwPG8ubGVuZ3RoO3ArKyljb25zb2xlLmxvZyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvW3BdLmRhdGFTeW5jKCkpLnNsaWNlKDAsdSkpO3JldHVybltpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxZcT1jbGFzc3tnZXQgaWQoKXtyZXR1cm4gdGhpcy5oYW5kbGUuaWR9Y29uc3RydWN0b3IoZSx0KXt0aGlzLmtleURUeXBlPWUsdGhpcy52YWx1ZURUeXBlPXQsdGhpcy5oYW5kbGU9eGUoMCksdGhpcy50ZW5zb3JNYXA9bmV3IE1hcCxIdCh0aGlzLmhhbmRsZSl9Y2xlYXJBbmRDbG9zZSgpe3RoaXMudGVuc29yTWFwLmZvckVhY2goZT0+ZS5kaXNwb3NlKCkpLHRoaXMudGVuc29yTWFwLmNsZWFyKCksdGhpcy5oYW5kbGUuZGlzcG9zZSgpfXNpemUoKXtyZXR1cm4gdGhpcy50ZW5zb3JNYXAuc2l6ZX10ZW5zb3JTaXplKCl7cmV0dXJuIHhlKHRoaXMuc2l6ZSgpLFwiaW50MzJcIil9YXN5bmMgaW1wb3J0KGUsdCl7dGhpcy5jaGVja0tleUFuZFZhbHVlVGVuc29yKGUsdCk7bGV0IG49YXdhaXQgZS5kYXRhKCk7cmV0dXJuIHRoaXMudGVuc29yTWFwLmZvckVhY2goYT0+YS5kaXNwb3NlKCkpLHRoaXMudGVuc29yTWFwLmNsZWFyKCksTygoKT0+e2xldCBhPWR0KHQpLHI9bi5sZW5ndGgscz1hLmxlbmd0aDt3LmFzc2VydChyPT09cywoKT0+YFRoZSBudW1iZXIgb2YgZWxlbWVudHMgZG9lc24ndCBtYXRjaCwga2V5cyBoYXMgJHtyfSBlbGVtZW50cywgdGhlIHZhbHVlcyBoYXMgJHtzfSBlbGVtZW50cy5gKTtmb3IobGV0IGk9MDtpPHI7aSsrKXtsZXQgbz1uW2ldLGw9YVtpXTtIdChsKSx0aGlzLnRlbnNvck1hcC5zZXQobyxsKX1yZXR1cm4gdGhpcy5oYW5kbGV9KX1hc3luYyBmaW5kKGUsdCl7dGhpcy5jaGVja0tleUFuZFZhbHVlVGVuc29yKGUsdCk7bGV0IG49YXdhaXQgZS5kYXRhKCk7cmV0dXJuIE8oKCk9PntsZXQgYT1bXTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoO3IrKyl7bGV0IHM9bltyXSxpPXRoaXMuZmluZFdpdGhEZWZhdWx0KHMsdCk7YS5wdXNoKGkpfXJldHVybiBBdChhKX0pfWZpbmRXaXRoRGVmYXVsdChlLHQpe2xldCBuPXRoaXMudGVuc29yTWFwLmdldChlKTtyZXR1cm4gbiE9bnVsbD9uOnR9Y2hlY2tLZXlBbmRWYWx1ZVRlbnNvcihlLHQpe2lmKGUuZHR5cGUhPT10aGlzLmtleURUeXBlKXRocm93IG5ldyBFcnJvcihgRXhwZWN0IGtleSBkdHlwZSAke3RoaXMua2V5RFR5cGV9LCBidXQgZ290ICR7ZS5kdHlwZX1gKTtpZih0LmR0eXBlIT09dGhpcy52YWx1ZURUeXBlKXRocm93IG5ldyBFcnJvcihgRXhwZWN0IHZhbHVlIGR0eXBlICR7dGhpcy52YWx1ZURUeXBlfSwgYnV0IGdvdCAke3QuZHR5cGV9YCl9fSxacT1hc3luYyhlLHQsbixhKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJIYXNoVGFibGVcIjpjYXNlXCJIYXNoVGFibGVWMlwiOntsZXQgcj1hLmdldEhhc2hUYWJsZUhhbmRsZUJ5TmFtZShlLm5hbWUpO2lmKHIhPW51bGwpcmV0dXJuW3JdO3tsZXQgcz1rKFwia2V5RFR5cGVcIixlLHQsbiksaT1rKFwidmFsdWVEVHlwZVwiLGUsdCxuKSxvPW5ldyBZcShzLGkpO3JldHVybiBhLmFkZEhhc2hUYWJsZShlLm5hbWUsbyksW28uaGFuZGxlXX19Y2FzZVwiSW5pdGlhbGl6ZVRhYmxlXCI6Y2FzZVwiSW5pdGlhbGl6ZVRhYmxlVjJcIjpjYXNlXCJMb29rdXBUYWJsZUltcG9ydFwiOmNhc2VcIkxvb2t1cFRhYmxlSW1wb3J0VjJcIjp7bGV0IHI9ayhcInRhYmxlSGFuZGxlXCIsZSx0LG4sYSkscz1rKFwia2V5c1wiLGUsdCxuKSxpPWsoXCJ2YWx1ZXNcIixlLHQsbik7cmV0dXJuW2F3YWl0IGEuZ2V0SGFzaFRhYmxlQnlJZChyLmlkKS5pbXBvcnQocyxpKV19Y2FzZVwiTG9va3VwVGFibGVGaW5kXCI6Y2FzZVwiTG9va3VwVGFibGVGaW5kVjJcIjp7bGV0IHI9ayhcInRhYmxlSGFuZGxlXCIsZSx0LG4sYSkscz1rKFwia2V5c1wiLGUsdCxuKSxpPWsoXCJkZWZhdWx0VmFsdWVcIixlLHQsbik7cmV0dXJuW2F3YWl0IGEuZ2V0SGFzaFRhYmxlQnlJZChyLmlkKS5maW5kKHMsaSldfWNhc2VcIkxvb2t1cFRhYmxlU2l6ZVwiOmNhc2VcIkxvb2t1cFRhYmxlU2l6ZVYyXCI6e2xldCByPWsoXCJ0YWJsZUhhbmRsZVwiLGUsdCxuLGEpO3JldHVyblthLmdldEhhc2hUYWJsZUJ5SWQoci5pZCkudGVuc29yU2l6ZSgpXX1kZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxKcT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiUmVzaXplQmlsaW5lYXJcIjp7bGV0IHI9ayhcImltYWdlc1wiLGUsdCxuKSxzPWsoXCJzaXplXCIsZSx0LG4pLGk9ayhcImFsaWduQ29ybmVyc1wiLGUsdCxuKSxvPWsoXCJoYWxmUGl4ZWxDZW50ZXJzXCIsZSx0LG4pO3JldHVyblthLmltYWdlLnJlc2l6ZUJpbGluZWFyKHIsW3NbMF0sc1sxXV0saSxvKV19Y2FzZVwiUmVzaXplTmVhcmVzdE5laWdoYm9yXCI6e2xldCByPWsoXCJpbWFnZXNcIixlLHQsbikscz1rKFwic2l6ZVwiLGUsdCxuKSxpPWsoXCJhbGlnbkNvcm5lcnNcIixlLHQsbiksbz1rKFwiaGFsZlBpeGVsQ2VudGVyc1wiLGUsdCxuKTtyZXR1cm5bYS5pbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3Iocixbc1swXSxzWzFdXSxpLG8pXX1jYXNlXCJDcm9wQW5kUmVzaXplXCI6e2xldCByPWsoXCJpbWFnZVwiLGUsdCxuKSxzPWsoXCJib3hlc1wiLGUsdCxuKSxpPWsoXCJib3hJbmRcIixlLHQsbiksbz1rKFwiY3JvcFNpemVcIixlLHQsbiksbD1rKFwibWV0aG9kXCIsZSx0LG4pLHU9ayhcImV4dHJhcG9sYXRpb25WYWx1ZVwiLGUsdCxuKTtyZXR1cm5bYS5pbWFnZS5jcm9wQW5kUmVzaXplKHIscyxpLG8sbCx1KV19Y2FzZVwiSW1hZ2VQcm9qZWN0aXZlVHJhbnNmb3JtVjNcIjp7bGV0IHI9ayhcImltYWdlc1wiLGUsdCxuKSxzPWsoXCJ0cmFuc2Zvcm1zXCIsZSx0LG4pLGk9ayhcIm91dHB1dFNoYXBlXCIsZSx0LG4pLG89ayhcImZpbGxWYWx1ZVwiLGUsdCxuKSxsPWsoXCJpbnRlcnBvbGF0aW9uXCIsZSx0LG4pLHU9ayhcImZpbGxNb2RlXCIsZSx0LG4pO3JldHVyblthLmltYWdlLnRyYW5zZm9ybShyLHMsbC50b0xvd2VyQ2FzZSgpLHUudG9Mb3dlckNhc2UoKSxvLGkpXX1kZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxRcT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiRXF1YWxcIjpyZXR1cm5bYS5lcXVhbChrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIk5vdEVxdWFsXCI6cmV0dXJuW2Eubm90RXF1YWwoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJHcmVhdGVyXCI6cmV0dXJuW2EuZ3JlYXRlcihrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkdyZWF0ZXJFcXVhbFwiOnJldHVyblthLmdyZWF0ZXJFcXVhbChrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkxlc3NcIjpyZXR1cm5bYS5sZXNzKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiTGVzc0VxdWFsXCI6cmV0dXJuW2EubGVzc0VxdWFsKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07Y2FzZVwiTG9naWNhbEFuZFwiOnJldHVyblthLmxvZ2ljYWxBbmQoayhcImFcIixlLHQsbiksayhcImJcIixlLHQsbikpXTtjYXNlXCJMb2dpY2FsTm90XCI6cmV0dXJuW2EubG9naWNhbE5vdChrKFwiYVwiLGUsdCxuKSldO2Nhc2VcIkxvZ2ljYWxPclwiOnJldHVyblthLmxvZ2ljYWxPcihrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIlNlbGVjdFwiOmNhc2VcIlNlbGVjdFYyXCI6cmV0dXJuW2Eud2hlcmUoayhcImNvbmRpdGlvblwiLGUsdCxuKSxrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSldO2Nhc2VcIkJpdHdpc2VBbmRcIjpyZXR1cm5bYS5iaXR3aXNlQW5kKGsoXCJhXCIsZSx0LG4pLGsoXCJiXCIsZSx0LG4pKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sZTU9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkJhdGNoTWF0TXVsXCI6Y2FzZVwiQmF0Y2hNYXRNdWxWMlwiOmNhc2VcIk1hdE11bFwiOnJldHVyblthLm1hdE11bChrKFwiYVwiLGUsdCxuKSxrKFwiYlwiLGUsdCxuKSxrKFwidHJhbnNwb3NlQVwiLGUsdCxuKSxrKFwidHJhbnNwb3NlQlwiLGUsdCxuKSldO2Nhc2VcIkVpbnN1bVwiOnJldHVyblthLmVpbnN1bShrKFwiZXF1YXRpb25cIixlLHQsbiksLi4uayhcInRlbnNvcnNcIixlLHQsbikpXTtjYXNlXCJUcmFuc3Bvc2VcIjpyZXR1cm5bYS50cmFuc3Bvc2UoayhcInhcIixlLHQsbiksayhcInBlcm1cIixlLHQsbikpXTtjYXNlXCJfRnVzZWRNYXRNdWxcIjpsZXRbcixzXT1rKFwiZnVzZWRPcHNcIixlLHQsbiksaT1yPT09XCJiaWFzYWRkXCIsbz1zPT09XCJwcmVsdVwiLGw9ayhcIm51bUFyZ3NcIixlLHQsbiksdT1rKFwibGVha3lyZWx1QWxwaGFcIixlLHQsbik7aWYoaSl7aWYobyYmbCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRnVzZWQgTWF0TXVsIHdpdGggQmlhc0FkZCBhbmQgUHJlbHUgbXVzdCBoYXZlIHR3byBleHRyYSBhcmd1bWVudHM6IGJpYXMgYW5kIGFscGhhLlwiKTtpZighbyYmbCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRnVzZWQgTWF0TXVsIHdpdGggQmlhc0FkZCBtdXN0IGhhdmUgb25lIGV4dHJhIGFyZ3VtZW50OiBiaWFzLlwiKX1sZXRbcCxkXT1rKFwiYXJnc1wiLGUsdCxuKTtyZXR1cm5bYS5mdXNlZC5tYXRNdWwoe2E6ayhcImFcIixlLHQsbiksYjprKFwiYlwiLGUsdCxuKSx0cmFuc3Bvc2VBOmsoXCJ0cmFuc3Bvc2VBXCIsZSx0LG4pLHRyYW5zcG9zZUI6ayhcInRyYW5zcG9zZUJcIixlLHQsbiksYmlhczpwLGFjdGl2YXRpb246cyxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOmQsbGVha3lyZWx1QWxwaGE6dX0pXTtjYXNlXCJNYXRyaXhCYW5kUGFydFwiOnJldHVyblthLmxpbmFsZy5iYW5kUGFydChrKFwiYVwiLGUsdCxuKSxrKFwibnVtTG93ZXJcIixlLHQsbiksayhcIm51bVVwcGVyXCIsZSx0LG4pKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sdDU9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIkV1Y2xpZGVhbk5vcm1cIjpyZXR1cm5bYS5ldWNsaWRlYW5Ob3JtKGsoXCJ4XCIsZSx0LG4pLGsoXCJheGlzXCIsZSx0LG4pLGsoXCJrZWVwRGltc1wiLGUsdCxuKSldO2Nhc2VcIkZ1c2VkQmF0Y2hOb3JtXCI6Y2FzZVwiRnVzZWRCYXRjaE5vcm1WMlwiOnJldHVyblthLmJhdGNoTm9ybShrKFwieFwiLGUsdCxuKSxrKFwibWVhblwiLGUsdCxuKSxrKFwidmFyaWFuY2VcIixlLHQsbiksayhcIm9mZnNldFwiLGUsdCxuKSxrKFwic2NhbGVcIixlLHQsbiksayhcImVwc2lsb25cIixlLHQsbikpXTtjYXNlXCJGdXNlZEJhdGNoTm9ybVYzXCI6cmV0dXJuW2EuYmF0Y2hOb3JtKGsoXCJ4XCIsZSx0LG4pLGsoXCJtZWFuXCIsZSx0LG4pLGsoXCJ2YXJpYW5jZVwiLGUsdCxuKSxrKFwib2Zmc2V0XCIsZSx0LG4pLGsoXCJzY2FsZVwiLGUsdCxuKSxrKFwiZXBzaWxvblwiLGUsdCxuKSldO2Nhc2VcIkxSTlwiOnJldHVyblthLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uKGsoXCJ4XCIsZSx0LG4pLGsoXCJyYWRpdXNcIixlLHQsbiksayhcImJpYXNcIixlLHQsbiksayhcImFscGhhXCIsZSx0LG4pLGsoXCJiZXRhXCIsZSx0LG4pKV07Y2FzZVwiU29mdG1heFwiOnJldHVyblthLnNvZnRtYXgoayhcInhcIixlLHQsbikpXTtjYXNlXCJMb2dTb2Z0bWF4XCI6cmV0dXJuW2EubG9nU29mdG1heChrKFwieFwiLGUsdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LG41PShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJSYWdnZWRHYXRoZXJcIjp7bGV0e291dHB1dE5lc3RlZFNwbGl0czpyLG91dHB1dERlbnNlVmFsdWVzOnN9PWEucmFnZ2VkR2F0aGVyKGsoXCJwYXJhbXNOZXN0ZWRTcGxpdHNcIixlLHQsbiksayhcInBhcmFtc0RlbnNlVmFsdWVzXCIsZSx0LG4pLGsoXCJpbmRpY2VzXCIsZSx0LG4pLGsoXCJvdXRwdXRSYWdnZWRSYW5rXCIsZSx0LG4pKTtyZXR1cm4gci5jb25jYXQocyl9Y2FzZVwiUmFnZ2VkUmFuZ2VcIjp7bGV0e3J0TmVzdGVkU3BsaXRzOnIscnREZW5zZVZhbHVlczpzfT1hLnJhZ2dlZFJhbmdlKGsoXCJzdGFydHNcIixlLHQsbiksayhcImxpbWl0c1wiLGUsdCxuKSxrKFwic3BsaXRzXCIsZSx0LG4pKTtyZXR1cm5bcixzXX1jYXNlXCJSYWdnZWRUZW5zb3JUb1RlbnNvclwiOnJldHVyblthLnJhZ2dlZFRlbnNvclRvVGVuc29yKGsoXCJzaGFwZVwiLGUsdCxuKSxrKFwidmFsdWVzXCIsZSx0LG4pLGsoXCJkZWZhdWx0VmFsdWVcIixlLHQsbiksayhcInJvd1BhcnRpdGlvblRlbnNvcnNcIixlLHQsbiksayhcInJvd1BhcnRpdGlvblR5cGVzXCIsZSx0LG4pKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoYE5vZGUgdHlwZSAke2Uub3B9IGlzIG5vdCBpbXBsZW1lbnRlZGApfX0sYTU9KGUsdCxuLGE9b24pPT57c3dpdGNoKGUub3Ape2Nhc2VcIk1heFwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKSxsPWsoXCJrZWVwRGltc1wiLGUsdCxuKTtyZXR1cm5bYS5tYXgoayhcInhcIixlLHQsbiksbyxsKV19Y2FzZVwiTWVhblwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKSxsPWsoXCJrZWVwRGltc1wiLGUsdCxuKTtyZXR1cm5bYS5tZWFuKGsoXCJ4XCIsZSx0LG4pLG8sbCldfWNhc2VcIk1pblwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKSxsPWsoXCJrZWVwRGltc1wiLGUsdCxuKTtyZXR1cm5bYS5taW4oayhcInhcIixlLHQsbiksbyxsKV19Y2FzZVwiU3VtXCI6e2xldCBvPWsoXCJheGlzXCIsZSx0LG4pLGw9ayhcImtlZXBEaW1zXCIsZSx0LG4pO3JldHVyblthLnN1bShrKFwieFwiLGUsdCxuKSxvLGwpXX1jYXNlXCJBbGxcIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwia2VlcERpbXNcIixlLHQsbik7cmV0dXJuW2EuYWxsKGsoXCJ4XCIsZSx0LG4pLG8sbCldfWNhc2VcIkFueVwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKSxsPWsoXCJrZWVwRGltc1wiLGUsdCxuKTtyZXR1cm5bYS5hbnkoayhcInhcIixlLHQsbiksbyxsKV19Y2FzZVwiQXJnTWF4XCI6e2xldCBvPWsoXCJheGlzXCIsZSx0LG4pO3JldHVyblthLmFyZ01heChrKFwieFwiLGUsdCxuKSxvKV19Y2FzZVwiQXJnTWluXCI6e2xldCBvPWsoXCJheGlzXCIsZSx0LG4pO3JldHVyblthLmFyZ01pbihrKFwieFwiLGUsdCxuKSxvKV19Y2FzZVwiUHJvZFwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKSxsPWsoXCJrZWVwRGltc1wiLGUsdCxuKTtyZXR1cm5bYS5wcm9kKGsoXCJ4XCIsZSx0LG4pLG8sbCldfWNhc2VcIkN1bXByb2RcIjp7bGV0IG89ayhcImF4aXNcIixlLHQsbiksbD1rKFwiZXhjbHVzaXZlXCIsZSx0LG4pLHU9ayhcInJldmVyc2VcIixlLHQsbik7cmV0dXJuW2EuY3VtcHJvZChrKFwieFwiLGUsdCxuKSxvLGwsdSldfWNhc2VcIkN1bXN1bVwiOntsZXQgbz1rKFwiYXhpc1wiLGUsdCxuKSxsPWsoXCJleGNsdXNpdmVcIixlLHQsbiksdT1rKFwicmV2ZXJzZVwiLGUsdCxuKTtyZXR1cm5bYS5jdW1zdW0oayhcInhcIixlLHQsbiksbyxsLHUpXX1jYXNlXCJCaW5jb3VudFwiOmxldCByPWsoXCJ4XCIsZSx0LG4pLHM9ayhcIndlaWdodHNcIixlLHQsbiksaT1rKFwic2l6ZVwiLGUsdCxuKTtyZXR1cm5bYS5iaW5jb3VudChyLHMsaSldO2Nhc2VcIkRlbnNlQmluY291bnRcIjp7bGV0IG89ayhcInhcIixlLHQsbiksbD1rKFwid2VpZ2h0c1wiLGUsdCxuKSx1PWsoXCJzaXplXCIsZSx0LG4pLHA9ayhcImJpbmFyeU91dHB1dFwiLGUsdCxuKTtyZXR1cm5bYS5kZW5zZUJpbmNvdW50KG8sbCx1LHApXX1kZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxyNT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiQ29uY2F0VjJcIjpjYXNlXCJDb25jYXRcIjp7bGV0IHI9ayhcIm5cIixlLHQsbikscz1rKFwiYXhpc1wiLGUsdCxuKSxpPWsoXCJ0ZW5zb3JzXCIsZSx0LG4pO3JldHVybiBpPWkuc2xpY2UoMCxyKSxbYS5jb25jYXQoaSxzKV19Y2FzZVwiR2F0aGVyXCI6e2xldCByPWsoXCJ4XCIsZSx0LG4pLHM9ayhcImluZGljZXNcIixlLHQsbik7cmV0dXJuW2EuZ2F0aGVyKHIsYS5jYXN0KHMsXCJpbnQzMlwiKSwwKV19Y2FzZVwiR2F0aGVyVjJcIjp7bGV0IHI9ayhcImF4aXNcIixlLHQsbikscz1rKFwiYmF0Y2hEaW1zXCIsZSx0LG4pLGk9ayhcInhcIixlLHQsbiksbz1rKFwiaW5kaWNlc1wiLGUsdCxuKTtyZXR1cm5bYS5nYXRoZXIoaSxhLmNhc3QobyxcImludDMyXCIpLHIscyldfWNhc2VcIlJldmVyc2VcIjp7bGV0IHI9ayhcImRpbXNcIixlLHQsbikscz1bXTtmb3IobGV0IG89MDtvPHIubGVuZ3RoO28rKylyW29dJiZzLnB1c2gobyk7bGV0IGk9ayhcInhcIixlLHQsbik7cmV0dXJuW2EucmV2ZXJzZShpLHMpXX1jYXNlXCJSZXZlcnNlVjJcIjp7bGV0IHI9ayhcImF4aXNcIixlLHQsbikscz1rKFwieFwiLGUsdCxuKTtyZXR1cm5bYS5yZXZlcnNlKHMscildfWNhc2VcIlNsaWNlXCI6e2xldCByPWsoXCJiZWdpblwiLGUsdCxuKSxzPWsoXCJzaXplXCIsZSx0LG4pO3JldHVyblthLnNsaWNlKGsoXCJ4XCIsZSx0LG4pLHIscyldfWNhc2VcIlN0cmlkZWRTbGljZVwiOntsZXQgcj1rKFwiYmVnaW5cIixlLHQsbikscz1rKFwiZW5kXCIsZSx0LG4pLGk9ayhcInN0cmlkZXNcIixlLHQsbiksbz1rKFwiYmVnaW5NYXNrXCIsZSx0LG4pLGw9ayhcImVuZE1hc2tcIixlLHQsbiksdT1rKFwiZWxsaXBzaXNNYXNrXCIsZSx0LG4pLHA9ayhcIm5ld0F4aXNNYXNrXCIsZSx0LG4pLGQ9ayhcInNocmlua0F4aXNNYXNrXCIsZSx0LG4pLGM9ayhcInhcIixlLHQsbik7cmV0dXJuW2Euc3RyaWRlZFNsaWNlKGMscixzLGksbyxsLHUscCxkKV19Y2FzZVwiUGFja1wiOnJldHVybiBPKCgpPT57bGV0IHI9ayhcImF4aXNcIixlLHQsbikscz1rKFwidGVuc29yc1wiLGUsdCxuKSxpPXNbMF0uc2hhcGUsbz1hLnNxdWVlemUoc1swXSkuc2hhcGUsbD1zLm1hcCh1PT57bGV0IHA9dy5hcnJheXNFcXVhbCh1LnNoYXBlLGkpO2lmKCFwJiYhdy5hcnJheXNFcXVhbChhLnNxdWVlemUodSkuc2hhcGUsbykpdGhyb3cgbmV3IEVycm9yKFwidGhlIGlucHV0IHRlbnNvcnMgc2hhcGUgZG9lcyBub3QgbWF0Y2hcIik7cmV0dXJuIHA/dTphLnJlc2hhcGUodSxpKX0pO3JldHVyblthLnN0YWNrKGwscildfSk7Y2FzZVwiVW5wYWNrXCI6e2xldCByPWsoXCJheGlzXCIsZSx0LG4pLHM9ayhcInRlbnNvclwiLGUsdCxuKTtyZXR1cm4gYS51bnN0YWNrKHMscil9Y2FzZVwiVGlsZVwiOntsZXQgcj1rKFwicmVwc1wiLGUsdCxuKTtyZXR1cm5bYS50aWxlKGsoXCJ4XCIsZSx0LG4pLHIpXX1jYXNlXCJTcGxpdFwiOmNhc2VcIlNwbGl0VlwiOntsZXQgcj1rKFwiYXhpc1wiLGUsdCxuKSxzPWsoXCJudW1PclNpemVTcGxpdHNcIixlLHQsbiksaT1rKFwieFwiLGUsdCxuKTtyZXR1cm4gYS5zcGxpdChpLHMscil9Y2FzZVwiU2NhdHRlck5kXCI6e2xldCByPWsoXCJpbmRpY2VzXCIsZSx0LG4pLHM9ayhcInZhbHVlc1wiLGUsdCxuKSxpPWsoXCJzaGFwZVwiLGUsdCxuKTtyZXR1cm5bYS5zY2F0dGVyTkQocixzLGkpXX1jYXNlXCJHYXRoZXJOZFwiOntsZXQgcj1rKFwieFwiLGUsdCxuKSxzPWsoXCJpbmRpY2VzXCIsZSx0LG4pO3JldHVyblthLmdhdGhlck5EKHIscyldfWNhc2VcIlNwYXJzZVRvRGVuc2VcIjp7bGV0IHI9ayhcInNwYXJzZUluZGljZXNcIixlLHQsbikscz1rKFwib3V0cHV0U2hhcGVcIixlLHQsbiksaT1rKFwic3BhcnNlVmFsdWVzXCIsZSx0LG4pLG89ayhcImRlZmF1bHRWYWx1ZVwiLGUsdCxuKTtyZXR1cm5bYS5zcGFyc2VUb0RlbnNlKHIsaSxzLGkuZHR5cGU9PT1vLmR0eXBlP286YS5jYXN0KG8saS5kdHlwZSkpXX1jYXNlXCJUZW5zb3JTY2F0dGVyVXBkYXRlXCI6e2xldCByPWsoXCJpbmRpY2VzXCIsZSx0LG4pLHM9ayhcInZhbHVlc1wiLGUsdCxuKSxpPWsoXCJ0ZW5zb3JcIixlLHQsbik7cmV0dXJuW2EudGVuc29yU2NhdHRlclVwZGF0ZShpLHIscyldfWRlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19LHM1PShlLHQsbixhPW9uKT0+e3N3aXRjaChlLm9wKXtjYXNlXCJTcGFyc2VGaWxsRW1wdHlSb3dzXCI6e2xldHtvdXRwdXRJbmRpY2VzOnIsb3V0cHV0VmFsdWVzOnMsZW1wdHlSb3dJbmRpY2F0b3I6aSxyZXZlcnNlSW5kZXhNYXA6b309YS5zcGFyc2Uuc3BhcnNlRmlsbEVtcHR5Um93cyhrKFwiaW5kaWNlc1wiLGUsdCxuKSxrKFwidmFsdWVzXCIsZSx0LG4pLGsoXCJkZW5zZVNoYXBlXCIsZSx0LG4pLGsoXCJkZWZhdWx0VmFsdWVcIixlLHQsbikpO3JldHVybltyLHMsaSxvXX1jYXNlXCJTcGFyc2VSZXNoYXBlXCI6e2xldHtvdXRwdXRJbmRpY2VzOnIsb3V0cHV0U2hhcGU6c309YS5zcGFyc2Uuc3BhcnNlUmVzaGFwZShrKFwiaW5wdXRJbmRpY2VzXCIsZSx0LG4pLGsoXCJpbnB1dFNoYXBlXCIsZSx0LG4pLGsoXCJuZXdTaGFwZVwiLGUsdCxuKSk7cmV0dXJuW3Isc119Y2FzZVwiU3BhcnNlU2VnbWVudE1lYW5cIjpyZXR1cm5bYS5zcGFyc2Uuc3BhcnNlU2VnbWVudE1lYW4oayhcImRhdGFcIixlLHQsbiksayhcImluZGljZXNcIixlLHQsbiksayhcInNlZ21lbnRJZHNcIixlLHQsbikpXTtjYXNlXCJTcGFyc2VTZWdtZW50U3VtXCI6cmV0dXJuW2Euc3BhcnNlLnNwYXJzZVNlZ21lbnRTdW0oayhcImRhdGFcIixlLHQsbiksayhcImluZGljZXNcIixlLHQsbiksayhcInNlZ21lbnRJZHNcIixlLHQsbikpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxpNT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiRkZUXCI6cmV0dXJuW2EuZmZ0KGsoXCJ4XCIsZSx0LG4pKV07Y2FzZVwiSUZGVFwiOnJldHVyblthLmlmZnQoayhcInhcIixlLHQsbikpXTtjYXNlXCJSRkZUXCI6cmV0dXJuW2EucmZmdChrKFwieFwiLGUsdCxuKSldO2Nhc2VcIklSRkZUXCI6cmV0dXJuW2EuaXJmZnQoayhcInhcIixlLHQsbikpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxvNT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiU3RhdGljUmVnZXhSZXBsYWNlXCI6cmV0dXJuW2Euc3RyaW5nLnN0YXRpY1JlZ2V4UmVwbGFjZShrKFwiaW5wdXRcIixlLHQsbiksayhcInBhdHRlcm5cIixlLHQsbiksayhcInJld3JpdGVcIixlLHQsbiksayhcInJlcGxhY2VHbG9iYWxcIixlLHQsbikpXTtjYXNlXCJTdHJpbmdOR3JhbXNcIjp7bGV0e25HcmFtczpyLG5HcmFtc1NwbGl0czpzfT1hLnN0cmluZy5zdHJpbmdOR3JhbXMoayhcImRhdGFcIixlLHQsbiksayhcImRhdGFTcGxpdHNcIixlLHQsbiksayhcInNlcGFyYXRvclwiLGUsdCxuKSxrKFwibkdyYW1XaWR0aHNcIixlLHQsbiksayhcImxlZnRQYWRcIixlLHQsbiksayhcInJpZ2h0UGFkXCIsZSx0LG4pLGsoXCJwYWRXaWR0aFwiLGUsdCxuKSxrKFwicHJlc2VydmVTaG9ydFNlcXVlbmNlc1wiLGUsdCxuKSk7cmV0dXJuW3Isc119Y2FzZVwiU3RyaW5nU3BsaXRcIjp7bGV0e2luZGljZXM6cix2YWx1ZXM6cyxzaGFwZTppfT1hLnN0cmluZy5zdHJpbmdTcGxpdChrKFwiaW5wdXRcIixlLHQsbiksayhcImRlbGltaXRlclwiLGUsdCxuKSxrKFwic2tpcEVtcHR5XCIsZSx0LG4pKTtyZXR1cm5bcixzLGldfWNhc2VcIlN0cmluZ1RvSGFzaEJ1Y2tldEZhc3RcIjpyZXR1cm5bYS5zdHJpbmcuc3RyaW5nVG9IYXNoQnVja2V0RmFzdChrKFwiaW5wdXRcIixlLHQsbiksayhcIm51bUJ1Y2tldHNcIixlLHQsbikpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihgTm9kZSB0eXBlICR7ZS5vcH0gaXMgbm90IGltcGxlbWVudGVkYCl9fSxsNT0oZSx0LG4sYT1vbik9Pntzd2l0Y2goZS5vcCl7Y2FzZVwiQ2FzdFwiOnJldHVyblthLmNhc3QoayhcInhcIixlLHQsbiksayhcImR0eXBlXCIsZSx0LG4pKV07Y2FzZVwiRXhwYW5kRGltc1wiOntsZXQgcj1rKFwiYXhpc1wiLGUsdCxuKTtyZXR1cm5bYS5leHBhbmREaW1zKGsoXCJ4XCIsZSx0LG4pLHIpXX1jYXNlXCJTcXVlZXplXCI6e2xldCByPWsoXCJheGlzXCIsZSx0LG4pO3JldHVyblthLnNxdWVlemUoayhcInhcIixlLHQsbikscildfWNhc2VcIlJlc2hhcGVcIjpyZXR1cm5bYS5yZXNoYXBlKGsoXCJ4XCIsZSx0LG4pLGsoXCJzaGFwZVwiLGUsdCxuKSldO2Nhc2VcIkVuc3VyZVNoYXBlXCI6cmV0dXJuW2EuZW5zdXJlU2hhcGUoayhcInhcIixlLHQsbiksayhcInNoYXBlXCIsZSx0LG4pKV07Y2FzZVwiTWlycm9yUGFkXCI6cmV0dXJuW2EubWlycm9yUGFkKGsoXCJ4XCIsZSx0LG4pLGsoXCJwYWRkaW5nXCIsZSx0LG4pLGsoXCJtb2RlXCIsZSx0LG4pKV07Y2FzZVwiUGFkVjJcIjpjYXNlXCJQYWRcIjpyZXR1cm5bYS5wYWQoayhcInhcIixlLHQsbiksayhcInBhZGRpbmdcIixlLHQsbiksayhcImNvbnN0YW50VmFsdWVcIixlLHQsbikpXTtjYXNlXCJTcGFjZVRvQmF0Y2hORFwiOntsZXQgcj1rKFwiYmxvY2tTaGFwZVwiLGUsdCxuKSxzPWsoXCJwYWRkaW5nc1wiLGUsdCxuKTtyZXR1cm5bYS5zcGFjZVRvQmF0Y2hORChrKFwieFwiLGUsdCxuKSxyLHMpXX1jYXNlXCJCYXRjaFRvU3BhY2VORFwiOntsZXQgcj1rKFwiYmxvY2tTaGFwZVwiLGUsdCxuKSxzPWsoXCJjcm9wc1wiLGUsdCxuKTtyZXR1cm5bYS5iYXRjaFRvU3BhY2VORChrKFwieFwiLGUsdCxuKSxyLHMpXX1jYXNlXCJEZXB0aFRvU3BhY2VcIjp7bGV0IHI9ayhcImJsb2NrU2l6ZVwiLGUsdCxuKSxzPWsoXCJkYXRhRm9ybWF0XCIsZSx0LG4pLnRvVXBwZXJDYXNlKCk7cmV0dXJuW2EuZGVwdGhUb1NwYWNlKGsoXCJ4XCIsZSx0LG4pLHIscyldfWNhc2VcIkJyb2FkY2FzdFRvXCI6cmV0dXJuW2EuYnJvYWRjYXN0VG8oayhcInhcIixlLHQsbiksayhcInNoYXBlXCIsZSx0LG4pKV07Y2FzZVwiQnJvYWRjYXN0QXJnc1wiOnJldHVyblthLmJyb2FkY2FzdEFyZ3MoayhcInMwXCIsZSx0LG4pLGsoXCJzMVwiLGUsdCxuKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBOb2RlIHR5cGUgJHtlLm9wfSBpcyBub3QgaW1wbGVtZW50ZWRgKX19O2Z1bmN0aW9uIFVJKGUsdCxuLGEscj1PKXtsZXQgcz0oKGksbyxsKT0+e3N3aXRjaChpLmNhdGVnb3J5KXtjYXNlXCJhcml0aG1ldGljXCI6cmV0dXJuIHIoKCk9PlBxKGksbyxsKSk7Y2FzZVwiYmFzaWNfbWF0aFwiOnJldHVybiByKCgpPT5McShpLG8sbCkpO2Nhc2VcImNvbnRyb2xcIjpyZXR1cm4gR3EoaSxvLGwpO2Nhc2VcImNvbnZvbHV0aW9uXCI6cmV0dXJuIHIoKCk9PkhxKGksbyxsKSk7Y2FzZVwiY3JlYXRpb25cIjpyZXR1cm4gcigoKT0+anEoaSxvLGwpKTtjYXNlXCJkeW5hbWljXCI6cmV0dXJuIHFxKGksbyxsKTtjYXNlXCJldmFsdWF0aW9uXCI6cmV0dXJuIHIoKCk9PktxKGksbyxsKSk7Y2FzZVwiaW1hZ2VcIjpyZXR1cm4gcigoKT0+SnEoaSxvLGwpKTtjYXNlXCJncmFwaFwiOnJldHVybiByKCgpPT5YcShpLG8sbCkpO2Nhc2VcImxvZ2ljYWxcIjpyZXR1cm4gcigoKT0+UXEoaSxvLGwpKTtjYXNlXCJtYXRyaWNlc1wiOnJldHVybiByKCgpPT5lNShpLG8sbCkpO2Nhc2VcIm5vcm1hbGl6YXRpb25cIjpyZXR1cm4gcigoKT0+dDUoaSxvLGwpKTtjYXNlXCJyYWdnZWRcIjpyZXR1cm4gcigoKT0+bjUoaSxvLGwpKTtjYXNlXCJyZWR1Y3Rpb25cIjpyZXR1cm4gcigoKT0+YTUoaSxvLGwpKTtjYXNlXCJzbGljZV9qb2luXCI6cmV0dXJuIHIoKCk9PnI1KGksbyxsKSk7Y2FzZVwic3BhcnNlXCI6cmV0dXJuIHIoKCk9PnM1KGksbyxsKSk7Y2FzZVwic3BlY3RyYWxcIjpyZXR1cm4gcigoKT0+aTUoaSxvLGwpKTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gcigoKT0+bzUoaSxvLGwpKTtjYXNlXCJ0cmFuc2Zvcm1hdGlvblwiOnJldHVybiByKCgpPT5sNShpLG8sbCkpO2Nhc2VcImhhc2hfdGFibGVcIjpyZXR1cm4gWnEoaSxvLGwsYSk7Y2FzZVwiY3VzdG9tXCI6bGV0IHU9ekMoaS5vcCk7aWYodSYmdS5jdXN0b21FeGVjdXRvcilyZXR1cm4gdS5jdXN0b21FeGVjdXRvcihuZXcgT3EoaSxvLGwpKTt0aHJvdyBUeXBlRXJyb3IoYEN1c3RvbSBvcCAke2kub3B9IGlzIG5vdCByZWdpc3RlcmVkLmApO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKGBVbmtub3duIG9wICcke2kub3B9Jy4gRmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3VlcyBzbyB3ZSBjYW4gYWRkIGl0LCBvciByZWdpc3RlciBhIGN1c3RvbSBleGVjdXRpb24gd2l0aCB0Zi5yZWdpc3Rlck9wKClgKX19KShlLHQsbik7cmV0dXJuIHcuaXNQcm9taXNlKHMpP3MudGhlbihpPT5bXS5jb25jYXQoaSkpOltdLmNvbmNhdChzKX12YXIgR0k9Y2xhc3N7Y29uc3RydWN0b3IoZT17fSx0PXt9LG49e30sYT17fSxyKXt0aGlzLndlaWdodE1hcD1lLHRoaXMudGVuc29yQXJyYXlNYXA9dCx0aGlzLnRlbnNvckxpc3RNYXA9bix0aGlzLmZ1bmN0aW9uTWFwPWEsdGhpcy5wYXJzZU5vZGVOYW1lQ2FjaGU9cix0aGlzLnJvb3RDb250ZXh0PXtpZDowLGZyYW1lTmFtZTpcIlwiLGl0ZXJhdGlvbklkOjB9LHRoaXMuY29udGV4dHM9W3RoaXMucm9vdENvbnRleHRdLHRoaXMubGFzdElkPTAsdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCl9bmV3RnJhbWUoZSx0KXtyZXR1cm57aWQ6ZSxmcmFtZU5hbWU6dCxpdGVyYXRpb25JZDowfX1zZXQgY3VycmVudENvbnRleHQoZSl7dGhpcy5jb250ZXh0cyE9PWUmJih0aGlzLmNvbnRleHRzPWUsdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCkpfWdldCBjdXJyZW50Q29udGV4dCgpe3JldHVybiB0aGlzLmNvbnRleHRzfWdldCBjdXJyZW50Q29udGV4dElkKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzWzBdfWdldCBjdXJyZW50Q29udGV4dElkcygpe3JldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc31nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCl7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLmNvbnRleHRzLmxlbmd0aC0xO3QrKyl7bGV0IG49dGhpcy5jb250ZXh0cy5zbGljZSgwLHRoaXMuY29udGV4dHMubGVuZ3RoLXQpO2UucHVzaCh0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKG4pKX1lLnB1c2goXCJcIiksdGhpcy5fY3VycmVudENvbnRleHRJZHM9ZX1jb250ZXh0SWRmb3JDb250ZXh0cyhlKXtyZXR1cm4gZT9lLm1hcCh0PT50LmlkPT09MCYmdC5pdGVyYXRpb25JZD09PTA/XCJcIjpgJHt0LmZyYW1lTmFtZX0tJHt0Lml0ZXJhdGlvbklkfWApLmpvaW4oXCIvXCIpOlwiXCJ9ZW50ZXJGcmFtZShlKXt0aGlzLmNvbnRleHRzJiYodGhpcy5sYXN0SWQrKyx0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmNvbnRleHRzLnB1c2godGhpcy5uZXdGcmFtZSh0aGlzLmxhc3RJZCxlKSksdGhpcy5fY3VycmVudENvbnRleHRJZHMudW5zaGlmdCh0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHRoaXMuY29udGV4dHMpKSl9ZXhpdEZyYW1lKCl7aWYodGhpcy5jb250ZXh0cyYmdGhpcy5jb250ZXh0cy5sZW5ndGg+MSl0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmNvbnRleHRzLnNwbGljZSgtMSksdGhpcy5jdXJyZW50Q29udGV4dElkcy5zaGlmdCgpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV4aXQgZnJhbWUsIHRoZSBjb250ZXh0IGlzIGVtcHR5XCIpfW5leHRJdGVyYXRpb24oKXtpZih0aGlzLmNvbnRleHRzJiZ0aGlzLmNvbnRleHRzLmxlbmd0aD4wKXt0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmxhc3RJZCsrO2xldCBlPU9iamVjdC5hc3NpZ24oe30sdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aC0xXSk7ZS5pdGVyYXRpb25JZCs9MSxlLmlkPXRoaXMubGFzdElkLHRoaXMuY29udGV4dHMuc3BsaWNlKC0xLDEsZSksdGhpcy5fY3VycmVudENvbnRleHRJZHMuc3BsaWNlKDAsMSx0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHRoaXMuY29udGV4dHMpKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbmNyZWFzZSBmcmFtZSBpdGVyYXRpb24sIHRoZSBjb250ZXh0IGlzIGVtcHR5XCIpfWdldFdlaWdodChlKXtyZXR1cm4gdGhpcy53ZWlnaHRNYXBbZV19YWRkVGVuc29yQXJyYXkoZSl7dGhpcy50ZW5zb3JBcnJheU1hcFtlLmlkXT1lfWdldFRlbnNvckFycmF5KGUpe3JldHVybiB0aGlzLnRlbnNvckFycmF5TWFwW2VdfWFkZFRlbnNvckxpc3QoZSl7dGhpcy50ZW5zb3JMaXN0TWFwW2UuaWRdPWV9Z2V0VGVuc29yTGlzdChlKXtyZXR1cm4gdGhpcy50ZW5zb3JMaXN0TWFwW2VdfWRpc3Bvc2UoZSl7Zm9yKGxldCB0IGluIHRoaXMudGVuc29yQXJyYXlNYXApdGhpcy50ZW5zb3JBcnJheU1hcFt0XS5jbGVhckFuZENsb3NlKGUpO2ZvcihsZXQgdCBpbiB0aGlzLnRlbnNvckxpc3RNYXApdGhpcy50ZW5zb3JMaXN0TWFwW3RdLmNsZWFyQW5kQ2xvc2UoZSl9fTtmdW5jdGlvbiBISShlLHQsbixhKXtsZXQgcj1uZXcgU2V0LHM9W10saT1udWxsLG89bnVsbCxsPW5ldyBTZXQsdT1uZXcgU2V0KE9iamVjdC5rZXlzKGUpLm1hcChjPT5YbihjKVswXSkpO2E9YXx8W107bGV0IHA9bmV3IFNldChhLm1hcChjPT5YbihjLm5hbWUpWzBdKSksZD1bLi4udF07Zm9yKDtkLmxlbmd0aD4wOyl7bGV0IGM9ZC5wb3AoKTtpZigoUXMoYyl8fGc1KGMpfHxiNShjKSkmJmk9PW51bGwmJihpPWMsbz1pLmNoaWxkcmVuLm1hcChoPT5oLm5hbWUpLmZpbHRlcihoPT5yLmhhcyhoKSkpLHIuYWRkKGMubmFtZSksbltjLm5hbWVdPT1udWxsJiYhdS5oYXMoYy5uYW1lKSYmIXAuaGFzKGMubmFtZSkpe2lmKGMuaW5wdXRzLmxlbmd0aD09PTApe3MucHVzaChjLm5hbWUpO2NvbnRpbnVlfWMuaW5wdXRzLmZvckVhY2goaD0+e2wuaGFzKGgubmFtZSl8fChsLmFkZChoLm5hbWUpLGQucHVzaChoKSl9KX19cmV0dXJue2lucHV0czplLG91dHB1dHM6dCx1c2VkTm9kZXM6cixtaXNzaW5nSW5wdXRzOnMsZHluYW1pY05vZGU6aSxzeW5jSW5wdXRzOm99fWZ1bmN0aW9uIHU1KGUsdCl7bGV0e3VzZWROb2RlczpuLGlucHV0czphfT10LHI9T2JqZWN0LmtleXMoYSkubWFwKGc9PlhuKGcpWzBdKS5tYXAoZz0+ZS5ub2Rlc1tnXSkscz1lLmluaXROb2Rlc3x8W10saT1nPT5uLmhhcyh0eXBlb2YgZz09XCJzdHJpbmdcIj9nOmcubmFtZSk7ZnVuY3Rpb24gbyhnKXtyZXR1cm5bLi4ubmV3IE1hcChnLm1hcChiPT5bYi5uYW1lLGJdKSkudmFsdWVzKCldfWxldCBsPW8oWy4uLnIsLi4uZS53ZWlnaHRzLC4uLnNdKS5maWx0ZXIoaSksdT1vKFsuLi5sLC4uLk9iamVjdC52YWx1ZXMoZS5ub2RlcyldKS5maWx0ZXIoaSkscD1uZXcgTWFwKHUubWFwKGc9PltnLm5hbWUsZ10pKSxkPXt9O2ZvcihsZXQgZyBvZiB1KXtkW2cubmFtZV09ZFtnLm5hbWVdfHwwO2ZvcihsZXQgYiBvZiBnLmNoaWxkcmVuKWkoYil8fChkW2IubmFtZV09TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSxkW2IubmFtZV09KGRbYi5uYW1lXXx8MCkrMX1sZXQgYz1PYmplY3QuZW50cmllcyhkKS5maWx0ZXIoKFssZ10pPT5nPT09MCkubWFwKChbZ10pPT5nKSxoPVsuLi5jXTtmb3IoO2MubGVuZ3RoPjA7KXtsZXQgZz1jLnBvcCgpLGI9cC5nZXQoZyk7Zm9yKGxldCB5IG9mIGIuY2hpbGRyZW4uZmlsdGVyKGkpKS0tZFt5Lm5hbWVdPT09MCYmKGgucHVzaCh5Lm5hbWUpLGMucHVzaCh5Lm5hbWUpKX1sZXQgbT1oLm1hcChnPT5wLmdldChnKSksZj1wNShtLGwpO3JldHVybiBjNShmLGwpLGZ9ZnVuY3Rpb24gcDUoZSx0KXtsZXQgbj1uZXcgTWFwKGUubWFwKHM9PltzLm5hbWUsc10pKSxhPXQubWFwKHM9PnMubmFtZSkscj1uZXcgU2V0KGEpO2Zvcig7YS5sZW5ndGg+MDspe2xldCBzPWEucG9wKCksaT1uLmdldChzKTtmb3IobGV0IG8gb2YgaS5jaGlsZHJlbikhbi5oYXMoby5uYW1lKXx8ci5oYXMoby5uYW1lKXx8KHIuYWRkKG8ubmFtZSksYS5wdXNoKG8ubmFtZSkpfXJldHVybiBlLmZpbHRlcihzPT5yLmhhcyhzLm5hbWUpKX12YXIgVGg9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlKXtzdXBlcihgTm9kZXNFeGVjdXRpb25PcmRlckVycm9yOiAke2V9YCl9fTtmdW5jdGlvbiBjNShlLHQpe2xldCBuPW5ldyBNYXAoZS5tYXAoKG8sbCk9PltvLm5hbWUsbF0pKSxhPW5ldyBTZXQodC5tYXAobz0+by5uYW1lKSkscj1vPT5hLmhhcyh0eXBlb2Ygbz09XCJzdHJpbmdcIj9vOm8ubmFtZSkscz1uZXcgU2V0KGUubWFwKG89Pm8ubmFtZSkpLGk9bz0+cy5oYXModHlwZW9mIG89PVwic3RyaW5nXCI/bzpvLm5hbWUpO2ZvcihsZXQgbyBvZiBlKXtmb3IobGV0IGwgb2Ygby5jaGlsZHJlbi5maWx0ZXIoaSkpe2lmKCFuLmhhcyhsLm5hbWUpKXRocm93IG5ldyBUaChgQ2hpbGQgJHtsLm5hbWV9IG9mIG5vZGUgJHtvLm5hbWV9IGlzIHVucmVhY2hhYmxlLmApO2lmKG4uZ2V0KG8ubmFtZSk+bi5nZXQobC5uYW1lKSl0aHJvdyBuZXcgVGgoYE5vZGUgJHtvLm5hbWV9IGlzIHNjaGVkdWxlZCB0byBydW4gYWZ0ZXIgaXRzIGNoaWxkICR7bC5uYW1lfS5gKX1pZighcihvKSlmb3IobGV0IGwgb2Ygby5pbnB1dHMpe2lmKCFuLmhhcyhsLm5hbWUpKXRocm93IG5ldyBUaChgSW5wdXQgJHtsLm5hbWV9IG9mIG5vZGUgJHtvLm5hbWV9IGlzIHVucmVhY2hhYmxlLmApO2lmKG4uZ2V0KGwubmFtZSk+bi5nZXQoby5uYW1lKSl0aHJvdyBuZXcgVGgoYE5vZGUgJHtvLm5hbWV9IGlzIHNjaGVkdWxlZCB0byBydW4gYmVmb3JlIGl0cyBpbnB1dCAke2wubmFtZX0uYCl9fX1mdW5jdGlvbiBkNShlKXtsZXQgdD1uZXcgTWFwKGUubWFwKChvLGwpPT5bby5uYW1lLGxdKSksbj1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixhPWUubWFwKChvLGwpPT5RcyhvKT9uOmwpLHI9bz0+e2xldCBsPWFbdC5nZXQoby5uYW1lKV07cmV0dXJuIGw9PW51bGw/LTE6bH0scz1lLm1hcCgobyxsKT0+by5jaGlsZHJlbi5tYXAocikucmVkdWNlKCh1LHApPT5NYXRoLm1heCh1LHApLGFbbF0pKSxpPW5ldyBNYXA7Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pe2xldCBsPXNbb107aWYobD09PW4pY29udGludWU7bGV0IHU9ZVtvXSxwPWVbbF07aS5oYXMocC5uYW1lKXx8aS5zZXQocC5uYW1lLFtdKSxpLmdldChwLm5hbWUpLnB1c2godSl9cmV0dXJuIGl9dmFyIGg1PW5ldyBTZXQoW1wiU3dpdGNoXCIsXCJNZXJnZVwiLFwiRW50ZXJcIixcIkV4aXRcIixcIk5leHRJdGVyYXRpb25cIixcIlN0YXRlbGVzc0lmXCIsXCJTdGF0ZWxlc3NXaGlsZVwiLFwiaWZcIixcIldoaWxlXCJdKSxtNT1uZXcgU2V0KFtcIk5vbk1heFN1cHByZXNzaW9uVjJcIixcIk5vbk1heFN1cHByZXNzaW9uVjNcIixcIk5vbk1heFN1cHByZXNzaW9uVjVcIixcIldoZXJlXCJdKSxmNT1uZXcgU2V0KFtcIkhhc2hUYWJsZVwiLFwiSGFzaFRhYmxlVjJcIixcIkxvb2t1cFRhYmxlSW1wb3J0XCIsXCJMb29rdXBUYWJsZUltcG9ydFYyXCIsXCJMb29rdXBUYWJsZUZpbmRcIixcIkxvb2t1cFRhYmxlRmluZFYyXCIsXCJMb29rdXBUYWJsZVNpemVcIixcIkxvb2t1cFRhYmxlU2l6ZVYyXCJdKTtmdW5jdGlvbiBRcyhlKXtyZXR1cm4gaDUuaGFzKGUub3ApfWZ1bmN0aW9uIGc1KGUpe3JldHVybiBtNS5oYXMoZS5vcCl9ZnVuY3Rpb24gYjUoZSl7cmV0dXJuIGY1LmhhcyhlLm9wKX12YXIgakk9Y2xhc3Mgb0V7Z2V0IHdlaWdodElkcygpe3JldHVybiB0aGlzLnBhcmVudD90aGlzLnBhcmVudC53ZWlnaHRJZHM6dGhpcy5fd2VpZ2h0SWRzfWdldCBmdW5jdGlvbkV4ZWN1dG9yTWFwKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LmZ1bmN0aW9uRXhlY3V0b3JNYXA6dGhpcy5fZnVuY3Rpb25FeGVjdXRvck1hcH1nZXQgd2VpZ2h0TWFwKCl7cmV0dXJuIHRoaXMucGFyZW50P3RoaXMucGFyZW50LndlaWdodE1hcDp0aGlzLl93ZWlnaHRNYXB9c2V0IHdlaWdodE1hcCh0KXtsZXQgbj1PYmplY3Qua2V5cyh0KS5tYXAoYT0+dFthXS5tYXAocj0+ci5pZCkpO3RoaXMuX3dlaWdodElkcz1bXS5jb25jYXQoLi4ubiksdGhpcy5fd2VpZ2h0TWFwPXR9c2V0IHJlc291cmNlTWFuYWdlcih0KXt0aGlzLl9yZXNvdXJjZU1hbmFnZXI9dH1nZXQgaW5wdXRzKCl7cmV0dXJuIHRoaXMuX2lucHV0cy5tYXAodD0+KHtuYW1lOnQubmFtZSxzaGFwZTp0LmF0dHJQYXJhbXMuc2hhcGU/dC5hdHRyUGFyYW1zLnNoYXBlLnZhbHVlOnZvaWQgMCxkdHlwZTp0LmF0dHJQYXJhbXMuZHR5cGU/dC5hdHRyUGFyYW1zLmR0eXBlLnZhbHVlOnZvaWQgMH0pKX1nZXQgb3V0cHV0cygpe3JldHVybiB0aGlzLl9vdXRwdXRzLm1hcCh0PT4oe25hbWU6dC5uYW1lLHNoYXBlOnQuYXR0clBhcmFtcy5zaGFwZT90LmF0dHJQYXJhbXMuc2hhcGUudmFsdWU6dm9pZCAwLGR0eXBlOnQuYXR0clBhcmFtcy5kdHlwZT90LmF0dHJQYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfSkpfWdldCBpbnB1dE5vZGVzKCl7cmV0dXJuIHRoaXMuX2lucHV0cy5tYXAodD0+dC5zaWduYXR1cmVLZXl8fHQubmFtZSl9Z2V0IG91dHB1dE5vZGVzKCl7cmV0dXJuIHRoaXMuX291dHB1dHMubWFwKHQ9PntsZXQgbj10LnNpZ25hdHVyZUtleXx8dC5uYW1lO3JldHVybiB0LmRlZmF1bHRPdXRwdXQ/YCR7bn06JHt0LmRlZmF1bHRPdXRwdXR9YDpufSl9Z2V0IGZ1bmN0aW9ucygpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLl9mdW5jdGlvbnMpLnJlZHVjZSgodCxuKT0+KHRbbl09dGhpcy5fZnVuY3Rpb25zW25dLnNpZ25hdHVyZSx0KSx7fSl9Y29uc3RydWN0b3IodCxuKXt0aGlzLmdyYXBoPXQsdGhpcy5wYXJlbnQ9bix0aGlzLmNvbXBpbGVkTWFwPW5ldyBNYXAsdGhpcy5wYXJzZU5vZGVOYW1lQ2FjaGU9bmV3IE1hcCx0aGlzLl93ZWlnaHRNYXA9e30sdGhpcy5TRVBBUkFUT1I9XCIsXCIsdGhpcy5fZnVuY3Rpb25zPXt9LHRoaXMuX2Z1bmN0aW9uRXhlY3V0b3JNYXA9e30sdGhpcy5rZWVwSW50ZXJtZWRpYXRlVGVuc29ycz0hMSx0aGlzLl9vdXRwdXRzPXQub3V0cHV0cyx0aGlzLl9pbnB1dHM9dC5pbnB1dHMsdGhpcy5faW5pdE5vZGVzPXQuaW5pdE5vZGVzLHRoaXMuX3NpZ25hdHVyZT10LnNpZ25hdHVyZSx0aGlzLl9mdW5jdGlvbnM9dC5mdW5jdGlvbnMsdC5mdW5jdGlvbnMhPW51bGwmJk9iamVjdC5rZXlzKHQuZnVuY3Rpb25zKS5mb3JFYWNoKGE9Pnt0aGlzLl9mdW5jdGlvbkV4ZWN1dG9yTWFwW2FdPW5ldyBvRSh0LmZ1bmN0aW9uc1thXSx0aGlzKX0pfWdldENvbXBpbGF0aW9uS2V5KHQsbil7bGV0IGE9dC5tYXAocz0+cy5uYW1lKS5zb3J0KCkscj1uLm1hcChzPT5zLm5hbWUpLnNvcnQoKTtyZXR1cm4gYS5qb2luKHRoaXMuU0VQQVJBVE9SKStcIi0tXCIrci5qb2luKHRoaXMuU0VQQVJBVE9SKX1jb21waWxlKHQsbil7bGV0IGE9SEkodCxuLHRoaXMud2VpZ2h0TWFwLHRoaXMuX2luaXROb2Rlcykse21pc3NpbmdJbnB1dHM6cixkeW5hbWljTm9kZTpzLHN5bmNJbnB1dHM6aX09YTtpZihzIT1udWxsKXRocm93IG5ldyBFcnJvcihgVGhpcyBleGVjdXRpb24gY29udGFpbnMgdGhlIG5vZGUgJyR7cy5uYW1lfScsIHdoaWNoIGhhcyB0aGUgZHluYW1pYyBvcCAnJHtzLm9wfScuIFBsZWFzZSB1c2UgbW9kZWwuZXhlY3V0ZUFzeW5jKCkgaW5zdGVhZC4gQWx0ZXJuYXRpdmVseSwgdG8gYXZvaWQgdGhlIGR5bmFtaWMgb3BzLCBzcGVjaWZ5IHRoZSBpbnB1dHMgWyR7aX1dYCk7aWYoci5sZW5ndGg+MCl7bGV0IHU9bi5tYXAoZD0+ZC5uYW1lKSxwPU9iamVjdC5rZXlzKHQpO3Rocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbXB1dGUgdGhlIG91dHB1dHMgWyR7dX1dIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0cyBbJHtwfV0uIE1pc3NpbmcgdGhlIGZvbGxvd2luZyBpbnB1dHM6IFske3J9XWApfWxldCBvPXU1KHRoaXMuZ3JhcGgsYSksbD1kNShvKTtyZXR1cm57b3JkZXJlZE5vZGVzOm8sbm9kZUxpdmVVbnRpbE1hcDpsfX1jbG9uZUFuZEtlZXBUZW5zb3IodCl7aWYodD09bnVsbClyZXR1cm4gbnVsbDtsZXQgbj10LmNsb25lKCk7cmV0dXJuIEh0KG4pLG59Y2xvbmVUZW5zb3JMaXN0KHQpe3JldHVybiB0P3QubWFwKG49PnRoaXMuY2xvbmVBbmRLZWVwVGVuc29yKG4pKTpudWxsfWNsb25lVGVuc29yTWFwKHQpe3JldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModCkubWFwKChbbixhXSk9PltuLHRoaXMuY2xvbmVUZW5zb3JMaXN0KGEpXSkpfWV4ZWN1dGUodCxuKXt0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JzKCksdD10aGlzLm1hcElucHV0cyh0KTtsZXQgYT1PYmplY3Qua2V5cyh0KS5zb3J0KCk7dGhpcy5jaGVja0lucHV0cyh0KSx0aGlzLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGUodCksbj10aGlzLm1hcE91dHB1dHMobiksdGhpcy5jaGVja091dHB1dHMobik7bGV0IHI9YS5tYXAoYz0+dGhpcy5ncmFwaC5ub2Rlc1tYbihjKVswXV0pLHM9bi5tYXAoYz0+WG4oYylbMF0pLGk9bmV3IFNldChzKSxvPXMubWFwKGM9PnRoaXMuZ3JhcGgubm9kZXNbY10pO28ubGVuZ3RoPT09MCYmKG89dGhpcy5fb3V0cHV0cyk7bGV0IGw9dGhpcy5nZXRDb21waWxhdGlvbktleShyLG8pLHU9dGhpcy5jb21waWxlZE1hcC5nZXQobCk7dT09bnVsbCYmKHU9dGhpcy5jb21waWxlKHQsbyksdGhpcy5jb21waWxlZE1hcC5zZXQobCx1KSk7dHJ5e3RoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnM9RygpLmdldEJvb2woXCJLRUVQX0lOVEVSTUVESUFURV9URU5TT1JTXCIpfWNhdGNoKGMpe3RoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnM9ITEsY29uc29sZS53YXJuKGMubWVzc2FnZSl9bGV0IHA9e30sZD17fTtyZXR1cm4gTygoKT0+e2xldCBjPW5ldyBHSSh0aGlzLndlaWdodE1hcCxwLGQsdGhpcy5mdW5jdGlvbkV4ZWN1dG9yTWFwLHRoaXMucGFyc2VOb2RlTmFtZUNhY2hlKSxoPU9iamVjdC5hc3NpZ24oe30sdGhpcy53ZWlnaHRNYXApO3RoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnMmJih0aGlzLmNsb25lZFRlbnNvcnNNYXA9dGhpcy5jbG9uZVRlbnNvck1hcCh0aGlzLndlaWdodE1hcCkpLE9iamVjdC5rZXlzKHQpLmZvckVhY2goYj0+e2xldFt5LHhdPVhuKGIsYyksdj1bXTt2W3hdPXRbYl0saFt5XT12LHRoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnMmJih0aGlzLmNsb25lZFRlbnNvcnNNYXBbeV09dGhpcy5jbG9uZVRlbnNvckxpc3QodikpfSk7bGV0IG09dGhpcy5nZXRGcm96ZW5UZW5zb3JJZHMoaCkse29yZGVyZWROb2RlczpmLG5vZGVMaXZlVW50aWxNYXA6Z309dTtmb3IobGV0IGIgb2YgZil7aWYoaFtiLm5hbWVdKWNvbnRpbnVlO2xldCB5PVVJKGIsaCxjLHRoaXMuX3Jlc291cmNlTWFuYWdlcik7aWYody5pc1Byb21pc2UoeSkpdGhyb3cgbmV3IEVycm9yKGBUaGUgZXhlY3V0aW9uIG9mIHRoZSBvcCAnJHtiLm9wfScgcmV0dXJuZWQgYSBwcm9taXNlLiBQbGVhc2UgdXNlIG1vZGVsLmV4ZWN1dGVBc3luYygpIGluc3RlYWQuYCk7aFtiLm5hbWVdPXksdGhpcy5rZWVwSW50ZXJtZWRpYXRlVGVuc29ycyYmKHRoaXMuY2xvbmVkVGVuc29yc01hcFtiLm5hbWVdPXRoaXMuY2xvbmVUZW5zb3JMaXN0KHkpKSx0aGlzLmNoZWNrVGVuc29yRm9yRGlzcG9zYWxXaXRoTm9kZUxpdmVVbnRpbEluZm8oYixoLGMsbSxpLGcuZ2V0KGIubmFtZSkpfXJldHVybiB0aGlzLnBhcmVudD09bnVsbCYmYy5kaXNwb3NlKG0pLG4ubWFwKGI9PnBuKGIsaCxjKSl9KX1nZXRGcm96ZW5UZW5zb3JJZHModCl7bGV0IG49W10uY29uY2F0LmFwcGx5KFtdLE9iamVjdC5rZXlzKHQpLm1hcChhPT50W2FdKS5tYXAoYT0+YS5tYXAocj0+ci5pZCkpKTtyZXR1cm4gbmV3IFNldChuKX1jaGVja1RlbnNvckZvckRpc3Bvc2FsKHQsbixhLHIscyxpLG8pe2lmKCEoUXMobil8fGkuaGFzKHQpKSl7Zm9yKGxldCBsIG9mIGFbdF0pbCE9bnVsbCYmKG9bbC5pZF09KG9bbC5pZF18fDApK24uY2hpbGRyZW4ubGVuZ3RoKTtmb3IobGV0IGwgb2Ygbi5pbnB1dHMpe2lmKFFzKGwpKWNvbnRpbnVlO2xldCB1PUxJKGwubmFtZSxhLHIpO2lmKHUhPW51bGwpZm9yKGxldCBwIG9mIHUpe2lmKCFwfHxwLmtlcHR8fHMuaGFzKHAuaWQpKWNvbnRpbnVlO2xldCBkPW9bcC5pZF07ZD09PTE/KHAuZGlzcG9zZSgpLGRlbGV0ZSBvW3AuaWRdKTpkIT1udWxsJiZvW3AuaWRdLS19fX19Y2hlY2tUZW5zb3JGb3JEaXNwb3NhbFdpdGhOb2RlTGl2ZVVudGlsSW5mbyh0LG4sYSxyLHMsaSl7ZnVuY3Rpb24gbyhsKXtyZXR1cm4gUXMobCl8fHMuaGFzKGwubmFtZSl9aWYoIShRcyh0KXx8aT09bnVsbCkpZm9yKGxldCBsIG9mIGkpe2lmKG8obCkpY29udGludWU7bGV0IHU9TEkobC5uYW1lLG4sYSk7Zm9yKGxldCBwIG9mIHUpIXB8fHAua2VwdHx8ci5oYXMocC5pZCl8fHAuZGlzcG9zZSgpfX1hc3luYyBleGVjdXRlQXN5bmModCxuKXtyZXR1cm4gdGhpcy5fZXhlY3V0ZUFzeW5jKHQsbil9ZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvcnMoKXt0aGlzLmNsb25lZFRlbnNvcnNNYXAmJihPYmplY3QudmFsdWVzKHRoaXMuY2xvbmVkVGVuc29yc01hcCkuZm9yRWFjaCh0PT57Zm9yKGxldCBuIG9mIHQpbiYmIW4uaXNEaXNwb3NlZCYmbi5kaXNwb3NlKCl9KSx0aGlzLmNsb25lZFRlbnNvcnNNYXA9bnVsbCl9Z2V0SW50ZXJtZWRpYXRlVGVuc29ycygpe3JldHVybiB0aGlzLmNsb25lZFRlbnNvcnNNYXB9YXN5bmMgX2V4ZWN1dGVBc3luYyh0LG4sYT0hMSxyPXt9LHM9e30pe3RoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvcnMoKSxhfHwodD10aGlzLm1hcElucHV0cyh0KSx0aGlzLmNoZWNrSW5wdXRzKHQpLHRoaXMuY2hlY2tJbnB1dFNoYXBlQW5kVHlwZSh0KSxuPXRoaXMubWFwT3V0cHV0cyhuKSx0aGlzLmNoZWNrT3V0cHV0cyhuKSk7dHJ5e3RoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnM9RygpLmdldEJvb2woXCJLRUVQX0lOVEVSTUVESUFURV9URU5TT1JTXCIpfWNhdGNoKGMpe3RoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnM9ITEsY29uc29sZS53YXJuKGMubWVzc2FnZSl9bGV0IGk9bmV3IEdJKHRoaXMud2VpZ2h0TWFwLHIscyx0aGlzLmZ1bmN0aW9uRXhlY3V0b3JNYXAsdGhpcy5wYXJzZU5vZGVOYW1lQ2FjaGUpO3RoaXMua2VlcEludGVybWVkaWF0ZVRlbnNvcnMmJih0aGlzLmNsb25lZFRlbnNvcnNNYXA9dGhpcy5jbG9uZVRlbnNvck1hcCh0aGlzLndlaWdodE1hcCkpO2xldCBvPWF3YWl0IHRoaXMuZXhlY3V0ZVdpdGhDb250cm9sRmxvdyh0LGksbixhKSxsPW4ubWFwKGM9PnBuKGMsbyxpKSksdT1sLm1hcChjPT5jLmlkKSxwPU9iamVjdC5rZXlzKHQpLm1hcChjPT50W2NdLmlkKSxkPW5ldyBTZXQoWy4uLnUsLi4ucCwuLi50aGlzLndlaWdodElkc10pO3JldHVybiBPYmplY3QudmFsdWVzKG8pLmZvckVhY2goYz0+e2MuZm9yRWFjaChoPT57aCYmIWguaXNEaXNwb3NlZCYmIWQuaGFzKGguaWQpJiZoLmRpc3Bvc2UoKX0pfSksdGhpcy5wYXJlbnQ9PW51bGwmJmkuZGlzcG9zZShkKSxsfWFzeW5jIGV4ZWN1dGVGdW5jdGlvbkFzeW5jKHQsbixhKXtsZXQgcj10LnJlZHVjZSgocyxpLG8pPT4oc1t0aGlzLmlucHV0c1tvXS5uYW1lXT1pLHMpLHt9KTtyZXR1cm4gdGhpcy5fZXhlY3V0ZUFzeW5jKHIsdGhpcy5vdXRwdXROb2RlcywhMCxuLGEpfWFzeW5jIGV4ZWN1dGVXaXRoQ29udHJvbEZsb3codCxuLGEscil7bGV0IHM9T2JqZWN0LmtleXModCksaT1zLm1hcCh2PT50aGlzLmdyYXBoLm5vZGVzW1huKHYpWzBdXSksbz1hLm1hcCh2PT5Ybih2KVswXSksbD1uZXcgU2V0KG8pLHU9by5tYXAodj0+dGhpcy5ncmFwaC5ub2Rlc1t2XSk7dS5sZW5ndGg9PT0wJiYodT10aGlzLl9vdXRwdXRzKTtsZXR7dXNlZE5vZGVzOnAsbWlzc2luZ0lucHV0czpkLGR5bmFtaWNOb2RlOmMsc3luY0lucHV0czpofT1ISSh0LHUsdGhpcy53ZWlnaHRNYXAsdGhpcy5faW5pdE5vZGVzKSxtPVsuLi5pLC4uLnRoaXMuZ3JhcGgud2VpZ2h0cywuLi50aGlzLl9pbml0Tm9kZXN8fFtdXS5tYXAodj0+KHtub2RlOnYsY29udGV4dHM6bi5jdXJyZW50Q29udGV4dH0pKSxmPU9iamVjdC5hc3NpZ24oe30sdGhpcy53ZWlnaHRNYXApO09iamVjdC5rZXlzKHQpLmZvckVhY2godj0+e2xldFtJLE5dPVhuKHYpLEM9W107Q1tOXT10W3ZdLGZbSV09Q30pO2xldCBnPXt9LGI9dGhpcy5nZXRGcm96ZW5UZW5zb3JJZHMoZikseT17fTtmb3IoO20ubGVuZ3RoPjA7KXtsZXQgdj10aGlzLnByb2Nlc3NTdGFjayhpLG0sbixmLHksYixsLGcscCk7YXdhaXQgUHJvbWlzZS5hbGwodil9Yz09bnVsbCYmIXImJmNvbnNvbGUud2FybihcIlRoaXMgbW9kZWwgZXhlY3V0aW9uIGRpZCBub3QgY29udGFpbiBhbnkgbm9kZXMgd2l0aCBjb250cm9sIGZsb3cgb3IgZHluYW1pYyBvdXRwdXQgc2hhcGVzLiBZb3UgY2FuIHVzZSBtb2RlbC5leGVjdXRlKCkgaW5zdGVhZC5cIik7bGV0IHg9dS5maWx0ZXIodj0+IVFzKHYpJiYhcG4odi5uYW1lLGYsbikpLm1hcCh2PT52Lm5hbWUpO2lmKHgubGVuZ3RoPjApe2xldCB2PVwiXCI7dGhyb3cgYyE9bnVsbCYmKHY9YEFsdGVybmF0aXZlbHksIHRvIGF2b2lkIHRoZSBkeW5hbWljIG9wcywgdXNlIG1vZGVsLmV4ZWN1dGUoKSBhbmQgc3BlY2lmeSB0aGUgaW5wdXRzIFske2h9XWApLG5ldyBFcnJvcihgQ2Fubm90IGNvbXB1dGUgdGhlIG91dHB1dHMgWyR7eH1dIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0cyBbJHtzfV0uIENvbnNpZGVyIHByb3ZpZGluZyB0aGUgZm9sbG93aW5nIGlucHV0czogWyR7ZH1dLiAke3Z9YCl9cmV0dXJuIGZ9cHJvY2Vzc1N0YWNrKHQsbixhLHIscyxpLG8sbCx1KXtsZXQgcD1bXTtmb3IoO24ubGVuZ3RoPjA7KXtsZXQgZD1uLnBvcCgpO2EuY3VycmVudENvbnRleHQ9ZC5jb250ZXh0cztsZXQgYz1cIlwiO2lmKGQubm9kZS5vcD09PVwiRW50ZXJcIiYmayhcImlzQ29uc3RhbnRcIixkLm5vZGUscixhKSYmKFtjXT1TcihkLm5vZGUubmFtZSxhKSkscltkLm5vZGUubmFtZV09PW51bGwpe2xldCBoPVVJKGQubm9kZSxyLGEsdGhpcy5fcmVzb3VyY2VNYW5hZ2VyKTtjfHwoW2NdPVNyKGQubm9kZS5uYW1lLGEpKTtsZXQgbT1hLmN1cnJlbnRDb250ZXh0O3cuaXNQcm9taXNlKGgpP3AucHVzaChoLnRoZW4oZj0+KHJbY109Zix0aGlzLmtlZXBJbnRlcm1lZGlhdGVUZW5zb3JzJiYodGhpcy5jbG9uZWRUZW5zb3JzTWFwW2NdPXRoaXMuY2xvbmVUZW5zb3JMaXN0KGYpKSxhLmN1cnJlbnRDb250ZXh0PW0sdGhpcy5jaGVja1RlbnNvckZvckRpc3Bvc2FsKGMsZC5ub2RlLHIsYSxpLG8sbCksdGhpcy5wcm9jZXNzQ2hpbGROb2RlcyhkLm5vZGUsbixhLHIscyx1KSxmKSkpOihyW2NdPWgsdGhpcy5rZWVwSW50ZXJtZWRpYXRlVGVuc29ycyYmKHRoaXMuY2xvbmVkVGVuc29yc01hcFtjXT10aGlzLmNsb25lVGVuc29yTGlzdChoKSksdGhpcy5jaGVja1RlbnNvckZvckRpc3Bvc2FsKGMsZC5ub2RlLHIsYSxpLG8sbCksdGhpcy5wcm9jZXNzQ2hpbGROb2RlcyhkLm5vZGUsbixhLHIscyx1KSl9ZWxzZSB0aGlzLnByb2Nlc3NDaGlsZE5vZGVzKGQubm9kZSxuLGEscixzLHUpfXJldHVybiBwfXByb2Nlc3NDaGlsZE5vZGVzKHQsbixhLHIscyxpKXt0LmNoaWxkcmVuLmZvckVhY2gobz0+e2xldFtsXT1TcihvLm5hbWUsYSk7c1tsXXx8IWkuaGFzKG8ubmFtZSl8fChvLm9wPT09XCJNZXJnZVwiP28uaW5wdXROYW1lcy5zb21lKHU9PiEhcG4odSxyLGEpKSYmKHNbbF09ITAsbi5wdXNoKHtjb250ZXh0czphLmN1cnJlbnRDb250ZXh0LG5vZGU6b30pKTpvLmlucHV0TmFtZXMuZXZlcnkodT0+ISFwbih1LHIsYSkpJiYoc1tsXT0hMCxuLnB1c2goe2NvbnRleHRzOmEuY3VycmVudENvbnRleHQsbm9kZTpvfSkpKX0pfWRpc3Bvc2UoKXtPYmplY3Qua2V5cyh0aGlzLndlaWdodE1hcCkuZm9yRWFjaCh0PT50aGlzLndlaWdodE1hcFt0XS5mb3JFYWNoKG49Pm4uZGlzcG9zZSgpKSl9Y2hlY2tJbnB1dFNoYXBlQW5kVHlwZSh0KXtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKG49PntsZXQgYT10W25dLFtyXT1YbihuKSxzPXRoaXMuZ3JhcGgubm9kZXNbcl07aWYocy5hdHRyUGFyYW1zLnNoYXBlJiZzLmF0dHJQYXJhbXMuc2hhcGUudmFsdWUpe2xldCBpPXMuYXR0clBhcmFtcy5zaGFwZS52YWx1ZSxvPWkubGVuZ3RoPT09YS5zaGFwZS5sZW5ndGgmJmEuc2hhcGUuZXZlcnkoKGwsdSk9PmlbdV09PT0tMXx8aVt1XT09PWwpO3cuYXNzZXJ0KG8sKCk9PmBUaGUgc2hhcGUgb2YgZGljdFsnJHtzLm5hbWV9J10gcHJvdmlkZWQgaW4gbW9kZWwuZXhlY3V0ZShkaWN0KSBtdXN0IGJlIFske2l9XSwgYnV0IHdhcyBbJHthLnNoYXBlfV1gKX1zLmF0dHJQYXJhbXMuZHR5cGUmJnMuYXR0clBhcmFtcy5kdHlwZS52YWx1ZSYmdy5hc3NlcnQoYS5kdHlwZT09PXMuYXR0clBhcmFtcy5kdHlwZS52YWx1ZSwoKT0+YFRoZSBkdHlwZSBvZiBkaWN0Wycke3MubmFtZX0nXSBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIG11c3QgYmUgJHtzLmF0dHJQYXJhbXMuZHR5cGUudmFsdWV9LCBidXQgd2FzICR7YS5kdHlwZX1gKX0pfW1hcElucHV0cyh0KXt2YXIgbixhO2xldCByPXt9O2ZvcihsZXQgcyBpbiB0KXtsZXQgaT0oYT0obj10aGlzLl9zaWduYXR1cmUpPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5pbnB1dHMpPT09bnVsbHx8YT09PXZvaWQgMD92b2lkIDA6YVtzXTtpIT1udWxsP3JbaS5uYW1lXT10W3NdOnJbc109dFtzXX1yZXR1cm4gcn1jaGVja0lucHV0cyh0KXtsZXQgbj1PYmplY3Qua2V5cyh0KS5maWx0ZXIoYT0+e2xldFtyXT1YbihhKTtyZXR1cm4gdGhpcy5ncmFwaC5ub2Rlc1tyXT09bnVsbH0pO2lmKG4ubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKGBUaGUgZGljdCBwcm92aWRlZCBpbiBtb2RlbC5leGVjdXRlKGRpY3QpIGhhcyBrZXlzOiBbJHtufV0gdGhhdCBhcmUgbm90IHBhcnQgb2YgZ3JhcGhgKX1tYXBPdXRwdXRzKHQpe3JldHVybiB0Lm1hcChuPT57dmFyIGEscjtsZXQgcz0ocj0oYT10aGlzLl9zaWduYXR1cmUpPT09bnVsbHx8YT09PXZvaWQgMD92b2lkIDA6YS5vdXRwdXRzKT09PW51bGx8fHI9PT12b2lkIDA/dm9pZCAwOnJbbl07cmV0dXJuIHMhPW51bGw/cy5uYW1lOm59LHt9KX1jaGVja091dHB1dHModCl7dC5mb3JFYWNoKG49PntsZXRbYV09WG4obik7aWYoIXRoaXMuZ3JhcGgubm9kZXNbYV0pdGhyb3cgbmV3IEVycm9yKGBUaGUgb3V0cHV0ICcke259JyBpcyBub3QgZm91bmQgaW4gdGhlIGdyYXBoYCl9KX19LHk1PWNsYXNze2NvbnN0cnVjdG9yKGU9e30sdD17fSl7dGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGU9ZSx0aGlzLmhhc2hUYWJsZU1hcD10fWFkZEhhc2hUYWJsZShlLHQpe3RoaXMuaGFzaFRhYmxlTmFtZVRvSGFuZGxlW2VdPXQuaGFuZGxlLHRoaXMuaGFzaFRhYmxlTWFwW3QuaWRdPXR9Z2V0SGFzaFRhYmxlSGFuZGxlQnlOYW1lKGUpe3JldHVybiB0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZVtlXX1nZXRIYXNoVGFibGVCeUlkKGUpe3JldHVybiB0aGlzLmhhc2hUYWJsZU1hcFtlXX1kaXNwb3NlKCl7Zm9yKGxldCBlIGluIHRoaXMuaGFzaFRhYmxlTWFwKXRoaXMuaGFzaFRhYmxlTWFwW2VdLmNsZWFyQW5kQ2xvc2UoKSxkZWxldGUgdGhpcy5oYXNoVGFibGVNYXBbZV07Zm9yKGxldCBlIGluIHRoaXMuaGFzaFRhYmxlTmFtZVRvSGFuZGxlKXRoaXMuaGFzaFRhYmxlTmFtZVRvSGFuZGxlW2VdLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGVbZV19fSx4NT1cIj90ZmpzLWZvcm1hdD1maWxlXCIsdjU9XCJtb2RlbC5qc29uXCIsRjE9Y2xhc3N7Z2V0IG1vZGVsVmVyc2lvbigpe3JldHVybiB0aGlzLnZlcnNpb259Z2V0IGlucHV0Tm9kZXMoKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dE5vZGVzfWdldCBvdXRwdXROb2Rlcygpe3JldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dE5vZGVzfWdldCBpbnB1dHMoKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dHN9Z2V0IG91dHB1dHMoKXtyZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXRzfWdldCB3ZWlnaHRzKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwfWdldCBtZXRhZGF0YSgpe3JldHVybiB0aGlzLmFydGlmYWN0cy51c2VyRGVmaW5lZE1ldGFkYXRhfWdldCBtb2RlbFNpZ25hdHVyZSgpe3JldHVybiB0aGlzLnNpZ25hdHVyZX1nZXQgbW9kZWxTdHJ1Y3R1cmVkT3V0cHV0S2V5cygpe3JldHVybiB0aGlzLnN0cnVjdHVyZWRPdXRwdXRLZXlzfWNvbnN0cnVjdG9yKGUsdD17fSxuPWp0KXt0aGlzLm1vZGVsVXJsPWUsdGhpcy5sb2FkT3B0aW9ucz10LHRoaXMudmVyc2lvbj1cIm4vYVwiLHRoaXMuaW89bix0PT1udWxsJiYodGhpcy5sb2FkT3B0aW9ucz17fSksdGhpcy5yZXNvdXJjZU1hbmFnZXI9bmV3IHk1fWZpbmRJT0hhbmRsZXIoKXtsZXQgZT10aGlzLm1vZGVsVXJsO2lmKGUubG9hZCE9bnVsbCl0aGlzLmhhbmRsZXI9ZTtlbHNlIGlmKHRoaXMubG9hZE9wdGlvbnMucmVxdWVzdEluaXQhPW51bGwpdGhpcy5oYW5kbGVyPXRoaXMuaW8uYnJvd3NlckhUVFBSZXF1ZXN0KGUsdGhpcy5sb2FkT3B0aW9ucyk7ZWxzZXtsZXQgdD10aGlzLmlvLmdldExvYWRIYW5kbGVycyhlLHRoaXMubG9hZE9wdGlvbnMpO2lmKHQubGVuZ3RoPT09MCl0LnB1c2godGhpcy5pby5icm93c2VySFRUUFJlcXVlc3QoZSx0aGlzLmxvYWRPcHRpb25zKSk7ZWxzZSBpZih0Lmxlbmd0aD4xKXRocm93IG5ldyBFcnJvcihgRm91bmQgbW9yZSB0aGFuIG9uZSAoJHt0Lmxlbmd0aH0pIGxvYWQgaGFuZGxlcnMgZm9yIFVSTCAnJHtbZV19J2ApO3RoaXMuaGFuZGxlcj10WzBdfX1sb2FkKCl7aWYodGhpcy5maW5kSU9IYW5kbGVyKCksdGhpcy5oYW5kbGVyLmxvYWQ9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHByb2NlZWQgd2l0aCBtb2RlbCBsb2FkaW5nIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgbG9hZGAgbWV0aG9kIGltcGxlbWVudGVkLlwiKTtsZXQgZT10aGlzLmhhbmRsZXIubG9hZCgpO3JldHVybiB3LmlzUHJvbWlzZShlKT9lLnRoZW4odD0+dC5nZXRXZWlnaHRTdHJlYW09PW51bGw/dGhpcy5sb2FkU3luYyh0KTp0aGlzLmxvYWRTdHJlYW1pbmcodCkpOnRoaXMubG9hZFN5bmMoZSl9bG9hZFN5bmMoZSl7bGV0IHQ9dGhpcy5pby5kZWNvZGVXZWlnaHRzKGUud2VpZ2h0RGF0YSxlLndlaWdodFNwZWNzKTtyZXR1cm4gdGhpcy5sb2FkV2l0aFdlaWdodE1hcChlLHQpfWFzeW5jIGxvYWRTdHJlYW1pbmcoZSl7aWYoZS5nZXRXZWlnaHRTdHJlYW09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgYXJ0aWZhY3RzIG1pc3Npbmcgc3RyZWFtV2VpZ2h0cyBmdW5jdGlvblwiKTtsZXQgdD1hd2FpdCBwTihlLmdldFdlaWdodFN0cmVhbSgpLGUud2VpZ2h0U3BlY3MpO3JldHVybiB0aGlzLmxvYWRXaXRoV2VpZ2h0TWFwKGUsdCl9bG9hZFdpdGhXZWlnaHRNYXAoZSx0KXt0aGlzLmFydGlmYWN0cz1lO2xldCBuPXRoaXMuYXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3ksYT10aGlzLmFydGlmYWN0cy5zaWduYXR1cmU7aWYodGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSE9bnVsbCl7bGV0IHI9dGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YTtyLnNpZ25hdHVyZSE9bnVsbCYmKGE9ci5zaWduYXR1cmUpLHIuc3RydWN0dXJlZE91dHB1dEtleXMhPW51bGwmJih0aGlzLnN0cnVjdHVyZWRPdXRwdXRLZXlzPXIuc3RydWN0dXJlZE91dHB1dEtleXMpfWlmKHRoaXMuc2lnbmF0dXJlPWEsdGhpcy52ZXJzaW9uPWAke24udmVyc2lvbnMucHJvZHVjZXJ9LiR7bi52ZXJzaW9ucy5taW5Db25zdW1lcn1gLHRoaXMuZXhlY3V0b3I9bmV3IGpJKHpJLkluc3RhbmNlLnRyYW5zZm9ybUdyYXBoKG4sdGhpcy5zaWduYXR1cmUpKSx0aGlzLmV4ZWN1dG9yLndlaWdodE1hcD10aGlzLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAodCksdGhpcy5leGVjdXRvci5yZXNvdXJjZU1hbmFnZXI9dGhpcy5yZXNvdXJjZU1hbmFnZXIsZS5tb2RlbEluaXRpYWxpemVyIT1udWxsJiZlLm1vZGVsSW5pdGlhbGl6ZXIubm9kZSE9bnVsbCl7bGV0IHI9ekkuSW5zdGFuY2UudHJhbnNmb3JtR3JhcGgoZS5tb2RlbEluaXRpYWxpemVyKTt0aGlzLmluaXRpYWxpemVyPW5ldyBqSShyKSx0aGlzLmluaXRpYWxpemVyLndlaWdodE1hcD10aGlzLmV4ZWN1dG9yLndlaWdodE1hcCx0aGlzLmluaXRpYWxpemVyLnJlc291cmNlTWFuYWdlcj10aGlzLnJlc291cmNlTWFuYWdlcix0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlPWUuaW5pdGlhbGl6ZXJTaWduYXR1cmV9cmV0dXJuITB9YXN5bmMgc2F2ZShlLHQpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgbj10aGlzLmlvLmdldFNhdmVIYW5kbGVycyhlKTtpZihuLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICcke2V9J2ApO2lmKG4ubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBtb3JlIHRoYW4gb25lICgke24ubGVuZ3RofSkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICcke2V9J2ApO2U9blswXX1pZihlLnNhdmU9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiR3JhcGhNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBzYXZlYCBhdHRyaWJ1dGUgZGVmaW5lZC5cIik7cmV0dXJuIGUuc2F2ZSh0aGlzLmFydGlmYWN0cyl9YWRkU3RydWN0dXJlZE91dHB1dE5hbWVzKGUpe2lmKHRoaXMuc3RydWN0dXJlZE91dHB1dEtleXMpe2xldCB0PWUgaW5zdGFuY2VvZiBDZT9bZV06ZSxuPXt9O3JldHVybiB0LmZvckVhY2goKGEscik9Pm5bdGhpcy5zdHJ1Y3R1cmVkT3V0cHV0S2V5c1tyXV09YSksbn1yZXR1cm4gZX1wcmVkaWN0KGUsdCl7bGV0IG49dGhpcy5leGVjdXRlKGUsdGhpcy5vdXRwdXROb2Rlcyk7cmV0dXJuIHRoaXMuYWRkU3RydWN0dXJlZE91dHB1dE5hbWVzKG4pfWFzeW5jIHByZWRpY3RBc3luYyhlLHQpe2xldCBuPWF3YWl0IHRoaXMuZXhlY3V0ZUFzeW5jKGUsdGhpcy5vdXRwdXROb2Rlcyk7cmV0dXJuIHRoaXMuYWRkU3RydWN0dXJlZE91dHB1dE5hbWVzKG4pfW5vcm1hbGl6ZUlucHV0cyhlKXt2YXIgdDtpZighKGUgaW5zdGFuY2VvZiBDZSkmJiFBcnJheS5pc0FycmF5KGUpKXtsZXQgcj0odD10aGlzLnNpZ25hdHVyZSk9PT1udWxsfHx0PT09dm9pZCAwP3ZvaWQgMDp0LmlucHV0cztpZihyIT1udWxsKWZvcihsZXQgcyBpbiByKXtsZXQgaT1yW3NdO2kucmVzb3VyY2VJZCE9bnVsbCYmKGVbc109dGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0W2kucmVzb3VyY2VJZF0pfXJldHVybiBlfWU9QXJyYXkuaXNBcnJheShlKT9lOltlXTtsZXQgbj1PYmplY3Qua2V5cyh0aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXQpLmxlbmd0aDtpZihlLmxlbmd0aCtuIT09dGhpcy5pbnB1dE5vZGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHRlbnNvciBjb3VudCBtaXNtYXRjaCwgdGhlIGdyYXBoIG1vZGVsIGhhcyAke3RoaXMuaW5wdXROb2Rlcy5sZW5ndGgtbn0gbm9uLXJlc291cmNlIHBsYWNlaG9sZGVycywgd2hpbGUgdGhlcmUgYXJlICR7ZS5sZW5ndGh9IGlucHV0IHRlbnNvcnMgcHJvdmlkZWQuYCk7bGV0IGE9MDtyZXR1cm4gdGhpcy5pbnB1dE5vZGVzLnJlZHVjZSgocixzKT0+e3ZhciBpLG8sbDtsZXQgdT0obD0obz0oaT10aGlzLnNpZ25hdHVyZSk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLmlucHV0cyk9PT1udWxsfHxvPT09dm9pZCAwP3ZvaWQgMDpvW3NdKT09PW51bGx8fGw9PT12b2lkIDA/dm9pZCAwOmwucmVzb3VyY2VJZDtyZXR1cm4gdSE9bnVsbD9yW3NdPXRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dFt1XTpyW3NdPWVbYSsrXSxyfSx7fSl9bm9ybWFsaXplT3V0cHV0cyhlKXtyZXR1cm4gZT1lfHx0aGlzLm91dHB1dE5vZGVzLEFycmF5LmlzQXJyYXkoZSk/ZTpbZV19ZXhlY3V0ZUluaXRpYWxpemVyR3JhcGgoKXtyZXR1cm4gdGhpcy5pbml0aWFsaXplcj09bnVsbD9bXTp0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlPT1udWxsP3RoaXMuaW5pdGlhbGl6ZXIuZXhlY3V0ZSh7fSxbXSk6dGhpcy5pbml0aWFsaXplci5leGVjdXRlKHt9LE9iamVjdC5rZXlzKHRoaXMuaW5pdGlhbGl6ZXJTaWduYXR1cmUub3V0cHV0cykpfWFzeW5jIGV4ZWN1dGVJbml0aWFsaXplckdyYXBoQXN5bmMoKXtyZXR1cm4gdGhpcy5pbml0aWFsaXplcj09bnVsbD9bXTp0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlPT1udWxsP3RoaXMuaW5pdGlhbGl6ZXIuZXhlY3V0ZUFzeW5jKHt9LFtdKTp0aGlzLmluaXRpYWxpemVyLmV4ZWN1dGVBc3luYyh7fSxPYmplY3Qua2V5cyh0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlLm91dHB1dHMpKX1zZXRSZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0KGUpe2lmKHRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dD17fSx0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlKXtsZXQgdD10aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlLm91dHB1dHMsbj1PYmplY3Qua2V5cyh0KTtmb3IobGV0IGE9MDthPG4ubGVuZ3RoO2ErKyl7bGV0IHI9blthXSxzPXRbcl07dGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0W3MucmVzb3VyY2VJZF09ZVthXX19fWV4ZWN1dGUoZSx0KXt0aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXQ9PW51bGwmJnRoaXMuc2V0UmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dCh0aGlzLmV4ZWN1dGVJbml0aWFsaXplckdyYXBoKCkpLGU9dGhpcy5ub3JtYWxpemVJbnB1dHMoZSksdD10aGlzLm5vcm1hbGl6ZU91dHB1dHModCk7bGV0IG49dGhpcy5leGVjdXRvci5leGVjdXRlKGUsdCk7cmV0dXJuIG4ubGVuZ3RoPjE/bjpuWzBdfWFzeW5jIGV4ZWN1dGVBc3luYyhlLHQpe3RoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dD09bnVsbCYmdGhpcy5zZXRSZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0KGF3YWl0IHRoaXMuZXhlY3V0ZUluaXRpYWxpemVyR3JhcGhBc3luYygpKSxlPXRoaXMubm9ybWFsaXplSW5wdXRzKGUpLHQ9dGhpcy5ub3JtYWxpemVPdXRwdXRzKHQpO2xldCBuPWF3YWl0IHRoaXMuZXhlY3V0b3IuZXhlY3V0ZUFzeW5jKGUsdCk7cmV0dXJuIG4ubGVuZ3RoPjE/bjpuWzBdfWdldEludGVybWVkaWF0ZVRlbnNvcnMoKXtyZXR1cm4gdGhpcy5leGVjdXRvci5nZXRJbnRlcm1lZGlhdGVUZW5zb3JzKCl9ZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvcnMoKXt0aGlzLmV4ZWN1dG9yLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JzKCl9Y29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChlKXtyZXR1cm4gT2JqZWN0LmtleXMoZSkucmVkdWNlKCh0LG4pPT4odFtuXT1bZVtuXV0sdCkse30pfWRpc3Bvc2UoKXt0aGlzLmV4ZWN1dG9yLmRpc3Bvc2UoKSx0aGlzLmluaXRpYWxpemVyJiYodGhpcy5pbml0aWFsaXplci5kaXNwb3NlKCksdGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0JiZFZSh0aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXQpKSx0aGlzLnJlc291cmNlTWFuYWdlci5kaXNwb3NlKCl9fTthc3luYyBmdW5jdGlvbiB3NShlLHQ9e30sbj1qdCl7aWYoZT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbFVybCBpbiBsb2FkR3JhcGhNb2RlbCgpIGNhbm5vdCBiZSBudWxsLiBQbGVhc2UgcHJvdmlkZSBhIHVybCBvciBhbiBJT0hhbmRsZXIgdGhhdCBsb2FkcyB0aGUgbW9kZWxcIik7dD09bnVsbCYmKHQ9e30pLHQuZnJvbVRGSHViJiZ0eXBlb2YgZT09XCJzdHJpbmdcIiYmKGU9STUoZSkpO2xldCBhPW5ldyBGMShlLHQsbik7cmV0dXJuIGF3YWl0IGEubG9hZCgpLGF9ZnVuY3Rpb24gazUoZSl7aWYoZT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbFVybCBpbiBsb2FkR3JhcGhNb2RlbFN5bmMoKSBjYW5ub3QgYmUgbnVsbC4gUGxlYXNlIHByb3ZpZGUgbW9kZWwgYXJ0aWZhY3RzIG9yIGFuIElPSGFuZGxlciB0aGF0IGxvYWRzIHRoZSBtb2RlbFwiKTtsZXQgdDtpZihlIGluc3RhbmNlb2YgQXJyYXkpe2xldFthLHJdPWU7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwibW9kZWxKU09OIG11c3QgYmUgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5XCIpO2lmKCFyfHwhKHIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpdGhyb3cgbmV3IEVycm9yKFwiQW4gQXJyYXlCdWZmZXIgb2Ygd2VpZ2h0cyBtdXN0IGJlIHRoZSBzZWNvbmQgZWxlbWVudCBvZiB0aGUgYXJyYXlcIik7aWYoIShcIm1vZGVsVG9wb2xvZ3lcImluIGEpKXRocm93IG5ldyBFcnJvcihcIk1vZGVsIEpTT04gaXMgbWlzc2luZyAnbW9kZWxUb3BvbG9neSdcIik7aWYoIShcIndlaWdodHNNYW5pZmVzdFwiaW4gYSkpdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgSlNPTiBpcyBtaXNzaW5nICd3ZWlnaHRzTWFuaWZlc3QnXCIpO2xldCBzPWp0LmdldFdlaWdodFNwZWNzKGEud2VpZ2h0c01hbmlmZXN0KSxpPWp0LmdldE1vZGVsQXJ0aWZhY3RzRm9ySlNPTlN5bmMoYSxzLHIpO3Q9anQuZnJvbU1lbW9yeVN5bmMoaSl9ZWxzZSBpZihcImxvYWRcImluIGUpdD1lO2Vsc2UgaWYoXCJtb2RlbFRvcG9sb2d5XCJpbiBlJiZcIndlaWdodFNwZWNzXCJpbiBlJiZcIndlaWdodERhdGFcImluIGUpdD1qdC5mcm9tTWVtb3J5U3luYyhlKTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZWwgZm9ybWF0XCIpO2xldCBuPW5ldyBGMSh0KTtyZXR1cm4gbi5sb2FkKCksbn1mdW5jdGlvbiBJNShlKXtyZXR1cm4gZS5lbmRzV2l0aChcIi9cIil8fChlPWUrXCIvXCIpLGAke2V9JHt2NX0ke3g1fWB9dmFyIFM1PVwiNC4yMi4wXCIsbEU9e307X2UobEUse0NTVkRhdGFzZXQ6KCk9PnhFLERhdGFzZXQ6KCk9PmlwLEZpbGVEYXRhU291cmNlOigpPT5URSxUZXh0TGluZURhdGFzZXQ6KCk9PnlFLFVSTERhdGFTb3VyY2U6KCk9PkNFLGFycmF5OigpPT5xNSxjc3Y6KCk9Pmk4LGZ1bmM6KCk9Pm84LGdlbmVyYXRvcjooKT0+bDgsbWljcm9waG9uZTooKT0+cDgsdmVyc2lvbl9kYXRhOigpPT5jOCx3ZWJjYW06KCk9PnU4LHppcDooKT0+SzV9KTt2YXIgTjU9eHMoYm0oKSksVDU9eHMoYm0oKSk7ZnVuY3Rpb24gQzUoZSx0KXtyZXR1cm4gb20oZSx0KX1mdW5jdGlvbiBvbShlLHQsbj1uZXcgTWFwLGE9bmV3IFNldCl7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZih0eXBlb2YgQmxvYj09XCJmdW5jdGlvblwiJiZlIGluc3RhbmNlb2YgQmxvYilyZXR1cm4gZS5zbGljZSgpO2lmKGEuaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO2lmKG4uaGFzKGUpKXJldHVybiBuLmdldChlKTtsZXQgcj10KGUpO2lmKHIucmVjdXJzZSYmci52YWx1ZSE9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiQSBkZWVwIG1hcCBmdW5jdGlvbiBtYXkgbm90IHJldHVybiBib3RoIGEgdmFsdWUgYW5kIHJlY3Vyc2U9dHJ1ZS5cIik7aWYoci5yZWN1cnNlKWlmKEhsKGUpKXtsZXQgcz1BcnJheS5pc0FycmF5KGUpP1tdOnt9O2EuYWRkKGUpO2ZvcihsZXQgaSBpbiBlKXtsZXQgbz1lW2ldLGw9b20obyx0LG4sYSk7c1tpXT1sfXJldHVybiBhLmRlbGV0ZShlKSxlLl9fcHJvdG9fXyYmKHMuX19wcm90b19fPWUuX19wcm90b19fKSxzfWVsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCByZWN1cnNlIGludG8gbm9uLWl0ZXJhYmxlIHR5cGU6ICR7ZX1gKTtlbHNlIHJldHVybiBuLnNldChlLHIudmFsdWUpLHIudmFsdWV9ZnVuY3Rpb24gRTUoZSx0PXBFKXtyZXR1cm4gdUUoZSx0KX1mdW5jdGlvbiB1RShlLHQsbj1uZXcgU2V0KXtsZXQgYT1lWzBdO2lmKG4uaGFzKGEpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO2xldCByPXQoZSk7aWYoci5yZWN1cnNlJiZyLnZhbHVlIT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJBIGRlZXAgemlwIGZ1bmN0aW9uIG1heSBub3QgcmV0dXJuIGJvdGggYSB2YWx1ZSBhbmQgcmVjdXJzZT10cnVlLlwiKTtpZihyLnJlY3Vyc2UpaWYoSGwoYSkpe2xldCBzPUFycmF5LmlzQXJyYXkoYSk/W106e307bi5hZGQoYSk7Zm9yKGxldCBpIGluIGEpe2xldCBvPWUubWFwKHU9PnVbaV0pLGw9dUUobyx0LG4pO3NbaV09bH1yZXR1cm4gbi5kZWxldGUoYSksc31lbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcmVjdXJzZSBpbnRvIG5vbi1pdGVyYWJsZSB0eXBlOiAke2F9YCk7ZWxzZSByZXR1cm4gci52YWx1ZX1mdW5jdGlvbiBwRShlKXtyZXR1cm4gZT09PW51bGw/bnVsbDpIbChlWzBdKT97dmFsdWU6bnVsbCxyZWN1cnNlOiEwfTp7dmFsdWU6ZSxyZWN1cnNlOiExfX1hc3luYyBmdW5jdGlvbiBjRShlLHQpe2xldCBuPW5ldyBNYXA7b20oZSx0LG4pO2ZvcihsZXQgYSBvZiBBcnJheS5mcm9tKG4ua2V5cygpKSl7bGV0IHI9bi5nZXQoYSk7aWYody5pc1Byb21pc2Uocikpe2xldCBzPWF3YWl0IHI7bi5zZXQoYSxzKX19cmV0dXJuIG9tKGUsdCxuKX1mdW5jdGlvbiBIbChlKXtsZXQgdD0hMTtpZihHKCkuZ2V0KFwiSVNfQlJPV1NFUlwiKSl0PWUgaW5zdGFuY2VvZiBUZXh0RGVjb2RlcjtlbHNle2xldHtTdHJpbmdEZWNvZGVyOm59PUZTKCk7dD1lIGluc3RhbmNlb2Ygbn1yZXR1cm4gZSE9bnVsbCYmIUFycmF5QnVmZmVyLmlzVmlldyhlKSYmKEFycmF5LmlzQXJyYXkoZSl8fHR5cGVvZiBlPT1cIm9iamVjdFwiJiYhKGUgaW5zdGFuY2VvZiBDZSkmJiEoZSBpbnN0YW5jZW9mIFByb21pc2UpJiYhdCl9ZnVuY3Rpb24gXzUoZSl7cmV0dXJuIGU9PW51bGx8fEE1KGUpfHxBcnJheS5pc0FycmF5KGUpfHx0eXBlb2YgZT09XCJvYmplY3RcIiYmZSBpbnN0YW5jZW9mIENlfHx3LmlzVHlwZWRBcnJheShlKX1mdW5jdGlvbiBBNShlKXtyZXR1cm4gZT09PW51bGx8fHR5cGVvZiBlIT1cIm9iamVjdFwiJiZ0eXBlb2YgZSE9XCJmdW5jdGlvblwifWZ1bmN0aW9uIEY1KGUpe3JldHVybiBDNShlLCQ1KX1mdW5jdGlvbiAkNShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIENlP3t2YWx1ZTplLmNsb25lKCkscmVjdXJzZTohMX06SGwoZSk/e3ZhbHVlOm51bGwscmVjdXJzZTohMH06e3ZhbHVlOmUscmVjdXJzZTohMX19dmFyIGRFPWNsYXNze2NvbnN0cnVjdG9yKGUpe2lmKHRoaXMuY2FwYWNpdHk9ZSx0aGlzLmJlZ2luPTAsdGhpcy5lbmQ9MCxlPT1udWxsKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgcmluZyBidWZmZXIgb2YgdW5rbm93biBjYXBhY2l0eS5cIik7aWYoZTwxKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgY3JlYXRlIHJpbmcgYnVmZmVyIG9mIGNhcGFjaXR5IDwgMS5cIik7dGhpcy5kYXRhPW5ldyBBcnJheShlKSx0aGlzLmRvdWJsZWRDYXBhY2l0eT0yKmV9d3JhcChlKXtmb3IoO2U8MDspZSs9dGhpcy5kb3VibGVkQ2FwYWNpdHk7cmV0dXJuIGUldGhpcy5kb3VibGVkQ2FwYWNpdHl9Z2V0KGUpe2lmKGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGdldCBpdGVtIGF0IGEgbmVnYXRpdmUgaW5kZXguXCIpO3JldHVybiB0aGlzLmRhdGFbZSV0aGlzLmNhcGFjaXR5XX1zZXQoZSx0KXtpZihlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzZXQgaXRlbSBhdCBhIG5lZ2F0aXZlIGluZGV4LlwiKTt0aGlzLmRhdGFbZSV0aGlzLmNhcGFjaXR5XT10fWxlbmd0aCgpe2xldCBlPXRoaXMuZW5kLXRoaXMuYmVnaW47cmV0dXJuIGU8MCYmKGU9dGhpcy5kb3VibGVkQ2FwYWNpdHkrZSksZX1pc0Z1bGwoKXtyZXR1cm4gdGhpcy5sZW5ndGgoKT09PXRoaXMuY2FwYWNpdHl9aXNFbXB0eSgpe3JldHVybiB0aGlzLmxlbmd0aCgpPT09MH1wdXNoKGUpe2lmKHRoaXMuaXNGdWxsKCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBmdWxsLlwiKTt0aGlzLnNldCh0aGlzLmVuZCxlKSx0aGlzLmVuZD10aGlzLndyYXAodGhpcy5lbmQrMSl9cHVzaEFsbChlKXtmb3IobGV0IHQgb2YgZSl0aGlzLnB1c2godCl9cG9wKCl7aWYodGhpcy5pc0VtcHR5KCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBlbXB0eS5cIik7dGhpcy5lbmQ9dGhpcy53cmFwKHRoaXMuZW5kLTEpO2xldCBlPXRoaXMuZ2V0KHRoaXMuZW5kKTtyZXR1cm4gdGhpcy5zZXQodGhpcy5lbmQsdm9pZCAwKSxlfXVuc2hpZnQoZSl7aWYodGhpcy5pc0Z1bGwoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJpbmcgYnVmZmVyIGlzIGZ1bGwuXCIpO3RoaXMuYmVnaW49dGhpcy53cmFwKHRoaXMuYmVnaW4tMSksdGhpcy5zZXQodGhpcy5iZWdpbixlKX1zaGlmdCgpe2lmKHRoaXMuaXNFbXB0eSgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiUmluZyBidWZmZXIgaXMgZW1wdHkuXCIpO2xldCBlPXRoaXMuZ2V0KHRoaXMuYmVnaW4pO3JldHVybiB0aGlzLnNldCh0aGlzLmJlZ2luLHZvaWQgMCksdGhpcy5iZWdpbj10aGlzLndyYXAodGhpcy5iZWdpbisxKSxlfXNodWZmbGVFeGNpc2UoZSl7aWYodGhpcy5pc0VtcHR5KCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSaW5nIGJ1ZmZlciBpcyBlbXB0eS5cIik7bGV0IHQ9dGhpcy53cmFwKHRoaXMuYmVnaW4rZSksbj10aGlzLmdldCh0KTtyZXR1cm4gdGhpcy5zZXQodCx0aGlzLnBvcCgpKSxufX0saEU9Y2xhc3MgbUUgZXh0ZW5kcyBkRXtjb25zdHJ1Y3Rvcigpe3N1cGVyKG1FLklOSVRJQUxfQ0FQQUNJVFkpfWlzRnVsbCgpe3JldHVybiExfXB1c2godCl7c3VwZXIuaXNGdWxsKCkmJnRoaXMuZXhwYW5kKCksc3VwZXIucHVzaCh0KX11bnNoaWZ0KHQpe3N1cGVyLmlzRnVsbCgpJiZ0aGlzLmV4cGFuZCgpLHN1cGVyLnVuc2hpZnQodCl9ZXhwYW5kKCl7bGV0IHQ9dGhpcy5jYXBhY2l0eSoyLG49bmV3IEFycmF5KHQpLGE9dGhpcy5sZW5ndGgoKTtmb3IobGV0IHI9MDtyPGE7cisrKW5bcl09dGhpcy5nZXQodGhpcy53cmFwKHRoaXMuYmVnaW4rcikpO3RoaXMuZGF0YT1uLHRoaXMuY2FwYWNpdHk9dCx0aGlzLmRvdWJsZWRDYXBhY2l0eT0yKnRoaXMuY2FwYWNpdHksdGhpcy5iZWdpbj0wLHRoaXMuZW5kPWF9fTtoRS5JTklUSUFMX0NBUEFDSVRZPTMyO2Z1bmN0aW9uIGZFKGUpe3JldHVybiBuZXcgTTUoZSl9ZnVuY3Rpb24gJDEoZSl7cmV0dXJuIG5ldyBPNShlKX1mdW5jdGlvbiBENShlLHQpe3JldHVybiBuZXcgZ0UoZSx0KX1mdW5jdGlvbiBSNShlLHQ9ZXMuRkFJTCl7cmV0dXJuIG5ldyBINShlLHQpfXZhciBzbj1jbGFzc3thc3luYyB0b0FycmF5KCl7bGV0IGU9W10sdD1hd2FpdCB0aGlzLm5leHQoKTtmb3IoOyF0LmRvbmU7KWUucHVzaCh0LnZhbHVlKSx0PWF3YWl0IHRoaXMubmV4dCgpO3JldHVybiBlfWFzeW5jIHRvQXJyYXlGb3JUZXN0KCl7bGV0IGU9dGhpcy5wcmVmZXRjaCgxMDApLHQ9W10sbj1hd2FpdCBlLm5leHQoKTtmb3IoOyFuLmRvbmU7KXQucHVzaChuLnZhbHVlKSxuPWF3YWl0IGUubmV4dCgpO3JldHVybiB0fWFzeW5jIHJlc29sdmVGdWxseSgpe2xldCBlPWF3YWl0IHRoaXMubmV4dCgpO2Zvcig7IWUuZG9uZTspZT1hd2FpdCB0aGlzLm5leHQoKX1hc3luYyByZXNvbHZlV2hpbGUoZSl7bGV0IHQ9YXdhaXQgdGhpcy5uZXh0KCksbj1lKHQudmFsdWUpO2Zvcig7IXQuZG9uZSYmbjspdD1hd2FpdCB0aGlzLm5leHQoKSxuPWUodC52YWx1ZSl9aGFuZGxlRXJyb3JzKGUpe3JldHVybiBuZXcgVTUodGhpcyxlKX1maWx0ZXIoZSl7cmV0dXJuIG5ldyBCNSh0aGlzLGUpfW1hcChlKXtyZXR1cm4gbmV3IFY1KHRoaXMsZSl9bWFwQXN5bmMoZSl7cmV0dXJuIG5ldyBxSSh0aGlzLGUpfXNlcmlhbE1hcEFzeW5jKGUpe3JldHVybiBuZXcgcUkodGhpcyxlKS5zZXJpYWwoKX1mbGF0bWFwKGUpe3JldHVybiBuZXcgRzUodGhpcyxlKX1hc3luYyBmb3JFYWNoQXN5bmMoZSl7cmV0dXJuIHRoaXMubWFwKGUpLnJlc29sdmVGdWxseSgpfWFzeW5jIHNlcmlhbEZvckVhY2goZSl7cmV0dXJuIHRoaXMuc2VyaWFsTWFwQXN5bmMoZSkucmVzb2x2ZVdoaWxlKHQ9PnQ9PT0hMCl9cm93TWFqb3JCYXRjaChlLHQ9ITApe3JldHVybiBuZXcgVzUodGhpcyxlLHQpfWNvbHVtbk1ham9yQmF0Y2goZSx0PSEwLG49cEUpe3JldHVybiB0aGlzLnJvd01ham9yQmF0Y2goZSx0KS5tYXAoYT0+RTUoYSxuKSl9Y29uY2F0ZW5hdGUoZSx0KXtyZXR1cm4gbmV3IGdFKGZFKFt0aGlzLGVdKSx0KX10YWtlKGUpe3JldHVybiBlPDB8fGU9PW51bGw/dGhpczpuZXcgejUodGhpcyxlKX1za2lwKGUpe3JldHVybiBlPDB8fGU9PW51bGw/dGhpczpuZXcgTDUodGhpcyxlKX1wcmVmZXRjaChlKXtyZXR1cm4gbmV3IGJFKHRoaXMsZSl9c2h1ZmZsZShlLHQpe3JldHVybiBuZXcgajUodGhpcyxlLHQpfXNlcmlhbCgpe3JldHVybiBuZXcgUDUodGhpcyl9fSxNNT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy5pdGVtcz1lLHRoaXMudHJhdj0wfXN1bW1hcnkoKXtyZXR1cm5gQXJyYXkgb2YgJHt0aGlzLml0ZW1zLmxlbmd0aH0gaXRlbXNgfWFzeW5jIG5leHQoKXtpZih0aGlzLnRyYXY+PXRoaXMuaXRlbXMubGVuZ3RoKXJldHVybnt2YWx1ZTpudWxsLGRvbmU6ITB9O2xldCBlPXRoaXMuaXRlbXNbdGhpcy50cmF2XTtyZXR1cm4gdGhpcy50cmF2Kysse3ZhbHVlOkY1KGUpLGRvbmU6ITF9fX0sTzU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMubmV4dEZuPWV9c3VtbWFyeSgpe3JldHVyblwiRnVuY3Rpb24gY2FsbFwifWFzeW5jIG5leHQoKXt0cnl7cmV0dXJuIHRoaXMubmV4dEZuKCl9Y2F0Y2goZSl7dGhyb3cgZS5tZXNzYWdlPWBFcnJvciB0aHJvd24gd2hpbGUgaXRlcmF0aW5nIHRocm91Z2ggYSBkYXRhc2V0OiAke2UubWVzc2FnZX1gLGV9fX0sUDU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSl9c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBTZXJpYWxgfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oKCk9PnRoaXMuc2VyaWFsTmV4dCgpKSx0aGlzLmxhc3RSZWFkfWFzeW5jIHNlcmlhbE5leHQoKXtyZXR1cm4gdGhpcy51cHN0cmVhbS5uZXh0KCl9fSxMNT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsdGhpcy5tYXhDb3VudD10LHRoaXMuY291bnQ9MCx0aGlzLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSl9c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBTa2lwYH1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKCgpPT50aGlzLnNlcmlhbE5leHQoKSksdGhpcy5sYXN0UmVhZH1hc3luYyBzZXJpYWxOZXh0KCl7Zm9yKDt0aGlzLmNvdW50Kys8dGhpcy5tYXhDb3VudDspe2xldCBlPWF3YWl0IHRoaXMudXBzdHJlYW0ubmV4dCgpO2lmKGUuZG9uZSlyZXR1cm4gZTtFZShlLnZhbHVlKX1yZXR1cm4gdGhpcy51cHN0cmVhbS5uZXh0KCl9fSx6NT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsdGhpcy5tYXhDb3VudD10LHRoaXMuY291bnQ9MH1zdW1tYXJ5KCl7cmV0dXJuYCR7dGhpcy51cHN0cmVhbS5zdW1tYXJ5KCl9IC0+IFRha2VgfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5jb3VudCsrPj10aGlzLm1heENvdW50P3t2YWx1ZTpudWxsLGRvbmU6ITB9OnRoaXMudXBzdHJlYW0ubmV4dCgpfX0sVzU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlLHQsbj0hMCl7c3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsdGhpcy5iYXRjaFNpemU9dCx0aGlzLmVuYWJsZVNtYWxsTGFzdEJhdGNoPW4sdGhpcy5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pfXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gUm93TWFqb3JCYXRjaGB9YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbigoKT0+dGhpcy5zZXJpYWxOZXh0KCkpLHRoaXMubGFzdFJlYWR9YXN5bmMgc2VyaWFsTmV4dCgpe2xldCBlPVtdO2Zvcig7ZS5sZW5ndGg8dGhpcy5iYXRjaFNpemU7KXtsZXQgdD1hd2FpdCB0aGlzLnVwc3RyZWFtLm5leHQoKTtpZih0LmRvbmUpcmV0dXJuIHRoaXMuZW5hYmxlU21hbGxMYXN0QmF0Y2gmJmUubGVuZ3RoPjA/e3ZhbHVlOmUsZG9uZTohMX06e3ZhbHVlOm51bGwsZG9uZTohMH07ZS5wdXNoKHQudmFsdWUpfXJldHVybnt2YWx1ZTplLGRvbmU6ITF9fX0sQjU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMucHJlZGljYXRlPXQsdGhpcy5sYXN0UmVhZD1Qcm9taXNlLnJlc29sdmUoe3ZhbHVlOm51bGwsZG9uZTohMX0pfXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gRmlsdGVyYH1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKCgpPT50aGlzLnNlcmlhbE5leHQoKSksdGhpcy5sYXN0UmVhZH1hc3luYyBzZXJpYWxOZXh0KCl7Zm9yKDs7KXtsZXQgZT1hd2FpdCB0aGlzLnVwc3RyZWFtLm5leHQoKTtpZihlLmRvbmV8fHRoaXMucHJlZGljYXRlKGUudmFsdWUpKXJldHVybiBlO0VlKGUudmFsdWUpfX19LFY1PWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLnRyYW5zZm9ybT10fXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gTWFwYH1hc3luYyBuZXh0KCl7bGV0IGU9YXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCk7aWYoZS5kb25lKXJldHVybnt2YWx1ZTpudWxsLGRvbmU6ITB9O2xldCB0PVdhLmdldFRlbnNvcnNJbkNvbnRhaW5lcihlLnZhbHVlKSxuPXRoaXMudHJhbnNmb3JtKGUudmFsdWUpLGE9V2EuZ2V0VGVuc29yc0luQ29udGFpbmVyKG4pO2ZvcihsZXQgciBvZiB0KVdhLmlzVGVuc29ySW5MaXN0KHIsYSl8fHIuZGlzcG9zZSgpO3JldHVybnt2YWx1ZTpuLGRvbmU6ITF9fX0sVTU9Y2xhc3MgZXh0ZW5kcyBzbntjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMuaGFuZGxlcj10LHRoaXMuY291bnQ9MCx0aGlzLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSl9c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBoYW5kbGVFcnJvcnNgfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5sYXN0UmVhZD10aGlzLmxhc3RSZWFkLnRoZW4oKCk9PnRoaXMuc2VyaWFsTmV4dCgpKSx0aGlzLmxhc3RSZWFkfWFzeW5jIHNlcmlhbE5leHQoKXtmb3IoOzspdHJ5e3JldHVybiBhd2FpdCB0aGlzLnVwc3RyZWFtLm5leHQoKX1jYXRjaChlKXtpZighdGhpcy5oYW5kbGVyKGUpKXJldHVybnt2YWx1ZTpudWxsLGRvbmU6ITB9fX19LHFJPWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLnRyYW5zZm9ybT10fXN1bW1hcnkoKXtyZXR1cm5gJHt0aGlzLnVwc3RyZWFtLnN1bW1hcnkoKX0gLT4gQXN5bmNNYXBgfWFzeW5jIG5leHQoKXtsZXQgZT1hd2FpdCB0aGlzLnVwc3RyZWFtLm5leHQoKTtpZihlLmRvbmUpcmV0dXJue3ZhbHVlOm51bGwsZG9uZTohMH07bGV0IHQ9V2EuZ2V0VGVuc29yc0luQ29udGFpbmVyKGUudmFsdWUpLG49YXdhaXQgdGhpcy50cmFuc2Zvcm0oZS52YWx1ZSksYT1XYS5nZXRUZW5zb3JzSW5Db250YWluZXIobik7Zm9yKGxldCByIG9mIHQpV2EuaXNUZW5zb3JJbkxpc3QocixhKXx8ci5kaXNwb3NlKCk7cmV0dXJue3ZhbHVlOm4sZG9uZTohMX19fSxEMT1jbGFzcyBleHRlbmRzIHNue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLm91dHB1dFF1ZXVlPW5ldyBoRSx0aGlzLmxhc3RSZWFkPVByb21pc2UucmVzb2x2ZSh7dmFsdWU6bnVsbCxkb25lOiExfSl9YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMubGFzdFJlYWQudGhlbigoKT0+dGhpcy5zZXJpYWxOZXh0KCkpLHRoaXMubGFzdFJlYWR9YXN5bmMgc2VyaWFsTmV4dCgpe2Zvcig7dGhpcy5vdXRwdXRRdWV1ZS5sZW5ndGgoKT09PTA7KWlmKCFhd2FpdCB0aGlzLnB1bXAoKSlyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTtyZXR1cm57dmFsdWU6dGhpcy5vdXRwdXRRdWV1ZS5zaGlmdCgpLGRvbmU6ITF9fX0sRzU9Y2xhc3MgZXh0ZW5kcyBEMXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMudHJhbnNmb3JtPXR9c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBGbGF0bWFwYH1hc3luYyBwdW1wKCl7bGV0IGU9YXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCk7aWYoZS5kb25lKXJldHVybiExO2xldCB0PVdhLmdldFRlbnNvcnNJbkNvbnRhaW5lcihlLnZhbHVlKSxuPXRoaXMudHJhbnNmb3JtKGUudmFsdWUpLGE9V2EuZ2V0VGVuc29yc0luQ29udGFpbmVyKG4pO3RoaXMub3V0cHV0UXVldWUucHVzaEFsbChuKTtmb3IobGV0IHIgb2YgdClXYS5pc1RlbnNvckluTGlzdChyLGEpfHxyLmRpc3Bvc2UoKTtyZXR1cm4hMH19LGdFPWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMuYmFzZUVycm9ySGFuZGxlcj10LHRoaXMubGFzdFJlYWQ9bnVsbCx0aGlzLml0ZXJhdG9yPW51bGwsdGhpcy5tb3JlSXRlcmF0b3JzPWV9c3VtbWFyeSgpe3JldHVyblwiVE9ETzogZmlsbCBpbiB1cHN0cmVhbSBvZiBjaGFpbmVkIHN1bW1hcmllcyAtPiBDaGFpbmVkXCJ9YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmxhc3RSZWFkPXRoaXMucmVhZEZyb21DaGFpbih0aGlzLmxhc3RSZWFkKSx0aGlzLmxhc3RSZWFkfWFzeW5jIHJlYWRGcm9tQ2hhaW4oZSl7aWYoYXdhaXQgZSx0aGlzLml0ZXJhdG9yPT1udWxsKXtsZXQgbj1hd2FpdCB0aGlzLm1vcmVJdGVyYXRvcnMubmV4dCgpO2lmKG4uZG9uZSlyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTt0aGlzLml0ZXJhdG9yPW4udmFsdWUsdGhpcy5iYXNlRXJyb3JIYW5kbGVyIT1udWxsJiYodGhpcy5pdGVyYXRvcj10aGlzLml0ZXJhdG9yLmhhbmRsZUVycm9ycyh0aGlzLmJhc2VFcnJvckhhbmRsZXIpKX1sZXQgdD1hd2FpdCB0aGlzLml0ZXJhdG9yLm5leHQoKTtyZXR1cm4gdC5kb25lPyh0aGlzLml0ZXJhdG9yPW51bGwsdGhpcy5yZWFkRnJvbUNoYWluKGUpKTp0fX0sZXM7KGZ1bmN0aW9uKGUpe2VbZS5GQUlMPTBdPVwiRkFJTFwiLGVbZS5TSE9SVEVTVD0xXT1cIlNIT1JURVNUXCIsZVtlLkxPTkdFU1Q9Ml09XCJMT05HRVNUXCJ9KShlc3x8KGVzPXt9KSk7dmFyIEg1PWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0PWVzLkZBSUwpe3N1cGVyKCksdGhpcy5pdGVyYXRvcnM9ZSx0aGlzLm1pc21hdGNoTW9kZT10LHRoaXMuY291bnQ9MCx0aGlzLmN1cnJlbnRQcm9taXNlPW51bGx9c3VtbWFyeSgpe3JldHVyblwie1RPRE86IGZpbGwgaW4gdXBzdHJlYW0gb2YgemlwIHN1bW1hcmllc30gLT4gWmlwXCJ9YXN5bmMgbmV4dFN0YXRlKGUpe2F3YWl0IGU7bGV0IHQ9MCxuPTA7ZnVuY3Rpb24gYShzKXtyZXR1cm4gcyBpbnN0YW5jZW9mIHNuP3t2YWx1ZTpzLm5leHQoKS50aGVuKGk9Pih0KyssaS5kb25lJiZuKyssaS52YWx1ZSkpLHJlY3Vyc2U6ITF9Ont2YWx1ZTpudWxsLHJlY3Vyc2U6ITB9fWxldCByPWF3YWl0IGNFKHRoaXMuaXRlcmF0b3JzLGEpO2lmKHQ9PT1uKXJldHVybnt2YWx1ZTpudWxsLGRvbmU6ITB9O2lmKG4+MClzd2l0Y2godGhpcy5taXNtYXRjaE1vZGUpe2Nhc2UgZXMuRkFJTDp0aHJvdyBuZXcgRXJyb3IoYFppcHBlZCBzdHJlYW1zIHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aC4gTWlzbWF0Y2hlZCBhdCBlbGVtZW50ICR7dGhpcy5jb3VudH0uYCk7Y2FzZSBlcy5TSE9SVEVTVDpyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTtjYXNlIGVzLkxPTkdFU1Q6ZGVmYXVsdDp9cmV0dXJuIHRoaXMuY291bnQrKyx7dmFsdWU6cixkb25lOiExfX1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMuY3VycmVudFByb21pc2U9dGhpcy5uZXh0U3RhdGUodGhpcy5jdXJyZW50UHJvbWlzZSksdGhpcy5jdXJyZW50UHJvbWlzZX19LGJFPWNsYXNzIGV4dGVuZHMgc257Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpLHRoaXMudXBzdHJlYW09ZSx0aGlzLmJ1ZmZlclNpemU9dCx0aGlzLmJ1ZmZlcj1uZXcgZEUodCl9c3VtbWFyeSgpe3JldHVybmAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBQcmVmZXRjaGB9cmVmaWxsKCl7Zm9yKDshdGhpcy5idWZmZXIuaXNGdWxsKCk7KXtsZXQgZT10aGlzLnVwc3RyZWFtLm5leHQoKTt0aGlzLmJ1ZmZlci5wdXNoKGUpfX1uZXh0KCl7cmV0dXJuIHRoaXMucmVmaWxsKCksdGhpcy5idWZmZXIuc2hpZnQoKX19LGo1PWNsYXNzIGV4dGVuZHMgYkV7Y29uc3RydWN0b3IoZSx0LG4pe3N1cGVyKGUsdCksdGhpcy51cHN0cmVhbT1lLHRoaXMud2luZG93U2l6ZT10LHRoaXMudXBzdHJlYW1FeGhhdXN0ZWQ9ITEsdGhpcy5yYW5kb209VDUuYWxlYShufHx3Lm5vdygpLnRvU3RyaW5nKCkpLHRoaXMubGFzdFJlYWQ9UHJvbWlzZS5yZXNvbHZlKHt2YWx1ZTpudWxsLGRvbmU6ITF9KX1hc3luYyBuZXh0KCl7cmV0dXJuIHRoaXMubGFzdFJlYWQ9dGhpcy5sYXN0UmVhZC50aGVuKCgpPT50aGlzLnNlcmlhbE5leHQoKSksdGhpcy5sYXN0UmVhZH1yYW5kb21JbnQoZSl7cmV0dXJuIE1hdGguZmxvb3IodGhpcy5yYW5kb20oKSplKX1jaG9vc2VJbmRleCgpe3JldHVybiB0aGlzLnJhbmRvbUludCh0aGlzLmJ1ZmZlci5sZW5ndGgoKSl9YXN5bmMgc2VyaWFsTmV4dCgpe2Zvcih0aGlzLnVwc3RyZWFtRXhoYXVzdGVkfHx0aGlzLnJlZmlsbCgpOyF0aGlzLmJ1ZmZlci5pc0VtcHR5KCk7KXtsZXQgZT10aGlzLmNob29zZUluZGV4KCksdD1hd2FpdCB0aGlzLmJ1ZmZlci5zaHVmZmxlRXhjaXNlKGUpO2lmKHQuZG9uZSl0aGlzLnVwc3RyZWFtRXhoYXVzdGVkPSEwO2Vsc2UgcmV0dXJuIHRoaXMucmVmaWxsKCksdH1yZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfX19LGlwPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5zaXplPW51bGx9YmF0Y2goZSx0PSEwKXtsZXQgbj10aGlzO3cuYXNzZXJ0KGU+MCwoKT0+YGJhdGNoU2l6ZSBuZWVkcyB0byBiZSBwb3NpdGl2ZSwgYnV0IGl0IGlzXG4gICAgICAke2V9YCk7bGV0IGE7cmV0dXJuIHRoaXMuc2l6ZT09PTEvMHx8dGhpcy5zaXplPT1udWxsP2E9dGhpcy5zaXplOnQ/YT1NYXRoLmNlaWwodGhpcy5zaXplL2UpOmE9TWF0aC5mbG9vcih0aGlzLnNpemUvZSksS24oYXN5bmMoKT0+KGF3YWl0IG4uaXRlcmF0b3IoKSkuY29sdW1uTWFqb3JCYXRjaChlLHQsWDUpLGEpfWNvbmNhdGVuYXRlKGUpe2xldCB0PXRoaXMsbjtyZXR1cm4gdGhpcy5zaXplPT09MS8wfHxlLnNpemU9PT0xLzA/bj0xLzA6dGhpcy5zaXplIT1udWxsJiZlLnNpemUhPW51bGw/bj10aGlzLnNpemUrZS5zaXplOm49bnVsbCxLbihhc3luYygpPT4oYXdhaXQgdC5pdGVyYXRvcigpKS5jb25jYXRlbmF0ZShhd2FpdCBlLml0ZXJhdG9yKCkpLG4pfWZpbHRlcihlKXtsZXQgdD10aGlzLG47cmV0dXJuIHRoaXMuc2l6ZT09PTEvMD9uPTEvMDpuPW51bGwsS24oYXN5bmMoKT0+KGF3YWl0IHQuaXRlcmF0b3IoKSkuZmlsdGVyKGE9Pk8oKCk9PmUoYSkpKSxuKX1hc3luYyBmb3JFYWNoQXN5bmMoZSl7cmV0dXJuKGF3YWl0IHRoaXMuaXRlcmF0b3IoKSkuZm9yRWFjaEFzeW5jKGUpfW1hcChlKXtsZXQgdD10aGlzO3JldHVybiBLbihhc3luYygpPT4oYXdhaXQgdC5pdGVyYXRvcigpKS5tYXAobj0+TygoKT0+ZShuKSkpLHRoaXMuc2l6ZSl9bWFwQXN5bmMoZSl7bGV0IHQ9dGhpcztyZXR1cm4gS24oYXN5bmMoKT0+KGF3YWl0IHQuaXRlcmF0b3IoKSkubWFwQXN5bmMoZSksdGhpcy5zaXplKX1wcmVmZXRjaChlKXtpZihlPT1udWxsKXRocm93IG5ldyBSYW5nZUVycm9yKFwiYERhdGFzZXQucHJlZmV0Y2goKWAgcmVxdWlyZXMgYnVmZmVyU2l6ZSB0byBiZSBzcGVjaWZpZWQuXCIpO2xldCB0PXRoaXM7cmV0dXJuIEtuKGFzeW5jKCk9Pihhd2FpdCB0Lml0ZXJhdG9yKCkpLnByZWZldGNoKGUpLHRoaXMuc2l6ZSl9cmVwZWF0KGUpe2xldCB0PXRoaXMsbjtyZXR1cm4gdGhpcy5zaXplIT1udWxsJiZlPjA/bj10aGlzLnNpemUqZTplPT09MD9uPTA6dGhpcy5zaXplIT1udWxsJiYoZT09PXZvaWQgMHx8ZTwwKT9uPTEvMDpuPW51bGwsS24oYXN5bmMoKT0+e2xldCBhPSQxKGFzeW5jKCk9Pih7dmFsdWU6YXdhaXQgdC5pdGVyYXRvcigpLGRvbmU6ITF9KSk7cmV0dXJuIEQ1KGEudGFrZShlKSl9LG4pfXNraXAoZSl7bGV0IHQ9dGhpcyxuO3JldHVybiB0aGlzLnNpemUhPW51bGwmJmU+PTAmJnRoaXMuc2l6ZT49ZT9uPXRoaXMuc2l6ZS1lOnRoaXMuc2l6ZSE9bnVsbCYmKHRoaXMuc2l6ZTxlfHxlPT09dm9pZCAwfHxlPDApP249MDpuPW51bGwsS24oYXN5bmMoKT0+KGF3YWl0IHQuaXRlcmF0b3IoKSkuc2tpcChlKSxuKX1zaHVmZmxlKGUsdCxuPSEwKXtpZihlPT1udWxsfHxlPDApdGhyb3cgdGhpcy5zaXplPT1udWxsP25ldyBSYW5nZUVycm9yKFwiYERhdGFzZXQuc2h1ZmZsZSgpYCByZXF1aXJlcyBidWZmZXJTaXplIHRvIGJlIHNwZWNpZmllZC5cIik6bmV3IFJhbmdlRXJyb3IoYFxcYERhdGFzZXQuc2h1ZmZsZSgpXFxgIHJlcXVpcmVzIGJ1ZmZlclNpemUgdG8gYmUgc3BlY2lmaWVkLiAgSWYgeW91ciBkYXRhIGZpdHMgaW4gbWFpbiBtZW1vcnkgKGZvciByZWd1bGFyIEpTIG9iamVjdHMpLCBhbmQvb3IgR1BVIG1lbW9yeSAoZm9yIFxcYHRmLlRlbnNvclxcYHMpLCBjb25zaWRlciBzZXR0aW5nIGJ1ZmZlclNpemUgdG8gdGhlIGRhdGFzZXQgc2l6ZSAoJHt0aGlzLnNpemV9IGVsZW1lbnRzKWApO2xldCBhPXRoaXMscj1ONS5hbGVhKHR8fHcubm93KCkudG9TdHJpbmcoKSk7cmV0dXJuIEtuKGFzeW5jKCk9PntsZXQgcz1yLmludDMyKCk7cmV0dXJuIG4mJihzKz1yLmludDMyKCkpLChhd2FpdCBhLml0ZXJhdG9yKCkpLnNodWZmbGUoZSxzLnRvU3RyaW5nKCkpfSx0aGlzLnNpemUpfXRha2UoZSl7bGV0IHQ9dGhpcyxuO3JldHVybiB0aGlzLnNpemUhPW51bGwmJnRoaXMuc2l6ZT5lP249ZTp0aGlzLnNpemUhPW51bGwmJnRoaXMuc2l6ZTw9ZT9uPXRoaXMuc2l6ZTpuPW51bGwsS24oYXN5bmMoKT0+KGF3YWl0IHQuaXRlcmF0b3IoKSkudGFrZShlKSxuKX1hc3luYyB0b0FycmF5KCl7aWYodGhpcy5zaXplPT09MS8wKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbmZpbml0ZSBkYXRhIHN0cmVhbSB0byBhcnJheS5cIik7cmV0dXJuKGF3YWl0IHRoaXMuaXRlcmF0b3IoKSkudG9BcnJheSgpfWFzeW5jIHRvQXJyYXlGb3JUZXN0KCl7aWYodGhpcy5zaXplPT09MS8wKXRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29udmVydCBpbmZpbml0ZSBkYXRhIHN0cmVhbSB0byBhcnJheS5cIik7cmV0dXJuKGF3YWl0IHRoaXMuaXRlcmF0b3IoKSkudG9BcnJheUZvclRlc3QoKX19O2lwLk1BWF9CVUZGRVJfU0laRT0xZTQ7ZnVuY3Rpb24gS24oZSx0PW51bGwpe3JldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBpcHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5zaXplPXR9YXN5bmMgaXRlcmF0b3IoKXtyZXR1cm4gZSgpfX19ZnVuY3Rpb24gcTUoZSl7cmV0dXJuIEtuKGFzeW5jKCk9PmZFKGUpLGUubGVuZ3RoKX1mdW5jdGlvbiBLNShlKXtpZighSGwoZSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50IHRvIHppcCgpIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5LlwiKTtsZXQgdDtpZihBcnJheS5pc0FycmF5KGUpKWZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXQ9dD09bnVsbD9lW25dLnNpemU6TWF0aC5taW4odCxlW25dLnNpemUpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIE9iamVjdClmb3IobGV0IG4gaW4gZSl0PXQ9PW51bGw/ZVtuXS5zaXplOk1hdGgubWluKHQsZVtuXS5zaXplKTtyZXR1cm4gS24oYXN5bmMoKT0+e2xldCBuPWF3YWl0IGNFKGUsYT0+e2lmKGEgaW5zdGFuY2VvZiBpcClyZXR1cm57dmFsdWU6YS5pdGVyYXRvcigpLHJlY3Vyc2U6ITF9O2lmKEhsKGEpKXJldHVybnt2YWx1ZTpudWxsLHJlY3Vyc2U6ITB9O3Rocm93IG5ldyBFcnJvcihcIkxlYXZlcyBvZiB0aGUgc3RydWN0dXJlIHBhc3NlZCB0byB6aXAoKSBtdXN0IGJlIERhdGFzZXRzLCBub3QgcHJpbWl0aXZlcy5cIil9KTtyZXR1cm4gUjUobixlcy5TSE9SVEVTVCl9LHQpfWZ1bmN0aW9uIFg1KGUpe2lmKGU9PT1udWxsKXJldHVybiBudWxsO2xldCB0PWVbMF07cmV0dXJuIF81KHQpP3t2YWx1ZTpZNShlKSxyZWN1cnNlOiExfTp7dmFsdWU6bnVsbCxyZWN1cnNlOiEwfX1mdW5jdGlvbiBZNShlKXtpZihlLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgbWFrZSBhIGJhdGNoIG9mIHplcm8gZWxlbWVudHMuXCIpO3JldHVybiBlWzBdaW5zdGFuY2VvZiBDZT9BdChlKTpibihlKX12YXIgeUU9Y2xhc3MgZXh0ZW5kcyBpcHtjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuaW5wdXQ9ZX1hc3luYyBpdGVyYXRvcigpe3JldHVybihhd2FpdCB0aGlzLmlucHV0Lml0ZXJhdG9yKCkpLmRlY29kZVVURjgoKS5zcGxpdChgXG5gKS5tYXAoZT0+KGUuZW5kc1dpdGgoXCJcXHJcIikmJihlPWUuc2xpY2UoMCwtMSkpLGUpKX19LENoPSdcIicsSnA9U3ltYm9sKFwib3V0XCIpLEtJPVN5bWJvbChcImZpZWxkXCIpLEVoPVN5bWJvbChcInF1b3RlXCIpLGJ4PVN5bWJvbChcInF1b3RlYWZ0ZXJxdW90ZVwiKSxYST1TeW1ib2woXCJxdW90ZWlucXVvdGVcIikseEU9Y2xhc3MgZXh0ZW5kcyBpcHthc3luYyBjb2x1bW5OYW1lcygpe3JldHVybiB0aGlzLmNvbHVtbk5hbWVzVmFsaWRhdGVkfHxhd2FpdCB0aGlzLnNldENvbHVtbk5hbWVzKCksdGhpcy5jb25maWd1cmVkQ29sdW1uc09ubHk/T2JqZWN0LmtleXModGhpcy5jb2x1bW5Db25maWdzKTp0aGlzLmZ1bGxDb2x1bW5OYW1lc31hc3luYyBzZXRDb2x1bW5OYW1lcygpe2xldCBlPWF3YWl0IHRoaXMubWF5YmVSZWFkSGVhZGVyTGluZSgpO2lmKCF0aGlzLmZ1bGxDb2x1bW5OYW1lcyYmIWUpdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIG5hbWVzIG11c3QgYmUgcHJvdmlkZWQgaWYgdGhlcmUgaXMgbm8gaGVhZGVyIGxpbmUuXCIpO3RoaXMuZnVsbENvbHVtbk5hbWVzJiZlJiZ3LmFzc2VydChlLmxlbmd0aD09PXRoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aCwoKT0+XCJUaGUgbGVuZ3RoIG9mIHByb3ZpZGVkIGNvbHVtbk5hbWVzIChcIit0aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgudG9TdHJpbmcoKStcIikgZG9lcyBub3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgaGVhZGVyIGxpbmUgcmVhZCBmcm9tIGZpbGUgKFwiK2UubGVuZ3RoLnRvU3RyaW5nKCkrXCIpLlwiKSx0aGlzLmZ1bGxDb2x1bW5OYW1lc3x8KHRoaXMuZnVsbENvbHVtbk5hbWVzPWUpO2xldCB0PXRoaXMuZnVsbENvbHVtbk5hbWVzLnJlZHVjZSgoYSxyKT0+KGFbcl09YVtyXSsxfHwxLGEpLHt9KSxuPU9iamVjdC5rZXlzKHQpLmZpbHRlcihhPT50W2FdPjEpO2lmKHcuYXNzZXJ0KG4ubGVuZ3RoPT09MCwoKT0+XCJEdXBsaWNhdGUgY29sdW1uIG5hbWVzIGZvdW5kOiBcIituLnRvU3RyaW5nKCkpLHRoaXMuY29sdW1uQ29uZmlncyl7Zm9yKGxldCBhIG9mIE9iamVjdC5rZXlzKHRoaXMuY29sdW1uQ29uZmlncykpaWYodGhpcy5mdWxsQ29sdW1uTmFtZXMuaW5kZXhPZihhKT09PS0xKXRocm93IG5ldyBFcnJvcignVGhlIGtleSBcIicrYSsnXCIgcHJvdmlkZWQgaW4gY29sdW1uQ29uZmlncyBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGNvbHVtbiBuYW1lcyAoJyt0aGlzLmZ1bGxDb2x1bW5OYW1lcy50b1N0cmluZygpK1wiKS5cIil9dGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZD0hMH1hc3luYyBtYXliZVJlYWRIZWFkZXJMaW5lKCl7aWYodGhpcy5oYXNIZWFkZXIpe2xldCBlPWF3YWl0KGF3YWl0IHRoaXMuYmFzZS5pdGVyYXRvcigpKS5uZXh0KCk7aWYoZS5kb25lKXRocm93IG5ldyBFcnJvcihcIk5vIGRhdGEgd2FzIGZvdW5kIGZvciBDU1YgcGFyc2luZy5cIik7bGV0IHQ9ZS52YWx1ZTtyZXR1cm4gdGhpcy5wYXJzZVJvdyh0LCExKX1lbHNlIHJldHVybiBudWxsfWNvbnN0cnVjdG9yKGUsdCl7c3VwZXIoKSx0aGlzLmlucHV0PWUsdGhpcy5oYXNIZWFkZXI9ITAsdGhpcy5mdWxsQ29sdW1uTmFtZXM9bnVsbCx0aGlzLmNvbHVtbk5hbWVzVmFsaWRhdGVkPSExLHRoaXMuY29sdW1uQ29uZmlncz1udWxsLHRoaXMuY29uZmlndXJlZENvbHVtbnNPbmx5PSExLHRoaXMuZGVsaW1pdGVyPVwiLFwiLHRoaXMuZGVsaW1XaGl0ZXNwYWNlPSExLHRoaXMuYmFzZT1uZXcgeUUoZSksdHx8KHQ9e30pLHRoaXMuaGFzSGVhZGVyPXQuaGFzSGVhZGVyIT09ITEsdGhpcy5mdWxsQ29sdW1uTmFtZXM9dC5jb2x1bW5OYW1lcyx0aGlzLmNvbHVtbkNvbmZpZ3M9dC5jb2x1bW5Db25maWdzLHRoaXMuY29uZmlndXJlZENvbHVtbnNPbmx5PXQuY29uZmlndXJlZENvbHVtbnNPbmx5LHQuZGVsaW1XaGl0ZXNwYWNlPyh3LmFzc2VydCh0LmRlbGltaXRlcj09bnVsbCwoKT0+XCJEZWxpbWl0ZXIgc2hvdWxkIG5vdCBiZSBwcm92aWRlZCB3aGVuIGRlbGltV2hpdGVzcGFjZSBpcyB0cnVlLlwiKSx0aGlzLmRlbGltV2hpdGVzcGFjZT0hMCx0aGlzLmRlbGltaXRlcj1cIiBcIik6dGhpcy5kZWxpbWl0ZXI9dC5kZWxpbWl0ZXI/dC5kZWxpbWl0ZXI6XCIsXCJ9YXN5bmMgaXRlcmF0b3IoKXt0aGlzLmNvbHVtbk5hbWVzVmFsaWRhdGVkfHxhd2FpdCB0aGlzLnNldENvbHVtbk5hbWVzKCk7bGV0IGU9YXdhaXQgdGhpcy5iYXNlLml0ZXJhdG9yKCk7cmV0dXJuIHRoaXMuaGFzSGVhZGVyJiYoZT1lLnNraXAoMSkpLGUubWFwKHQ9PnRoaXMubWFrZURhdGFFbGVtZW50KHQpKX1tYWtlRGF0YUVsZW1lbnQoZSl7bGV0IHQ9dGhpcy5wYXJzZVJvdyhlKSxuPXt9LGE9e307Zm9yKGxldCByPTA7cjx0aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGg7cisrKXtsZXQgcz10aGlzLmZ1bGxDb2x1bW5OYW1lc1tyXSxpPXRoaXMuY29sdW1uQ29uZmlncz90aGlzLmNvbHVtbkNvbmZpZ3Nbc106bnVsbDtpZighKHRoaXMuY29uZmlndXJlZENvbHVtbnNPbmx5JiYhaSkpe2xldCBvPXRbcl0sbD1udWxsO2lmKG89PT1cIlwiKWlmKGkmJmkuZGVmYXVsdCE9PXZvaWQgMClsPWkuZGVmYXVsdDtlbHNle2lmKGkmJihpLnJlcXVpcmVkfHxpLmlzTGFiZWwpKXRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgY29sdW1uICR7c30gaXMgZW1wdHkgaW4gdGhpcyBsaW5lOiAke2V9YCk7bD12b2lkIDB9ZWxzZXtsZXQgdT1OdW1iZXIobyk7aWYoaXNOYU4odSkpaSYmaS5kdHlwZT09PVwiYm9vbFwiP2w9dGhpcy5nZXRCb29sZWFuKG8pOmw9bztlbHNlIGlmKCFpfHwhaS5kdHlwZSlsPXU7ZWxzZSBzd2l0Y2goaS5kdHlwZSl7Y2FzZVwiZmxvYXQzMlwiOmw9dTticmVhaztjYXNlXCJpbnQzMlwiOmw9TWF0aC5mbG9vcih1KTticmVhaztjYXNlXCJib29sXCI6bD10aGlzLmdldEJvb2xlYW4obyk7YnJlYWs7ZGVmYXVsdDpsPXV9fWkmJmkuaXNMYWJlbD9hW3NdPWw6bltzXT1sfX1yZXR1cm4gT2JqZWN0LmtleXMoYSkubGVuZ3RoPT09MD9uOnt4czpuLHlzOmF9fWdldEJvb2xlYW4oZSl7cmV0dXJuIGU9PT1cIjFcInx8ZS50b0xvd2VyQ2FzZSgpPT09XCJ0cnVlXCI/MTowfXBhcnNlUm93KGUsdD0hMCl7bGV0IG49W10sYT0wLHI9ZS5sZW5ndGgscz1KcDtmb3IobGV0IGk9MDtpPHI7aSsrKXN3aXRjaChzKXtjYXNlIEpwOnN3aXRjaChlLmNoYXJBdChpKSl7Y2FzZSBDaDphPWkrMSxzPUVoO2JyZWFrO2Nhc2UgdGhpcy5kZWxpbWl0ZXI6aWYoYT1pKzEsdGhpcy5kZWxpbWl0ZXI9PT1cIiBcIiYmdGhpcy5kZWxpbVdoaXRlc3BhY2UpYnJlYWs7bi5wdXNoKFwiXCIpLHM9SnA7YnJlYWs7ZGVmYXVsdDpzPUtJLGE9aTticmVha31icmVhaztjYXNlIEtJOnN3aXRjaChlLmNoYXJBdChpKSl7Y2FzZSB0aGlzLmRlbGltaXRlcjpuLnB1c2goZS5zdWJzdHJpbmcoYSxpKSkscz1KcCxhPWkrMTticmVhaztkZWZhdWx0On1icmVhaztjYXNlIEVoOnN3aXRjaChlLmNoYXJBdChpKSl7Y2FzZSBDaDpzPWJ4O2JyZWFrO2RlZmF1bHQ6fWJyZWFrO2Nhc2UgYng6c3dpdGNoKGUuY2hhckF0KGkpKXtjYXNlIHRoaXMuZGVsaW1pdGVyOm4ucHVzaChlLnN1YnN0cmluZyhhLGktMSkpLHM9SnAsYT1pKzE7YnJlYWs7Y2FzZSBDaDpzPUVoO2JyZWFrO2RlZmF1bHQ6cz1YSTticmVha31icmVhaztjYXNlIFhJOnN3aXRjaChlLmNoYXJBdChpKSl7Y2FzZSBDaDpzPUVoO2JyZWFrO2RlZmF1bHQ6fWJyZWFrO2RlZmF1bHQ6fWlmKHM9PT1ieD9uLnB1c2goZS5zdWJzdHJpbmcoYSxyLTEpKTpuLnB1c2goZS5zdWJzdHJpbmcoYSkpLHQmJm4ubGVuZ3RoIT09dGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCByb3cgaW4gY3N2IGZpbGUuIFNob3VsZCBoYXZlICR7dGhpcy5mdWxsQ29sdW1uTmFtZXMubGVuZ3RofSBlbGVtZW50cyBpbiBhIHJvdywgYnV0IGdvdCAke259YCk7cmV0dXJuIG59fSxaNT1jbGFzcyB2RSBleHRlbmRzIHNue2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5taWNyb3Bob25lQ29uZmlnPXQsdGhpcy5pc0Nsb3NlZD0hMSx0aGlzLmZmdFNpemU9dC5mZnRTaXplfHwxMDI0O2xldCBuPU1hdGgubG9nMih0aGlzLmZmdFNpemUpO2lmKHRoaXMuZmZ0U2l6ZTwwfHxuPDR8fG4+MTR8fCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmZnRTaXplOiBpdCBtdXN0IGJlIGEgcG93ZXIgb2YgMiBiZXR3ZWVuIDIgdG8gNCBhbmQgMiB0byAxNCwgYnV0IGdvdCAke3RoaXMuZmZ0U2l6ZX1gKTtpZih0aGlzLm51bUZyYW1lcz10Lm51bUZyYW1lc1BlclNwZWN0cm9ncmFtfHw0Myx0aGlzLnNhbXBsZVJhdGVIej10LnNhbXBsZVJhdGVIeix0aGlzLmNvbHVtblRydW5jYXRlTGVuZ3RoPXQuY29sdW1uVHJ1bmNhdGVMZW5ndGh8fHRoaXMuZmZ0U2l6ZSx0aGlzLmF1ZGlvVHJhY2tDb25zdHJhaW50cz10LmF1ZGlvVHJhY2tDb25zdHJhaW50cyx0aGlzLnNtb290aGluZ1RpbWVDb25zdGFudD10LnNtb290aGluZ1RpbWVDb25zdGFudHx8MCx0aGlzLmluY2x1ZGVTcGVjdHJvZ3JhbT10LmluY2x1ZGVTcGVjdHJvZ3JhbSE9PSExLHRoaXMuaW5jbHVkZVdhdmVmb3JtPXQuaW5jbHVkZVdhdmVmb3JtPT09ITAsIXRoaXMuaW5jbHVkZVNwZWN0cm9ncmFtJiYhdGhpcy5pbmNsdWRlV2F2ZWZvcm0pdGhyb3cgbmV3IEVycm9yKFwiQm90aCBpbmNsdWRlU3BlY3Ryb2dyYW0gYW5kIGluY2x1ZGVXYXZlZm9ybSBhcmUgZmFsc2UuIEF0IGxlYXN0IG9uZSB0eXBlIG9mIGRhdGEgc2hvdWxkIGJlIHJldHVybmVkLlwiKX1zdW1tYXJ5KCl7cmV0dXJuXCJtaWNyb3Bob25lXCJ9c3RhdGljIGFzeW5jIGNyZWF0ZSh0PXt9KXtpZighRygpLmdldChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwibWljcm9waG9uZSBBUEkgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlciBlbnZpcm9ubWVudC5cIik7bGV0IG49bmV3IHZFKHQpO3JldHVybiBhd2FpdCBuLnN0YXJ0KCksbn1hc3luYyBzdGFydCgpe3RyeXt0aGlzLnN0cmVhbT1hd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7YXVkaW86dGhpcy5hdWRpb1RyYWNrQ29uc3RyYWludHM9PW51bGw/ITA6dGhpcy5hdWRpb1RyYWNrQ29uc3RyYWludHMsdmlkZW86ITF9KX1jYXRjaChhKXt0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHRocm93biB3aGlsZSBpbml0aWFsaXppbmcgdmlkZW8gc3RyZWFtOiAke2EubWVzc2FnZX1gKX1pZighdGhpcy5zdHJlYW0pdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IG9idGFpbiBhdWRpbyBmcm9tIG1pY3JvcGhvbmUuXCIpO2xldCB0PXdpbmRvdy5BdWRpb0NvbnRleHR8fHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7aWYodGhpcy5hdWRpb0NvbnRleHQ9bmV3IHQsIXRoaXMuc2FtcGxlUmF0ZUh6KXRoaXMuc2FtcGxlUmF0ZUh6PXRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7ZWxzZSBpZih0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlIT09dGhpcy5zYW1wbGVSYXRlSHopdGhyb3cgbmV3IEVycm9yKGBNaXNtYXRjaCBpbiBzYW1wbGluZyByYXRlOiBFeHBlY3RlZDogJHt0aGlzLnNhbXBsZVJhdGVIen07IEFjdHVhbDogJHt0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlfWApO2xldCBuPXRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHRoaXMuc3RyZWFtKTt0aGlzLmFuYWx5c2VyPXRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCksdGhpcy5hbmFseXNlci5mZnRTaXplPXRoaXMuZmZ0U2l6ZSoyLHRoaXMuYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50PXRoaXMuc21vb3RoaW5nVGltZUNvbnN0YW50LG4uY29ubmVjdCh0aGlzLmFuYWx5c2VyKSx0aGlzLmZyZXFEYXRhPW5ldyBGbG9hdDMyQXJyYXkodGhpcy5mZnRTaXplKSx0aGlzLnRpbWVEYXRhPW5ldyBGbG9hdDMyQXJyYXkodGhpcy5mZnRTaXplKX1hc3luYyBuZXh0KCl7aWYodGhpcy5pc0Nsb3NlZClyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTtsZXQgdCxuLGE9YXdhaXQgdGhpcy5nZXRBdWRpb0RhdGEoKTtpZih0aGlzLmluY2x1ZGVTcGVjdHJvZ3JhbSl7bGV0IHI9dGhpcy5mbGF0dGVuUXVldWUoYS5mcmVxRGF0YVF1ZXVlKTt0PXRoaXMuZ2V0VGVuc29yRnJvbUF1ZGlvRGF0YUFycmF5KHIsW3RoaXMubnVtRnJhbWVzLHRoaXMuY29sdW1uVHJ1bmNhdGVMZW5ndGgsMV0pfWlmKHRoaXMuaW5jbHVkZVdhdmVmb3JtKXtsZXQgcj10aGlzLmZsYXR0ZW5RdWV1ZShhLnRpbWVEYXRhUXVldWUpO249dGhpcy5nZXRUZW5zb3JGcm9tQXVkaW9EYXRhQXJyYXkocixbdGhpcy5udW1GcmFtZXMqdGhpcy5mZnRTaXplLDFdKX1yZXR1cm57dmFsdWU6e3NwZWN0cm9ncmFtOnQsd2F2ZWZvcm06bn0sZG9uZTohMX19YXN5bmMgY2FwdHVyZSgpe3JldHVybihhd2FpdCB0aGlzLm5leHQoKSkudmFsdWV9YXN5bmMgZ2V0QXVkaW9EYXRhKCl7bGV0IHQ9W10sbj1bXSxhPTA7cmV0dXJuIG5ldyBQcm9taXNlKHI9PntsZXQgcz1zZXRJbnRlcnZhbCgoKT0+e3RoaXMuaW5jbHVkZVNwZWN0cm9ncmFtJiYodGhpcy5hbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEodGhpcy5mcmVxRGF0YSksdGhpcy5mcmVxRGF0YVswXT09PS0xLzAmJnIoe2ZyZXFEYXRhUXVldWU6dCx0aW1lRGF0YVF1ZXVlOm59KSx0LnB1c2godGhpcy5mcmVxRGF0YS5zbGljZSgwLHRoaXMuY29sdW1uVHJ1bmNhdGVMZW5ndGgpKSksdGhpcy5pbmNsdWRlV2F2ZWZvcm0mJih0aGlzLmFuYWx5c2VyLmdldEZsb2F0VGltZURvbWFpbkRhdGEodGhpcy50aW1lRGF0YSksbi5wdXNoKHRoaXMudGltZURhdGEuc2xpY2UoKSkpLCsrYT09PXRoaXMubnVtRnJhbWVzJiYoY2xlYXJJbnRlcnZhbChzKSxyKHtmcmVxRGF0YVF1ZXVlOnQsdGltZURhdGFRdWV1ZTpufSkpfSx0aGlzLmZmdFNpemUvdGhpcy5zYW1wbGVSYXRlSHoqMWUzKX0pfXN0b3AoKXt0aGlzLmlzQ2xvc2VkfHwodGhpcy5pc0Nsb3NlZD0hMCx0aGlzLmFuYWx5c2VyLmRpc2Nvbm5lY3QoKSx0aGlzLmF1ZGlvQ29udGV4dC5jbG9zZSgpLHRoaXMuc3RyZWFtIT1udWxsJiZ0aGlzLnN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGg+MCYmdGhpcy5zdHJlYW0uZ2V0VHJhY2tzKClbMF0uc3RvcCgpKX10b0FycmF5KCl7dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGluZmluaXRlIGF1ZGlvIHN0cmVhbSB0byBhcnJheS5cIil9Z2V0U2FtcGxlUmF0ZSgpe3JldHVybiB0aGlzLnNhbXBsZVJhdGVIen1mbGF0dGVuUXVldWUodCl7bGV0IG49dFswXS5sZW5ndGgsYT1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKm4pO3JldHVybiB0LmZvckVhY2goKHIscyk9PmEuc2V0KHIscypuKSksYX1nZXRUZW5zb3JGcm9tQXVkaW9EYXRhQXJyYXkodCxuKXtsZXQgYT1uZXcgRmxvYXQzMkFycmF5KHcuc2l6ZUZyb21TaGFwZShuKSk7cmV0dXJuIGEuc2V0KHQsYS5sZW5ndGgtdC5sZW5ndGgpLGJuKGEsbil9fSxKNT1jbGFzcyB3RSBleHRlbmRzIHNue2NvbnN0cnVjdG9yKHQsbil7aWYoc3VwZXIoKSx0aGlzLndlYmNhbVZpZGVvRWxlbWVudD10LHRoaXMud2ViY2FtQ29uZmlnPW4sdGhpcy5pc0Nsb3NlZD0hMCx0aGlzLnJlc2l6ZT0hMSx0aGlzLm5lZWRUb1Jlc2l6ZSgpKWlmKHRoaXMucmVzaXplPSEwLHRoaXMuY3JvcFNpemU9W3RoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZUhlaWdodCx0aGlzLndlYmNhbUNvbmZpZy5yZXNpemVXaWR0aF0sdGhpcy5jcm9wQm94SW5kPWplKFswXSxcImludDMyXCIpLHRoaXMud2ViY2FtQ29uZmlnLmNlbnRlckNyb3Ape2xldCBhPXRoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZVdpZHRoKjEvdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQud2lkdGgscj10aGlzLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHQqMS90aGlzLndlYmNhbVZpZGVvRWxlbWVudC5oZWlnaHQscz0oMS1hKS8yLGk9KDEtcikvMixvPXMrYSxsPXIraTt0aGlzLmNyb3BCb3g9RWEoW2kscyxsLG9dLFsxLDRdKX1lbHNlIHRoaXMuY3JvcEJveD1FYShbMCwwLDEsMV0sWzEsNF0pfXN1bW1hcnkoKXtyZXR1cm5cIndlYmNhbVwifXN0YXRpYyBhc3luYyBjcmVhdGUodCxuPXt9KXtpZighRygpLmdldChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwidGYuZGF0YS53ZWJjYW0gaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlciBlbnZpcm9ubWVudC5cIik7aWYoIXQpe2lmKHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpLCFuLnJlc2l6ZVdpZHRofHwhbi5yZXNpemVIZWlnaHQpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgd2ViY2FtIHZpZGVvIGVsZW1lbnQsIG9yIHJlc2l6ZVdpZHRoIGFuZCByZXNpemVIZWlnaHQgdG8gY3JlYXRlIGEgaGlkZGVuIHZpZGVvIGVsZW1lbnQuXCIpO3Qud2lkdGg9bi5yZXNpemVXaWR0aCx0LmhlaWdodD1uLnJlc2l6ZUhlaWdodH1sZXQgYT1uZXcgd0UodCxuKTtyZXR1cm4gYXdhaXQgYS5zdGFydCgpLGF9YXN5bmMgc3RhcnQoKXt0aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlJiZ3LmFzc2VydCh0aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlPT09XCJ1c2VyXCJ8fHRoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGU9PT1cImVudmlyb25tZW50XCIsKCk9PmBJbnZhbGlkIHdlYmNhbSBmYWNpbmcgbW9kZTogJHt0aGlzLndlYmNhbUNvbmZpZy5mYWNpbmdNb2RlfS4gUGxlYXNlIHByb3ZpZGUgJ3VzZXInIG9yICdlbnZpcm9ubWVudCdgKTt0cnl7dGhpcy5zdHJlYW09YXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe3ZpZGVvOntkZXZpY2VJZDp0aGlzLndlYmNhbUNvbmZpZy5kZXZpY2VJZCxmYWNpbmdNb2RlOnRoaXMud2ViY2FtQ29uZmlnLmZhY2luZ01vZGU/dGhpcy53ZWJjYW1Db25maWcuZmFjaW5nTW9kZTpcInVzZXJcIix3aWR0aDp0aGlzLndlYmNhbVZpZGVvRWxlbWVudC53aWR0aCxoZWlnaHQ6dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuaGVpZ2h0fX0pfWNhdGNoKHQpe3Rocm93IHQubWVzc2FnZT1gRXJyb3IgdGhyb3duIHdoaWxlIGluaXRpYWxpemluZyB2aWRlbyBzdHJlYW06ICR7dC5tZXNzYWdlfWAsdH1pZighdGhpcy5zdHJlYW0pdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IG9idGFpbiB2aWRlbyBmcm9tIHdlYmNhbS5cIik7dHJ5e3RoaXMud2ViY2FtVmlkZW9FbGVtZW50LnNyY09iamVjdD10aGlzLnN0cmVhbX1jYXRjaCh0KXtjb25zb2xlLmxvZyh0KSx0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5zcmM9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5zdHJlYW0pfXJldHVybiB0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5wbGF5KCksdGhpcy5pc0Nsb3NlZD0hMSxuZXcgUHJvbWlzZSh0PT57dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQub25sb2FkZWRtZXRhZGF0YT0oKT0+e3QoKX19KX1hc3luYyBuZXh0KCl7aWYodGhpcy5pc0Nsb3NlZClyZXR1cm57dmFsdWU6bnVsbCxkb25lOiEwfTtsZXQgdDt0cnl7dD1xby5mcm9tUGl4ZWxzKHRoaXMud2ViY2FtVmlkZW9FbGVtZW50KX1jYXRjaChuKXt0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHRocm93biBjb252ZXJ0aW5nIHZpZGVvIHRvIHBpeGVsczogJHtKU09OLnN0cmluZ2lmeShuKX1gKX1pZih0aGlzLnJlc2l6ZSl0cnl7cmV0dXJue3ZhbHVlOnRoaXMuY3JvcEFuZFJlc2l6ZUZyYW1lKHQpLGRvbmU6ITF9fWNhdGNoKG4pe3Rocm93IG5ldyBFcnJvcihgRXJyb3IgdGhyb3duIGNyb3BwaW5nIHRoZSB2aWRlbzogJHtuLm1lc3NhZ2V9YCl9ZmluYWxseXt0LmRpc3Bvc2UoKX1lbHNlIHJldHVybnt2YWx1ZTp0LGRvbmU6ITF9fW5lZWRUb1Jlc2l6ZSgpe3JldHVybiEhKHRoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZVdpZHRoJiZ0aGlzLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHQmJih0aGlzLndlYmNhbVZpZGVvRWxlbWVudC53aWR0aCE9PXRoaXMud2ViY2FtQ29uZmlnLnJlc2l6ZVdpZHRofHx0aGlzLndlYmNhbVZpZGVvRWxlbWVudC5oZWlnaHQhPT10aGlzLndlYmNhbUNvbmZpZy5yZXNpemVIZWlnaHQpKX1jcm9wQW5kUmVzaXplRnJhbWUodCl7cmV0dXJuIE8oKCk9PntsZXQgbj1HdChyZSh0LFwiZmxvYXQzMlwiKSwwKSxhO2E9Wm4uY3JvcEFuZFJlc2l6ZShuLHRoaXMuY3JvcEJveCx0aGlzLmNyb3BCb3hJbmQsdGhpcy5jcm9wU2l6ZSxcImJpbGluZWFyXCIpO2xldCByPWEuc2hhcGU7cmV0dXJuIFcoYSxyLnNsaWNlKDEpKX0pfWFzeW5jIGNhcHR1cmUoKXtyZXR1cm4oYXdhaXQgdGhpcy5uZXh0KCkpLnZhbHVlfXN0b3AoKXt0aGlzLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHQ9PnQuc3RvcCgpKTt0cnl7dGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuc3JjT2JqZWN0PW51bGx9Y2F0Y2godCl7Y29uc29sZS5sb2codCksdGhpcy53ZWJjYW1WaWRlb0VsZW1lbnQuc3JjPW51bGx9dGhpcy5pc0Nsb3NlZD0hMH10b0FycmF5KCl7dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IGluZmluaXRlIHZpZGVvIHN0cmVhbSB0byBhcnJheS5cIil9fSxrRT1jbGFzc3t9LElFPWNsYXNzIGV4dGVuZHMgc257c3BsaXQoZSl7cmV0dXJuIG5ldyBRNSh0aGlzLGUpfX0sUTU9Y2xhc3MgZXh0ZW5kcyBJRXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMuaW1wbD1uZXcgZTgoZSx0KX1zdW1tYXJ5KCl7cmV0dXJuIHRoaXMuaW1wbC5zdW1tYXJ5KCl9YXN5bmMgbmV4dCgpe3JldHVybiB0aGlzLmltcGwubmV4dCgpfX0sZTg9Y2xhc3MgZXh0ZW5kcyBEMXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMuc2VwYXJhdG9yPXQsdGhpcy5jYXJyeW92ZXI9XCJcIn1zdW1tYXJ5KCl7cmV0dXJuYCR7dGhpcy51cHN0cmVhbS5zdW1tYXJ5KCl9IC0+IFNwbGl0KCcke3RoaXMuc2VwYXJhdG9yfScpYH1hc3luYyBwdW1wKCl7bGV0IGU9YXdhaXQgdGhpcy51cHN0cmVhbS5uZXh0KCk7aWYoZS5kb25lKXJldHVybiB0aGlzLmNhcnJ5b3Zlcj09PVwiXCI/ITE6KHRoaXMub3V0cHV0UXVldWUucHVzaCh0aGlzLmNhcnJ5b3ZlciksdGhpcy5jYXJyeW92ZXI9XCJcIiwhMCk7bGV0IHQ9ZS52YWx1ZS5zcGxpdCh0aGlzLnNlcGFyYXRvcik7dFswXT10aGlzLmNhcnJ5b3Zlcit0WzBdO2ZvcihsZXQgbiBvZiB0LnNsaWNlKDAsLTEpKXRoaXMub3V0cHV0UXVldWUucHVzaChuKTtyZXR1cm4gdGhpcy5jYXJyeW92ZXI9dFt0Lmxlbmd0aC0xXSwhMH19LHQ4PWNsYXNzIGV4dGVuZHMgc257ZGVjb2RlVVRGOCgpe3JldHVybiBuZXcgbjgodGhpcyl9fSxuOD1jbGFzcyBleHRlbmRzIElFe2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy51cHN0cmVhbT1lLHRoaXMuaW1wbD1uZXcgYTgoZSl9c3VtbWFyeSgpe3JldHVybiB0aGlzLmltcGwuc3VtbWFyeSgpfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5pbXBsLm5leHQoKX19LGE4PWNsYXNzIGV4dGVuZHMgRDF7Y29uc3RydWN0b3IoZSl7aWYoc3VwZXIoKSx0aGlzLnVwc3RyZWFtPWUsRygpLmdldChcIklTX0JST1dTRVJcIikpdGhpcy5kZWNvZGVyPW5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO2Vsc2V7bGV0e1N0cmluZ0RlY29kZXI6dH09RlMoKTt0aGlzLmRlY29kZXI9bmV3IHQoXCJ1dGY4XCIpfX1zdW1tYXJ5KCl7cmV0dXJuYCR7dGhpcy51cHN0cmVhbS5zdW1tYXJ5KCl9IC0+IFV0ZjhgfWFzeW5jIHB1bXAoKXtsZXQgZT1hd2FpdCB0aGlzLnVwc3RyZWFtLm5leHQoKSx0O2lmKGUuZG9uZSlyZXR1cm4hMTt0PWUudmFsdWU7bGV0IG47cmV0dXJuIEcoKS5nZXQoXCJJU19CUk9XU0VSXCIpP249dGhpcy5kZWNvZGVyLmRlY29kZSh0LHtzdHJlYW06ITB9KTpuPXRoaXMuZGVjb2Rlci53cml0ZShCdWZmZXIuZnJvbSh0LmJ1ZmZlcikpLHRoaXMub3V0cHV0UXVldWUucHVzaChuKSwhMH19LFNFPWNsYXNzIGV4dGVuZHMgdDh7Y29uc3RydWN0b3IoZSx0PXt9KXtzdXBlcigpLHRoaXMuZmlsZT1lLHRoaXMub3B0aW9ucz10LHcuYXNzZXJ0KGUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHwoRygpLmdldChcIklTX0JST1dTRVJcIik/ZSBpbnN0YW5jZW9mIEZpbGV8fGUgaW5zdGFuY2VvZiBCbG9iOiExKSwoKT0+XCJGaWxlQ2h1bmtJdGVyYXRvciBvbmx5IHN1cHBvcnRzIEZpbGUsIEJsb2IgYW5kIFVpbnQ4QXJyYXkgcmlnaHQgbm93LlwiKSx0aGlzLm9mZnNldD10Lm9mZnNldHx8MCx0aGlzLmNodW5rU2l6ZT10LmNodW5rU2l6ZXx8MTAyNCoxMDI0fXN1bW1hcnkoKXtyZXR1cm5gRmlsZUNodW5rcyAke3RoaXMuZmlsZX1gfWFzeW5jIG5leHQoKXtyZXR1cm4gdGhpcy5vZmZzZXQ+PSh0aGlzLmZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5P3RoaXMuZmlsZS5ieXRlTGVuZ3RoOnRoaXMuZmlsZS5zaXplKT97dmFsdWU6bnVsbCxkb25lOiEwfTp7dmFsdWU6YXdhaXQgbmV3IFByb21pc2UoKGUsdCk9PntsZXQgbj10aGlzLm9mZnNldCt0aGlzLmNodW5rU2l6ZTtpZih0aGlzLmZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KWUobmV3IFVpbnQ4QXJyYXkodGhpcy5maWxlLnNsaWNlKHRoaXMub2Zmc2V0LG4pKSk7ZWxzZXtsZXQgYT1uZXcgRmlsZVJlYWRlcjthLm9ubG9hZD1zPT57bGV0IGk9YS5yZXN1bHQ7aWYoaSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYoaT1uZXcgVWludDhBcnJheShpKSksIShpIGluc3RhbmNlb2YgVWludDhBcnJheSkpcmV0dXJuIHQobmV3IFR5cGVFcnJvcihcIkZpbGVSZWFkZXIgcmV0dXJuZWQgdW5rbm93biB0eXBlLlwiKSk7ZShpKX0sYS5vbmFib3J0PXM9PnQobmV3IEVycm9yKFwiQWJvcnRlZFwiKSksYS5vbmVycm9yPXM9PnQobmV3IEVycm9yKHMudHlwZSkpO2xldCByPXRoaXMuZmlsZS5zbGljZSh0aGlzLm9mZnNldCxuKTthLnJlYWRBc0FycmF5QnVmZmVyKHIpfXRoaXMub2Zmc2V0PW59KSxkb25lOiExfX19O2FzeW5jIGZ1bmN0aW9uIHI4KGUsdD17fSxuKXtsZXQgYSxyO3R5cGVvZiBlPT1cInN0cmluZ1wiP2E9ZTooYT1lLnVybCxyPXM4KGUpKTtsZXQgcz1hd2FpdChufHx3LmZldGNoKShhLHIpO2lmKHMub2spe2xldCBpPW5ldyBVaW50OEFycmF5KGF3YWl0IHMuYXJyYXlCdWZmZXIoKSk7cmV0dXJuIG5ldyBTRShpLHQpfWVsc2UgdGhyb3cgbmV3IEVycm9yKHMuc3RhdHVzVGV4dCl9dmFyIHM4PWU9Pih7bWV0aG9kOmUubWV0aG9kLGhlYWRlcnM6ZS5oZWFkZXJzLGJvZHk6ZS5ib2R5LG1vZGU6ZS5tb2RlLGNyZWRlbnRpYWxzOmUuY3JlZGVudGlhbHMsY2FjaGU6ZS5jYWNoZSxyZWRpcmVjdDplLnJlZGlyZWN0LHJlZmVycmVyOmUucmVmZXJyZXIsaW50ZWdyaXR5OmUuaW50ZWdyaXR5fSk7ZnVuY3Rpb24gTkUoZSl7cmV0dXJuIHR5cGVvZiBlPT1cInN0cmluZ1wiJiZlLnNsaWNlKDAsNyk9PT1cImZpbGU6Ly9cIn12YXIgVEU9Y2xhc3MgZXh0ZW5kcyBrRXtjb25zdHJ1Y3RvcihlLHQ9e30pe3N1cGVyKCksdGhpcy5pbnB1dD1lLHRoaXMub3B0aW9ucz10fWFzeW5jIGl0ZXJhdG9yKCl7aWYoTkUodGhpcy5pbnB1dCkmJkcoKS5nZXQoXCJJU19OT0RFXCIpKXtsZXQgZT1JdigpO3RoaXMuaW5wdXQ9ZS5yZWFkRmlsZVN5bmModGhpcy5pbnB1dC5zbGljZSg3KSl9cmV0dXJuIG5ldyBTRSh0aGlzLmlucHV0LHRoaXMub3B0aW9ucyl9fSxDRT1jbGFzcyBleHRlbmRzIGtFe2NvbnN0cnVjdG9yKGUsdD17fSl7c3VwZXIoKSx0aGlzLnVybD1lLHRoaXMuZmlsZU9wdGlvbnM9dH1hc3luYyBpdGVyYXRvcigpe3JldHVybiBORSh0aGlzLnVybCk/bmV3IFRFKHRoaXMudXJsLHRoaXMuZmlsZU9wdGlvbnMpLml0ZXJhdG9yKCk6cjgodGhpcy51cmwsdGhpcy5maWxlT3B0aW9ucyl9fTtmdW5jdGlvbiBpOChlLHQ9e30pe3JldHVybiBuZXcgeEUobmV3IENFKGUpLHQpfWZ1bmN0aW9uIG84KGUpe2xldCB0PSQxKGUpO3JldHVybiBLbihhc3luYygpPT50KX1mdW5jdGlvbiBsOChlKXtyZXR1cm4gS24oYXN5bmMoKT0+e2xldCB0PWF3YWl0IGUoKTtyZXR1cm4gJDEoKCk9PnQubmV4dCgpKX0pfWFzeW5jIGZ1bmN0aW9uIHU4KGUsdCl7cmV0dXJuIEo1LmNyZWF0ZShlLHQpfWFzeW5jIGZ1bmN0aW9uIHA4KGUpe3JldHVybiBaNS5jcmVhdGUoZSl9dmFyIGM4PVwiNC4yMi4wXCI7ZnVuY3Rpb24gZ2UoZSx0KXtBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLGUuZm9yRWFjaChuPT57biE9bnVsbCYmdy5hc3NlcnQobi5kdHlwZSE9PVwiY29tcGxleDY0XCIsKCk9PmAke3R9IGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IHRlbnNvcnMgaW4gdGhlIENQVSBiYWNrZW5kLmApfSl9dmFyIGQ4PW1yLndoZXJlSW1wbCxSMT1jbGFzcyBFRSBleHRlbmRzIEZje25leHREYXRhSWQoKXtyZXR1cm4gRUUubmV4dERhdGFJZCsrfWNvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmJsb2NrU2l6ZT00OCx0aGlzLmZpcnN0VXNlPSEwLHRoaXMuZGF0YT1uZXcgeW0odGhpcyxUYSgpKX13cml0ZSh0LG4sYSl7dGhpcy5maXJzdFVzZSYmKHRoaXMuZmlyc3RVc2U9ITEsRygpLmdldChcIklTX05PREVcIikmJlQud2FybihgXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5IaSwgbG9va3MgbGlrZSB5b3UgYXJlIHJ1bm5pbmcgVGVuc29yRmxvdy5qcyBpbiBOb2RlLmpzLiBUbyBzcGVlZCB0aGluZ3MgdXAgZHJhbWF0aWNhbGx5LCBpbnN0YWxsIG91ciBub2RlIGJhY2tlbmQsIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtbm9kZSBmb3IgbW9yZSBkZXRhaWxzLiBcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1gKSk7bGV0IHI9e2lkOnRoaXMubmV4dERhdGFJZCgpfTtyZXR1cm4gdGhpcy5kYXRhLnNldChyLHt2YWx1ZXM6dCxkdHlwZTphLHJlZkNvdW50OjF9KSxyfW1ha2VUZW5zb3JJbmZvKHQsbixhKXtsZXQgcjtpZihuPT09XCJzdHJpbmdcIiYmYSE9bnVsbCYmYS5sZW5ndGg+MCYmdy5pc1N0cmluZyhhWzBdKSl7bGV0IHM9YS5tYXAoaT0+dy5lbmNvZGVTdHJpbmcoaSkpO3I9dGhpcy53cml0ZShzLHQsbil9ZWxzZSByPXRoaXMud3JpdGUoYSx0LG4pO3JldHVybntkYXRhSWQ6cixzaGFwZTp0LGR0eXBlOm59fXJlZkNvdW50KHQpe3JldHVybiB0aGlzLmRhdGEuaGFzKHQpP3RoaXMuZGF0YS5nZXQodCkucmVmQ291bnQ6MH1pbmNSZWYodCl7bGV0IG49dGhpcy5kYXRhLmdldCh0KTtuLnJlZkNvdW50Kyt9ZGVjUmVmKHQpe2lmKHRoaXMuZGF0YS5oYXModCkpe2xldCBuPXRoaXMuZGF0YS5nZXQodCk7bi5yZWZDb3VudC0tfX1tb3ZlKHQsbixhLHIscyl7dGhpcy5kYXRhLnNldCh0LHt2YWx1ZXM6bixkdHlwZTpyLHJlZkNvdW50OnN9KX1udW1EYXRhSWRzKCl7cmV0dXJuIHRoaXMuZGF0YS5udW1EYXRhSWRzKCl9YXN5bmMgcmVhZCh0KXtyZXR1cm4gdGhpcy5yZWFkU3luYyh0KX1yZWFkU3luYyh0KXtsZXR7ZHR5cGU6bixjb21wbGV4VGVuc29ySW5mb3M6YX09dGhpcy5kYXRhLmdldCh0KTtpZihuPT09XCJjb21wbGV4NjRcIil7bGV0IHI9dGhpcy5yZWFkU3luYyhhLnJlYWwuZGF0YUlkKSxzPXRoaXMucmVhZFN5bmMoYS5pbWFnLmRhdGFJZCk7cmV0dXJuIFQubWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhyLHMpfXJldHVybiB3LmNvbnZlcnRCYWNrZW5kVmFsdWVzQW5kQXJyYXlCdWZmZXIodGhpcy5kYXRhLmdldCh0KS52YWx1ZXMsbil9YnVmZmVyU3luYyh0KXtsZXQgbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKTtpZih0LmR0eXBlPT09XCJzdHJpbmdcIil0cnl7bGV0IGE9bi5tYXAocj0+dy5kZWNvZGVTdHJpbmcocikpO3JldHVybiBPZSh0LnNoYXBlLHQuZHR5cGUsYSl9Y2F0Y2goYSl7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSBlbmNvZGVkIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04XCIpfXJldHVybiBPZSh0LnNoYXBlLHQuZHR5cGUsbil9bWFrZU91dHB1dCh0LG4sYSl7cmV0dXJuIFRhKCkubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKHRoaXMubWFrZVRlbnNvckluZm8obixhLHQpLHRoaXMpfWRpc3Bvc2VEYXRhKHQsbj0hMSl7aWYodGhpcy5kYXRhLmhhcyh0KSl7aWYodGhpcy5kYXRhLmdldCh0KS5yZWZDb3VudC0tLCFuJiZ0aGlzLmRhdGEuZ2V0KHQpLnJlZkNvdW50PjApcmV0dXJuITE7bGV0e2NvbXBsZXhUZW5zb3JJbmZvczphfT10aGlzLmRhdGEuZ2V0KHQpO2EhPW51bGwmJih0aGlzLmRpc3Bvc2VEYXRhKGEucmVhbC5kYXRhSWQsITApLHRoaXMuZGlzcG9zZURhdGEoYS5pbWFnLmRhdGFJZCwhMCkpLHRoaXMuZGF0YS5kZWxldGUodCl9cmV0dXJuITB9ZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCl7dGhpcy5kaXNwb3NlRGF0YSh0LmRhdGFJZCl9YXN5bmMgdGltZSh0KXtsZXQgbj13Lm5vdygpO3JldHVybiB0KCkse2tlcm5lbE1zOncubm93KCktbn19bWVtb3J5KCl7cmV0dXJue3VucmVsaWFibGU6ITAscmVhc29uczpbXCJUaGUgcmVwb3J0ZWQgbWVtb3J5IGlzIGFuIHVwcGVyIGJvdW5kLiBEdWUgdG8gYXV0b21hdGljIGdhcmJhZ2UgY29sbGVjdGlvbiwgdGhlIHRydWUgYWxsb2NhdGVkIG1lbW9yeSBtYXkgYmUgbGVzcy5cIl19fXdoZXJlKHQpe2dlKFt0XSxcIndoZXJlXCIpO2xldCBuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpO3JldHVybiBkOCh0LnNoYXBlLG4pfWRpc3Bvc2UoKXt9ZmxvYXRQcmVjaXNpb24oKXtyZXR1cm4gMzJ9ZXBzaWxvbigpe3JldHVybiBzdXBlci5lcHNpbG9uKCl9fTtSMS5uZXh0RGF0YUlkPTA7dmFyIE0xPXt9O19lKE0xLHthZGRJbXBsOigpPT5GRSxiaW5jb3VudEltcGw6KCk9PlAxLGJpbmNvdW50UmVkdWNlSW1wbDooKT0+JEUsYml0d2lzZUFuZEltcGw6KCk9PkRFLGNhc3RJbXBsOigpPT5BRSxjZWlsSW1wbDooKT0+UkUsY29uY2F0SW1wbDooKT0+TDEsZXF1YWxJbXBsOigpPT5NRSxleHBJbXBsOigpPT5QRSxleHBtMUltcGw6KCk9PnpFLGZsb29yRGl2SW1wbDooKT0+QkUsZmxvb3JJbXBsOigpPT5XRSxnYXRoZXJOZEltcGw6KCk9PlZFLGdhdGhlclYySW1wbDooKT0+VUUsZ3JlYXRlckVxdWFsSW1wbDooKT0+SEUsZ3JlYXRlckltcGw6KCk9PkdFLGxlc3NFcXVhbEltcGw6KCk9PnFFLGxlc3NJbXBsOigpPT5qRSxsaW5TcGFjZUltcGw6KCk9PktFLGxvZ0ltcGw6KCk9PlhFLG1heEltcGw6KCk9PllFLG1heGltdW1JbXBsOigpPT5aRSxtaW5pbXVtSW1wbDooKT0+SkUsbXVsdGlwbHlJbXBsOigpPT56MSxuZWdJbXBsOigpPT5RRSxub3RFcXVhbEltcGw6KCk9PmVfLHByb2RJbXBsOigpPT50XyxyYWdnZWRHYXRoZXJJbXBsOigpPT5uXyxyYWdnZWRSYW5nZUltcGw6KCk9PmFfLHJhZ2dlZFRlbnNvclRvVGVuc29ySW1wbDooKT0+cl8scmFuZ2VJbXBsOigpPT5CMSxyc3FydEltcGw6KCk9PnNfLHNjYXR0ZXJJbXBsOigpPT5uaSxzaWdtb2lkSW1wbDooKT0+Y0ssc2ltcGxlQWJzSW1wbDooKT0+X0Usc2xpY2VJbXBsOigpPT51bSxzcGFyc2VGaWxsRW1wdHlSb3dzSW1wbDooKT0+b18sc3BhcnNlUmVzaGFwZUltcGw6KCk9PmxfLHNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25JbXBsOigpPT5WMSxzcXJ0SW1wbDooKT0+bUssc3F1YXJlZERpZmZlcmVuY2VJbXBsOigpPT51XyxzdGF0aWNSZWdleFJlcGxhY2VJbXBsOigpPT5wXyxzdHJpZGVkU2xpY2VJbXBsOigpPT5jXyxzdHJpbmdOR3JhbXNJbXBsOigpPT5VMSxzdHJpbmdTcGxpdEltcGw6KCk9PkcxLHN0cmluZ1RvSGFzaEJ1Y2tldEZhc3RJbXBsOigpPT5IMSxzdWJJbXBsOigpPT5kXyx0aWxlSW1wbDooKT0+aF8sdG9wS0ltcGw6KCk9PmZfLHRyYW5zcG9zZUltcGw6KCk9PlcxLHVuaXF1ZUltcGw6KCk9PnExfSk7ZnVuY3Rpb24gX0UoZSl7bGV0IHQ9bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pdFtuXT1NYXRoLmFicyhlW25dKTtyZXR1cm4gdH12YXIgaDg9ZT0+e2xldHt4OnR9PWUuaW5wdXRzLG49ZS5iYWNrZW5kO2dlKHQsXCJhYnNcIik7bGV0IGE9bmV3IEZsb2F0MzJBcnJheSh3LnNpemVGcm9tU2hhcGUodC5zaGFwZSkpLHI9bi5kYXRhLmdldCh0LmRhdGFJZCkudmFsdWVzO3JldHVybiBhPV9FKHIpLG4ubWFrZU91dHB1dChhLHQuc2hhcGUsdC5kdHlwZSl9LG04PXtrZXJuZWxOYW1lOllsLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpoOH07ZnVuY3Rpb24gTXQoZSl7cmV0dXJuKHQsbixhLHIscyk9PntsZXQgaT1ULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHQsbiksbz1pLmxlbmd0aCxsPXcuY29tcHV0ZVN0cmlkZXMoaSksdT13LnNpemVGcm9tU2hhcGUoaSkscD13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUocyx1KSxkPXQubGVuZ3RoLGM9bi5sZW5ndGgsaD13LmNvbXB1dGVTdHJpZGVzKHQpLG09dy5jb21wdXRlU3RyaWRlcyhuKSxmPVQuZ2V0QnJvYWRjYXN0RGltcyh0LGkpLGc9VC5nZXRCcm9hZGNhc3REaW1zKG4saSk7aWYoZi5sZW5ndGgrZy5sZW5ndGg9PT0wKWZvcihsZXQgYj0wO2I8cC5sZW5ndGg7KytiKXBbYl09ZShhW2IlYS5sZW5ndGhdLHJbYiVyLmxlbmd0aF0pO2Vsc2UgZm9yKGxldCBiPTA7YjxwLmxlbmd0aDsrK2Ipe2xldCB5PXcuaW5kZXhUb0xvYyhiLG8sbCkseD15LnNsaWNlKC1kKTtmLmZvckVhY2goQz0+eFtDXT0wKTtsZXQgdj13LmxvY1RvSW5kZXgoeCxkLGgpLEk9eS5zbGljZSgtYyk7Zy5mb3JFYWNoKEM9PklbQ109MCk7bGV0IE49dy5sb2NUb0luZGV4KEksYyxtKTtwW2JdPWUoYVt2XSxyW05dKX1yZXR1cm5bcCxpXX19ZnVuY3Rpb24gWW4oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7cmVhbDphLGltYWc6cn09dCxzPW4uZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxpPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxvPW4ubWFrZVRlbnNvckluZm8oYS5zaGFwZSxcImNvbXBsZXg2NFwiKSxsPW4uZGF0YS5nZXQoby5kYXRhSWQpO3JldHVybiBsLmNvbXBsZXhUZW5zb3JJbmZvcz17cmVhbDpuLm1ha2VUZW5zb3JJbmZvKGEuc2hhcGUsXCJmbG9hdDMyXCIscyksaW1hZzpuLm1ha2VUZW5zb3JJbmZvKHIuc2hhcGUsXCJmbG9hdDMyXCIsaSl9LG99dmFyIGY4PXtrZXJuZWxOYW1lOndtLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpZbn07ZnVuY3Rpb24gbG0oZSx0LG49XCJmbG9hdDMyXCIpe2lmKG49PT1cImNvbXBsZXg2NFwiKXtsZXQgcj1sbShlLHQsXCJmbG9hdDMyXCIpLHM9bG0oZSx0LFwiZmxvYXQzMlwiKTtyZXR1cm4gWW4oe2lucHV0czp7cmVhbDpyLGltYWc6c30sYmFja2VuZDplfSl9bGV0IGE9dy5tYWtlWmVyb3NUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZSh0KSxuKTtyZXR1cm4gZS5tYWtlVGVuc29ySW5mbyh0LG4sYSl9ZnVuY3Rpb24gY3IoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O3JldHVybiBuLmluY1JlZihhLmRhdGFJZCkse2RhdGFJZDphLmRhdGFJZCxzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGV9fXZhciBnOD17a2VybmVsTmFtZTplbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Y3J9O2Z1bmN0aW9uIHlpKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2lucHV0OmF9PXQscj1uLmRhdGEuZ2V0KGEuZGF0YUlkKS5jb21wbGV4VGVuc29ySW5mb3MucmVhbCxzPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcztyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLHIuZHR5cGUscyl9dmFyIGI4PXtrZXJuZWxOYW1lOkRtLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp5aX07ZnVuY3Rpb24gQUUoZSx0LG4sYSl7aWYoYT09PVwiaW50MzJcIil7bGV0IHI9SW50MzJBcnJheS5mcm9tKGUpO3JldHVyblt0LFwiaW50MzJcIixyXX1pZihhPT09XCJib29sXCIpe2xldCByPXcudG9UeXBlZEFycmF5KFswXSxuKSxbcyxpXT1NdCgobyxsKT0+byE9PWw/MTowKSh0LFtdLGUscixcImJvb2xcIik7cmV0dXJuW2ksXCJib29sXCIsc119dGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBDYXN0OiBmYWlsZWQgdG8gY2FzdCAke259IHRvICR7YX1gKX1mdW5jdGlvbiBicyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZHR5cGU6c309YTtpZihzPT09XCJjb21wbGV4NjRcIil7aWYoci5kdHlwZT09PVwiY29tcGxleDY0XCIpcmV0dXJuIGNyKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7bGV0IHA9bG0obixyLnNoYXBlLHIuZHR5cGUpLGQ9YnMoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e2R0eXBlOlwiZmxvYXQzMlwifX0pLGM9WW4oe2lucHV0czp7cmVhbDpkLGltYWc6cH0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhkKSxjfWlmKHIuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgcD15aSh7aW5wdXRzOntpbnB1dDpyfSxiYWNrZW5kOm59KSxkPWJzKHtpbnB1dHM6e3g6cH0sYmFja2VuZDpuLGF0dHJzOntkdHlwZTpzfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApLGR9aWYoIXcuaGFzRW5jb2RpbmdMb3NzKHIuZHR5cGUscykpe2xldCBwPWNyKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7cmV0dXJue2RhdGFJZDpwLmRhdGFJZCxzaGFwZTpwLnNoYXBlLGR0eXBlOnN9fWxldCBpPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxbbyxsLHVdPUFFKGksci5zaGFwZSxyLmR0eXBlLHMpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKG8sbCx1KX12YXIgeTg9e2tlcm5lbE5hbWU6TWksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmJzfTtmdW5jdGlvbiBadChlLHQsbixhKXtyZXR1cm4gbj09bnVsbD8oe2lucHV0czpyLGJhY2tlbmQ6c30pPT57bGV0e2E6aSxiOm99PXIsbD1zO2dlKFtpLG9dLGUpO2xldCB1PWwuZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlcyxwPWwuZGF0YS5nZXQoby5kYXRhSWQpLnZhbHVlcyxkPWkuZHR5cGU9PT1cInN0cmluZ1wiP1QuZnJvbVVpbnQ4VG9TdHJpbmdBcnJheSh1KTp1LGM9aS5kdHlwZT09PVwic3RyaW5nXCI/VC5mcm9tVWludDhUb1N0cmluZ0FycmF5KHApOnAsaD1hfHxpLmR0eXBlLFttLGZdPXQoaS5zaGFwZSxvLnNoYXBlLGQsYyxoKTtyZXR1cm4gbC5tYWtlVGVuc29ySW5mbyhmLGgsbSl9Oih7aW5wdXRzOnIsYmFja2VuZDpzfSk9PntsZXR7YTppLGI6b309cixsPXM7aWYoaS5kdHlwZT09PVwiY29tcGxleDY0XCJ8fG8uZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgdT1icyh7aW5wdXRzOnt4Oml9LGJhY2tlbmQ6bCxhdHRyczp7ZHR5cGU6XCJjb21wbGV4NjRcIn19KSxwPWwuZGF0YS5nZXQodS5kYXRhSWQpLGQ9cC5jb21wbGV4VGVuc29ySW5mb3MucmVhbCxjPXAuY29tcGxleFRlbnNvckluZm9zLmltYWcsaD1sLmRhdGEuZ2V0KGQuZGF0YUlkKS52YWx1ZXMsbT1sLmRhdGEuZ2V0KGMuZGF0YUlkKS52YWx1ZXMsZj1icyh7aW5wdXRzOnt4Om99LGJhY2tlbmQ6bCxhdHRyczp7ZHR5cGU6XCJjb21wbGV4NjRcIn19KSxnPWwuZGF0YS5nZXQoZi5kYXRhSWQpLGI9Zy5jb21wbGV4VGVuc29ySW5mb3MucmVhbCx5PWcuY29tcGxleFRlbnNvckluZm9zLmltYWcseD1sLmRhdGEuZ2V0KGIuZGF0YUlkKS52YWx1ZXMsdj1sLmRhdGEuZ2V0KHkuZGF0YUlkKS52YWx1ZXMsW0ksTixDXT1uKGkuc2hhcGUsby5zaGFwZSxoLG0seCx2KSxfPWwubWFrZVRlbnNvckluZm8oQyxcImZsb2F0MzJcIixJKSxGPWwubWFrZVRlbnNvckluZm8oQyxcImZsb2F0MzJcIixOKSxEPVluKHtpbnB1dHM6e3JlYWw6XyxpbWFnOkZ9LGJhY2tlbmQ6bH0pO3JldHVybiBsLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHUpLGwuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksbC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhfKSxsLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEYpLER9ZWxzZXtsZXQgdT1sLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMscD1sLmRhdGEuZ2V0KG8uZGF0YUlkKS52YWx1ZXMsZD1hfHxpLmR0eXBlLFtjLGhdPXQoaS5zaGFwZSxvLnNoYXBlLHUscCxkKTtyZXR1cm4gbC5tYWtlVGVuc29ySW5mbyhoLGQsYyl9fX1mdW5jdGlvbiBPMShlKXtyZXR1cm4odCxuLGEscixzLGkpPT57bGV0IG89VC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LG4pLGw9dy5zaXplRnJvbVNoYXBlKG8pLHU9by5sZW5ndGgscD13LmNvbXB1dGVTdHJpZGVzKG8pLGQ9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKFwiZmxvYXQzMlwiLGwpLGM9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKFwiZmxvYXQzMlwiLGwpLGg9VC5nZXRCcm9hZGNhc3REaW1zKHQsbyksbT1ULmdldEJyb2FkY2FzdERpbXMobixvKSxmPVQubWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhhLHIpLGc9VC5tZXJnZVJlYWxBbmRJbWFnQXJyYXlzKHMsaSksYj10Lmxlbmd0aCx5PXcuY29tcHV0ZVN0cmlkZXModCkseD1uLmxlbmd0aCx2PXcuY29tcHV0ZVN0cmlkZXMobik7aWYoaC5sZW5ndGgrbS5sZW5ndGg9PT0wKWZvcihsZXQgST0wO0k8ZC5sZW5ndGg7SSsrKXtsZXQgTj1JJWYubGVuZ3RoLEM9SSVnLmxlbmd0aCxfPWUoZltOKjJdLGZbTioyKzFdLGdbQyoyXSxnW0MqMisxXSk7ZFtJXT1fLnJlYWwsY1tJXT1fLmltYWd9ZWxzZSBmb3IobGV0IEk9MDtJPGQubGVuZ3RoO0krKyl7bGV0IE49dy5pbmRleFRvTG9jKEksdSxwKSxDPU4uc2xpY2UoLWIpO2guZm9yRWFjaChTPT5DW1NdPTApO2xldCBfPXcubG9jVG9JbmRleChDLGIseSksRj1OLnNsaWNlKC14KTttLmZvckVhY2goUz0+RltTXT0wKTtsZXQgRD13LmxvY1RvSW5kZXgoRix4LHYpLCQ9ZShmW18qMl0sZltfKjIrMV0sZ1tEKjJdLGdbRCoyKzFdKTtkW0ldPSQucmVhbCxjW0ldPSQuaW1hZ31yZXR1cm5bZCxjLG9dfX12YXIgRkU9TXQoKGUsdCk9PmUrdCkseDg9TzEoKGUsdCxuLGEpPT4oe3JlYWw6ZStuLGltYWc6dCthfSkpLGpsPVp0KHZzLEZFLHg4KSx2OD17a2VybmVsTmFtZTp2cyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6amx9O2Z1bmN0aW9uIFAxKGUsdCxuLGEscil7bGV0IHM9dy5zaXplRnJvbVNoYXBlKGEpLGk9dy5tYWtlWmVyb3NUeXBlZEFycmF5KHIsbik7Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDtvKyspe2xldCBsPWVbb107aWYobDwwKXRocm93IG5ldyBFcnJvcihcIklucHV0IHggbXVzdCBiZSBub24tbmVnYXRpdmUhXCIpO2w+PXJ8fChzPjA/aVtsXSs9dFtvXTppW2xdKz0xKX1yZXR1cm4gaX1mdW5jdGlvbiAkRShlLHQsbixhPSExKXtsZXQgcj1lLnNoYXBlWzBdLHM9ZS5zaGFwZVsxXSxpPU9lKFtyLG5dLHQuZHR5cGUpO2ZvcihsZXQgbz0wO288cjtvKyspZm9yKGxldCBsPTA7bDxzO2wrKyl7bGV0IHU9ZS5nZXQobyxsKTtpZih1PDApdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgeCBtdXN0IGJlIG5vbi1uZWdhdGl2ZSFcIik7dT49bnx8KGE/aS5zZXQoMSxvLHUpOnQuc2l6ZT4wP2kuc2V0KGkuZ2V0KG8sdSkrdC5nZXQobyxsKSxvLHUpOmkuc2V0KGkuZ2V0KG8sdSkrMSxvLHUpKX1yZXR1cm4gaX12YXIgREU9TXQoKGUsdCk9PmUmdCksdzg9WnQocnUsREUpLGs4PXtrZXJuZWxOYW1lOnJ1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp3OH07ZnVuY3Rpb24gZnIoZSl7cmV0dXJuKHQsbixhKT0+e2xldCByPXcuZ2V0QXJyYXlGcm9tRFR5cGUobix0Lmxlbmd0aCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDsrK3MpcltzXT1lKHRbc10sYSk7cmV0dXJuIHJ9fWZ1bmN0aW9uIGx0KGUsdCxuKXtsZXQgYT1mcih0KTtyZXR1cm4gRnMoZSxhLG4pfWZ1bmN0aW9uIEZzKGUsdCxuKXtyZXR1cm4oe2lucHV0czphLGF0dHJzOnIsYmFja2VuZDpzfSk9PntsZXR7eDppfT1hO2dlKGksZSk7bGV0IG89cyxsPW8uZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlcyx1O2lmKGkuZHR5cGU9PT1cInN0cmluZ1wiKXtpZighQXJyYXkuaXNBcnJheShsKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yJ3MgdmFsdWUgd2FzIG5vdCBhbiBpbnN0YW5jZSBvZiBBcnJheVwiKTt1PVQuZnJvbVVpbnQ4VG9TdHJpbmdBcnJheShsKX1lbHNlIHU9bDtsZXQgcD1ufHxpLmR0eXBlLGQ9dCh1LHAscik7cmV0dXJuIG8ubWFrZVRlbnNvckluZm8oaS5zaGFwZSxwLGQpfX12YXIgUkU9ZnIoZT0+TWF0aC5jZWlsKGUpKSxJOD1GcyhPaSxSRSksUzg9e2tlcm5lbE5hbWU6T2ksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkk4fTtmdW5jdGlvbiBMMShlLHQsbixhKXtsZXQgcj13LmdldEFycmF5RnJvbURUeXBlKG4sdy5zaXplRnJvbVNoYXBlKHQpKTtpZihhJiZuIT09XCJzdHJpbmdcIil7bGV0IHM9MDtlLmZvckVhY2goaT0+e2xldCBvPXcuc2l6ZUZyb21TaGFwZShpLnNoYXBlKTtyLnNldChpLnZhbHMscykscys9b30pfWVsc2V7bGV0IHM9MDtlLmZvckVhY2goaT0+e2xldCBvPW49PT1cInN0cmluZ1wiP1QuZnJvbVVpbnQ4VG9TdHJpbmdBcnJheShpLnZhbHMpOmkudmFscyxsPTA7Zm9yKGxldCB1PTA7dTxpLnNoYXBlWzBdOysrdSl7bGV0IHA9dSp0WzFdK3M7Zm9yKGxldCBkPTA7ZDxpLnNoYXBlWzFdOysrZClyW3ArZF09b1tsKytdfXMrPWkuc2hhcGVbMV19KX1yZXR1cm4gcn12YXIgTUU9TXQoKGUsdCk9PmU9PT10PzE6MCksT0U9WnQoZHUsTUUsbnVsbCxcImJvb2xcIiksTjg9e2tlcm5lbE5hbWU6ZHUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOk9FfSxQRT1mcihlPT5NYXRoLmV4cChlKSksTEU9RnMoS2ksUEUsXCJmbG9hdDMyXCIpLFQ4PXtrZXJuZWxOYW1lOktpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpMRX0sekU9ZnIoZT0+TWF0aC5leHBtMShlKSksQzg9RnMoWGksekUpLEU4PXtrZXJuZWxOYW1lOlhpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpDOH0sV0U9ZnIoZT0+TWF0aC5mbG9vcihlKSksXzg9RnMoWWksV0UpLEE4PXtrZXJuZWxOYW1lOllpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpfOH0sQkU9TXQoKGUsdCk9Pk1hdGguZmxvb3IoZS90KSksRjg9WnQoWmksQkUsbnVsbCxcImludDMyXCIpLCQ4PXtrZXJuZWxOYW1lOlppLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpGOH07ZnVuY3Rpb24gVkUoZSx0LG4sYSxyLHMsaSxvLGwpe2xldCB1PU9lKFthLHNdLG4pO2ZvcihsZXQgcD0wO3A8YTtwKyspe2xldCBkPVtdLGM9MDtmb3IobGV0IGg9MDtoPHI7aCsrKXtsZXQgbT1lW3AqcitoXTtjKz1tKmlbaF0sZC5wdXNoKG0pfWlmKGM8MHx8Yz49bC9zKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbmRpY2VzOiAke2R9IGRvZXMgbm90IGluZGV4IGludG8gJHtvfWApO2ZvcihsZXQgaD0wO2g8cztoKyspdS52YWx1ZXNbcCpzK2hdPXQuZ2V0KC4uLnQuaW5kZXhUb0xvYyhjKnMraCkpfXJldHVybiB1fWZ1bmN0aW9uIFVFKGUsdCxuKXtsZXQgYT1PZShuLGUuZHR5cGUpO2ZvcihsZXQgcj0wO3I8YS5zaXplOysrcil7bGV0IHM9YS5pbmRleFRvTG9jKHIpLnNsaWNlKCksaT1zWzBdLG89c1syXSxsPXQubG9jVG9JbmRleChbaSxvXSk7c1syXT10LnZhbHVlc1tsXTtsZXQgdT1lLmxvY1RvSW5kZXgocyk7MDw9dSYmdTxlLnZhbHVlcy5sZW5ndGgmJihhLnZhbHVlc1tyXT1lLnZhbHVlc1t1XSl9cmV0dXJuIGF9dmFyIEdFPU10KChlLHQpPT5lPnQ/MTowKSxEOD1adChidSxHRSxudWxsLFwiYm9vbFwiKSxSOD17a2VybmVsTmFtZTpidSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6RDh9LEhFPU10KChlLHQpPT5lPj10PzE6MCksTTg9WnQoUWksSEUsbnVsbCxcImJvb2xcIiksTzg9e2tlcm5lbE5hbWU6UWksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOk04fSxqRT1NdCgoZSx0KT0+ZTx0PzE6MCksUDg9WnQoeXUsakUsbnVsbCxcImJvb2xcIiksTDg9e2tlcm5lbE5hbWU6eXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlA4fSxxRT1NdCgoZSx0KT0+ZTw9dD8xOjApLHo4PVp0KHh1LHFFLG51bGwsXCJib29sXCIpLFc4PXtrZXJuZWxOYW1lOnh1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp6OH07ZnVuY3Rpb24gS0UoZSx0LG4pe2xldCBhPSh0LWUpLyhuLTEpLHI9dy5tYWtlWmVyb3NUeXBlZEFycmF5KG4sXCJmbG9hdDMyXCIpO3JbMF09ZTtmb3IobGV0IHM9MTtzPHIubGVuZ3RoO3MrKylyW3NdPXJbcy0xXSthO3JldHVybiByfXZhciBYRT1mcihlPT5NYXRoLmxvZyhlKSksQjg9RnMoc28sWEUpLFY4PXtrZXJuZWxOYW1lOnNvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpCOH07ZnVuY3Rpb24gWUUoZSx0LG4sYSl7bGV0IHI9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGEsdy5zaXplRnJvbVNoYXBlKG4pKTtmb3IobGV0IHM9MDtzPHIubGVuZ3RoOysrcyl7bGV0IGk9cyp0LG89ZVtpXTtmb3IobGV0IGw9MDtsPHQ7KytsKXtsZXQgdT1lW2krbF07KE51bWJlci5pc05hTih1KXx8dT5vKSYmKG89dSl9cltzXT1vfXJldHVybiByfXZhciBaRT1NdCgoZSx0KT0+TWF0aC5tYXgoZSx0KSksVTg9WnQodW8sWkUpLEc4PXtrZXJuZWxOYW1lOnVvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpVOH0sSkU9TXQoKGUsdCk9Pk1hdGgubWluKGUsdCkpLEg4PVp0KG1vLEpFKSxqOD17a2VybmVsTmFtZTptbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6SDh9LHoxPU10KChlLHQpPT5lKnQpLHE4PU8xKChlLHQsbixhKT0+KHtyZWFsOmUqbi10KmEsaW1hZzplKmErdCpufSkpLHpmPVp0KGJvLHoxLHE4KSxLOD17a2VybmVsTmFtZTpibyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6emZ9O2Z1bmN0aW9uIFFFKGUsdCxuKXtsZXQgYT13LmNyZWF0ZVNjYWxhclZhbHVlKC0xLG4pO3JldHVybiB6MShbXSx0LGEsZSxuKX1mdW5jdGlvbiBYOChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQ7Z2UoYSxcIm5lZ1wiKTtsZXQgcj1uLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsW3MsaV09UUUocixhLnNoYXBlLGEuZHR5cGUpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGksYS5kdHlwZSxzKX12YXIgWTg9e2tlcm5lbE5hbWU6Q3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlg4fSxlXz1NdCgoZSx0KT0+ZSE9PXQ/MTowKSxaOD1adChFdSxlXyxudWxsLFwiYm9vbFwiKSxKOD17a2VybmVsTmFtZTpFdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Wjh9O2Z1bmN0aW9uIFcxKGUsdCxuLGEscil7bGV0IHM9dC5sZW5ndGgsaT13LnNpemVGcm9tU2hhcGUodCksbz13LmNvbXB1dGVTdHJpZGVzKHQpLGw9dy5jb21wdXRlU3RyaWRlcyhyKSx1PXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShuLHcuc2l6ZUZyb21TaGFwZShyKSk7Zm9yKGxldCBwPTA7cDxpOysrcCl7bGV0IGQ9dy5pbmRleFRvTG9jKHAscyxvKSxjPW5ldyBBcnJheShkLmxlbmd0aCk7Zm9yKGxldCBtPTA7bTxjLmxlbmd0aDttKyspY1ttXT1kW2FbbV1dO2xldCBoPXcubG9jVG9JbmRleChjLHMsbCk7dVtoXT1lW3BdfXJldHVybiB1fWZ1bmN0aW9uIFZuKGUpe2xldHtpbnB1dHM6dCxhdHRyczpuLGJhY2tlbmQ6YX09ZSx7eDpyfT10LHtwZXJtOnN9PW47Z2UocixcInRyYW5zcG9zZVwiKTtsZXQgaT1yLnNoYXBlLmxlbmd0aCxvPW5ldyBBcnJheShpKTtmb3IobGV0IHA9MDtwPG8ubGVuZ3RoO3ArKylvW3BdPXIuc2hhcGVbc1twXV07bGV0IGw9YS5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLHU9VzEobCxyLnNoYXBlLHIuZHR5cGUscyxvKTtyZXR1cm57ZGF0YUlkOmEud3JpdGUodSxvLHIuZHR5cGUpLHNoYXBlOm8sZHR5cGU6ci5kdHlwZX19dmFyIFE4PXtrZXJuZWxOYW1lOkNyLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpWbn07ZnVuY3Rpb24gdF8oZSx0LG4sYSl7bGV0W3Isc109VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGUsYSksaT1mYSh0LFwiaW50MzJcIiksbz13Lm1ha2VaZXJvc1R5cGVkQXJyYXkody5zaXplRnJvbVNoYXBlKHIpLGkpLGw9dy5zaXplRnJvbVNoYXBlKHMpO2ZvcihsZXQgdT0wO3U8by5sZW5ndGg7Kyt1KXtsZXQgcD11KmwsZD0xO2ZvcihsZXQgYz0wO2M8bDsrK2MpZCo9bltwK2NdO29bdV09ZH1yZXR1cm57b3V0VmFsczpvLG91dFNoYXBlOnIsb3V0RHR5cGU6aX19ZnVuY3Rpb24gZUsoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxrZWVwRGltczppfT1hO2dlKHIsXCJwcm9kXCIpO2xldCBvPXIuc2hhcGUubGVuZ3RoLGw9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLHU9VC5nZXRBeGVzUGVybXV0YXRpb24obCxvKSxwPWwsZD1yLGM9W107dSE9bnVsbCYmKGQ9Vm4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06dX19KSxjLnB1c2goZCkscD1ULmdldElubmVyTW9zdEF4ZXMocC5sZW5ndGgsbykpO2xldCBoPW4uZGF0YS5nZXQoZC5kYXRhSWQpLnZhbHVlcyx7b3V0VmFsczptLG91dFNoYXBlOmYsb3V0RHR5cGU6Z309dF8oZC5zaGFwZSxkLmR0eXBlLGgscCksYj1mO3JldHVybiBpJiYoYj1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGYsbCkpLGMuZm9yRWFjaCh5PT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpKSxuLm1ha2VUZW5zb3JJbmZvKGIsZyxtKX12YXIgdEs9e2tlcm5lbE5hbWU6a28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmVLfTtmdW5jdGlvbiBuSyhlLHQsbil7ZS5mb3JFYWNoKChhLHIpPT57aWYoYTwwfHxhPj1uKXtsZXQgcz13LmluZGV4VG9Mb2Mocix0Lmxlbmd0aCx3LmNvbXB1dGVTdHJpZGVzKHQpKS5qb2luKFwiLFwiKTt0aHJvdyBuZXcgRXJyb3IoYGluZGljZXNbJHtzfV0gPSAke2F9IGlzIG5vdCBpbiBbMCwgJHtufSlgKX19KX1mdW5jdGlvbiBhSyhlLHQpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKXtsZXQgYT1lW25dLHI9bj09PWUubGVuZ3RoLTE/dDplW24rMV0ubGVuZ3RoO2lmKGEubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSYWdnZWQgc3BsaXRzIG1heSBub3QgYmUgZW1wdHlcIik7aWYoYVswXTwwKXRocm93IG5ldyBFcnJvcihcIlJhZ2dlZCBzcGxpdHMgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7aWYoYVthLmxlbmd0aC0xXT5yKXRocm93IG5ldyBFcnJvcihcIlJhZ2dlZCBzcGxpdHMgbXVzdCBub3QgcG9pbnQgcGFzdCB2YWx1ZXNcIik7Zm9yKGxldCBzPTE7czxhLmxlbmd0aDsrK3MpaWYoYVtzLTFdPmFbc10pdGhyb3cgbmV3IEVycm9yKFwiUmFnZ2VkIHNwbGl0cyBtdXN0IGJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXJcIil9fWZ1bmN0aW9uIHJLKGUsdCxuLGEpe2xldCByPVtdLHM9MCxpPXQubGVuZ3RoLTErbi5sZW5ndGgsbz1uZXcgQXJyYXkoaSkuZmlsbChudWxsKS5tYXAoKCk9PlswXSk7YUsobixhKTtsZXQgbD0xO2ZvcihsZXQgdT0wO3U8dC5sZW5ndGgtMTsrK3Upe2wqPXRbdV07bGV0IHA9dFt1KzFdO2ZvcihsZXQgZD0xO2Q8bCsxOysrZClvW3VdLnB1c2goZCpwKX1mb3IobGV0IHU9MDt1PGUubGVuZ3RoOysrdSl7bGV0IHA9ZVt1XSxkPWVbdV0rMTtmb3IobGV0IGM9MDtjPG4ubGVuZ3RoOysrYyl7bGV0IGg9bltjXSxtPWMrdC5sZW5ndGgtMTtpZihtPj0wKXtsZXQgZj1vW21dLGc9ZltmLmxlbmd0aC0xXS1oW3BdO2ZvcihsZXQgYj1wO2I8ZDsrK2Ipb1ttXS5wdXNoKGhbYisxXStnKX1wPWhbcF0sZD1oW2RdfWQhPT1wJiYoci5wdXNoKFtwLGRdKSxzKz1kLXApfXJldHVybntvdXRTcGxpdHM6byx2YWx1ZVNsaWNlczpyLG51bVZhbHVlczpzfX1mdW5jdGlvbiBzSyhlKXtsZXQgdD1bXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbil7bGV0IGE9ZVtuXS5sZW5ndGgscj13LmdldEFycmF5RnJvbURUeXBlKFwiaW50MzJcIixhKTt0LnB1c2gociksZVtuXS5mb3JFYWNoKChzLGkpPT5yW2ldPXMpfXJldHVybiB0fWZ1bmN0aW9uIFlJKGUsdCl7bGV0IG49ZS5zbGljZSgwLHQpO2Zvcig7bi5sZW5ndGg8dDspbi5wdXNoKDEpO2ZvcihsZXQgYT10O2E8ZS5sZW5ndGg7YSsrKW5bdC0xXSo9ZVthXTtyZXR1cm4gbn1mdW5jdGlvbiBpSyhlLHQsbixhLHIscyl7bGV0IGk9WUkodCwyKVsxXSxvPVlJKHMsMilbMV0sbD0wO2ZvcihsZXQgdSBvZiBuKWZvcihsZXQgcD11WzBdO3A8dVsxXTsrK3Ape2ZvcihsZXQgZD0wO2Q8YTsrK2QpcltsKm8rZF09ZVtwKmkrZF07KytsfX1mdW5jdGlvbiBvSyhlLHQsbixhLHIpe2xldCBzPXQuc2xpY2UoKTtzWzBdPXI7bGV0IGk9dy5nZXRBcnJheUZyb21EVHlwZShuLHcuc2l6ZUZyb21TaGFwZShzKSksbz1lLmxlbmd0aCxsPW89PT0wPzA6by90WzBdO3JldHVybiBpSyhlLHQsYSxsLGkscyksW2ksc119ZnVuY3Rpb24gbl8oZSx0LG4sYSxyLHMsaSxvKXtpZihlLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwicGFyYW1zTmVzdGVkU3BsaXRzIG11c3QgYmUgbm9uIGVtcHR5XCIpO2lmKHRbMF0ubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJTcGxpdCB0ZW5zb3JzIG11c3Qgbm90IGJlIHNjYWxhcnNcIik7bGV0IGw9dFswXVswXS0xO2lmKG5LKHMsaSxsKSxhLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwicGFyYW1zLnJhbmsgbXVzdCBiZSBub256ZXJvXCIpO2xldCB1PWFbMF0se291dFNwbGl0czpwLHZhbHVlU2xpY2VzOmQsbnVtVmFsdWVzOmN9PXJLKHMsaSxlLHUpLGg9c0socCksbT1vSyhuLGEscixkLGMpO3JldHVybltoLG1bMF0sbVsxXV19dmFyIFpJPTIxNDc0ODM2NDc7ZnVuY3Rpb24gYV8oZSx0LG4sYSxyLHMsaSl7aWYodC5sZW5ndGg+MSl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMgbXVzdCBiZSBhIHNjYWxhciBvciB2ZWN0b3JcIik7aWYoci5sZW5ndGg+MSl0aHJvdyBuZXcgRXJyb3IoXCJsaW1pdHMgbXVzdCBiZSBhIHNjYWxhciBvciB2ZWN0b3JcIik7aWYoaS5sZW5ndGg+MSl0aHJvdyBuZXcgRXJyb3IoXCJkZWx0YXMgbXVzdCBiZSBhIHNjYWxhciBvciB2ZWN0b3JcIik7bGV0IG89dC5sZW5ndGg9PT0wLGw9ci5sZW5ndGg9PT0wLHU9aS5sZW5ndGg9PT0wLHA9W107b3x8cC5wdXNoKHRbMF0pLGx8fHAucHVzaChyWzBdKSx1fHxwLnB1c2goaVswXSk7Zm9yKGxldCBnPTE7ZzxwLmxlbmd0aDsrK2cpaWYocFtnXSE9PXBbZy0xXSl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMsIGxpbWl0cywgYW5kIGRlbHRhcyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7bGV0IGQ9cC5sZW5ndGg9PT0wPzE6cFswXSxjPXcuZ2V0QXJyYXlGcm9tRFR5cGUoXCJpbnQzMlwiLGQrMSk7Y1swXT0wO2ZvcihsZXQgZz0wO2c8ZDsrK2cpe2xldCBiPW8/ZVswXTplW2ddLHk9bD9hWzBdOmFbZ10seD11P3NbMF06c1tnXTtpZih4PT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlcyBkZWx0YSAhPSAwXCIpO2xldCB2O2lmKHg+MCYmeTxifHx4PDAmJnk+Yil2PTA7ZWxzZSBpZih2PU1hdGguY2VpbChNYXRoLmFicygoeS1iKS94KSksdj5aSSl0aHJvdyBuZXcgRXJyb3IoYFJlcXVpcmVzICgobGltaXQgLSBzdGFydCkgLyBkZWx0YSkgPD0gJHtaSX1gKTtjW2crMV09Y1tnXSt2fWxldCBoPWNbZF0sbT13LmdldEFycmF5RnJvbURUeXBlKG4saCksZj0wO2ZvcihsZXQgZz0wO2c8ZDsrK2cpe2xldCBiPWNbZysxXS1jW2ddLHk9bz9lWzBdOmVbZ10seD11P3NbMF06c1tnXTtmb3IobGV0IHY9MDt2PGI7Kyt2KW1bZisrXT15LHkrPXh9cmV0dXJuW2MsbV19dmFyIE5hPVQuUm93UGFydGl0aW9uVHlwZSxsSz1jbGFzcyBvdntjb25zdHJ1Y3Rvcih0LG4sYSxyLHMsaSxvLGwsdSxwKXt0aGlzLnNoYXBlPXQsdGhpcy5zaGFwZVNoYXBlPW4sdGhpcy52YWx1ZXM9YSx0aGlzLnZhbHVlc1NoYXBlPXIsdGhpcy52YWx1ZXNEVHlwZT1zLHRoaXMuZGVmYXVsdFZhbHVlPWksdGhpcy5kZWZhdWx0VmFsdWVTaGFwZT1vLHRoaXMucm93UGFydGl0aW9uVmFsdWVzPWwsdGhpcy5yb3dQYXJ0aXRpb25WYWx1ZXNTaGFwZXM9dSx0aGlzLnJvd1BhcnRpdGlvblR5cGVzPVQuZ2V0Um93UGFydGl0aW9uVHlwZXNIZWxwZXIocCksdGhpcy5yYWdnZWRSYW5rPVQuZ2V0UmFnZ2VkUmFuayh0aGlzLnJvd1BhcnRpdGlvblR5cGVzKX1nZXRSb3dQYXJ0aXRpb25UeXBlQnlEaW1lbnNpb24odCl7cmV0dXJuIHRoaXMucm93UGFydGl0aW9uVHlwZXNbMF09PT1OYS5GSVJTVF9ESU1fU0laRT90aGlzLnJvd1BhcnRpdGlvblR5cGVzW3QrMV06dGhpcy5yb3dQYXJ0aXRpb25UeXBlc1t0XX1nZXRSb3dQYXJ0aXRpb25UZW5zb3IodCl7cmV0dXJuIHRoaXMucm93UGFydGl0aW9uVHlwZXNbMF09PT1OYS5GSVJTVF9ESU1fU0laRT90aGlzLnJvd1BhcnRpdGlvblZhbHVlc1t0KzFdOnRoaXMucm93UGFydGl0aW9uVmFsdWVzW3RdfWdldE1heFdpZHRoKHQpe2xldCBuPXRoaXMuZ2V0Um93UGFydGl0aW9uVGVuc29yKHQtMSk7c3dpdGNoKHRoaXMuZ2V0Um93UGFydGl0aW9uVHlwZUJ5RGltZW5zaW9uKHQtMSkpe2Nhc2UgTmEuVkFMVUVfUk9XSURTOnJldHVybiBvdi5nZXRNYXhXaWR0aFZhbHVlUm93SUQobik7Y2FzZSBOYS5ST1dfU1BMSVRTOnJldHVybiBvdi5nZXRNYXhXaWR0aFJvd1NwbGl0KG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaGFuZGxlIHBhcnRpdGlvbiB0eXBlICR7TmFbdGhpcy5nZXRSb3dQYXJ0aXRpb25UeXBlQnlEaW1lbnNpb24odC0xKV19YCl9fXN0YXRpYyBnZXRNYXhXaWR0aFJvd1NwbGl0KHQpe2xldCBuPXQubGVuZ3RoO2lmKG49PT0wfHxuPT09MSlyZXR1cm4gMDtsZXQgYT0wO2ZvcihsZXQgcj0wO3I8bi0xOysrcil7bGV0IHM9dFtyKzFdLXRbcl07cz5hJiYoYT1zKX1yZXR1cm4gYX1zdGF0aWMgZ2V0TWF4V2lkdGhWYWx1ZVJvd0lEKHQpe2xldCBuPXQubGVuZ3RoO2lmKG49PT0wKXJldHVybiAwO2xldCBhPTAscj10WzBdLHM9MDtmb3IobGV0IGk9MTtpPG47KytpKXtsZXQgbz10W2ldO28hPT1yJiYocj1vLHM9TWF0aC5tYXgoaS1hLHMpLGE9aSl9cmV0dXJuIE1hdGgubWF4KG4tYSxzKX10ZW5zb3JTaGFwZUZyb21UZW5zb3IodCxuLGE9ITApe2lmKG4ubGVuZ3RoPT09MCl7aWYodFswXT09PS0xKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcIlRoZSBvbmx5IHZhbGlkIHNjYWxhciBzaGFwZSB0ZW5zb3IgaXMgdGhlIGZ1bGx5IHVua25vd24gc2hhcGUgc3BlY2lmaWVkIGFzIC0xLlwiKX1yZXR1cm4gUUkodCxhKX1jYWxjdWxhdGVPdXRwdXRTaXplKHQpe2xldCBuPXRoaXMudmFsdWVzU2hhcGUsYT10aGlzLmRlZmF1bHRWYWx1ZVNoYXBlO1QudmFsaWRhdGVEZWZhdWx0VmFsdWVTaGFwZShhLG4pO2xldCByPXRoaXMudGVuc29yU2hhcGVGcm9tVGVuc29yKHRoaXMuc2hhcGUsdGhpcy5zaGFwZVNoYXBlKSxzPVQuY29tYmluZVJhZ2dlZFRlbnNvclRvVGVuc29yU2hhcGVzKHRoaXMucmFnZ2VkUmFuayxyLG4pO3NbMF08MCYmKHNbMF09dCk7Zm9yKGxldCBpPTE7aTw9dGhpcy5yYWdnZWRSYW5rOysraSlzW2ldPDAmJihzW2ldPXRoaXMuZ2V0TWF4V2lkdGgoaSkpO3JldHVybiBzfWNhbGN1bGF0ZUZpcnN0UGFyZW50T3V0cHV0SW5kZXgodCxuLGEpe2xldCByPU1hdGgubWluKHQsYSkscz1bXSxpPTA7Zm9yKGxldCBvPTA7bzxyOysrbyxpKz1uKXMucHVzaChpKTtmb3IobGV0IG89cjtvPHQ7KytvKXMucHVzaCgtMSk7cmV0dXJuIHcuYXNzZXJ0KHMubGVuZ3RoPT09dCwoKT0+XCJGaW5hbCBsZW5ndGggb2YgcmVzdWx0IG11c3QgYmUgZXF1YWwgdG8gZmlyc3REaW1lbnNpb24uXCIpLHN9Y2FsY3VsYXRlT3V0cHV0SW5kZXhSb3dTcGxpdCh0LG4sYSxyKXtsZXQgcz10Lmxlbmd0aCxpPVtdO2ZvcihsZXQgbz0wO288cy0xOysrbyl7bGV0IGw9dFtvKzFdLXRbb10sdT1NYXRoLm1pbihyLGwpLHA9bltvXTtwPT09LTEmJih1PTApO2ZvcihsZXQgZD0wO2Q8dTsrK2QpaS5wdXNoKHApLHArPWE7Zm9yKGxldCBkPTA7ZDxsLXU7KytkKWkucHVzaCgtMSl9aWYocz4wJiZpLmxlbmd0aCE9PXRbcy0xXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdyBzcGxpdCBzaXplLlwiKTtyZXR1cm4gaX1jYWxjdWxhdGVPdXRwdXRJbmRleFZhbHVlUm93SUQodCxuLGEscil7bGV0IHM9dC5sZW5ndGgsaT1bXTtpZihzPT09MClyZXR1cm5bXTtsZXQgbz0wLGw9dFswXTtpZihsPj1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdvdCBjdXJyZW50VmFsdWVSb3dJZD0ke2x9LCB3aGljaCBpcyBub3QgbGVzcyB0aGFuICR7bi5sZW5ndGh9YCk7bGV0IHU9bltsXTtpLnB1c2godSk7Zm9yKGxldCBwPTE7cDxzOysrcCl7bGV0IGQ9dFtwXTtpZihkPT09bCl1Pj0wJiYoKytvLG88cj91Kz1hOnU9LTEpO2Vsc2V7aWYobz0wLGw9ZCxkPj1uLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdvdCBuZXh0VmFsdWVSb3dJZD0ke2R9IHdoaWNoIGlzIG5vdCBsZXNzIHRoYW4gJHtuLmxlbmd0aH1gKTt1PW5bZF19aS5wdXNoKHUpfWlmKGkubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3cgaWRzLlwiKTtyZXR1cm4gaX1jYWxjdWxhdGVPdXRwdXRJbmRleCh0LG4sYSxyKXtsZXQgcz10aGlzLmdldFJvd1BhcnRpdGlvblRlbnNvcih0KSxpPXRoaXMuZ2V0Um93UGFydGl0aW9uVHlwZUJ5RGltZW5zaW9uKHQpO3N3aXRjaChpKXtjYXNlIE5hLlZBTFVFX1JPV0lEUzpyZXR1cm4gdGhpcy5jYWxjdWxhdGVPdXRwdXRJbmRleFZhbHVlUm93SUQocyxuLGEscik7Y2FzZSBOYS5ST1dfU1BMSVRTOmlmKHMubGVuZ3RoLTE+bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBSb3cgcGFydGl0aW9uIHNpemUgaXMgZ3JlYXRlciB0aGFuIG91dHB1dCBzaXplOiAke3MubGVuZ3RoLTF9ID4gJHtuLmxlbmd0aH1gKTtyZXR1cm4gdGhpcy5jYWxjdWxhdGVPdXRwdXRJbmRleFJvd1NwbGl0KHMsbixhLHIpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0aXRpb24gdHlwZTogJHtOYVtpXX1gKX19Z2V0Rmlyc3REaW1lbnNpb25TaXplKCl7bGV0IHQ9dGhpcy5yb3dQYXJ0aXRpb25WYWx1ZXNbMF07aWYodGhpcy5yb3dQYXJ0aXRpb25UeXBlcy5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIk5vIHJvd19wYXJ0aXRpb25fdHlwZXMgZ2l2ZW4uXCIpO2xldCBuPXRoaXMucm93UGFydGl0aW9uVHlwZXNbMF07c3dpdGNoKG4pe2Nhc2UgTmEuRklSU1RfRElNX1NJWkU6cmV0dXJuIHRbMF07Y2FzZSBOYS5WQUxVRV9ST1dJRFM6dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhbmRsZSBWQUxVRV9ST1dJRFMgaW4gZmlyc3QgZGltZW5zaW9uLlwiKTtjYXNlIE5hLlJPV19TUExJVFM6cmV0dXJuIHRoaXMucm93UGFydGl0aW9uVmFsdWVzU2hhcGVzWzBdWzBdLTE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBoYW5kbGUgdHlwZSAke05hW25dfWApfX1jb21wdXRlKCl7aWYodGhpcy5yb3dQYXJ0aXRpb25WYWx1ZXNbMF0ubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZmlyc3QgcGFydGl0aW9uIGlucHV0LiBUZW5zb3IgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXCIpO2xldCB0PXRoaXMuZ2V0Rmlyc3REaW1lbnNpb25TaXplKCksbj10aGlzLmNhbGN1bGF0ZU91dHB1dFNpemUodCksYT1uZXcgQXJyYXkodGhpcy5yYWdnZWRSYW5rKzEpO2FbYS5sZW5ndGgtMV09MTtmb3IobGV0IGk9YS5sZW5ndGgtMjtpPj0wOy0taSlhW2ldPWFbaSsxXSpuW2krMV07bGV0IHI9UUkobiwhMSkscz13LmdldEFycmF5RnJvbURUeXBlKHRoaXMudmFsdWVzRFR5cGUsdy5zaXplRnJvbVNoYXBlKHIpKTtpZihhWzBdKm5bMF0+MCl7bGV0IGk9dGhpcy5jYWxjdWxhdGVGaXJzdFBhcmVudE91dHB1dEluZGV4KHQsYVswXSxuWzBdKTtmb3IobGV0IG89MTtvPD10aGlzLnJhZ2dlZFJhbms7KytvKWk9dGhpcy5jYWxjdWxhdGVPdXRwdXRJbmRleChvLTEsaSxhW29dLG5bb10pO3RoaXMuc2V0T3V0cHV0KHRoaXMucmFnZ2VkUmFuayxpLHMscil9cmV0dXJuW3Isc119c2V0T3V0cHV0KHQsbixhLHIpe2lmKGEubGVuZ3RoPT09MClyZXR1cm47bGV0IHM9dGhpcy52YWx1ZXMsaT1hLG89ci5zbGljZSgpO289by5zbGljZSh0KzEpO2xldCBsPXcuc2l6ZUZyb21TaGFwZShvKSx1PW4ubGVuZ3RoLHA9dGhpcy5kZWZhdWx0VmFsdWU7aWYocC5sZW5ndGghPT1sJiZwLmxlbmd0aCE9PTEpe2xldCBtPXRoaXMuZGVmYXVsdFZhbHVlU2hhcGU7TygoKT0+e2xldCBmPVcocCxtKTtwPWFpKGYsbykuZGF0YVN5bmMoKX0pfWxldCBkPTAsYz0wLGg9MDtmb3IobGV0IG09MDttPD11OysrbSl7bGV0IGY9bTx1P25bbV06LTE7aWYoZj09PWgpeysraDtjb250aW51ZX1pZihjPGgpe2xldCBnPXMuc3ViYXJyYXkoZCpsKSxiPWkuc3ViYXJyYXkoYypsKSx5PShoLWMpKmw7SkkoYixnLHkpfWlmKG0+PXUpe2xldCBnPWEubGVuZ3RoO2Y9TWF0aC5mbG9vcihnL2wpfWlmKGY+aClpZih0aGlzLmRlZmF1bHRWYWx1ZS5sZW5ndGg9PT0xKWkuc3ViYXJyYXkoaCpsLGYqbCkuZmlsbCh0aGlzLmRlZmF1bHRWYWx1ZVswXSksaD1mO2Vsc2UgZm9yKDtmPmg7KXtsZXQgZz1pLnNsaWNlKGgqbCk7SkkoZyxwLGwpLCsraH1mPDA/KGQ9bSsxLGM9aCk6KGQ9bSxjPWgsaD1jKzEpfX19O2Z1bmN0aW9uIEpJKGUsdCxuKXtmb3IobGV0IGE9MDthPG47YSsrKWVbYV09dFthXX1mdW5jdGlvbiBRSShlLHQpe2xldCBuPVtdO2ZvcihsZXQgYSBvZiBlKXtpZihhPDApe2lmKCF0KXRocm93IG5ldyBFcnJvcihgRGltZW5zaW9uICR7YX0gbXVzdCBiZSA+PSAwYCk7aWYoYTwtMSl0aHJvdyBuZXcgRXJyb3IoYERpbWVuc2lvbiAke2F9IG11c3QgYmUgPj0gLTFgKTthPS0xfW4ucHVzaChhKX1yZXR1cm4gbn1mdW5jdGlvbiByXyhlLHQsbixhLHIscyxpLG8sbCx1KXtyZXR1cm4gbmV3IGxLKGUsdCxuLGEscixzLGksbyxsLHUpLmNvbXB1dGUoKX1mdW5jdGlvbiBCMShlLHQsbixhKXtsZXQgcj1lPT09dCxzPWU8dCYmbjwwLGk9dDxlJiZuPjE7aWYocnx8c3x8aSlyZXR1cm4gdy5tYWtlWmVyb3NUeXBlZEFycmF5KDAsYSk7bGV0IG89TWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL24pKSxsPXcubWFrZVplcm9zVHlwZWRBcnJheShvLGEpO3Q8ZSYmbj09PTEmJihuPS0xKSxsWzBdPWU7Zm9yKGxldCB1PTE7dTxsLmxlbmd0aDt1KyspbFt1XT1sW3UtMV0rbjtyZXR1cm4gbH12YXIgc189ZnIoZT0+MS9NYXRoLnNxcnQoZSkpLHVLPUZzKEFvLHNfKSxwSz17a2VybmVsTmFtZTpBbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6dUt9O2Z1bmN0aW9uIG5pKGUsdCxuLGEscixzLGksbyxsLHUpe2xldCBwPVthL3Iscl0sZD1lLnZhbHVlcyxjPXQudmFsdWVzO2lmKGE9PT0wKXJldHVybiBPZShuLHQuZHR5cGUpO2xldCBoPWwgaW5zdGFuY2VvZiBXdD9sOk9lKHAsdC5kdHlwZSk7dHlwZW9mIGw9PVwic3RyaW5nXCJ8fHR5cGVvZiBsPT1cIm51bWJlclwiP2gudmFsdWVzLmZpbGwobCk6dHlwZW9mIGw9PVwiYm9vbGVhblwiJiZoLnZhbHVlcy5maWxsKCtsKTtmb3IobGV0IG09MDttPHM7bSsrKXtsZXQgZj1bXSxnPTA7Zm9yKGxldCBiPTA7YjxpO2IrKyl7bGV0IHk9ZFttKmkrYl07Zi5wdXNoKHkpLGcrPXkqb1tiXX1pZihnPDB8fGc+PWEvcil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5kaWNlczogJHtmfSBkb2VzIG5vdCBpbmRleCBpbnRvICR7bn1gKTtmb3IobGV0IGI9MDtiPHI7YisrKXU/aC52YWx1ZXNbZypyK2JdKz1jW20qcitiXTpoLnZhbHVlc1tnKnIrYl09dC5yYW5rPT09MD9jWzBdOmNbbSpyK2JdfXJldHVybiBofXZhciBjSz1mcihlPT4xLygxK01hdGguZXhwKC1lKSkpLGlfPWx0KE1vLGU9PjEvKDErTWF0aC5leHAoLWUpKSksZEs9e2tlcm5lbE5hbWU6TW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmlffTtmdW5jdGlvbiB1bShlLHQsbixhLHIpe2xldCBzPUt0LmlzU2xpY2VDb250aW5vdXMoYSx0LG4pLGk9dy5zaXplRnJvbVNoYXBlKG4pLG89dy5jb21wdXRlU3RyaWRlcyhhKTtpZihzKXtsZXQgZD1LdC5jb21wdXRlRmxhdE9mZnNldCh0LG8pO3JldHVybiByPT09XCJzdHJpbmdcIj9lLnNsaWNlKGQsZCtpKTplLnN1YmFycmF5KGQsZCtpKX1sZXQgbD1yPT09XCJzdHJpbmdcIj9ULmZyb21VaW50OFRvU3RyaW5nQXJyYXkoZSk6ZSx1PU9lKGEscixsKSxwPU9lKG4scik7Zm9yKGxldCBkPTA7ZDxwLnNpemU7KytkKXtsZXQgYz1wLmluZGV4VG9Mb2MoZCksaD1jLm1hcCgobSxmKT0+bSt0W2ZdKTtwLnNldCh1LmdldCguLi5oKSwuLi5jKX1yZXR1cm4gcj09PVwic3RyaW5nXCI/VC5mcm9tU3RyaW5nQXJyYXlUb1VpbnQ4KHAudmFsdWVzKTpwLnZhbHVlc31mdW5jdGlvbiB4aShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YmVnaW46cyxzaXplOml9PWE7Z2UocixcInNsaWNlXCIpO2xldFtvLGxdPUt0LnBhcnNlU2xpY2VQYXJhbXMocixzLGkpO0t0LmFzc2VydFBhcmFtc1ZhbGlkKHIsbyxsKTtsZXQgdT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMscD11bSh1LG8sbCxyLnNoYXBlLHIuZHR5cGUpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwsci5kdHlwZSxwKX12YXIgaEs9e2tlcm5lbE5hbWU6QnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnhpfTtmdW5jdGlvbiBvXyhlLHQsbixhLHIscyxpKXtsZXQgbz10WzBdLGw9c1swXSx1PW5ldyBBcnJheShsKSxwPW5ldyBBcnJheShvKSxkPXRbMV07aWYobD09PTApe2lmKG8hPT0wKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZUZpbGxFbXB0eVJvd3NJbmRpY2VzRGVuc2VTaGFwZU1pc21hdGNoKG8pKTtsZXQgZz13LmdldEFycmF5RnJvbURUeXBlKG4sMCksYj13LmdldEFycmF5RnJvbURUeXBlKHIsMCk7cmV0dXJuW2csWzAsZF0sYix1LHBdfWxldCBjPSEwLGg9MCxtPW5ldyBBcnJheShsKS5maWxsKDApO2ZvcihsZXQgZz0wO2c8bzsrK2cpe2xldCBiPWVbZypkXTtpZihiPDApdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlRmlsbEVtcHR5Um93c05lZ2F0aXZlSW5kZXhFcnJvck1lc3NhZ2UoZyxiKSk7aWYoYj49bCl0aHJvdyBuZXcgRXJyb3IoVC5nZXRTcGFyc2VGaWxsRW1wdHlSb3dzT3V0T2ZSYW5nZUluZGV4RXJyb3JNZXNzYWdlKGcsYixsKSk7KyttW2JdLGM9YyYmYj49aCxoPWJ9bGV0IGY9ITA7Zm9yKGxldCBnPTA7ZzxsOysrZyl7bGV0IGI9bVtnXT09PTA7dVtnXT1iLGY9ZiYmIWIsbVtnXT1NYXRoLm1heChtW2ddLDEpLGc+MCYmKG1bZ10rPW1bZy0xXSl9aWYoZiYmYyl7bGV0IGc9ZSxiPWE7Zm9yKGxldCB5PTA7eTxvOysreSlwW3ldPXk7cmV0dXJuW2csW28sZF0sYix1LHBdfWVsc2V7bGV0IGc9bVtsLTFdLGI9dy5nZXRBcnJheUZyb21EVHlwZShuLGcqZCkseT13LmdldEFycmF5RnJvbURUeXBlKHIsZykseD1uZXcgQXJyYXkobCkuZmlsbCgwKTtmb3IobGV0IHY9MDt2PG87Kyt2KXtsZXQgST1lW3YqZF0sTj14W0ldLEM9KEk9PT0wPzA6bVtJLTFdKStOO3hbSV0rKztmb3IobGV0IF89MDtfPGQ7KytfKWJbQypkK19dPWVbdipkK19dO3lbQ109YVt2XSxwW3ZdPUN9Zm9yKGxldCB2PTA7djxsOysrdilpZih4W3ZdPT09MCl7bGV0IEk9dj09PTA/MDptW3YtMV07YltJKmQrMF09djtmb3IobGV0IE49MTtOPGQ7KytOKWJbSSpkK05dPTA7eVtJXT1pfXJldHVybltiLFtnLGRdLHksdSxwXX19ZnVuY3Rpb24gbF8oZSx0LG4sYSxyKXtsZXQgcz13LnNpemVGcm9tU2hhcGUoYSksaT10WzBdLG89ci5sZW5ndGgsbD1bXSx1PTEscD0tMTtmb3IobGV0IGY9MDtmPG87KytmKXtsZXQgZz1yW2ZdO2lmKGc9PT0tMSl7aWYocCE9PS0xKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVJlc2hhcGVNdWx0aXBsZU5lZ2F0aXZlT25lT3V0cHV0RGltRXJyb3JNZXNzYWdlKHAsZikpO3A9ZixsLnB1c2goMSl9ZWxzZXtpZihnPDApdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlUmVzaGFwZU5lZ2F0aXZlT3V0cHV0RGltRXJyb3JNZXNzYWdlKGYsZykpO3UqPWcsbC5wdXNoKGcpfX1pZihwIT09LTEpe2lmKHU8PTApdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlUmVzaGFwZUVtcHR5VGVuc29yWmVyb091dHB1dERpbUVycm9yTWVzc2FnZSgpKTtsZXQgZj1NYXRoLnRydW5jKHMvdSk7aWYodSpmIT09cyl0aHJvdyBuZXcgRXJyb3IoVC5nZXRTcGFyc2VSZXNoYXBlSW5wdXRPdXRwdXRNdWx0aXBsZUVycm9yTWVzc2FnZShhLGwpKTtsW3BdPWZ9aWYody5zaXplRnJvbVNoYXBlKGwpIT09cyl0aHJvdyBuZXcgRXJyb3IoVC5nZXRTcGFyc2VSZXNoYXBlSW5wdXRPdXRwdXRNaXNtYXRjaEVycm9yTWVzc2FnZShhLGwpKTtsZXQgZD1hLmxlbmd0aCxjPVtdO2lmKGQ+MCl7Y1tkLTFdPTE7Zm9yKGxldCBmPWQtMjtmPj0wOy0tZiljW2ZdPWNbZisxXSphW2YrMV19bGV0IGg9W107aWYobz4wKXtoW28tMV09MTtmb3IobGV0IGY9by0yO2Y+PTA7LS1mKWhbZl09aFtmKzFdKmxbZisxXX1sZXQgbT13LmdldEFycmF5RnJvbURUeXBlKG4saSpvKTtmb3IobGV0IGY9MDtmPGk7KytmKXtsZXQgZz0wO2ZvcihsZXQgYj0wO2I8ZDsrK2IpZys9ZVtmKmQrYl0qY1tiXTtmb3IobGV0IGI9MDtiPG87KytiKW1bZipvK2JdPU1hdGgudHJ1bmMoZy9oW2JdKSxnJT1oW2JdfXJldHVyblttLFtpLG9dLGxdfWZ1bmN0aW9uIFYxKGUsdCxuLGEscixzPSExLGk9MCl7bGV0IG89YS5sZW5ndGgsbD1bdFswXSxlLmxlbmd0aC90WzBdXSx1PWxbMV0scD1vPjA/cltvLTFdKzE6MDtpZihwPDApdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbk5lZ2F0aXZlU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpKTtsZXQgZD10LnNsaWNlKCk7ZFswXT1wO2xldCBjPWQucmVkdWNlKCh5LHgpPT55KngsMSksaD13LmdldEFycmF5RnJvbURUeXBlKG4sYyk7aWYobz09PTApcmV0dXJuIHA+MCYmaC5maWxsKGkpLFtoLGRdO2lmKHA8PTApdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbk5lZ2F0aXZlU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpKTtsZXQgbT0wLGY9MSxnPTAsYj1yW21dO2Zvcig7Oyl7bGV0IHk9MDtpZihmPG8pe2lmKHk9cltmXSxiPT09eSl7KytmO2NvbnRpbnVlfWlmKGI+PXkpdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbk5vbkluY3JlYXNpbmdTZWdtZW50SWRzRXJyb3JNZXNzYWdlKCkpfWlmKGI8MHx8Yj49cCl0aHJvdyBuZXcgRXJyb3IoVC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uU2VnbWVudElkT3V0T2ZSYW5nZUVycm9yTWVzc2FnZShiLHApKTtiPmcmJmguZmlsbChpLGcqdSxiKnUpO2ZvcihsZXQgeD1tO3g8ZjsrK3gpe2xldCB2PWFbeF07aWYodjwwfHx2Pj1sWzBdKXRocm93IG5ldyBFcnJvcihULmdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25JbmRpY2VzT3V0T2ZSYW5nZUVycm9yTWVzc2FnZSh4LGFbeF0sbFswXSkpO2ZvcihsZXQgST0wO0k8dTtJKyspaFtiKnUrSV0rPWVbdip1K0ldfWlmKHMpZm9yKGxldCB4PTA7eDx1O3grKyloW2IqdSt4XS89Zi1tO2lmKG09ZiwrK2YsZz1iKzEsYj15LGY+bylicmVha31yZXR1cm4gZzxwJiZoLmZpbGwoaSxnKnUscCp1KSxbaCxkXX12YXIgbUs9ZnIoZT0+TWF0aC5zcXJ0KGUpKSxmSz1sdChQbyxlPT5NYXRoLnNxcnQoZSkpLGdLPXtrZXJuZWxOYW1lOlBvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmS30sdV89TXQoKGUsdCk9PntsZXQgbj1lLXQ7cmV0dXJuIG4qbn0pLGJLPVp0KFdvLHVfKSx5Sz17a2VybmVsTmFtZTpXbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Ykt9LHBfPWZyKChlLHQpPT57bGV0e3BhdHRlcm46bixyZXBsYWNlR2xvYmFsOmEscmV3cml0ZTpyfT10O3JldHVybiBlLnJlcGxhY2UobmV3IFJlZ0V4cChuLGE/XCJnXCI6XCJcIikscil9KSx4Sz1GcyhLYyxwXyksdks9e2tlcm5lbE5hbWU6S2MsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnhLfTtmdW5jdGlvbiBjXyhlLHQsbixhKXtsZXQgcj1PZShlLHQuZHR5cGUpO2ZvcihsZXQgcz0wO3M8ci5zaXplO3MrKyl7bGV0IGk9ci5pbmRleFRvTG9jKHMpLG89bmV3IEFycmF5KGkubGVuZ3RoKTtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKylvW2xdPWlbbF0qbltsXSthW2xdO3Iuc2V0KHQuZ2V0KC4uLm8pLC4uLmkpfXJldHVybiByfXZhciB3Sz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIscyl7dGhpcy5zZXBhcmF0b3I9dy5lbmNvZGVTdHJpbmcoZSksdGhpcy5uR3JhbVdpZHRocz10LHRoaXMubGVmdFBhZD13LmVuY29kZVN0cmluZyhuKSx0aGlzLnJpZ2h0UGFkPXcuZW5jb2RlU3RyaW5nKGEpLHRoaXMucGFkV2lkdGg9cix0aGlzLnByZXNlcnZlU2hvcnQ9c31nZXRQYWRXaWR0aChlKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wYWRXaWR0aDwwP2UtMTp0aGlzLnBhZFdpZHRoLGUtMSl9Z2V0TnVtTkdyYW1zKGUsdCl7bGV0IG49dGhpcy5nZXRQYWRXaWR0aCh0KTtyZXR1cm4gTWF0aC5tYXgoMCxlKzIqbi10KzEpfWNyZWF0ZU5HcmFtcyhlLHQsbixhLHIscyl7Zm9yKGxldCBpPTA7aTxyOysraSl7bGV0IG89dGhpcy5nZXRQYWRXaWR0aChzKSxsPU1hdGgubWF4KDAsby1pKSx1PU1hdGgubWF4KDAsby0oci0oaSsxKSkpLHA9cy0obCt1KSxkPXQrKGw+MD8wOmktbyksYz0wO2MrPWwqdGhpcy5sZWZ0UGFkLmxlbmd0aDtmb3IobGV0IGI9MDtiPHA7KytiKWMrPWVbZCtiXS5sZW5ndGg7Yys9dSp0aGlzLnJpZ2h0UGFkLmxlbmd0aDtsZXQgaD1sK3UrcC0xO2MrPWgqdGhpcy5zZXBhcmF0b3IubGVuZ3RoLG5bYStpXT1uZXcgVWludDhBcnJheShjKTtsZXQgbT1uW2EraV0sZj0wLGc9Yj0+Yi5mb3JFYWNoKHk9Pm1bZisrXT15KTtmb3IobGV0IGI9MDtiPGw7KytiKWcodGhpcy5sZWZ0UGFkKSxnKHRoaXMuc2VwYXJhdG9yKTtmb3IobGV0IGI9MDtiPHAtMTsrK2IpZyhlW2QrYl0pLGcodGhpcy5zZXBhcmF0b3IpO2lmKHA+MCl7ZyhlW2QrcC0xXSk7Zm9yKGxldCBiPTA7Yjx1OysrYilnKHRoaXMuc2VwYXJhdG9yKSxnKHRoaXMucmlnaHRQYWQpfWVsc2V7Zm9yKGxldCBiPTA7Yjx1LTE7KytiKWcodGhpcy5yaWdodFBhZCksZyh0aGlzLnNlcGFyYXRvcik7Zyh0aGlzLnJpZ2h0UGFkKX19fWNvbXB1dGUoZSx0KXtsZXQgbj1lLmxlbmd0aCxhPXQubGVuZ3RoO2lmKGE+MCl7bGV0IG89dFswXTtpZihvIT09MCl0aHJvdyBuZXcgRXJyb3IoYEZpcnN0IHNwbGl0IHZhbHVlIG11c3QgYmUgMCwgZ290ICR7b31gKTtmb3IobGV0IGw9MTtsPGE7KytsKXtsZXQgdT10W2xdPj1vO2lmKHU9dSYmdFtsXTw9biwhdSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3BsaXQgdmFsdWUgJHt0W2xdfSwgbXVzdCBiZSBpbiBbJHtvfSwgJHtufV1gKTtvPXRbbF19aWYobyE9PW4pdGhyb3cgbmV3IEVycm9yKGBMYXN0IHNwbGl0IHZhbHVlIG11c3QgYmUgZGF0YSBzaXplLiBFeHBlY3RlZCAke259LCBnb3QgJHtvfWApfWxldCByPWEtMSxzPXcuZ2V0QXJyYXlGcm9tRFR5cGUoXCJpbnQzMlwiLGEpO2lmKG49PT0wfHxhPT09MCl7bGV0IG89bmV3IEFycmF5KG4pO2ZvcihsZXQgbD0wO2w8PXI7KytsKXNbbF09MDtyZXR1cm5bbyxzXX1zWzBdPTA7Zm9yKGxldCBvPTE7bzw9cjsrK28pe2xldCBsPXRbb10tdFtvLTFdLHU9MDt0aGlzLm5HcmFtV2lkdGhzLmZvckVhY2gocD0+e3UrPXRoaXMuZ2V0TnVtTkdyYW1zKGwscCl9KSx0aGlzLnByZXNlcnZlU2hvcnQmJmw+MCYmdT09PTAmJih1PTEpLHNbb109c1tvLTFdK3V9bGV0IGk9bmV3IEFycmF5KHNbcl0pO2ZvcihsZXQgbz0wO288cjsrK28pe2xldCBsPXRbb10sdT1zW29dO2lmKHRoaXMubkdyYW1XaWR0aHMuZm9yRWFjaChwPT57bGV0IGQ9dFtvKzFdLXRbb10sYz10aGlzLmdldE51bU5HcmFtcyhkLHApO3RoaXMuY3JlYXRlTkdyYW1zKGUsbCxpLHUsYyxwKSx1Kz1jfSksdGhpcy5wcmVzZXJ2ZVNob3J0JiZ1PT09c1tvXSl7bGV0IHA9dFtvKzFdLXRbb107aWYocD09PTApY29udGludWU7bGV0IGQ9cCsyKnRoaXMucGFkV2lkdGg7dGhpcy5jcmVhdGVOR3JhbXMoZSxsLGksdSwxLGQpfX1yZXR1cm5baSxzXX19O2Z1bmN0aW9uIFUxKGUsdCxuLGEscixzLGksbyl7cmV0dXJuIG5ldyB3SyhuLGEscixzLGksbykuY29tcHV0ZShlLHQpfWZ1bmN0aW9uIGtLKGUsdCxuLGEpe2lmKCFlLmxlbmd0aClyZXR1cm47aWYodC5sZW5ndGg9PT0wKXtmb3IobGV0IHM9MDtzPGUubGVuZ3RoOysrcylhLnB1c2goZS5zdWJhcnJheShzLHMrMSkpO3JldHVybn1pZih0Lmxlbmd0aD09PTEpe2xldCBzPXRbMF0saT1lLmluZGV4T2Yocyk7Zm9yKDtpIT09LTE7KXtsZXQgbz1lLnN1YmFycmF5KDAsaSk7KCFufHxvLmxlbmd0aCE9PTApJiZhLnB1c2gobyksZT1lLnN1YmFycmF5KGkrMSksaT1lLmluZGV4T2Yocyl9KCFufHxlLmxlbmd0aCE9PTApJiZhLnB1c2goZSk7cmV0dXJufWxldCByPTA7Zm9yKGxldCBzPTA7czxlLmxlbmd0aCsxO3MrKylpZihzPT09ZS5sZW5ndGh8fHQuaW5kZXhPZihlW3NdKSE9PS0xKXtsZXQgaT1lLnN1YmFycmF5KHIscyk7KCFufHxpLmxlbmd0aCE9PTApJiZhLnB1c2goaSkscj1zKzF9fWZ1bmN0aW9uIEcxKGUsdCxuKXtsZXQgYT1lLmxlbmd0aCxyPVtdLHM9MCxpPTAsbz1uZXcgQXJyYXkoYSk7Zm9yKGxldCBjPTA7YzxhOysrYyl7bGV0IGg9ci5sZW5ndGg7a0soZVtjXSx0LG4scik7bGV0IG09ci5sZW5ndGgtaDtvW2NdPW0scys9bSxpPU1hdGgubWF4KGksbSl9bGV0IGw9dy5nZXRBcnJheUZyb21EVHlwZShcImludDMyXCIscyoyKSx1PW5ldyBBcnJheShzKSxwPVthLGldLGQ9MDtmb3IobGV0IGM9MDtjPGE7KytjKWZvcihsZXQgaD0wO2g8b1tjXTsrK2gpbFtkKjJdPWMsbFtkKjIrMV09aCx1W2RdPXJbZF0sKytkO3JldHVybltsLHUscF19ZnVuY3Rpb24gSDEoZSx0KXtsZXQgbj13LmdldEFycmF5RnJvbURUeXBlKFwiaW50MzJcIixlLmxlbmd0aCk7Zm9yKGxldCBhPTA7YTxlLmxlbmd0aDsrK2EpblthXT13LmZpbmdlclByaW50NjQoZVthXSkubW9kdWxvKHQpLmdldExvd0JpdHNVbnNpZ25lZCgpO3JldHVybiBufXZhciBkXz1NdCgoZSx0KT0+ZS10KSxJSz1PMSgoZSx0LG4sYSk9Pih7cmVhbDplLW4saW1hZzp0LWF9KSksajE9WnQoQm8sZF8sSUspLFNLPXtrZXJuZWxOYW1lOkJvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpqMX07ZnVuY3Rpb24gaF8oZSx0KXtsZXQgbj1uZXcgQXJyYXkoZS5yYW5rKTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoO3IrKyluW3JdPWUuc2hhcGVbcl0qdFtyXTtsZXQgYT1PZShuLGUuZHR5cGUpO2ZvcihsZXQgcj0wO3I8YS52YWx1ZXMubGVuZ3RoOysrcil7bGV0IHM9YS5pbmRleFRvTG9jKHIpLGk9bmV3IEFycmF5KGUucmFuayk7Zm9yKGxldCBsPTA7bDxpLmxlbmd0aDtsKyspaVtsXT1zW2xdJWUuc2hhcGVbbF07bGV0IG89ZS5sb2NUb0luZGV4KGkpO2EudmFsdWVzW3JdPWUudmFsdWVzW29dfXJldHVybiBhfXZhciBuYz0oZSx0KT0+e2xldCBuPXQudmFsdWUtZS52YWx1ZTtyZXR1cm4gbj09PTA/ZS5pbmRleC10LmluZGV4Om59O2Z1bmN0aW9uIG1fKGUsdCxuPTAsYT1lLmxlbmd0aC0xKXtmb3IoO2E+bjspe2lmKGEtbj42MDApe2xldCBvPWEtbisxLGw9dC1uKzEsdT1NYXRoLmxvZyhvKSxwPS41Kk1hdGguZXhwKDIqdS8zKSxkPS41Kk1hdGguc3FydCh1KnAqKG8tcCkvbykqTWF0aC5zaWduKGwtby8yKSxjPU1hdGgubWF4KG4sTWF0aC5mbG9vcih0LWwqcC9vK2QpKSxoPU1hdGgubWluKGEsTWF0aC5mbG9vcih0KyhvLWwpKnAvbytkKSk7bV8oZSx0LGMsaCl9bGV0IHI9ZVt0XSxzPW4saT1hO2Zvcih3LnN3YXAoZSxuLHQpLG5jKGVbYV0scik+MCYmdy5zd2FwKGUsbixhKTtzPGk7KXtmb3Iody5zd2FwKGUscyxpKSxzKyssaS0tO25jKGVbc10scik8MDspcz1zKzE7Zm9yKDtuYyhlW2ldLHIpPjA7KWk9aS0xfW5jKGVbbl0scik9PT0wP3cuc3dhcChlLG4saSk6KGk9aSsxLHcuc3dhcChlLGksYSkpLGk8PXQmJihuPWkrMSksdDw9aSYmKGE9aS0xKX19ZnVuY3Rpb24gZl8oZSx0LG4sYSxyKXtsZXQgcz10W3QubGVuZ3RoLTFdLFtpLG9dPVtlLmxlbmd0aC9zLHNdLGw9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKG4saSphKSx1PXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShcImludDMyXCIsaSphKTtmb3IobGV0IGQ9MDtkPGk7ZCsrKXtsZXQgYz1kKm8saD1lLnN1YmFycmF5KGMsYytvKSxtPW5ldyBBcnJheShoLmxlbmd0aCk7aC5mb3JFYWNoKCh5LHgpPT5tW3hdPXt2YWx1ZTp5LGluZGV4Onh9KSxhPG0ubGVuZ3RoJiYobV8obSxhKSxtPW0uc2xpY2UoMCxhKSksciYmbS5zb3J0KG5jKTtsZXQgZj1kKmEsZz1sLnN1YmFycmF5KGYsZithKSxiPXUuc3ViYXJyYXkoZixmK2EpO2ZvcihsZXQgeT0wO3k8YTt5KyspZ1t5XT1tW3ldLnZhbHVlLGJbeV09bVt5XS5pbmRleH1sZXQgcD10LnNsaWNlKCk7cmV0dXJuIHBbcC5sZW5ndGgtMV09YSxbT2UocCxuLGwpLE9lKHAsXCJpbnQzMlwiLHUpXX1mdW5jdGlvbiBxMShlLHQsbixhKXtsZXQgcj13LnBhcnNlQXhpc1BhcmFtKHQsbilbMF0scz1bMSxuWzBdLDFdO2ZvcihsZXQgbT0wO208cjttKyspc1swXSo9blttXTtzWzFdPW5bcl07Zm9yKGxldCBtPXIrMTttPG4ubGVuZ3RoO20rKylzWzJdKj1uW21dO2xldCBpPW5ldyBNYXAsbz1uZXcgSW50MzJBcnJheShuW3JdKSxsPW5ldyBXdChzLGEsZSksdT1bXSxwPXNbMF09PT0xJiZzWzJdPT09MTtmb3IobGV0IG09MDttPG5bcl07bSsrKXtsZXQgZjtpZihwKWY9ZVttXS50b1N0cmluZygpO2Vsc2V7bGV0IGI9W107Zm9yKGxldCB5PTA7eTxzWzBdO3krKylmb3IobGV0IHg9MDt4PHNbMl07eCsrKWIucHVzaChsLmdldCh5LG0seCkpO2Y9Yi5qb2luKFwiLFwiKX1sZXQgZz1pLmdldChmKTtpZihnIT1udWxsKW9bbV09ZztlbHNle2xldCBiPWkuc2l6ZTtpLnNldChmLGIpLG9bbV09Yix1LnB1c2gobSl9fWxldCBkPXMuc2xpY2UoKTtkWzFdPWkuc2l6ZTtsZXQgYz1uZXcgV3QoZCxhKTt1LmZvckVhY2goKG0sZik9Pntmb3IobGV0IGc9MDtnPHNbMF07ZysrKWZvcihsZXQgYj0wO2I8c1syXTtiKyspYy5zZXQobC5nZXQoZyxtLGIpLGcsZixiKX0pO2xldCBoPW4uc2xpY2UoKTtyZXR1cm4gaFtyXT1kWzFdLHtvdXRwdXRWYWx1ZXM6Yy52YWx1ZXMsb3V0cHV0U2hhcGU6aCxpbmRpY2VzOm99fXZhciBOSz1cIjQuMjIuMFwiO09tKFwiY3B1XCIsKCk9Pm5ldyBSMSwxKTt2YXIgZ189bHQoamksZT0+ZT49MD9lOk1hdGguZXhwKGUpLTEpLFRLPXtrZXJuZWxOYW1lOmppLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpnX307ZnVuY3Rpb24gYl8oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2FscGhhOnN9PWE7Z2UoW3JdLFwibGVha3lSZWx1XCIpO2xldCBpPXcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKSxvPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxsPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShcImZsb2F0MzJcIixpKTtmb3IobGV0IHU9MDt1PG8ubGVuZ3RoO3UrKylsW3VdPW9bdV08MD9zKm9bdV06b1t1XTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLFwiZmxvYXQzMlwiLGwpfXZhciBDSz17a2VybmVsTmFtZTpybyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Yl99LEVLPU10KChlLHQpPT5lPDA/dCplOmUpO2Z1bmN0aW9uIHlfKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YSxhbHBoYTpyfT10O2dlKFthLHJdLFwicHJlbHVcIik7bGV0IHM9bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGk9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLFtvLGxdPUVLKGEuc2hhcGUsci5zaGFwZSxzLGksXCJmbG9hdDMyXCIpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwsXCJmbG9hdDMyXCIsbyl9dmFyIF9LPXtrZXJuZWxOYW1lOndvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp5X30seF89bHQoU28sZT0+TWF0aC5tYXgoMCxlKSksQUs9e2tlcm5lbE5hbWU6U28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnhffSx2Xz1sdChDbyxlPT5NYXRoLm1pbihNYXRoLm1heCgwLGUpLDYpKSxGSz17a2VybmVsTmFtZTpDbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6dl99O2Z1bmN0aW9uIHBtKGUsdCxuLGEscil7aWYobj09PVwibGluZWFyXCIpcmV0dXJuIGNyKHtpbnB1dHM6e3g6dH0sYmFja2VuZDplfSk7aWYobj09PVwicmVsdVwiKXJldHVybiB4Xyh7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6ZX0pO2lmKG49PT1cImVsdVwiKXJldHVybiBnXyh7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6ZX0pO2lmKG49PT1cInJlbHU2XCIpcmV0dXJuIHZfKHtpbnB1dHM6e3g6dH0sYmFja2VuZDplfSk7aWYobj09PVwicHJlbHVcIilyZXR1cm4geV8oe2lucHV0czp7eDp0LGFscGhhOmF9LGJhY2tlbmQ6ZX0pO2lmKG49PT1cImxlYWt5cmVsdVwiKXJldHVybiBiXyh7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6ZSxhdHRyczp7YWxwaGE6cn19KTtpZihuPT09XCJzaWdtb2lkXCIpcmV0dXJuIGlfKHtpbnB1dHM6e3g6dH0sYmFja2VuZDplfSk7dGhyb3cgbmV3IEVycm9yKGBBY3RpdmF0aW9uICR7bn0gaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgQ1BVIGJhY2tlbmQuYCl9ZnVuY3Rpb24geHQoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse3NoYXBlOnN9PWEsaT13LnNpemVGcm9tU2hhcGUoci5zaGFwZSksbz13LmluZmVyRnJvbUltcGxpY2l0U2hhcGUocyxpKSxsPXcuc2l6ZUZyb21TaGFwZShvKTt3LmFzc2VydChpPT09bCwoKT0+YFRoZSBuZXcgc2hhcGUgKCR7b30pIGhhcyAke2x9IGVsZW1lbnRzIGFuZCB0aGUgb2xkIHNoYXBlICgke3Iuc2hhcGV9KSBoYXMgJHtpfSBlbGVtZW50cy4gVGhlIG5ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuYCksbi5pbmNSZWYoci5kYXRhSWQpO2xldCB1PW4uZGF0YS5nZXQoci5kYXRhSWQpO2lmKHUuY29tcGxleFRlbnNvckluZm9zIT1udWxsKXtsZXQgcD11LmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLGQ9dS5jb21wbGV4VGVuc29ySW5mb3MuaW1hZztwLnNoYXBlPW8sZC5zaGFwZT1vfXJldHVybntkYXRhSWQ6ci5kYXRhSWQsc2hhcGU6byxkdHlwZTpyLmR0eXBlfX12YXIgJEs9e2tlcm5lbE5hbWU6UnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnh0fTtmdW5jdGlvbiB3XyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2E6cixiOnN9PXQse3RyYW5zcG9zZUE6aSx0cmFuc3Bvc2VCOm99PWE7Z2UoW3Isc10sXCJtYXRNdWxcIik7bGV0IGw9ci5zaGFwZS5sZW5ndGgsdT1zLnNoYXBlLmxlbmd0aCxwPWk/ci5zaGFwZVtsLTJdOnIuc2hhcGVbbC0xXSxkPW8/cy5zaGFwZVt1LTFdOnMuc2hhcGVbdS0yXSxjPWk/ci5zaGFwZVtsLTFdOnIuc2hhcGVbbC0yXSxoPW8/cy5zaGFwZVt1LTJdOnMuc2hhcGVbdS0xXSxtPXIuc2hhcGUuc2xpY2UoMCwtMiksZj1zLnNoYXBlLnNsaWNlKDAsLTIpLGc9dy5zaXplRnJvbVNoYXBlKG0pLGI9dy5zaXplRnJvbVNoYXBlKGYpLHk9SnUuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoci5zaGFwZS5zbGljZSgwLC0yKSxzLnNoYXBlLnNsaWNlKDAsLTIpKS5jb25jYXQoW2MsaF0pO3cuYXNzZXJ0KHA9PT1kLCgpPT5gRXJyb3IgaW4gbWF0TXVsOiBpbm5lciBzaGFwZXMgKCR7cH0pIGFuZCAoJHtkfSkgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyAke3Iuc2hhcGV9IGFuZCAke3Muc2hhcGV9IGFuZCB0cmFuc3Bvc2VBPSR7aX0gYW5kIHRyYW5zcG9zZUI9JHtvfSBtdXN0IG1hdGNoLmApO2xldCB4PWk/W2cscCxjXTpbZyxjLHBdLHY9bz9bYixoLGRdOltiLGQsaF0sST14dCh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6eH19KSxOPXh0KHtpbnB1dHM6e3g6c30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp2fX0pLEM9aT9JLnNoYXBlWzFdOkkuc2hhcGVbMl0sXz1pP0kuc2hhcGVbMl06SS5zaGFwZVsxXSxGPW8/Ti5zaGFwZVsxXTpOLnNoYXBlWzJdLEQ9TWF0aC5tYXgoZyxiKSwkPW4uZGF0YS5nZXQoSS5kYXRhSWQpLnZhbHVlcyxTPW4uZGF0YS5nZXQoTi5kYXRhSWQpLnZhbHVlcyxNPXcuY29tcHV0ZVN0cmlkZXMoSS5zaGFwZSksQj13LmNvbXB1dGVTdHJpZGVzKE4uc2hhcGUpLFtVLEgscV09aT9bTVswXSwxLE1bMV1dOltNWzBdLE1bMV0sMV0sW0ssWixKXT1vP1sxLEJbMV0sQlswXV06W0JbMV0sMSxCWzBdXSxlZT1fKkYsYWU9T2UoW0QsXyxGXSxJLmR0eXBlKSx0ZT1hZS52YWx1ZXMsc2U9bi5ibG9ja1NpemU7Zm9yKGxldCBpZT0wO2llPEQ7aWUrKyl7bGV0IHZlPWllJWcsdWU9aWUlYjtmb3IobGV0IHllPTA7eWU8Xzt5ZSs9c2Upe2xldCBrZT1NYXRoLm1pbih5ZStzZSxfKTtmb3IobGV0IFNlPTA7U2U8RjtTZSs9c2Upe2xldCBMZT1NYXRoLm1pbihTZStzZSxGKTtmb3IobGV0IFVlPTA7VWU8QztVZSs9c2Upe2xldCBtdD1NYXRoLm1pbihVZStzZSxDKTtmb3IobGV0IHN0PXllO3N0PGtlO3N0KyspZm9yKGxldCB0dD1TZTt0dDxMZTt0dCsrKXtsZXQgbnQ9MDtmb3IobGV0IFJlPVVlO1JlPG10O1JlKyspe2xldCBndD0kW3ZlKlUrc3QqSCtSZSpxXSxHbj1TW1JlKksrdHQqWit1ZSpKXTtudCs9Z3QqR259dGVbaWUqZWUrKHN0KkYrdHQpXSs9bnR9fX19fXJldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEkpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oTiksbi5tYWtlVGVuc29ySW5mbyh5LGFlLmR0eXBlLGFlLnZhbHVlcyl9dmFyIERLPXtrZXJuZWxOYW1lOlJpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp3X307ZnVuY3Rpb24gUksoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHthOnIsYjpzLGJpYXM6aSxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOm99PXQse3RyYW5zcG9zZUE6bCx0cmFuc3Bvc2VCOnUsYWN0aXZhdGlvbjpwLGxlYWt5cmVsdUFscGhhOmR9PWEsYyxoLG0sZj1bXTtjPXdfKHtpbnB1dHM6e2E6cixiOnN9LGF0dHJzOnt0cmFuc3Bvc2VBOmwsdHJhbnNwb3NlQjp1fSxiYWNrZW5kOm59KSxpJiYoaD1qbCh7aW5wdXRzOnthOmMsYjppfSxiYWNrZW5kOm59KSxmLnB1c2goYyksYz1oKSxwJiYobT1wbShuLGMscCxvLGQpLGYucHVzaChjKSxjPW0pO2ZvcihsZXQgZyBvZiBmKW4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZyk7cmV0dXJuIGN9dmFyIE1LPXtrZXJuZWxOYW1lOmlpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpSS30sT0s9bHQoTmksZT0+TWF0aC5hY29zKGUpKSxQSz17a2VybmVsTmFtZTpOaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6T0t9LExLPWx0KFRpLGU9Pk1hdGguYWNvc2goZSkpLHpLPXtrZXJuZWxOYW1lOlRpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpMS307ZnVuY3Rpb24gV0soZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSxhPXQ7Z2UodCxcImFkZE5cIik7bGV0IHI9YS5tYXAobz0+bi5kYXRhLmdldChvLmRhdGFJZCkudmFsdWVzKSxzPU9lKGFbMF0uc2hhcGUsYVswXS5kdHlwZSksaT1zLnZhbHVlcztmb3IobGV0IG89MDtvPGEubGVuZ3RoO28rKyl7bGV0IGw9cltvXTtmb3IobGV0IHU9MDt1PGkubGVuZ3RoO3UrKylpW3VdKz1sW3VdfXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKHMuc2hhcGUscy5kdHlwZSxzLnZhbHVlcyl9dmFyIEJLPXtrZXJuZWxOYW1lOkNpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpXS307ZnVuY3Rpb24gVksoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxrZWVwRGltczppfT1hO2dlKHIsXCJhbGxcIik7bGV0IG89dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLGw9byx1PVQuZ2V0QXhlc1Blcm11dGF0aW9uKGwsci5zaGFwZS5sZW5ndGgpLHA9cjt1IT1udWxsJiYocD1Wbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTp1fX0pLGw9VC5nZXRJbm5lck1vc3RBeGVzKGwubGVuZ3RoLHIuc2hhcGUubGVuZ3RoKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFsbFwiLGwscC5zaGFwZS5sZW5ndGgpO2xldFtkLGNdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhwLnNoYXBlLGwpLGg9dy5zaXplRnJvbVNoYXBlKGMpLG09dy5tYWtlWmVyb3NUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZShkKSxwLmR0eXBlKSxmPW4uZGF0YS5nZXQocC5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGI9MDtiPG0ubGVuZ3RoOysrYil7bGV0IHk9YipoLHg9Zlt5XTtmb3IobGV0IHY9MDt2PGg7Kyt2KXtsZXQgST1mW3krdl07eD14JiZJfW1bYl09eH11IT1udWxsJiZuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApO2xldCBnPW4ubWFrZVRlbnNvckluZm8oZCxwLmR0eXBlLG0pO2lmKGkpe2xldCBiPVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oZCxvKSx5PXh0KHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpifX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLHl9cmV0dXJuIGd9dmFyIFVLPXtrZXJuZWxOYW1lOlpsLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpWS307ZnVuY3Rpb24gR0soZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxrZWVwRGltczppfT1hO2dlKHIsXCJhbnlcIik7bGV0IG89dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLGw9byx1PVQuZ2V0QXhlc1Blcm11dGF0aW9uKGwsci5zaGFwZS5sZW5ndGgpLHA9cjt1IT1udWxsJiYocD1Wbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTp1fX0pLGw9VC5nZXRJbm5lck1vc3RBeGVzKGwubGVuZ3RoLHIuc2hhcGUubGVuZ3RoKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFueVwiLGwscC5zaGFwZS5sZW5ndGgpO2xldFtkLGNdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhwLnNoYXBlLGwpLGg9dy5zaXplRnJvbVNoYXBlKGMpLG09dy5tYWtlWmVyb3NUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZShkKSxwLmR0eXBlKSxmPW4uZGF0YS5nZXQocC5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGI9MDtiPG0ubGVuZ3RoOysrYil7bGV0IHk9YipoLHg9Zlt5XTtmb3IobGV0IHY9MDt2PGg7Kyt2KXtsZXQgST1mW3krdl07eD14fHxJfW1bYl09eH11IT1udWxsJiZuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApO2xldCBnPW4ubWFrZVRlbnNvckluZm8oZCxwLmR0eXBlLG0pO2lmKGkpe2xldCBiPVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oZCxvKSx5PXh0KHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpifX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLHl9cmV0dXJuIGd9dmFyIEhLPXtrZXJuZWxOYW1lOkpsLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpHS307ZnVuY3Rpb24gaksoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6c309YTtnZShyLFwiYXJnTWF4XCIpO2xldCBpPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxvPVQuZ2V0QXhlc1Blcm11dGF0aW9uKGksci5zaGFwZS5sZW5ndGgpLGw9cix1PVtdO28hPW51bGwmJihsPVZuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOm99fSksdS5wdXNoKGwpLGk9VC5nZXRJbm5lck1vc3RBeGVzKGkubGVuZ3RoLGwuc2hhcGUubGVuZ3RoKSksaT1baVswXV0sVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01heFwiLGksbC5zaGFwZS5sZW5ndGgpO2xldFtwLGRdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhsLnNoYXBlLGkpLGM9dy5zaXplRnJvbVNoYXBlKHApLGg9dy5tYWtlWmVyb3NUeXBlZEFycmF5KGMsXCJpbnQzMlwiKSxtPXcuc2l6ZUZyb21TaGFwZShkKSxmPW4uZGF0YS5nZXQobC5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGc9MDtnPGgubGVuZ3RoOysrZyl7bGV0IGI9ZyptLHk9ZltiXSx4PTA7Zm9yKGxldCB2PTA7djxtOysrdil7bGV0IEk9ZltiK3ZdO0k+eSYmKHk9SSx4PXYpfWhbZ109eH1yZXR1cm4gdS5mb3JFYWNoKGc9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZykpLG4ubWFrZVRlbnNvckluZm8ocCxcImludDMyXCIsaCl9dmFyIHFLPXtrZXJuZWxOYW1lOlFsLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpqS307ZnVuY3Rpb24gS0soZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6c309YTtnZShyLFwiYXJnTWluXCIpO2xldCBpPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxvPVQuZ2V0QXhlc1Blcm11dGF0aW9uKGksci5zaGFwZS5sZW5ndGgpLGw9cix1PVtdO28hPW51bGwmJihsPVZuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOm99fSksdS5wdXNoKGwpLGk9VC5nZXRJbm5lck1vc3RBeGVzKGkubGVuZ3RoLGwuc2hhcGUubGVuZ3RoKSksaT1baVswXV0sVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFyZ01pblwiLGksbC5zaGFwZS5sZW5ndGgpO2xldFtwLGRdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhsLnNoYXBlLGkpLGM9dy5zaXplRnJvbVNoYXBlKHApLGg9dy5tYWtlWmVyb3NUeXBlZEFycmF5KGMsXCJpbnQzMlwiKSxtPXcuc2l6ZUZyb21TaGFwZShkKSxmPW4uZGF0YS5nZXQobC5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGc9MDtnPGgubGVuZ3RoOysrZyl7bGV0IGI9ZyptLHk9ZltiXSx4PTA7Zm9yKGxldCB2PTA7djxtOysrdil7bGV0IEk9ZltiK3ZdO0k8eSYmKHk9SSx4PXYpfWhbZ109eH1yZXR1cm4gdS5mb3JFYWNoKGc9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZykpLG4ubWFrZVRlbnNvckluZm8ocCxcImludDMyXCIsaCl9dmFyIFhLPXtrZXJuZWxOYW1lOmV1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpLS30sWUs9bHQoRWksZT0+TWF0aC5hc2luKGUpKSxaSz17a2VybmVsTmFtZTpFaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6WUt9LEpLPWx0KF9pLGU9Pk1hdGguYXNpbmgoZSkpLFFLPXtrZXJuZWxOYW1lOl9pLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpKS30sZVg9bHQoQWksZT0+TWF0aC5hdGFuKGUpKSx0WD17a2VybmVsTmFtZTpBaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ZVh9LG5YPU10KChlLHQpPT5NYXRoLmF0YW4yKGUsdCkpLGFYPVp0KCRpLG5YKSxyWD17a2VybmVsTmFtZTokaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6YVh9LHNYPWx0KEZpLGU9Pk1hdGguYXRhbmgoZSkpLGlYPXtrZXJuZWxOYW1lOkZpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpzWH07ZnVuY3Rpb24gSzEoZSx0LG4sYSxyLHMpe2xldCBpPXIuc3RyaWRlSGVpZ2h0LG89ci5zdHJpZGVXaWR0aCxsPXIuZGlsYXRpb25IZWlnaHQsdT1yLmRpbGF0aW9uV2lkdGgscD1yLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxkPXIuZWZmZWN0aXZlRmlsdGVyV2lkdGgsYz1yLnBhZEluZm8udG9wLGg9ci5wYWRJbmZvLmxlZnQsbT1zPT09XCJtYXhcIj9OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGY9T2Uoci5vdXRTaGFwZSxuKSxnPWYudmFsdWVzLGI9ci5vdXRTaGFwZVsxXSpyLm91dFNoYXBlWzJdKnIub3V0U2hhcGVbM10seT1yLm91dFNoYXBlWzJdKnIub3V0U2hhcGVbM10seD1yLm91dFNoYXBlWzNdO2ZvcihsZXQgdj0wO3Y8ci5iYXRjaFNpemU7Kyt2KXtsZXQgST12KmIsTj12KmFbMF07Zm9yKGxldCBDPTA7QzxyLmluQ2hhbm5lbHM7KytDKWZvcihsZXQgXz0wO188ci5vdXRIZWlnaHQ7KytfKXtsZXQgRj1fKmktYyxEPU1hdGgubWF4KDAsRiksJD1NYXRoLm1pbihyLmluSGVpZ2h0LHArRiksUz1JK18qeTtmb3IobGV0IE09MDtNPHIub3V0V2lkdGg7KytNKXtsZXQgQj1NKm8taCxVPU1hdGgubWF4KDAsQiksSD1NYXRoLm1pbihyLmluV2lkdGgsZCtCKSxxPW0sSz0wLFo9MDtmb3IobGV0IGVlPUQ7ZWU8JDtlZSs9bCl7bGV0IGFlPU4rZWUqYVsxXTtmb3IobGV0IHRlPVU7dGU8SDt0ZSs9dSl7bGV0IHNlPWFlK3RlKmFbMl0saWU9ZVtzZStDXTtzPT09XCJtYXhcIiYmaWU+cT9xPWllOnM9PT1cImF2Z1wiJiYoSys9aWUsWisrKX1pZihpc05hTihxKSlicmVha31sZXQgSj1TK00qeCtDO2dbSl09cz09PVwiYXZnXCI/Sy9aOnF9fX1yZXR1cm4gZn1mdW5jdGlvbiBrXyhlLHQsbixhLHI9ITEscz0hMSl7bGV0IGk9T2UoYS5vdXRTaGFwZSxcImludDMyXCIpLG89YS5zdHJpZGVIZWlnaHQsbD1hLnN0cmlkZVdpZHRoLHU9YS5kaWxhdGlvbkhlaWdodCxwPWEuZGlsYXRpb25XaWR0aCxkPWEuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGM9YS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxoPWEucGFkSW5mby50b3AsbT1hLnBhZEluZm8ubGVmdCxmPU9lKHQsbixlKTtmb3IobGV0IGc9MDtnPGEuYmF0Y2hTaXplOysrZylmb3IobGV0IGI9MDtiPGEuaW5DaGFubmVsczsrK2IpZm9yKGxldCB5PTA7eTxhLm91dEhlaWdodDsrK3kpe2xldCB4PXkqby1oLHY9eDtmb3IoO3Y8MDspdis9dTtsZXQgST1NYXRoLm1pbihhLmluSGVpZ2h0LGQreCk7Zm9yKGxldCBOPTA7TjxhLm91dFdpZHRoOysrTil7bGV0IEM9TipsLW0sXz1DO2Zvcig7XzwwOylfKz1wO2xldCBGPU1hdGgubWluKGEuaW5XaWR0aCxjK0MpLEQ9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCQ9LTE7Zm9yKGxldCBTPXY7UzxJO1MrPXUpe2xldCBNPVMteDtmb3IobGV0IEI9XztCPEY7Qis9cCl7bGV0IFU9Qi1DLEg9Zi5nZXQoZyxTLEIsYik7SD5EJiYoRD1ILHI/JD1zPygoZyphLmluSGVpZ2h0K1MpKmEuaW5XaWR0aCtCKSphLmluQ2hhbm5lbHMrYjooUyphLmluV2lkdGgrQikqYS5pbkNoYW5uZWxzK2I6JD1NKmMrVSl9fWkuc2V0KCQsZyx5LE4sYil9fXJldHVybiBpfWZ1bmN0aW9uIElfKGUsdCxuLGEscixzKXtsZXQgaT1yLnN0cmlkZURlcHRoLG89ci5zdHJpZGVIZWlnaHQsbD1yLnN0cmlkZVdpZHRoLHU9ci5kaWxhdGlvbkRlcHRoLHA9ci5kaWxhdGlvbkhlaWdodCxkPXIuZGlsYXRpb25XaWR0aCxjPXIuZWZmZWN0aXZlRmlsdGVyRGVwdGgsaD1yLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxtPXIuZWZmZWN0aXZlRmlsdGVyV2lkdGgsZj1yLnBhZEluZm8uZnJvbnQsZz1yLnBhZEluZm8udG9wLGI9ci5wYWRJbmZvLmxlZnQseT1zPT09XCJtYXhcIj9OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHg9T2Uoci5vdXRTaGFwZSxuKSx2PXgudmFsdWVzLEk9ci5vdXRTaGFwZVsxXSpyLm91dFNoYXBlWzJdKnIub3V0U2hhcGVbM10qci5vdXRTaGFwZVs0XSxOPXIub3V0U2hhcGVbMl0qci5vdXRTaGFwZVszXSpyLm91dFNoYXBlWzRdLEM9ci5vdXRTaGFwZVszXSpyLm91dFNoYXBlWzRdLF89ci5vdXRTaGFwZVs0XTtmb3IobGV0IEY9MDtGPHIuYmF0Y2hTaXplOysrRil7bGV0IEQ9RipJLCQ9RiphWzBdO2ZvcihsZXQgUz0wO1M8ci5pbkNoYW5uZWxzOysrUylmb3IobGV0IE09MDtNPHIub3V0RGVwdGg7KytNKXtsZXQgQj1NKmktZixVPUI7Zm9yKDtVPDA7KVUrPXU7bGV0IEg9TWF0aC5taW4oci5pbkRlcHRoLGMrQikscT1EK00qTjtmb3IobGV0IEs9MDtLPHIub3V0SGVpZ2h0OysrSyl7bGV0IFo9SypvLWcsSj1aO2Zvcig7SjwwOylKKz1wO2xldCBlZT1NYXRoLm1pbihyLmluSGVpZ2h0LGgrWiksYWU9cStLKkM7Zm9yKGxldCB0ZT0wO3RlPHIub3V0V2lkdGg7Kyt0ZSl7bGV0IHNlPXRlKmwtYixpZT1zZTtmb3IoO2llPDA7KWllKz1kO2xldCB2ZT1NYXRoLm1pbihyLmluV2lkdGgsbStzZSksdWU9YWUrdGUqXyx5ZT15LGtlPTAsU2U9MDtmb3IobGV0IFVlPVU7VWU8SDtVZSs9dSl7bGV0IG10PSQrVWUqYVsxXTtmb3IobGV0IHN0PUo7c3Q8ZWU7c3QrPXApe2xldCB0dD1tdCtzdCphWzJdO2ZvcihsZXQgbnQ9aWU7bnQ8dmU7bnQrPWQpe2xldCBSZT10dCtudCphWzNdLGd0PWVbUmUrU107aWYocz09PVwibWF4XCImJmd0PnllP3llPWd0OnM9PT1cImF2Z1wiJiYoa2UrPWd0LFNlKyspLGlzTmFOKHllKSlicmVha31pZihpc05hTih5ZSkpYnJlYWt9aWYoaXNOYU4oeWUpKWJyZWFrfWxldCBMZT11ZStTO3ZbTGVdPXM9PT1cImF2Z1wiP2tlL01hdGgubWF4KFNlLDEpOnllfX19fXJldHVybiB4fWZ1bmN0aW9uIG9YKGUsdCl7bGV0IG49T2UodC5vdXRTaGFwZSxcImludDMyXCIpLGE9dC5zdHJpZGVEZXB0aCxyPXQuc3RyaWRlSGVpZ2h0LHM9dC5zdHJpZGVXaWR0aCxpPXQuZGlsYXRpb25EZXB0aCxvPXQuZGlsYXRpb25IZWlnaHQsbD10LmRpbGF0aW9uV2lkdGgsdT10LmVmZmVjdGl2ZUZpbHRlckRlcHRoLHA9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsZD10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGM9dC5wYWRJbmZvLmZyb250LGg9dC5wYWRJbmZvLnRvcCxtPXQucGFkSW5mby5sZWZ0O2ZvcihsZXQgZj0wO2Y8dC5iYXRjaFNpemU7KytmKWZvcihsZXQgZz0wO2c8dC5pbkNoYW5uZWxzOysrZylmb3IobGV0IGI9MDtiPHQub3V0RGVwdGg7KytiKXtsZXQgeT1iKmEtYyx4PXk7Zm9yKDt4PDA7KXgrPWk7bGV0IHY9TWF0aC5taW4odC5pbkRlcHRoLHUreSk7Zm9yKGxldCBJPTA7STx0Lm91dEhlaWdodDsrK0kpe2xldCBOPUkqci1oLEM9Tjtmb3IoO0M8MDspQys9bztsZXQgXz1NYXRoLm1pbih0LmluSGVpZ2h0LHArTik7Zm9yKGxldCBGPTA7Rjx0Lm91dFdpZHRoOysrRil7bGV0IEQ9RipzLW0sJD1EO2Zvcig7JDwwOykkKz1sO2xldCBTPU1hdGgubWluKHQuaW5XaWR0aCxkK0QpLE09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLEI9LTE7Zm9yKGxldCBVPXg7VTx2O1UrPWkpe2xldCBIPVUteTtmb3IobGV0IHE9QztxPF87cSs9byl7bGV0IEs9cS1OO2ZvcihsZXQgWj0kO1o8UztaKz1sKXtsZXQgSj1aLUQsZWU9ZS5nZXQoZixVLHEsWixnKTtlZT49TSYmKE09ZWUsQj1IKnAqZCtLKnArSil9fX1uLnNldChCLGYsYixJLEYsZyl9fX1yZXR1cm4gbn1mdW5jdGlvbiBsWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dDtnZShyLFwiYXZnUG9vbFwiKTtsZXR7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkaW1Sb3VuZGluZ01vZGU6bH09YSx1PTE7dy5hc3NlcnQoVC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoaSx1KSwoKT0+YEVycm9yIGluIGF2Z1Bvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7aX0gYW5kIGRpbGF0aW9ucyAnJHt1fSdgKTtsZXQgcD1ULmNvbXB1dGVQb29sMkRJbmZvKHIuc2hhcGUscyxpLHUsbyxsKSxkO2lmKHAuZmlsdGVyV2lkdGg9PT0xJiZwLmZpbHRlckhlaWdodD09PTEmJncuYXJyYXlzRXF1YWwocC5pblNoYXBlLHAub3V0U2hhcGUpKWQ9Y3Ioe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KTtlbHNle2xldCBjPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxoPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksbT1LMShjLHIuc2hhcGUsci5kdHlwZSxoLHAsXCJhdmdcIik7ZD1uLm1ha2VUZW5zb3JJbmZvKHAub3V0U2hhcGUsci5kdHlwZSxtLnZhbHVlcyl9cmV0dXJuIGR9dmFyIHVYPXtrZXJuZWxOYW1lOkRpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpsWH07ZnVuY3Rpb24gcFgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8sZGltUm91bmRpbmdNb2RlOmwsZGF0YUZvcm1hdDp1fT1hO2dlKHIsXCJhdmdQb29sM2RcIik7bGV0IHA9VC5jb21wdXRlUG9vbDNESW5mbyhyLnNoYXBlLHMsaSwxLG8sbCx1KSxkPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxjPUlfKGQsci5zaGFwZSxyLmR0eXBlLHcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSkscCxcImF2Z1wiKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhjLnNoYXBlLFwiZmxvYXQzMlwiLGMudmFsdWVzKX12YXIgY1g9e2tlcm5lbE5hbWU6dHUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnBYfTtmdW5jdGlvbiBkWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCx7ZmlsdGVyU2l6ZTppLHN0cmlkZXM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dX09YTtnZShbcixzXSxcImF2Z1Bvb2wzREdyYWRcIik7bGV0IHA9VC5jb21wdXRlUG9vbDNESW5mbyhzLnNoYXBlLGksbywxLGwsdSksZD1wLnN0cmlkZURlcHRoLGM9cC5zdHJpZGVIZWlnaHQsaD1wLnN0cmlkZVdpZHRoLG09cC5maWx0ZXJEZXB0aCxmPXAuZmlsdGVySGVpZ2h0LGc9cC5maWx0ZXJXaWR0aCxiPXAuZGlsYXRpb25EZXB0aCx5PXAuZGlsYXRpb25IZWlnaHQseD1wLmRpbGF0aW9uV2lkdGgsdj1wLmVmZmVjdGl2ZUZpbHRlckRlcHRoLEk9cC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsTj1wLmVmZmVjdGl2ZUZpbHRlcldpZHRoLEM9di0xLXAucGFkSW5mby5mcm9udCxfPU4tMS1wLnBhZEluZm8ubGVmdCxGPUktMS1wLnBhZEluZm8udG9wLEQ9T2Uocy5zaGFwZSxcImZsb2F0MzJcIiksJD0xLyhtKmYqZyksUz1uLmJ1ZmZlclN5bmMocik7Zm9yKGxldCBNPTA7TTxwLmJhdGNoU2l6ZTsrK00pZm9yKGxldCBCPTA7QjxwLmluQ2hhbm5lbHM7KytCKWZvcihsZXQgVT0wO1U8cC5pbkRlcHRoOysrVSlmb3IobGV0IEg9MDtIPHAuaW5IZWlnaHQ7KytIKWZvcihsZXQgcT0wO3E8cC5pbldpZHRoOysrcSl7bGV0IEs9VS1DLFo9SC1GLEo9cS1fLGVlPTA7Zm9yKGxldCBhZT0wO2FlPHY7YWUrPWIpe2xldCB0ZT0oSythZSkvZDtpZighKHRlPDB8fHRlPj1wLm91dERlcHRofHxNYXRoLmZsb29yKHRlKSE9PXRlKSlmb3IobGV0IHNlPTA7c2U8STtzZSs9eSl7bGV0IGllPShaK3NlKS9jO2lmKCEoaWU8MHx8aWU+PXAub3V0SGVpZ2h0fHxNYXRoLmZsb29yKGllKSE9PWllKSlmb3IobGV0IHZlPTA7dmU8Tjt2ZSs9eCl7bGV0IHVlPShKK3ZlKS9oO2lmKHVlPDB8fHVlPj1wLm91dFdpZHRofHxNYXRoLmZsb29yKHVlKSE9PXVlKWNvbnRpbnVlO2xldCB5ZT1TLmdldChNLHRlLGllLHVlLEIpO2VlKz15ZX19fUQuc2V0KGVlKiQsTSxVLEgscSxCKX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhELnNoYXBlLEQuZHR5cGUsRC52YWx1ZXMpfXZhciBoWD17a2VybmVsTmFtZTpSYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ZFh9O2Z1bmN0aW9uIG1YKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixpbnB1dDpzfT10LGk9cztnZShbcixzXSxcImF2Z1Bvb2xHcmFkXCIpO2xldHtmaWx0ZXJTaXplOm8sc3RyaWRlczpsLHBhZDp1fT1hLHA9VC5jb21wdXRlUG9vbDJESW5mbyhpLnNoYXBlLG8sbCwxLHUpLGQ9cC5zdHJpZGVIZWlnaHQsYz1wLnN0cmlkZVdpZHRoLGg9cC5maWx0ZXJIZWlnaHQsbT1wLmZpbHRlcldpZHRoLGY9cC5kaWxhdGlvbkhlaWdodCxnPXAuZGlsYXRpb25XaWR0aCxiPXAuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHk9cC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCx4PXktMS1wLnBhZEluZm8ubGVmdCx2PWItMS1wLnBhZEluZm8udG9wLEk9T2UoaS5zaGFwZSxcImZsb2F0MzJcIiksTj0xLyhoKm0pLEM9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLF89T2Uoci5zaGFwZSxcImZsb2F0MzJcIixDKTtmb3IobGV0IEY9MDtGPHAuYmF0Y2hTaXplOysrRilmb3IobGV0IEQ9MDtEPHAuaW5DaGFubmVsczsrK0QpZm9yKGxldCAkPTA7JDxwLmluSGVpZ2h0OysrJClmb3IobGV0IFM9MDtTPHAuaW5XaWR0aDsrK1Mpe2xldCBNPSQtdixCPVMteCxVPTA7Zm9yKGxldCBIPTA7SDxiO0grPWYpe2xldCBxPShNK0gpL2Q7aWYoIShxPDB8fHE+PXAub3V0SGVpZ2h0fHxNYXRoLmZsb29yKHEpIT09cSkpZm9yKGxldCBLPTA7Szx5O0srPWcpe2xldCBaPShCK0spL2M7aWYoWjwwfHxaPj1wLm91dFdpZHRofHxNYXRoLmZsb29yKFopIT09Wiljb250aW51ZTtsZXQgSj1fLmdldChGLHEsWixEKTtVKz1KfX1JLnNldChVKk4sRiwkLFMsRCl9cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oSS5zaGFwZSxJLmR0eXBlLEkudmFsdWVzKX12YXIgZlg9e2tlcm5lbE5hbWU6RGMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOm1YfTtmdW5jdGlvbiBnWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixzY2FsZTpzLG9mZnNldDppLG1lYW46byx2YXJpYW5jZTpsfT10O3cuYXNzZXJ0KG8uc2hhcGUubGVuZ3RoPT09bC5zaGFwZS5sZW5ndGgsKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCB2YXJpYW5jZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSx3LmFzc2VydChpPT1udWxsfHxvLnNoYXBlLmxlbmd0aD09PWkuc2hhcGUubGVuZ3RoLCgpPT5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgb2Zmc2V0IHRvIGhhdmUgZXF1YWwgcmFua3MuXCIpLHcuYXNzZXJ0KHM9PW51bGx8fG8uc2hhcGUubGVuZ3RoPT09cy5zaGFwZS5sZW5ndGgsKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBzY2FsZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwiKSxnZShbcixvLGwscyxpXSxcImJhdGNoTm9ybVwiKTtsZXR7dmFyaWFuY2VFcHNpbG9uOnV9PWE7dT09bnVsbCYmKHU9LjAwMSk7bGV0IHA9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGQ9bi5kYXRhLmdldChvLmRhdGFJZCkudmFsdWVzLGM9bi5kYXRhLmdldChsLmRhdGFJZCkudmFsdWVzLGg9cz9uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXM6bmV3IEZsb2F0MzJBcnJheShbMV0pLG09aT9uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXM6bmV3IEZsb2F0MzJBcnJheShbMF0pLGY9bmV3IEZsb2F0MzJBcnJheShwLmxlbmd0aCksZz1tLmxlbmd0aCxiPWgubGVuZ3RoLHk9Yy5sZW5ndGgseD1kLmxlbmd0aCx2PTAsST0wLE49MCxDPTA7Zm9yKGxldCBfPTA7XzxwLmxlbmd0aDsrK18pZltfXT1tW3YrK10rKHBbX10tZFtJKytdKSpoW04rK10vTWF0aC5zcXJ0KGNbQysrXSt1KSx2Pj1nJiYodj0wKSxJPj14JiYoST0wKSxOPj1iJiYoTj0wKSxDPj15JiYoQz0wKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLHIuZHR5cGUsZil9dmFyIGJYPXtrZXJuZWxOYW1lOkppLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpnWH07ZnVuY3Rpb24geVgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2Jsb2NrU2hhcGU6cyxjcm9wczppfT1hO2dlKFtyXSxcImJhdGNoVG9TcGFjZU5EXCIpO2xldCBvPXMucmVkdWNlKChiLHkpPT5iKnkpLGw9VC5nZXRSZXNoYXBlZChyLnNoYXBlLHMsbyksdT1ULmdldFBlcm11dGVkKGwubGVuZ3RoLHMubGVuZ3RoKSxwPVQuZ2V0UmVzaGFwZWRQZXJtdXRlZChyLnNoYXBlLHMsbyksZD1ULmdldFNsaWNlQmVnaW5Db29yZHMoaSxzLmxlbmd0aCksYz1ULmdldFNsaWNlU2l6ZShwLGkscy5sZW5ndGgpLGg9eHQoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmx9fSksbT1Wbih7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6bixhdHRyczp7cGVybTp1fX0pLGY9eHQoe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnB9fSksZz14aSh7aW5wdXRzOnt4OmZ9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46ZCxzaXplOmN9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLGd9dmFyIHhYPXtrZXJuZWxOYW1lOm51LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp5WH07ZnVuY3Rpb24gdlgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsd2VpZ2h0czpzfT10LHtzaXplOml9PWEsbz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsbD1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsdT1QMShvLGwscy5kdHlwZSxzLnNoYXBlLGkpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtpXSxzLmR0eXBlLHUpfXZhciB3WD17a2VybmVsTmFtZTphdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6dlh9O2Z1bmN0aW9uIGtYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3MwOmEsczE6cn09dCxzPW4uZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxpPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxvPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoQXJyYXkuZnJvbShzKSxBcnJheS5mcm9tKGkpKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbby5sZW5ndGhdLFwiaW50MzJcIixJbnQzMkFycmF5LmZyb20obykpfXZhciBJWD17a2VybmVsTmFtZTpNYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6a1h9LFNYPWx0KHdzLChlLHQpPT57bGV0IG49dDtyZXR1cm4gZT5uLmNsaXBWYWx1ZU1heD9uLmNsaXBWYWx1ZU1heDplPG4uY2xpcFZhbHVlTWluP24uY2xpcFZhbHVlTWluOmV9KSxOWD17a2VybmVsTmFtZTp3cyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6U1h9LFRYPWU9PntsZXR7eDp0fT1lLmlucHV0cyxuPWUuYmFja2VuZCxhPW5ldyBGbG9hdDMyQXJyYXkody5zaXplRnJvbVNoYXBlKHQuc2hhcGUpKSxyPW4uZGF0YS5nZXQodC5kYXRhSWQpLHM9ci5jb21wbGV4VGVuc29ySW5mb3MucmVhbCxpPXIuY29tcGxleFRlbnNvckluZm9zLmltYWcsbz1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsbD1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCB1PTA7dTxvLmxlbmd0aDt1Kyspe2xldCBwPW9bdV0sZD1sW3VdO2FbdV09TWF0aC5oeXBvdChwLGQpfXJldHVybiBuLm1ha2VPdXRwdXQoYSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sQ1g9e2tlcm5lbE5hbWU6T2MsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlRYfTtmdW5jdGlvbiBxbChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dDphfT10LHI9bi5kYXRhLmdldChhLmRhdGFJZCkuY29tcGxleFRlbnNvckluZm9zLmltYWcscz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXM7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oci5zaGFwZSxyLmR0eXBlLHMpfXZhciBFWD17a2VybmVsTmFtZTpfbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6cWx9O2Z1bmN0aW9uIEtsKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7YXhpczpyfT1hLHM9dy5wYXJzZUF4aXNQYXJhbShyLHRbMF0uc2hhcGUpWzBdLGk9dC5tYXAoZj0+Zi5zaGFwZSk7VC5hc3NlcnRQYXJhbXNDb25zaXN0ZW50KGkscyk7bGV0IG89VC5jb21wdXRlT3V0U2hhcGUodC5tYXAoZj0+Zi5zaGFwZSkscyk7aWYody5zaXplRnJvbVNoYXBlKG8pPT09MClyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhvLHRbMF0uZHR5cGUsW10pO2xldCBsPXQuZmlsdGVyKGY9Pncuc2l6ZUZyb21TaGFwZShmLnNoYXBlKT4wKTtpZihsLmxlbmd0aD09PTEpcmV0dXJuIGNyKHtpbnB1dHM6e3g6bFswXX0sYmFja2VuZDpufSk7aWYobFswXS5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCBmPWwubWFwKHY9PnlpKHtpbnB1dHM6e2lucHV0OnZ9LGJhY2tlbmQ6bn0pKSxnPWwubWFwKHY9PnFsKHtpbnB1dHM6e2lucHV0OnZ9LGJhY2tlbmQ6bn0pKSxiPUtsKHtpbnB1dHM6ZixiYWNrZW5kOm4sYXR0cnM6e2F4aXM6c319KSx5PUtsKHtpbnB1dHM6ZyxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6c319KSx4PVluKHtpbnB1dHM6e3JlYWw6YixpbWFnOnl9LGJhY2tlbmQ6bn0pO3JldHVybiBmLmZvckVhY2godj0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh2KSksZy5mb3JFYWNoKHY9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odikpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYiksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSx4fWxldCB1PWwubWFwKGY9PntsZXQgZz1bLTEsdy5zaXplRnJvbVNoYXBlKGYuc2hhcGUuc2xpY2UocykpXTtyZXR1cm4geHQoe2lucHV0czp7eDpmfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmd9fSl9KSxwPXUubWFwKGY9Pih7dmFsczpuLmRhdGEuZ2V0KGYuZGF0YUlkKS52YWx1ZXMsc2hhcGU6Zi5zaGFwZX0pKTtvPVQuY29tcHV0ZU91dFNoYXBlKHUubWFwKGY9PmYuc2hhcGUpLDEpO2xldCBkPXVbMF0uc2hhcGVbMF09PT0xLGM9TDEocCxvLHRbMF0uZHR5cGUsZCksaD1ULmNvbXB1dGVPdXRTaGFwZShsLm1hcChmPT5mLnNoYXBlKSxzKSxtPW4ubWFrZVRlbnNvckluZm8oaCx0WzBdLmR0eXBlLGMpO3JldHVybiB1LmZvckVhY2goZj0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSksbX12YXIgX1g9e2tlcm5lbE5hbWU6c3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOktsfTtmdW5jdGlvbiBTXyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLHBhZDpvLGRhdGFGb3JtYXQ6bCxkaWxhdGlvbnM6dSxkaW1Sb3VuZGluZ01vZGU6cH09YTtnZShbcixzXSxcImNvbnYyZFwiKTtsZXQgZD1ULmNvbnZlcnRDb252MkREYXRhRm9ybWF0KGwpLGM9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsaSx1LG8scCwhMSxkKSxoPWMuZmlsdGVySGVpZ2h0LG09Yy5maWx0ZXJXaWR0aCxmPWMuZGlsYXRpb25IZWlnaHQsZz1jLmRpbGF0aW9uV2lkdGgsYj1jLnBhZEluZm8ubGVmdCx5PWMucGFkSW5mby50b3AseD1jLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiLHY9bmV3IFd0KGMub3V0U2hhcGUsci5kdHlwZSksST13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLE49dy5jb21wdXRlU3RyaWRlcyhzLnNoYXBlKSxDPUlbMF0sXz14P0lbMV06SVsyXSxGPXg/SVsyXToxLEQ9eD8xOklbMV0sJD12LnN0cmlkZXNbMF0sUz14P3Yuc3RyaWRlc1sxXTp2LnN0cmlkZXNbMl0sTT14P3Yuc3RyaWRlc1syXToxLEI9eD8xOnYuc3RyaWRlc1sxXSxVPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxIPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxxPXYudmFsdWVzO2ZvcihsZXQgSz0wO0s8Yy5iYXRjaFNpemU7KytLKXtsZXQgWj1LKkMsSj1LKiQ7Zm9yKGxldCBlZT0wO2VlPGMub3V0SGVpZ2h0OysrZWUpe2xldCBhZT1KK2VlKlMsdGU9ZWUqYy5zdHJpZGVIZWlnaHQteTtmb3IobGV0IHNlPTA7c2U8aDsrK3NlKXtsZXQgaWU9dGUrc2UqZjtpZihpZTwwfHxpZT49Yy5pbkhlaWdodCljb250aW51ZTtsZXQgdmU9c2UqTlswXSx1ZT1aK2llKl87Zm9yKGxldCB5ZT0wO3llPGMub3V0V2lkdGg7Kyt5ZSl7bGV0IGtlPWFlK3llKk0sU2U9eWUqYy5zdHJpZGVXaWR0aC1iO2ZvcihsZXQgTGU9MDtMZTxtOysrTGUpe2xldCBVZT1TZStMZSpnO2lmKFVlPDB8fFVlPj1jLmluV2lkdGgpY29udGludWU7bGV0IG10PXZlK0xlKk5bMV0sc3Q9dWUrVWUqRix0dD1tdDtmb3IobGV0IG50PTA7bnQ8Yy5pbkNoYW5uZWxzOysrbnQpe2xldCBSZT1VW3N0K250KkRdO2ZvcihsZXQgZ3Q9MDtndDxjLm91dENoYW5uZWxzOysrZ3QpcVtrZStndCpCXSs9UmUqSFt0dCtndF07dHQrPWMub3V0Q2hhbm5lbHN9fX19fX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyh2LnNoYXBlLHYuZHR5cGUscSl9dmFyIEFYPXtrZXJuZWxOYW1lOlBpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpTX307ZnVuY3Rpb24gRlgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZHk6c309dCx7c3RyaWRlczppLHBhZDpvLGRhdGFGb3JtYXQ6bCxkaW1Sb3VuZGluZ01vZGU6dSxmaWx0ZXJTaGFwZTpwfT1hO2dlKFtyLHNdLFwiY29udjJkQmFja3Byb3BGaWx0ZXJcIik7bGV0IGQ9VC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChsKSxjPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxwLGksMSxvLHUsITEsZCkse3N0cmlkZUhlaWdodDpoLHN0cmlkZVdpZHRoOm0sZmlsdGVySGVpZ2h0OmYsZmlsdGVyV2lkdGg6Z309YyxiPWMuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCIseT1uZXcgV3QoYy5maWx0ZXJTaGFwZSxcImZsb2F0MzJcIikseD1jLnBhZEluZm8ubGVmdCx2PWMucGFkSW5mby50b3AsST1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsTj1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsQz1uZXcgV3Qoci5zaGFwZSxyLmR0eXBlLEkpLF89bmV3IFd0KHMuc2hhcGUscy5kdHlwZSxOKTtmb3IobGV0IEY9MDtGPGY7KytGKXtsZXQgRD1NYXRoLm1heCgwLE1hdGguY2VpbCgodi1GKS9oKSksJD1NYXRoLm1pbihjLm91dEhlaWdodCwoYy5pbkhlaWdodCt2LUYpL2gpO2ZvcihsZXQgUz0wO1M8ZzsrK1Mpe2xldCBNPU1hdGgubWF4KDAsTWF0aC5jZWlsKCh4LVMpL20pKSxCPU1hdGgubWluKGMub3V0V2lkdGgsKGMuaW5XaWR0aCt4LVMpL20pO2ZvcihsZXQgVT0wO1U8Yy5pbkNoYW5uZWxzOysrVSlmb3IobGV0IEg9MDtIPGMub3V0Q2hhbm5lbHM7KytIKXtsZXQgcT0wO2ZvcihsZXQgSz0wO0s8Yy5iYXRjaFNpemU7KytLKWZvcihsZXQgWj1EO1o8JDsrK1ope2xldCBKPUYrWipoLXY7Zm9yKGxldCBlZT1NO2VlPEI7KytlZSl7bGV0IGFlPVMrZWUqbS14O2I/cSs9Qy5nZXQoSyxKLGFlLFUpKl8uZ2V0KEssWixlZSxIKTpxKz1DLmdldChLLFUsSixhZSkqXy5nZXQoSyxILFosZWUpfX15LnNldChxLEYsUyxVLEgpfX19cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oeS5zaGFwZSx5LmR0eXBlLHkudmFsdWVzKX12YXIgJFg9e2tlcm5lbE5hbWU6a20sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkZYfTtmdW5jdGlvbiBEWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsZmlsdGVyOnN9PXQse2lucHV0U2hhcGU6aSxzdHJpZGVzOm8scGFkOmwsZGF0YUZvcm1hdDp1LGRpbVJvdW5kaW5nTW9kZTpwfT1hO2dlKFtyLHNdLFwiY29udjJkQmFja3Byb3BJbnB1dFwiKTtsZXQgZD13LmNvbXB1dGVTdHJpZGVzKHMuc2hhcGUpLGM9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxoPVQuY29udmVydENvbnYyRERhdGFGb3JtYXQodSksbT1ULmNvbXB1dGVDb252MkRJbmZvKGkscy5zaGFwZSxvLDEsbCxwLCExLGgpLGY9bmV3IFd0KG0uaW5TaGFwZSxcImZsb2F0MzJcIiksZz1mLnZhbHVlcyxiPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyx5PW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxbeCx2LEldPWQse2JhdGNoU2l6ZTpOLGZpbHRlckhlaWdodDpDLGZpbHRlcldpZHRoOl8saW5DaGFubmVsczpGLGluSGVpZ2h0OkQsaW5XaWR0aDokLG91dENoYW5uZWxzOlMsb3V0SGVpZ2h0Ok0sb3V0V2lkdGg6QixzdHJpZGVIZWlnaHQ6VSxzdHJpZGVXaWR0aDpIfT1tO2g9bS5kYXRhRm9ybWF0O2xldCBxPUMtMS1tLnBhZEluZm8udG9wLEs9Xy0xLW0ucGFkSW5mby5sZWZ0LFo9aD09PVwiY2hhbm5lbHNMYXN0XCIsSj1mLnN0cmlkZXNbMF0sZWU9Wj9mLnN0cmlkZXNbMV06Zi5zdHJpZGVzWzJdLGFlPVo/Zi5zdHJpZGVzWzJdOjEsdGU9Wj8xOmYuc3RyaWRlc1sxXSxzZT1jWzBdLGllPVo/Y1sxXTpjWzJdLHZlPVo/Y1syXToxLHVlPVo/MTpjWzFdO2ZvcihsZXQgeWU9MDt5ZTxOOysreWUpZm9yKGxldCBrZT0wO2tlPEY7KytrZSlmb3IobGV0IFNlPTA7U2U8RDsrK1NlKXtsZXQgTGU9U2UtcSxVZT1NYXRoLm1heCgwLE1hdGguY2VpbChMZS9VKSksbXQ9TWF0aC5taW4oTSwoQytMZSkvVSk7Zm9yKGxldCBzdD0wO3N0PCQ7KytzdCl7bGV0IHR0PXN0LUssbnQ9TWF0aC5tYXgoMCxNYXRoLmNlaWwodHQvSCkpLFJlPU1hdGgubWluKEIsKF8rdHQpL0gpLGd0PTA7Zm9yKGxldCBPdD1VZTtPdDxtdDsrK090KXtsZXQgaWE9T3QqVS1MZTtmb3IobGV0IHVuPW50O3VuPFJlOysrdW4pe2xldCBGbj11bipILXR0LG9hPXNlKnllK2llKk90K3ZlKnVuLCRuPXgqKEMtMS1pYSkrdiooXy0xLUZuKStJKmtlO2ZvcihsZXQgdXQ9MDt1dDxTOysrdXQpe2xldCBEbj1iW29hK3VlKnV0XSxIbj15WyRuK3V0XTtndCs9RG4qSG59fX1sZXQgR249Sip5ZStlZSpTZSthZSpzdCt0ZSprZTtnW0duXT1ndH19cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oZi5zaGFwZSxmLmR0eXBlLGYudmFsdWVzKX12YXIgUlg9e2tlcm5lbE5hbWU6TGksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkRYfTtmdW5jdGlvbiBNWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLHBhZDpvLGRpbGF0aW9uczpsfT1hO2dlKFtyLHNdLFwiY29udjNkXCIpO2xldCB1PVQuY29tcHV0ZUNvbnYzREluZm8oci5zaGFwZSxzLnNoYXBlLGksbCxvKSx7ZmlsdGVyRGVwdGg6cCxmaWx0ZXJIZWlnaHQ6ZCxmaWx0ZXJXaWR0aDpjLGRpbGF0aW9uRGVwdGg6aCxkaWxhdGlvbkhlaWdodDptLGRpbGF0aW9uV2lkdGg6ZixwYWRJbmZvOmd9PXUsYj1nLmZyb250LHk9Zy5sZWZ0LHg9Zy50b3Asdj1uZXcgV3QodS5vdXRTaGFwZSxyLmR0eXBlKSxJPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxOPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxDPXYudmFsdWVzLF89dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxGPXcuY29tcHV0ZVN0cmlkZXMocy5zaGFwZSk7Zm9yKGxldCBEPTA7RDx1LmJhdGNoU2l6ZTsrK0Qpe2xldCAkPUQqX1swXSxTPUQqdi5zdHJpZGVzWzBdO2ZvcihsZXQgTT0wO008dS5vdXREZXB0aDsrK00pe2xldCBCPVMrTSp2LnN0cmlkZXNbMV0sVT1NKnUuc3RyaWRlRGVwdGgtYjtmb3IobGV0IEg9MDtIPHA7KytIKXtsZXQgcT1VK0gqaDtpZihxPDB8fHE+PXUuaW5EZXB0aCljb250aW51ZTtsZXQgSz1IKkZbMF0sWj0kK3EqX1sxXTtmb3IobGV0IEo9MDtKPHUub3V0SGVpZ2h0OysrSil7bGV0IGVlPUIrSip2LnN0cmlkZXNbMl0sYWU9Sip1LnN0cmlkZUhlaWdodC14O2ZvcihsZXQgdGU9MDt0ZTxkOysrdGUpe2xldCBzZT1hZSt0ZSptO2lmKHNlPDB8fHNlPj11LmluSGVpZ2h0KWNvbnRpbnVlO2xldCBpZT1LK3RlKkZbMV0sdmU9WitzZSpfWzJdO2ZvcihsZXQgdWU9MDt1ZTx1Lm91dFdpZHRoOysrdWUpe2xldCB5ZT1lZSt1ZSp1Lm91dENoYW5uZWxzLGtlPXVlKnUuc3RyaWRlV2lkdGgteTtmb3IobGV0IFNlPTA7U2U8YzsrK1NlKXtsZXQgTGU9a2UrU2UqZjtpZihMZTwwfHxMZT49dS5pbldpZHRoKWNvbnRpbnVlO2xldCBVZT1pZStTZSpGWzJdLG10PXZlK0xlKnUuaW5DaGFubmVscyxzdD1VZTtmb3IobGV0IHR0PTA7dHQ8dS5pbkNoYW5uZWxzOysrdHQpe2xldCBudD1JW210K3R0XTtmb3IobGV0IFJlPTA7UmU8dS5vdXRDaGFubmVsczsrK1JlKUNbeWUrUmVdKz1udCpOW3N0K1JlXTtzdCs9dS5vdXRDaGFubmVsc319fX19fX19cmV0dXJuIG4ubWFrZVRlbnNvckluZm8odi5zaGFwZSx2LmR0eXBlLHYudmFsdWVzKX12YXIgT1g9e2tlcm5lbE5hbWU6emksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOk1YfTtmdW5jdGlvbiBQWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixkeTpzfT10LHtzdHJpZGVzOmkscGFkOm8sZmlsdGVyU2hhcGU6bH09YTtnZShbcixzXSxcImNvbnYzZEJhY2twcm9wRmlsdGVyVjJcIik7bGV0IHU9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxwPXcuY29tcHV0ZVN0cmlkZXMocy5zaGFwZSksZD1ULmNvbXB1dGVDb252M0RJbmZvKHIuc2hhcGUsbCxpLDEsbyksYz1kLnN0cmlkZURlcHRoLGg9ZC5zdHJpZGVIZWlnaHQsbT1kLnN0cmlkZVdpZHRoLGY9ZC5maWx0ZXJEZXB0aCxnPWQuZmlsdGVySGVpZ2h0LGI9ZC5maWx0ZXJXaWR0aCx5PW5ldyBXdChkLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSx4PXkudmFsdWVzLFt2LEksTixDXT15LnN0cmlkZXMsXz1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsW0YsRCwkLFNdPXAsTT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsW0IsVSxILHFdPXUsSz1kLnBhZEluZm8uZnJvbnQsWj1kLnBhZEluZm8ubGVmdCxKPWQucGFkSW5mby50b3A7Zm9yKGxldCBlZT0wO2VlPGY7KytlZSl7bGV0IGFlPU1hdGgubWF4KDAsTWF0aC5jZWlsKChLLWVlKS9jKSksdGU9TWF0aC5taW4oZC5vdXREZXB0aCwoZC5pbkRlcHRoK0stZWUpL2MpLHNlPWVlKnY7Zm9yKGxldCBpZT0wO2llPGc7KytpZSl7bGV0IHZlPU1hdGgubWF4KDAsTWF0aC5jZWlsKChKLWllKS9oKSksdWU9TWF0aC5taW4oZC5vdXRIZWlnaHQsKGQuaW5IZWlnaHQrSi1pZSkvaCkseWU9aWUqSStzZTtmb3IobGV0IGtlPTA7a2U8YjsrK2tlKXtsZXQgU2U9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKFota2UpL20pKSxMZT1NYXRoLm1pbihkLm91dFdpZHRoLChkLmluV2lkdGgrWi1rZSkvbSksVWU9a2UqTit5ZTtmb3IobGV0IG10PTA7bXQ8ZC5pbkNoYW5uZWxzOysrbXQpe2xldCBzdD1tdCpDK1VlO2ZvcihsZXQgdHQ9MDt0dDxkLm91dENoYW5uZWxzOysrdHQpe2xldCBudD0wO2ZvcihsZXQgUmU9MDtSZTxkLmJhdGNoU2l6ZTsrK1JlKXtsZXQgZ3Q9UmUqQixHbj1SZSpGO2ZvcihsZXQgT3Q9YWU7T3Q8dGU7KytPdCl7bGV0IGlhPShlZStPdCpjLUspKlUrZ3QsdW49T3QqRCtHbjtmb3IobGV0IEZuPXZlO0ZuPHVlOysrRm4pe2xldCBvYT0oaWUrRm4qaC1KKSpIK2lhLCRuPUZuKiQrdW47Zm9yKGxldCB1dD1TZTt1dDxMZTsrK3V0KXtsZXQgRG49KGtlK3V0Km0tWikqcStvYSxIbj11dCpTKyRuO250Kz1NW0RuK210XSpfW0huK3R0XX19fX14W3N0K3R0XT1udH19fX19cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oeS5zaGFwZSx5LmR0eXBlLHkudmFsdWVzKX12YXIgTFg9e2tlcm5lbE5hbWU6aXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlBYfTtmdW5jdGlvbiB6WChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsZmlsdGVyOnN9PXQse3BhZDppLHN0cmlkZXM6byxpbnB1dFNoYXBlOmx9PWE7Z2UoW3JdLFwiY29udjNkQmFja3Byb3BJbnB1dFYyXCIpO2xldCB1PXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSkscD13LmNvbXB1dGVTdHJpZGVzKHMuc2hhcGUpLGQ9VC5jb21wdXRlQ29udjNESW5mbyhsLHMuc2hhcGUsbywxLGkpLGM9bmV3IFd0KGQuaW5TaGFwZSxcImZsb2F0MzJcIiksaD1jLnZhbHVlcyxbbSxmLGcsYl09Yy5zdHJpZGVzLHk9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLFt4LHYsSSxOXT11LEM9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLFtfLEYsRCwkXT1wLHtiYXRjaFNpemU6UyxmaWx0ZXJEZXB0aDpNLGZpbHRlckhlaWdodDpCLGZpbHRlcldpZHRoOlUsaW5DaGFubmVsczpILGluRGVwdGg6cSxpbkhlaWdodDpLLGluV2lkdGg6WixvdXRDaGFubmVsczpKLG91dERlcHRoOmVlLG91dEhlaWdodDphZSxvdXRXaWR0aDp0ZSxzdHJpZGVEZXB0aDpzZSxzdHJpZGVIZWlnaHQ6aWUsc3RyaWRlV2lkdGg6dmV9PWQsdWU9TS0xLWQucGFkSW5mby5mcm9udCx5ZT1CLTEtZC5wYWRJbmZvLnRvcCxrZT1VLTEtZC5wYWRJbmZvLmxlZnQ7Zm9yKGxldCBTZT0wO1NlPFM7KytTZSlmb3IobGV0IExlPTA7TGU8SDsrK0xlKWZvcihsZXQgVWU9MDtVZTxxOysrVWUpe2xldCBtdD1VZS11ZSxzdD1NYXRoLm1heCgwLE1hdGguY2VpbChtdC9zZSkpLHR0PU1hdGgubWluKGVlLChNK210KS9zZSk7Zm9yKGxldCBudD0wO250PEs7KytudCl7bGV0IFJlPW50LXllLGd0PU1hdGgubWF4KDAsTWF0aC5jZWlsKFJlL2llKSksR249TWF0aC5taW4oYWUsKEIrUmUpL2llKTtmb3IobGV0IE90PTA7T3Q8WjsrK090KXtsZXQgaWE9T3Qta2UsdW49TWF0aC5tYXgoMCxNYXRoLmNlaWwoaWEvdmUpKSxGbj1NYXRoLm1pbih0ZSwoVStpYSkvdmUpLG9hPTA7Zm9yKGxldCAkbj1zdDskbjx0dDsrKyRuKXtsZXQgdXQ9JG4qc2UtbXQ7Zm9yKGxldCBEbj1ndDtEbjxHbjsrK0RuKXtsZXQgSG49RG4qaWUtUmU7Zm9yKGxldCB4cj11bjt4cjxGbjsrK3hyKXtsZXQgbWw9eHIqdmUtaWEsWmE9eCpTZSt2KiRuK0kqRG4rTip4cixXcD1fKihNLTEtdXQpK0YqKEItMS1IbikrRCooVS0xLW1sKSskKkxlO2ZvcihsZXQgSWE9MDtJYTxKOysrSWEpe2xldCBVcj15W1phK0lhXSxKdD1DW1dwK0lhXTtvYSs9VXIqSnR9fX19aFttKlNlK2YqVWUrZypudCtiKk90K0xlXT1vYX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGMuc2hhcGUsYy5kdHlwZSxjLnZhbHVlcyl9dmFyIFdYPXtrZXJuZWxOYW1lOm91LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp6WH0sQlg9bHQoV2ksZT0+TWF0aC5jb3MoZSkpLFZYPXtrZXJuZWxOYW1lOldpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpCWH0sVVg9bHQoQmksZT0+TWF0aC5jb3NoKGUpKSxHWD17a2VybmVsTmFtZTpCaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6VVh9O2Z1bmN0aW9uIEhYKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2U6cixib3hlczpzLGJveEluZDppfT10LHtjcm9wU2l6ZTpvLG1ldGhvZDpsLGV4dHJhcG9sYXRpb25WYWx1ZTp1fT1hLFtwLGQsYyxoXT1yLnNoYXBlLG09cy5zaGFwZVswXSxbZixnXT1vLGI9T2UoW20sZixnLGhdLFwiZmxvYXQzMlwiKSx5PW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyx4PW4uZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlcyx2PW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxJPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksTj13LmNvbXB1dGVTdHJpZGVzKGIuc2hhcGUpO2ZvcihsZXQgQz0wO0M8bTtDKyspe2xldCBfPUMqNCxGPXlbX10sRD15W18rMV0sJD15W18rMl0sUz15W18rM10sTT14W0NdO2lmKE0+PXApY29udGludWU7bGV0IEI9Zj4xPygkLUYpKihkLTEpLyhmLTEpOjAsVT1nPjE/KFMtRCkqKGMtMSkvKGctMSk6MDtmb3IobGV0IEg9MDtIPGY7SCsrKXtsZXQgcT1mPjE/RiooZC0xKStIKkI6LjUqKEYrJCkqKGQtMSk7aWYocTwwfHxxPmQtMSl7Zm9yKGxldCBLPTA7SzxnO0srKylmb3IobGV0IFo9MDtaPGg7WisrKXtsZXQgSj1aK0sqTlsyXStIKk5bMV0rQypOWzBdO2IudmFsdWVzW0pdPXV9Y29udGludWV9aWYobD09PVwiYmlsaW5lYXJcIil7bGV0IEs9TWF0aC5mbG9vcihxKSxaPU1hdGguY2VpbChxKSxKPXEtSztmb3IobGV0IGVlPTA7ZWU8ZztlZSsrKXtsZXQgYWU9Zz4xP0QqKGMtMSkrZWUqVTouNSooRCtTKSooYy0xKTtpZihhZTwwfHxhZT5jLTEpe2ZvcihsZXQgdmU9MDt2ZTxoO3ZlKyspe2xldCB1ZT12ZStlZSpOWzJdK0gqTlsxXStDKk5bMF07Yi52YWx1ZXNbdWVdPXV9Y29udGludWV9bGV0IHRlPU1hdGguZmxvb3IoYWUpLHNlPU1hdGguY2VpbChhZSksaWU9YWUtdGU7Zm9yKGxldCB2ZT0wO3ZlPGg7dmUrKyl7bGV0IHVlPXZlK3RlKklbMl0rSypJWzFdK00qSVswXSx5ZT12W3VlXTt1ZT12ZStzZSpJWzJdK0sqSVsxXStNKklbMF07bGV0IGtlPXZbdWVdO3VlPXZlK3RlKklbMl0rWipJWzFdK00qSVswXTtsZXQgU2U9dlt1ZV07dWU9dmUrc2UqSVsyXStaKklbMV0rTSpJWzBdO2xldCBMZT12W3VlXSxVZT15ZSsoa2UteWUpKmllLG10PVNlKyhMZS1TZSkqaWU7dWU9dmUrZWUqTlsyXStIKk5bMV0rQypOWzBdLGIudmFsdWVzW3VlXT1VZSsobXQtVWUpKkp9fX1lbHNlIGZvcihsZXQgSz0wO0s8ZzsrK0spe2xldCBaPWc+MT9EKihjLTEpK0sqVTouNSooRCtTKSooYy0xKTtpZihaPDB8fFo+Yy0xKXtmb3IobGV0IGFlPTA7YWU8aDthZSsrKXtsZXQgdGU9YWUrSypOWzJdK0gqTlsxXStDKk5bMF07Yi52YWx1ZXNbdGVdPXV9Y29udGludWV9bGV0IEo9TWF0aC5yb3VuZChaKSxlZT1NYXRoLnJvdW5kKHEpO2ZvcihsZXQgYWU9MDthZTxoO2FlKyspe2xldCB0ZT1hZStKKklbMl0rZWUqSVsxXStNKklbMF0sc2U9YWUrSypOWzJdK0gqTlsxXStDKk5bMF07Yi52YWx1ZXNbc2VdPXZbdGVdfX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGIuc2hhcGUsYi5kdHlwZSxiLnZhbHVlcyl9dmFyIGpYPXtrZXJuZWxOYW1lOnV1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpIWH07ZnVuY3Rpb24gcVgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxleGNsdXNpdmU6aSxyZXZlcnNlOm99PWE7Z2UocixcImN1bXByb2RcIik7bGV0IGw9VC5nZXRBeGVzUGVybXV0YXRpb24oW3NdLHIuc2hhcGUubGVuZ3RoKSx1PXI7bCE9bnVsbCYmKHU9Vm4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06bH19KSk7bGV0IHA9VC5nZXRJbm5lck1vc3RBeGVzKDEsci5zaGFwZS5sZW5ndGgpWzBdO2lmKHAhPT11LnNoYXBlLmxlbmd0aC0xKXRocm93IG5ldyBFcnJvcihgYmFja2VuZC5jdW1wcm9kIGluIENQVSBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz0ke3Uuc2hhcGUubGVuZ3RoLTF9IGJ1dCBnb3QgYXhpcz0ke3B9YCk7bGV0IGQ9ZmEodS5kdHlwZSxcImludDMyXCIpLGM9dy5tYWtlT25lc1R5cGVkQXJyYXkody5zaXplRnJvbVNoYXBlKHUuc2hhcGUpLGQpLGg9bi5kYXRhLmdldCh1LmRhdGFJZCkudmFsdWVzLG09dS5zaGFwZVt1LnNoYXBlLmxlbmd0aC0xXSxmPW8/KGIseSk9PmIrbS15LTE6KGIseSk9PmIreTtmb3IobGV0IGI9MDtiPGgubGVuZ3RoO2IrPW0pZm9yKGxldCB5PTA7eTxtO3krKyl7bGV0IHg9ZihiLHkpO2lmKHk9PT0wKWNbeF09aT8xOmhbeF07ZWxzZXtsZXQgdj1mKGIseS0xKTtjW3hdPWk/aFt2XSpjW3ZdOmhbeF0qY1t2XX19bGV0IGc9bi5tYWtlVGVuc29ySW5mbyh1LnNoYXBlLGQsYyk7aWYobCE9bnVsbCl7bGV0IGI9VC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKGwpLHk9Vm4oe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06Yn19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHUpLHl9cmV0dXJuIGd9dmFyIEtYPXtrZXJuZWxOYW1lOmx1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpxWH07ZnVuY3Rpb24gWFgoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxleGNsdXNpdmU6aSxyZXZlcnNlOm99PWE7Z2UocixcImN1bXN1bVwiKTtsZXQgbD1ULmdldEF4ZXNQZXJtdXRhdGlvbihbc10sci5zaGFwZS5sZW5ndGgpLHU9cjtsIT1udWxsJiYodT1Wbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpsfX0pKTtsZXQgcD1ULmdldElubmVyTW9zdEF4ZXMoMSxyLnNoYXBlLmxlbmd0aClbMF07aWYocCE9PXUuc2hhcGUubGVuZ3RoLTEpdGhyb3cgbmV3IEVycm9yKGBiYWNrZW5kLmN1bXN1bSBpbiBDUFUgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9JHt1LnNoYXBlLmxlbmd0aC0xfSBidXQgZ290IGF4aXM9JHtwfWApO2xldCBkPWZhKHUuZHR5cGUsXCJpbnQzMlwiKSxjPXcubWFrZVplcm9zVHlwZWRBcnJheSh3LnNpemVGcm9tU2hhcGUodS5zaGFwZSksZCksaD1uLmRhdGEuZ2V0KHUuZGF0YUlkKS52YWx1ZXMsbT11LnNoYXBlW3Uuc2hhcGUubGVuZ3RoLTFdLGY9bz8oYix5KT0+YittLXktMTooYix5KT0+Yit5O2ZvcihsZXQgYj0wO2I8aC5sZW5ndGg7Yis9bSlmb3IobGV0IHk9MDt5PG07eSsrKXtsZXQgeD1mKGIseSk7aWYoeT09PTApY1t4XT1pPzA6aFt4XTtlbHNle2xldCB2PWYoYix5LTEpO2NbeF09aT9oW3ZdK2Nbdl06aFt4XStjW3ZdfX1sZXQgZz1uLm1ha2VUZW5zb3JJbmZvKHUuc2hhcGUsZCxjKTtpZihsIT1udWxsKXtsZXQgYj1ULmdldFVuZG9BeGVzUGVybXV0YXRpb24obCkseT1Wbih7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpifX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odSkseX1yZXR1cm4gZ312YXIgWVg9e2tlcm5lbE5hbWU6VmksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlhYfTtmdW5jdGlvbiBaWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cix3ZWlnaHRzOnN9PXQse3NpemU6aSxiaW5hcnlPdXRwdXQ6b309YTtpZihyLnNoYXBlLmxlbmd0aD09PTEpe2xldCBsPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyx1PW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxwPVAxKGwsdSxzLmR0eXBlLHMuc2hhcGUsaSk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oW2ldLHMuZHR5cGUscCl9ZWxzZSBpZihyLnNoYXBlLmxlbmd0aD09PTIpe2xldCBsPW4uYnVmZmVyU3luYyhyKSx1PW4uYnVmZmVyU3luYyhzKSxwPSRFKGwsdSxpLG8pO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKHAuc2hhcGUscy5kdHlwZSxwLnZhbHVlcyl9dGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiBkZW5zZUJpbmNvdW50OiBpbnB1dCBtdXN0IGJlIGF0IG1vc3QgcmFuayAyLCBidXQgZ290IHJhbmske3Iuc2hhcGUubGVuZ3RofS5gKX12YXIgSlg9e2tlcm5lbE5hbWU6UGMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlpYfTtmdW5jdGlvbiBRWChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YmxvY2tTaXplOnMsZGF0YUZvcm1hdDppfT1hO3cuYXNzZXJ0KGk9PT1cIk5IV0NcIiwoKT0+YE9ubHkgTkhXQyBkYXRhRm9ybWF0IHN1cHBvcnRlZCBvbiBDUFUgZm9yIGRlcHRoVG9TcGFjZS4gR290ICR7aX1gKTtsZXQgbz1yLnNoYXBlWzBdLGw9ci5zaGFwZVsxXSx1PXIuc2hhcGVbMl0scD1yLnNoYXBlWzNdLGQ9bCpzLGM9dSpzLGg9cC8ocypzKSxtPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxmPW5ldyBGbG9hdDMyQXJyYXkobypkKmMqaCksZz0wO2ZvcihsZXQgYj0wO2I8bzsrK2IpZm9yKGxldCB5PTA7eTxkOysreSl7bGV0IHg9TWF0aC5mbG9vcih5L3MpLHY9eSVzO2ZvcihsZXQgST0wO0k8YzsrK0kpe2xldCBOPU1hdGguZmxvb3IoSS9zKSxDPUklcyxfPSh2KnMrQykqaDtmb3IobGV0IEY9MDtGPGg7KytGKXtsZXQgRD1GK18rcCooTit1Kih4K2wqYikpO2ZbZysrXT1tW0RdfX19cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oW28sZCxjLGhdLHIuZHR5cGUsZil9dmFyIGVZPXtrZXJuZWxOYW1lOnB1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpRWH07ZnVuY3Rpb24gTl8oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnN9PXQse3N0cmlkZXM6aSxwYWQ6byxkaWxhdGlvbnM6bCxkaW1Sb3VuZGluZ01vZGU6dX09YTtnZShbcixzXSxcImRlcHRod2lzZUNvbnYyRE5hdGl2ZVwiKTtsZXQgcD13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLGQ9dy5jb21wdXRlU3RyaWRlcyhzLnNoYXBlKSxjPWw7Yz09bnVsbCYmKGM9WzEsMV0pLHcuYXNzZXJ0KFQuZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGksYyksKCk9PmBFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7aX0gYW5kIGRpbGF0aW9ucyAnJHtjfSdgKTtsZXQgaD1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscy5zaGFwZSxpLGMsbyx1LCEwKSx7ZmlsdGVySGVpZ2h0Om0sZmlsdGVyV2lkdGg6ZixkaWxhdGlvbkhlaWdodDpnLGRpbGF0aW9uV2lkdGg6YixwYWRJbmZvOnl9PWgseD15LmxlZnQsdj15LnRvcCxJPWgub3V0Q2hhbm5lbHMvaC5pbkNoYW5uZWxzLE49bmV3IFd0KGgub3V0U2hhcGUsci5kdHlwZSksQz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsXz1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsRj1OLnZhbHVlcztmb3IobGV0IEQ9MDtEPGguYmF0Y2hTaXplOysrRCl7bGV0ICQ9RCpwWzBdLFM9RCpOLnN0cmlkZXNbMF07Zm9yKGxldCBNPTA7TTxoLm91dEhlaWdodDsrK00pe2xldCBCPVMrTSpOLnN0cmlkZXNbMV0sVT1NKmguc3RyaWRlSGVpZ2h0LXY7Zm9yKGxldCBIPTA7SDxtOysrSCl7bGV0IHE9VStIKmc7aWYocTwwfHxxPj1oLmluSGVpZ2h0KWNvbnRpbnVlO2xldCBLPUgqZFswXSxaPSQrcSpwWzFdO2ZvcihsZXQgSj0wO0o8aC5vdXRXaWR0aDsrK0ope2xldCBlZT1CK0oqTi5zdHJpZGVzWzJdLGFlPUoqaC5zdHJpZGVXaWR0aC14O2ZvcihsZXQgdGU9MDt0ZTxmOysrdGUpe2xldCBzZT1hZSt0ZSpiO2lmKHNlPDB8fHNlPj1oLmluV2lkdGgpY29udGludWU7bGV0IGllPUsrdGUqZFsxXSx2ZT1aK3NlKmguaW5DaGFubmVscyx1ZT1lZSx5ZT1pZTtmb3IobGV0IGtlPTA7a2U8aC5pbkNoYW5uZWxzOysra2Upe2xldCBTZT1DW3ZlK2tlXTtmb3IobGV0IExlPTA7TGU8STsrK0xlKUZbdWUrTGVdKz1TZSpfW3llK0xlXTt1ZSs9SSx5ZSs9SX19fX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKE4uc2hhcGUsTi5kdHlwZSxOLnZhbHVlcyl9dmFyIHRZPXtrZXJuZWxOYW1lOlVpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpOX307ZnVuY3Rpb24gblkoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZHk6c309dCx7c3RyaWRlczppLGRpbGF0aW9uczpvLHBhZDpsLGRpbVJvdW5kaW5nTW9kZTp1LGZpbHRlclNoYXBlOnB9PWE7Z2UoW3Isc10sXCJkZXB0aHdpc2VDb252MmROYXRpdmVCYWNrcHJvcEZpbHRlclwiKTtsZXQgZD1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscCxpLG8sbCx1LCEwKSx7c3RyaWRlSGVpZ2h0OmMsc3RyaWRlV2lkdGg6aCxmaWx0ZXJIZWlnaHQ6bSxmaWx0ZXJXaWR0aDpmfT1kLGc9bmV3IFd0KGQuZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLGI9ZC5wYWRJbmZvLmxlZnQseT1kLnBhZEluZm8udG9wLHg9ZC5vdXRDaGFubmVscy9kLmluQ2hhbm5lbHMsdj1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsST1uZXcgV3Qoci5zaGFwZSxyLmR0eXBlLHYpLE49bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLEM9bmV3IFd0KHMuc2hhcGUscy5kdHlwZSxOKTtmb3IobGV0IF89MDtfPG07KytfKXtsZXQgRj1NYXRoLm1heCgwLE1hdGguY2VpbCgoeS1fKS9jKSksRD1NYXRoLm1pbihkLm91dEhlaWdodCwoZC5pbkhlaWdodCt5LV8pL2MpO2ZvcihsZXQgJD0wOyQ8ZjsrKyQpe2xldCBTPU1hdGgubWF4KDAsTWF0aC5jZWlsKChiLSQpL2gpKSxNPU1hdGgubWluKGQub3V0V2lkdGgsKGQuaW5XaWR0aCtiLSQpL2gpO2ZvcihsZXQgQj0wO0I8ZC5vdXRDaGFubmVsczsrK0Ipe2xldCBVPU1hdGgudHJ1bmMoQi94KSxIPUIleCxxPTA7Zm9yKGxldCBLPTA7SzxkLmJhdGNoU2l6ZTsrK0spZm9yKGxldCBaPUY7WjxEOysrWil7bGV0IEo9XytaKmMteTtmb3IobGV0IGVlPVM7ZWU8TTsrK2VlKXtsZXQgYWU9JCtlZSpoLWI7cSs9SS5nZXQoSyxKLGFlLFUpKkMuZ2V0KEssWixlZSxCKX19Zy5zZXQocSxfLCQsVSxIKX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGcuc2hhcGUsZy5kdHlwZSxnLnZhbHVlcyl9dmFyIGFZPXtrZXJuZWxOYW1lOkltLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpuWX07ZnVuY3Rpb24gclkoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGZpbHRlcjpzfT10LHtzdHJpZGVzOmksZGlsYXRpb25zOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnUsaW5wdXRTaGFwZTpwfT1hO2dlKFtyLHNdLFwiZGVwdGh3aXNlQ29udjJETmF0aXZlQmFja3Byb3BJbnB1dFwiKTtsZXQgZD13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLGM9dy5jb21wdXRlU3RyaWRlcyhzLnNoYXBlKSxoPVQuY29tcHV0ZUNvbnYyREluZm8ocCxzLnNoYXBlLGksbyxsLHUsITApLG09bmV3IFd0KGguaW5TaGFwZSxcImZsb2F0MzJcIiksZj1tLnZhbHVlcyxbZyxiLHldPW0uc3RyaWRlcyx4PW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxbdixJLE5dPWQsQz1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsW18sRixEXT1jLHtiYXRjaFNpemU6JCxmaWx0ZXJIZWlnaHQ6UyxmaWx0ZXJXaWR0aDpNLGluQ2hhbm5lbHM6QixpbkhlaWdodDpVLGluV2lkdGg6SCxvdXRDaGFubmVsczpxLG91dEhlaWdodDpLLG91dFdpZHRoOlosc3RyaWRlSGVpZ2h0Okosc3RyaWRlV2lkdGg6ZWV9PWgsYWU9Uy0xLWgucGFkSW5mby50b3AsdGU9TS0xLWgucGFkSW5mby5sZWZ0LHNlPXEvQjtmb3IobGV0IGllPTA7aWU8JDsrK2llKWZvcihsZXQgdmU9MDt2ZTxCOysrdmUpZm9yKGxldCB1ZT0wO3VlPFU7Kyt1ZSl7bGV0IHllPXVlLWFlLGtlPU1hdGgubWF4KDAsTWF0aC5jZWlsKHllL0opKSxTZT1NYXRoLm1pbihLLChTK3llKS9KKTtmb3IobGV0IExlPTA7TGU8SDsrK0xlKXtsZXQgVWU9TGUtdGUsbXQ9TWF0aC5tYXgoMCxNYXRoLmNlaWwoVWUvZWUpKSxzdD1NYXRoLm1pbihaLChNK1VlKS9lZSksdHQ9MDtmb3IobGV0IG50PWtlO250PFNlOysrbnQpe2xldCBSZT1udCpKLXllO2ZvcihsZXQgZ3Q9bXQ7Z3Q8c3Q7KytndCl7bGV0IEduPWd0KmVlLVVlLE90PXYqaWUrSSpudCtOKmd0LGlhPV8qKFMtMS1SZSkrRiooTS0xLUduKStEKnZlO2ZvcihsZXQgdW49MDt1bjxzZTsrK3VuKXtsZXQgRm49dmUqc2UrdW4sb2E9eFtPdCtGbl0sJG49Q1tpYSt1bl07dHQrPW9hKiRufX19ZltnKmllK2IqdWUreSpMZSt2ZV09dHR9fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKG0uc2hhcGUsbS5kdHlwZSxtLnZhbHVlcyl9dmFyIHNZPXtrZXJuZWxOYW1lOlNtLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpyWX07ZnVuY3Rpb24gaVkoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10LHI9dy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpLHM9bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGk9T2UoW3Iscl0sYS5kdHlwZSksbz1pLnZhbHVlcztmb3IobGV0IHU9MDt1PHMubGVuZ3RoO3UrKylvW3Uqcit1XT1zW3VdO2xldCBsPVsuLi5hLnNoYXBlLC4uLmEuc2hhcGVdO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwsaS5kdHlwZSxpLnZhbHVlcyl9dmFyIG9ZPXtrZXJuZWxOYW1lOkxjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzppWX0sbFk9e2tlcm5lbE5hbWU6R2ksYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYmFja2VuZDp0LGF0dHJzOm59KT0+e2xldHt4OmEsZmlsdGVyOnJ9PWUse3N0cmlkZXM6cyxwYWQ6aSxkaWxhdGlvbnM6b309bixsPXQsdT1sLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMscD1hLnNoYXBlLmxlbmd0aCxkPWwuZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxjPXIuc2hhcGUubGVuZ3RoLHtiYXRjaFNpemU6aCxpbkhlaWdodDptLGluV2lkdGg6ZixpbkNoYW5uZWxzOmcsb3V0SGVpZ2h0OmIsb3V0V2lkdGg6eSxwYWRJbmZvOngsc3RyaWRlSGVpZ2h0OnYsc3RyaWRlV2lkdGg6SSxmaWx0ZXJIZWlnaHQ6TixmaWx0ZXJXaWR0aDpDLGRpbGF0aW9uSGVpZ2h0Ol8sZGlsYXRpb25XaWR0aDpGLG91dFNoYXBlOkR9PVQuY29tcHV0ZURpbGF0aW9uMkRJbmZvKGEuc2hhcGUsci5zaGFwZSxzLGksXCJOSFdDXCIsbyksJD13LnNpemVGcm9tU2hhcGUoRCksUz1ELmxlbmd0aCxNPXcuZ2V0QXJyYXlGcm9tRFR5cGUoYS5kdHlwZSwkKTtmb3IobGV0IEI9MDtCPGg7KytCKWZvcihsZXQgVT0wO1U8YjsrK1Upe2xldCBIPVUqdi14LnRvcDtmb3IobGV0IHE9MDtxPHk7KytxKXtsZXQgSz1xKkkteC5sZWZ0O2ZvcihsZXQgWj0wO1o8ZzsrK1ope2xldCBKPU51bWJlci5NSU5fU0FGRV9JTlRFR0VSO2ZvcihsZXQgYWU9MDthZTxOOysrYWUpe2xldCB0ZT1IK2FlKl87aWYodGU+PTAmJnRlPG0pZm9yKGxldCBzZT0wO3NlPEM7KytzZSl7bGV0IGllPUsrc2UqRjtpZihpZT49MCYmaWU8Zil7bGV0IHZlPXcubG9jVG9JbmRleChbQix0ZSxpZSxaXSxwLHcuY29tcHV0ZVN0cmlkZXMoYS5zaGFwZSkpLHVlPXcubG9jVG9JbmRleChbYWUsc2UsWl0sYyx3LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpKSx5ZT11W3ZlXStkW3VlXTt5ZT5KJiYoSj15ZSl9fX1sZXQgZWU9dy5sb2NUb0luZGV4KFtCLFUscSxaXSxTLHcuY29tcHV0ZVN0cmlkZXMoRCkpO01bZWVdPUp9fX1yZXR1cm57ZGF0YUlkOmwud3JpdGUody50b1R5cGVkQXJyYXkoTSxhLmR0eXBlKSxELGEuZHR5cGUpLHNoYXBlOkQsZHR5cGU6YS5kdHlwZX19fSx1WT17a2VybmVsTmFtZTpSbCxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6KHtpbnB1dHM6ZSxiYWNrZW5kOnQsYXR0cnM6bn0pPT57bGV0e3g6YSxmaWx0ZXI6cixkeTpzfT1lLHtzdHJpZGVzOmkscGFkOm8sZGlsYXRpb25zOmx9PW4sdT10LHA9dy50b05lc3RlZEFycmF5KGEuc2hhcGUsdS5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzKSxkPXcudG9OZXN0ZWRBcnJheShyLnNoYXBlLHUuZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcykse2JhdGNoU2l6ZTpjLGluSGVpZ2h0OmgsaW5XaWR0aDptLGluQ2hhbm5lbHM6ZixvdXRIZWlnaHQ6ZyxvdXRXaWR0aDpiLHBhZEluZm86eSxzdHJpZGVIZWlnaHQ6eCxzdHJpZGVXaWR0aDp2LGZpbHRlckhlaWdodDpJLGZpbHRlcldpZHRoOk4sZGlsYXRpb25IZWlnaHQ6QyxkaWxhdGlvbldpZHRoOl8sb3V0U2hhcGU6Rn09VC5jb21wdXRlRGlsYXRpb24yREluZm8oYS5zaGFwZSxyLnNoYXBlLGksbyxcIk5IV0NcIixsKTt3LmFzc2VydChzLnJhbms9PT1GLmxlbmd0aCwoKT0+YEVycm9yIGluICR7Umx9LCBkeSBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyBvdXRwdXQgJHtGLmxlbmd0aH0sIGJ1dCBnb3QgJHtzLnJhbmt9YCk7bGV0IEQ9dy50b05lc3RlZEFycmF5KEYsdS5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzKSwkPXcubWFrZVplcm9zTmVzdGVkVHlwZWRBcnJheShyLnNoYXBlLHIuZHR5cGUpO2ZvcihsZXQgUz0wO1M8YzsrK1MpZm9yKGxldCBNPTA7TTxnOysrTSl7bGV0IEI9TSp4LXkudG9wO2ZvcihsZXQgVT0wO1U8YjsrK1Upe2xldCBIPVUqdi15LmxlZnQ7Zm9yKGxldCBxPTA7cTxmOysrcSl7bGV0IEs9TnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsWj0wLEo9MDtmb3IobGV0IGVlPTA7ZWU8STsrK2VlKXtsZXQgYWU9QitlZSpDO2lmKGFlPj0wJiZhZTxoKWZvcihsZXQgdGU9MDt0ZTxOOysrdGUpe2xldCBzZT1IK3RlKl87aWYoc2U+PTAmJnNlPG0pe2xldCBpZT1wW1NdW2FlXVtzZV1bcV0rZFtlZV1bdGVdW3FdO2llPksmJihLPWllLFo9ZWUsSj10ZSl9fX0kW1pdW0pdW3FdKz1EW1NdW01dW1VdW3FdfX19cmV0dXJue2RhdGFJZDp1LndyaXRlKHcudG9UeXBlZEFycmF5KCQsYS5kdHlwZSksci5zaGFwZSxyLmR0eXBlKSxzaGFwZTpyLnNoYXBlLGR0eXBlOnIuZHR5cGV9fX0scFk9e2tlcm5lbE5hbWU6RGwsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYmFja2VuZDp0LGF0dHJzOm59KT0+e2xldHt4OmEsZmlsdGVyOnIsZHk6c309ZSx7c3RyaWRlczppLHBhZDpvLGRpbGF0aW9uczpsfT1uLHU9dCxwPXcudG9OZXN0ZWRBcnJheShhLnNoYXBlLHUuZGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyksZD13LnRvTmVzdGVkQXJyYXkoci5zaGFwZSx1LmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMpLHtiYXRjaFNpemU6YyxpbkhlaWdodDpoLGluV2lkdGg6bSxpbkNoYW5uZWxzOmYsb3V0SGVpZ2h0Omcsb3V0V2lkdGg6YixwYWRJbmZvOnksc3RyaWRlSGVpZ2h0Ongsc3RyaWRlV2lkdGg6dixmaWx0ZXJIZWlnaHQ6SSxmaWx0ZXJXaWR0aDpOLGRpbGF0aW9uSGVpZ2h0OkMsZGlsYXRpb25XaWR0aDpfLG91dFNoYXBlOkZ9PVQuY29tcHV0ZURpbGF0aW9uMkRJbmZvKGEuc2hhcGUsci5zaGFwZSxpLG8sXCJOSFdDXCIsbCk7dy5hc3NlcnQocy5yYW5rPT09Ri5sZW5ndGgsKCk9PmBFcnJvciBpbiAke0RsfSwgZHkgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgb3V0cHV0ICR7Ri5sZW5ndGh9LCBidXQgZ290ICR7cy5yYW5rfWApO2xldCBEPXcudG9OZXN0ZWRBcnJheShGLHUuZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyksJD13Lm1ha2VaZXJvc05lc3RlZFR5cGVkQXJyYXkoYS5zaGFwZSxhLmR0eXBlKTtmb3IobGV0IFM9MDtTPGM7KytTKWZvcihsZXQgTT0wO008ZzsrK00pe2xldCBCPU0qeC15LnRvcDtmb3IobGV0IFU9MDtVPGI7KytVKXtsZXQgSD1VKnYteS5sZWZ0O2ZvcihsZXQgcT0wO3E8ZjsrK3Epe2xldCBLPU51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFo9QjwwPzA6QixKPUg8MD8wOkg7Zm9yKGxldCBlZT0wO2VlPEk7KytlZSl7bGV0IGFlPUIrZWUqQztpZihhZT49MCYmYWU8aClmb3IobGV0IHRlPTA7dGU8TjsrK3RlKXtsZXQgc2U9SCt0ZSpfO2lmKHNlPj0wJiZzZTxtKXtsZXQgaWU9cFtTXVthZV1bc2VdW3FdK2RbZWVdW3RlXVtxXTtpZT5LJiYoSz1pZSxaPWFlLEo9c2UpfX19JFtTXVtaXVtKXVtxXSs9RFtTXVtNXVtVXVtxXX19fXJldHVybntkYXRhSWQ6dS53cml0ZSh3LnRvVHlwZWRBcnJheSgkLGEuZHR5cGUpLGEuc2hhcGUsYS5kdHlwZSksc2hhcGU6YS5zaGFwZSxkdHlwZTphLmR0eXBlfX19O2Z1bmN0aW9uIGNZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2U6cn09dCx7Y2FudmFzOnMsb3B0aW9uczppfT1hLHtjb250ZXh0T3B0aW9uczpvLGltYWdlT3B0aW9uczpsfT1pfHx7fSx1PShsPT1udWxsP3ZvaWQgMDpsLmFscGhhKXx8MSxwPShvPT1udWxsP3ZvaWQgMDpvLmNvbnRleHRUeXBlKXx8XCIyZFwiO2lmKHAhPT1cIjJkXCIpdGhyb3cgbmV3IEVycm9yKGBDb250ZXh0IHR5cGUgJHtvLmNvbnRleHRUeXBlfSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBDUFUgYmFja2VuZC5gKTtsZXQgZD1zLmdldENvbnRleHQocCwobz09bnVsbD92b2lkIDA6by5jb250ZXh0QXR0cmlidXRlcyl8fHt9KTtpZihkPT1udWxsKXRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCB0aGUgY29udGV4dCB3aXRoICR7cH0gdHlwZS5gKTtsZXRbYyxoXT1yLnNoYXBlLnNsaWNlKDAsMiksbT1yLnNoYXBlLmxlbmd0aD09PTI/MTpyLnNoYXBlWzJdLGY9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGc9ci5kdHlwZT09PVwiZmxvYXQzMlwiPzI1NToxLGI9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGgqYyo0KTtmb3IobGV0IHg9MDt4PGMqaDsrK3gpe2xldCB2PVswLDAsMCwyNTUqdV07Zm9yKGxldCBOPTA7TjxtO04rKyl7bGV0IEM9Zlt4Km0rTl07aWYoci5kdHlwZT09PVwiZmxvYXQzMlwiKXtpZihDPDB8fEM+MSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciB2YWx1ZXMgZm9yIGEgZmxvYXQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSBidXQgZW5jb3VudGVyZWQgJHtDfS5gKX1lbHNlIGlmKHIuZHR5cGU9PT1cImludDMyXCImJihDPDB8fEM+MjU1KSl0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciB2YWx1ZXMgZm9yIGEgaW50MzIgVGVuc29yIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswIC0gMjU1XSBidXQgZW5jb3VudGVyZWQgJHtDfS5gKTttPT09MT8odlswXT1DKmcsdlsxXT1DKmcsdlsyXT1DKmcpOnZbTl09QypnfWxldCBJPXgqNDtiW0krMF09TWF0aC5yb3VuZCh2WzBdKSxiW0krMV09TWF0aC5yb3VuZCh2WzFdKSxiW0krMl09TWF0aC5yb3VuZCh2WzJdKSxiW0krM109TWF0aC5yb3VuZCh2WzNdKX1zLndpZHRoPWgscy5oZWlnaHQ9YztsZXQgeT1uZXcgSW1hZ2VEYXRhKGIsaCxjKTtyZXR1cm4gZC5wdXRJbWFnZURhdGEoeSwwLDApLHJ9dmFyIGRZPXtrZXJuZWxOYW1lOk5tLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpjWX07ZnVuY3Rpb24gRWQoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxrZWVwRGltczppfT1hO2dlKHIsXCJzdW1cIik7bGV0IG87ci5kdHlwZT09PVwiYm9vbFwiP289YnMoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e2R0eXBlOlwiaW50MzJcIn19KTpvPWNyKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7bGV0IGw9by5zaGFwZS5sZW5ndGgsdT13LnBhcnNlQXhpc1BhcmFtKHMsby5zaGFwZSkscD1ULmdldEF4ZXNQZXJtdXRhdGlvbih1LGwpLGQ9dSxjPW87cCE9bnVsbCYmKGM9Vm4oe2lucHV0czp7eDpvfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06cH19KSxkPVQuZ2V0SW5uZXJNb3N0QXhlcyhkLmxlbmd0aCxsKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcInN1bVwiLGQsYy5zaGFwZS5sZW5ndGgpO2xldFtoLG1dPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhjLnNoYXBlLGQpLGY9VC51cGNhc3RUeXBlKGMuZHR5cGUsXCJpbnQzMlwiKSxnPWxtKG4saCxmKSxiPXcuc2l6ZUZyb21TaGFwZShtKSx5PW4uZGF0YS5nZXQoZy5kYXRhSWQpLnZhbHVlcyx4PW4uZGF0YS5nZXQoYy5kYXRhSWQpLnZhbHVlcztmb3IobGV0IHY9MDt2PHkubGVuZ3RoOysrdil7bGV0IEk9dipiLE49MDtmb3IobGV0IEM9MDtDPGI7KytDKU4rPXhbSStDXTt5W3ZdPU59aWYoaSl7bGV0IHY9VC5leHBhbmRTaGFwZVRvS2VlcERpbShnLnNoYXBlLHUpLEk9ZztnPXh0KHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp2fX0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oSSl9cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obykscCE9bnVsbCYmbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxnfXZhciBoWT17a2VybmVsTmFtZTpMbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6RWR9O2Z1bmN0aW9uIG1ZKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZXF1YXRpb246cn09YSxzPXQse2FsbERpbXM6aSxzdW1tZWREaW1zOm8saWREaW1zOmx9PVQuZGVjb2RlRWluc3VtRXF1YXRpb24ocixzLmxlbmd0aCk7VC5jaGVja0VpbnN1bURpbVNpemVzKGkubGVuZ3RoLGwscyk7bGV0e3BhdGg6dSxzdGVwczpwfT1ULmdldEVpbnN1bUNvbXB1dGVQYXRoKG8sbCksZD1wLmxlbmd0aCxjPW51bGwsaD1pLmxlbmd0aCxtPVtdO2ZvcihsZXQgZj0wO2Y8ZDsrK2Ype2ZvcihsZXQgZyBvZiBwW2ZdKXtsZXR7cGVybXV0YXRpb25JbmRpY2VzOmIsZXhwYW5kRGltczp5fT1ULmdldEVpbnN1bVBlcm11dGF0aW9uKGgsbFtnXSkseDtULmlzSWRlbnRpdHlQZXJtdXRhdGlvbihiKT94PXNbZ106KHg9Vm4oe2lucHV0czp7eDpzW2ddfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06Yn19KSxtLnB1c2goeCkpO2xldCB2PXguc2hhcGUuc2xpY2UoKTtmb3IobGV0IEk9MDtJPHkubGVuZ3RoOysrSSl2LnNwbGljZSh5W0ldLDAsMSk7dy5hcnJheXNFcXVhbCh4LnNoYXBlLHYpfHwoeD14dCh7aW5wdXRzOnt4fSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnZ9fSksbS5wdXNoKHgpKSxjPT09bnVsbD9jPXg6KGM9emYoe2lucHV0czp7YTp4LGI6Y30sYmFja2VuZDpufSksbS5wdXNoKGMpKX1mPGQtMSYmKHVbZl0+PTAmJihjPUVkKHtpbnB1dHM6e3g6Y30sYmFja2VuZDpuLGF0dHJzOntheGlzOnVbZl0tKGkubGVuZ3RoLWgpLGtlZXBEaW1zOiExfX0pLG0ucHVzaChjKSksaC0tKX1mb3IobGV0IGYgb2YgbSlmIT09YyYmbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKTtyZXR1cm4gY312YXIgZlk9e2tlcm5lbE5hbWU6VG0sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOm1ZfTtmdW5jdGlvbiBnWShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtkeTphLHk6cn09dDtnZShbYSxyXSxcImVsdUdyYWRcIik7bGV0IHM9bmV3IEZsb2F0MzJBcnJheSh3LnNpemVGcm9tU2hhcGUoci5zaGFwZSkpLGk9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLG89bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzO2ZvcihsZXQgbD0wO2w8aS5sZW5ndGg7KytsKXtsZXQgdT1pW2xdO3U+PTA/c1tsXT1vW2xdOnNbbF09b1tsXSoodSsxKX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLFwiZmxvYXQzMlwiLHMpfXZhciBiWT17a2VybmVsTmFtZTpjdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Z1l9LHlZPVQuRVJGX1AseFk9VC5FUkZfQTEsdlk9VC5FUkZfQTIsd1k9VC5FUkZfQTMsa1k9VC5FUkZfQTQsSVk9VC5FUkZfQTUsU1k9bHQocWksZT0+e2xldCB0PU1hdGguc2lnbihlKSxuPU1hdGguYWJzKGUpLGE9MS8oMSt5WSpuKTtyZXR1cm4gdCooMS0oKCgoSVkqYStrWSkqYSt3WSkqYSt2WSkqYSt4WSkqYSpNYXRoLmV4cCgtbipuKSl9KSxOWT17a2VybmVsTmFtZTpxaSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6U1l9O2Z1bmN0aW9uIGNtKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW5wdXQ6cn09dCx7ZGltOnN9PWEsaT1yLnNoYXBlLmxlbmd0aCxvPXIuc2hhcGUuc2xpY2UoKSxsPXM7cmV0dXJuIHM8MCYmKHcuYXNzZXJ0KC0oaSsxKTw9cywoKT0+YEF4aXMgbXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgWyR7LShpKzEpfSwgJHtpfV1gKSxsPWkrcysxKSxvLnNwbGljZShsLDAsMSkseHQoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOm99fSl9dmFyIFRZPXtrZXJuZWxOYW1lOmh1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpjbX0sQ1k9TXQoKGUsdCk9PmUvdCksWDE9WnQoSGksQ1kpLGx2PXtrZXJuZWxOYW1lOkhpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpYMX07ZnVuY3Rpb24gVF8oZSx0LG4pe2xldCBhPWUuc2hhcGUscj1hWzBdLHM9YVsxXSxpPW4uZGF0YS5nZXQoZS5kYXRhSWQpLG89aS5jb21wbGV4VGVuc29ySW5mb3MucmVhbCxsPWkuY29tcGxleFRlbnNvckluZm9zLmltYWcsdT1bcixzXSxwPXcuc2l6ZUZyb21TaGFwZSh1KSxkPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShcImZsb2F0MzJcIixwKSxjPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShcImZsb2F0MzJcIixwKTtmb3IobGV0IGc9MDtnPHI7ZysrKXtsZXQgYj14aSh7aW5wdXRzOnt4Om99LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46W2csMF0sc2l6ZTpbMSxzXX19KSx5PXhpKHtpbnB1dHM6e3g6bH0sYmFja2VuZDpuLGF0dHJzOntiZWdpbjpbZywwXSxzaXplOlsxLHNdfX0pLHg9WW4oe2lucHV0czp7cmVhbDpiLGltYWc6eX0sYmFja2VuZDpufSkse3JlYWw6dixpbWFnOkl9PUVZKHgsdCxuKSxOPVQubWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyh2LEkpO2ZvcihsZXQgQz0wO0M8cztDKyspe2xldCBfPVQuZ2V0Q29tcGxleFdpdGhJbmRleChOLEMpO2RbZypzK0NdPV8ucmVhbCxjW2cqcytDXT1fLmltYWd9bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhiKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeCl9bGV0IGg9bi5tYWtlVGVuc29ySW5mbyh1LFwiZmxvYXQzMlwiLGQpLG09bi5tYWtlVGVuc29ySW5mbyh1LFwiZmxvYXQzMlwiLGMpLGY9WW4oe2lucHV0czp7cmVhbDpoLGltYWc6bX0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxmfWZ1bmN0aW9uIEVZKGUsdCxuKXtsZXQgYT13LnNpemVGcm9tU2hhcGUoZS5zaGFwZSkscj1uLmRhdGEuZ2V0KGUuZGF0YUlkKSxzPW4uZGF0YS5nZXQoci5jb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQpLnZhbHVlcyxpPW4uZGF0YS5nZXQoci5jb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kYXRhSWQpLnZhbHVlcztpZihfWShhKSl7bGV0IG89dXYocyxpLGEsdCxuKSxsPVtlLnNoYXBlWzBdLGUuc2hhcGVbMV1dO2lmKHQpe2xldCB1PW4ubWFrZVRlbnNvckluZm8obCxcImZsb2F0MzJcIixvLnJlYWwpLHA9bi5tYWtlVGVuc29ySW5mbyhsLFwiZmxvYXQzMlwiLG8uaW1hZyksZD1uLm1ha2VUZW5zb3JJbmZvKFtdLFwiZmxvYXQzMlwiLHcuY3JlYXRlU2NhbGFyVmFsdWUoYSxcImZsb2F0MzJcIikpLGM9Y3Ioe2lucHV0czp7eDpkfSxiYWNrZW5kOm59KSxoPWx2Lmtlcm5lbEZ1bmMoe2lucHV0czp7YTp1LGI6ZH0sYmFja2VuZDpufSksbT1sdi5rZXJuZWxGdW5jKHtpbnB1dHM6e2E6cCxiOmN9LGJhY2tlbmQ6bn0pLGY9bi5kYXRhLmdldChoLmRhdGFJZCkudmFsdWVzLGc9bi5kYXRhLmdldChtLmRhdGFJZCkudmFsdWVzO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHUpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhkKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSx7cmVhbDpmLGltYWc6Z319cmV0dXJuIG99ZWxzZXtsZXQgbz1ULm1lcmdlUmVhbEFuZEltYWdBcnJheXMocyxpKSxsPUFZKG8sYSx0KTtyZXR1cm4gVC5zcGxpdFJlYWxBbmRJbWFnQXJyYXlzKGwpfX1mdW5jdGlvbiBfWShlKXtyZXR1cm4oZSZlLTEpPT09MH1mdW5jdGlvbiB1dihlLHQsbixhLHIpe2lmKG49PT0xKXJldHVybntyZWFsOmUsaW1hZzp0fTtsZXQgcz1ULm1lcmdlUmVhbEFuZEltYWdBcnJheXMoZSx0KSxpPW4vMixvPVQuY29tcGxleFdpdGhFdmVuSW5kZXgocyksbD1vLnJlYWwsdT1vLmltYWcscD1bbC5sZW5ndGhdLGQ9ci5tYWtlVGVuc29ySW5mbyhwLFwiZmxvYXQzMlwiLGwpLGM9ci5tYWtlVGVuc29ySW5mbyhwLFwiZmxvYXQzMlwiLHUpLGg9WW4oe2lucHV0czp7cmVhbDpkLGltYWc6Y30sYmFja2VuZDpyfSksbT1ULmNvbXBsZXhXaXRoT2RkSW5kZXgocyksZj1tLnJlYWwsZz1tLmltYWcsYj1bZi5sZW5ndGhdLHk9ci5tYWtlVGVuc29ySW5mbyhiLFwiZmxvYXQzMlwiLGYpLHg9ci5tYWtlVGVuc29ySW5mbyhiLFwiZmxvYXQzMlwiLGcpLHY9WW4oe2lucHV0czp7cmVhbDp5LGltYWc6eH0sYmFja2VuZDpyfSksST11dihsLHUsaSxhLHIpLE49SS5yZWFsLEM9SS5pbWFnLF89W04ubGVuZ3RoXSxGPXIubWFrZVRlbnNvckluZm8oXyxcImZsb2F0MzJcIixOKSxEPXIubWFrZVRlbnNvckluZm8oXyxcImZsb2F0MzJcIixDKSwkPVluKHtpbnB1dHM6e3JlYWw6RixpbWFnOkR9LGJhY2tlbmQ6cn0pLFM9dXYoZixnLGksYSxyKSxNPVMucmVhbCxCPVMuaW1hZyxVPVtNLmxlbmd0aF0sSD1yLm1ha2VUZW5zb3JJbmZvKFUsXCJmbG9hdDMyXCIsTSkscT1yLm1ha2VUZW5zb3JJbmZvKFUsXCJmbG9hdDMyXCIsQiksSz1Zbih7aW5wdXRzOntyZWFsOkgsaW1hZzpxfSxiYWNrZW5kOnJ9KSxaPVQuZXhwb25lbnRzKG4sYSksSj1bWi5yZWFsLmxlbmd0aF0sZWU9ci5tYWtlVGVuc29ySW5mbyhKLFwiZmxvYXQzMlwiLFoucmVhbCksYWU9ci5tYWtlVGVuc29ySW5mbyhKLFwiZmxvYXQzMlwiLFouaW1hZyksdGU9WW4oe2lucHV0czp7cmVhbDplZSxpbWFnOmFlfSxiYWNrZW5kOnJ9KSxzZT16Zih7aW5wdXRzOnthOnRlLGI6S30sYmFja2VuZDpyfSksaWU9amwoe2lucHV0czp7YTokLGI6c2V9LGJhY2tlbmQ6cn0pLHZlPWoxKHtpbnB1dHM6e2E6JCxiOnNlfSxiYWNrZW5kOnJ9KSx1ZT15aSh7aW5wdXRzOntpbnB1dDppZX0sYmFja2VuZDpyfSkseWU9eWkoe2lucHV0czp7aW5wdXQ6dmV9LGJhY2tlbmQ6cn0pLGtlPXFsKHtpbnB1dHM6e2lucHV0OmllfSxiYWNrZW5kOnJ9KSxTZT1xbCh7aW5wdXRzOntpbnB1dDp2ZX0sYmFja2VuZDpyfSksTGU9S2woe2lucHV0czpbdWUseWVdLGJhY2tlbmQ6cixhdHRyczp7YXhpczowfX0pLFVlPUtsKHtpbnB1dHM6W2tlLFNlXSxiYWNrZW5kOnIsYXR0cnM6e2F4aXM6MH19KSxtdD1yLmRhdGEuZ2V0KExlLmRhdGFJZCkudmFsdWVzLHN0PXIuZGF0YS5nZXQoVWUuZGF0YUlkKS52YWx1ZXM7cmV0dXJuIHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeSksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh4KSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHYpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oRiksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhEKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKCQpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oSCksci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhxKSxyLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEspLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZWUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYWUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odGUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oc2UpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaWUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odmUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odWUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oa2UpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeWUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oU2UpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oTGUpLHIuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oVWUpLHtyZWFsOm10LGltYWc6c3R9fWZ1bmN0aW9uIEFZKGUsdCxuKXtsZXQgYT1uZXcgRmxvYXQzMkFycmF5KHQqMik7Zm9yKGxldCByPTA7cjx0O3IrKyl7bGV0IHM9MCxpPTA7Zm9yKGxldCBvPTA7bzx0O28rKyl7bGV0IGw9VC5leHBvbmVudChyKm8sdCxuKSx1PVQuZ2V0Q29tcGxleFdpdGhJbmRleChlLG8pO3MrPXUucmVhbCpsLnJlYWwtdS5pbWFnKmwuaW1hZyxpKz11LnJlYWwqbC5pbWFnK3UuaW1hZypsLnJlYWx9biYmKHMvPXQsaS89dCksVC5hc3NpZ25Ub1R5cGVkQXJyYXkoYSxzLGkscil9cmV0dXJuIGF9ZnVuY3Rpb24gRlkoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5wdXQ6YX09dCxyPXcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSxzPWEuc2hhcGVbYS5zaGFwZS5sZW5ndGgtMV0saT1yL3Msbz14dCh7aW5wdXRzOnt4OmF9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6W2ksc119fSksbD1UXyhvLCExLG4pLHU9eHQoe2lucHV0czp7eDpsfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmEuc2hhcGV9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhsKSx1fXZhciAkWT17a2VybmVsTmFtZTpDbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Rll9O2Z1bmN0aW9uIFkxKGUpe2xldHtiYWNrZW5kOnQsYXR0cnM6bn09ZSx7c2hhcGU6YSx2YWx1ZTpyLGR0eXBlOnN9PW4saT1zfHx3LmluZmVyRHR5cGUociksbz13LmdldEFycmF5RnJvbURUeXBlKGksdy5zaXplRnJvbVNoYXBlKGEpKTtyZXR1cm4gUlkobyxyLGkpLHQubWFrZVRlbnNvckluZm8oYSxpLG8pfXZhciBEWT17a2VybmVsTmFtZTp6YyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6WTF9O2Z1bmN0aW9uIFJZKGUsdCxuKXtlLmZpbGwodCl9dmFyIE1ZPXtrZXJuZWxOYW1lOm11LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzooe2lucHV0czplLGF0dHJzOnQsYmFja2VuZDpufSk9PntsZXR7aW1hZ2U6YX09ZSxyPW4scz13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoYS5kdHlwZSx3LnNpemVGcm9tU2hhcGUoYS5zaGFwZSkpLFtpLG8sbCx1XT1hLnNoYXBlLHA9ci5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzO2ZvcihsZXQgZD0wO2Q8aTtkKyspe2xldCBjPWQqbCpvKnU7Zm9yKGxldCBoPTA7aDxvO2grKyl7bGV0IG09aCoobCp1KTtmb3IobGV0IGY9MDtmPGw7ZisrKXtsZXQgZz1mKnU7Zm9yKGxldCBiPTA7Yjx1O2IrKyl7bGV0IHk9TWF0aC5yb3VuZChsLWYtMSkseD1jK20rZytiLHY9cFt4XTtpZih5Pj0wJiZ5PGwpe2xldCBJPXkqdSxOPWMrbStJK2I7dj1wW05dfXNbeF09dn19fX1yZXR1cm57ZGF0YUlkOnIud3JpdGUocyxhLnNoYXBlLGEuZHR5cGUpLHNoYXBlOmEuc2hhcGUsZHR5cGU6YS5kdHlwZX19fTtmdW5jdGlvbiBPWShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10LHtzdHJpZGVzOmwscGFkOnUsZGF0YUZvcm1hdDpwLGRpbGF0aW9uczpkLGRpbVJvdW5kaW5nTW9kZTpjLGFjdGl2YXRpb246aCxsZWFreXJlbHVBbHBoYTptfT1hLGY9U18oe2lucHV0czp7eDpyLGZpbHRlcjpzfSxiYWNrZW5kOm4sYXR0cnM6e3N0cmlkZXM6bCxwYWQ6dSxkYXRhRm9ybWF0OnAsZGlsYXRpb25zOmQsZGltUm91bmRpbmdNb2RlOmN9fSk7aWYoaSl7bGV0IGc9ZjtpZihwPT09XCJOQ0hXXCImJmkuc2hhcGUubGVuZ3RoPT09MSYmaS5zaGFwZVswXSE9PTEpe2xldCBiPXh0KHtpbnB1dHM6e3g6aX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbaS5zaGFwZVswXSwxLDFdfX0pO2Y9amwoe2lucHV0czp7YTpmLGJ9LGJhY2tlbmQ6bn0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYil9ZWxzZSBmPWpsKHtpbnB1dHM6e2E6ZixiOml9LGJhY2tlbmQ6bn0pO24uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZyl9aWYoaCl7bGV0IGc9ZjtpZihwPT09XCJOQ0hXXCImJmg9PT1cInByZWx1XCImJm8uc2hhcGUubGVuZ3RoPT09MSYmby5zaGFwZVswXSE9PTEpe2xldCBiPXh0KHtpbnB1dHM6e3g6b30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbby5zaGFwZVswXSwxLDFdfX0pO2Y9cG0obixmLGgsYixtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGIpfWVsc2UgZj1wbShuLGYsaCxvLG0pO24uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZyl9cmV0dXJuIGZ9dmFyIFBZPXtrZXJuZWxOYW1lOm9pLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpPWX07ZnVuY3Rpb24gTFkoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnMsYmlhczppLHByZWx1QWN0aXZhdGlvbldlaWdodHM6b309dCx7c3RyaWRlczpsLHBhZDp1LGRhdGFGb3JtYXQ6cCxkaWxhdGlvbnM6ZCxkaW1Sb3VuZGluZ01vZGU6YyxhY3RpdmF0aW9uOmgsbGVha3lyZWx1QWxwaGE6bX09YSxmPU5fKHtpbnB1dHM6e3g6cixmaWx0ZXI6c30sYmFja2VuZDpuLGF0dHJzOntzdHJpZGVzOmwscGFkOnUsZGF0YUZvcm1hdDpwLGRpbGF0aW9uczpkLGRpbVJvdW5kaW5nTW9kZTpjfX0pO2lmKGkpe2xldCBnPWY7Zj1qbCh7aW5wdXRzOnthOmYsYjppfSxiYWNrZW5kOm59KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpfWlmKGgpe2xldCBnPWY7Zj1wbShuLGYsaCxvLG0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZyl9cmV0dXJuIGZ9dmFyIHpZPXtrZXJuZWxOYW1lOmxpLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpMWX07ZnVuY3Rpb24gV1koZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7cGFyYW1zOmEsaW5kaWNlczpyfT10LHM9dy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpLGk9ci5zaGFwZSxvPWlbaS5sZW5ndGgtMV0sW2wsdSxwLGRdPVQucHJlcGFyZUFuZFZhbGlkYXRlKGEscik7aWYodT09PTApcmV0dXJuIG4ubWFrZVRlbnNvckluZm8obCxhLmR0eXBlLFtdKTtsZXQgYz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsaD1uLmJ1ZmZlclN5bmMoYSksbT1WRShjLGgsYS5kdHlwZSx1LG8scCxkLGEuc2hhcGUscyk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obCxhLmR0eXBlLG0udmFsdWVzKX12YXIgQlk9e2tlcm5lbE5hbWU6Z3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOldZfTtmdW5jdGlvbiBWWShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixpbmRpY2VzOnN9PXQse2F4aXM6aSxiYXRjaERpbXM6b309YTtnZShbcixzXSxcImdhdGhlclYyXCIpO2xldCBsPXcucGFyc2VBeGlzUGFyYW0oaSxyLnNoYXBlKVswXSx1PW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxwPXIuc2hhcGVbbF07Zm9yKGxldCB2PTA7djx1Lmxlbmd0aDsrK3Ype2xldCBJPXVbdl07dy5hc3NlcnQoSTw9cC0xJiZJPj0wLCgpPT5gR2F0aGVyVjI6IHRoZSBpbmRleCB2YWx1ZSAke0l9IGlzIG5vdCBpbiBbMCwgJHtwLTF9XWApfWxldCBkPW87bz09bnVsbCYmKGQ9MCk7bGV0IGM9dy5zaXplRnJvbVNoYXBlKHMuc2hhcGUpLGg9VC5zZWdtZW50X3V0aWwuY29sbGVjdEdhdGhlck9wU2hhcGVJbmZvKHIscyxsLGQpLG09eHQoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltoLmJhdGNoU2l6ZSxoLm91dGVyU2l6ZSxoLmRpbVNpemUsaC5zbGljZVNpemVdfX0pLGY9eHQoe2lucHV0czp7eDpzfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltoLmJhdGNoU2l6ZSxjL2guYmF0Y2hTaXplXX19KSxnPVtoLmJhdGNoU2l6ZSxoLm91dGVyU2l6ZSxjL2guYmF0Y2hTaXplLGguc2xpY2VTaXplXSxiPW4uYnVmZmVyU3luYyhmKSx5PW4uYnVmZmVyU3luYyhtKSx4PVVFKHksYixnKTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLG4ubWFrZVRlbnNvckluZm8oaC5vdXRwdXRTaGFwZSx4LmR0eXBlLHgudmFsdWVzKX12YXIgVVk9e2tlcm5lbE5hbWU6ZnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlZZfTtmdW5jdGlvbiBHWShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dDphfT10LHI9dy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpLHM9YS5zaGFwZVthLnNoYXBlLmxlbmd0aC0xXSxpPXIvcyxvPXh0KHtpbnB1dHM6e3g6YX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbaSxzXX19KSxsPVRfKG8sITAsbiksdT14dCh7aW5wdXRzOnt4Omx9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6YS5zaGFwZX19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGwpLHV9dmFyIEhZPXtrZXJuZWxOYW1lOkVtLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpHWX0salk9bHQodG8sZT0+TnVtYmVyLmlzRmluaXRlKGUpPzE6MCxcImJvb2xcIikscVk9e2tlcm5lbE5hbWU6dG8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmpZfSxLWT1sdChubyxlPT5NYXRoLmFicyhlKT09PTEvMD8xOjAsXCJib29sXCIpLFhZPXtrZXJuZWxOYW1lOm5vLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpLWX0sWVk9bHQoYW8sZT0+TnVtYmVyLmlzTmFOKGUpPzE6MCxcImJvb2xcIiksWlk9e2tlcm5lbE5hbWU6YW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOllZfTtmdW5jdGlvbiBKWShlKXtsZXR7YmFja2VuZDp0LGF0dHJzOm59PWUse3N0YXJ0OmEsc3RvcDpyLG51bTpzfT1uLGk9S0UoYSxyLHMpO3JldHVybiB0Lm1ha2VUZW5zb3JJbmZvKFtpLmxlbmd0aF0sXCJmbG9hdDMyXCIsaSl9dmFyIFFZPXtrZXJuZWxOYW1lOnZ1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpKWX0sZTc9bHQoaW8sZT0+TWF0aC5sb2cxcChlKSksdDc9e2tlcm5lbE5hbWU6aW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmU3fSxuNz1NdCgoZSx0KT0+ZSYmdCksYTc9WnQod3UsbjcsbnVsbCxcImJvb2xcIikscjc9e2tlcm5lbE5hbWU6d3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmE3fSxzNz1sdChrdSxlPT5lPzA6MSxcImJvb2xcIiksaTc9e2tlcm5lbE5hbWU6a3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnM3fSxvNz1NdCgoZSx0KT0+ZXx8dCksbDc9WnQoSXUsbzcsbnVsbCxcImJvb2xcIiksdTc9e2tlcm5lbE5hbWU6SXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmw3fTtmdW5jdGlvbiBwNyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZGVwdGhSYWRpdXM6cyxiaWFzOmksYWxwaGE6byxiZXRhOmx9PWE7Z2UocixcIkxSTlwiKTtsZXQgdT1yLnNoYXBlWzNdLHA9dS0xLGQ9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGM9dy5zaXplRnJvbVNoYXBlKHIuc2hhcGUpLGg9bmV3IEZsb2F0MzJBcnJheShjKTtmdW5jdGlvbiBtKGYpe2xldCBnPWYldSxiPWYtZytNYXRoLm1heCgwLGctcykseT1mLWcrTWF0aC5taW4oZytzLHApLHg9MDtmb3IoO2I8PXk7YisrKXtsZXQgdj1kW2JdO3grPXYqdn1yZXR1cm4geH1mb3IobGV0IGY9MDtmPGM7ZisrKXtsZXQgZz1tKGYpLGI9ZFtmXSpNYXRoLnBvdyhpK28qZywtbCk7aFtmXT1ifXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKHIuc2hhcGUsci5kdHlwZSxoKX12YXIgYzc9e2tlcm5lbE5hbWU6b28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnA3fTtmdW5jdGlvbiBkNyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cix5OnMsZHk6aX09dCx7ZGVwdGhSYWRpdXM6byxiaWFzOmwsYWxwaGE6dSxiZXRhOnB9PWE7Z2UoaSxcIkxSTkdyYWRcIik7bGV0IGQ9dy5zaXplRnJvbVNoYXBlKGkuc2hhcGUpLGM9aS5zaGFwZVszXSxoPW4uZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlcyxtPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxmPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxnPW5ldyBGbG9hdDMyQXJyYXkoZCksYj1kO2ZvcihsZXQgeT0wO3k8Yjt5Kyspe2xldCB4PXklYyx2PXkteCtNYXRoLm1heCgwLHgtbyksST15LXgrTWF0aC5taW4oYyx4K28rMSksTj0wO2ZvcihsZXQgQz12O0M8STtDKyspTis9TWF0aC5wb3cobVtDXSwyKTtOPXUqTitsO2ZvcihsZXQgQz12O0M8STtDKyspe2xldCBfPS0yKnUqcCptW0NdKmZbeV0vTjt5PT09QyYmKF8rPU1hdGgucG93KE4sLXApKSxfKj1oW3ldLGdbQ10rPV99fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGkuc2hhcGUsci5kdHlwZSxnKX12YXIgaDc9e2tlcm5lbE5hbWU6U3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmQ3fTtmdW5jdGlvbiBDXyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7cmVkdWN0aW9uSW5kaWNlczpzLGtlZXBEaW1zOml9PWEsbz1uLGw9ci5zaGFwZSx1PWwubGVuZ3RoLHA9dy5wYXJzZUF4aXNQYXJhbShzLGwpLGQ9cCxjPVQuZ2V0QXhlc1Blcm11dGF0aW9uKGQsdSksaD1vLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXM7aWYoYyE9bnVsbCl7bGV0IHY9bmV3IEFycmF5KHUpO2ZvcihsZXQgST0wO0k8di5sZW5ndGg7SSsrKXZbSV09bFtjW0ldXTtoPVcxKGgsbCxyLmR0eXBlLGMsdiksZD1ULmdldElubmVyTW9zdEF4ZXMoZC5sZW5ndGgsdSksbD12fWdlKHIsXCJtYXhcIiksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1heFwiLGQsdSk7bGV0W20sZl09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGwsZCksZz13LnNpemVGcm9tU2hhcGUoZiksYj1ZRShoLGcsbSxyLmR0eXBlKSx5PW8ud3JpdGUoYixtLHIuZHR5cGUpLHg9bTtyZXR1cm4gaSYmKHg9VC5leHBhbmRTaGFwZVRvS2VlcERpbShtLHApKSx7ZGF0YUlkOnksc2hhcGU6eCxkdHlwZTpyLmR0eXBlfX12YXIgbTc9e2tlcm5lbE5hbWU6bG8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkNffTtmdW5jdGlvbiBmNyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dDtnZShyLFwibWF4UG9vbFwiKTtsZXR7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkaW1Sb3VuZGluZ01vZGU6bH09YSx1PTE7dy5hc3NlcnQoVC5laXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUoaSx1KSwoKT0+YEVycm9yIGluIG1heFBvb2w6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7aX0gYW5kIGRpbGF0aW9ucyAnJHt1fSdgKTtsZXQgcD1ULmNvbXB1dGVQb29sMkRJbmZvKHIuc2hhcGUscyxpLHUsbyxsKSxkO2lmKHAuZmlsdGVyV2lkdGg9PT0xJiZwLmZpbHRlckhlaWdodD09PTEmJncuYXJyYXlzRXF1YWwocC5pblNoYXBlLHAub3V0U2hhcGUpKWQ9Y3Ioe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KTtlbHNle2xldCBjPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxoPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksbT1LMShjLHIuc2hhcGUsci5kdHlwZSxoLHAsXCJtYXhcIik7ZD1uLm1ha2VUZW5zb3JJbmZvKHAub3V0U2hhcGUsci5kdHlwZSxtLnZhbHVlcyl9cmV0dXJuIGR9dmFyIGc3PXtrZXJuZWxOYW1lOnBvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmN307ZnVuY3Rpb24gYjcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8sZGltUm91bmRpbmdNb2RlOmwsZGF0YUZvcm1hdDp1fT1hO2dlKHIsXCJtYXhQb29sM2RcIik7bGV0IHA9VC5jb21wdXRlUG9vbDNESW5mbyhyLnNoYXBlLHMsaSwxLG8sbCx1KSxkPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxjPUlfKGQsci5zaGFwZSxyLmR0eXBlLHcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSkscCxcIm1heFwiKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhjLnNoYXBlLFwiZmxvYXQzMlwiLGMudmFsdWVzKX12YXIgeTc9e2tlcm5lbE5hbWU6TnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmI3fTtmdW5jdGlvbiB4NyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCx7ZmlsdGVyU2l6ZTppLHN0cmlkZXM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dX09YTtnZShbcixzXSxcIm1heFBvb2wzREdyYWRcIik7bGV0IHA9VC5jb21wdXRlUG9vbDNESW5mbyhzLnNoYXBlLGksbywxLGwsdSksZD1uLmJ1ZmZlclN5bmMocyksYz1vWChkLHApLGg9cC5zdHJpZGVEZXB0aCxtPXAuc3RyaWRlSGVpZ2h0LGY9cC5zdHJpZGVXaWR0aCxnPXAuZGlsYXRpb25EZXB0aCxiPXAuZGlsYXRpb25IZWlnaHQseT1wLmRpbGF0aW9uV2lkdGgseD1wLmVmZmVjdGl2ZUZpbHRlckRlcHRoLHY9cC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsST1wLmVmZmVjdGl2ZUZpbHRlcldpZHRoLE49eC0xLXAucGFkSW5mby5mcm9udCxDPUktMS1wLnBhZEluZm8ubGVmdCxfPXYtMS1wLnBhZEluZm8udG9wLEY9T2Uocy5zaGFwZSxcImZsb2F0MzJcIiksRD1uLmJ1ZmZlclN5bmMocik7Zm9yKGxldCAkPTA7JDxwLmJhdGNoU2l6ZTsrKyQpZm9yKGxldCBTPTA7UzxwLmluQ2hhbm5lbHM7KytTKWZvcihsZXQgTT0wO008cC5pbkRlcHRoOysrTSlmb3IobGV0IEI9MDtCPHAuaW5IZWlnaHQ7KytCKWZvcihsZXQgVT0wO1U8cC5pbldpZHRoOysrVSl7bGV0IEg9TS1OLHE9Qi1fLEs9VS1DLFo9MDtmb3IobGV0IEo9MDtKPHg7Sis9Zyl7bGV0IGVlPShIK0opL2g7aWYoIShlZTwwfHxlZT49cC5vdXREZXB0aHx8TWF0aC5mbG9vcihlZSkhPT1lZSkpZm9yKGxldCBhZT0wO2FlPHY7YWUrPWIpe2xldCB0ZT0ocSthZSkvbTtpZighKHRlPDB8fHRlPj1wLm91dEhlaWdodHx8TWF0aC5mbG9vcih0ZSkhPT10ZSkpZm9yKGxldCBzZT0wO3NlPEk7c2UrPXkpe2xldCBpZT0oSytzZSkvZjtpZihpZTwwfHxpZT49cC5vdXRXaWR0aHx8TWF0aC5mbG9vcihpZSkhPT1pZSljb250aW51ZTtsZXQgdmU9eCp2KkktMS1jLmdldCgkLGVlLHRlLGllLFMpLHVlPUoqdipJK2FlKkkrc2UseWU9dmU9PT11ZT8xOjA7aWYoeWU9PT0wKWNvbnRpbnVlO2xldCBrZT1ELmdldCgkLGVlLHRlLGllLFMpO1orPWtlKnllfX19Ri5zZXQoWiwkLE0sQixVLFMpfXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKEYuc2hhcGUsRi5kdHlwZSxGLnZhbHVlcyl9dmFyIHY3PXtrZXJuZWxOYW1lOkJjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp4N307ZnVuY3Rpb24gdzcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnMsb3V0cHV0Oml9PXQsbz1zO2dlKFtzLGldLFwibWF4UG9vbEdyYWRcIik7bGV0e2ZpbHRlclNpemU6bCxzdHJpZGVzOnUscGFkOnAsZGltUm91bmRpbmdNb2RlOmR9PWEsYz1ULmNvbXB1dGVQb29sMkRJbmZvKG8uc2hhcGUsbCx1LDEscCxkKSxoPW4uZGF0YS5nZXQoby5kYXRhSWQpLnZhbHVlcyxtPU9lKGMub3V0U2hhcGUsby5kdHlwZSxrXyhoLG8uc2hhcGUsby5kdHlwZSxjKS52YWx1ZXMpLGY9Yy5zdHJpZGVIZWlnaHQsZz1jLnN0cmlkZVdpZHRoLGI9Yy5kaWxhdGlvbkhlaWdodCx5PWMuZGlsYXRpb25XaWR0aCx4PWMuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHY9Yy5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxJPXYtMS1jLnBhZEluZm8ubGVmdCxOPXgtMS1jLnBhZEluZm8udG9wLEM9T2Uoby5zaGFwZSxcImZsb2F0MzJcIiksXz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsRj1PZShyLnNoYXBlLFwiZmxvYXQzMlwiLF8pO2ZvcihsZXQgRD0wO0Q8Yy5iYXRjaFNpemU7KytEKWZvcihsZXQgJD0wOyQ8Yy5pbkNoYW5uZWxzOysrJClmb3IobGV0IFM9MDtTPGMuaW5IZWlnaHQ7KytTKWZvcihsZXQgTT0wO008Yy5pbldpZHRoOysrTSl7bGV0IEI9Uy1OLFU9TS1JLEg9MDtmb3IobGV0IHE9MDtxPHg7cSs9Yil7bGV0IEs9KEIrcSkvZjtpZighKEs8MHx8Sz49Yy5vdXRIZWlnaHR8fE1hdGguZmxvb3IoSykhPT1LKSlmb3IobGV0IFo9MDtaPHY7Wis9eSl7bGV0IEo9KFUrWikvZztpZihKPDB8fEo+PWMub3V0V2lkdGh8fE1hdGguZmxvb3IoSikhPT1KKWNvbnRpbnVlO2xldCBlZT14KnYtMS1tLmdldChELEssSiwkKSxhZT1xKnYrWix0ZT1lZT09PWFlPzE6MDtpZih0ZT09PTApY29udGludWU7bGV0IHNlPUYuZ2V0KEQsSyxKLCQpO0grPXNlKnRlfX1DLnNldChILEQsUyxNLCQpfXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKEMuc2hhcGUsQy5kdHlwZSxDLnZhbHVlcyl9dmFyIGs3PXtrZXJuZWxOYW1lOldjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp3N307ZnVuY3Rpb24gSTcoZSx0LG4sYSxyKXtsZXQgcz13LmNvbXB1dGVTdHJpZGVzKHQpLGk9SzEoZSx0LG4scyxyLFwibWF4XCIpLG89a18oZSx0LG4sciwhMCxhKTtyZXR1cm5baS52YWx1ZXMsby52YWx1ZXNdfXZhciBTNz17a2VybmVsTmFtZTpWYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6KHtpbnB1dHM6ZSxhdHRyczp0LGJhY2tlbmQ6bn0pPT57bGV0e3g6YX09ZSx7ZmlsdGVyU2l6ZTpyLHN0cmlkZXM6cyxwYWQ6aSxpbmNsdWRlQmF0Y2hJbkluZGV4Om99PXQsbD1uO2dlKGEsXCJNYXhQb29sV2l0aEFyZ21heFwiKTtsZXQgdT1sLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMscD1ULmNvbXB1dGVQb29sMkRJbmZvKGEuc2hhcGUscixzLFsxLDFdLGkpLFtkLGNdPUk3KHUsYS5zaGFwZSxhLmR0eXBlLG8scCksaD1sLndyaXRlKGQscC5vdXRTaGFwZSxhLmR0eXBlKSxtPWwud3JpdGUoYyxwLm91dFNoYXBlLGEuZHR5cGUpO3JldHVyblt7ZGF0YUlkOmgsc2hhcGU6cC5vdXRTaGFwZSxkdHlwZTphLmR0eXBlfSx7ZGF0YUlkOm0sc2hhcGU6cC5vdXRTaGFwZSxkdHlwZTpcImludDMyXCJ9XX19O2Z1bmN0aW9uIE43KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YSxvPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSxsPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhyLnNoYXBlLG8pWzFdLHU9dy5zaXplRnJvbVNoYXBlKGwpLHA9W10sZD1uLm1ha2VUZW5zb3JJbmZvKFtdLFwiZmxvYXQzMlwiLG5ldyBGbG9hdDMyQXJyYXkoW3VdKSk7cC5wdXNoKGQpO2xldCBjPWJzKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KTtwLnB1c2goYyk7bGV0IGg9WDEoe2lucHV0czp7YTpjLGI6ZH0sYmFja2VuZDpufSk7cC5wdXNoKGgpO2xldCBtPUVkKHtpbnB1dHM6e3g6aH0sYmFja2VuZDpuLGF0dHJzOntheGlzOnMsa2VlcERpbXM6aX19KTtyZXR1cm4gcC5mb3JFYWNoKGY9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZikpLG19dmFyIFQ3PXtrZXJuZWxOYW1lOmNvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpON307ZnVuY3Rpb24gQzcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxrZWVwRGltczppfT1hO2dlKHIsXCJtaW5cIik7bGV0IG89dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLGw9byx1PVQuZ2V0QXhlc1Blcm11dGF0aW9uKGwsci5zaGFwZS5sZW5ndGgpLHA9cjt1IT1udWxsJiYocD1Wbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTp1fX0pLGw9VC5nZXRJbm5lck1vc3RBeGVzKGwubGVuZ3RoLHIuc2hhcGUubGVuZ3RoKSksVC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcIm1pblwiLGwscC5zaGFwZS5sZW5ndGgpO2xldFtkLGNdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhwLnNoYXBlLGwpLGg9dy5zaXplRnJvbVNoYXBlKGMpLG09dy5tYWtlWmVyb3NUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZShkKSxwLmR0eXBlKSxmPW4uZGF0YS5nZXQocC5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGI9MDtiPG0ubGVuZ3RoOysrYil7bGV0IHk9YipoLHg9Zlt5XTtmb3IobGV0IHY9MDt2PGg7Kyt2KXtsZXQgST1mW3krdl07KE51bWJlci5pc05hTihJKXx8STx4KSYmKHg9SSl9bVtiXT14fXUhPW51bGwmJm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocCk7bGV0IGc9bi5tYWtlVGVuc29ySW5mbyhkLHAuZHR5cGUsbSk7aWYoaSl7bGV0IGI9VC5leHBhbmRTaGFwZVRvS2VlcERpbShkLG8pLHk9eHQoe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmJ9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZykseX1yZXR1cm4gZ312YXIgRTc9e2tlcm5lbE5hbWU6aG8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkM3fTtmdW5jdGlvbiBfNyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7cGFkZGluZ3M6cyxtb2RlOml9PWE7Z2UocixcIm1pcnJvclBhZFwiKTtsZXQgbz1zLm1hcCgoeSx4KT0+eVswXStyLnNoYXBlW3hdK3lbMV0pLGw9cy5tYXAoeT0+eVswXSksdT1zLm1hcCgoeSx4KT0+eVswXStyLnNoYXBlW3hdKSxwPWk9PT1cInJlZmxlY3RcIj8wOjEsZD1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsYz1yLnNoYXBlLmxlbmd0aCxoPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksbT13LnNpemVGcm9tU2hhcGUobyksZj1vLmxlbmd0aCxnPXcuY29tcHV0ZVN0cmlkZXMobyksYj13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoci5kdHlwZSxtKTtmb3IobGV0IHk9MDt5PG07eSsrKXtsZXQgeD13LmluZGV4VG9Mb2MoeSxmLGcpO2ZvcihsZXQgST0wO0k8ZjtJKyspeFtJXTxsW0ldP3hbSV09bFtJXSoyLXhbSV0tcDp4W0ldPj11W0ldJiYoeFtJXT0odVtJXS0xKSoyLXhbSV0rcCk7eD14Lm1hcCgoSSxOKT0+SS1sW05dKTtsZXQgdj13LmxvY1RvSW5kZXgoeCxjLGgpO2JbeV09ZFt2XX1yZXR1cm57ZGF0YUlkOm4ud3JpdGUoYixvLHIuZHR5cGUpLHNoYXBlOm8sZHR5cGU6ci5kdHlwZX19dmFyIEE3PXtrZXJuZWxOYW1lOmZvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpfN30sRjc9TXQoKGUsdCk9PntsZXQgbj1lJXQ7cmV0dXJuIGU8MCYmdDwwfHxlPj0wJiZ0Pj0wP246KG4rdCkldH0pLCQ3PVp0KGdvLEY3KSxENz17a2VybmVsTmFtZTpnbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6JDd9LFI3PXhzKGJtKCkpO2Z1bmN0aW9uIEVfKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7bG9naXRzOnJ9PXQse2RpbTpzfT1hLGk9ci5zaGFwZS5sZW5ndGgsbz1zO2lmKG89PT0tMSYmKG89aS0xKSxvIT09aS0xKXRocm93IEVycm9yKGBTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiBMb2dpdHMgd2FzIHJhbmsgJHtpfSBhbmQgZGltIHdhcyAke299YCk7bGV0IGw9dy5wYXJzZUF4aXNQYXJhbShbb10sci5zaGFwZSksdT1DXyh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cmVkdWN0aW9uSW5kaWNlczpsLGtlZXBEaW1zOiExfX0pLHA9VC5leHBhbmRTaGFwZVRvS2VlcERpbSh1LnNoYXBlLGwpLGQ9eHQoe2lucHV0czp7eDp1fSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnB9fSksYz1qMSh7aW5wdXRzOnthOnIsYjpkfSxiYWNrZW5kOm59KSxoPUxFKHtpbnB1dHM6e3g6Y30sYmFja2VuZDpufSksbT1FZCh7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6bixhdHRyczp7YXhpczpsLGtlZXBEaW1zOiExfX0pLGY9eHQoe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnB9fSksZz1YMSh7aW5wdXRzOnthOmgsYjpmfSxiYWNrZW5kOm59KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh1KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGQpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksZ312YXIgTTc9e2tlcm5lbE5hbWU6em8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkVffTtmdW5jdGlvbiBPNyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2xvZ2l0czpyfT10LHtudW1TYW1wbGVzOnMsc2VlZDppLG5vcm1hbGl6ZWQ6b309YTtnZShyLFwibXVsdGlub21pYWxcIik7bGV0IGw9bz9yOkVfKHtpbnB1dHM6e2xvZ2l0czpyfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTotMX19KSx1PWwuc2hhcGVbMF0scD1sLnNoYXBlWzFdLGQ9bi5kYXRhLmdldChsLmRhdGFJZCkudmFsdWVzLGM9W3Usc10saD13Lm1ha2VaZXJvc1R5cGVkQXJyYXkody5zaXplRnJvbVNoYXBlKGMpLFwiaW50MzJcIik7Zm9yKGxldCBtPTA7bTx1OysrbSl7bGV0IGY9bSpwLGc9bmV3IEZsb2F0MzJBcnJheShwLTEpO2dbMF09ZFtmXTtmb3IobGV0IHg9MTt4PGcubGVuZ3RoOysreClnW3hdPWdbeC0xXStkW2YreF07bGV0IGI9UjcuYWxlYShpLnRvU3RyaW5nKCkpLHk9bSpzO2ZvcihsZXQgeD0wO3g8czsrK3gpe2xldCB2PWIoKTtoW3kreF09Zy5sZW5ndGg7Zm9yKGxldCBJPTA7STxnLmxlbmd0aDtJKyspaWYodjxnW0ldKXtoW3kreF09STticmVha319fXJldHVybiBvfHxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGwpLG4ubWFrZVRlbnNvckluZm8oYyxcImludDMyXCIsaCl9dmFyIFA3PXtrZXJuZWxOYW1lOlR1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpPN30sTDc9bXIubm9uTWF4U3VwcHJlc3Npb25WM0ltcGw7ZnVuY3Rpb24gejcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtib3hlczpyLHNjb3JlczpzfT10LHttYXhPdXRwdXRTaXplOmksaW91VGhyZXNob2xkOm8sc2NvcmVUaHJlc2hvbGQ6bH09YTtnZShyLFwiTm9uTWF4U3VwcHJlc3Npb25cIik7bGV0IHU9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLHA9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLHtzZWxlY3RlZEluZGljZXM6ZH09TDcodSxwLGksbyxsKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbZC5sZW5ndGhdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShkKSl9dmFyIFc3PXtrZXJuZWxOYW1lOl91LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp6N30sQjc9bXIubm9uTWF4U3VwcHJlc3Npb25WNEltcGw7ZnVuY3Rpb24gVjcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtib3hlczpyLHNjb3JlczpzfT10LHttYXhPdXRwdXRTaXplOmksaW91VGhyZXNob2xkOm8sc2NvcmVUaHJlc2hvbGQ6bCxwYWRUb01heE91dHB1dFNpemU6dX09YTtnZShyLFwiTm9uTWF4U3VwcHJlc3Npb25QYWRkZWRcIik7bGV0IHA9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGQ9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLHtzZWxlY3RlZEluZGljZXM6Yyx2YWxpZE91dHB1dHM6aH09QjcocCxkLGksbyxsLHUpO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKFtjLmxlbmd0aF0sXCJpbnQzMlwiLG5ldyBJbnQzMkFycmF5KGMpKSxuLm1ha2VUZW5zb3JJbmZvKFtdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShbaF0pKV19dmFyIFU3PXtrZXJuZWxOYW1lOkF1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpWN30sRzc9bXIubm9uTWF4U3VwcHJlc3Npb25WNUltcGw7ZnVuY3Rpb24gSDcoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtib3hlczpyLHNjb3JlczpzfT10LHttYXhPdXRwdXRTaXplOmksaW91VGhyZXNob2xkOm8sc2NvcmVUaHJlc2hvbGQ6bCxzb2Z0Tm1zU2lnbWE6dX09YTtnZShyLFwiTm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVcIik7bGV0IHA9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGQ9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLGM9aSxoPW8sbT1sLGY9dSx7c2VsZWN0ZWRJbmRpY2VzOmcsc2VsZWN0ZWRTY29yZXM6Yn09RzcocCxkLGMsaCxtLGYpO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKFtnLmxlbmd0aF0sXCJpbnQzMlwiLG5ldyBJbnQzMkFycmF5KGcpKSxuLm1ha2VUZW5zb3JJbmZvKFtiLmxlbmd0aF0sXCJmbG9hdDMyXCIsbmV3IEZsb2F0MzJBcnJheShiKSldfXZhciBqNz17a2VybmVsTmFtZTpGdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6SDd9O2Z1bmN0aW9uIHE3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW5kaWNlczpyfT10LHtkdHlwZTpzLGRlcHRoOmksb25WYWx1ZTpvLG9mZlZhbHVlOmx9PWE7Z2UocixcIm9uZUhvdFwiKTtsZXQgdT13LnNpemVGcm9tU2hhcGUoci5zaGFwZSkscD1uZXcgRmxvYXQzMkFycmF5KHUqaSk7cC5maWxsKGwpO2xldCBkPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcztmb3IobGV0IGM9MDtjPHU7KytjKWRbY10+PTAmJmRbY108aSYmKHBbYyppK2RbY11dPW8pO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKFsuLi5yLnNoYXBlLGldLHMscCl9dmFyIEs3PXtrZXJuZWxOYW1lOnlvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpxN307ZnVuY3Rpb24gZG0oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O2lmKGEuZHR5cGU9PT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcInplcm9zTGlrZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdHJpbmcgdGVuc29yc1wiKTtpZihhLmR0eXBlPT09XCJjb21wbGV4NjRcIil7bGV0IHI9eWkoe2lucHV0czp7aW5wdXQ6YX0sYmFja2VuZDpufSkscz1kbSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pLGk9cWwoe2lucHV0czp7aW5wdXQ6YX0sYmFja2VuZDpufSksbz1kbSh7aW5wdXRzOnt4Oml9LGJhY2tlbmQ6bn0pLGw9WW4oe2lucHV0czp7cmVhbDpzLGltYWc6b30sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ociksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhzKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGkpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksbH1lbHNlIHJldHVybiBZMSh7YmFja2VuZDpuLGF0dHJzOntzaGFwZTphLnNoYXBlLHZhbHVlOjAsZHR5cGU6YS5kdHlwZX19KX12YXIgWDc9e2tlcm5lbE5hbWU6WXUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmRtfTtmdW5jdGlvbiBfXyhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQ7aWYoYS5kdHlwZT09PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwib25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCBmb3Igc3RyaW5nIHRlbnNvcnNcIik7aWYoYS5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCByPXlpKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLHM9X18oe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KSxpPXFsKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLG89ZG0oe2lucHV0czp7eDppfSxiYWNrZW5kOm59KSxsPVluKHtpbnB1dHM6e3JlYWw6cyxpbWFnOm99LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLGx9ZWxzZSByZXR1cm4gWTEoe2JhY2tlbmQ6bixhdHRyczp7c2hhcGU6YS5zaGFwZSx2YWx1ZToxLGR0eXBlOmEuZHR5cGV9fSl9dmFyIFk3PXtrZXJuZWxOYW1lOiR1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpfX307ZnVuY3Rpb24gQV8oZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtheGlzOnJ9PWE7aWYodC5sZW5ndGg9PT0xKXJldHVybiBjbSh7aW5wdXRzOntpbnB1dDp0WzBdfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTpyfX0pO2xldCBzPXRbMF0uc2hhcGUsaT10WzBdLmR0eXBlO3QuZm9yRWFjaChwPT57dy5hc3NlcnRTaGFwZXNNYXRjaChzLHAuc2hhcGUsXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIHNoYXBlc1wiKSx3LmFzc2VydChpPT09cC5kdHlwZSwoKT0+XCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gc3RhY2sgbXVzdCBoYXZlIG1hdGNoaW5nIGR0eXBlc1wiKX0pO2xldCBvPVtdLGw9dC5tYXAocD0+e2xldCBkPWNtKHtpbnB1dHM6e2lucHV0OnB9LGJhY2tlbmQ6bixhdHRyczp7ZGltOnJ9fSk7cmV0dXJuIG8ucHVzaChkKSxkfSksdT1LbCh7aW5wdXRzOmwsYmFja2VuZDpuLGF0dHJzOntheGlzOnJ9fSk7cmV0dXJuIG8uZm9yRWFjaChwPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApKSx1fXZhciBaNz17a2VybmVsTmFtZTpEdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6QV99O2Z1bmN0aW9uIEo3KGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtwYWRkaW5nczpzLGNvbnN0YW50VmFsdWU6aX09YTtnZShyLFwicGFkXCIpO2xldCBvPXMubWFwKChiLHkpPT5iWzBdK3Iuc2hhcGVbeV0rYlsxXSksbD1zLm1hcChiPT5iWzBdKSx1PW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxwPXcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKSxkPXIuc2hhcGUubGVuZ3RoLGM9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxoPXcuc2l6ZUZyb21TaGFwZShvKSxtPW8ubGVuZ3RoLGY9dy5jb21wdXRlU3RyaWRlcyhvKSxnPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShyLmR0eXBlLGgpO2khPT0wJiZnLmZpbGwoaSk7Zm9yKGxldCBiPTA7YjxwO2IrKyl7bGV0IHk9dy5pbmRleFRvTG9jKGIsZCxjKS5tYXAoKHYsSSk9PnYrbFtJXSkseD13LmxvY1RvSW5kZXgoeSxtLGYpO2dbeF09dVtiXX1yZXR1cm57ZGF0YUlkOm4ud3JpdGUoZyxvLHIuZHR5cGUpLHNoYXBlOm8sZHR5cGU6ci5kdHlwZX19dmFyIEZfPXtrZXJuZWxOYW1lOnhvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpKN30sUTc9TXQoKGUsdCk9Pk1hdGgucG93KGUsdCkpLGVaPVp0KHZvLFE3KSx0Wj17a2VybmVsTmFtZTp2byxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ZVp9O2Z1bmN0aW9uIG5aKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7cGFyYW1zTmVzdGVkU3BsaXRzOnIscGFyYW1zRGVuc2VWYWx1ZXM6cyxpbmRpY2VzOml9PXQse291dHB1dFJhZ2dlZFJhbms6b309YSxsPXIubWFwKGI9Pm4uZGF0YS5nZXQoYi5kYXRhSWQpLnZhbHVlcyksdT1yLm1hcChiPT5iLnNoYXBlKSxwPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxkPW4uZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlcyxbYyxoLG1dPW5fKGwsdSxwLHMuc2hhcGUscy5kdHlwZSxkLGkuc2hhcGUsbyksZj1jLm1hcChiPT5uLm1ha2VUZW5zb3JJbmZvKFtiLmxlbmd0aF0sXCJpbnQzMlwiLGIpKSxnPW4ubWFrZVRlbnNvckluZm8obSxzLmR0eXBlLGgpO3JldHVybiBmLmNvbmNhdChbZ10pfXZhciBhWj17a2VybmVsTmFtZTpBbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6blp9O2Z1bmN0aW9uIHJaKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3N0YXJ0czphLGxpbWl0czpyLGRlbHRhczpzfT10LGk9bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLG89bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLFt1LHBdPWFfKGksYS5zaGFwZSxhLmR0eXBlLG8sci5zaGFwZSxsLHMuc2hhcGUpLGQ9bi5tYWtlVGVuc29ySW5mbyhbdS5sZW5ndGhdLFwiaW50MzJcIix1KSxjPW4ubWFrZVRlbnNvckluZm8oW3AubGVuZ3RoXSxhLmR0eXBlLHApO3JldHVybltkLGNdfXZhciBzWj17a2VybmVsTmFtZTpGbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6clp9O2Z1bmN0aW9uIGlaKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7c2hhcGU6cix2YWx1ZXM6cyxkZWZhdWx0VmFsdWU6aSxyb3dQYXJ0aXRpb25UZW5zb3JzOm99PXQse3Jvd1BhcnRpdGlvblR5cGVzOmx9PWEsdT1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMscD1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsZD1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMsYz1vLm1hcChnPT5uLmRhdGEuZ2V0KGcuZGF0YUlkKS52YWx1ZXMpLGg9by5tYXAoZz0+Zy5zaGFwZSksW20sZl09cl8odSxyLnNoYXBlLHAscy5zaGFwZSxzLmR0eXBlLGQsaS5zaGFwZSxjLGgsbCk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obSxzLmR0eXBlLGYpfXZhciBvWj17a2VybmVsTmFtZTokbSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6aVp9O2Z1bmN0aW9uIGxaKGUpe2xldHtiYWNrZW5kOnQsYXR0cnM6bn09ZSx7c3RhcnQ6YSxzdG9wOnIsZHR5cGU6cyxzdGVwOml9PW4sbz1CMShhLHIsaSxzKTtyZXR1cm4gdC5tYWtlVGVuc29ySW5mbyhbby5sZW5ndGhdLHMsbyl9dmFyIHVaPXtrZXJuZWxOYW1lOlVjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpsWn0scFo9bHQoSW8sZT0+MS9lKSxjWj17a2VybmVsTmFtZTpJbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6cFp9O2Z1bmN0aW9uIGRaKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2VzOnJ9PXQse2FsaWduQ29ybmVyczpzLGhhbGZQaXhlbENlbnRlcnM6aSxzaXplOm99PWE7Z2UocixcInJlc2l6ZUJpbGluZWFyXCIpO2xldCBsPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksW3UscF09byxbZCxjLGgsbV09ci5zaGFwZSxmPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxnPW5ldyBGbG9hdDMyQXJyYXkody5zaXplRnJvbVNoYXBlKFtkLHUscCxtXSkpLGI9W3MmJnU+MT9jLTE6YyxzJiZwPjE/aC0xOmhdLHk9W3MmJnU+MT91LTE6dSxzJiZwPjE/cC0xOnBdLHg9MCx2PWJbMF0veVswXSxJPWJbMV0veVsxXTtmb3IobGV0IE49MDtOPGQ7TisrKWZvcihsZXQgQz0wO0M8dTtDKyspe2xldCBfO2k/Xz12KihDKy41KS0uNTpfPXYqQztsZXQgRj1NYXRoLm1heCgwLE1hdGguZmxvb3IoXykpLEQ9Xy1GLCQ9TWF0aC5taW4oYy0xLE1hdGguY2VpbChfKSksUz1OKmxbMF0rRipsWzFdLE09TipsWzBdKyQqbFsxXTtmb3IobGV0IEI9MDtCPHA7QisrKXtsZXQgVTtpP1U9SSooQisuNSktLjU6VT1JKkI7bGV0IEg9TWF0aC5tYXgoMCxNYXRoLmZsb29yKFUpKSxxPVUtSCxLPU1hdGgubWluKGgtMSxNYXRoLmNlaWwoVSkpLFo9UytIKmxbMl0sSj1NK0gqbFsyXSxlZT1TK0sqbFsyXSxhZT1NK0sqbFsyXTtmb3IobGV0IHRlPTA7dGU8bTt0ZSsrKXtsZXQgc2U9ZltaK3RlXSxpZT1mW0ordGVdLHZlPWZbZWUrdGVdLHVlPWZbYWUrdGVdLHllPXNlKyh2ZS1zZSkqcSxrZT1pZSsodWUtaWUpKnEsU2U9eWUrKGtlLXllKSpEO2dbeCsrXT1TZX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtkLHUscCxtXSxcImZsb2F0MzJcIixnKX12YXIgaFo9e2tlcm5lbE5hbWU6VG8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmRafTtmdW5jdGlvbiBtWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlczpyLGR5OnN9PXQse2FsaWduQ29ybmVyczppfT1hO2dlKFtzLHJdLFwicmVzaXplQmlsaW5lYXJHcmFkXCIpO2xldCBvPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksW2wsdSxwLGRdPXIuc2hhcGUsWyxjLGhdPXMuc2hhcGUsbT1uZXcgRmxvYXQzMkFycmF5KGwqdSpwKmQpLGY9W2kmJmM+MT91LTE6dSxpJiZoPjE/cC0xOnBdLGc9W2kmJmM+MT9jLTE6YyxpJiZoPjE/aC0xOmhdLGI9ZlswXS9nWzBdLHk9ZlsxXS9nWzFdLHg9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLHY9MDtmb3IobGV0IEk9MDtJPGw7SSsrKXtsZXQgTj1JKm9bMF07Zm9yKGxldCBDPTA7QzxjO0MrKyl7bGV0IF89QypiLEY9TWF0aC5mbG9vcihfKSxEPU1hdGgubWluKE1hdGguY2VpbChfKSx1LTEpLCQ9TitGKm9bMV0sUz1OK0Qqb1sxXSxNPV8tRixCPTEtTTtmb3IobGV0IFU9MDtVPGg7VSsrKXtsZXQgSD1VKnkscT1NYXRoLmZsb29yKEgpLEs9TWF0aC5taW4oTWF0aC5jZWlsKEgpLHAtMSksWj1ILXEsSj0xLVosZWU9JCtxKm9bMl0sYWU9JCtLKm9bMl0sdGU9UytxKm9bMl0sc2U9UytLKm9bMl0saWU9QipKLHZlPUIqWix1ZT1NKkoseWU9TSpaO2ZvcihsZXQga2U9MDtrZTxkO2tlKyspe2xldCBTZT14W3YrK107bVtlZStrZV0rPVNlKmllLG1bYWUra2VdKz1TZSp2ZSxtW3RlK2tlXSs9U2UqdWUsbVtzZStrZV0rPVNlKnllfX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtsLHAsdSxkXSxcImZsb2F0MzJcIixtKX12YXIgZlo9e2tlcm5lbE5hbWU6T3UsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOm1afTtmdW5jdGlvbiBnWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlczpyfT10LHthbGlnbkNvcm5lcnM6cyxoYWxmUGl4ZWxDZW50ZXJzOmksc2l6ZTpvfT1hO2dlKHIsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7bGV0IGw9dy5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSxbdSxwXT1vLFtkLGMsaCxtXT1yLnNoYXBlLGY9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGc9bmV3IEZsb2F0MzJBcnJheShkKnUqcCptKSxiPVtzJiZ1PjE/Yy0xOmMscyYmcD4xP2gtMTpoXSx5PVtzJiZ1PjE/dS0xOnUscyYmcD4xP3AtMTpwXSx4PWJbMF0veVswXSx2PWJbMV0veVsxXSxJPTA7Zm9yKGxldCBOPTA7TjxkO04rKyl7bGV0IEM9TipsWzBdO2ZvcihsZXQgXz0wO188dTtfKyspe2xldCBGPWk/eCooXysuNSk6eCpfLEQ9TWF0aC5taW4oYy0xLHM/TWF0aC5yb3VuZChGKTpNYXRoLmZsb29yKEYpKTtpJiYoRD1NYXRoLm1heCgwLEQpKTtsZXQgJD1DK0QqbFsxXTtmb3IobGV0IFM9MDtTPHA7UysrKXtsZXQgTT1pP3YqKFMrLjUpOnYqUyxCPU1hdGgubWluKGgtMSxzP01hdGgucm91bmQoTSk6TWF0aC5mbG9vcihNKSk7aSYmKEI9TWF0aC5tYXgoMCxCKSk7bGV0IFU9JCtCKmxbMl07Zm9yKGxldCBIPTA7SDxtO0grKyl7bGV0IHE9ZltVK0hdO2dbSSsrXT1xfX19fXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtkLHUscCxtXSxyLmR0eXBlLGcpfXZhciBiWj17a2VybmVsTmFtZTpObyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Z1p9O2Z1bmN0aW9uIHlaKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2VzOnIsZHk6c309dCx7YWxpZ25Db3JuZXJzOml9PWE7Z2UoW3Mscl0sXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JHcmFkXCIpO2xldCBvPXcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSksbD13LmNvbXB1dGVTdHJpZGVzKHMuc2hhcGUpLFt1LHAsZCxjXT1yLnNoYXBlLFssaCxtXT1zLnNoYXBlLGY9bmV3IEZsb2F0MzJBcnJheSh1KnAqZCpjKSxnPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyxiPVtpJiZoPjE/cC0xOnAsaSYmbT4xP2QtMTpkXSx5PVtpJiZoPjE/aC0xOmgsaSYmbT4xP20tMTptXSx4PWJbMF0veVswXSx2PWJbMV0veVsxXSxJPTEveCxOPTEvdixDPU1hdGguY2VpbChJKSoyKzIsXz1NYXRoLmNlaWwoTikqMisyO2ZvcihsZXQgRj0wO0Y8dTtGKyspe2xldCBEPUYqb1swXTtmb3IobGV0ICQ9MDskPHA7JCsrKXtsZXQgUz1EKyQqb1sxXSxNPU1hdGguZmxvb3IoJCpJKSxCPU1hdGguZmxvb3IoTS1DLzIpO2ZvcihsZXQgVT0wO1U8ZDtVKyspe2xldCBIPVMrVSpvWzJdLHE9TWF0aC5mbG9vcihVKk4pLEs9TWF0aC5mbG9vcihxLV8vMik7Zm9yKGxldCBaPTA7WjxjO1orKyl7bGV0IEo9MDtmb3IobGV0IGVlPTA7ZWU8QztlZSsrKXtsZXQgYWU9ZWUrQjtpZihhZTwwfHxhZT49aCljb250aW51ZTtsZXQgdGU9RCthZSpsWzFdLHNlPWFlKngsaWU9TWF0aC5taW4ocC0xLGk/TWF0aC5yb3VuZChzZSk6TWF0aC5mbG9vcihzZSkpO2lmKCQ9PT1pZSlmb3IobGV0IHZlPTA7dmU8Xzt2ZSsrKXtsZXQgdWU9dmUrSztpZih1ZTwwfHx1ZT49bSljb250aW51ZTtsZXQgeWU9dGUrdWUqbFsyXSxrZT11ZSp2LFNlPU1hdGgubWluKGQtMSxpP01hdGgucm91bmQoa2UpOk1hdGguZmxvb3Ioa2UpKTtVPT09U2UmJihKKz1nW3llK1pdKX19ZltIK1pdPUp9fX19cmV0dXJuIG4ubWFrZVRlbnNvckluZm8oci5zaGFwZSxyLmR0eXBlLGYpfXZhciB4Wj17a2VybmVsTmFtZTpNdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6eVp9O2Z1bmN0aW9uIHZaKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtkaW1zOnN9PWE7Z2UocixcInJldmVyc2VcIik7bGV0IGk9ci5zaGFwZS5sZW5ndGgsbz13LnBhcnNlQXhpc1BhcmFtKHMsci5zaGFwZSk7aWYoaT09PTApcmV0dXJuIGNyKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7bGV0IGw9bmV3IFd0KHIuc2hhcGUsci5kdHlwZSksdT1uLmJ1ZmZlclN5bmMocik7Zm9yKGxldCBwPTA7cDxsLnNpemU7cCsrKXtsZXQgZD1sLmluZGV4VG9Mb2MocCksYz1kLnNsaWNlKCk7by5mb3JFYWNoKGg9PmNbaF09ci5zaGFwZVtoXS0xLWNbaF0pLGwuc2V0KHUuZ2V0KC4uLmMpLC4uLmQpfXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwuc2hhcGUsbC5kdHlwZSxsLnZhbHVlcyl9dmFyIHdaPXtrZXJuZWxOYW1lOkVvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp2Wn0sa1o9e2tlcm5lbE5hbWU6WnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYXR0cnM6dCxiYWNrZW5kOm59KT0+e2xldHtpbWFnZTphfT1lLHtyYWRpYW5zOnIsZmlsbFZhbHVlOnMsY2VudGVyOml9PXQsbz1uLGw9dy5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGEuZHR5cGUsdy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpKSxbdSxwLGQsY109YS5zaGFwZSxbaCxtXT1ULmdldEltYWdlQ2VudGVyKGkscCxkKSxmPTI1NSxnPU1hdGguc2luKHIpLGI9TWF0aC5jb3MocikseT1vLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXM7Zm9yKGxldCB4PTA7eDx1O3grKyl7bGV0IHY9eCpkKnAqYztmb3IobGV0IEk9MDtJPHA7SSsrKXtsZXQgTj1JKihkKmMpO2ZvcihsZXQgQz0wO0M8ZDtDKyspe2xldCBfPUMqYztmb3IobGV0IEY9MDtGPGM7RisrKXtsZXQgRD1bdSxJLEMsRl0sJD1EWzJdLFM9RFsxXSxNPSgkLWgpKmItKFMtbSkqZyxCPSgkLWgpKmcrKFMtbSkqYjtNPU1hdGgucm91bmQoTStoKSxCPU1hdGgucm91bmQoQittKTtsZXQgVT1zO2lmKHR5cGVvZiBzIT1cIm51bWJlclwiJiYoRj09PTM/VT1mOlU9c1tGXSksTT49MCYmTTxkJiZCPj0wJiZCPHApe2xldCBxPUIqKGQqYyksSz1NKmMsWj12K3ErSytGO1U9eVtaXX1sZXQgSD12K04rXytGO2xbSF09VX19fX1yZXR1cm57ZGF0YUlkOm8ud3JpdGUobCxhLnNoYXBlLGEuZHR5cGUpLHNoYXBlOmEuc2hhcGUsZHR5cGU6YS5kdHlwZX19fSxJWj1sdChfbyxlPT57bGV0IHQ9TWF0aC5mbG9vcihlKTtyZXR1cm4gZS10PC41P01hdGguZmxvb3IoZSk6ZS10Pi41P01hdGguY2VpbChlKTp0JTI9PT0wP3Q6dCsxfSksU1o9e2tlcm5lbE5hbWU6X28sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOklafTtmdW5jdGlvbiBOWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2luZGljZXM6cix1cGRhdGVzOnN9PXQse3NoYXBlOml9PWEse3NsaWNlUmFuazpvLG51bVVwZGF0ZXM6bCxzbGljZVNpemU6dSxzdHJpZGVzOnAsb3V0cHV0U2l6ZTpkfT1ULmNhbGN1bGF0ZVNoYXBlcyhzLHIsaSksYz0hMCxoPW4uYnVmZmVyU3luYyhyKSxtPW4uYnVmZmVyU3luYyhzKSxmPW5pKGgsbSxpLGQsdSxsLG8scCwwLGMpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGksZi5kdHlwZSxmLnZhbHVlcyl9dmFyIFRaPXtrZXJuZWxOYW1lOlB1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpOWn07ZnVuY3Rpb24gQ1ooZSx0KXtsZXQgbj0wLGE9ZS5sZW5ndGgscj0wO2Zvcig7bjxhOylyPU1hdGguZmxvb3IoKG4rYSkvMiksZVtyXTx0P249cisxOmE9cjtyZXR1cm4gYX1mdW5jdGlvbiBFWihlLHQpe2xldCBuPTAsYT1lLmxlbmd0aCxyPTA7Zm9yKDtuPGE7KXI9TWF0aC5mbG9vcigobithKS8yKSxlW3JdPD10P249cisxOmE9cjtyZXR1cm4gYX1mdW5jdGlvbiBfWihlLHQsbixhLHIscyl7bGV0IGk9dy5nZXRBcnJheUZyb21EVHlwZShcImludDMyXCIsbipyKTtmb3IobGV0IG89MDtvPG47KytvKXtsZXQgbD1lLnNsaWNlKG8qYSwobysxKSphKSx1PW8qcjtmb3IobGV0IHA9MDtwPHI7KytwKWlbdStwXT1zPT09XCJsZWZ0XCI/Q1oobCx0W3ArdV0pOkVaKGwsdFtwK3VdKX1yZXR1cm4gaX1mdW5jdGlvbiBBWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NvcnRlZFNlcXVlbmNlOnIsdmFsdWVzOnN9PXQse3NpZGU6aX09YSxvPW4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxsPW4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyx1PV9aKG8sbCxyLnNoYXBlWzBdLHIuc2hhcGVbMV0scy5zaGFwZVsxXSxpKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhzLnNoYXBlLFwiaW50MzJcIix1KX12YXIgRlo9e2tlcm5lbE5hbWU6enUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOkFafTtmdW5jdGlvbiAkWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtjb25kaXRpb246YSx0OnIsZTpzfT10O2dlKFthLHIsc10sXCJzZWxlY3RcIik7bGV0IGk9YS5zaGFwZS5sZW5ndGgsbz1uLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsbD1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsdT1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMscD1mYShyLmR0eXBlLHMuZHR5cGUpLGQ9dy5tYWtlWmVyb3NUeXBlZEFycmF5KHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKSxwKSxjPTAsaD1pPT09MHx8aT4xfHxyLnNoYXBlLmxlbmd0aD09PTE/MTp3LnNpemVGcm9tU2hhcGUoci5zaGFwZS5zbGljZSgxKSk7Zm9yKGxldCBtPTA7bTxvLmxlbmd0aDttKyspZm9yKGxldCBmPTA7ZjxoO2YrKylvW21dPT09MT9kW2MrK109bFttXTpkW2MrK109dVttXTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhyLnNoYXBlLHAsZCl9dmFyIERaPXtrZXJuZWxOYW1lOld1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzokWn0sUlo9VC5TRUxVX1NDQUxFQUxQSEEsTVo9VC5TRUxVX1NDQUxFLE9aPWx0KEZvLGU9PmU+PTA/TVoqZTpSWiooTWF0aC5leHAoZSktMSkpLFBaPXtrZXJuZWxOYW1lOkZvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpPWn0sTFo9bHQoUm8sZT0+ZTwwPy0xOmU+MD8xOjApLHpaPXtrZXJuZWxOYW1lOlJvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpMWn0sV1o9bHQoJG8sZT0+TWF0aC5zaW4oZSkpLEJaPXtrZXJuZWxOYW1lOiRvLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpXWn0sVlo9bHQoRG8sZT0+TWF0aC5zaW5oKGUpKSxVWj17a2VybmVsTmFtZTpEbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Vlp9LEdaPTExOTIwOTI4OTU1MDc4MTI1ZS0yMyxlUz1NYXRoLmxvZyhHWikrMixIWj1sdChPbyxlPT57bGV0IHQ9ZT4tZVMsbj1lPGVTLGE9TWF0aC5leHAoZSkscjtyZXR1cm4gbj9yPWE6dD9yPWU6cj1NYXRoLmxvZygxK2EpLHJ9KSxqWj17a2VybmVsTmFtZTpPbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6SFp9O2Z1bmN0aW9uIHFaKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtibG9ja1NoYXBlOnMscGFkZGluZ3M6aX09YTtnZShbcl0sXCJzcGFjZVRvQmF0Y2hORFwiKTtsZXQgbz13LnNpemVGcm9tU2hhcGUocyksbD1bWzAsMF1dO2wucHVzaCguLi5pKTtmb3IobGV0IGc9MStzLmxlbmd0aDtnPHIuc2hhcGUubGVuZ3RoOysrZylsLnB1c2goWzAsMF0pO2xldCB1PUZfLmtlcm5lbEZ1bmMoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3BhZGRpbmdzOmwsY29uc3RhbnRWYWx1ZTowfX0pLHA9VC5nZXRSZXNoYXBlZCh1LnNoYXBlLHMsbywhMSksZD1ULmdldFBlcm11dGVkKHAubGVuZ3RoLHMubGVuZ3RoLCExKSxjPVQuZ2V0UmVzaGFwZWRQZXJtdXRlZCh1LnNoYXBlLHMsbywhMSksaD14dCh7aW5wdXRzOnt4OnV9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6cH19KSxtPVZuKHtpbnB1dHM6e3g6aH0sYmFja2VuZDpuLGF0dHJzOntwZXJtOmR9fSksZj14dCh7aW5wdXRzOnt4Om19LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Y319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh1KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSksZn12YXIgS1o9e2tlcm5lbE5hbWU6VnUsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnFafTtmdW5jdGlvbiBYWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbmRpY2VzOmEsdmFsdWVzOnIsZGVuc2VTaGFwZTpzLGRlZmF1bHRWYWx1ZTppfT10O2lmKHMuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYERlbnNlIHNoYXBlIG11c3QgYmUgYSB2ZWN0b3IsIHNhdzpcbiAgICAgICAgJHtzLnNoYXBlfWApO2lmKGEuc2hhcGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgbXVzdCBiZSBhIG1hdHJpeCwgc2F3OlxuICAgICAgICAke2Euc2hhcGV9YCk7aWYoci5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgVmFsdWVzIG11c3QgYmUgYSB2ZWN0b3IsIHNhdzpcbiAgICAgICAgJHtyLnNoYXBlfWApO2lmKGkuc2hhcGUubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYERlZmF1bHQgdmFsdWUgbXVzdCBiZSBhIHNjYWxhciwgc2F3OlxuICAgICAgICAke2kuc2hhcGV9YCk7bGV0IG89bi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGw9bi5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLHU9bi5kYXRhLmdldChzLmRhdGFJZCkudmFsdWVzLHA9bi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzWzBdLFtkLGMsaCxtLGZdPW9fKG8sYS5zaGFwZSxhLmR0eXBlLGwsci5kdHlwZSx1LHApO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKGMsYS5kdHlwZSxkKSxuLm1ha2VUZW5zb3JJbmZvKFtjWzBdXSxyLmR0eXBlLGgpLG4ubWFrZVRlbnNvckluZm8oW20ubGVuZ3RoXSxcImJvb2xcIixuZXcgVWludDhBcnJheShtLm1hcChnPT5OdW1iZXIoZykpKSksbi5tYWtlVGVuc29ySW5mbyhbZi5sZW5ndGhdLGEuZHR5cGUsbmV3IEludDMyQXJyYXkoZikpXX12YXIgWVo9e2tlcm5lbE5hbWU6R2MsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOlhafTtmdW5jdGlvbiBaWihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dEluZGljZXM6YSxpbnB1dFNoYXBlOnIsbmV3U2hhcGU6c309dDtpZihhLnNoYXBlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBpbmRpY2VzIHNob3VsZCBiZSBhIG1hdHJpeCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgJHthLnNoYXBlfWApO2lmKHIuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNoYXBlIHNob3VsZCBiZSBhIHZlY3RvciBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgJHtyLnNoYXBlfWApO2lmKHMuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBzaGFwZSBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlICR7cy5zaGFwZX1gKTtsZXQgaT1BcnJheS5mcm9tKG4uZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyksbz1uLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsbD1BcnJheS5mcm9tKG4uZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcyksW3UscCxkXT1sXyhvLGEuc2hhcGUsYS5kdHlwZSxpLGwpO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKHAsYS5kdHlwZSx1KSxuLm1ha2VUZW5zb3JJbmZvKFtkLmxlbmd0aF0scy5kdHlwZSxuZXcgSW50MzJBcnJheShkKSldfXZhciBKWj17a2VybmVsTmFtZTpHdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Wlp9O2Z1bmN0aW9uIFFaKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2RhdGE6YSxpbmRpY2VzOnIsc2VnbWVudElkczpzfT10O2lmKGEuc2hhcGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBzaG91bGQgYmUgYXQgbGVhc3QgMSBkaW1lbnNpb25hbCBidXQgcmVjZWl2ZWQgc2NhbGFyXCIpO2lmKHIuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgICR7ci5zaGFwZX1gKTtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBTZWdtZW50IGlkcyBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAgJHtzLnNoYXBlfWApO2lmKHIuc2hhcGVbMF0hPT1zLnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcInNlZ21lbnRJZHMgYW5kIGluZGljZXMgc2hvdWxkIGhhdmUgc2FtZSBzaXplLlwiKTtsZXQgaT1uLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsbz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsbD1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsW3UscF09VjEoaSxhLnNoYXBlLGEuZHR5cGUsbyxsLCEwKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhwLGEuZHR5cGUsdSl9dmFyIGVKPXtrZXJuZWxOYW1lOkhjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpRWn07ZnVuY3Rpb24gdEooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7ZGF0YTphLGluZGljZXM6cixzZWdtZW50SWRzOnN9PXQ7aWYoYS5zaGFwZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHNob3VsZCBiZSBhdCBsZWFzdCAxIGRpbWVuc2lvbmFsIGJ1dCByZWNlaXZlZCBzY2FsYXJcIik7aWYoci5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgSW5kaWNlcyBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAke3Iuc2hhcGV9YCk7aWYocy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgU2VnbWVudCBpZHMgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgJHtzLnNoYXBlfWApO2lmKHIuc2hhcGVbMF0hPT1zLnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcInNlZ21lbnRJZHMgYW5kIGluZGljZXMgc2hvdWxkIGhhdmUgc2FtZSBzaXplLlwiKTtsZXQgaT1uLmRhdGEuZ2V0KGEuZGF0YUlkKS52YWx1ZXMsbz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsbD1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsW3UscF09VjEoaSxhLnNoYXBlLGEuZHR5cGUsbyxsKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhwLGEuZHR5cGUsdSl9dmFyIG5KPXtrZXJuZWxOYW1lOmpjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzp0Sn07ZnVuY3Rpb24gYUooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtzcGFyc2VJbmRpY2VzOnIsc3BhcnNlVmFsdWVzOnMsZGVmYXVsdFZhbHVlOml9PXQse291dHB1dFNoYXBlOm99PWEse3NsaWNlUmFuazpsLG51bVVwZGF0ZXM6dSxzbGljZVNpemU6cCxzdHJpZGVzOmQsb3V0cHV0U2l6ZTpjfT1ULmNhbGN1bGF0ZVNoYXBlcyhzLHIsbyksaD0hMSxtPW4uYnVmZmVyU3luYyhyKSxmO3N3aXRjaChzLmR0eXBlKXtjYXNlXCJib29sXCI6e2xldCBnPW4uYnVmZmVyU3luYyhzKSxiPSEhbi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzWzBdO2Y9bmkobSxnLG8sYyxwLHUsbCxkLGIsaCk7YnJlYWt9Y2FzZVwiZmxvYXQzMlwiOntsZXQgZz1uLmJ1ZmZlclN5bmMocyksYj1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXNbMF07Zj1uaShtLGcsbyxjLHAsdSxsLGQsYixoKTticmVha31jYXNlXCJpbnQzMlwiOntsZXQgZz1uLmJ1ZmZlclN5bmMocyksYj1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXNbMF07Zj1uaShtLGcsbyxjLHAsdSxsLGQsYixoKTticmVha31jYXNlXCJzdHJpbmdcIjp7bGV0IGc9bi5idWZmZXJTeW5jKHMpLGI9dy5kZWNvZGVTdHJpbmcobi5kYXRhLmdldChpLmRhdGFJZCkudmFsdWVzWzBdKTtmPW5pKG0sZyxvLGMscCx1LGwsZCxiLGgpO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlICR7cy5kdHlwZX1gKX1yZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhvLGYuZHR5cGUsZi52YWx1ZXMpfXZhciBySj17a2VybmVsTmFtZTpIdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6YUp9O2Z1bmN0aW9uIHNKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtudW1PclNpemVTcGxpdHM6cyxheGlzOml9PWEsbz13LnBhcnNlQXhpc1BhcmFtKGksci5zaGFwZSlbMF0sbD1ULnByZXBhcmVTcGxpdFNpemUocixzLG8pLHU9bmV3IEFycmF5KHIuc2hhcGUubGVuZ3RoKS5maWxsKDApLHA9ci5zaGFwZS5zbGljZSgpO3JldHVybiBsLm1hcChkPT57bGV0IGM9Wy4uLnBdO2Nbb109ZDtsZXQgaD14aSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46dSxzaXplOmN9fSk7cmV0dXJuIHVbb10rPWQsaH0pfXZhciBpSj17a2VybmVsTmFtZTpVdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6c0p9LG9KPXtrZXJuZWxOYW1lOnFjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzooe2lucHV0czplLGJhY2tlbmQ6dH0pPT57bGV0e3g6bn09ZSxhPXQ7Z2UobixcInNxdWFyZVwiKTtsZXQgcj1hLmRhdGEuZ2V0KG4uZGF0YUlkKS52YWx1ZXMscz1uZXcgRmxvYXQzMkFycmF5KHIubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHIubGVuZ3RoOysraSl7bGV0IG89cltpXTtzW2ldPW8qb31yZXR1cm57ZGF0YUlkOmEud3JpdGUocyxuLnNoYXBlLG4uZHR5cGUpLHNoYXBlOm4uc2hhcGUsZHR5cGU6bi5kdHlwZX19fSxsSj1sdChJcywoZSx0KT0+e2xldCBuPXQ7cmV0dXJuIGlzTmFOKGUpP05hTjplPjA/MTpuLmFscGhhfSksdUo9e2tlcm5lbE5hbWU6SXMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmxKfTtmdW5jdGlvbiBwSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YmVnaW46cyxlbmQ6aSxzdHJpZGVzOm8sYmVnaW5NYXNrOmwsZW5kTWFzazp1LGVsbGlwc2lzTWFzazpwLG5ld0F4aXNNYXNrOmQsc2hyaW5rQXhpc01hc2s6Y309YTtnZShyLFwic3RyaWRlZFNsaWNlXCIpO2xldHtmaW5hbFNoYXBlU3BhcnNlOmgsZmluYWxTaGFwZTptLGlzSWRlbnRpdHk6ZixzbGljZURpbTA6Zyxpc1NpbXBsZVNsaWNlOmIsYmVnaW46eSxlbmQ6eCxzdHJpZGVzOnZ9PUt0LnNsaWNlSW5mbyhyLnNoYXBlLHMsaSxvLGwsdSxwLGQsYyksSTtpZihmKUk9eHQoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOm19fSk7ZWxzZSBpZihnfHxiKXt3LmFzc2VydChyLnNoYXBlLmxlbmd0aD49MSwoKT0+YElucHV0IG11c3QgaGF2ZSByYW5rIGF0IGxlYXN0IDEsIGdvdDogJHtyLnNoYXBlLmxlbmd0aH1gKTtsZXQgTj1LdC5jb21wdXRlT3V0U2hhcGUoeSx4LHYpLEM9eGkoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOnksc2l6ZTpOfX0pO0k9eHQoe2lucHV0czp7eDpDfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOm19fSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhDKX1lbHNle2xldCBOPW4uYnVmZmVyU3luYyhyKSxDPWNfKGgsTix2LHkpO0k9bi5tYWtlVGVuc29ySW5mbyhtLEMuZHR5cGUsQy52YWx1ZXMpfXJldHVybiBJfXZhciBjSj17a2VybmVsTmFtZTpqdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6cEp9O2Z1bmN0aW9uIGRKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7c2VwYXJhdG9yOnIsbkdyYW1XaWR0aHM6cyxsZWZ0UGFkOmkscmlnaHRQYWQ6byxwYWRXaWR0aDpsLHByZXNlcnZlU2hvcnRTZXF1ZW5jZXM6dX09YSx7ZGF0YTpwLGRhdGFTcGxpdHM6ZH09dCxjPW4uZGF0YS5nZXQocC5kYXRhSWQpLnZhbHVlcyxoPW4uZGF0YS5nZXQoZC5kYXRhSWQpLnZhbHVlcyxbbSxmXT1VMShjLGgscixzLGksbyxsLHUpO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKFttLmxlbmd0aF0sXCJzdHJpbmdcIixtKSxuLm1ha2VUZW5zb3JJbmZvKGQuc2hhcGUsXCJpbnQzMlwiLGYpXX12YXIgaEo9e2tlcm5lbE5hbWU6WGMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmRKfTtmdW5jdGlvbiBtSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NraXBFbXB0eTpyfT1hLHtpbnB1dDpzLGRlbGltaXRlcjppfT10O2lmKHMuZHR5cGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgb2YgZGF0YXR5cGUgc3RyaW5nXCIpO2lmKHMuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYElucHV0IG11c3QgYmUgYSB2ZWN0b3IsIGdvdCBzaGFwZTogJHtzLnNoYXBlfWApO2lmKGkuc2hhcGUubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYERlbGltaXRlciBtdXN0IGJlIGEgc2NhbGFyLCBnb3Qgc2hhcGU6ICR7aS5zaGFwZX1gKTtsZXQgbz1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsbD1uLmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXNbMF0sW3UscCxkXT1HMShvLGwsciksYz1wLmxlbmd0aDtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhbYywyXSxcImludDMyXCIsdSksbi5tYWtlVGVuc29ySW5mbyhbY10sXCJzdHJpbmdcIixwKSxuLm1ha2VUZW5zb3JJbmZvKFsyXSxcImludDMyXCIsbmV3IEludDMyQXJyYXkoZCkpXX12YXIgZko9e2tlcm5lbE5hbWU6WWMsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOm1KfTtmdW5jdGlvbiBnSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse251bUJ1Y2tldHM6cn09YSx7aW5wdXQ6c309dDtpZihzLmR0eXBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIG9mIGRhdGF0eXBlIHN0cmluZ1wiKTtpZihyPD0wKXRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBidWNrZXRzIG11c3QgYmUgYXQgbGVhc3QgMVwiKTtsZXQgaT1uLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsbz1IMShpLHIpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKHMuc2hhcGUsXCJpbnQzMlwiLG8pfXZhciBiSj17a2VybmVsTmFtZTpaYyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6Z0p9LHlKPWx0KFZvLGU9Pk1hdGgudGFuKGUpKSx4Sj17a2VybmVsTmFtZTpWbyxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6eUp9LHZKPWx0KFVvLGU9Pk1hdGgudGFuaChlKSksd0o9e2tlcm5lbE5hbWU6VW8sYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOnZKfTtmdW5jdGlvbiBrSihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt0ZW5zb3I6YSxpbmRpY2VzOnIsdXBkYXRlczpzfT10LHtzbGljZVJhbms6aSxudW1VcGRhdGVzOm8sc2xpY2VTaXplOmwsc3RyaWRlczp1LG91dHB1dFNpemU6cH09VC5jYWxjdWxhdGVTaGFwZXMocyxyLGEuc2hhcGUpLGQ9ITEsYz1uLmJ1ZmZlclN5bmMociksaD1uLmJ1ZmZlclN5bmMocyksbT1uLmJ1ZmZlclN5bmMoYSksZj1uaShjLGgsYS5zaGFwZSxwLGwsbyxpLHUsbSxkKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhhLnNoYXBlLGYuZHR5cGUsZi52YWx1ZXMpfXZhciBJSj17a2VybmVsTmFtZTpMdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6a0p9O2Z1bmN0aW9uIFNKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtyZXBzOnN9PWE7Z2UocixcInRpbGVcIik7bGV0IGk9aF8obi5idWZmZXJTeW5jKHIpLHMpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGkuc2hhcGUsaS5kdHlwZSxpLnZhbHVlcyl9dmFyIE5KPXtrZXJuZWxOYW1lOmtzLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpTSn07ZnVuY3Rpb24gVEooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2s6cyxzb3J0ZWQ6aX09YTtnZShyLFwidG9wa1wiKTtsZXQgbz1uLmRhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsW2wsdV09Zl8obyxyLnNoYXBlLHIuZHR5cGUscyxpKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhsLnNoYXBlLGwuZHR5cGUsbC52YWx1ZXMpLG4ubWFrZVRlbnNvckluZm8odS5zaGFwZSx1LmR0eXBlLHUudmFsdWVzKV19dmFyIENKPXtrZXJuZWxOYW1lOnF1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpUSn07ZnVuY3Rpb24gRUooZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHtpbWFnZTpyLHRyYW5zZm9ybXM6c309dCx7aW50ZXJwb2xhdGlvbjppLGZpbGxNb2RlOm8sZmlsbFZhbHVlOmwsb3V0cHV0U2hhcGU6dX09bixbcCxkLGMsaF09ci5zaGFwZSxbbSxmXT11IT1udWxsP3U6W2QsY10sZz1bcCxtLGYsaF0sYj13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLHk9YlswXSx4PWJbMV0sdj1iWzJdLEk9dy5jb21wdXRlU3RyaWRlcyhnKSxOPUlbMF0sQz1JWzFdLF89SVsyXSxGPXcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShyLmR0eXBlLHcuc2l6ZUZyb21TaGFwZShnKSk7Ri5maWxsKGwpO2xldCBEPWEuZGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcywkPWEuZGF0YS5nZXQocy5kYXRhSWQpLnZhbHVlcztmb3IobGV0IFM9MDtTPHA7KytTKXtsZXQgTT1zLnNoYXBlWzBdPT09MT8kOiQuc3ViYXJyYXkoUyo4LFMqOCs4KTtmb3IobGV0IEI9MDtCPG07KytCKWZvcihsZXQgVT0wO1U8ZjsrK1UpZm9yKGxldCBIPTA7SDxoOysrSCl7bGV0IHEsSz1NWzZdKlUrTVs3XSpCKzE7aWYoSz09PTApY29udGludWU7bGV0IFo9KE1bMF0qVStNWzFdKkIrTVsyXSkvSyxKPShNWzNdKlUrTVs0XSpCK01bNV0pL0ssZWU9dFMoWixjLG8pLGFlPXRTKEosZCxvKTtzd2l0Y2goaSl7Y2FzZVwibmVhcmVzdFwiOnE9UkooRCxkLGMseSx4LHYsUyxhZSxlZSxILGwpO2JyZWFrO2Nhc2VcImJpbGluZWFyXCI6cT1NSihELGQsYyx5LHgsdixTLGFlLGVlLEgsbCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIFRyYW5zZm9ybTogRXhwZWN0ICduZWFyZXN0JyBvciAnYmlsaW5lYXInLCBidXQgZ290ICR7aX1gKX1sZXQgdGU9UypOK0IqQytVKl8rSDtGW3RlXT1xfXJldHVybiBhLm1ha2VUZW5zb3JJbmZvKGcsci5kdHlwZSxGKX1yZXR1cm57ZGF0YUlkOmEud3JpdGUoRixnLHIuZHR5cGUpLHNoYXBlOnIuc2hhcGUsZHR5cGU6ci5kdHlwZX19dmFyIF9KPXtrZXJuZWxOYW1lOkt1LGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpFSn07ZnVuY3Rpb24gdFMoZSx0LG4pe3N3aXRjaChuKXtjYXNlXCJyZWZsZWN0XCI6cmV0dXJuIEFKKGUsdCk7Y2FzZVwid3JhcFwiOnJldHVybiBGSihlLHQpO2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm4gREooZSx0KTtjYXNlXCJjb25zdGFudFwiOmRlZmF1bHQ6cmV0dXJuICRKKGUsdCl9fWZ1bmN0aW9uIEFKKGUsdCl7bGV0IG49ZTtpZihuPDApaWYodDw9MSluPTA7ZWxzZXtsZXQgYT0yKnQ7bjxhJiYobj1hKk1hdGgudHJ1bmMoLW4vYSkrbiksbj1uPC10P24rYTotbi0xfWVsc2UgaWYobj50LTEpaWYodDw9MSluPTA7ZWxzZXtsZXQgYT0yKnQ7bi09YSpNYXRoLnRydW5jKG4vYSksbj49dCYmKG49YS1uLTEpfXJldHVybiB3LmNsYW1wKDAsbix0LTEpfWZ1bmN0aW9uIEZKKGUsdCl7bGV0IG49ZTtpZihuPDApaWYodDw9MSluPTA7ZWxzZXtsZXQgYT10LTE7bis9dCooTWF0aC50cnVuYygtbi9hKSsxKX1lbHNlIGlmKG4+dC0xKWlmKHQ8PTEpbj0wO2Vsc2V7bGV0IGE9dC0xO24tPXQqTWF0aC50cnVuYyhuL2EpfXJldHVybiB3LmNsYW1wKDAsbix0LTEpfWZ1bmN0aW9uICRKKGUsdCl7cmV0dXJuIGV9ZnVuY3Rpb24gREooZSx0KXtyZXR1cm4gdy5jbGFtcCgwLGUsdC0xKX1mdW5jdGlvbiBhYyhlLHQsbixhLHIscyxpLG8sbCx1LHApe2xldCBkPWkqYStvKnIrbCpzK3U7cmV0dXJuIDA8PW8mJm88dCYmMDw9bCYmbDxuP2VbZF06cH1mdW5jdGlvbiBSSihlLHQsbixhLHIscyxpLG8sbCx1LHApe2xldCBkPU1hdGgucm91bmQobyksYz1NYXRoLnJvdW5kKGwpO3JldHVybiBhYyhlLHQsbixhLHIscyxpLGQsYyx1LHApfWZ1bmN0aW9uIE1KKGUsdCxuLGEscixzLGksbyxsLHUscCl7bGV0IGQ9TWF0aC5mbG9vcihvKSxjPU1hdGguZmxvb3IobCksaD1kKzEsbT1jKzEsZj0obS1sKSphYyhlLHQsbixhLHIscyxpLGQsYyx1LHApKyhsLWMpKmFjKGUsdCxuLGEscixzLGksZCxtLHUscCksZz0obS1sKSphYyhlLHQsbixhLHIscyxpLGgsYyx1LHApKyhsLWMpKmFjKGUsdCxuLGEscixzLGksaCxtLHUscCk7cmV0dXJuKGgtbykqZisoby1kKSpnfWZ1bmN0aW9uIE9KKGUpe2xldHtpbnB1dHM6dCxhdHRyczpuLGJhY2tlbmQ6YX09ZSx7YXhpczpyfT1uLHt4OnN9PXQ7Z2UocyxcInVuaXF1ZVwiKTtsZXQgaT1hLmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMse291dHB1dFZhbHVlczpvLG91dHB1dFNoYXBlOmwsaW5kaWNlczp1fT1xMShpLHIscy5zaGFwZSxzLmR0eXBlKTtyZXR1cm5bYS5tYWtlVGVuc29ySW5mbyhsLHMuZHR5cGUsbyksYS5tYWtlVGVuc29ySW5mbyhbdS5sZW5ndGhdLFwiaW50MzJcIix1KV19dmFyIFBKPXtrZXJuZWxOYW1lOkpjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpPSn07ZnVuY3Rpb24gTEooZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt2YWx1ZTpyfT10LHtheGlzOnN9PWE7czwwJiYocys9ci5zaGFwZS5sZW5ndGgpO2xldCBpPXIuc2hhcGUubGVuZ3RoLG89ci5zaGFwZVtzXSxsPW5ldyBBcnJheShpLTEpLHU9MDtmb3IobGV0IGg9MDtoPGk7aCsrKWghPT1zJiYobFt1KytdPXIuc2hhcGVbaF0pO2xldCBwPW5ldyBBcnJheShpKS5maWxsKDApLGQ9ci5zaGFwZS5zbGljZSgpO2Rbc109MTtsZXQgYz1uZXcgQXJyYXkobyk7Zm9yKGxldCBoPTA7aDxjLmxlbmd0aDtoKyspe3Bbc109aDtsZXQgbT14aSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46cCxzaXplOmR9fSk7Y1toXT14dCh7aW5wdXRzOnt4Om19LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bH19KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pfXJldHVybiBjfXZhciB6Sj17a2VybmVsTmFtZTpYdSxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6TEp9O2Z1bmN0aW9uIFdKKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLHNlZ21lbnRJZHM6c309dCx7bnVtU2VnbWVudHM6aX09YTtnZShyLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIpO2xldCBvPXIuc2hhcGUubGVuZ3RoLGw9cy5zaGFwZS5sZW5ndGgsdT1bXSxwPVtdLGQ9by1sLGM9cztmb3IobGV0IG09MDttPGQ7KyttKXtsZXQgZj1jbSh7aW5wdXRzOntpbnB1dDpjfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTptKzF9fSk7Yz1mLHAucHVzaChmKX1mb3IobGV0IG09MDttPGk7KyttKXtsZXQgZj13LmNyZWF0ZVNjYWxhclZhbHVlKG0sXCJpbnQzMlwiKSxnPW4ubWFrZVRlbnNvckluZm8oW10sXCJpbnQzMlwiLGYpLGI9T0Uoe2lucHV0czp7YTpnLGI6Y30sYmFja2VuZDpufSkseT1icyh7aW5wdXRzOnt4OmJ9LGJhY2tlbmQ6bixhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSkseD16Zih7aW5wdXRzOnthOnksYjpyfSxiYWNrZW5kOm59KSx2PUVkKHtpbnB1dHM6e3h9LGJhY2tlbmQ6bixhdHRyczp7YXhpczowLGtlZXBEaW1zOiExfX0pO3UucHVzaCh2KSxwLnB1c2goZykscC5wdXNoKGIpLHAucHVzaCh5KSxwLnB1c2goeCkscC5wdXNoKHYpfWxldCBoPUFfKHtpbnB1dHM6dSxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6MH19KTtyZXR1cm4gcC5mb3JFYWNoKG09Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSkpLGh9dmFyIEJKPXtrZXJuZWxOYW1lOlFjLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpXSn0sVko9W01LLG04LFBLLHpLLHY4LEJLLFVLLEhLLHFLLFhLLFpLLFFLLHRYLHJYLGlYLHVYLGNYLGhYLGZYLERLLGJYLHhYLHdYLGs4LElYLHk4LFM4LE5YLGY4LENYLF9YLEFYLCRYLFJYLE9YLExYLFdYLFZYLEdYLGpYLEtYLFlYLEpYLGVZLHRZLGFZLHNZLG9ZLGxZLHVZLHBZLGRZLGZZLFRLLGJZLE44LE5ZLFQ4LFRZLEU4LCRZLERZLE1ZLEE4LCQ4LFBZLHpZLEJZLFVZLFI4LE84LGc4LEhZLEVYLHFZLFhZLFpZLENLLEw4LFc4LFFZLFY4LHQ3LHI3LGk3LHU3LGM3LGg3LG03LEc4LGc3LHk3LHY3LGs3LFM3LFQ3LEU3LGo4LEE3LEQ3LFA3LEs4LFk4LFc3LFU3LGo3LEo4LEs3LFk3LFo3LEZfLHRaLF9LLHRLLGFaLHNaLG9aLHVaLGI4LGx2LGNaLEFLLEZLLCRLLGhaLGZaLGJaLHhaLHdaLGtaLFNaLHBLLFRaLEZaLERaLFBaLGRLLHpaLEJaLFVaLGhLLE03LGpaLEtaLFlaLEpaLGVKLG5KLHJKLGlKLGdLLG9KLHlLLHZLLHVKLGNKLGhKLGZKLGJKLFNLLGhZLHhKLHdKLElKLE5KLENKLF9KLFE4LFBKLHpKLEJKLFg3XTtmb3IobGV0IGUgb2YgVkopZWQoZSk7dmFyICRfPXt9O19lKCRfLHthc3NlcnROb3RDb21wbGV4OigpPT5scCxiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjooKT0+UUosYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXI6KCk9PlBoLGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI6KCk9PktfLGJpbmRUZXh0dXJlVW5pdDooKT0+SF8sYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTooKT0+cHYsY2FsbEFuZENoZWNrOigpPT5kZSxjYW5CZVJlcHJlc2VudGVkOigpPT5SXyxjcmVhdGVGcmFnbWVudFNoYWRlcjooKT0+UF8sY3JlYXRlRnJhbWVidWZmZXI6KCk9PkdfLGNyZWF0ZVByb2dyYW06KCk9PkxfLGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyOigpPT5CXyxjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXI6KCk9PldfLGNyZWF0ZVRleHR1cmU6KCk9PlZfLGNyZWF0ZVZlcnRleFNoYWRlcjooKT0+T18sZ2V0QmF0Y2hEaW06KCk9PnZpLGdldEV4dGVuc2lvbk9yVGhyb3c6KCk9PnJjLGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlOigpPT5YXyxnZXRNYXhUZXh0dXJlc0luU2hhZGVyOigpPT5RXyxnZXROdW1DaGFubmVsczooKT0+WkosZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbjooKT0+cV8sZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c6KCk9PmpfLGdldFJvd3NDb2xzOigpPT53aSxnZXRTaGFwZUFzM0Q6KCk9PmljLGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGU6KCk9PlpfLGdldFdlYkdMRGlzam9pbnRRdWVyeVRpbWVyVmVyc2lvbjooKT0+ZUEsZ2V0V2ViR0xFcnJvck1lc3NhZ2U6KCk9Pk1fLGdldFdlYkdMTWF4VGV4dHVyZVNpemU6KCk9PkpfLGhhc0V4dGVuc2lvbjooKT0+ZGEsaXNDYXBhYmxlT2ZSZW5kZXJpbmdUb0Zsb2F0VGV4dHVyZTooKT0+dEEsaXNEb3dubG9hZEZsb2F0VGV4dHVyZUVuYWJsZWQ6KCk9Pm5BLGlzUmVzaGFwZUZyZWU6KCk9PlRjLGlzV2ViR0xGZW5jZUVuYWJsZWQ6KCk9PmFBLGlzV2ViR0xWZXJzaW9uRW5hYmxlZDooKT0+ZHYsbGlua1Byb2dyYW06KCk9PnpfLGxvZ1NoYWRlclNvdXJjZUFuZEluZm9Mb2c6KCk9PkoxLHJlc2V0TWF4VGV4dHVyZVNpemU6KCk9PmU5LHJlc2V0TWF4VGV4dHVyZXNJblNoYWRlcjooKT0+dDksdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyOigpPT5jdix1bmJpbmRUZXh0dXJlVW5pdDooKT0+SkosdmFsaWRhdGVGcmFtZWJ1ZmZlcjooKT0+c2MsdmFsaWRhdGVQcm9ncmFtOigpPT5PaCx2YWxpZGF0ZVRleHR1cmVTaXplOigpPT5VX30pO3ZhciBlaT17fSxfaD17YWxwaGE6ITEsYW50aWFsaWFzOiExLHByZW11bHRpcGxpZWRBbHBoYTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsZGVwdGg6ITEsc3RlbmNpbDohMSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiEwfTtmdW5jdGlvbiBEXyhlLHQpe2VpW2VdPXR9ZnVuY3Rpb24gamEoZSx0KXtpZighKGUgaW4gZWkpfHx0IT1udWxsKXtsZXQgYT1HSihlLHQpO2lmKGEhPT1udWxsKWVpW2VdPWE7ZWxzZSByZXR1cm4gY29uc29sZS5sb2coXCJDb3VsZCBub3QgZ2V0IGNvbnRleHQgZm9yIFdlYkdMIHZlcnNpb25cIixlKSxudWxsfWxldCBuPWVpW2VdO3JldHVybiBuPT1udWxsfHxuLmlzQ29udGV4dExvc3QoKT8oZGVsZXRlIGVpW2VdLGphKGUpKToobi5kaXNhYmxlKG4uREVQVEhfVEVTVCksbi5kaXNhYmxlKG4uU1RFTkNJTF9URVNUKSxuLmRpc2FibGUobi5CTEVORCksbi5kaXNhYmxlKG4uRElUSEVSKSxuLmRpc2FibGUobi5QT0xZR09OX09GRlNFVF9GSUxMKSxuLmRpc2FibGUobi5TQU1QTEVfQ09WRVJBR0UpLG4uZW5hYmxlKG4uU0NJU1NPUl9URVNUKSxuLmVuYWJsZShuLkNVTExfRkFDRSksbi5jdWxsRmFjZShuLkJBQ0spLGVpW2VdKX1mdW5jdGlvbiBVSihlKXtpZighRygpLmdldEJvb2woXCJJU19TQUZBUklcIikmJnR5cGVvZiBPZmZzY3JlZW5DYW52YXMhPVwidW5kZWZpbmVkXCImJmU9PT0yKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDMwMCwxNTApO2lmKHR5cGVvZiBkb2N1bWVudCE9XCJ1bmRlZmluZWRcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEgY2FudmFzIGluIHRoaXMgY29udGV4dFwiKX1mdW5jdGlvbiBHSihlLHQpe2lmKGUhPT0xJiZlIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC5cIik7bGV0IG49dD09bnVsbD9VSihlKTp0O3JldHVybiBuLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsYT0+e2EucHJldmVudERlZmF1bHQoKSxkZWxldGUgZWlbZV19LCExKSxHKCkuZ2V0Qm9vbChcIlNPRlRXQVJFX1dFQkdMX0VOQUJMRURcIikmJihfaC5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0PSExKSxlPT09MT9uLmdldENvbnRleHQoXCJ3ZWJnbFwiLF9oKXx8bi5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsX2gpOm4uZ2V0Q29udGV4dChcIndlYmdsMlwiLF9oKX12YXIgTmM7KGZ1bmN0aW9uKGUpe2VbZS5ERU5TRT0wXT1cIkRFTlNFXCIsZVtlLlNIQVJFRF9CQVRDSD0xXT1cIlNIQVJFRF9CQVRDSFwifSkoTmN8fChOYz17fSkpO3ZhciBjYTsoZnVuY3Rpb24oZSl7ZVtlLlJFTkRFUj0wXT1cIlJFTkRFUlwiLGVbZS5VUExPQUQ9MV09XCJVUExPQURcIixlW2UuUElYRUxTPTJdPVwiUElYRUxTXCIsZVtlLkRPV05MT0FEPTNdPVwiRE9XTkxPQURcIn0pKGNhfHwoY2E9e30pKTt2YXIgY247KGZ1bmN0aW9uKGUpe2VbZS5VTlBBQ0tFRF9GTE9BVDE2PTBdPVwiVU5QQUNLRURfRkxPQVQxNlwiLGVbZS5VTlBBQ0tFRF9GTE9BVDMyPTFdPVwiVU5QQUNLRURfRkxPQVQzMlwiLGVbZS5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEU9Ml09XCJQQUNLRURfNFgxX1VOU0lHTkVEX0JZVEVcIixlW2UuUEFDS0VEXzJYMl9GTE9BVDMyPTNdPVwiUEFDS0VEXzJYMl9GTE9BVDMyXCIsZVtlLlBBQ0tFRF8yWDJfRkxPQVQxNj00XT1cIlBBQ0tFRF8yWDJfRkxPQVQxNlwifSkoY258fChjbj17fSkpO2Z1bmN0aW9uIF9kKGUsdCl7cmV0dXJuW3QsZV19ZnVuY3Rpb24gSEooZSx0KXtyZXR1cm4gZSp0fWZ1bmN0aW9uIEFoKGUpe2xldCB0PXcuc2l6ZUZyb21TaGFwZShlKSxuPU1hdGguY2VpbCh0LzQpO3JldHVybiB3LnNpemVUb1NxdWFyaXNoU2hhcGUobil9ZnVuY3Rpb24gb3AoZSx0KXtyZXR1cm5bTWF0aC5tYXgoMSxNYXRoLmNlaWwodC8yKSksTWF0aC5tYXgoMSxNYXRoLmNlaWwoZS8yKSldfWZ1bmN0aW9uIGpKKGUsdCl7bGV0W24sYV09b3AoZSx0KTtyZXR1cm4gbiphKjR9ZnVuY3Rpb24gWjEoZSx0KXtsZXQgbj1lLGEscixzLGksbyxsLHUscCxkLGM7cmV0dXJuIEcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mj8oYT1uLlIzMkYscj1uLlIxNkYscz1uLlJHQkExNkYsaT1uLlJHQkEzMkYsbz1uLlJFRCx1PTQscD0xLGQ9bi5IQUxGX0ZMT0FULGM9bi5GTE9BVCxsPW4uUkdCQTgpOihhPWUuUkdCQSxyPWUuUkdCQSxzPWUuUkdCQSxpPW4uUkdCQSxvPWUuUkdCQSx1PTQscD00LGQ9dCE9bnVsbD90LkhBTEZfRkxPQVRfT0VTOm51bGwsYz1lLkZMT0FULGw9ZS5SR0JBKSx7aW50ZXJuYWxGb3JtYXRGbG9hdDphLGludGVybmFsRm9ybWF0SGFsZkZsb2F0OnIsaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQ6cyxpbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0OmksdGV4dHVyZUZvcm1hdEZsb2F0Om8sZG93bmxvYWRUZXh0dXJlRm9ybWF0OmwsZG93bmxvYWRVbnBhY2tOdW1DaGFubmVsczp1LGRlZmF1bHROdW1DaGFubmVsczpwLHRleHR1cmVUeXBlSGFsZkZsb2F0OmQsdGV4dHVyZVR5cGVGbG9hdDpjfX1mdW5jdGlvbiBkZShlLHQpe2xldCBuPXQoKTtyZXR1cm4gRygpLmdldEJvb2woXCJERUJVR1wiKSYmcUooZSksbn1mdW5jdGlvbiBxSihlKXtsZXQgdD1lLmdldEVycm9yKCk7aWYodCE9PWUuTk9fRVJST1IpdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgRXJyb3I6IFwiK01fKGUsdCkpfXZhciBLSj01OTZlLTEwLFhKPTY1NTA0O2Z1bmN0aW9uIFJfKGUpe3JldHVybiEhKEcoKS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKXx8ZT09PTB8fEtKPE1hdGguYWJzKGUpJiZNYXRoLmFicyhlKTxYSil9ZnVuY3Rpb24gTV8oZSx0KXtzd2l0Y2godCl7Y2FzZSBlLk5PX0VSUk9SOnJldHVyblwiTk9fRVJST1JcIjtjYXNlIGUuSU5WQUxJRF9FTlVNOnJldHVyblwiSU5WQUxJRF9FTlVNXCI7Y2FzZSBlLklOVkFMSURfVkFMVUU6cmV0dXJuXCJJTlZBTElEX1ZBTFVFXCI7Y2FzZSBlLklOVkFMSURfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9PUEVSQVRJT05cIjtjYXNlIGUuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046cmV0dXJuXCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTlwiO2Nhc2UgZS5PVVRfT0ZfTUVNT1JZOnJldHVyblwiT1VUX09GX01FTU9SWVwiO2Nhc2UgZS5DT05URVhUX0xPU1RfV0VCR0w6cmV0dXJuXCJDT05URVhUX0xPU1RfV0VCR0xcIjtkZWZhdWx0OnJldHVybmBVbmtub3duIGVycm9yIGNvZGUgJHt0fWB9fWZ1bmN0aW9uIHJjKGUsdCl7cmV0dXJuIE9yKGUsKCk9PmUuZ2V0RXh0ZW5zaW9uKHQpLCdFeHRlbnNpb24gXCInK3QrJ1wiIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpfWZ1bmN0aW9uIE9fKGUsdCl7bGV0IG49T3IoZSwoKT0+ZS5jcmVhdGVTaGFkZXIoZS5WRVJURVhfU0hBREVSKSxcIlVuYWJsZSB0byBjcmVhdGUgdmVydGV4IFdlYkdMU2hhZGVyLlwiKTtpZihkZShlLCgpPT5lLnNoYWRlclNvdXJjZShuLHQpKSxkZShlLCgpPT5lLmNvbXBpbGVTaGFkZXIobikpLGUuZ2V0U2hhZGVyUGFyYW1ldGVyKG4sZS5DT01QSUxFX1NUQVRVUyk9PT0hMSl0aHJvdyBjb25zb2xlLmxvZyhlLmdldFNoYWRlckluZm9Mb2cobikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuXCIpO3JldHVybiBufWZ1bmN0aW9uIFBfKGUsdCl7bGV0IG49T3IoZSwoKT0+ZS5jcmVhdGVTaGFkZXIoZS5GUkFHTUVOVF9TSEFERVIpLFwiVW5hYmxlIHRvIGNyZWF0ZSBmcmFnbWVudCBXZWJHTFNoYWRlci5cIik7aWYoZGUoZSwoKT0+ZS5zaGFkZXJTb3VyY2Uobix0KSksZGUoZSwoKT0+ZS5jb21waWxlU2hhZGVyKG4pKSxHKCkuZ2V0KFwiRU5HSU5FX0NPTVBJTEVfT05MWVwiKSlyZXR1cm4gbjtpZihlLmdldFNoYWRlclBhcmFtZXRlcihuLGUuQ09NUElMRV9TVEFUVVMpPT09ITEpdGhyb3cgSjEodCxlLmdldFNoYWRlckluZm9Mb2cobikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci5cIik7cmV0dXJuIG59dmFyIFlKPS9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO2Z1bmN0aW9uIEoxKGUsdCl7bGV0IG49WUouZXhlYyh0KTtpZihuPT1udWxsKXtjb25zb2xlLmxvZyhgQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6ICR7dH1gKSxjb25zb2xlLmxvZyhlKTtyZXR1cm59bGV0IGE9K25bMV0scj1lLnNwbGl0KGBcbmApLHM9ci5sZW5ndGgudG9TdHJpbmcoKS5sZW5ndGgrMixpPXIubWFwKChkLGMpPT53LnJpZ2h0UGFkKChjKzEpLnRvU3RyaW5nKCkscykrZCksbz0wO2ZvcihsZXQgZD0wO2Q8aS5sZW5ndGg7ZCsrKW89TWF0aC5tYXgoaVtkXS5sZW5ndGgsbyk7bGV0IGw9aS5zbGljZSgwLGEtMSksdT1pLnNsaWNlKGEtMSxhKSxwPWkuc2xpY2UoYSk7Y29uc29sZS5sb2cobC5qb2luKGBcbmApKSxjb25zb2xlLmxvZyh0LnNwbGl0KGBcbmApWzBdKSxjb25zb2xlLmxvZyhgJWMgJHt3LnJpZ2h0UGFkKHVbMF0sbyl9YCxcImJvcmRlcjoxcHggc29saWQgcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiNlM2QyZDI7IGNvbG9yOiNhNjE3MTdcIiksY29uc29sZS5sb2cocC5qb2luKGBcbmApKX1mdW5jdGlvbiBMXyhlKXtyZXR1cm4gT3IoZSwoKT0+ZS5jcmVhdGVQcm9ncmFtKCksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS5cIil9ZnVuY3Rpb24gel8oZSx0KXtpZihkZShlLCgpPT5lLmxpbmtQcm9ncmFtKHQpKSwhRygpLmdldChcIkVOR0lORV9DT01QSUxFX09OTFlcIikmJmUuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0LGUuTElOS19TVEFUVVMpPT09ITEpdGhyb3cgY29uc29sZS5sb2coZS5nZXRQcm9ncmFtSW5mb0xvZyh0KSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLlwiKX1mdW5jdGlvbiBPaChlLHQpe2lmKGRlKGUsKCk9PmUudmFsaWRhdGVQcm9ncmFtKHQpKSxlLmdldFByb2dyYW1QYXJhbWV0ZXIodCxlLlZBTElEQVRFX1NUQVRVUyk9PT0hMSl0aHJvdyBjb25zb2xlLmxvZyhlLmdldFByb2dyYW1JbmZvTG9nKHQpKSxuZXcgRXJyb3IoXCJTaGFkZXIgcHJvZ3JhbSB2YWxpZGF0aW9uIGZhaWxlZC5cIil9ZnVuY3Rpb24gV18oZSx0KXtsZXQgbj1PcihlLCgpPT5lLmNyZWF0ZUJ1ZmZlcigpLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gZGUoZSwoKT0+ZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG4pKSxkZShlLCgpPT5lLmJ1ZmZlckRhdGEoZS5BUlJBWV9CVUZGRVIsdCxlLlNUQVRJQ19EUkFXKSksbn1mdW5jdGlvbiBCXyhlLHQpe2xldCBuPU9yKGUsKCk9PmUuY3JlYXRlQnVmZmVyKCksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMQnVmZmVyXCIpO3JldHVybiBkZShlLCgpPT5lLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixuKSksZGUoZSwoKT0+ZS5idWZmZXJEYXRhKGUuRUxFTUVOVF9BUlJBWV9CVUZGRVIsdCxlLlNUQVRJQ19EUkFXKSksbn1mdW5jdGlvbiBaSigpe3JldHVybiBHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTI/MTo0fWZ1bmN0aW9uIFZfKGUpe3JldHVybiBPcihlLCgpPT5lLmNyZWF0ZVRleHR1cmUoKSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xUZXh0dXJlLlwiKX1mdW5jdGlvbiBVXyhlLHQpe2xldCBuPUcoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIpO2lmKGU8PTB8fHQ8PTApe2xldCBhPWBbJHtlfXgke3R9XWA7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIithK1wiIGlzIGludmFsaWQuXCIpfWlmKGU+bnx8dD5uKXtsZXQgYT1gWyR7ZX14JHt0fV1gLHI9YFske259eCR7bn1dYDt0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplIFwiK2ErXCIgZ3JlYXRlciB0aGFuIFdlYkdMIG1heGltdW0gb24gdGhpcyBicm93c2VyIC8gR1BVIFwiK3IrXCIuXCIpfX1mdW5jdGlvbiBHXyhlKXtyZXR1cm4gT3IoZSwoKT0+ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEZyYW1lYnVmZmVyLlwiKX1mdW5jdGlvbiBwdihlLHQsbixhLHIscyxpKXtsZXQgbz1lLmdldEF0dHJpYkxvY2F0aW9uKHQsbik7cmV0dXJuIG89PT0tMT8hMTooZGUoZSwoKT0+ZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLGEpKSxkZShlLCgpPT5lLnZlcnRleEF0dHJpYlBvaW50ZXIobyxyLGUuRkxPQVQsITEscyxpKSksZGUoZSwoKT0+ZS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShvKSksITApfWZ1bmN0aW9uIEhfKGUsdCxuKXtZXyhlLG4pLGRlKGUsKCk9PmUuYWN0aXZlVGV4dHVyZShlLlRFWFRVUkUwK24pKSxkZShlLCgpPT5lLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCx0KSl9ZnVuY3Rpb24gSkooZSx0KXtZXyhlLHQpLGRlKGUsKCk9PmUuYWN0aXZlVGV4dHVyZShlLlRFWFRVUkUwK3QpKSxkZShlLCgpPT5lLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSl9ZnVuY3Rpb24gal8oZSx0LG4pe3JldHVybiBPcihlLCgpPT5lLmdldFVuaWZvcm1Mb2NhdGlvbih0LG4pLCd1bmlmb3JtIFwiJytuKydcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLicpfWZ1bmN0aW9uIHFfKGUsdCxuKXtyZXR1cm4gZS5nZXRVbmlmb3JtTG9jYXRpb24odCxuKX1mdW5jdGlvbiBLXyhlLHQsbixhKXtkZShlLCgpPT5IXyhlLHQsYSkpLGRlKGUsKCk9PmUudW5pZm9ybTFpKG4sYSkpfWZ1bmN0aW9uIFFKKGUpe2RlKGUsKCk9PmUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbnVsbCkpLGRlKGUsKCk9PmUudmlld3BvcnQoMCwwLGUuY2FudmFzLndpZHRoLGUuY2FudmFzLmhlaWdodCkpLGRlKGUsKCk9PmUuc2Npc3NvcigwLDAsZS5jYW52YXMud2lkdGgsZS5jYW52YXMuaGVpZ2h0KSl9ZnVuY3Rpb24gUGgoZSx0LG4pe2RlKGUsKCk9PmUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsbikpLGRlKGUsKCk9PmUuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCx0LDApKX1mdW5jdGlvbiBjdihlLHQpe2RlKGUsKCk9PmUuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsdCkpLGRlKGUsKCk9PmUuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCxudWxsLDApKX1mdW5jdGlvbiBzYyhlKXtsZXQgdD1lLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZS5GUkFNRUJVRkZFUik7aWYodCE9PWUuRlJBTUVCVUZGRVJfQ09NUExFVEUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgYmluZGluZyBmcmFtZWJ1ZmZlcjogXCIrWF8oZSx0KSl9ZnVuY3Rpb24gWF8oZSx0KXtzd2l0Y2godCl7Y2FzZSBlLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiO2Nhc2UgZS5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCI7Y2FzZSBlLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpyZXR1cm5cIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiO2Nhc2UgZS5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpyZXR1cm5cIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXCI7ZGVmYXVsdDpyZXR1cm5gdW5rbm93biBlcnJvciAke3R9YH19ZnVuY3Rpb24gT3IoZSx0LG4pe2xldCBhPWRlKGUsKCk9PnQoKSk7aWYoYT09bnVsbCl0aHJvdyBuZXcgRXJyb3Iobik7cmV0dXJuIGF9ZnVuY3Rpb24gWV8oZSx0KXtsZXQgbj1lLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTLTEsYT10K2UuVEVYVFVSRTA7aWYoYTxlLlRFWFRVUkUwfHxhPm4pe2xldCByPWBbZ2wuVEVYVFVSRTAsIGdsLlRFWFRVUkUke259XWA7dGhyb3cgbmV3IEVycm9yKGB0ZXh0dXJlVW5pdCBtdXN0IGJlIGluICR7cn0uYCl9fWZ1bmN0aW9uIHZpKGUsdD0yKXtyZXR1cm4gdy5zaXplRnJvbVNoYXBlKGUuc2xpY2UoMCxlLmxlbmd0aC10KSl9ZnVuY3Rpb24gd2koZSl7aWYoZS5sZW5ndGg9PT0wKXRocm93IEVycm9yKFwiQ2Fubm90IGdldCByb3dzIGFuZCBjb2x1bW5zIG9mIGFuIGVtcHR5IHNoYXBlIGFycmF5LlwiKTtyZXR1cm5bZS5sZW5ndGg+MT9lW2UubGVuZ3RoLTJdOjEsZVtlLmxlbmd0aC0xXV19ZnVuY3Rpb24gaWMoZSl7bGV0IHQ9WzEsMSwxXTtyZXR1cm4gZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD09PTEmJmVbMF09PT0xfHwodD1bdmkoZSksLi4ud2koZSldKSx0fWZ1bmN0aW9uIFpfKGUsdD0hMSl7bGV0IG49RygpLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIiksYT1HKCkuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1NJWkVfRk9SX05BUlJPV19URVhUVVJFXCIpO2E9PT0xLzAmJkcoKS5nZXRCb29sKFwiV0VCR0xfQVVUT19TUVVBUklGWV9OQVJST1dfVEVYVFVSRV9TSEFQRVwiKSYmKGE9bi8yKSx0JiYobj1uKjIsYT1hKjIsZT1lLm1hcCgobyxsKT0+bD49ZS5sZW5ndGgtMj93Lm5lYXJlc3RMYXJnZXJFdmVuKGVbbF0pOmVbbF0pLGUubGVuZ3RoPT09MSYmKGU9WzIsZVswXV0pKSxlLmxlbmd0aCE9PTImJihlPXcuc3F1ZWV6ZVNoYXBlKGUpLm5ld1NoYXBlKTtsZXQgcj13LnNpemVGcm9tU2hhcGUoZSkscz1udWxsO2UubGVuZ3RoPD0xJiZyPD1uP3M9WzEscl06ZS5sZW5ndGg9PT0yJiZlWzBdPD1uJiZlWzFdPD1uP3M9ZTplLmxlbmd0aD09PTMmJmVbMF0qZVsxXTw9biYmZVsyXTw9bj9zPVtlWzBdKmVbMV0sZVsyXV06ZS5sZW5ndGg9PT0zJiZlWzBdPD1uJiZlWzFdKmVbMl08PW4/cz1bZVswXSxlWzFdKmVbMl1dOmUubGVuZ3RoPT09NCYmZVswXSplWzFdKmVbMl08PW4mJmVbM108PW4/cz1bZVswXSplWzFdKmVbMl0sZVszXV06ZS5sZW5ndGg9PT00JiZlWzBdPD1uJiZlWzFdKmVbMl0qZVszXTw9biYmKHM9W2VbMF0sZVsxXSplWzJdKmVbM11dKTtsZXQgaT1zIT1udWxsJiZNYXRoLm1heCguLi5zKT5hJiZNYXRoLm1pbiguLi5zKTw9KHQ/MjoxKSYmTWF0aC5taW4oLi4ucyk+MDtpZihzPT1udWxsfHxpKWlmKHQpe2xldCBvPXZpKGUpLGw9Mix1PTI7ZS5sZW5ndGgmJihbbCx1XT13aShlKSkscj1vKihsLzIpKih1LzIpLHM9dy5zaXplVG9TcXVhcmlzaFNoYXBlKHIpLm1hcChwPT5wKjIpfWVsc2Ugcz13LnNpemVUb1NxdWFyaXNoU2hhcGUocik7cmV0dXJuIHN9ZnVuY3Rpb24gRmgoZSl7cmV0dXJuIGUlMj09PTB9ZnVuY3Rpb24gVGMoZSx0KXtpZihlPWUuc2xpY2UoLTIpLHQ9dC5zbGljZSgtMiksdy5hcnJheXNFcXVhbChlLHQpfHwhZS5sZW5ndGh8fCF0Lmxlbmd0aHx8ZVswXT09PTB8fGVbMV09PT0wfHx0WzBdPT09MHx8dFsxXT09PTApcmV0dXJuITA7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl7bGV0IG49ZVtlLmxlbmd0aC0xXSxhPXRbdC5sZW5ndGgtMV07aWYobj09PWF8fEZoKG4pJiZGaChhKSYmKGVbMF09PT0xfHx0WzBdPT09MSkpcmV0dXJuITB9cmV0dXJuIGVbMV09PT10WzFdJiZGaChlWzBdKSYmRmgodFswXSl9dmFyIExoLHpoO2Z1bmN0aW9uIEpfKGUpe2lmKExoPT1udWxsKXtsZXQgdD1qYShlKTtMaD10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX1NJWkUpfXJldHVybiBMaH1mdW5jdGlvbiBlOSgpe0xoPW51bGx9ZnVuY3Rpb24gdDkoKXt6aD1udWxsfWZ1bmN0aW9uIFFfKGUpe2lmKHpoPT1udWxsKXtsZXQgdD1qYShlKTt6aD10LmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKX1yZXR1cm4gTWF0aC5taW4oMTYsemgpfWZ1bmN0aW9uIGVBKGUpe2lmKGU9PT0wKXJldHVybiAwO2xldCB0LG49amEoZSk7cmV0dXJuIGRhKG4sXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyXCIpJiZlPT09Mj90PTI6ZGEobixcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKT90PTE6dD0wLHR9ZnVuY3Rpb24gZGEoZSx0KXtyZXR1cm4gZS5nZXRFeHRlbnNpb24odCkhPW51bGx9ZnVuY3Rpb24gZHYoZSl7dHJ5e2lmKGphKGUpIT1udWxsKXJldHVybiEwfWNhdGNoKHQpe3JldHVybiBjb25zb2xlLmxvZyhcIkVycm9yIHdoZW4gZ2V0dGluZyBXZWJHTCBjb250ZXh0OiBcIix0KSwhMX1yZXR1cm4hMX1mdW5jdGlvbiB0QShlKXtpZihlPT09MClyZXR1cm4hMTtsZXQgdD1qYShlKTtpZihlPT09MSl7aWYoIWRhKHQsXCJPRVNfdGV4dHVyZV9mbG9hdFwiKSlyZXR1cm4hMX1lbHNlIGlmKCFkYSh0LFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4hMTtyZXR1cm4gaHYodCl9ZnVuY3Rpb24gbkEoZSl7aWYoZT09PTApcmV0dXJuITE7bGV0IHQ9amEoZSk7aWYoZT09PTEpe2lmKCFkYSh0LFwiT0VTX3RleHR1cmVfZmxvYXRcIil8fCFkYSh0LFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpKXJldHVybiExfWVsc2V7aWYoZGEodCxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuIGh2KHQpO2xldCBuPVwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCI7aWYoZGEodCxuKSl7bGV0IGE9dC5nZXRFeHRlbnNpb24obik7cmV0dXJuIG45KHQsYSl9cmV0dXJuITF9cmV0dXJuIGh2KHQpfWZ1bmN0aW9uIGh2KGUpe2xldCB0PVoxKGUpLG49ZS5jcmVhdGVUZXh0dXJlKCk7ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbiksZS50ZXhJbWFnZTJEKGUuVEVYVFVSRV8yRCwwLHQuaW50ZXJuYWxGb3JtYXRGbG9hdCwxLDEsMCx0LnRleHR1cmVGb3JtYXRGbG9hdCx0LnRleHR1cmVUeXBlRmxvYXQsbnVsbCk7bGV0IGE9ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpO2UuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsYSksZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLGUuQ09MT1JfQVRUQUNITUVOVDAsZS5URVhUVVJFXzJELG4sMCk7bGV0IHI9ZS5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGUuRlJBTUVCVUZGRVIpPT09ZS5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCksZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUixudWxsKSxlLmRlbGV0ZVRleHR1cmUobiksZS5kZWxldGVGcmFtZWJ1ZmZlcihhKSxyfWZ1bmN0aW9uIG45KGUsdCl7bGV0IG49WjEoZSx0KSxhPWUuY3JlYXRlVGV4dHVyZSgpO2UuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELGEpLGUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0SGFsZkZsb2F0LDEsMSwwLG4udGV4dHVyZUZvcm1hdEZsb2F0LG4udGV4dHVyZVR5cGVIYWxmRmxvYXQsbnVsbCk7bGV0IHI9ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpO2UuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsciksZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLGUuQ09MT1JfQVRUQUNITUVOVDAsZS5URVhUVVJFXzJELGEsMCk7bGV0IHM9ZS5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGUuRlJBTUVCVUZGRVIpPT09ZS5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCksZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUixudWxsKSxlLmRlbGV0ZVRleHR1cmUoYSksZS5kZWxldGVGcmFtZWJ1ZmZlcihyKSxzfWZ1bmN0aW9uIGFBKGUpe3JldHVybiBlIT09Mj8hMTpqYShlKS5mZW5jZVN5bmMhPW51bGx9ZnVuY3Rpb24gbHAoZSx0KXtBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLGUuZm9yRWFjaChuPT57biE9bnVsbCYmdy5hc3NlcnQobi5kdHlwZSE9PVwiY29tcGxleDY0XCIsKCk9PmAke3R9IGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IHRlbnNvcnMgaW4gdGhlIFdlYkdMIGJhY2tlbmQuYCl9KX12YXIgYmU9RygpO2JlLnJlZ2lzdGVyRmxhZyhcIkhBU19XRUJHTFwiLCgpPT5iZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPjApO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1ZFUlNJT05cIiwoKT0+ZHYoMik/MjpkdigxKT8xOjApO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0NIRUNLX05VTUVSSUNBTF9QUk9CTEVNU1wiLCgpPT4hMSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiLCgpPT5iZS5nZXQoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mik7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQ1BVX0ZPUldBUkRcIiwoKT0+ITApO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiLCgpPT4hMSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS1wiLCgpPT5iZS5nZXRCb29sKFwiSEFTX1dFQkdMXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQ0xJUFwiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIsKCk9PmJlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIsKCk9PmJlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19JTUFHRV9PUEVSQVRJT05TXCIsKCk9PmJlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX1JFRFVDRVwiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQ09OVl9JTTJDT0xcIiwoKT0+YmUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQ09OVjJEVFJBTlNQT1NFXCIsKCk9PmJlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIsKCk9PkpfKGJlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIsKCk9PlFfKGJlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiLCgpPT57bGV0IGU9YmUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKTtyZXR1cm4gZT09PTA/MDplQShlKX0pO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiLCgpPT5iZS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wJiYhYWQuaXNNb2JpbGUoKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRVwiLCgpPT50QShiZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIpPyExOmJlLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFXCIpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIsKCk9Pm5BKGJlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpKTtiZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9GRU5DRV9BUElfRU5BQkxFRFwiLCgpPT5hQShiZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKSk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiLCgpPT5iZS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKT80OjApO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RFTEVURV9URVhUVVJFX1RIUkVTSE9MRFwiLCgpPT4tMSxlPT57aWYodHlwZW9mIGUhPVwibnVtYmVyXCIpdGhyb3cgbmV3IEVycm9yKGBXRUJHTF9ERUxFVEVfVEVYVFVSRV9USFJFU0hPTEQgbXVzdCBiZSBhIG51bWJlciBidXQgZ290ICR7ZX0uYCk7aWYoZTwwJiZlIT09LTEpdGhyb3cgbmV3IEVycm9yKGBXRUJHTF9ERUxFVEVfVEVYVFVSRV9USFJFU0hPTEQgbXVzdCBiZSAtMSAoaW5kaWNhdGluZyBuZXZlciBkZWxldGUpIG9yIGF0IGxlYXN0IDAsIGJ1dCBnb3QgJHtlfS5gKX0pO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0ZMVVNIX1RIUkVTSE9MRFwiLCgpPT5hZC5pc01vYmlsZSgpPzE6LTEsZT0+e2lmKHR5cGVvZiBlIT1cIm51bWJlclwiKXRocm93IG5ldyBFcnJvcihgV0VCR0xfRkxVU0hfVEhSRVNIT0xEIG11c3QgYmUgYSBudW1iZXIgYnV0IGdvdCAke2V9LmApO2lmKGU8MCYmZSE9PS0xKXRocm93IG5ldyBFcnJvcihgV0VCR0xfRkxVU0hfVEhSRVNIT0xEIG11c3QgYmUgLTEgKGluZGljYXRpbmcgbmV2ZXIgbWFudWFsIGZsdXNoKSBvciBhdCBsZWFzdCAwLCBidXQgZ290ICR7ZX0uYCl9KTtiZS5yZWdpc3RlckZsYWcoXCJDUFVfSEFORE9GRl9TSVpFX1RIUkVTSE9MRFwiLCgpPT4xMjgpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1VTRV9TSEFQRVNfVU5JRk9STVNcIiwoKT0+ITEpO2JlLnJlZ2lzdGVyRmxhZyhcIlRPUEtfTEFTVF9ESU1fQ1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTERcIiwoKT0+MWU1KTtiZS5yZWdpc3RlckZsYWcoXCJUT1BLX0tfQ1BVX0hBTkRPRkZfVEhSRVNIT0xEXCIsKCk9PjEyOCk7YmUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRVhQX0NPTlZcIiwoKT0+ITEpO2JlLnJlZ2lzdGVyRmxhZyhcIlNPRlRXQVJFX1dFQkdMX0VOQUJMRURcIiwoKT0+YmUuZ2V0Qm9vbChcIklTX1RFU1RcIikpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX01BWF9TSVpFX0ZPUl9OQVJST1dfVEVYVFVSRVwiLCgpPT4xLzApO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0FVVE9fU1FVQVJJRllfTkFSUk9XX1RFWFRVUkVfU0hBUEVcIiwoKT0+ITEpO2JlLnJlZ2lzdGVyRmxhZyhcIldFQkdMMl9JU05BTl9DVVNUT01cIiwoKT0+ITEpO2JlLnJlZ2lzdGVyRmxhZyhcIkVOR0lORV9DT01QSUxFX09OTFlcIiwoKT0+ITEpO2Z1bmN0aW9uIEVuKCl7bGV0IGUsdCxuLGEscixzLGksbyxsLHU7cmV0dXJuIEcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mj8oZT1cIiN2ZXJzaW9uIDMwMCBlc1wiLHQ9XCJpblwiLG49XCJvdXRcIixhPVwiaW5cIixyPVwidGV4dHVyZVwiLHM9XCJvdXRwdXRDb2xvclwiLGk9XCJvdXQgdmVjNCBvdXRwdXRDb2xvcjtcIixvPUcoKS5nZXRCb29sKFwiV0VCR0wyX0lTTkFOX0NVU1RPTVwiKT9gXG4gICAgICBib29sIGlzbmFuX2N1c3RvbShmbG9hdCB2YWwpIHtcbiAgICAgICAgdWludCBmbG9hdFRvVWludCA9IGZsb2F0Qml0c1RvVWludCh2YWwpO1xuICAgICAgICByZXR1cm4gKGZsb2F0VG9VaW50ICYgMHg3ZmZmZmZmZnUpID4gMHg3ZjgwMDAwMHU7XG4gICAgICB9XG5cbiAgICAgIGJ2ZWM0IGlzbmFuX2N1c3RvbSh2ZWM0IHZhbCkge1xuICAgICAgICByZXR1cm4gYnZlYzQoaXNuYW5fY3VzdG9tKHZhbC54KSxcbiAgICAgICAgICBpc25hbl9jdXN0b20odmFsLnkpLCBpc25hbl9jdXN0b20odmFsLnopLCBpc25hbl9jdXN0b20odmFsLncpKTtcbiAgICAgIH1cblxuICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxuICAgIGA6XCJcIixsPVwiXCIsdT1gXG4gICAgICAjZGVmaW5lIHJvdW5kKHZhbHVlKSBuZXdSb3VuZCh2YWx1ZSlcbiAgICAgIGludCBuZXdSb3VuZChmbG9hdCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XG4gICAgICB9XG5cbiAgICAgIGl2ZWM0IG5ld1JvdW5kKHZlYzQgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XG4gICAgICB9XG4gICAgYCk6KGU9XCJcIix0PVwiYXR0cmlidXRlXCIsbj1cInZhcnlpbmdcIixhPVwidmFyeWluZ1wiLHI9XCJ0ZXh0dXJlMkRcIixzPVwiZ2xfRnJhZ0NvbG9yXCIsaT1cIlwiLG89YFxuICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxuICAgICAgYm9vbCBpc25hbl9jdXN0b20oZmxvYXQgdmFsKSB7XG4gICAgICAgIHJldHVybiAodmFsID4gMC4gfHwgdmFsIDwgMS4gfHwgdmFsID09IDAuKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJ2ZWM0IGlzbmFuX2N1c3RvbSh2ZWM0IHZhbCkge1xuICAgICAgICByZXR1cm4gYnZlYzQoaXNuYW4odmFsLngpLCBpc25hbih2YWwueSksIGlzbmFuKHZhbC56KSwgaXNuYW4odmFsLncpKTtcbiAgICAgIH1cbiAgICBgLGw9YFxuICAgICAgdW5pZm9ybSBmbG9hdCBJTkZJTklUWTtcblxuICAgICAgYm9vbCBpc2luZihmbG9hdCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGFicyh2YWwpID09IElORklOSVRZO1xuICAgICAgfVxuICAgICAgYnZlYzQgaXNpbmYodmVjNCB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGVxdWFsKGFicyh2YWwpLCB2ZWM0KElORklOSVRZKSk7XG4gICAgICB9XG4gICAgYCx1PWBcbiAgICAgIGludCByb3VuZChmbG9hdCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XG4gICAgICB9XG5cbiAgICAgIGl2ZWM0IHJvdW5kKHZlYzQgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGl2ZWM0KGZsb29yKHZhbHVlICsgdmVjNCgwLjUpKSk7XG4gICAgICB9XG4gICAgYCkse3ZlcnNpb246ZSxhdHRyaWJ1dGU6dCx2YXJ5aW5nVnM6bix2YXJ5aW5nRnM6YSx0ZXh0dXJlMkQ6cixvdXRwdXQ6cyxkZWZpbmVPdXRwdXQ6aSxkZWZpbmVTcGVjaWFsTmFOOm8sZGVmaW5lU3BlY2lhbEluZjpsLGRlZmluZVJvdW5kOnV9fWZ1bmN0aW9uIFpvKGUsdCxuPVwiaW5kZXhcIil7bGV0IGE9dy5jb21wdXRlU3RyaWRlcyh0KTtyZXR1cm4gYS5tYXAoKHIscyk9PntsZXQgaT1gaW50ICR7ZVtzXX0gPSAke259IC8gJHtyfWAsbz1zPT09YS5sZW5ndGgtMT9gaW50ICR7ZVtzKzFdfSA9ICR7bn0gLSAke2Vbc119ICogJHtyfWA6YGluZGV4IC09ICR7ZVtzXX0gKiAke3J9YDtyZXR1cm5gJHtpfTsgJHtvfTtgfSkuam9pbihcIlwiKX1mdW5jdGlvbiBXZihlLHQsbj1cImluZGV4XCIpe2xldCBhPXcuY29tcHV0ZVN0cmlkZXModCk7cmV0dXJuIGEubWFwKChyLHMpPT57bGV0IGk9YGludCAke2Vbc119ID0gJHtufSAvIG91dFNoYXBlU3RyaWRlc1ske3N9XWAsbz1zPT09YS5sZW5ndGgtMT9gaW50ICR7ZVtzKzFdfSA9ICR7bn0gLSAke2Vbc119ICogb3V0U2hhcGVTdHJpZGVzWyR7c31dYDpgaW5kZXggLT0gJHtlW3NdfSAqIG91dFNoYXBlU3RyaWRlc1ske3N9XWA7cmV0dXJuYCR7aX07ICR7b307YH0pLmpvaW4oXCJcIil9ZnVuY3Rpb24gYTkoZSx0KXtsZXQgbj1lLmxlbmd0aCxhPWUubWFwKHM9PmAke3R9WyR7c31dYCkscj1uZXcgQXJyYXkobi0xKTtyW24tMl09YVtuLTFdO2ZvcihsZXQgcz1uLTM7cz49MDstLXMpcltzXT1gKCR7cltzKzFdfSAqICR7YVtzKzFdfSlgO3JldHVybiByfWZ1bmN0aW9uIHI5KGUsdCxuPVwiaW5kZXhcIil7bGV0IGE9ZS5tYXAoKHMsaSk9PmkpLHI9YTkoYSx0KTtyZXR1cm4gci5tYXAoKHMsaSk9PntsZXQgbz1gaW50ICR7ZVtpXX0gPSAke259IC8gJHtyW2ldfWAsbD1pPT09ci5sZW5ndGgtMT9gaW50ICR7ZVtpKzFdfSA9ICR7bn0gLSAke2VbaV19ICogJHtyW2ldfWA6YGluZGV4IC09ICR7ZVtpXX0gKiAke3JbaV19YDtyZXR1cm5gJHtvfTsgJHtsfTtgfSkuam9pbihcIlwiKX1mdW5jdGlvbiBRMShlKXtsZXQgdD13LmNvbXB1dGVTdHJpZGVzKGUpLm1hcChuPT5uLnRvU3RyaW5nKCkpO3JldHVybmBcbiAgaW50IGdldEZsYXRJbmRleChpdmVjMyBjb29yZHMpIHtcbiAgICByZXR1cm4gY29vcmRzLnggKiAke3RbMF19ICsgY29vcmRzLnkgKiAke3RbMV19ICsgY29vcmRzLno7XG4gIH1cbmB9ZnVuY3Rpb24gZWsoKXtyZXR1cm5gXG4gIGludCBnZXRGbGF0SW5kZXgoaXZlYzMgY29vcmRzKSB7XG4gICAgcmV0dXJuIGNvb3Jkcy54ICogb3V0U2hhcGVTdHJpZGVzWzBdICsgY29vcmRzLnkgKiBvdXRTaGFwZVN0cmlkZXNbMV0gKyBjb29yZHMuejtcbiAgfVxuYH12YXIgckE9YFxuICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xuICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcblxuICBsb3dwIHZlYzQgZW5jb2RlX2Zsb2F0KGhpZ2hwIGZsb2F0IHYpIHtcbiAgICBpZiAoaXNuYW4odikpIHtcbiAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XG4gICAgfVxuXG4gICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XG5cbiAgICBpZihhdiA8IEZMT0FUX01JTikge1xuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcbiAgICB9IGVsc2UgaWYodiA8IC1GTE9BVF9NQVgpIHtcbiAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xuICAgIH1cblxuICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XG5cbiAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xuICAgIGhpZ2hwIGZsb2F0IG0gPSBleHAyKGZyYWN0KGxvZzIoYXYpKSkgLSAxLjA7XG5cbiAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcbiAgICBtIC09IGNbMl0gLyAxMjguMDtcbiAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xuICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XG4gICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xuXG4gICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XG4gICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcbiAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xuICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XG5cbiAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcblxuICAgIHJldHVybiBjIC8gMjU1LjA7XG4gIH1cbmAse2dldEJyb2FkY2FzdERpbXM6c0F9PVQ7ZnVuY3Rpb24gczkoZSx0LG4pe2xldCBhPVtdO2lmKGUuZm9yRWFjaChjPT57bGV0IGg9dy5zaXplRnJvbVNoYXBlKGMuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7aWYoYy5zaGFwZUluZm8uaXNVbmlmb3JtP2EucHVzaChgdW5pZm9ybSBmbG9hdCAke2MubmFtZX0ke2g+MT9gWyR7aH1dYDpcIlwifTtgKTooYS5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke2MubmFtZX07YCksYS5wdXNoKGB1bmlmb3JtIGludCBvZmZzZXQke2MubmFtZX07YCkpLG4uZW5hYmxlU2hhcGVVbmlmb3Jtcyl7bGV0e3VuaWZvcm1TaGFwZTptfT10ayhuLnBhY2tlZElucHV0cyxjLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsYy5zaGFwZUluZm8udGV4U2hhcGUpO3N3aXRjaChtLmxlbmd0aCl7Y2FzZSAxOmEucHVzaChgdW5pZm9ybSBpbnQgJHtjLm5hbWV9U2hhcGU7YCk7YnJlYWs7Y2FzZSAyOmEucHVzaChgdW5pZm9ybSBpdmVjMiAke2MubmFtZX1TaGFwZTtgKTticmVhaztjYXNlIDM6YS5wdXNoKGB1bmlmb3JtIGl2ZWMzICR7Yy5uYW1lfVNoYXBlO2ApO2JyZWFrO2Nhc2UgNDphLnB1c2goYHVuaWZvcm0gaXZlYzQgJHtjLm5hbWV9U2hhcGU7YCk7YnJlYWs7ZGVmYXVsdDpicmVha31hLnB1c2goYHVuaWZvcm0gaXZlYzIgJHtjLm5hbWV9VGV4U2hhcGU7YCl9fSksbi5lbmFibGVTaGFwZVVuaWZvcm1zKXtzd2l0Y2godC5sb2dpY2FsU2hhcGUubGVuZ3RoKXtjYXNlIDE6YS5wdXNoKFwidW5pZm9ybSBpbnQgb3V0U2hhcGU7XCIpO2JyZWFrO2Nhc2UgMjphLnB1c2goXCJ1bmlmb3JtIGl2ZWMyIG91dFNoYXBlO1wiKSxhLnB1c2goXCJ1bmlmb3JtIGludCBvdXRTaGFwZVN0cmlkZXM7XCIpO2JyZWFrO2Nhc2UgMzphLnB1c2goXCJ1bmlmb3JtIGl2ZWMzIG91dFNoYXBlO1wiKSxhLnB1c2goXCJ1bmlmb3JtIGl2ZWMyIG91dFNoYXBlU3RyaWRlcztcIik7YnJlYWs7Y2FzZSA0OmEucHVzaChcInVuaWZvcm0gaXZlYzQgb3V0U2hhcGU7XCIpLGEucHVzaChcInVuaWZvcm0gaXZlYzMgb3V0U2hhcGVTdHJpZGVzO1wiKTticmVhaztkZWZhdWx0OmJyZWFrfWEucHVzaChcInVuaWZvcm0gaXZlYzIgb3V0VGV4U2hhcGU7XCIpfW4uY3VzdG9tVW5pZm9ybXMmJm4uY3VzdG9tVW5pZm9ybXMuZm9yRWFjaChjPT57YS5wdXNoKGB1bmlmb3JtICR7Yy50eXBlfSAke2MubmFtZX0ke2MuYXJyYXlJbmRleD9gWyR7Yy5hcnJheUluZGV4fV1gOlwiXCJ9O2ApfSk7bGV0IHI9YS5qb2luKGBcbmApLHM9ZS5tYXAoYz0+aTkoYyx0LG4ucGFja2VkSW5wdXRzLG4uZW5hYmxlU2hhcGVVbmlmb3JtcykpLmpvaW4oYFxuYCksaT10LnRleFNoYXBlLG89RW4oKSxsPXU5KG8pLHUscCxkPWQ5KG8pO3JldHVybiB0LmlzUGFja2VkPyh1PW85KHQubG9naWNhbFNoYXBlLGksbi5lbmFibGVTaGFwZVVuaWZvcm1zKSxwPWM5KG8pKToodT1sOSh0LmxvZ2ljYWxTaGFwZSxpLG4uZW5hYmxlU2hhcGVVbmlmb3JtcykscD1wOShvKSksbi5wYWNrZWRJbnB1dHMmJihkKz1nOSksW2QsbCxwLHIsdSxzLG4udXNlckNvZGVdLmpvaW4oYFxuYCl9ZnVuY3Rpb24gdXAoZSx0PSExKXtsZXQgbj1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7c3dpdGNoKG4ubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIEU5KGUsdCk7Y2FzZSAxOnJldHVybiBBOShlLHQpO2Nhc2UgMjpyZXR1cm4gJDkoZSx0KTtjYXNlIDM6cmV0dXJuIFI5KGUsdCk7Y2FzZSA0OnJldHVybiBPOShlLHQpO2Nhc2UgNTpyZXR1cm4gUDkoZSk7Y2FzZSA2OnJldHVybiBMOShlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtuLmxlbmd0aH0tRCBpbnB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZGApfX1mdW5jdGlvbiBpQShlLHQpe3N3aXRjaChlLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIEM5KGUpO2Nhc2UgMTpyZXR1cm4gXzkoZSx0KTtjYXNlIDI6cmV0dXJuIEY5KGUsdCk7Y2FzZSAzOnJldHVybiBEOShlLHQpO2RlZmF1bHQ6cmV0dXJuIE05KGUsdCl9fWZ1bmN0aW9uIGk5KGUsdCxuPSExLGEpe2xldCByPVwiXCI7bj9yKz1pQShlLGEpOnIrPXVwKGUsYSk7bGV0IHM9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGk9dC5sb2dpY2FsU2hhcGU7cmV0dXJuIHMubGVuZ3RoPD1pLmxlbmd0aCYmKG4/cis9ejkoZSx0KTpyKz1XOShlLHQpKSxyfWZ1bmN0aW9uIG85KGUsdCxuKXtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gb0EoKTtjYXNlIDE6cmV0dXJuIGI5KGUsdCxuKTtjYXNlIDI6cmV0dXJuIE45KGUsdCxuKTtjYXNlIDM6cmV0dXJuIHg5KGUsdCxuKTtkZWZhdWx0OnJldHVybiB3OShlLHQsbil9fWZ1bmN0aW9uIGw5KGUsdCxuKXtzd2l0Y2goZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gb0EoKTtjYXNlIDE6cmV0dXJuIHk5KGUsdCxuKTtjYXNlIDI6cmV0dXJuIFQ5KGUsdCxuKTtjYXNlIDM6cmV0dXJuIHY5KGUsdCxuKTtjYXNlIDQ6cmV0dXJuIGs5KGUsdCxuKTtjYXNlIDU6cmV0dXJuIEk5KGUsdCk7Y2FzZSA2OnJldHVybiBTOShlLHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2UubGVuZ3RofS1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZGApfX1mdW5jdGlvbiB1OShlKXtyZXR1cm5gXG4gICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcbiAgICAgIHJldHVybiAke2UudGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XG4gICAgfVxuICBgfWZ1bmN0aW9uIHA5KGUpe3JldHVybmBcbiAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcbiAgICAgICR7ZS5vdXRwdXR9ID0gdmVjNCh2YWwsIDAsIDAsIDApO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBjOShlKXtyZXR1cm5gXG4gICAgdm9pZCBzZXRPdXRwdXQodmVjNCB2YWwpIHtcbiAgICAgICR7ZS5vdXRwdXR9ID0gdmFsO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBkOShlKXtyZXR1cm5gJHtlLnZlcnNpb259XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAke2UudmFyeWluZ0ZzfSB2ZWMyIHJlc3VsdFVWO1xuICAgICR7ZS5kZWZpbmVPdXRwdXR9XG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgIHN0cnVjdCBpdmVjNVxuICAgIHtcbiAgICAgIGludCB4O1xuICAgICAgaW50IHk7XG4gICAgICBpbnQgejtcbiAgICAgIGludCB3O1xuICAgICAgaW50IHU7XG4gICAgfTtcblxuICAgIHN0cnVjdCBpdmVjNlxuICAgIHtcbiAgICAgIGludCB4O1xuICAgICAgaW50IHk7XG4gICAgICBpbnQgejtcbiAgICAgIGludCB3O1xuICAgICAgaW50IHU7XG4gICAgICBpbnQgdjtcbiAgICB9O1xuXG4gICAgdW5pZm9ybSBmbG9hdCBOQU47XG4gICAgJHtlLmRlZmluZVNwZWNpYWxOYU59XG4gICAgJHtlLmRlZmluZVNwZWNpYWxJbmZ9XG4gICAgJHtlLmRlZmluZVJvdW5kfVxuXG4gICAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xuICAgIH1cblxuICAgIGludCBpZGl2KGludCBhLCBpbnQgYiwgZmxvYXQgc2lnbikge1xuICAgICAgaW50IHJlcyA9IGEgLyBiO1xuICAgICAgaW50IG1vZCA9IGltb2QoYSwgYik7XG4gICAgICBpZiAoc2lnbiA8IDAuICYmIG1vZCAhPSAwKSB7XG4gICAgICAgIHJlcyAtPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvL0Jhc2VkIG9uIHRoZSB3b3JrIG9mIERhdmUgSG9za2luc1xuICAgIC8vaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzRkalNSV1xuICAgICNkZWZpbmUgSEFTSFNDQUxFMSA0NDMuODk3NVxuICAgIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKXtcbiAgICAgIHZlYzIgcCA9IHJlc3VsdFVWICogc2VlZDtcbiAgICAgIHZlYzMgcDMgID0gZnJhY3QodmVjMyhwLnh5eCkgKiBIQVNIU0NBTEUxKTtcbiAgICAgIHAzICs9IGRvdChwMywgcDMueXp4ICsgMTkuMTkpO1xuICAgICAgcmV0dXJuIGZyYWN0KChwMy54ICsgcDMueSkgKiBwMy56KTtcbiAgICB9XG5cbiAgICAke2g5fVxuICAgICR7bTl9XG4gICAgJHtmOX1cbiAgYH12YXIgaDk9YFxudmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xufVxudmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xuICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xufVxuYCxtOT1gXG52ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCB0ZXhOdW1SLFxuICBpbnQgdGV4TnVtQywgaW50IHJvdywgaW50IGNvbCkge1xuICBpbnQgdGV4ZWxJbmRleCA9IChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xufVxuYCxmOT1gXG52ZWMyIHBhY2tlZFVWZnJvbTNEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQyxcbiAgICBpbnQgdGV4ZWxzSW5CYXRjaCwgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IGIsXG4gICAgaW50IHJvdywgaW50IGNvbCkge1xuICBpbnQgaW5kZXggPSBiICogdGV4ZWxzSW5CYXRjaCArIChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG59XG5gLGc5PWBcbiAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIHZlYzIgaW5uZXJEaW1zKSB7XG4gICAgdmVjMiBtb2RDb29yZCA9IG1vZChpbm5lckRpbXMsIDIuKTtcbiAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZykgOlxuICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLmIgOiBmcmFnLmEpO1xuICB9XG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XG4gICAgZmxvYXQgbW9kQ29vcmQgPSBtb2QoZmxvYXQoZGltKSwgMi4pO1xuICAgIHJldHVybiBtb2RDb29yZCA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZztcbiAgfVxuYDtmdW5jdGlvbiBvQSgpe3JldHVybmBcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICBgfWZ1bmN0aW9uIGI5KGUsdCxuKXtsZXQgYT1bTWF0aC5jZWlsKHRbMF0vMiksTWF0aC5jZWlsKHRbMV0vMildO3JldHVybiBhWzBdPT09MT9uP2BcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnggKiBjZWlsKGZsb2F0KG91dFRleFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueCAqICR7YVsxXX0uMCk7XG4gICAgICB9XG4gICAgYDphWzFdPT09MT9uP2BcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnkgKiBjZWlsKGZsb2F0KG91dFRleFNoYXBlWzBdKSAvIDIuMCkpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueSAqICR7YVswXX0uMCk7XG4gICAgICB9XG4gICAgYDpuP2BcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcGFja2VkVGV4U2hhcGUgPSBpdmVjMihjZWlsKGZsb2F0KG91dFRleFNoYXBlWzBdKSAvIDIuMCksIGNlaWwoZmxvYXQob3V0VGV4U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihwYWNrZWRUZXhTaGFwZVswXSwgcGFja2VkVGV4U2hhcGVbMV0pKTtcbiAgICAgIHJldHVybiAyICogKHJlc1RleFJDLnggKiBwYWNrZWRUZXhTaGFwZVsxXSArIHJlc1RleFJDLnkpO1xuICAgIH1cbiAgYDpgXG4gICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7YVswXX0sICR7YVsxXX0pKTtcbiAgICAgIHJldHVybiAyICogKHJlc1RleFJDLnggKiAke2FbMV19ICsgcmVzVGV4UkMueSk7XG4gICAgfVxuICBgfWZ1bmN0aW9uIHk5KGUsdCxuKXtyZXR1cm4gdFswXT09PTE/bj9gXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBmbG9hdChvdXRUZXhTaGFwZVsxXSkpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi54ICogJHt0WzFdfS4wKTtcbiAgICAgIH1cbiAgICBgOnRbMV09PT0xP24/YFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi55ICogZmxvYXQob3V0VGV4U2hhcGVbMF0pKTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiBpbnQocmVzdWx0VVYueSAqICR7dFswXX0uMCk7XG4gICAgICB9XG4gICAgYDpuP2BcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIob3V0VGV4U2hhcGVbMF0sIG91dFRleFNoYXBlWzFdKSk7XG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIG91dFRleFNoYXBlWzFdICsgcmVzVGV4UkMueTtcbiAgICB9XG4gIGA6YFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqICR7dFsxXX0gKyByZXNUZXhSQy55O1xuICAgIH1cbiAgYH1mdW5jdGlvbiB4OShlLHQsbil7aWYobilyZXR1cm5gXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcGFja2VkVGV4U2hhcGUgPSBpdmVjMihjZWlsKGZsb2F0KG91dFRleFNoYXBlWzBdKSAvIDIuMCksIGNlaWwoZmxvYXQob3V0VGV4U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gaW50KGNlaWwoZmxvYXQob3V0U2hhcGVbMl0pIC8gMi4wKSk7XG4gICAgICBpbnQgdGV4ZWxzSW5CYXRjaCA9IHRleGVsc0luTG9naWNhbFJvdyAqIGludChjZWlsKGZsb2F0KG91dFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIocGFja2VkVGV4U2hhcGVbMF0sIHBhY2tlZFRleFNoYXBlWzFdKSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogcGFja2VkVGV4U2hhcGVbMV0gKyByZXNUZXhSQy55O1xuXG4gICAgICBpbnQgYiA9IGluZGV4IC8gdGV4ZWxzSW5CYXRjaDtcbiAgICAgIGluZGV4IC09IGIgKiB0ZXhlbHNJbkJhdGNoO1xuXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyB0ZXhlbHNJbkxvZ2ljYWxSb3cpO1xuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCB0ZXhlbHNJbkxvZ2ljYWxSb3cpICogMjtcblxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xuICAgIH1cbiAgYDtsZXQgYT1bTWF0aC5jZWlsKHRbMF0vMiksTWF0aC5jZWlsKHRbMV0vMildLHI9TWF0aC5jZWlsKGVbMl0vMikscz1yKk1hdGguY2VpbChlWzFdLzIpO3JldHVybmBcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2FbMF19LCAke2FbMV19KSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHthWzFdfSArIHJlc1RleFJDLnk7XG5cbiAgICAgIGludCBiID0gaW5kZXggLyAke3N9O1xuICAgICAgaW5kZXggLT0gYiAqICR7c307XG5cbiAgICAgIGludCByID0gMiAqIChpbmRleCAvICR7cn0pO1xuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCAke3J9KSAqIDI7XG5cbiAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gdjkoZSx0LG4pe2lmKG4pcmV0dXJuYFxuICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSkpO1xuICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBvdXRUZXhTaGFwZVsxXSArIHJlc1RleFJDLnk7XG4gICAgJHtXZihbXCJyXCIsXCJjXCIsXCJkXCJdLGUpfVxuICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcbiAgfVxuYDtsZXQgYT1abyhbXCJyXCIsXCJjXCIsXCJkXCJdLGUpO3JldHVybmBcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHt0WzFdfSArIHJlc1RleFJDLnk7XG4gICAgICAke2F9XG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XG4gICAgfVxuICBgfWZ1bmN0aW9uIHc5KGUsdCxuKXtpZihuKXJldHVybmBcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiBwYWNrZWRUZXhTaGFwZSA9IGl2ZWMyKGNlaWwoZmxvYXQob3V0VGV4U2hhcGVbMF0pIC8gMi4wKSwgY2VpbChmbG9hdChvdXRUZXhTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKHBhY2tlZFRleFNoYXBlWzBdLCBwYWNrZWRUZXhTaGFwZVsxXSkpO1xuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIHBhY2tlZFRleFNoYXBlWzFdICsgcmVzVGV4UkMueTtcblxuICAgICAgaW50IHRleGVsc0luTG9naWNhbFJvdyA9IGludChjZWlsKGZsb2F0KG91dFNoYXBlWzNdKSAvIDIuMCkpO1xuICAgICAgaW50IHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBpbnQoY2VpbChmbG9hdChvdXRTaGFwZVsyXSkgLyAyLjApKTtcbiAgICAgIGludCB0ZXhlbHNJbkJhdGNoTiA9IHRleGVsc0luQmF0Y2ggKiBvdXRTaGFwZVsxXTtcblxuICAgICAgaW50IGIyID0gaW5kZXggLyB0ZXhlbHNJbkJhdGNoTjtcbiAgICAgIGluZGV4IC09IGIyICogdGV4ZWxzSW5CYXRjaE47XG5cbiAgICAgIGludCBiID0gaW5kZXggLyB0ZXhlbHNJbkJhdGNoO1xuICAgICAgaW5kZXggLT0gYiAqIHRleGVsc0luQmF0Y2g7XG5cbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIHRleGVsc0luTG9naWNhbFJvdyk7XG4gICAgICBpbnQgYyA9IGltb2QoaW5kZXgsIHRleGVsc0luTG9naWNhbFJvdykgKiAyO1xuXG4gICAgICByZXR1cm4gaXZlYzQoYjIsIGIsIHIsIGMpO1xuICAgIH1cbiAgYDtsZXQgYT1bTWF0aC5jZWlsKHRbMF0vMiksTWF0aC5jZWlsKHRbMV0vMildLHI9TWF0aC5jZWlsKGVbZS5sZW5ndGgtMV0vMikscz1yKk1hdGguY2VpbChlW2UubGVuZ3RoLTJdLzIpLGk9cyxvPVwiXCIsbD1cImIsIHIsIGNcIjtmb3IobGV0IHU9Mjt1PGUubGVuZ3RoLTE7dSsrKWkqPWVbZS5sZW5ndGgtdS0xXSxvPWBcbiAgICAgIGludCBiJHt1fSA9IGluZGV4IC8gJHtpfTtcbiAgICAgIGluZGV4IC09IGIke3V9ICogJHtpfTtcbiAgICBgK28sbD1gYiR7dX0sIGArbDtyZXR1cm5gXG4gICAgaXZlYyR7ZS5sZW5ndGh9IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7YVswXX0sICR7YVsxXX0pKTtcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiAke2FbMV19ICsgcmVzVGV4UkMueTtcblxuICAgICAgJHtvfVxuXG4gICAgICBpbnQgYiA9IGluZGV4IC8gJHtzfTtcbiAgICAgIGluZGV4IC09IGIgKiAke3N9O1xuXG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyAke3J9KTtcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xuXG4gICAgICByZXR1cm4gaXZlYyR7ZS5sZW5ndGh9KCR7bH0pO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBrOShlLHQsbil7aWYobilyZXR1cm5gXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgIHZlYzIob3V0VGV4U2hhcGVbMF0sIG91dFRleFNoYXBlWzFdKSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogb3V0VGV4U2hhcGVbMV0gKyByZXNUZXhSQy55O1xuICAgICAgJHtXZihbXCJyXCIsXCJjXCIsXCJkXCIsXCJkMlwiXSxlKX1cbiAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XG4gICAgfVxuICBgO2xldCBhPVpvKFtcInJcIixcImNcIixcImRcIixcImQyXCJdLGUpO3JldHVybmBcbiAgICBpdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHt0WzFdfSArIHJlc1RleFJDLnk7XG4gICAgICAke2F9XG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBJOShlLHQpe2xldCBuPVpvKFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiXSxlKTtyZXR1cm5gXG4gICAgaXZlYzUgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoJHt0WzBdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHt0WzFdfSkpO1xuXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHt0WzFdfSArIHJlc1RleFJDLnk7XG5cbiAgICAgICR7bn1cblxuICAgICAgaXZlYzUgb3V0U2hhcGUgPSBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xuICAgICAgcmV0dXJuIG91dFNoYXBlO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBTOShlLHQpe2xldCBuPVpvKFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiLFwiZDRcIl0sZSk7cmV0dXJuYFxuICAgIGl2ZWM2IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiAke3RbMV19ICsgcmVzVGV4UkMueTtcblxuICAgICAgJHtufVxuXG4gICAgICBpdmVjNiByZXN1bHQgPSBpdmVjNihyLCBjLCBkLCBkMiwgZDMsIGQ0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBgfWZ1bmN0aW9uIE45KGUsdCxuKXtsZXQgYT1bTWF0aC5jZWlsKHRbMF0vMiksTWF0aC5jZWlsKHRbMV0vMildO2lmKHcuYXJyYXlzRXF1YWwoZSx0KSlyZXR1cm4gbj9gXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdChvdXRUZXhTaGFwZVswXSkgLyAyLjApLCBjZWlsKGZsb2F0KG91dFRleFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgICByZXR1cm4gMiAqIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihwYWNrZWRUZXhTaGFwZVswXSwgcGFja2VkVGV4U2hhcGVbMV0pKTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoJHthWzBdfSwgJHthWzFdfSkpO1xuICAgICAgfVxuICAgIGA7bGV0IHI9TWF0aC5jZWlsKGVbMV0vMik7cmV0dXJuIG4/YFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdChvdXRUZXhTaGFwZVswXSkgLyAyLjApLCBjZWlsKGZsb2F0KG91dFRleFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgaW50IHRleGVsc0luTG9naWNhbFJvdyA9IGludChjZWlsKGZsb2F0KG91dFNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIocGFja2VkVGV4U2hhcGVbMF0sIHBhY2tlZFRleFNoYXBlWzFdKSk7XG5cbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBwYWNrZWRUZXhTaGFwZVsxXSArIHJlc1RleFJDLnk7XG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyB0ZXhlbHNJbkxvZ2ljYWxSb3cpO1xuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCB0ZXhlbHNJbkxvZ2ljYWxSb3cpICogMjtcblxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xuICAgIH1cbiAgYDpgXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHthWzBdfSwgJHthWzFdfSkpO1xuXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHthWzFdfSArIHJlc1RleFJDLnk7XG4gICAgICBpbnQgciA9IDIgKiAoaW5kZXggLyAke3J9KTtcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgJHtyfSkgKiAyO1xuXG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XG4gICAgfVxuICBgfWZ1bmN0aW9uIFQ5KGUsdCxuKXtyZXR1cm4gdy5hcnJheXNFcXVhbChlLHQpP24/YFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSkpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcbiAgICAgIH1cbiAgICBgOmVbMV09PT0xP24/YFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSkpO1xuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogb3V0VGV4U2hhcGVbMV0gKyByZXNUZXhSQy55O1xuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7dFsxXX0gKyByZXNUZXhSQy55O1xuICAgICAgICByZXR1cm4gaXZlYzIoaW5kZXgsIDApO1xuICAgICAgfVxuICAgIGA6ZVswXT09PTE/bj9gXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIob3V0VGV4U2hhcGVbMF0sIG91dFRleFNoYXBlWzFdKSk7XG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBvdXRUZXhTaGFwZVsxXSArIHJlc1RleFJDLnk7XG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XG4gICAgICB9XG4gICAgYDpgXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogJHt0WzFdfSArIHJlc1RleFJDLnk7XG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XG4gICAgICB9XG4gICAgYDpuP2BcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihvdXRUZXhTaGFwZVswXSwgb3V0VGV4U2hhcGVbMV0pKTtcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBvdXRUZXhTaGFwZVsxXSArIHJlc1RleFJDLnk7XG4gICAgICBpbnQgciA9IGluZGV4IC8gb3V0U2hhcGVbMV07XG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqIG91dFNoYXBlWzFdO1xuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xuICAgIH1cbiAgYDpgXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqICR7dFsxXX0gKyByZXNUZXhSQy55O1xuICAgICAgaW50IHIgPSBpbmRleCAvICR7ZVsxXX07XG4gICAgICBpbnQgYyA9IGluZGV4IC0gciAqICR7ZVsxXX07XG4gICAgICByZXR1cm4gaXZlYzIociwgYyk7XG4gICAgfVxuICBgfWZ1bmN0aW9uIEpvKGUpe3JldHVybmBvZmZzZXQke2V9YH1mdW5jdGlvbiBDOShlKXtsZXQgdD1lLm5hbWUsbj1cImdldFwiK3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKSxhPUVuKCk7cmV0dXJuYFxuICAgIHZlYzQgJHtufSgpIHtcbiAgICAgIHJldHVybiAke2EudGV4dHVyZTJEfSgke3R9LCBoYWxmQ1IpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBFOShlLHQpe2xldCBuPWUubmFtZSxhPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpO2lmKGUuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5gZmxvYXQgJHthfSgpIHtyZXR1cm4gJHtufTt9YDtsZXRbcixzXT1lLnNoYXBlSW5mby50ZXhTaGFwZTtpZihyPT09MSYmcz09PTEpcmV0dXJuYFxuICAgICAgZmxvYXQgJHthfSgpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgaGFsZkNSKTtcbiAgICAgIH1cbiAgICBgO2xldCBpPUpvKG4pO2lmKHQpcmV0dXJuYFxuICAgIGZsb2F0ICR7YX0oKSB7XG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke259VGV4U2hhcGVbMF0sICR7bn1UZXhTaGFwZVsxXSwgJHtpfSk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgfVxuICBgO2xldFtvLGxdPWUuc2hhcGVJbmZvLnRleFNoYXBlO3JldHVybmBcbiAgICBmbG9hdCAke2F9KCkge1xuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtvfSwgJHtsfSwgJHtpfSk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uIF85KGUsdCl7bGV0IG49ZS5uYW1lLGE9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkscj1lLnNoYXBlSW5mby50ZXhTaGFwZSxzPUVuKCk7aWYodClyZXR1cm5gXG4gICAgdmVjNCAke2F9KGludCBpbmRleCkge1xuICAgICAgaXZlYzIgcGFja2VkVGV4U2hhcGUgPSBpdmVjMihjZWlsKGZsb2F0KCR7bn1UZXhTaGFwZVswXSkgLyAyLjApLCBjZWlsKGZsb2F0KCR7bn1UZXhTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20xRChcbiAgICAgICAgcGFja2VkVGV4U2hhcGVbMF0sIHBhY2tlZFRleFNoYXBlWzFdLCBpbmRleCk7XG4gICAgICByZXR1cm4gJHtzLnRleHR1cmUyRH0oJHtufSwgdXYpO1xuICAgIH1cbiAgYDtsZXQgaT1bTWF0aC5jZWlsKHJbMF0vMiksTWF0aC5jZWlsKHJbMV0vMildO3JldHVybmBcbiAgICB2ZWM0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMUQoXG4gICAgICAgICR7aVswXX0sICR7aVsxXX0sIGluZGV4KTtcbiAgICAgIHJldHVybiAke3MudGV4dHVyZTJEfSgke259LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uIEE5KGUsdCl7bGV0IG49ZS5uYW1lLGE9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSk7aWYoZS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVybmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICAgICR7cHAoZSl9XG4gICAgICB9XG4gICAgYDtsZXQgcj1lLnNoYXBlSW5mby50ZXhTaGFwZSxzPXJbMF0saT1yWzFdO2lmKGk9PT0xJiZzPT09MSlyZXR1cm5gXG4gICAgICBmbG9hdCAke2F9KGludCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCBoYWxmQ1IpO1xuICAgICAgfVxuICAgIGA7bGV0IG89Sm8obik7cmV0dXJuIGk9PT0xP3Q/YFxuICAgICAgZmxvYXQgJHthfShpbnQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXggKyAke299KSArIDAuNSkgLyBmbG9hdCgke259VGV4U2hhcGVbMF0pKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgZmxvYXQgJHthfShpbnQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXggKyAke299KSArIDAuNSkgLyAke3N9LjApO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgICB9XG4gICAgYDpzPT09MT90P2BcbiAgICAgIGZsb2F0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCArICR7b30pICsgMC41KSAvIGZsb2F0KCR7bn1UZXhTaGFwZVsxXSksIDAuNSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IGluZGV4KSB7XG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCArICR7b30pICsgMC41KSAvICR7aX0uMCwgMC41KTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgICAgfVxuICAgIGA6dD9gXG4gICAgZmxvYXQgJHthfShpbnQgaW5kZXgpIHtcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bn1UZXhTaGFwZVswXSwgJHtufVRleFNoYXBlWzFdLCBpbmRleCArICR7b30pO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgIH1cbiAgYDpgXG4gICAgZmxvYXQgJHthfShpbnQgaW5kZXgpIHtcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7c30sICR7aX0sIGluZGV4ICsgJHtvfSk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uIEY5KGUsdCl7bGV0IG49ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGE9ZS5uYW1lLHI9XCJnZXRcIithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSkscz1lLnNoYXBlSW5mby50ZXhTaGFwZSxpPXNbMF0sbz1zWzFdLGw9RW4oKTtpZihzIT1udWxsJiZ3LmFycmF5c0VxdWFsKG4scykpcmV0dXJuIHQ/YFxuICAgICAgdmVjNCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7YX1UZXhTaGFwZVsxXSwgJHthfVRleFNoYXBlWzBdKTtcblxuICAgICAgICByZXR1cm4gJHtsLnRleHR1cmUyRH0oJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgdmVjNCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7b30uMCwgJHtpfS4wKTtcblxuICAgICAgICByZXR1cm4gJHtsLnRleHR1cmUyRH0oJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA7aWYodClyZXR1cm5gXG4gICAgdmVjNCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIGl2ZWMyIHBhY2tlZFRleFNoYXBlID0gaXZlYzIoY2VpbChmbG9hdCgke2F9VGV4U2hhcGVbMF0pIC8gMi4wKSwgY2VpbChmbG9hdCgke2F9VGV4U2hhcGVbMV0pIC8gMi4wKSk7XG4gICAgICBpbnQgdmFsdWVzUGVyUm93ID0gaW50KGNlaWwoZmxvYXQoJHthfVNoYXBlWzFdKSAvIDIuMCkpO1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKHZhbHVlc1BlclJvdywgcGFja2VkVGV4U2hhcGVbMF0sIHBhY2tlZFRleFNoYXBlWzFdLCByb3csIGNvbCk7XG4gICAgICByZXR1cm4gJHtsLnRleHR1cmUyRH0oJHthfSwgdXYpO1xuICAgIH1cbiAgYDtsZXQgdT1bTWF0aC5jZWlsKHNbMF0vMiksTWF0aC5jZWlsKHNbMV0vMildLHA9TWF0aC5jZWlsKG5bMV0vMik7cmV0dXJuYFxuICAgIHZlYzQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMkQoJHtwfSwgJHt1WzBdfSwgJHt1WzFdfSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7bC50ZXh0dXJlMkR9KCR7YX0sIHV2KTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gJDkoZSx0KXtsZXQgbj1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsYT1lLm5hbWUscj1cImdldFwiK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zbGljZSgxKSxzPWUuc2hhcGVJbmZvLnRleFNoYXBlO2lmKHMhPW51bGwmJncuYXJyYXlzRXF1YWwobixzKSl7aWYodClyZXR1cm5gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7YX1UZXhTaGFwZVsxXSwgJHthfVRleFNoYXBlWzBdKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA7bGV0IGM9c1swXSxoPXNbMV07cmV0dXJuYFxuICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7aH0uMCwgJHtjfS4wKTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICB9XG4gIGB9bGV0e25ld1NoYXBlOmksa2VwdERpbXM6b309dy5zcXVlZXplU2hhcGUobiksbD1pO2lmKGwubGVuZ3RoPG4ubGVuZ3RoKXtsZXQgYz1jcChlLGwpLGg9W1wicm93XCIsXCJjb2xcIl07cmV0dXJuYFxuICAgICAgJHt1cChjLHQpfVxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIHJldHVybiAke3J9KCR7ZHAoaCxvKX0pO1xuICAgICAgfVxuICAgIGB9aWYoZS5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVybmBcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMihyb3csIGNvbCksIHZlYzIoJHtuWzFdfSwgMSkpKTtcbiAgICAgICAgJHtwcChlKX1cbiAgICAgIH1cbiAgICBgO2xldCB1PXNbMF0scD1zWzFdLGQ9Sm8oYSk7cmV0dXJuIHA9PT0xP3Q/YFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsICR7ZH0pLCB2ZWMzKCR7YX1TaGFwZVsxXSwgMSwgMSkpO1xuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyBmbG9hdCgke2F9VGV4U2hhcGVbMF0pKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA6YFxuICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgJHtkfSksIHZlYzMoJHtuWzFdfSwgMSwgMSkpO1xuICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gJHt1fS4wKTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICB9XG4gIGA6dT09PTE/dD9gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgJHtkfSksIHZlYzMoJHthfVNoYXBlWzFdLCAxLCAxKSk7XG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyBmbG9hdCgke2F9VGV4U2hhcGVbMV0pLCAwLjUpO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gICAgYDpgXG4gICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCAke2R9KSwgdmVjMygke25bMV19LCAxLCAxKSk7XG4gICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHtwfS4wLCAwLjUpO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgIH1cbiAgYDp0P2BcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXG4gICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7YX1TaGFwZVsxXSArIGNvbCArICR7ZH07XG4gICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7YX1UZXhTaGFwZVswXSwgJHthfVRleFNoYXBlWzFdLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgIGludCBpbmRleCA9IHJvdyAqICR7blsxXX0gKyBjb2wgKyAke2R9O1xuICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dX0sICR7cH0sIGluZGV4KTtcbiAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gIH1cbmB9ZnVuY3Rpb24gRDkoZSx0KXtsZXQgbj1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsYT1lLm5hbWUscj1cImdldFwiK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zbGljZSgxKSxzPWUuc2hhcGVJbmZvLnRleFNoYXBlLGk9W01hdGguY2VpbChzWzBdLzIpLE1hdGguY2VpbChzWzFdLzIpXTtpZihuWzBdPT09MSl7bGV0IGM9bi5zbGljZSgxKSxoPVsxLDJdLG09Y3AoZSxjKSxmPVtcImJcIixcInJvd1wiLFwiY29sXCJdO3JldHVybmBcbiAgICAgICAgJHtpQShtLHQpfVxuICAgICAgICB2ZWM0ICR7cn0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICByZXR1cm4gJHtyfSgke2RwKGYsaCl9KTtcbiAgICAgICAgfVxuICAgICAgYH1sZXQgbz1FbigpO2lmKHQpcmV0dXJuYFxuICAgIHZlYzQgJHtyfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgaXZlYzIgcGFja2VkVGV4U2hhcGUgPSBpdmVjMihjZWlsKGZsb2F0KCR7YX1UZXhTaGFwZVswXSkgLyAyLjApLCBjZWlsKGZsb2F0KCR7YX1UZXhTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIGludCB2YWx1ZXNQZXJSb3cgPSBpbnQoY2VpbChmbG9hdCgke2F9U2hhcGVbMl0pIC8gMi4wKSk7XG4gICAgICBpbnQgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIGludChjZWlsKGZsb2F0KCR7YX1TaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20zRChcbiAgICAgICAgcGFja2VkVGV4U2hhcGVbMF0sIHBhY2tlZFRleFNoYXBlWzFdLCB0ZXhlbHNJbkJhdGNoLCB2YWx1ZXNQZXJSb3csIGIsIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke28udGV4dHVyZTJEfSgke2F9LCB1dik7XG4gICAgfVxuICBgO2xldCBsPWlbMF0sdT1pWzFdLHA9TWF0aC5jZWlsKG5bMl0vMiksZD1wKk1hdGguY2VpbChuWzFdLzIpO3JldHVybmBcbiAgICB2ZWM0ICR7cn0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20zRChcbiAgICAgICAgJHtsfSwgJHt1fSwgJHtkfSwgJHtwfSwgYiwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7by50ZXh0dXJlMkR9KCR7YX0sIHV2KTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gUjkoZSx0KXtsZXQgbj1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsYT1lLm5hbWUscj1cImdldFwiK2EuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zbGljZSgxKSxzPW5bMV0qblsyXSxpPW5bMl0se25ld1NoYXBlOm8sa2VwdERpbXM6bH09dy5zcXVlZXplU2hhcGUobiksdT1vO2lmKHUubGVuZ3RoPG4ubGVuZ3RoKXtsZXQgZj1jcChlLHUpLGc9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCJdO3JldHVybmBcbiAgICAgICAgJHt1cChmLHQpfVxuICAgICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xuICAgICAgICAgIHJldHVybiAke3J9KCR7ZHAoZyxsKX0pO1xuICAgICAgICB9XG4gICAgICBgfWlmKGUuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMzKCR7c30sICR7aX0sIDEpKSk7XG4gICAgICAgICR7cHAoZSl9XG4gICAgICB9XG4gICAgYDtsZXQgcD1lLnNoYXBlSW5mby50ZXhTaGFwZSxkPXBbMF0sYz1wWzFdLGg9ZS5zaGFwZUluZm8uZmxhdE9mZnNldDtpZihjPT09cyYmaD09bnVsbClyZXR1cm4gdD9gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xuICAgICAgICBpbnQgc3RyaWRlMSA9ICR7YX1TaGFwZVsyXTtcbiAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjMihjb2wsIGRlcHRoKSwgdmVjMihzdHJpZGUxLCAxKSk7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xuICAgICAgICAgICAgICAgICAgIHZlYzIoJHthfVRleFNoYXBlWzFdLCAke2F9VGV4U2hhcGVbMF0pO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gICAgYDpgXG4gICAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XG4gICAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XG4gICAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWMyKGNvbCwgZGVwdGgpLCB2ZWMyKCR7aX0sIDEpKTtcbiAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtjfS4wLCAke2R9LjApO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtpZihjPT09aSYmaD09bnVsbClyZXR1cm4gdD9gXG4gICAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xuICAgICAgICBmbG9hdCB0ZXhSID0gZG90KHZlYzIocm93LCBjb2wpLCB2ZWMyKCR7YX1TaGFwZVsxXSwgMSkpO1xuICAgICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgpO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMigke2F9VGV4U2hhcGVbMV0sICR7YX1UZXhTaGFwZVswXSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICBmbG9hdCAke3J9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xuICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMigke25bMV19LCAxKSk7XG4gICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgpO1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHtjfS4wLCAke2R9LjApO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgIH1cbiAgYDtsZXQgbT1KbyhhKTtyZXR1cm4gdD9gXG4gICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cbiAgICAgIGludCBzdHJpZGUwID0gJHthfVNoYXBlWzFdICogJHthfVNoYXBlWzJdO1xuICAgICAgaW50IHN0cmlkZTEgPSAke2F9U2hhcGVbMl07XG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoICsgJHttfTtcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7YX1UZXhTaGFwZVswXSwgJHthfVRleFNoYXBlWzFdLCBpbmRleCk7XG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgfVxuICAgIGA6YFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcbiAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N9ICsgY29sICogJHtpfSArIGRlcHRoICsgJHttfTtcbiAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtkfSwgJHtjfSwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gIGB9ZnVuY3Rpb24gTTkoZSx0KXtsZXQgbj1lLm5hbWUsYT1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxyPUVuKCk7aWYodClyZXR1cm5gXG4gICAgdmVjNCAke2F9KGludCBiMiwgaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgIGludCB2YWx1ZXNQZXJSb3cgPSBpbnQoY2VpbChmbG9hdCgke259U2hhcGVbM10pIC8gMi4wKSk7XG4gICAgICBpbnQgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIGludChjZWlsKGZsb2F0KCR7bn1TaGFwZVsyXSkgLyAyLjApKTtcbiAgICAgIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdmFsdWVzUGVyUm93ICsgKGNvbCAvIDIpO1xuICAgICAgdGV4ZWxzSW5CYXRjaCAqPSAke259U2hhcGVbMV07XG4gICAgICBpbmRleCA9IGIyICogdGV4ZWxzSW5CYXRjaCArIGluZGV4O1xuICAgICAgaXZlYzIgcGFja2VkVGV4U2hhcGUgPSBpdmVjMihjZWlsKGZsb2F0KCR7bn1UZXhTaGFwZVswXSkgLyAyLjApLCBjZWlsKGZsb2F0KCR7bn1UZXhTaGFwZVsxXSkgLyAyLjApKTtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBwYWNrZWRUZXhTaGFwZVsxXTtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogcGFja2VkVGV4U2hhcGVbMV07XG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihwYWNrZWRUZXhTaGFwZVsxXSwgcGFja2VkVGV4U2hhcGVbMF0pOyByZXR1cm4gJHtyLnRleHR1cmUyRH0oJHtufSwgdXYpO1xuICAgIH1cbiAgYDtsZXQgcz1lLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsaT1zLmxlbmd0aCxvPWUuc2hhcGVJbmZvLnRleFNoYXBlLGw9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXSx1PWxbMF0scD1sWzFdLGQ9TWF0aC5jZWlsKHNbaS0xXS8yKSxjPWQqTWF0aC5jZWlsKHNbaS0yXS8yKSxoPVwiaW50IGIsIGludCByb3csIGludCBjb2xcIixtPWBiICogJHtjfSArIChyb3cgLyAyKSAqICR7ZH0gKyAoY29sIC8gMilgO2ZvcihsZXQgZj0yO2Y8aS0xO2YrKyloPWBpbnQgYiR7Zn0sIGAraCxjKj1zW2ktZi0xXSxtPWBiJHtmfSAqICR7Y30gKyBgK207cmV0dXJuYFxuICAgIHZlYzQgJHthfSgke2h9KSB7XG4gICAgICBpbnQgaW5kZXggPSAke219O1xuICAgICAgaW50IHRleFIgPSBpbmRleCAvICR7cH07XG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqICR7cH07XG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMigke3B9LCAke3V9KTtcbiAgICAgIHJldHVybiAke3IudGV4dHVyZTJEfSgke259LCB1dik7XG4gICAgfVxuICBgfWZ1bmN0aW9uIE85KGUsdCl7bGV0IG49ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLGE9ZS5uYW1lLHI9XCJnZXRcIithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSkscz1uWzNdLGk9blsyXSpzLG89blsxXSppLHtuZXdTaGFwZTpsLGtlcHREaW1zOnV9PXcuc3F1ZWV6ZVNoYXBlKG4pO2lmKGwubGVuZ3RoPG4ubGVuZ3RoKXtsZXQgeT1jcChlLGwpLHg9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIl07cmV0dXJuYFxuICAgICAgJHt1cCh5LHQpfVxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAgICAgcmV0dXJuICR7cn0oJHtkcCh4LHUpfSk7XG4gICAgICB9XG4gICAgYH1pZihlLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuYFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0KCR7b30sICR7aX0sICR7c30sIDEpKSk7XG4gICAgICAgICR7cHAoZSl9XG4gICAgICB9XG4gICAgYDtsZXQgcD1lLnNoYXBlSW5mby5mbGF0T2Zmc2V0LGQ9ZS5zaGFwZUluZm8udGV4U2hhcGUsYz1kWzBdLGg9ZFsxXSxtPWBpbnQgc3RyaWRlMiA9ICR7YX1TaGFwZVszXTtgLGY9YGludCBzdHJpZGUxID0gJHthfVNoYXBlWzJdICogc3RyaWRlMjtgLGc9YGludCBzdHJpZGUwID0gJHthfVNoYXBlWzFdICogc3RyaWRlMTtgO2lmKGg9PT1vJiZwPT1udWxsKXJldHVybiB0P2BcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgICR7bX1cbiAgICAgICAgJHtmfVxuICAgICAgICBmbG9hdCB0ZXhSID0gZmxvYXQocm93KTtcbiAgICAgICAgZmxvYXQgdGV4QyA9XG4gICAgICAgICAgICBkb3QodmVjMyhjb2wsIGRlcHRoLCBkZXB0aDIpLFxuICAgICAgICAgICAgICAgIHZlYzMoc3RyaWRlMSwgc3RyaWRlMiwgMSkpO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgICB2ZWMyKCR7YX1UZXhTaGFwZVsxXSwgJHthfVRleFNoYXBlWzBdKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHthfSwgdXYpO1xuICAgICAgfVxuICAgIGA6YFxuICAgICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAgICAgZmxvYXQgdGV4UiA9IGZsb2F0KHJvdyk7XG4gICAgICAgIGZsb2F0IHRleEMgPVxuICAgICAgICAgICAgZG90KHZlYzMoY29sLCBkZXB0aCwgZGVwdGgyKSxcbiAgICAgICAgICAgICAgICB2ZWMzKCR7aX0sICR7c30sIDEpKTtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICAgdmVjMigke2h9LjAsICR7Y30uMCk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgO2lmKGg9PT1zJiZwPT1udWxsKXJldHVybiB0P2BcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoJHthfVNoYXBlWzFdICogJHthfVNoYXBlWzJdLCAke2F9U2hhcGVbMl0sIDEpKTtcbiAgICAgICAgZmxvYXQgdGV4QyA9IGZsb2F0KGRlcHRoMik7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xuICAgICAgICAgICAgICAgICAgdmVjMigke2F9VGV4U2hhcGVbMV0sICR7YX1UZXhTaGFwZVswXSk7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICAgIH1cbiAgICBgOmBcbiAgICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoJHtuWzFdKm5bMl19LCAke25bMl19LCAxKSk7XG4gICAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aDIpO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgIHZlYzIoJHtofS4wLCAke2N9LjApO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2F9LCB1dik7XG4gICAgICB9XG4gICAgYDtsZXQgYj1KbyhhKTtyZXR1cm4gdD9gXG4gICAgZmxvYXQgJHtyfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cbiAgICAgICR7bX1cbiAgICAgICR7Zn1cbiAgICAgICR7Z31cbiAgICAgIGludCBpbmRleCA9IHJvdyAqIHN0cmlkZTAgKyBjb2wgKiBzdHJpZGUxICtcbiAgICAgICAgICBkZXB0aCAqIHN0cmlkZTIgKyBkZXB0aDI7XG4gICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke2F9VGV4U2hhcGVbMF0sICR7YX1UZXhTaGFwZVsxXSwgaW5kZXggKyAke2J9KTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICB9XG4gIGA6YFxuICAgIGZsb2F0ICR7cn0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiAke299ICsgY29sICogJHtpfSArXG4gICAgICAgICAgZGVwdGggKiAke3N9ICsgZGVwdGgyO1xuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtjfSwgJHtofSwgaW5kZXggKyAke2J9KTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7YX0sIHV2KTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gUDkoZSl7bGV0IHQ9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49ZS5uYW1lLGE9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkscj10WzRdLHM9dFszXSpyLGk9dFsyXSpzLG89dFsxXSppLHtuZXdTaGFwZTpsLGtlcHREaW1zOnV9PXcuc3F1ZWV6ZVNoYXBlKHQpO2lmKGwubGVuZ3RoPHQubGVuZ3RoKXtsZXQgZj1jcChlLGwpLGc9W1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiXTtyZXR1cm5gXG4gICAgICAke3VwKGYpfVxuICAgICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgcmV0dXJuICR7YX0oJHtkcChnLHUpfSk7XG4gICAgICB9XG4gICAgYH1pZihlLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuYFxuICAgICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QoXG4gICAgICAgICAgdmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXG4gICAgICAgICAgdmVjNCgke299LCAke2l9LCAke3N9LCAke3J9KSkgK1xuICAgICAgICAgIGRlcHRoMztcbiAgICAgICAgJHtwcChlKX1cbiAgICAgIH1cbiAgICBgO2xldCBwPWUuc2hhcGVJbmZvLmZsYXRPZmZzZXQsZD1lLnNoYXBlSW5mby50ZXhTaGFwZSxjPWRbMF0saD1kWzFdO2lmKGg9PT1vJiZwPT1udWxsKXJldHVybmBcbiAgICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XG4gICAgICAgIGludCB0ZXhSID0gcm93O1xuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzQoY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoJHtpfSwgJHtzfSwgJHtyfSwgMSkpO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgICB2ZWMyKCR7aH0uMCwgJHtjfS4wKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgICAgfVxuICAgIGA7aWYoaD09PXImJnA9PW51bGwpcmV0dXJuYFxuICAgICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdChcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcbiAgICAgICAgICB2ZWM0KCR7dFsxXSp0WzJdKnRbM119LFxuICAgICAgICAgICAgICAgJHt0WzJdKnRbM119LCAke3RbM119LCAxKSk7XG4gICAgICAgIGludCB0ZXhDID0gZGVwdGgzO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgIHZlYzIoJHtofS4wLCAke2N9LjApO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgICB9XG4gICAgYDtsZXQgbT1KbyhuKTtyZXR1cm5gXG4gICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cbiAgICAgIGludCBpbmRleCA9IHJvdyAqICR7b30gKyBjb2wgKiAke2l9ICsgZGVwdGggKiAke3N9ICtcbiAgICAgICAgICBkZXB0aDIgKiAke3J9ICsgZGVwdGgzICsgJHttfTtcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7Y30sICR7aH0sIGluZGV4KTtcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHV2KTtcbiAgICB9XG4gIGB9ZnVuY3Rpb24gTDkoZSl7bGV0IHQ9ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49ZS5uYW1lLGE9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkse25ld1NoYXBlOnIsa2VwdERpbXM6c309dy5zcXVlZXplU2hhcGUodCk7aWYoci5sZW5ndGg8dC5sZW5ndGgpe2xldCBnPWNwKGUsciksYj1bXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCIsXCJkZXB0aDRcIl07cmV0dXJuYFxuICAgICAgJHt1cChnKX1cbiAgICAgIGZsb2F0ICR7YX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAgIHJldHVybiAke2F9KCR7ZHAoYixzKX0pO1xuICAgICAgfVxuICAgIGB9bGV0IGk9dFs1XSxvPXRbNF0qaSxsPXRbM10qbyx1PXRbMl0qbCxwPXRbMV0qdTtpZihlLnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuYFxuICAgICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdChcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcbiAgICAgICAgICB2ZWM0KCR7cH0sICR7dX0sICR7bH0sICR7b30pKSArXG4gICAgICAgICAgZG90KFxuICAgICAgICAgICAgdmVjMihkZXB0aDMsIGRlcHRoNCksXG4gICAgICAgICAgICB2ZWMyKCR7aX0sIDEpKSk7XG4gICAgICAgICR7cHAoZSl9XG4gICAgICB9XG4gICAgYDtsZXQgZD1lLnNoYXBlSW5mby5mbGF0T2Zmc2V0LGM9ZS5zaGFwZUluZm8udGV4U2hhcGUsaD1jWzBdLG09Y1sxXTtpZihtPT09cCYmZD09bnVsbClyZXR1cm5gXG4gICAgICBmbG9hdCAke2F9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xuICAgICAgICBpbnQgdGV4UiA9IHJvdztcbiAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWM0KGNvbCwgZGVwdGgsIGRlcHRoMiwgZGVwdGgzKSxcbiAgICAgICAgICB2ZWM0KCR7dX0sICR7bH0sICR7b30sICR7aX0pKSArXG4gICAgICAgICAgICAgICBmbG9hdChkZXB0aDQpO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgICB2ZWMyKCR7bX0uMCwgJHtofS4wKTtcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgICAgfVxuICAgIGA7aWYobT09PWkmJmQ9PW51bGwpcmV0dXJuYFxuICAgICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcbiAgICAgICAgICB2ZWM0KCR7dFsxXSp0WzJdKnRbM10qdFs0XX0sXG4gICAgICAgICAgICAgICAke3RbMl0qdFszXSp0WzRdfSxcbiAgICAgICAgICAgICAgICR7dFszXSp0WzRdfSxcbiAgICAgICAgICAgICAgICR7dFs0XX0pKSArIGZsb2F0KGRlcHRoMyk7XG4gICAgICAgIGludCB0ZXhDID0gZGVwdGg0O1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgIHZlYzIoJHttfS4wLCAke2h9LjApO1xuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke259LCB1dik7XG4gICAgICB9XG4gICAgYDtsZXQgZj1KbyhuKTtyZXR1cm5gXG4gICAgZmxvYXQgJHthfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiAke3B9ICsgY29sICogJHt1fSArIGRlcHRoICogJHtsfSArXG4gICAgICAgICAgZGVwdGgyICogJHtvfSArIGRlcHRoMyAqICR7aX0gKyBkZXB0aDQgKyAke2Z9O1xuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtofSwgJHttfSwgaW5kZXgpO1xuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtufSwgdXYpO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBwcChlKXtsZXQgdD1lLm5hbWUsbj13LnNpemVGcm9tU2hhcGUoZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTtyZXR1cm4gbjwyP2ByZXR1cm4gJHt0fTtgOmBcbiAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7bn07IGkrKykge1xuICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICR7dH1baV07XG4gICAgICB9XG4gICAgfVxuICBgfWZ1bmN0aW9uIHo5KGUsdCl7bGV0IG49ZS5uYW1lLGE9bi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLHI9XCJnZXRcIithK1wiQXRPdXRDb29yZHNcIixzPWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgsaT10LmxvZ2ljYWxTaGFwZS5sZW5ndGgsbz1zQShlLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsdC5sb2dpY2FsU2hhcGUpLGw9aHQoaSksdT1pLXMscCxkPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07cz09PTA/cD1cIlwiOmk8MiYmby5sZW5ndGg+PTE/cD1cImNvb3JkcyA9IDA7XCI6cD1vLm1hcChnPT5gY29vcmRzLiR7ZFtnK3VdfSA9IDA7YCkuam9pbihgXG5gKTtsZXQgYz1cIlwiO2k8MiYmcz4wP2M9XCJjb29yZHNcIjpjPWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5tYXAoKGcsYik9PmBjb29yZHMuJHtkW2IrdV19YCkuam9pbihcIiwgXCIpO2xldCBoPVwicmV0dXJuIG91dHB1dFZhbHVlO1wiLG09dy5zaXplRnJvbVNoYXBlKGUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk9PT0xLGY9dy5zaXplRnJvbVNoYXBlKHQubG9naWNhbFNoYXBlKT09PTE7aWYocz09PTEmJiFtJiYhZiloPWBcbiAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh5LCBvdXRwdXRWYWx1ZS54eSk7XG4gICAgYDtlbHNlIGlmKG0mJiFmKWk9PT0xP2g9YFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS54LCAwLiwgMC4pO1xuICAgICAgYDpoPWBcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XG4gICAgICBgO2Vsc2UgaWYoby5sZW5ndGgpe2xldCBnPXMtMixiPXMtMTtvLmluZGV4T2YoZyk+LTEmJm8uaW5kZXhPZihiKT4tMT9oPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XCI6by5pbmRleE9mKGcpPi0xP2g9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55LCBvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS55KTtcIjpvLmluZGV4T2YoYik+LTEmJihoPVwicmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnp6KTtcIil9cmV0dXJuYFxuICAgIHZlYzQgJHtyfSgpIHtcbiAgICAgICR7bH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAke3B9XG4gICAgICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0JHthfSgke2N9KTtcbiAgICAgICR7aH1cbiAgICB9XG4gIGB9ZnVuY3Rpb24gVzkoZSx0KXtsZXQgbj1lLm5hbWUsYT1uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkscj1cImdldFwiK2ErXCJBdE91dENvb3Jkc1wiLHM9dC50ZXhTaGFwZSxpPWUuc2hhcGVJbmZvLnRleFNoYXBlLG89ZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCxsPXQubG9naWNhbFNoYXBlLmxlbmd0aDtpZighZS5zaGFwZUluZm8uaXNVbmlmb3JtJiZvPT09bCYmZS5zaGFwZUluZm8uZmxhdE9mZnNldD09bnVsbCYmdy5hcnJheXNFcXVhbChpLHMpKXJldHVybmBcbiAgICAgIGZsb2F0ICR7cn0oKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bn0sIHJlc3VsdFVWKTtcbiAgICAgIH1cbiAgICBgO2xldCB1PWh0KGwpLHA9c0EoZS5zaGFwZUluZm8ubG9naWNhbFNoYXBlLHQubG9naWNhbFNoYXBlKSxkPWwtbyxjLGg9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTtvPT09MD9jPVwiXCI6bDwyJiZwLmxlbmd0aD49MT9jPVwiY29vcmRzID0gMDtcIjpjPXAubWFwKGY9PmBjb29yZHMuJHtoW2YrZF19ID0gMDtgKS5qb2luKGBcbmApO2xldCBtPVwiXCI7cmV0dXJuIGw8MiYmbz4wP209XCJjb29yZHNcIjptPWUuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5tYXAoKGYsZyk9PmBjb29yZHMuJHtoW2crZF19YCkuam9pbihcIiwgXCIpLGBcbiAgICBmbG9hdCAke3J9KCkge1xuICAgICAgJHt1fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICR7Y31cbiAgICAgIHJldHVybiBnZXQke2F9KCR7bX0pO1xuICAgIH1cbiAgYH1mdW5jdGlvbiBodChlKXtpZihlPD0xKXJldHVyblwiaW50XCI7aWYoZT09PTIpcmV0dXJuXCJpdmVjMlwiO2lmKGU9PT0zKXJldHVyblwiaXZlYzNcIjtpZihlPT09NClyZXR1cm5cIml2ZWM0XCI7aWYoZT09PTUpcmV0dXJuXCJpdmVjNVwiO2lmKGU9PT02KXJldHVyblwiaXZlYzZcIjt0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7ZX0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX1mdW5jdGlvbiB0ayhlLHQsbil7bGV0e25ld1NoYXBlOmEsa2VwdERpbXM6cn09dy5zcXVlZXplU2hhcGUodCkscz10Lmxlbmd0aCxpPWUmJnM9PT0zJiZ0WzBdPT09MSxvPWk/dC5zbGljZSgxKTphLGw9IWUmJnM+MSYmIXcuYXJyYXlzRXF1YWwodCxuKSYmYS5sZW5ndGg8c3x8aTtyZXR1cm57dXNlU3F1ZWV6ZVNoYXBlOmwsdW5pZm9ybVNoYXBlOmw/bzp0LGtlcHREaW1zOnJ9fWZ1bmN0aW9uIGNwKGUsdCl7bGV0IG49SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlKSk7cmV0dXJuIG4uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZT10LG59ZnVuY3Rpb24gZHAoZSx0KXtyZXR1cm4gdC5tYXAobj0+ZVtuXSkuam9pbihcIiwgXCIpfWZ1bmN0aW9uIEI5KGUsdCxuLGEpe2xldCByPW4ubWFwKChwLGQpPT57bGV0IGM9e2xvZ2ljYWxTaGFwZTpwLnNoYXBlLHRleFNoYXBlOnAuaXNVbmlmb3JtP251bGw6cC50ZXhEYXRhLnRleFNoYXBlLGlzVW5pZm9ybTpwLmlzVW5pZm9ybSxpc1BhY2tlZDpwLmlzVW5pZm9ybT8hMTpwLnRleERhdGEuaXNQYWNrZWQsZmxhdE9mZnNldDpudWxsfTtyZXR1cm4gcC50ZXhEYXRhIT1udWxsJiZwLnRleERhdGEuc2xpY2UhPW51bGwmJnAudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0PjAmJihjLmZsYXRPZmZzZXQ9cC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQpLHtuYW1lOnQudmFyaWFibGVOYW1lc1tkXSxzaGFwZUluZm86Y319KSxzPXIubWFwKHA9PnAuc2hhcGVJbmZvKSxpPXtsb2dpY2FsU2hhcGU6YS5zaGFwZSx0ZXhTaGFwZTphLnRleERhdGEudGV4U2hhcGUsaXNVbmlmb3JtOiExLGlzUGFja2VkOmEudGV4RGF0YS5pc1BhY2tlZCxmbGF0T2Zmc2V0Om51bGx9LG89czkocixpLHQpLGw9UF8oZS5nbCxvKSx1PWUuY3JlYXRlUHJvZ3JhbShsKTtyZXR1cm4gRygpLmdldChcIkVOR0lORV9DT01QSUxFX09OTFlcIik/e3Byb2dyYW06dCxmcmFnbWVudFNoYWRlcjpsLHNvdXJjZTpvLHdlYkdMUHJvZ3JhbTp1LGluU2hhcGVJbmZvczpzLG91dFNoYXBlSW5mbzppLHZhcmlhYmxlc0xvY2F0aW9uczpudWxsLGN1c3RvbVVuaWZvcm1Mb2NhdGlvbnM6bnVsbCxpbmZMb2M6bnVsbCxuYW5Mb2M6bnVsbCxvdXRTaGFwZUxvY2F0aW9uOm51bGwsb3V0U2hhcGVTdHJpZGVzTG9jYXRpb246bnVsbCxvdXRUZXhTaGFwZUxvY2F0aW9uOm51bGx9OihlLmJ1aWxkVmFvKHUpLE9iamVjdC5hc3NpZ24oe3Byb2dyYW06dCxmcmFnbWVudFNoYWRlcjpsLHNvdXJjZTpvLHdlYkdMUHJvZ3JhbTp1LGluU2hhcGVJbmZvczpzLG91dFNoYXBlSW5mbzppfSxsQShlLHQsdSkpKX1mdW5jdGlvbiBsQShlLHQsbil7bGV0IGE9W10scj1bXSxzLGksbyxsPW51bGwsdT1udWxsO3U9ZS5nZXRVbmlmb3JtTG9jYXRpb24obixcIk5BTlwiLCExKSxHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTEmJihsPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sXCJJTkZJTklUWVwiLCExKSk7bGV0IHA9ITE7Zm9yKGxldCBkIG9mIHQudmFyaWFibGVOYW1lcyl7bGV0IGM9e25hbWU6ZCx1bmlmb3JtOmUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sZCxwKSxvZmZzZXQ6ZS5nZXRVbmlmb3JtTG9jYXRpb24obixgb2Zmc2V0JHtkfWAscCl9O3QuZW5hYmxlU2hhcGVVbmlmb3JtcyYmKGMuc2hhcGU9ZS5nZXRVbmlmb3JtTG9jYXRpb24obixgJHtkfVNoYXBlYCxwKSxjLnRleFNoYXBlPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sYCR7ZH1UZXhTaGFwZWAscCkpLGEucHVzaChjKX1pZih0LmVuYWJsZVNoYXBlVW5pZm9ybXMmJihzPWUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sXCJvdXRTaGFwZVwiLHApLG89ZS5nZXRVbmlmb3JtTG9jYXRpb24obixcIm91dFNoYXBlU3RyaWRlc1wiLHApLGk9ZS5nZXRVbmlmb3JtTG9jYXRpb24obixcIm91dFRleFNoYXBlXCIscCkpLHQuY3VzdG9tVW5pZm9ybXMpZm9yKGxldCBkIG9mIHQuY3VzdG9tVW5pZm9ybXMpci5wdXNoKGUuZ2V0VW5pZm9ybUxvY2F0aW9uKG4sZC5uYW1lLHApKTtyZXR1cm57dmFyaWFibGVzTG9jYXRpb25zOmEsY3VzdG9tVW5pZm9ybUxvY2F0aW9uczpyLGluZkxvYzpsLG5hbkxvYzp1LG91dFNoYXBlTG9jYXRpb246cyxvdXRTaGFwZVN0cmlkZXNMb2NhdGlvbjpvLG91dFRleFNoYXBlTG9jYXRpb246aX19ZnVuY3Rpb24gblMoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IEVycm9yKGBCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggJHtlLmxlbmd0aH0gaW5wdXRzLCBidXQgd2FzIGV4ZWN1dGVkIHdpdGggJHt0Lmxlbmd0aH0gaW5wdXRzYCk7ZS5mb3JFYWNoKChuLGEpPT57bGV0IHI9bi5sb2dpY2FsU2hhcGUscz10W2FdLGk9cy5zaGFwZTtpZighdy5hcnJheXNFcXVhbChyLGkpKXRocm93IEVycm9yKGBCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyAke3J9IGFuZCAke2l9IG11c3QgbWF0Y2hgKTtpZihuLmlzVW5pZm9ybSYmcy5pc1VuaWZvcm0pcmV0dXJuO2xldCBvPW4udGV4U2hhcGUsbD1zLmlzVW5pZm9ybT9udWxsOnMudGV4RGF0YS50ZXhTaGFwZTtpZighdy5hcnJheXNFcXVhbChvLGwpKXRocm93IEVycm9yKGBCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHRleHR1cmUgc2hhcGVzIHRoYW4gdGhlIGN1cnJlbnQgYXJncy4gU2hhcGUgJHtvfSBhbmQgJHtsfSBtdXN0IG1hdGNoYCl9KX1mdW5jdGlvbiBWOShlLHQsbixhLHIpe3QucHJvZ3JhbS5lbmFibGVTaGFwZVVuaWZvcm1zfHwoblModC5pblNoYXBlSW5mb3MsbiksblMoW3Qub3V0U2hhcGVJbmZvXSxbYV0pKTtsZXQgcz1hLnRleERhdGEudGV4dHVyZSxpPWEudGV4RGF0YS50ZXhTaGFwZTthLnRleERhdGEuaXNQYWNrZWQ/ZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlKHMudGV4dHVyZSxpWzBdLGlbMV0pOmUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShzLnRleHR1cmUsaVswXSxpWzFdKSxlLnNldFByb2dyYW0odC53ZWJHTFByb2dyYW0pLGUuYmluZFZlcnRleEFycmF5KHQud2ViR0xQcm9ncmFtLnZhbyksRygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0xJiZ0LmluZkxvYyE9PW51bGwmJmUuZ2wudW5pZm9ybTFmKHQuaW5mTG9jLDEvMCksdC5uYW5Mb2MhPT1udWxsJiZlLmdsLnVuaWZvcm0xZih0Lm5hbkxvYyxOYU4pO2ZvcihsZXQgbD0wO2w8bi5sZW5ndGg7KytsKXtsZXQgdT1uW2xdLHt1bmlmb3JtOnAsb2Zmc2V0OmQsc2hhcGU6Yyx0ZXhTaGFwZTpofT10LnZhcmlhYmxlc0xvY2F0aW9uc1tsXTtpZihjKXtsZXR7dW5pZm9ybVNoYXBlOm19PXRrKHQucHJvZ3JhbS5wYWNrZWRJbnB1dHMsdS5zaGFwZSx1LnRleERhdGEudGV4U2hhcGUpO3N3aXRjaChtLmxlbmd0aCl7Y2FzZSAxOmUuZ2wudW5pZm9ybTFpdihjLG5ldyBJbnQzMkFycmF5KG0pKTticmVhaztjYXNlIDI6ZS5nbC51bmlmb3JtMml2KGMsbmV3IEludDMyQXJyYXkobSkpO2JyZWFrO2Nhc2UgMzplLmdsLnVuaWZvcm0zaXYoYyxuZXcgSW50MzJBcnJheShtKSk7YnJlYWs7Y2FzZSA0OmUuZ2wudW5pZm9ybTRpdihjLG5ldyBJbnQzMkFycmF5KG0pKTticmVhaztkZWZhdWx0OmJyZWFrfX1pZihoJiZlLmdsLnVuaWZvcm0yaShoLHUudGV4RGF0YS50ZXhTaGFwZVswXSx1LnRleERhdGEudGV4U2hhcGVbMV0pLHAhPW51bGwpe2lmKHUuaXNVbmlmb3JtKXtpZih3LnNpemVGcm9tU2hhcGUodS5zaGFwZSk8MillLmdsLnVuaWZvcm0xZihwLHUudW5pZm9ybVZhbHVlc1swXSk7ZWxzZXtsZXQgbT11LnVuaWZvcm1WYWx1ZXM7bSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8KG09bmV3IEZsb2F0MzJBcnJheShtKSksZS5nbC51bmlmb3JtMWZ2KHAsbSl9Y29udGludWV9dS50ZXhEYXRhLnNsaWNlIT1udWxsJiZkIT1udWxsJiZlLmdsLnVuaWZvcm0xaShkLHUudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0KSxlLnNldElucHV0TWF0cml4VGV4dHVyZSh1LnRleERhdGEudGV4dHVyZS50ZXh0dXJlLHAsbCl9fWxldCBvPXQub3V0U2hhcGVMb2NhdGlvbjtpZihvKXN3aXRjaChhLnNoYXBlLmxlbmd0aCl7Y2FzZSAxOmUuZ2wudW5pZm9ybTFpdihvLG5ldyBJbnQzMkFycmF5KGEuc2hhcGUpKTticmVhaztjYXNlIDI6ZS5nbC51bmlmb3JtMml2KG8sbmV3IEludDMyQXJyYXkoYS5zaGFwZSkpO2JyZWFrO2Nhc2UgMzplLmdsLnVuaWZvcm0zaXYobyxuZXcgSW50MzJBcnJheShhLnNoYXBlKSk7YnJlYWs7Y2FzZSA0OmUuZ2wudW5pZm9ybTRpdihvLG5ldyBJbnQzMkFycmF5KGEuc2hhcGUpKTticmVhaztkZWZhdWx0OmJyZWFrfWlmKHQub3V0U2hhcGVTdHJpZGVzTG9jYXRpb24pe2xldCBsPXcuY29tcHV0ZVN0cmlkZXMoYS5zaGFwZSk7c3dpdGNoKGEuc2hhcGUubGVuZ3RoKXtjYXNlIDI6ZS5nbC51bmlmb3JtMWl2KHQub3V0U2hhcGVTdHJpZGVzTG9jYXRpb24sbmV3IEludDMyQXJyYXkobCkpO2JyZWFrO2Nhc2UgMzplLmdsLnVuaWZvcm0yaXYodC5vdXRTaGFwZVN0cmlkZXNMb2NhdGlvbixuZXcgSW50MzJBcnJheShsKSk7YnJlYWs7Y2FzZSA0OmUuZ2wudW5pZm9ybTNpdih0Lm91dFNoYXBlU3RyaWRlc0xvY2F0aW9uLG5ldyBJbnQzMkFycmF5KGwpKTticmVhaztkZWZhdWx0OmJyZWFrfX1pZih0Lm91dFRleFNoYXBlTG9jYXRpb24mJmUuZ2wudW5pZm9ybTJpKHQub3V0VGV4U2hhcGVMb2NhdGlvbixhLnRleERhdGEudGV4U2hhcGVbMF0sYS50ZXhEYXRhLnRleFNoYXBlWzFdKSx0LnByb2dyYW0uY3VzdG9tVW5pZm9ybXMmJnIpZm9yKGxldCBsPTA7bDx0LnByb2dyYW0uY3VzdG9tVW5pZm9ybXMubGVuZ3RoOysrbCl7bGV0IHU9dC5wcm9ncmFtLmN1c3RvbVVuaWZvcm1zW2xdLHA9dC5jdXN0b21Vbmlmb3JtTG9jYXRpb25zW2xdLGQ9cltsXTtpZih1LnR5cGU9PT1cImZsb2F0XCIpZS5nbC51bmlmb3JtMWZ2KHAsZCk7ZWxzZSBpZih1LnR5cGU9PT1cInZlYzJcIillLmdsLnVuaWZvcm0yZnYocCxkKTtlbHNlIGlmKHUudHlwZT09PVwidmVjM1wiKWUuZ2wudW5pZm9ybTNmdihwLGQpO2Vsc2UgaWYodS50eXBlPT09XCJ2ZWM0XCIpZS5nbC51bmlmb3JtNGZ2KHAsZCk7ZWxzZSBpZih1LnR5cGU9PT1cImludFwiKWUuZ2wudW5pZm9ybTFpdihwLGQpO2Vsc2UgaWYodS50eXBlPT09XCJpdmVjMlwiKWUuZ2wudW5pZm9ybTJpdihwLGQpO2Vsc2UgaWYodS50eXBlPT09XCJpdmVjM1wiKWUuZ2wudW5pZm9ybTNpdihwLGQpO2Vsc2UgaWYodS50eXBlPT09XCJpdmVjNFwiKWUuZ2wudW5pZm9ybTRpdihwLGQpO2Vsc2UgdGhyb3cgRXJyb3IoYHVuaWZvcm0gdHlwZSAke3UudHlwZX0gaXMgbm90IHN1cHBvcnRlZCB5ZXQuYCl9ZS5leGVjdXRlUHJvZ3JhbSgpfWZ1bmN0aW9uIFU5KGUsdCxuKXtsZXQgYT1cIlwiO3QuY29uY2F0KG4pLmZvckVhY2goaT0+e2xldCBvPWkudGV4RGF0YSE9bnVsbCYmaS50ZXhEYXRhLnNsaWNlIT1udWxsJiZpLnRleERhdGEuc2xpY2UuZmxhdE9mZnNldD4wO2lmKGUuZW5hYmxlU2hhcGVVbmlmb3JtcyYmIWkuaXNVbmlmb3JtKXtsZXQgbD1pLnRleERhdGEudGV4U2hhcGUse3VzZVNxdWVlemVTaGFwZTp1LHVuaWZvcm1TaGFwZTpwLGtlcHREaW1zOmR9PXRrKGUucGFja2VkSW5wdXRzLGkuc2hhcGUsbCksYz1cIlwiLGg9XCJcIixtPVwiXCI7aWYocC5sZW5ndGg9PT0xJiZlLnBhY2tlZElucHV0cyl7bGV0IEk9W01hdGguY2VpbChsWzBdLzIpLE1hdGguY2VpbChsWzFdLzIpXTtjPWAke0lbMF0+MX1fJHtJWzFdPjF9YH1lbHNlIGlmKHAubGVuZ3RoPT09MiYmIWUucGFja2VkSW5wdXRzKWg9YCR7cFswXT4xfV8ke3BbMV0+MX1gO2Vsc2UgaWYocC5sZW5ndGg+MiYmIWUucGFja2VkSW5wdXRzKXtsZXQgST13LmNvbXB1dGVTdHJpZGVzKHApO209YCR7SVswXT09PWxbMV19XyR7SVtJLmxlbmd0aC0xXT09PWxbMV19YH1sZXQgZj1pLnNoYXBlLmxlbmd0aCxnPXAubGVuZ3RoPT09MiYmdy5hcnJheXNFcXVhbChpLnNoYXBlLGwpLGI9dy5zaXplRnJvbVNoYXBlKGkuc2hhcGUpPT09MSx5PVQuZ2V0QnJvYWRjYXN0RGltcyhpLnNoYXBlLG4uc2hhcGUpLHg9IWUucGFja2VkSW5wdXRzJiZmPT09bi5zaGFwZS5sZW5ndGgmJncuYXJyYXlzRXF1YWwobCxuLnRleERhdGEudGV4U2hhcGUpLHY9ZS5wYWNrZWRJbnB1dHN8fHAubGVuZ3RoPjI/XCJcIjpgJHtsWzBdPjF9XyR7bFsxXT4xfWA7YSs9YCR7Zn1fJHt4fV8ke3U/ZDpcIlwifV8ke3AubGVuZ3RofV8ke2J9XyR7eX1fJHtnfV8ke2N9XyR7aH1fJHttfV8ke3Z9XyR7b31gfWVsc2V7bGV0IGw9aS5pc1VuaWZvcm0/XCJ1bmlmb3JtXCI6aS50ZXhEYXRhLnRleFNoYXBlO2ErPWAke2kuc2hhcGV9XyR7bH1fJHtvfWB9fSk7bGV0IHI9ZS51c2VyQ29kZSxzPWUuY29uc3RydWN0b3IubmFtZTtyZXR1cm4gcys9XCJfXCIrYStcIl9cIityK2Ake0coKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpfWAsc31mdW5jdGlvbiB2bihlKXtyZXR1cm4gRygpLmdldEJvb2woXCJXRUJHTF9VU0VfU0hBUEVTX1VOSUZPUk1TXCIpJiZlPD00fXZhciBHOT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dFBhY2tpbmdTY2hlbWU9TmMuREVOU0UsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJ0ZXhTaGFwZVwiLHR5cGU6XCJpdmVjMlwifV07bGV0IHQ9RW4oKTt0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGl2ZWMzIG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoaW50IGluZGV4KSB7XG4gICAgICAgICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP1dmKFtcInJcIixcImNcIixcImRcIl0sZSk6Wm8oW1wiclwiLFwiY1wiLFwiZFwiXSxlKX1cbiAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSkpO1xuICAgICAgICBpbnQgaW5kZXggPSA0ICogKHJlc1RleFJDLnggKiB0ZXhTaGFwZVsxXSArIHJlc1RleFJDLnkpO1xuXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG5cbiAgICAgICAgZm9yIChpbnQgaT0wOyBpPDQ7IGkrKykge1xuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBpbmRleCArIGk7XG4gICAgICAgICAgaXZlYzMgcmMgPSBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGZsYXRJbmRleCk7XG4gICAgICAgICAgcmVzdWx0W2ldID0gZ2V0QShyYy54LCByYy55LCByYy56KTtcbiAgICAgICAgfVxuXG4gICAgICAgICR7dC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGB9fSxIOT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dFBhY2tpbmdTY2hlbWU9TmMuREVOU0UsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJ0ZXhTaGFwZVwiLHR5cGU6XCJpdmVjMlwifV07bGV0IHQ9RW4oKTt0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGl2ZWMzIG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoaW50IGluZGV4KSB7XG4gICAgICAgICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP1dmKFtcInJcIixcImNcIixcImRcIl0sZSk6Wm8oW1wiclwiLFwiY1wiLFwiZFwiXSxlKX1cbiAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSkpO1xuICAgICAgICBpbnQgaW5kZXggPSA0ICogKHJlc1RleFJDLnggKiB0ZXhTaGFwZVsxXSArIHJlc1RleFJDLnkpO1xuXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG5cbiAgICAgICAgZm9yIChpbnQgaT0wOyBpPDQ7IGkrKykge1xuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBpbmRleCArIGk7XG4gICAgICAgICAgaXZlYzMgcmMgPSBvdXRDb29yZHNGcm9tRmxhdEluZGV4KGZsYXRJbmRleCk7XG4gICAgICAgICAgcmVzdWx0W2ldID0gZ2V0Q2hhbm5lbChnZXRBKHJjLngsIHJjLnksIHJjLnopLCB2ZWMyKHJjLnksIHJjLnopKTtcbiAgICAgICAgfVxuXG4gICAgICAgICR7dC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGB9fSxqOT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dFRleFVzYWdlPWNhLkRPV05MT0FEO2xldCB0PUVuKCk7dGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgJHtyQX1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICR7dC5vdXRwdXR9ID0gZW5jb2RlX2Zsb2F0KHgpO1xuICAgICAgfVxuICAgIGB9fSxxOT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMSx0aGlzLm91dFRleFVzYWdlPWNhLkRPV05MT0FEO2xldCB0PUVuKCk7dGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgJHtyQX1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgeCA9IGdldENoYW5uZWwoZ2V0QUF0T3V0Q29vcmRzKCksIHZlYzIoY29vcmRzLnksIGNvb3Jkcy56KSk7XG4gICAgICAgICR7dC5vdXRwdXR9ID0gZW5jb2RlX2Zsb2F0KHgpO1xuICAgICAgfVxuICAgIGB9fSxLOT17UjowLEc6MSxCOjIsQTozfSxhUz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9ITEsbj1cIlJHQkFcIil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJ0ZXhTaGFwZVwiLHR5cGU6XCJpdmVjMlwifV07bGV0IGE9RW4oKTt0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXQgcj1cInJlc3VsdFwiO3QmJihyPVwiZmxvb3IocmVzdWx0ICogMjU1LiArIDAuNSlcIik7bGV0IHM9XCJcIjtmb3IobGV0IGk9MDtpPG4ubGVuZ3RoO2krKyl7bGV0IG89bltpXTtzKz1gXG4gICAgICAgICAgaWYob2Zmc2V0ID09ICR7aX0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1ske0s5W29dfV07XG4gICAgICAgICAgfWB9dGhpcy51c2VyQ29kZT1gXG4gICAgICAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9laygpOlExKGUpfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KGNvb3Jkcyk7XG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuO1xuICAgICAgICBpbnQgb2Zmc2V0ID0gaW1vZChmbGF0SW5kZXgsICR7bi5sZW5ndGh9KTtcblxuICAgICAgICBmbGF0SW5kZXggPSBpZGl2KGZsYXRJbmRleCwgJHtuLmxlbmd0aH0sIDEuKTtcblxuICAgICAgICBpbnQgciA9IGZsYXRJbmRleCAvIHRleFNoYXBlWzFdO1xuICAgICAgICBpZiAociA8IHRleFNoYXBlWzBdKSB7XG4gICAgICAgICAgaW50IGMgPSBpbW9kKGZsYXRJbmRleCwgdGV4U2hhcGVbMV0pO1xuICAgICAgICAgIHZlYzIgdXYgPSAodmVjMihjLCByKSArIGhhbGZDUikgLyB2ZWMyKHRleFNoYXBlWzFdLCB0ZXhTaGFwZVswXSk7XG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSAke2EudGV4dHVyZTJEfShBLCB1dik7XG4gICAgICAgICAgJHtzfVxuICAgICAgICB9XG4gICAgICAgICR7YS5vdXRwdXR9ID0gdmVjNCgke3J9LCAwLiwgMC4sIDAuKTtcbiAgICAgIH1cbiAgICBgfX0sWDk9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PSExKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInRleFNoYXBlXCIsdHlwZTpcIml2ZWMyXCJ9XTtsZXQgbj1FbigpO3RoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpO2xldCBhPVwiXCIscj1cInJlc3VsdFwiO3QmJihyPVwiZmxvb3IocmVzdWx0ICogMjU1LiArIDAuNSlcIik7Zm9yKGxldCBzPTA7czw9MTtzKyspZm9yKGxldCBpPTA7aTw9MTtpKyspe2xldCBvPXMqMitpO2ErPWBcbiAgICAgICAgICBsb2NhbENvb3JkcyA9IGNvb3JkcztcbiAgICAgICAgICBpZihsb2NhbENvb3Jkc1syXSArICR7aX0gPCAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9cIm91dFNoYXBlWzJdXCI6YCR7ZVsyXX1gfSkge1xuICAgICAgICAgIGxvY2FsQ29vcmRzWzJdICs9ICR7aX07XG4gICAgICAgICAgaWYgKGxvY2FsQ29vcmRzWzFdICsgJHtzfSA8ICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP1wib3V0U2hhcGVbMV1cIjpgJHtlWzFdfWB9KSB7XG4gICAgICAgICAgICBsb2NhbENvb3Jkc1sxXSArPSAke3N9O1xuXG4gICAgICAgICAgICBmbGF0SW5kZXggPSBnZXRGbGF0SW5kZXgobG9jYWxDb29yZHMpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gaW1vZChmbGF0SW5kZXgsIDQpO1xuXG4gICAgICAgICAgICBmbGF0SW5kZXggPSBpZGl2KGZsYXRJbmRleCwgNCwgMS4pO1xuXG4gICAgICAgICAgICBpbnQgciA9IGZsYXRJbmRleCAvIHRleFNoYXBlWzFdO1xuICAgICAgICAgICAgaW50IGMgPSBpbW9kKGZsYXRJbmRleCwgdGV4U2hhcGVbMV0pO1xuICAgICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGMsIHIpICsgaGFsZkNSKSAvIHZlYzIodGV4U2hhcGVbMV0sIHRleFNoYXBlWzBdKTtcbiAgICAgICAgICAgIHZhbHVlcyA9ICR7bi50ZXh0dXJlMkR9KEEsIHV2KTtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFske299XSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09IDEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0WyR7b31dID0gdmFsdWVzWzFdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT0gMikge1xuICAgICAgICAgICAgICByZXN1bHRbJHtvfV0gPSB2YWx1ZXNbMl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHRbJHtvfV0gPSB2YWx1ZXNbM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGB9dGhpcy51c2VyQ29kZT1gXG4gICAgICAgICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP2VrKCk6UTEoZSl9XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcbiAgICAgICAgICBpbnQgZmxhdEluZGV4LCByLCBjLCBvZmZzZXQ7XG4gICAgICAgICAgaXZlYzMgbG9jYWxDb29yZHM7XG4gICAgICAgICAgdmVjMiB1djtcbiAgICAgICAgICB2ZWM0IHZhbHVlcztcblxuICAgICAgICAgICR7YX1cblxuICAgICAgICAgICR7bi5vdXRwdXR9ID0gJHtyfTtcbiAgICAgICAgfVxuICAgIGB9fSx1QT17fTtfZSh1QSx7YmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zOigpPT55QSxjcmVhdGVCdWZmZXJGcm9tT3V0cHV0VGV4dHVyZTooKT0+d0EsY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU6KCk9Pm1BLGNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlOigpPT5iQSxjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZTooKT0+aEEsY3JlYXRlSW5kZXhCdWZmZXI6KCk9PmRBLGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU6KCk9PmdBLGNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlOigpPT5mQSxjcmVhdGVWZXJ0ZXhCdWZmZXI6KCk9PmNBLGNyZWF0ZVZlcnRleFNoYWRlcjooKT0+cEEsZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU6KCk9PklBLGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI6KCk9PmtBLGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmU6KCk9Pk5BLGRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcjooKT0+U0EsZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDE2TWF0cml4VGV4dHVyZTooKT0+YWssZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZTooKT0+aWssZ2V0SW50ZXJuYWxGb3JtYXRGb3JGbG9hdDMyTWF0cml4VGV4dHVyZTooKT0+bmssZ2V0SW50ZXJuYWxGb3JtYXRGb3JQYWNrZWRNYXRyaXhUZXh0dXJlOigpPT5zayxnZXRJbnRlcm5hbEZvcm1hdEZvclVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlOigpPT5yayx1cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZTooKT0+eEEsdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlOigpPT52QX0pO2Z1bmN0aW9uIHBBKGUpe2xldCB0PUVuKCksbj1gJHt0LnZlcnNpb259XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICR7dC5hdHRyaWJ1dGV9IHZlYzMgY2xpcFNwYWNlUG9zO1xuICAgICR7dC5hdHRyaWJ1dGV9IHZlYzIgdXY7XG4gICAgJHt0LnZhcnlpbmdWc30gdmVjMiByZXN1bHRVVjtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2VQb3MsIDEpO1xuICAgICAgcmVzdWx0VVYgPSB1djtcbiAgICB9YDtyZXR1cm4gT18oZSxuKX1mdW5jdGlvbiBjQShlKXtsZXQgdD1uZXcgRmxvYXQzMkFycmF5KFstMSwxLDAsMCwxLC0xLC0xLDAsMCwwLDEsMSwwLDEsMSwxLC0xLDAsMSwwXSk7cmV0dXJuIFdfKGUsdCl9ZnVuY3Rpb24gZEEoZSl7bGV0IHQ9bmV3IFVpbnQxNkFycmF5KFswLDEsMiwyLDEsM10pO3JldHVybiBCXyhlLHQpfWZ1bmN0aW9uIEFkKGUsdCxuLGEscixzKXtVXyh0LG4pO2xldCBpPVZfKGUpLG89ZS5URVhUVVJFXzJEO3JldHVybiBkZShlLCgpPT5lLmJpbmRUZXh0dXJlKG8saSkpLGRlKGUsKCk9PmUudGV4UGFyYW1ldGVyaShvLGUuVEVYVFVSRV9XUkFQX1MsZS5DTEFNUF9UT19FREdFKSksZGUoZSwoKT0+ZS50ZXhQYXJhbWV0ZXJpKG8sZS5URVhUVVJFX1dSQVBfVCxlLkNMQU1QX1RPX0VER0UpKSxkZShlLCgpPT5lLnRleFBhcmFtZXRlcmkobyxlLlRFWFRVUkVfTUlOX0ZJTFRFUixlLk5FQVJFU1QpKSxkZShlLCgpPT5lLnRleFBhcmFtZXRlcmkobyxlLlRFWFRVUkVfTUFHX0ZJTFRFUixlLk5FQVJFU1QpKSxHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTE/ZGUoZSwoKT0+ZS50ZXhJbWFnZTJEKG8sMCxhLHQsbiwwLHIscyxudWxsKSk6ZGUoZSwoKT0+ZS50ZXhTdG9yYWdlMkQobywxLGEsdCxuKSksZGUoZSwoKT0+ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCkpLHt0ZXh0dXJlOmksdGV4U2hhcGU6W24sdF19fWZ1bmN0aW9uIG5rKGUpe3JldHVybiBlLmludGVybmFsRm9ybWF0RmxvYXR9ZnVuY3Rpb24gaEEoZSx0LG4sYSl7bGV0W3Isc109X2QodCxuKTtyZXR1cm4gQWQoZSxyLHMsbmsoYSksYS50ZXh0dXJlRm9ybWF0RmxvYXQsZS5GTE9BVCl9ZnVuY3Rpb24gYWsoZSl7cmV0dXJuIGUuaW50ZXJuYWxGb3JtYXRIYWxmRmxvYXR9ZnVuY3Rpb24gbUEoZSx0LG4sYSl7bGV0W3Isc109X2QodCxuKTtyZXR1cm4gQWQoZSxyLHMsYWsoYSksYS50ZXh0dXJlRm9ybWF0RmxvYXQsYS50ZXh0dXJlVHlwZUhhbGZGbG9hdCl9ZnVuY3Rpb24gcmsoZSl7cmV0dXJuIGUuZG93bmxvYWRUZXh0dXJlRm9ybWF0fWZ1bmN0aW9uIGZBKGUsdCxuLGEpe2xldFtyLHNdPV9kKHQsbik7cmV0dXJuIEFkKGUscixzLHJrKGEpLGUuUkdCQSxlLlVOU0lHTkVEX0JZVEUpfWZ1bmN0aW9uIHNrKGUpe3JldHVybiBlLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXR9ZnVuY3Rpb24gZ0EoZSx0LG4sYSl7bGV0W3Isc109b3AodCxuKTtyZXR1cm4gQWQoZSxyLHMsc2soYSksZS5SR0JBLGUuRkxPQVQpfWZ1bmN0aW9uIGlrKGUpe3JldHVybiBlLmludGVybmFsRm9ybWF0UGFja2VkSGFsZkZsb2F0fWZ1bmN0aW9uIGJBKGUsdCxuLGEpe2xldFtyLHNdPW9wKHQsbik7cmV0dXJuIEFkKGUscixzLGlrKGEpLGUuUkdCQSxhLnRleHR1cmVUeXBlSGFsZkZsb2F0KX1mdW5jdGlvbiB5QShlLHQsbil7cmV0dXJuIGRlKGUsKCk9PmUuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUixuKSkscHYoZSx0LFwiY2xpcFNwYWNlUG9zXCIsbiwzLDIwLDApJiZwdihlLHQsXCJ1dlwiLG4sMiwyMCwxMil9ZnVuY3Rpb24geEEoZSx0LG4sYSxyLHMpe2RlKGUsKCk9PmUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELHQpKTtsZXQgaSxvLGw7ciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/KGk9bmV3IFVpbnQ4QXJyYXkobiphKjQpLG89ZS5VTlNJR05FRF9CWVRFLGw9ZS5SR0JBKTooaT1uZXcgRmxvYXQzMkFycmF5KG4qYSo0KSxvPWUuRkxPQVQsbD1zLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQpLGkuc2V0KHIpLEcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mj9kZShlLCgpPT5lLnRleFN1YkltYWdlMkQoZS5URVhUVVJFXzJELDAsMCwwLG4sYSxlLlJHQkEsbyxpKSk6ZGUoZSwoKT0+ZS50ZXhJbWFnZTJEKGUuVEVYVFVSRV8yRCwwLGwsbixhLDAsZS5SR0JBLG8saSkpLGRlKGUsKCk9PmUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELG51bGwpKX1mdW5jdGlvbiB2QShlLHQsbil7ZGUoZSwoKT0+ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsdCkpLG4uZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/RygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0yP2RlKGUsKCk9PmUudGV4U3ViSW1hZ2UyRChlLlRFWFRVUkVfMkQsMCwwLDAsbi53aWR0aCxuLmhlaWdodCxlLlJHQkEsZS5VTlNJR05FRF9CWVRFLG4uZGF0YSkpOmRlKGUsKCk9PmUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxlLlJHQkEsbi53aWR0aCxuLmhlaWdodCwwLGUuUkdCQSxlLlVOU0lHTkVEX0JZVEUsbi5kYXRhKSk6RygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0yP2RlKGUsKCk9PmUudGV4U3ViSW1hZ2UyRChlLlRFWFRVUkVfMkQsMCwwLDAsZS5SR0JBLGUuVU5TSUdORURfQllURSxuKSk6ZGUoZSwoKT0+ZS50ZXhJbWFnZTJEKGUuVEVYVFVSRV8yRCwwLGUuUkdCQSxlLlJHQkEsZS5VTlNJR05FRF9CWVRFLG4pKSxkZShlLCgpPT5lLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSl9ZnVuY3Rpb24gd0EoZSx0LG4sYSl7bGV0IHI9ZS5jcmVhdGVCdWZmZXIoKTtkZShlLCgpPT5lLmJpbmRCdWZmZXIoZS5QSVhFTF9QQUNLX0JVRkZFUixyKSk7bGV0IHM9NCo0KnQqbjtyZXR1cm4gZGUoZSwoKT0+ZS5idWZmZXJEYXRhKGUuUElYRUxfUEFDS19CVUZGRVIscyxlLlNUUkVBTV9SRUFEKSksZGUoZSwoKT0+ZS5yZWFkUGl4ZWxzKDAsMCxuLHQsZS5SR0JBLGUuRkxPQVQsMCkpLGRlKGUsKCk9PmUuYmluZEJ1ZmZlcihlLlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpKSxyfWZ1bmN0aW9uIGtBKGUsdCxuKXtsZXQgYT1lLHI9bmV3IEZsb2F0MzJBcnJheShuKTtyZXR1cm4gYS5iaW5kQnVmZmVyKGEuUElYRUxfUEFDS19CVUZGRVIsdCksYS5nZXRCdWZmZXJTdWJEYXRhKGEuUElYRUxfUEFDS19CVUZGRVIsMCxyKSxhLmJpbmRCdWZmZXIoYS5QSVhFTF9QQUNLX0JVRkZFUixudWxsKSxyfWZ1bmN0aW9uIElBKGUsdCxuLGEpe2xldFtyLHNdPV9kKHQsbiksaT00LG89bmV3IFVpbnQ4QXJyYXkoSEoodCpuLGkpKTtyZXR1cm4gZGUoZSwoKT0+ZS5yZWFkUGl4ZWxzKDAsMCxyLHMsYS5kb3dubG9hZFRleHR1cmVGb3JtYXQsZS5VTlNJR05FRF9CWVRFLG8pKSxuZXcgRmxvYXQzMkFycmF5KG8uYnVmZmVyKX1mdW5jdGlvbiBTQShlLHQsbixhLHIscyxpLG8pe2xldCBsPWUsdT1uZXcgRmxvYXQzMkFycmF5KGpKKHMsaSkpO3JldHVybiBsLmJpbmRCdWZmZXIobC5QSVhFTF9QQUNLX0JVRkZFUix0KSxsLmdldEJ1ZmZlclN1YkRhdGEobC5QSVhFTF9QQUNLX0JVRkZFUiwwLHUpLGwuYmluZEJ1ZmZlcihsLlBJWEVMX1BBQ0tfQlVGRkVSLG51bGwpLHV9ZnVuY3Rpb24gTkEoZSx0LG4pe2xldCBhPW5ldyBGbG9hdDMyQXJyYXkodCpuKjQpO3JldHVybiBkZShlLCgpPT5lLnJlYWRQaXhlbHMoMCwwLG4sdCxlLlJHQkEsZS5GTE9BVCxhKSksYX12YXIgV2g9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5vdXRwdXRUZXh0dXJlPW51bGwsdGhpcy5wcm9ncmFtPW51bGwsdGhpcy5kaXNwb3NlZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdO2xldCB0PUcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpO2lmKGUhPW51bGw/KHRoaXMuZ2w9ZSxEXyh0LGUpKTp0aGlzLmdsPWphKHQpLGU9dGhpcy5nbCxHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT09PTIpe2xldCByPWU7dGhpcy5jcmVhdGVWZXJ0ZXhBcnJheT0oKT0+ZGUociwoKT0+ci5jcmVhdGVWZXJ0ZXhBcnJheSgpKSx0aGlzLmJpbmRWZXJ0ZXhBcnJheT1zPT5kZShyLCgpPT5yLmJpbmRWZXJ0ZXhBcnJheShzKSksdGhpcy5kZWxldGVWZXJ0ZXhBcnJheT1zPT5kZShyLCgpPT5yLmRlbGV0ZVZlcnRleEFycmF5KHMpKSx0aGlzLmdldFZlcnRleEFycmF5PSgpPT5kZShyLCgpPT5yLmdldFBhcmFtZXRlcihyLlZFUlRFWF9BUlJBWV9CSU5ESU5HKSl9ZWxzZSBpZihlIT1udWxsKXtsZXQgcj1lLmdldEV4dGVuc2lvbihcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpO2lmKHI9PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiQWxsIFdlYkdMMSBpbXBsZW1lbnRhdGlvbnMgYXJlIGV4cGVjdGVkIHRvIG9mZmVyIE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0LlwiKTt0aGlzLmNyZWF0ZVZlcnRleEFycmF5PSgpPT5kZShlLCgpPT5yLmNyZWF0ZVZlcnRleEFycmF5T0VTKCkpLHRoaXMuYmluZFZlcnRleEFycmF5PXM9PmRlKGUsKCk9PnIuYmluZFZlcnRleEFycmF5T0VTKHMpKSx0aGlzLmRlbGV0ZVZlcnRleEFycmF5PXM9PmRlKGUsKCk9PnIuZGVsZXRlVmVydGV4QXJyYXlPRVMocykpLHRoaXMuZ2V0VmVydGV4QXJyYXk9KCk9PmRlKGUsKCk9PmUuZ2V0UGFyYW1ldGVyKHIuVkVSVEVYX0FSUkFZX0JJTkRJTkdfT0VTKSl9bGV0IG49XCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIixhPVwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCI7aWYodGhpcy5wYXJhbGxlbENvbXBpbGF0aW9uRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiS0hSX3BhcmFsbGVsX3NoYWRlcl9jb21waWxlXCIpLEcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09MSl7bGV0IHI9XCJPRVNfdGV4dHVyZV9mbG9hdFwiLHM9XCJPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XCI7aWYodGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb249cmModGhpcy5nbCxyKSxkYSh0aGlzLmdsLHMpKXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbj1yYyh0aGlzLmdsLHMpO2Vsc2UgaWYoRygpLmdldChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiKSl0aHJvdyBuZXcgRXJyb3IoXCJHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgaGFsZiBmbG9hdCB0ZXh0dXJlcywgeWV0IHRoZSBlbnZpcm9ubWVudCBmbGFnIFdFQkdMX0ZPUkNFX0YxNl9URVhUVVJFUyBpcyBzZXQgdG8gdHJ1ZS5cIik7aWYodGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKG4pLGRhKHRoaXMuZ2wsYSkpdGhpcy5jb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbj1yYyh0aGlzLmdsLGEpO2Vsc2UgaWYoRygpLmdldChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiKSl0aHJvdyBuZXcgRXJyb3IoXCJHTCBjb250ZXh0IGRvZXMgbm90IHN1cHBvcnQgY29sb3IgcmVuZGVyYWJsZSBoYWxmIGZsb2F0cywgeWV0IHRoZSBlbnZpcm9ubWVudCBmbGFnIFdFQkdMX0ZPUkNFX0YxNl9URVhUVVJFUyBpcyBzZXQgdG8gdHJ1ZS5cIil9ZWxzZSBpZihuPVwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiLGRhKHRoaXMuZ2wsbikpdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKG4pO2Vsc2UgaWYoZGEodGhpcy5nbCxhKSl0aGlzLmNvbG9yQnVmZmVySGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKGEpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGNvbG9yIHJlbmRlcmFibGUgZmxvYXRzXCIpO3RoaXMudmVydGV4QnVmZmVyPWNBKHRoaXMuZ2wpLHRoaXMuaW5kZXhCdWZmZXI9ZEEodGhpcy5nbCksdGhpcy5mcmFtZWJ1ZmZlcj1HXyh0aGlzLmdsKSx0aGlzLnRleHR1cmVDb25maWc9WjEodGhpcy5nbCx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pfWdldCBkZWJ1Zygpe3JldHVybiBHKCkuZ2V0Qm9vbChcIkRFQlVHXCIpfWRpc3Bvc2UoKXtpZih0aGlzLmRpc3Bvc2VkKXJldHVybjt0aGlzLnByb2dyYW0hPW51bGwmJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIFdlYkdMUHJvZ3JhbS4gVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuXCIpLHRoaXMub3V0cHV0VGV4dHVyZSE9bnVsbCYmY29uc29sZS53YXJuKFwiRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0IG1hdHJpeCB0ZXh0dXJlIHdpdGggR1BHUFVDb250ZXh0LmRlbGV0ZU1hdHJpeFRleHR1cmUgYmVmb3JlIGRpc3Bvc2luZy5cIik7bGV0IGU9dGhpcy5nbDtkZShlLCgpPT5lLmZpbmlzaCgpKSxkZShlLCgpPT5lLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpKSxkZShlLCgpPT5lLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpKSxkZShlLCgpPT5lLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsbnVsbCkpLGRlKGUsKCk9PmUuYmluZEJ1ZmZlcihlLkVMRU1FTlRfQVJSQVlfQlVGRkVSLG51bGwpKSxkZShlLCgpPT5lLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyKSksdGhpcy5kaXNwb3NlZD0hMH1jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZShlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGhBKHRoaXMuZ2wsZSx0LHRoaXMudGV4dHVyZUNvbmZpZyl9Y3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmUoZSx0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxtQSh0aGlzLmdsLGUsdCx0aGlzLnRleHR1cmVDb25maWcpfWNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZkEodGhpcy5nbCxlLHQsdGhpcy50ZXh0dXJlQ29uZmlnKX11cGxvYWRQaXhlbERhdGFUb1RleHR1cmUoZSx0KXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHZBKHRoaXMuZ2wsZSx0KX11cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZShlLHQsbixhKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHhBKHRoaXMuZ2wsZSx0LG4sYSx0aGlzLnRleHR1cmVDb25maWcpfWNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksYkEodGhpcy5nbCxlLHQsdGhpcy50ZXh0dXJlQ29uZmlnKX1jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKGUsdCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZ0EodGhpcy5nbCxlLHQsdGhpcy50ZXh0dXJlQ29uZmlnKX1kZWxldGVNYXRyaXhUZXh0dXJlKGUpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5vdXRwdXRUZXh0dXJlPT09ZSYmKGN2KHRoaXMuZ2wsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5vdXRwdXRUZXh0dXJlPW51bGwpLGRlKHRoaXMuZ2wsKCk9PnRoaXMuZ2wuZGVsZXRlVGV4dHVyZShlKSl9ZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmUoZSx0LG4pe3JldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKGUsKCk9PklBKHRoaXMuZ2wsdCxuLHRoaXMudGV4dHVyZUNvbmZpZykpfWRvd25sb2FkUGFja2VkTWF0cml4RnJvbUJ1ZmZlcihlLHQsbixhLHIscyl7cmV0dXJuIFNBKHRoaXMuZ2wsZSx0LG4sYSxyLHMsdGhpcy50ZXh0dXJlQ29uZmlnKX1kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKGUsdCl7cmV0dXJuIGtBKHRoaXMuZ2wsZSx0KX1jcmVhdGVCdWZmZXJGcm9tVGV4dHVyZShlLHQsbil7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoZSk7bGV0IGE9d0EodGhpcy5nbCx0LG4sdGhpcy50ZXh0dXJlQ29uZmlnKTtyZXR1cm4gdGhpcy51bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcigpLGF9Y3JlYXRlQW5kV2FpdEZvckZlbmNlKCl7bGV0IGU9dGhpcy5jcmVhdGVGZW5jZSh0aGlzLmdsKTtyZXR1cm4gdGhpcy5wb2xsRmVuY2UoZSl9Y3JlYXRlRmVuY2UoZSl7bGV0IHQsbjtpZihHKCkuZ2V0Qm9vbChcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIpKXtsZXQgYT1lLHI9YS5mZW5jZVN5bmMoYS5TWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSwwKTtlLmZsdXNoKCksbj0oKT0+e2xldCBzPWEuY2xpZW50V2FpdFN5bmMociwwLDApO3JldHVybiBzPT09YS5BTFJFQURZX1NJR05BTEVEfHxzPT09YS5DT05ESVRJT05fU0FUSVNGSUVEfSx0PXJ9ZWxzZSBHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik+MD8odD10aGlzLmJlZ2luUXVlcnkoKSx0aGlzLmVuZFF1ZXJ5KCksbj0oKT0+dGhpcy5pc1F1ZXJ5QXZhaWxhYmxlKHQsRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKSk6bj0oKT0+ITA7cmV0dXJue3F1ZXJ5OnQsaXNGZW5jZVBhc3NlZDpufX1kb3dubG9hZE1hdHJpeEZyb21QYWNrZWRUZXh0dXJlKGUsdCxuKXtyZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcihlLCgpPT5OQSh0aGlzLmdsLHQsbikpfWNyZWF0ZVByb2dyYW0oZSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTtsZXQgdD10aGlzLmdsO3RoaXMudmVydGV4U2hhZGVyPT1udWxsJiYodGhpcy52ZXJ0ZXhTaGFkZXI9cEEodCkpO2xldCBuPUxfKHQpO2RlKHQsKCk9PnQuYXR0YWNoU2hhZGVyKG4sdGhpcy52ZXJ0ZXhTaGFkZXIpKSxkZSh0LCgpPT50LmF0dGFjaFNoYWRlcihuLGUpKSx6Xyh0LG4pO2xldCBhPU9iamVjdC5hc3NpZ24obix7dmFvOnRoaXMuY3JlYXRlVmVydGV4QXJyYXkoKX0pO3JldHVybiB0aGlzLmRlYnVnJiZPaCh0LGEpLGF9YnVpbGRWYW8oZSl7dGhpcy5zZXRQcm9ncmFtKGUpLHRoaXMuYmluZFZlcnRleEFycmF5KGUudmFvKTtsZXQgdD10aGlzLmdsO2RlKHQsKCk9PnQuYmluZEJ1ZmZlcih0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLHRoaXMuaW5kZXhCdWZmZXIpKSx5QSh0LGUsdGhpcy52ZXJ0ZXhCdWZmZXIpfWRlbGV0ZVByb2dyYW0oZSl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlPT09dGhpcy5wcm9ncmFtJiYodGhpcy5wcm9ncmFtPW51bGwpLGUhPW51bGwmJihkZSh0aGlzLmdsLCgpPT50aGlzLmdsLmRlbGV0ZVByb2dyYW0oZSkpLHRoaXMuZGVsZXRlVmVydGV4QXJyYXkoZS52YW8pKX1zZXRQcm9ncmFtKGUpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5wcm9ncmFtPWUsdGhpcy5wcm9ncmFtIT1udWxsJiZ0aGlzLmRlYnVnJiZPaCh0aGlzLmdsLHRoaXMucHJvZ3JhbSksZGUodGhpcy5nbCwoKT0+dGhpcy5nbC51c2VQcm9ncmFtKGUpKX1nZXRVbmlmb3JtTG9jYXRpb24oZSx0LG49ITApe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLG4/al8odGhpcy5nbCxlLHQpOnFfKHRoaXMuZ2wsZSx0KX1nZXRBdHRyaWJ1dGVMb2NhdGlvbihlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGRlKHRoaXMuZ2wsKCk9PnRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24oZSx0KSl9Z2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhlLHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsdCl9c2V0SW5wdXRNYXRyaXhUZXh0dXJlKGUsdCxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpLEtfKHRoaXMuZ2wsZSx0LG4pfXNldE91dHB1dE1hdHJpeFRleHR1cmUoZSx0LG4pe3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihlLG4sdCl9c2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZShlLHQsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTtsZXRbYSxyXT1vcCh0LG4pO3RoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihlLGEscil9c2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb24oZSx0LG4sYSl7dGhpcy5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihuLGUsYSx0KX1zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbihlLHQsbixhKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuXCIpfWRlYnVnVmFsaWRhdGUoKXt0aGlzLnByb2dyYW0hPW51bGwmJk9oKHRoaXMuZ2wsdGhpcy5wcm9ncmFtKSxzYyh0aGlzLmdsKX1leGVjdXRlUHJvZ3JhbSgpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy50aHJvd0lmTm9Qcm9ncmFtKCk7bGV0IGU9dGhpcy5nbDtpZih0aGlzLmRlYnVnKXtsZXQgdD10aGlzLmdldFZlcnRleEFycmF5KCk7Y29uc29sZS5hc3NlcnQodD09PXRoaXMucHJvZ3JhbS52YW8sXCJWQU8gY2hhbmdlZCBiZXR3ZWVuIHNldFByb2dyYW0gYW5kIGV4ZWN1dGVQcm9ncmFtIVwiKSx0aGlzLmRlYnVnVmFsaWRhdGUoKX1kZShlLCgpPT5lLmRyYXdFbGVtZW50cyhlLlRSSUFOR0xFUyw2LGUuVU5TSUdORURfU0hPUlQsMCkpfWJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZCgpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksZGUodGhpcy5nbCwoKT0+dGhpcy5nbC5maW5pc2goKSl9Z2V0UXVlcnlUaW1lckV4dGVuc2lvbigpe3JldHVybiB0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbj09bnVsbCYmKHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9uPXJjKHRoaXMuZ2wsRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPT09Mj9cIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIjpcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKSksdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb259Z2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpe3JldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKX1nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCl7cmV0dXJuIHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbigpfWJlZ2luUXVlcnkoKXtpZihHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIik9PT0yKXtsZXQgbj10aGlzLmdsLGE9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCkscj1uLmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIG4uYmVnaW5RdWVyeShhLlRJTUVfRUxBUFNFRF9FWFQscikscn1sZXQgZT10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSx0PWUuY3JlYXRlUXVlcnlFWFQoKTtyZXR1cm4gZS5iZWdpblF1ZXJ5RVhUKGUuVElNRV9FTEFQU0VEX0VYVCx0KSx0fWVuZFF1ZXJ5KCl7aWYoRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpPT09Mil7bGV0IHQ9dGhpcy5nbCxuPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO3QuZW5kUXVlcnkobi5USU1FX0VMQVBTRURfRVhUKTtyZXR1cm59bGV0IGU9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7ZS5lbmRRdWVyeUVYVChlLlRJTUVfRUxBUFNFRF9FWFQpfWFzeW5jIHdhaXRGb3JRdWVyeUFuZEdldFRpbWUoZSl7cmV0dXJuIGF3YWl0IHcucmVwZWF0ZWRUcnkoKCk9PnRoaXMuZGlzcG9zZWR8fHRoaXMuaXNRdWVyeUF2YWlsYWJsZShlLEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSkpLHRoaXMuZ2V0UXVlcnlUaW1lKGUsRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKX1nZXRRdWVyeVRpbWUoZSx0KXtpZih0PT09MClyZXR1cm4gbnVsbDtpZih0PT09Mil7bGV0IG49dGhpcy5nbDtyZXR1cm4gbi5nZXRRdWVyeVBhcmFtZXRlcihlLG4uUVVFUllfUkVTVUxUKS8xZTZ9ZWxzZXtsZXQgbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtyZXR1cm4gbi5nZXRRdWVyeU9iamVjdEVYVChlLG4uUVVFUllfUkVTVUxUX0VYVCkvMWU2fX1pc1F1ZXJ5QXZhaWxhYmxlKGUsdCl7aWYodD09PTApcmV0dXJuITA7aWYodD09PTIpe2xldCBuPXRoaXMuZ2wsYT10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKSxyPW4uZ2V0UXVlcnlQYXJhbWV0ZXIoZSxuLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO3JldHVybiB0aGlzLmRpc2pvaW50PT1udWxsJiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihhLkdQVV9ESVNKT0lOVF9FWFQpKSxyJiYhdGhpcy5kaXNqb2ludH1lbHNle2xldCBuPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpLGE9bi5nZXRRdWVyeU9iamVjdEVYVChlLG4uUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQpO3JldHVybiB0aGlzLmRpc2pvaW50PT1udWxsJiYodGhpcy5kaXNqb2ludD10aGlzLmdsLmdldFBhcmFtZXRlcihuLkdQVV9ESVNKT0lOVF9FWFQpKSxhJiYhdGhpcy5kaXNqb2ludH19cG9sbEZlbmNlKGUpe3JldHVybiBuZXcgUHJvbWlzZSh0PT57dGhpcy5hZGRJdGVtVG9Qb2xsKCgpPT5lLmlzRmVuY2VQYXNzZWQoKSwoKT0+dCgpKX0pfXBvbGxJdGVtcygpe2xldCBlPVk5KHRoaXMuaXRlbXNUb1BvbGwubWFwKHQ9PnQuaXNEb25lRm4pKTtmb3IobGV0IHQ9MDt0PD1lOysrdCl7bGV0e3Jlc29sdmVGbjpufT10aGlzLml0ZW1zVG9Qb2xsW3RdO24oKX10aGlzLml0ZW1zVG9Qb2xsPXRoaXMuaXRlbXNUb1BvbGwuc2xpY2UoZSsxKX1hZGRJdGVtVG9Qb2xsKGUsdCl7aWYodGhpcy5pdGVtc1RvUG9sbC5wdXNoKHtpc0RvbmVGbjplLHJlc29sdmVGbjp0fSksdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGg+MSlyZXR1cm47bGV0IG47XCJzZXRUaW1lb3V0Q3VzdG9tXCJpbiBHKCkucGxhdGZvcm0mJihuPUcoKS5wbGF0Zm9ybS5zZXRUaW1lb3V0Q3VzdG9tLmJpbmQoRygpLnBsYXRmb3JtKSksdy5yZXBlYXRlZFRyeSgoKT0+KHRoaXMucG9sbEl0ZW1zKCksdGhpcy5pdGVtc1RvUG9sbC5sZW5ndGg9PT0wKSwoKT0+MCxudWxsLG4pfWJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcihlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLFBoKHRoaXMuZ2wsZSx0aGlzLmZyYW1lYnVmZmVyKSx0aGlzLmRlYnVnJiZzYyh0aGlzLmdsKX11bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcigpe3RoaXMub3V0cHV0VGV4dHVyZSE9bnVsbD8oUGgodGhpcy5nbCx0aGlzLm91dHB1dFRleHR1cmUsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmc2ModGhpcy5nbCkpOmN2KHRoaXMuZ2wsdGhpcy5mcmFtZWJ1ZmZlcil9ZG93bmxvYWRNYXRyaXhEcml2ZXIoZSx0KXt0aGlzLmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlcihlKTtsZXQgbj10KCk7cmV0dXJuIHRoaXMudW5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIoKSxufXNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIoZSx0LG4pe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCk7bGV0IGE9dGhpcy5nbDtQaChhLGUsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmc2MoYSksdGhpcy5vdXRwdXRUZXh0dXJlPWUsZGUoYSwoKT0+YS52aWV3cG9ydCgwLDAsdCxuKSksZGUoYSwoKT0+YS5zY2lzc29yKDAsMCx0LG4pKX1zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihlLHQsbixhKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLGRlKHRoaXMuZ2wsKCk9PnRoaXMuZ2wuc2Npc3NvcihlLHQsbixhKSl9dGhyb3dJZkRpc3Bvc2VkKCl7aWYodGhpcy5kaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gdXNlIGRpc3Bvc2VkIEdQR1BVQ29udGV4dC5cIil9dGhyb3dJZk5vUHJvZ3JhbSgpe2lmKHRoaXMucHJvZ3JhbT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LlwiKX19O2Z1bmN0aW9uIFk5KGUpe2xldCB0PTA7Zm9yKDt0PGUubGVuZ3RoJiZlW3RdKCk7Kyt0KTtyZXR1cm4gdC0xfXZhcnthZGRJbXBsOlo5LGJpbmNvdW50SW1wbDpUQSxiaW5jb3VudFJlZHVjZUltcGw6SjksYml0d2lzZUFuZEltcGw6UTksY2FzdEltcGw6ZVEsY2VpbEltcGw6dFEsY29uY2F0SW1wbDpuUSxlcXVhbEltcGw6YVEsZXhwSW1wbDpyUSxleHBtMUltcGw6c1EsZmxvb3JJbXBsOmlRLGdhdGhlck5kSW1wbDpvUSxnYXRoZXJWMkltcGw6bFEsZ3JlYXRlckltcGw6dVEsZ3JlYXRlckVxdWFsSW1wbDpwUSxsZXNzSW1wbDpjUSxsZXNzRXF1YWxJbXBsOmRRLGxpblNwYWNlSW1wbDpoUSxsb2dJbXBsOm1RLG1heEltcGw6ZlEsbWF4aW11bUltcGw6Z1EsbWluaW11bUltcGw6YlEsbXVsdGlwbHlJbXBsOnlRLG5lZ0ltcGw6eFEsbm90RXF1YWxJbXBsOnZRLHByb2RJbXBsOndRLHJhZ2dlZEdhdGhlckltcGw6a1EscmFnZ2VkUmFuZ2VJbXBsOklRLHJhZ2dlZFRlbnNvclRvVGVuc29ySW1wbDpTUSxyYW5nZUltcGw6TlEscnNxcnRJbXBsOlRRLHNjYXR0ZXJJbXBsOkNRLHNpZ21vaWRJbXBsOkVRLHNpbXBsZUFic0ltcGw6Q0Esc2xpY2VJbXBsOl9RLHNwYXJzZUZpbGxFbXB0eVJvd3NJbXBsOkFRLHNwYXJzZVJlc2hhcGVJbXBsOkZRLHNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25JbXBsOkVBLHNxcnRJbXBsOiRRLHN0YXRpY1JlZ2V4UmVwbGFjZUltcGw6RFEsc3RyaWRlZFNsaWNlSW1wbDpSUSxzdHJpbmdOR3JhbXNJbXBsOk1RLHN0cmluZ1NwbGl0SW1wbDpPUSxzdHJpbmdUb0hhc2hCdWNrZXRGYXN0SW1wbDpQUSxzdWJJbXBsOkxRLHRpbGVJbXBsOnpRLHRvcEtJbXBsOldRLHRyYW5zcG9zZUltcGw6b2ssdW5pcXVlSW1wbDpCUX09TTE7ZnVuY3Rpb24gX0EoZSx0KXtyZXR1cm5bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAsdCkubWFwKG49PmAke2V9LiR7bn1gKX1mdW5jdGlvbiBJbihlLHQpe3JldHVybiB0PT09MT9bZV06X0EoZSx0KX1mdW5jdGlvbiBWUShlLHQpe2lmKGU9PT0xKXJldHVyblwicmNcIjtsZXQgbj1cIlwiO2ZvcihsZXQgYT0wO2E8ZTthKyspbis9dFthXSxhPGUtMSYmKG4rPVwiLFwiKTtyZXR1cm4gbn12YXIgVVE9Y2xhc3N7Y29uc3RydWN0b3IoZSl7aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMucmFuaz1lLmxlbmd0aCx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpLHRoaXMucmFuaz09PTApdGhpcy51c2VyQ29kZT1gXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBzZXRPdXRwdXQodmVjNChnZXRBKCksIDAuLCAwLiwgMC4pKTtcbiAgICAgICAgfVxuICAgICAgYDtlbHNle2xldCB0PUluKFwicmNcIix0aGlzLnJhbmspLG49aHQodGhpcy5yYW5rKSxhPXRoaXMuZ2V0T3V0T2ZCb3VuZHNDb25kaXRpb24odCkscj10aGlzLmdldFNldHVwKHQpLHM9dGhpcy5nZXRPdXRwdXQodCk7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAke259IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgICBpZigke2F9KSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNCgwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR7cn1cblxuICAgICAgICAgICAgc2V0T3V0cHV0KHZlYzQoJHtzfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYH19Z2V0U291cmNlQ29vcmRzQXJyKGUpe2xldCB0PVtdO2ZvcihsZXQgbj0wO248PTE7bisrKWZvcihsZXQgYT0wO2E8PTE7YSsrKXtsZXQgcj1gJHtuPT09MD9cInJcIjpcInJwMVwifSwgJHthPT09MD9cImNcIjpcImNwMVwifWA7Zm9yKGxldCBzPTI7czx0aGlzLnJhbms7cysrKXI9YCR7ZVtlLmxlbmd0aC0xLXNdfSxgK3I7dC5wdXNoKHIpfXJldHVybiB0fWdldE91dE9mQm91bmRzQ29uZGl0aW9uKGUpe2lmKHRoaXMucmFuaz09PTEpcmV0dXJuYHJjID4gJHt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/XCJvdXRTaGFwZVwiOnRoaXMub3V0cHV0U2hhcGVbMF19YDtsZXQgdD1cIlwiO2ZvcihsZXQgbj10aGlzLnJhbmstMjtuPHRoaXMucmFuaztuKyspdCs9YCR7ZVtuXX0gPj0gJHt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/YG91dFNoYXBlWyR7bn1dYDp0aGlzLm91dHB1dFNoYXBlW25dfWAsbjx0aGlzLnJhbmstMSYmKHQrPVwifHxcIik7cmV0dXJuIHR9Z2V0U2V0dXAoZSl7aWYodGhpcy5yYW5rPT09MSlyZXR1cm5cIlwiO2xldCB0PWUuc2xpY2UoLTIpLG49dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP2BvdXRTaGFwZVske3RoaXMucmFua30gLSAxXWA6dGhpcy5vdXRwdXRTaGFwZVt0aGlzLnJhbmstMV0sYT10aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/YG91dFNoYXBlWyR7dGhpcy5yYW5rfSAtIDJdYDp0aGlzLm91dHB1dFNoYXBlW3RoaXMucmFuay0yXTtyZXR1cm5gXG4gICAgICBpbnQgciA9ICR7dFswXX07XG4gICAgICBpbnQgYyA9ICR7dFsxXX07XG4gICAgICBpbnQgcnAxID0gciArIDE7XG4gICAgICBpbnQgY3AxID0gYyArIDE7XG5cbiAgICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gJHtufTtcbiAgICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gJHthfTtcbiAgICBgfWdldE91dHB1dChlKXtsZXQgdD10aGlzLmdldFNvdXJjZUNvb3Jkc0FycihlKTtyZXR1cm4gdGhpcy5yYW5rPT09MT9gZ2V0QShyYyksIChyYyArIDEgPj0gJHt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/XCJvdXRTaGFwZVwiOnRoaXMub3V0cHV0U2hhcGVbMF19ID8gMC4gOiBnZXRBKHJjICsgMSkpLCAwLCAwYDpgZ2V0QSgke3RbMF19KSxcbiAgICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKCR7dFsxXX0pLFxuICAgICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoJHt0WzJdfSksXG4gICAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QSgke3RbM119KWB9fSxBQT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwiaW5wdXRTaGFwZVwiLHR5cGU6XCJpdmVjM1wifV0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7bGV0IG49XCJcIjtmb3IobGV0IGE9MDthPDQ7YSsrKXtsZXQgcj1cInRoaXNSQyA9IHJjO1wiO2ElMj09PTEmJihyKz1cInRoaXNSQy56ICs9IDE7XCIpLGE+MSYmKHIrPVwidGhpc1JDLnkgKz0gMTtcIiksbis9YFxuICAgICAgICAke3J9XG4gICAgICAgICR7YT4wP1wiaWYodGhpc1JDLnkgPCByb3dzICYmIHRoaXNSQy56IDwgY29scyl7XCI6XCJcIn1cbiAgICAgICAgICBpbnQgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KHRoaXNSQyk7XG5cbiAgICAgICAgICBpdmVjMyBpbnB1dFJDID0gaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoZmxhdEluZGV4KTtcbiAgICAgICAgICB2ZWMyIGlucHV0UkNJbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XG5cbiAgICAgICAgICByZXN1bHRbJHthfV0gPVxuICAgICAgICAgICAgZ2V0Q2hhbm5lbChnZXRBKGlucHV0UkMueCwgaW5wdXRSQy55LCBpbnB1dFJDLnopLCBpbnB1dFJDSW5uZXJEaW1zKTtcbiAgICAgICAgJHthPjA/XCJ9XCI6XCJcIn1cbiAgICAgIGB9dGhpcy51c2VyQ29kZT1gXG4gICAgICAke0dRKHQsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zKX1cbiAgICAgICR7dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP2VrKCk6UTEoZSl9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuXG4gICAgICAgIGl2ZWMzIHRoaXNSQztcbiAgICAgICAgaW50IHJvd3MgPSAke3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9cIm91dFNoYXBlWzFdXCI6ZVsxXX07XG4gICAgICAgIGludCBjb2xzID0gJHt0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/XCJvdXRTaGFwZVsyXVwiOmVbMl19O1xuXG4gICAgICAgICR7bn1cblxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gR1EoZSx0KXtyZXR1cm5gXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XG4gICAgICAke3Q/cjkoW1wiclwiLFwiY1wiLFwiZFwiXSxcImlucHV0U2hhcGVcIik6Wm8oW1wiclwiLFwiY1wiLFwiZFwiXSxlKX1cbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcbiAgICB9XG4gIGB9dmFyIEhRPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuZ3BncHU9ZSx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTAsdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQ9MCx0aGlzLl9udW1CeXRlc0ZyZWU9MCx0aGlzLmZyZWVUZXh0dXJlcz17fSx0aGlzLnVzZWRUZXh0dXJlcz17fSx0aGlzLmxvZ0VuYWJsZWQ9ITF9YWNxdWlyZVRleHR1cmUoZSx0LG4pe2xldCBhPXNTKHQsbikscj1pUyhlLGEsbik7ciBpbiB0aGlzLmZyZWVUZXh0dXJlc3x8KHRoaXMuZnJlZVRleHR1cmVzW3JdPVtdKSxyIGluIHRoaXMudXNlZFRleHR1cmVzfHwodGhpcy51c2VkVGV4dHVyZXNbcl09W10pO2xldCBzPXJTKGUsYSx0aGlzLmdwZ3B1LmdsLHRoaXMuZ3BncHUudGV4dHVyZUNvbmZpZyxuKTtpZih0aGlzLmZyZWVUZXh0dXJlc1tyXS5sZW5ndGg+MCl7dGhpcy5udW1GcmVlVGV4dHVyZXMtLSx0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMuX251bUJ5dGVzRnJlZS09cyx0aGlzLmxvZygpO2xldCBvPXRoaXMuZnJlZVRleHR1cmVzW3JdLnBvcCgpO3JldHVybiB0aGlzLnVzZWRUZXh0dXJlc1tyXS5wdXNoKG8pLG99bGV0IGk7cmV0dXJuIGE9PT1jbi5QQUNLRURfMlgyX0ZMT0FUMzI/aT10aGlzLmdwZ3B1LmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoZVswXSxlWzFdKTphPT09Y24uUEFDS0VEXzJYMl9GTE9BVDE2P2k9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZShlWzBdLGVbMV0pOmE9PT1jbi5VTlBBQ0tFRF9GTE9BVDMyP2k9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZShlWzBdLGVbMV0pOmE9PT1jbi5VTlBBQ0tFRF9GTE9BVDE2P2k9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZShlWzBdLGVbMV0pOmE9PT1jbi5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEUmJihpPXRoaXMuZ3BncHUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUoZVswXSxlWzFdKSksdGhpcy51c2VkVGV4dHVyZXNbcl0ucHVzaChpKSx0aGlzLm51bVVzZWRUZXh0dXJlcysrLHRoaXMuX251bUJ5dGVzQWxsb2NhdGVkKz1zLHRoaXMubG9nKCksaX1yZWxlYXNlVGV4dHVyZShlLHQsbixhKXtpZih0aGlzLmZyZWVUZXh0dXJlcz09bnVsbClyZXR1cm47bGV0IHI9c1MobixhKSxzPWlTKHQscixhKTtzIGluIHRoaXMuZnJlZVRleHR1cmVzfHwodGhpcy5mcmVlVGV4dHVyZXNbc109W10pO2xldCBpPXJTKHQscix0aGlzLmdwZ3B1LmdsLHRoaXMuZ3BncHUudGV4dHVyZUNvbmZpZyxhKSxvPUcoKS5nZXROdW1iZXIoXCJXRUJHTF9ERUxFVEVfVEVYVFVSRV9USFJFU0hPTERcIik7byE9PS0xJiZ0aGlzLl9udW1CeXRlc0FsbG9jYXRlZD5vPyh0aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoZS50ZXh0dXJlKSx0aGlzLl9udW1CeXRlc0FsbG9jYXRlZC09aSk6KHRoaXMuZnJlZVRleHR1cmVzW3NdLnB1c2goZSksdGhpcy5udW1GcmVlVGV4dHVyZXMrKyx0aGlzLl9udW1CeXRlc0ZyZWUrPWkpLHRoaXMubnVtVXNlZFRleHR1cmVzLS07bGV0IGw9dGhpcy51c2VkVGV4dHVyZXNbc10sdT1sJiZsLmluZGV4T2YoZSk7aWYodT09bnVsbHx8dTwwKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWxlYXNlIGEgdGV4dHVyZSB0aGF0IHdhcyBuZXZlciBwcm92aWRlZCBieSB0aGlzIHRleHR1cmUgbWFuYWdlclwiKTtsW3VdPWxbbC5sZW5ndGgtMV0sbC5wb3AoKSx0aGlzLmxvZygpfWxvZygpe2lmKCF0aGlzLmxvZ0VuYWJsZWQpcmV0dXJuO2xldCBlPXRoaXMubnVtRnJlZVRleHR1cmVzK3RoaXMubnVtVXNlZFRleHR1cmVzO2NvbnNvbGUubG9nKFwiRnJlZS9Vc2VkXCIsYCR7dGhpcy5udW1GcmVlVGV4dHVyZXN9IC8gJHt0aGlzLm51bVVzZWRUZXh0dXJlc31gLGAoJHtlfSlgKTtsZXQgdD10aGlzLl9udW1CeXRlc0ZyZWUvdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQ7Y29uc29sZS5sb2coYEJ5dGVzIGFsbG9jYXRlZDogJHt0aGlzLl9udW1CeXRlc0FsbG9jYXRlZH1gKSxjb25zb2xlLmxvZyhgQnl0ZXMgdW51c2VkOiAke3RoaXMuX251bUJ5dGVzRnJlZX0gKCR7TWF0aC5yb3VuZCgxMDAqdCl9JSlgKX1nZXQgbnVtQnl0ZXNBbGxvY2F0ZWQoKXtyZXR1cm4gdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWR9Z2V0IG51bUJ5dGVzRnJlZSgpe3JldHVybiB0aGlzLl9udW1CeXRlc0ZyZWV9Z2V0TnVtVXNlZFRleHR1cmVzKCl7cmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzfWdldE51bUZyZWVUZXh0dXJlcygpe3JldHVybiB0aGlzLm51bUZyZWVUZXh0dXJlc31kaXNwb3NlKCl7aWYodGhpcy5mcmVlVGV4dHVyZXMhPW51bGwpe2ZvcihsZXQgZSBpbiB0aGlzLmZyZWVUZXh0dXJlcyl0aGlzLmZyZWVUZXh0dXJlc1tlXS5mb3JFYWNoKHQ9Pnt0aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodC50ZXh0dXJlKX0pO2ZvcihsZXQgZSBpbiB0aGlzLnVzZWRUZXh0dXJlcyl0aGlzLnVzZWRUZXh0dXJlc1tlXS5mb3JFYWNoKHQ9Pnt0aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodC50ZXh0dXJlKX0pO3RoaXMuZnJlZVRleHR1cmVzPW51bGwsdGhpcy51c2VkVGV4dHVyZXM9bnVsbCx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTAsdGhpcy5fbnVtQnl0ZXNBbGxvY2F0ZWQ9MCx0aGlzLl9udW1CeXRlc0ZyZWU9MH19fTtmdW5jdGlvbiBqUShlLHQpe2xldCBuPWU7aWYodD09PW4uUjMyRilyZXR1cm4gNDtpZih0PT09bi5SMTZGKXJldHVybiAyO2lmKHQ9PT1uLlJHQkEzMkZ8fHQ9PT1lLlJHQkEpcmV0dXJuIDE2O2lmKHQ9PT1uLlJHQkExNkYpcmV0dXJuIDg7aWYodD09PW4uUkdCQTgpcmV0dXJuIDQ7dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGludGVybmFsIGZvcm1hdCAke3R9YCl9ZnVuY3Rpb24gclMoZSx0LG4sYSxyKXtsZXQgcz1xUSh0LGEpLGk7aWYocil7bGV0W2wsdV09b3AoZVswXSxlWzFdKTtpPWwqdX1lbHNle2xldFtsLHVdPV9kKGVbMF0sZVsxXSk7aT1sKnV9bGV0IG89alEobixzKTtyZXR1cm4gaSpvfWZ1bmN0aW9uIHFRKGUsdCl7c3dpdGNoKGUpe2Nhc2UgY24uUEFDS0VEXzJYMl9GTE9BVDMyOnJldHVybiBzayh0KTtjYXNlIGNuLlBBQ0tFRF8yWDJfRkxPQVQxNjpyZXR1cm4gaWsodCk7Y2FzZSBjbi5VTlBBQ0tFRF9GTE9BVDMyOnJldHVybiBuayh0KTtjYXNlIGNuLlVOUEFDS0VEX0ZMT0FUMTY6cmV0dXJuIGFrKHQpO2Nhc2UgY24uUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFOnJldHVybiByayh0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBwaHlzaWNhbCB0ZXh0dXJlIHR5cGUgJHtlfWApfX1mdW5jdGlvbiBLUShlKXtyZXR1cm4gRygpLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpP2U/Y24uUEFDS0VEXzJYMl9GTE9BVDMyOmNuLlVOUEFDS0VEX0ZMT0FUMzI6ZT9jbi5QQUNLRURfMlgyX0ZMT0FUMTY6Y24uVU5QQUNLRURfRkxPQVQxNn1mdW5jdGlvbiBzUyhlLHQpe2lmKGU9PT1jYS5VUExPQUQpcmV0dXJuIGNuLlBBQ0tFRF8yWDJfRkxPQVQzMjtpZihlPT09Y2EuUkVOREVSfHxlPT1udWxsKXJldHVybiBLUSh0KTtpZihlPT09Y2EuRE9XTkxPQUR8fGU9PT1jYS5QSVhFTFMpcmV0dXJuIGNuLlBBQ0tFRF80WDFfVU5TSUdORURfQllURTt0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbG9naWNhbCB0ZXh0dXJlIHR5cGUgJHtlfWApfWZ1bmN0aW9uIGlTKGUsdCxuKXtyZXR1cm5gJHtlWzBdfV8ke2VbMV19XyR7dH1fJHtufWB9dmFyIHJyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCksdGhpcy51c2VyQ29kZT1gXG4gICAgICBmbG9hdCB1bmFyeU9wZXJhdGlvbihmbG9hdCB4KSB7XG4gICAgICAgICR7dH1cbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XG4gICAgICAgIGZsb2F0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcblxuICAgICAgICBzZXRPdXRwdXQoeSk7XG4gICAgICB9XG4gICAgYH19LERhPVwiaWYgKGlzbmFuKHgpKSByZXR1cm4geDtcIixYUT1cInJldHVybiB4O1wiLG9TPVwicmV0dXJuIGFicyh4KTtcIixZUT1cInJldHVybiAoeCA+PSAwLjApID8geCA6IChleHAoeCkgLSAxLjApO1wiLFpRPURhK2BcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XG5gLEpRPURhK2BcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IG1pbig2LjAsIHgpO1xuYCxZcj1cInJldHVybiB4O1wiLFFRPVwicmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHgpKTtcIixlZWU9XCJyZXR1cm4geDtcIix0ZWU9YFxuICB2ZWM0IHJlc3VsdDtcblxuICByZXN1bHQuciA9ICh4LnIgPj0gMC4wKSA/IHguciA6IChleHAoeC5yKSAtIDEuMCk7XG4gIHJlc3VsdC5nID0gKHguZyA+PSAwLjApID8geC5nIDogKGV4cCh4LmcpIC0gMS4wKTtcbiAgcmVzdWx0LmIgPSAoeC5iID49IDAuMCkgPyB4LmIgOiAoZXhwKHguYikgLSAxLjApO1xuICByZXN1bHQuYSA9ICh4LmEgPj0gMC4wKSA/IHguYSA6IChleHAoeC5hKSAtIDEuMCk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbmAsbmVlPWBcbiAgdmVjNCByZXN1bHQgPSB4ICogdmVjNChncmVhdGVyVGhhbkVxdWFsKHgsIHZlYzQoMC4wKSkpO1xuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xuXG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6IHJlc3VsdC5yO1xuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6IHJlc3VsdC5hO1xuXG4gIHJldHVybiByZXN1bHQ7XG5gLGFlZT1gXG4gIHZlYzQgcmVzdWx0ID0gbWluKHgsIHZlYzQoNi4pKSAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcblxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcblxuICByZXR1cm4gcmVzdWx0O1xuYCxyZWU9XCJyZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1wiLHRzPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCksdGhpcy51c2VyQ29kZT1gXG4gICAgICB2ZWM0IHVuYXJ5T3BlcmF0aW9uKHZlYzQgeCkge1xuICAgICAgICAke3R9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xuXG4gICAgICAgIHNldE91dHB1dCh5KTtcbiAgICAgIH1cbiAgICBgfX0sc2VlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSExLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpO2xldCB0PWUubGVuZ3RoLG49SW4oXCJyY1wiLHQpLGE9aHQodCkscj1WUSh0LG4pLHM9bi5zbGljZSgtMiksaT10PD0xP1wicmNcIjpgdmVjMigke3Muam9pbihcIixcIil9KWA7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7YX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCBwYWNrZWRJbnB1dCA9IGdldEEoJHtyfSk7XG5cbiAgICAgICAgc2V0T3V0cHV0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7aX0pKTtcbiAgICAgIH1cbiAgICBgfX0saWVlPW1yLndoZXJlSW1wbCxvZWU9MWUtNyxsZWU9MWUtNCx5eD17fTtmdW5jdGlvbiB1ZWUoZSl7cmV0dXJuIGUgaW4geXh8fCh5eFtlXT17fSkseXhbZV19dmFyIHBlZT1HKCkuZ2V0TnVtYmVyKFwiQ1BVX0hBTkRPRkZfU0laRV9USFJFU0hPTERcIiksY2VlPTYwMDtmdW5jdGlvbiBkZWUoKXtyZXR1cm4gRygpLmdsb2JhbC5zY3JlZW49PW51bGw/MTAyNDpHKCkuZ2xvYmFsLnNjcmVlbi5oZWlnaHQqRygpLmdsb2JhbC5zY3JlZW4ud2lkdGgqd2luZG93LmRldmljZVBpeGVsUmF0aW8qY2VlLzEwMjQvMTAyNH12YXIgbGs9Y2xhc3MgRkEgZXh0ZW5kcyBGY3tuZXh0RGF0YUlkKCl7cmV0dXJuIEZBLm5leHREYXRhSWQrK31jb25zdHJ1Y3Rvcih0KXtpZihzdXBlcigpLHRoaXMucGVuZGluZ1JlYWQ9bmV3IFdlYWtNYXAsdGhpcy5wZW5kaW5nRGlzcG9zYWw9bmV3IFdlYWtTZXQsdGhpcy5kYXRhUmVmQ291bnQ9bmV3IFdlYWtNYXAsdGhpcy5udW1CeXRlc0luR1BVPTAsdGhpcy51cGxvYWRXYWl0TXM9MCx0aGlzLmRvd25sb2FkV2FpdE1zPTAsdGhpcy5sYXN0R2xGbHVzaFRpbWU9MCx0aGlzLndhcm5lZEFib3V0TWVtb3J5PSExLHRoaXMucGVuZGluZ0RlbGV0ZXM9MCx0aGlzLmRpc3Bvc2VkPSExLCFHKCkuZ2V0Qm9vbChcIkhBU19XRUJHTFwiKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlXCIpO2xldCBuO2lmKHQhPW51bGwpe2lmKHQgaW5zdGFuY2VvZiBXaCluPXQ7ZWxzZXtsZXQgYT1qYShHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSx0KTtuPW5ldyBXaChhKX10aGlzLmJpbmFyeUNhY2hlPXt9LHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseT0hMX1lbHNle2xldCBhPWphKEcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpKTtuPW5ldyBXaChhKSx0aGlzLmJpbmFyeUNhY2hlPXVlZShHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSksdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5PSEwfXRoaXMuZ3BncHU9bix0aGlzLmNhbnZhcz10aGlzLmdwZ3B1LmdsLmNhbnZhcyx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBIUSh0aGlzLmdwZ3B1KSx0aGlzLm51bU1CQmVmb3JlV2FybmluZz1kZWUoKSx0aGlzLnRleERhdGE9bmV3IHltKHRoaXMsVGEoKSl9bnVtRGF0YUlkcygpe3JldHVybiB0aGlzLnRleERhdGEubnVtRGF0YUlkcygpLXRoaXMucGVuZGluZ0RlbGV0ZXN9d3JpdGVUZXh0dXJlKHQsbixhLHIscyxpKXtsZXQgbz10aGlzLm1ha2VUZW5zb3JJbmZvKG4sYSksbD10aGlzLnRleERhdGEuZ2V0KG8uZGF0YUlkKTtsLmlzUGFja2VkPSExLGwudGV4dHVyZT17dGV4dHVyZTp0LHRleFNoYXBlOltyLHNdfSxsLnRleFNoYXBlPVtyLHNdO2xldCB1PWljKG4pLHA9bmV3IGFTKHUsITEsaSksZD10aGlzLnJ1bldlYkdMUHJvZ3JhbShwLFtvXSxhLFtbcixzXV0pO3JldHVybiBkLnNoYXBlPW4sbC50ZXh0dXJlPW51bGwsdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxkLmRhdGFJZH13cml0ZSh0LG4sYSl7aWYoKEcoKS5nZXRCb29sKFwiV0VCR0xfQ0hFQ0tfTlVNRVJJQ0FMX1BST0JMRU1TXCIpfHxHKCkuZ2V0Qm9vbChcIkRFQlVHXCIpKSYmdGhpcy5jaGVja051bWVyaWNhbFByb2JsZW1zKHQpLGE9PT1cImNvbXBsZXg2NFwiJiZ0IT1udWxsKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB3cml0ZSB0byBhIGNvbXBsZXg2NCBkdHlwZS4gUGxlYXNlIHVzZSB0Zi5jb21wbGV4KHJlYWwsIGltYWcpLlwiKTtsZXQgcj17aWQ6dGhpcy5uZXh0RGF0YUlkKCl9O3JldHVybiB0aGlzLnRleERhdGEuc2V0KHIse3NoYXBlOm4sZHR5cGU6YSx2YWx1ZXM6dCx1c2FnZTpjYS5VUExPQUQscmVmQ291bnQ6MX0pLHJ9cmVmQ291bnQodCl7cmV0dXJuIHRoaXMudGV4RGF0YS5oYXModCk/dGhpcy50ZXhEYXRhLmdldCh0KS5yZWZDb3VudDowfWluY1JlZih0KXtsZXQgbj10aGlzLnRleERhdGEuZ2V0KHQpO24ucmVmQ291bnQrK31kZWNSZWYodCl7aWYodGhpcy50ZXhEYXRhLmhhcyh0KSl7bGV0IG49dGhpcy50ZXhEYXRhLmdldCh0KTtuLnJlZkNvdW50LS19fW1vdmUodCxuLGEscixzKXtpZihHKCkuZ2V0Qm9vbChcIkRFQlVHXCIpJiZ0aGlzLmNoZWNrTnVtZXJpY2FsUHJvYmxlbXMobikscj09PVwiY29tcGxleDY0XCIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIHRvIGEgY29tcGxleDY0IGR0eXBlLiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMudGV4RGF0YS5zZXQodCx7c2hhcGU6YSxkdHlwZTpyLHZhbHVlczpuLHVzYWdlOmNhLlVQTE9BRCxyZWZDb3VudDpzfSl9ZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCl7dGhpcy5kaXNwb3NlRGF0YSh0LmRhdGFJZCl9cmVhZFN5bmModCl7bGV0IG49dGhpcy50ZXhEYXRhLmdldCh0KSx7dmFsdWVzOmEsZHR5cGU6cixjb21wbGV4VGVuc29ySW5mb3M6cyxzbGljZTppLHNoYXBlOm8saXNQYWNrZWQ6bH09bjtpZihpIT1udWxsKXtsZXQgYztsP2M9bmV3IHRzKG8sWXIpOmM9bmV3IHJyKG8sWXIpO2xldCBoPXRoaXMucnVuV2ViR0xQcm9ncmFtKGMsW3tkYXRhSWQ6dCxzaGFwZTpvLGR0eXBlOnJ9XSxyKSxtPXRoaXMucmVhZFN5bmMoaC5kYXRhSWQpO3JldHVybiB0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG19aWYoYSE9bnVsbClyZXR1cm4gdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0KTtpZihyPT09XCJzdHJpbmdcIilyZXR1cm4gYTtsZXQgdT10aGlzLmFjdGl2ZVRpbWVycyE9bnVsbCxwO3UmJihwPXcubm93KCkpO2xldCBkO2lmKHI9PT1cImNvbXBsZXg2NFwiKXtsZXQgYz10aGlzLnJlYWRTeW5jKHMucmVhbC5kYXRhSWQpLGg9dGhpcy5yZWFkU3luYyhzLmltYWcuZGF0YUlkKTtkPVQubWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhjLGgpfWVsc2UgZD10aGlzLmdldFZhbHVlc0Zyb21UZXh0dXJlKHQpO3JldHVybiB1JiYodGhpcy5kb3dubG9hZFdhaXRNcys9dy5ub3coKS1wKSx0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQsZCl9YXN5bmMgcmVhZCh0KXtpZih0aGlzLnBlbmRpbmdSZWFkLmhhcyh0KSl7bGV0IG09dGhpcy5wZW5kaW5nUmVhZC5nZXQodCk7cmV0dXJuIG5ldyBQcm9taXNlKGY9Pm0ucHVzaChmKSl9bGV0IG49dGhpcy50ZXhEYXRhLmdldCh0KSx7dmFsdWVzOmEsc2hhcGU6cixzbGljZTpzLGR0eXBlOmksY29tcGxleFRlbnNvckluZm9zOm8saXNQYWNrZWQ6bH09bjtpZihzIT1udWxsKXtsZXQgbTtsP209bmV3IHRzKHIsWXIpOm09bmV3IHJyKHIsWXIpO2xldCBmPXRoaXMucnVuV2ViR0xQcm9ncmFtKG0sW3tkYXRhSWQ6dCxzaGFwZTpyLGR0eXBlOml9XSxpKSxnPXRoaXMucmVhZChmLmRhdGFJZCk7cmV0dXJuIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksZ31pZihhIT1udWxsKXJldHVybiB0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQpO2lmKEcoKS5nZXRCb29sKFwiREVCVUdcIikmJiFHKCkuZ2V0Qm9vbChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikmJkcoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPT09Mil0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IuZGF0YSgpIHdpdGggV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRD1mYWxzZSBhbmQgV0VCR0xfVkVSU0lPTj0yIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtsZXQgdT1udWxsLHA7aWYoaSE9PVwiY29tcGxleDY0XCImJkcoKS5nZXQoXCJXRUJHTF9CVUZGRVJfU1VQUE9SVEVEXCIpKXtwPXRoaXMuZGVjb2RlKHQpO2xldCBtPXRoaXMudGV4RGF0YS5nZXQocC5kYXRhSWQpO3U9dGhpcy5ncGdwdS5jcmVhdGVCdWZmZXJGcm9tVGV4dHVyZShtLnRleHR1cmUudGV4dHVyZSwuLi5BaChyKSl9dGhpcy5wZW5kaW5nUmVhZC5zZXQodCxbXSksaSE9PVwiY29tcGxleDY0XCImJmF3YWl0IHRoaXMuZ3BncHUuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7bGV0IGQ7aWYoaT09PVwiY29tcGxleDY0XCIpe2xldCBtPWF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnJlYWQoby5yZWFsLmRhdGFJZCksdGhpcy5yZWFkKG8uaW1hZy5kYXRhSWQpXSksZj1tWzBdLGc9bVsxXTtkPVQubWVyZ2VSZWFsQW5kSW1hZ0FycmF5cyhmLGcpfWVsc2UgaWYodT09bnVsbClkPXRoaXMuZ2V0VmFsdWVzRnJvbVRleHR1cmUodCk7ZWxzZXtsZXQgbT13LnNpemVGcm9tU2hhcGUocik7ZD10aGlzLmdwZ3B1LmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXIodSxtKX1pZihwIT1udWxsJiZ0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApLHUhPW51bGwpe2xldCBtPXRoaXMuZ3BncHUuZ2w7ZGUobSwoKT0+bS5kZWxldGVCdWZmZXIodSkpfWxldCBjPXRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCxkKSxoPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHQpO3JldHVybiB0aGlzLnBlbmRpbmdSZWFkLmRlbGV0ZSh0KSxoLmZvckVhY2gobT0+bShjKSksdGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKHQpJiYodGhpcy5wZW5kaW5nRGlzcG9zYWwuZGVsZXRlKHQpLHRoaXMuZGlzcG9zZURhdGEodCkmJlRhKCkucmVtb3ZlRGF0YUlkKHQsdGhpcyksdGhpcy5wZW5kaW5nRGVsZXRlcy0tKSxjfXJlYWRUb0dQVSh0LG49e30pe2xldCBhPXRoaXMudGV4RGF0YS5nZXQodCkse3ZhbHVlczpyLHNoYXBlOnMsc2xpY2U6aSxkdHlwZTpvLGlzUGFja2VkOmwsdGV4dHVyZTp1fT1hO2lmKG89PT1cImNvbXBsZXg2NFwiKXRocm93IG5ldyBFcnJvcihcIkRvZXMgbm90IHN1cHBvcnQgcmVhZGluZyB0ZXh0dXJlIGZvciBjb21wbGV4NjQgZHR5cGUuXCIpO2lmKGkhPW51bGwpe2xldCBoO2w/aD1uZXcgdHMocyxZcik6aD1uZXcgcnIocyxZcik7bGV0IG09dGhpcy5ydW5XZWJHTFByb2dyYW0oaCxbe2RhdGFJZDp0LHNoYXBlOnMsZHR5cGU6b31dLG8pLGY9dGhpcy5yZWFkVG9HUFUobSxuKTtyZXR1cm4gdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxmfWlmKHU9PW51bGwpdGhyb3cgciE9bnVsbD9uZXcgRXJyb3IoXCJEYXRhIGlzIG5vdCBvbiBHUFUgYnV0IG9uIENQVS5cIik6bmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gZGF0YSBvbiBHUFUgb3IgQ1BVLlwiKTtsZXQgcD10aGlzLmRlY29kZSh0LG4uY3VzdG9tVGV4U2hhcGUpLGQ9VGEoKS5tYWtlVGVuc29yRnJvbVRlbnNvckluZm8ocCksYz10aGlzLnRleERhdGEuZ2V0KHAuZGF0YUlkKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih7dGVuc29yUmVmOmR9LGMudGV4dHVyZSl9YnVmZmVyU3luYyh0KXtsZXQgbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKTtpZih0LmR0eXBlPT09XCJzdHJpbmdcIil0cnl7bGV0IGE9bi5tYXAocj0+dy5kZWNvZGVTdHJpbmcocikpO3JldHVybiBPZSh0LnNoYXBlLHQuZHR5cGUsYSl9Y2F0Y2goYSl7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSBlbmNvZGVkIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04XCIpfXJldHVybiBPZSh0LnNoYXBlLHQuZHR5cGUsbil9Y2hlY2tOdW1lcmljYWxQcm9ibGVtcyh0KXtpZih0IT1udWxsKWZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtsZXQgYT10W25dO2lmKCFSXyhhKSl0aHJvdyBHKCkuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0NBUEFCTEVcIik/RXJyb3IoYFRoZSB2YWx1ZSAke2F9IGNhbm5vdCBiZSByZXByZXNlbnRlZCB3aXRoIHlvdXIgY3VycmVudCBzZXR0aW5ncy4gQ29uc2lkZXIgZW5hYmxpbmcgZmxvYXQzMiByZW5kZXJpbmc6ICd0Zi5lbnYoKS5zZXQoJ1dFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRUQnLCB0cnVlKTsnYCk6RXJyb3IoYFRoZSB2YWx1ZSAke2F9IGNhbm5vdCBiZSByZXByZXNlbnRlZCBvbiB0aGlzIGRldmljZS5gKX19Z2V0VmFsdWVzRnJvbVRleHR1cmUodCl7bGV0e3NoYXBlOm4sZHR5cGU6YSxpc1BhY2tlZDpyfT10aGlzLnRleERhdGEuZ2V0KHQpLHM9dy5zaXplRnJvbVNoYXBlKG4pO2lmKEcoKS5nZXRCb29sKFwiV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRFwiKSl7bGV0IGM9dGhpcy5kZWNvZGUodCksaD10aGlzLnRleERhdGEuZ2V0KGMuZGF0YUlkKSxtPXRoaXMuZ3BncHUuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZShoLnRleHR1cmUudGV4dHVyZSwuLi5BaChuKSkuc3ViYXJyYXkoMCxzKTtyZXR1cm4gdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxtfWxldCBpPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKSYmcj09PSEwLG89aT9pYyhuKTpuLGw9aT9uZXcgcTkobyk6bmV3IGo5KG8pLHU9dGhpcy5ydW5XZWJHTFByb2dyYW0obCxbe3NoYXBlOm8sZHR5cGU6YSxkYXRhSWQ6dH1dLFwiZmxvYXQzMlwiKSxwPXRoaXMudGV4RGF0YS5nZXQodS5kYXRhSWQpLGQ9dGhpcy5ncGdwdS5kb3dubG9hZEJ5dGVFbmNvZGVkRmxvYXRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShwLnRleHR1cmUudGV4dHVyZSxwLnRleFNoYXBlWzBdLHAudGV4U2hhcGVbMV0pLnN1YmFycmF5KDAscyk7cmV0dXJuIHRoaXMuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odSksZH10aW1lckF2YWlsYWJsZSgpe3JldHVybiBHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjB9dGltZSh0KXtsZXQgbj10aGlzLmFjdGl2ZVRpbWVycyxhPVtdLHI9ITE7dGhpcy5wcm9ncmFtVGltZXJzU3RhY2s9PW51bGw/KHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPWEscj0hMCk6dGhpcy5hY3RpdmVUaW1lcnMucHVzaChhKSx0aGlzLmFjdGl2ZVRpbWVycz1hLHQoKTtsZXQgcz13LmZsYXR0ZW4odGhpcy5hY3RpdmVUaW1lcnMubWFwKGw9PmwucXVlcnkpKS5maWx0ZXIobD0+bCE9bnVsbCksaT13LmZsYXR0ZW4odGhpcy5hY3RpdmVUaW1lcnMubWFwKGw9PmwubmFtZSkpLmZpbHRlcihsPT5sIT1udWxsKTt0aGlzLmFjdGl2ZVRpbWVycz1uLHImJih0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1udWxsKTtsZXQgbz17dXBsb2FkV2FpdE1zOnRoaXMudXBsb2FkV2FpdE1zLGRvd25sb2FkV2FpdE1zOnRoaXMuZG93bmxvYWRXYWl0TXMsa2VybmVsTXM6bnVsbCx3YWxsTXM6bnVsbH07cmV0dXJuKGFzeW5jKCk9PntpZihHKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjApe2xldCBsPWF3YWl0IFByb21pc2UuYWxsKHMpO28ua2VybmVsTXM9dy5zdW0obCksby5nZXRFeHRyYVByb2ZpbGVJbmZvPSgpPT5sLm1hcCgodSxwKT0+KHtuYW1lOmlbcF0sbXM6dX0pKS5tYXAodT0+YCR7dS5uYW1lfTogJHt1Lm1zfWApLmpvaW4oXCIsIFwiKX1lbHNlIG8ua2VybmVsTXM9e2Vycm9yOlwiV2ViR0wgcXVlcnkgdGltZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuXCJ9O3JldHVybiB0aGlzLnVwbG9hZFdhaXRNcz0wLHRoaXMuZG93bmxvYWRXYWl0TXM9MCxvfSkoKX1tZW1vcnkoKXtyZXR1cm57dW5yZWxpYWJsZTohMSxudW1CeXRlc0luR1BVOnRoaXMubnVtQnl0ZXNJbkdQVSxudW1CeXRlc0luR1BVQWxsb2NhdGVkOnRoaXMudGV4dHVyZU1hbmFnZXIubnVtQnl0ZXNBbGxvY2F0ZWQsbnVtQnl0ZXNJbkdQVUZyZWU6dGhpcy50ZXh0dXJlTWFuYWdlci5udW1CeXRlc0ZyZWV9fXN0YXJ0VGltZXIoKXtyZXR1cm4gRygpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wP3RoaXMuZ3BncHUuYmVnaW5RdWVyeSgpOntzdGFydE1zOncubm93KCksZW5kTXM6bnVsbH19ZW5kVGltZXIodCl7cmV0dXJuIEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MD8odGhpcy5ncGdwdS5lbmRRdWVyeSgpLHQpOih0LmVuZE1zPXcubm93KCksdCl9YXN5bmMgZ2V0UXVlcnlUaW1lKHQpe2lmKEcoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MClyZXR1cm4gdGhpcy5ncGdwdS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHQpO2xldCBuPXQ7cmV0dXJuIG4uZW5kTXMtbi5zdGFydE1zfWRpc3Bvc2VEYXRhKHQsbj0hMSl7aWYodGhpcy5wZW5kaW5nRGlzcG9zYWwuaGFzKHQpKXJldHVybiExO2lmKCF0aGlzLnRleERhdGEuaGFzKHQpKXJldHVybiEwO2lmKG4/dGhpcy50ZXhEYXRhLmdldCh0KS5yZWZDb3VudD0wOnRoaXMudGV4RGF0YS5nZXQodCkucmVmQ291bnQtLSwhbiYmdGhpcy50ZXhEYXRhLmdldCh0KS5yZWZDb3VudD4wKXJldHVybiExO2lmKHRoaXMucGVuZGluZ1JlYWQuaGFzKHQpKXJldHVybiB0aGlzLnBlbmRpbmdEaXNwb3NhbC5hZGQodCksdGhpcy5wZW5kaW5nRGVsZXRlcysrLCExO3RoaXMucmVsZWFzZUdQVURhdGEodCk7bGV0e2NvbXBsZXhUZW5zb3JJbmZvczphfT10aGlzLnRleERhdGEuZ2V0KHQpO3JldHVybiBhIT1udWxsJiYodGhpcy5kaXNwb3NlRGF0YShhLnJlYWwuZGF0YUlkLG4pLHRoaXMuZGlzcG9zZURhdGEoYS5pbWFnLmRhdGFJZCxuKSksdGhpcy50ZXhEYXRhLmRlbGV0ZSh0KSwhMH1yZWxlYXNlR1BVRGF0YSh0KXtsZXR7dGV4dHVyZTpuLGR0eXBlOmEsdGV4U2hhcGU6cix1c2FnZTpzLGlzUGFja2VkOmksc2xpY2U6b309dGhpcy50ZXhEYXRhLmdldCh0KSxsPW8mJm8ub3JpZ0RhdGFJZHx8dCx1PXRoaXMuZGF0YVJlZkNvdW50LmdldChsKTt1PjE/dGhpcy5kYXRhUmVmQ291bnQuc2V0KGwsdS0xKToodGhpcy5kYXRhUmVmQ291bnQuZGVsZXRlKGwpLG4hPW51bGwmJih0aGlzLm51bUJ5dGVzSW5HUFUtPXRoaXMuY29tcHV0ZUJ5dGVzKHIsYSksdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShuLHIscyxpKSkpO2xldCBwPXRoaXMudGV4RGF0YS5nZXQodCk7cC50ZXh0dXJlPW51bGwscC50ZXhTaGFwZT1udWxsLHAuaXNQYWNrZWQ9ITEscC5zbGljZT1udWxsfWdldFRleHR1cmUodCl7cmV0dXJuIHRoaXMudXBsb2FkVG9HUFUodCksdGhpcy50ZXhEYXRhLmdldCh0KS50ZXh0dXJlLnRleHR1cmV9Z2V0RGF0YUluZm8odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodCl9c2hvdWxkRXhlY3V0ZU9uQ1BVKHQsbj1wZWUpe3JldHVybiBHKCkuZ2V0Qm9vbChcIldFQkdMX0NQVV9GT1JXQVJEXCIpJiZ0LmV2ZXJ5KGE9PnRoaXMudGV4RGF0YS5nZXQoYS5kYXRhSWQpLnRleHR1cmU9PW51bGwmJncuc2l6ZUZyb21TaGFwZShhLnNoYXBlKTxuKX1nZXRHUEdQVUNvbnRleHQoKXtyZXR1cm4gdGhpcy5ncGdwdX13aGVyZSh0KXtULndhcm4oXCJ0Zi53aGVyZSgpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYud2hlcmVBc3luYygpIGluc3RlYWRcIik7bGV0IG49dC5kYXRhU3luYygpO3JldHVybiBpZWUodC5zaGFwZSxuKX1wYWNrZWRVbmFyeU9wKHQsbixhKXtsZXQgcj1uZXcgdHModC5zaGFwZSxuKSxzPXRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxhKTtyZXR1cm4gVGEoKS5tYWtlVGVuc29yRnJvbVRlbnNvckluZm8ocyl9YWJzKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkmJnQuZHR5cGUhPT1cImNvbXBsZXg2NFwiKXtsZXQgcj1DQSh0aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS52YWx1ZXMpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQodC5zaGFwZSx0LmR0eXBlLHIpfWlmKEcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxvUyx0LmR0eXBlKTtsZXQgbj1uZXcgcnIodC5zaGFwZSxvUyksYT10aGlzLmNvbXBpbGVBbmRSdW4obixbdF0pO3JldHVybiBUYSgpLm1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyhhKX1tYWtlVGVuc29ySW5mbyh0LG4sYSl7bGV0IHI7aWYobj09PVwic3RyaW5nXCImJmEhPW51bGwmJmEubGVuZ3RoPjAmJncuaXNTdHJpbmcoYVswXSkpe2xldCBzPWEubWFwKGk9PncuZW5jb2RlU3RyaW5nKGkpKTtyPXRoaXMud3JpdGUocyx0LG4pfWVsc2Ugcj10aGlzLndyaXRlKGEsdCxuKTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChyKS51c2FnZT1udWxsLHtkYXRhSWQ6cixzaGFwZTp0LGR0eXBlOm59fW1ha2VPdXRwdXQodCxuLGEpe3JldHVybiBUYSgpLm1ha2VUZW5zb3JGcm9tVGVuc29ySW5mbyh0aGlzLm1ha2VUZW5zb3JJbmZvKHQsbixhKSx0aGlzKX11bnBhY2tUZW5zb3IodCl7bGV0IG49bmV3IHNlZSh0LnNoYXBlKTtyZXR1cm4gdGhpcy5ydW5XZWJHTFByb2dyYW0obixbdF0sdC5kdHlwZSl9cGFja1RlbnNvcih0KXtsZXQgbj1uZXcgVVEodC5zaGFwZSk7cmV0dXJuIHRoaXMucnVuV2ViR0xQcm9ncmFtKG4sW3RdLHQuZHR5cGUsbnVsbCwhMCl9cGFja2VkUmVzaGFwZSh0LG4pe2xldCBhPVt2aSh0LnNoYXBlKSwuLi53aSh0LnNoYXBlKV0scj17ZHR5cGU6dC5kdHlwZSxzaGFwZTphLGRhdGFJZDp0LmRhdGFJZH0scz1bdmkobiksLi4ud2kobildLGk9bmV3IEFBKHMsYSksbz0hMCxsPVthXSx1PXRoaXMucnVuV2ViR0xQcm9ncmFtKGksW3JdLHQuZHR5cGUsbCxvKTtyZXR1cm57ZGF0YUlkOnUuZGF0YUlkLHNoYXBlOm4sZHR5cGU6dS5kdHlwZX19ZGVjb2RlKHQsbil7bGV0IGE9dGhpcy50ZXhEYXRhLmdldCh0KSx7aXNQYWNrZWQ6cixzaGFwZTpzLGR0eXBlOml9PWE7aWYobiE9bnVsbCl7bGV0IGM9dy5zaXplRnJvbVNoYXBlKHMpLGg9blswXSpuWzFdKjQ7dy5hc3NlcnQoYzw9aCwoKT0+XCJjdXN0b21UZXhTaGFwZSBpcyB0b28gc21hbGwuIFJvdyAqIENvbHVtbiAqIDQgc2hvdWxkIGJlIGVxdWFsIG9yIGxhcmdlciB0aGFuIHRoZSBzaXplIG9mIHRoZSB0ZW5zb3IgZGF0YS5cIil9bGV0IG89aWMocyksbDtyP2w9bmV3IEg5KG8pOmw9bmV3IEc5KG8pO2xldCB1PSEwLHA9W24hPW51bGw/bjpBaChvKV0sZD10aGlzLnJ1bldlYkdMUHJvZ3JhbShsLFt7c2hhcGU6byxkdHlwZTppLGRhdGFJZDp0fV0saSxwLHUsbik7cmV0dXJue2R0eXBlOmksc2hhcGU6cyxkYXRhSWQ6ZC5kYXRhSWR9fXJ1bldlYkdMUHJvZ3JhbSh0LG4sYSxyLHM9ITEsaSl7bGV0IG89dGhpcy5tYWtlVGVuc29ySW5mbyh0Lm91dHB1dFNoYXBlLGEpLGw9dGhpcy50ZXhEYXRhLmdldChvLmRhdGFJZCk7aWYodC5wYWNrZWRPdXRwdXQmJihsLmlzUGFja2VkPSEwKSx0Lm91dFBhY2tpbmdTY2hlbWU9PT1OYy5ERU5TRSl7bGV0IGI9aSE9bnVsbD9pOkFoKHQub3V0cHV0U2hhcGUpO2wudGV4U2hhcGU9Yi5tYXAoeT0+eSoyKX1pZih0Lm91dFRleFVzYWdlIT1udWxsJiYobC51c2FnZT10Lm91dFRleFVzYWdlKSx3LnNpemVGcm9tU2hhcGUoby5zaGFwZSk9PT0wKXJldHVybiBsLnZhbHVlcz13LmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoby5kdHlwZSwwKSxvO2xldCB1PVtdLHA9bi5tYXAoYj0+e2lmKGIuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXRocm93IG5ldyBFcnJvcihcIkdQR1BVUHJvZ3JhbSBkb2VzIG5vdCBzdXBwb3J0IGNvbXBsZXg2NCBpbnB1dC4gRm9yIGNvbXBsZXg2NCBkdHlwZXMsIHBsZWFzZSBzZXBhcmF0ZSB0aGUgcHJvZ3JhbSBpbnRvIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cy5cIik7bGV0IHk9dGhpcy50ZXhEYXRhLmdldChiLmRhdGFJZCk7aWYoeS50ZXh0dXJlPT1udWxsKXtpZighdC5wYWNrZWRJbnB1dHMmJncuc2l6ZUZyb21TaGFwZShiLnNoYXBlKTw9RygpLmdldE51bWJlcihcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIikpcmV0dXJue3NoYXBlOmIuc2hhcGUsdGV4RGF0YTpudWxsLGlzVW5pZm9ybTohMCx1bmlmb3JtVmFsdWVzOnkudmFsdWVzfTt0LnBhY2tlZElucHV0cyYmKHkuaXNQYWNrZWQ9ITAseS5zaGFwZT1iLnNoYXBlKX1pZih0aGlzLnVwbG9hZFRvR1BVKGIuZGF0YUlkKSwhIXkuaXNQYWNrZWQhPSEhdC5wYWNrZWRJbnB1dHMpYj15LmlzUGFja2VkP3RoaXMudW5wYWNrVGVuc29yKGIpOnRoaXMucGFja1RlbnNvcihiKSx1LnB1c2goYikseT10aGlzLnRleERhdGEuZ2V0KGIuZGF0YUlkKTtlbHNlIGlmKHkuaXNQYWNrZWQmJiFUYyh5LnNoYXBlLGIuc2hhcGUpKXtsZXQgeD1iLHY9Yi5zaGFwZTtiLnNoYXBlPXkuc2hhcGUsYj10aGlzLnBhY2tlZFJlc2hhcGUoYix2KSx1LnB1c2goYikseT10aGlzLnRleERhdGEuZ2V0KGIuZGF0YUlkKSx4LnNoYXBlPXZ9cmV0dXJue3NoYXBlOmIuc2hhcGUsdGV4RGF0YTp5LGlzVW5pZm9ybTohMX19KTt0aGlzLnVwbG9hZFRvR1BVKG8uZGF0YUlkKTtsZXQgZD17c2hhcGU6by5zaGFwZSx0ZXhEYXRhOmwsaXNVbmlmb3JtOiExfSxjPVU5KHQscCxkKSxoPXRoaXMuZ2V0QW5kU2F2ZUJpbmFyeShjLCgpPT5COSh0aGlzLmdwZ3B1LHQscCxkKSksbT10aGlzLmFjdGl2ZVRpbWVycyE9bnVsbCxmO20mJihmPXRoaXMuc3RhcnRUaW1lcigpKSxHKCkuZ2V0KFwiRU5HSU5FX0NPTVBJTEVfT05MWVwiKXx8VjkodGhpcy5ncGdwdSxoLHAsZCxyKSx1LmZvckVhY2goYj0+dGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhiKSksbSYmKGY9dGhpcy5lbmRUaW1lcihmKSx0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKHtuYW1lOnQuY29uc3RydWN0b3IubmFtZSxxdWVyeTp0aGlzLmdldFF1ZXJ5VGltZShmKX0pKTtsZXQgZz1HKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRkxVU0hfVEhSRVNIT0xEXCIpO2lmKGc+MCl7bGV0IGI9dy5ub3coKTtiLXRoaXMubGFzdEdsRmx1c2hUaW1lPmcmJih0aGlzLmdwZ3B1LmdsLmZsdXNoKCksdGhpcy5sYXN0R2xGbHVzaFRpbWU9Yil9aWYoIUcoKS5nZXRCb29sKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiKSYmbC5pc1BhY2tlZCYmcz09PSExKXtsZXQgYj10aGlzLnVucGFja1RlbnNvcihvKTtyZXR1cm4gdGhpcy5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxifXJldHVybiBvfWNvbXBpbGVBbmRSdW4odCxuLGEscixzPSExKXtyZXR1cm4gYT1hfHxuWzBdLmR0eXBlLHRoaXMucnVuV2ViR0xQcm9ncmFtKHQsbixhLHIscyl9Z2V0QW5kU2F2ZUJpbmFyeSh0LG4pe3JldHVybiB0IGluIHRoaXMuYmluYXJ5Q2FjaGV8fCh0aGlzLmJpbmFyeUNhY2hlW3RdPW4oKSksdGhpcy5iaW5hcnlDYWNoZVt0XX1nZXRUZXh0dXJlTWFuYWdlcigpe3JldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyfWRpc3Bvc2UoKXt0aGlzLmRpc3Bvc2VkfHwoRygpLmdldEJvb2woXCJJU19URVNUXCIpfHxPYmplY3Qua2V5cyh0aGlzLmJpbmFyeUNhY2hlKS5mb3JFYWNoKHQ9Pnt0aGlzLmdwZ3B1LmRlbGV0ZVByb2dyYW0odGhpcy5iaW5hcnlDYWNoZVt0XS53ZWJHTFByb2dyYW0pLGRlbGV0ZSB0aGlzLmJpbmFyeUNhY2hlW3RdfSksdGhpcy50ZXh0dXJlTWFuYWdlci5kaXNwb3NlKCksdGhpcy5jYW52YXMhPW51bGwmJnR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCE9XCJ1bmRlZmluZWRcIiYmdGhpcy5jYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudD90aGlzLmNhbnZhcy5yZW1vdmUoKTp0aGlzLmNhbnZhcz1udWxsLHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSYmKHRoaXMuZ3BncHUucHJvZ3JhbT1udWxsLHRoaXMuZ3BncHUuZGlzcG9zZSgpKSx0aGlzLmRpc3Bvc2VkPSEwKX1mbG9hdFByZWNpc2lvbigpe3JldHVybiB0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWU9PW51bGwmJih0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWU9TygoKT0+e2lmKCFHKCkuZ2V0KFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiKSl7bGV0IHQ9RygpLmdldEJvb2woXCJERUJVR1wiKTtHKCkuc2V0KFwiREVCVUdcIiwhMSk7bGV0IG49dGhpcy5hYnMoeGUoMWUtOCkpLmRhdGFTeW5jKClbMF07aWYoRygpLnNldChcIkRFQlVHXCIsdCksbj4wKXJldHVybiAzMn1yZXR1cm4gMTZ9KSksdGhpcy5mbG9hdFByZWNpc2lvblZhbHVlfWVwc2lsb24oKXtyZXR1cm4gdGhpcy5mbG9hdFByZWNpc2lvbigpPT09MzI/b2VlOmxlZX11cGxvYWRUb0dQVSh0KXtsZXQgbj10aGlzLnRleERhdGEuZ2V0KHQpLHtzaGFwZTphLGR0eXBlOnIsdmFsdWVzOnMsdGV4dHVyZTppLHVzYWdlOm8saXNQYWNrZWQ6bH09bjtpZihpIT1udWxsKXJldHVybjtsZXQgdT10aGlzLmFjdGl2ZVRpbWVycyE9bnVsbCxwO3UmJihwPXcubm93KCkpO2xldCBkPW4udGV4U2hhcGU7aWYoZD09bnVsbCYmKGQ9Wl8oYSxsKSxuLnRleFNoYXBlPWQpLHMhPW51bGwpe2xldCBjPWljKGEpLGgsbT1kWzFdLGY9ZFswXSxnPXMgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxzIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXk7KGx8fCFnKSYmKFttLGZdPW9wKGRbMF0sZFsxXSkpLGw/aD1uZXcgWDkoYyxnKTpoPW5ldyBhUyhjLGcpO2xldCBiPWc/W2YsbV06ZCx5PXRoaXMubWFrZVRlbnNvckluZm8oYixyKSx4PXRoaXMudGV4RGF0YS5nZXQoeS5kYXRhSWQpO2c/eC51c2FnZT1jYS5QSVhFTFM6eC51c2FnZT1jYS5VUExPQUQseC50ZXhTaGFwZT1iLHRoaXMuZ3BncHUudXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmUodGhpcy5nZXRUZXh0dXJlKHkuZGF0YUlkKSxtLGYscyk7bGV0IHY9W1tmLG1dXSxJPXRoaXMucnVuV2ViR0xQcm9ncmFtKGgsW3ldLHIsdiwhMCksTj10aGlzLnRleERhdGEuZ2V0KEkuZGF0YUlkKTtuLnRleFNoYXBlPU4udGV4U2hhcGUsbi5pc1BhY2tlZD1OLmlzUGFja2VkLG4udXNhZ2U9Ti51c2FnZSxHKCkuZ2V0KFwiRU5HSU5FX0NPTVBJTEVfT05MWVwiKT90aGlzLmRpc3Bvc2VEYXRhKEkuZGF0YUlkKToobi50ZXh0dXJlPU4udGV4dHVyZSxuLnZhbHVlcz1udWxsLHRoaXMudGV4RGF0YS5kZWxldGUoSS5kYXRhSWQpKSx0aGlzLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpLHUmJih0aGlzLnVwbG9hZFdhaXRNcys9dy5ub3coKS1wKX1lbHNle2xldCBjPXRoaXMuYWNxdWlyZVRleHR1cmUoZCxvLHIsbCk7bi50ZXh0dXJlPWN9fWNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQsbil7bGV0IGE9dGhpcy50ZXhEYXRhLmdldCh0KSx7ZHR5cGU6cn09YTtyZXR1cm4gbiE9bnVsbCYmKGEudmFsdWVzPWhlZShuLHIpKSxhLnZhbHVlc31hY3F1aXJlVGV4dHVyZSh0LG4sYSxyKXtpZih0aGlzLm51bUJ5dGVzSW5HUFUrPXRoaXMuY29tcHV0ZUJ5dGVzKHQsYSksIXRoaXMud2FybmVkQWJvdXRNZW1vcnkmJnRoaXMubnVtQnl0ZXNJbkdQVT50aGlzLm51bU1CQmVmb3JlV2FybmluZyoxMDI0KjEwMjQpe2xldCBzPSh0aGlzLm51bUJ5dGVzSW5HUFUvMTAyNC8xMDI0KS50b0ZpeGVkKDIpO3RoaXMud2FybmVkQWJvdXRNZW1vcnk9ITAsY29uc29sZS53YXJuKGBIaWdoIG1lbW9yeSB1c2FnZSBpbiBHUFU6ICR7c30gTUIsIG1vc3QgbGlrZWx5IGR1ZSB0byBhIG1lbW9yeSBsZWFrYCl9cmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodCxuLHIpfWNvbXB1dGVCeXRlcyh0LG4pe3JldHVybiB0WzBdKnRbMV0qdy5ieXRlc1BlckVsZW1lbnQobil9Y2hlY2tDb21waWxlQ29tcGxldGlvbigpe2ZvcihsZXRbLHRdb2YgT2JqZWN0LmVudHJpZXModGhpcy5iaW5hcnlDYWNoZSkpdGhpcy5jaGVja0NvbXBsZXRpb25fKHQpfWFzeW5jIGNoZWNrQ29tcGlsZUNvbXBsZXRpb25Bc3luYygpe2xldCB0PVtdO2lmKHRoaXMuZ3BncHUucGFyYWxsZWxDb21waWxhdGlvbkV4dGVuc2lvbil7Zm9yKGxldFssbl1vZiBPYmplY3QuZW50cmllcyh0aGlzLmJpbmFyeUNhY2hlKSl0LnB1c2godGhpcy5jaGVja0NvbXBsZXRpb25Bc3luY18obikpO3JldHVybiBQcm9taXNlLmFsbCh0KX1lbHNle2ZvcihsZXRbLG5db2YgT2JqZWN0LmVudHJpZXModGhpcy5iaW5hcnlDYWNoZSkpe2xldCBhPW5ldyBQcm9taXNlKHI9Pnt0cnl7dGhpcy5jaGVja0NvbXBsZXRpb25fKG4pLHIoITApfWNhdGNoKHMpe3Rocm93IHN9fSk7dC5wdXNoKGEpfXJldHVybiBQcm9taXNlLmFsbCh0KX19YXN5bmMgY2hlY2tDb21wbGV0aW9uQXN5bmNfKHQpe3JldHVybiB0aGlzLmdwZ3B1LmdsLmdldFByb2dyYW1QYXJhbWV0ZXIodC53ZWJHTFByb2dyYW0sdGhpcy5ncGdwdS5wYXJhbGxlbENvbXBpbGF0aW9uRXh0ZW5zaW9uLkNPTVBMRVRJT05fU1RBVFVTX0tIUik/dGhpcy5jaGVja0NvbXBsZXRpb25fKHQpOihhd2FpdCBadygpLHRoaXMuY2hlY2tDb21wbGV0aW9uQXN5bmNfKHQpKX1jaGVja0NvbXBsZXRpb25fKHQpe2lmKHRoaXMuZ3BncHUuZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0LndlYkdMUHJvZ3JhbSx0aGlzLmdwZ3B1LmdsLkxJTktfU1RBVFVTKT09PSExKXRocm93IGNvbnNvbGUubG9nKHRoaXMuZ3BncHUuZ2wuZ2V0UHJvZ3JhbUluZm9Mb2codC53ZWJHTFByb2dyYW0pKSx0aGlzLmdwZ3B1LmdsLmdldFNoYWRlclBhcmFtZXRlcih0LmZyYWdtZW50U2hhZGVyLHRoaXMuZ3BncHUuZ2wuQ09NUElMRV9TVEFUVVMpPT09ITE/KEoxKHQuc291cmNlLHRoaXMuZ3BncHUuZ2wuZ2V0U2hhZGVySW5mb0xvZyh0LmZyYWdtZW50U2hhZGVyKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyLlwiKSk6bmV3IEVycm9yKFwiRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLlwiKTtyZXR1cm4hMH1nZXRVbmlmb3JtTG9jYXRpb25zKCl7Zm9yKGxldCB0IG9mIE9iamVjdC52YWx1ZXModGhpcy5iaW5hcnlDYWNoZSkpe3RoaXMuZ3BncHUuYnVpbGRWYW8odC53ZWJHTFByb2dyYW0pO2xldHt2YXJpYWJsZXNMb2NhdGlvbnM6bixjdXN0b21Vbmlmb3JtTG9jYXRpb25zOmEsaW5mTG9jOnIsbmFuTG9jOnMsb3V0U2hhcGVMb2NhdGlvbjppLG91dFNoYXBlU3RyaWRlc0xvY2F0aW9uOm8sb3V0VGV4U2hhcGVMb2NhdGlvbjpsfT1sQSh0aGlzLmdwZ3B1LHQucHJvZ3JhbSx0LndlYkdMUHJvZ3JhbSk7dC52YXJpYWJsZXNMb2NhdGlvbnM9bix0LmN1c3RvbVVuaWZvcm1Mb2NhdGlvbnM9YSx0LmluZkxvYz1yLHQubmFuTG9jPXMsdC5vdXRTaGFwZUxvY2F0aW9uPWksdC5vdXRTaGFwZVN0cmlkZXNMb2NhdGlvbj1vLHQub3V0VGV4U2hhcGVMb2NhdGlvbj1sfX1jcmVhdGVUZW5zb3JGcm9tR1BVRGF0YSh0LG4sYSl7dC5jaGFubmVscz10LmNoYW5uZWxzfHxcIlJHQkFcIjtsZXR7dGV4dHVyZTpyLGhlaWdodDpzLHdpZHRoOmksY2hhbm5lbHM6b309dCxsPVRhKCkuYmFja2VuZDtpZighbC5ncGdwdS5nbC5pc1RleHR1cmUocikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRleHR1cmUgaXMgaW52YWxpZC4gQWxzbywgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgdGV4dHVyZSBhbmQgdGhlIFRGSlMgV2ViR0wgYmFja2VuZCBhcmUgdXNpbmcgdGhlIHNhbWUgY2FudmFzLiBJZiB5b3Ugd2FudCB0byB1c2UgeW91ciBvd24gY3VzdG9tIGNhbnZhcywgeW91IGhhdmUgdG8gY3JlYXRlIGFuZCB1c2UgdGhlIGN1c3RvbSBURkpTIFdlYkdMIGJhY2tlbmQgY3JlYXRlZCBmcm9tIHRoZSBjYW52YXMgdGhyb3VnaCAnbmV3IHRmLk1hdGhCYWNrZW5kV2ViR0woY3VzdG9tQ2FudmFzKScuXCIpO2xldCB1PWwud3JpdGVUZXh0dXJlKHIsbixhLHMsaSxvKTtyZXR1cm4gVGEoKS5tYWtlVGVuc29yRnJvbURhdGFJZCh1LG4sYSxsKX19O2xrLm5leHREYXRhSWQ9MDtmdW5jdGlvbiBoZWUoZSx0KXtpZih0PT09XCJmbG9hdDMyXCJ8fHQ9PT1cImNvbXBsZXg2NFwiKXJldHVybiBlO2lmKHQ9PT1cImludDMyXCJ8fHQ9PT1cImJvb2xcIil7bGV0IG49dD09PVwiaW50MzJcIj9uZXcgSW50MzJBcnJheShlLmxlbmd0aCk6bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgYT0wO2E8bi5sZW5ndGg7KythKW5bYV09TWF0aC5yb3VuZChlW2FdKTtyZXR1cm4gbn1lbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkdHlwZSAke3R9YCl9dmFyIG1lZT1cIjQuMjIuMFwiO2Z1bmN0aW9uICRBKCl7RygpLnNldChcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiLCEwKX1hZC5pc0Jyb3dzZXIoKSYmT20oXCJ3ZWJnbFwiLCgpPT5uZXcgbGssMik7dmFyIGZlZT17Zm9yY2VIYWxmRmxvYXQ6JEF9LHVrPWBcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcbiAgaWYgKGlzbmFuKGIpKSByZXR1cm4gYjtcbmAsa2k9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJCXCJdLHRoaXMub3V0cHV0U2hhcGU9VC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LG4pLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCksdGhpcy51c2VyQ29kZT1gXG4gICAgICBmbG9hdCBiaW5hcnlPcGVyYXRpb24oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgICAgICAke2V9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xuICAgICAgfVxuICAgIGB9fSxRbz1gXG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IE5BTiA6IHJlc3VsdC5yO1xuICByZXN1bHQuZyA9IGlzTmFOLmcgPyBOQU4gOiByZXN1bHQuZztcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8gTkFOIDogcmVzdWx0LmI7XG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IE5BTiA6IHJlc3VsdC5hO1xuYCxocD1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhPSExKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiQlwiXSx0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nPSEwLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9VC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LG4pO2xldCByPXRoaXMub3V0cHV0U2hhcGUubGVuZ3RoO3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bihyKTtsZXQgcz1cIlwiO2lmKGEpaWYocj09PTB8fHcuc2l6ZUZyb21TaGFwZSh0aGlzLm91dHB1dFNoYXBlKT09PTEpcz1gXG4gICAgICAgICAgcmVzdWx0LnkgPSAwLjtcbiAgICAgICAgICByZXN1bHQueiA9IDAuO1xuICAgICAgICAgIHJlc3VsdC53ID0gMC47XG4gICAgICAgIGA7ZWxzZSBpZihzPWBcbiAgICAgICAgICAke2h0KHIpfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgYCxyPT09MSl0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM/cys9YFxuICAgICAgICAgICAgcmVzdWx0LnkgPSAoY29vcmRzICsgMSkgPj0gb3V0U2hhcGUgPyAwLiA6IHJlc3VsdC55O1xuICAgICAgICAgICAgcmVzdWx0LnogPSAwLjtcbiAgICAgICAgICAgIHJlc3VsdC53ID0gMC47XG4gICAgICAgICAgYDpzKz1gXG4gICAgICAgICAgICByZXN1bHQueSA9IChjb29yZHMgKyAxKSA+PSAke3RoaXMub3V0cHV0U2hhcGVbMF19ID8gMC4gOiByZXN1bHQueTtcbiAgICAgICAgICAgIHJlc3VsdC56ID0gMC47XG4gICAgICAgICAgICByZXN1bHQudyA9IDAuO1xuICAgICAgICAgIGA7ZWxzZXtsZXQgaT1JbihcImNvb3Jkc1wiLHIpO3RoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz9zKz1gXG4gICAgICAgICAgICBib29sIG5leHRSb3dPdXRPZkJvdW5kcyA9XG4gICAgICAgICAgICAgICgke2lbci0yXX0gKyAxKSA+PSBvdXRTaGFwZVske3J9IC0gMl07XG4gICAgICAgICAgICBib29sIG5leHRDb2xPdXRPZkJvdW5kcyA9XG4gICAgICAgICAgICAgICgke2lbci0xXX0gKyAxKSA+PSBvdXRTaGFwZVske3J9IC0gMV07XG4gICAgICAgICAgICByZXN1bHQueSA9IG5leHRDb2xPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lnk7XG4gICAgICAgICAgICByZXN1bHQueiA9IG5leHRSb3dPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lno7XG4gICAgICAgICAgICByZXN1bHQudyA9IG5leHRDb2xPdXRPZkJvdW5kcyB8fCBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC53O1xuICAgICAgICAgIGA6cys9YFxuICAgICAgICAgICAgYm9vbCBuZXh0Um93T3V0T2ZCb3VuZHMgPVxuICAgICAgICAgICAgICAoJHtpW3ItMl19ICsgMSkgPj0gJHt0aGlzLm91dHB1dFNoYXBlW3ItMl19O1xuICAgICAgICAgICAgYm9vbCBuZXh0Q29sT3V0T2ZCb3VuZHMgPVxuICAgICAgICAgICAgICAoJHtpW3ItMV19ICsgMSkgPj0gJHt0aGlzLm91dHB1dFNoYXBlW3ItMV19O1xuICAgICAgICAgICAgcmVzdWx0LnkgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC55O1xuICAgICAgICAgICAgcmVzdWx0LnogPSBuZXh0Um93T3V0T2ZCb3VuZHMgPyAwLiA6IHJlc3VsdC56O1xuICAgICAgICAgICAgcmVzdWx0LncgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgfHwgbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQudztcbiAgICAgICAgICBgfXRoaXMudXNlckNvZGU9YFxuICAgICAgdmVjNCBiaW5hcnlPcGVyYXRpb24odmVjNCBhLCB2ZWM0IGIpIHtcbiAgICAgICAgJHtlfVxuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgYSA9IGdldEFBdE91dENvb3JkcygpO1xuICAgICAgICB2ZWM0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGJpbmFyeU9wZXJhdGlvbihhLCBiKTtcbiAgICAgICAgJHtzfVxuXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiB0YShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQ7cmV0dXJuIG4uaW5jUmVmKGEuZGF0YUlkKSx7ZGF0YUlkOmEuZGF0YUlkLHNoYXBlOmEuc2hhcGUsZHR5cGU6YS5kdHlwZX19dmFyIGdlZT17a2VybmVsTmFtZTplbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp0YX07ZnVuY3Rpb24gJHMoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7cmVhbDphLGltYWc6cn09dCxzPW4ubWFrZVRlbnNvckluZm8oYS5zaGFwZSxcImNvbXBsZXg2NFwiKSxpPW4udGV4RGF0YS5nZXQocy5kYXRhSWQpLG89dGEoe2lucHV0czp7eDphfSxiYWNrZW5kOm59KSxsPXRhKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7cmV0dXJuIGkuY29tcGxleFRlbnNvckluZm9zPXtyZWFsOm8saW1hZzpsfSxzfXZhciBiZWU9e2tlcm5lbE5hbWU6d20sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6JHN9LERBPVwicmV0dXJuIChhIDwgMC4pID8gYiAqIGEgOiBhO1wiLFJBPWBcbiAgdmVjNCBhTGVzc1RoYW5aZXJvID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuKSkpO1xuICByZXR1cm4gKGFMZXNzVGhhblplcm8gKiAoYiAqIGEpKSArICgodmVjNCgxLjApIC0gYUxlc3NUaGFuWmVybykgKiBhKTtcbmA7ZnVuY3Rpb24geWVlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHthbHBoYTpzfT1hLGk9bi5tYWtlVGVuc29ySW5mbyhbXSxcImZsb2F0MzJcIix3LmNyZWF0ZVNjYWxhclZhbHVlKHMsXCJmbG9hdDMyXCIpKSxvPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgaHAoUkEsci5zaGFwZSxpLnNoYXBlKTpuZXcga2koREEsci5zaGFwZSxpLnNoYXBlKSxsPW4ucnVuV2ViR0xQcm9ncmFtKG8sW3IsaV0sXCJmbG9hdDMyXCIpO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGkpLGx9dmFyIHhlZT17a2VybmVsTmFtZTpybyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp5ZWV9LE1BPVwicmV0dXJuIChhIDwgMC4pID8gYiAqIGEgOiBhO1wiLE9BPWBcbiAgdmVjNCBhTGVzc1RoYW5aZXJvID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuKSkpO1xuICByZXR1cm4gKGFMZXNzVGhhblplcm8gKiAoYiAqIGEpKSArICgodmVjNCgxLjApIC0gYUxlc3NUaGFuWmVybykgKiBhKTtcbmA7ZnVuY3Rpb24gdmVlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YSxhbHBoYTpyfT10LHM9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBocChPQSxhLnNoYXBlLHIuc2hhcGUpOm5ldyBraShNQSxhLnNoYXBlLHIuc2hhcGUpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShzLFthLHJdLFwiZmxvYXQzMlwiKX12YXIgd2VlPXtrZXJuZWxOYW1lOndvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnZlZX0sbXA9XCJpZiAoaXNuYW4oeCkpIHJldHVybiB4O1wiO2Z1bmN0aW9uIFplKHtvcFNuaXBwZXQ6ZSxwYWNrZWRPcFNuaXBwZXQ6dCxjcHVLZXJuZWxJbXBsOm4sZHR5cGU6YX0pe3JldHVybih7aW5wdXRzOnIsYmFja2VuZDpzfSk9PntsZXR7eDppfT1yLG89cyxsPWF8fGkuZHR5cGU7aWYoby5zaG91bGRFeGVjdXRlT25DUFUoW2ldKSYmbiE9bnVsbCl7bGV0IGQ9by50ZXhEYXRhLmdldChpLmRhdGFJZCksYz1uKGQudmFsdWVzLGwpO3JldHVybiBvLm1ha2VUZW5zb3JJbmZvKGkuc2hhcGUsbCxjKX1sZXQgdT1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSYmdCE9bnVsbCxwO3JldHVybiB1P3A9bmV3IHRzKGkuc2hhcGUsdCk6cD1uZXcgcnIoaS5zaGFwZSxlKSxvLnJ1bldlYkdMUHJvZ3JhbShwLFtpXSxsKX19ZnVuY3Rpb24gaG4oe29wU25pcHBldDplLHBhY2tlZE9wU25pcHBldDp0LGNoZWNrT3V0T2ZCb3VuZHM6bj0hMSxzdXBwb3J0c0NvbXBsZXg6YT0hMSxjcHVLZXJuZWxJbXBsOnIsZHR5cGU6c30pe3JldHVybih7aW5wdXRzOmksYmFja2VuZDpvfSk9PntsZXR7YTpsLGI6dX09aSxwPW87aWYoYSYmbC5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCBtPXAudGV4RGF0YS5nZXQobC5kYXRhSWQpLGY9cC50ZXhEYXRhLmdldCh1LmRhdGFJZCksW2csYl09W1ttLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLGYuY29tcGxleFRlbnNvckluZm9zLnJlYWxdLFttLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLGYuY29tcGxleFRlbnNvckluZm9zLmltYWddXS5tYXAoeD0+e2xldFt2LEldPXgsTj17ZGF0YUlkOnYuZGF0YUlkLGR0eXBlOnYuZHR5cGUsc2hhcGU6bC5zaGFwZX0sQz17ZGF0YUlkOkkuZGF0YUlkLGR0eXBlOkkuZHR5cGUsc2hhcGU6dS5zaGFwZX0sXz1uZXcga2koZSxsLnNoYXBlLHUuc2hhcGUpO3JldHVybiBwLnJ1bldlYkdMUHJvZ3JhbShfLFtOLENdLGZhKHYuZHR5cGUsSS5kdHlwZSkpfSkseT0kcyh7aW5wdXRzOntyZWFsOmcsaW1hZzpifSxiYWNrZW5kOnB9KTtyZXR1cm4gcC5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhnKSxwLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGIpLHl9bGV0IGQ9c3x8ZmEobC5kdHlwZSx1LmR0eXBlKTtpZigobC5kdHlwZT09PVwic3RyaW5nXCJ8fHUuZHR5cGU9PT1cInN0cmluZ1wifHxwLnNob3VsZEV4ZWN1dGVPbkNQVShbbCx1XSkpJiZyIT1udWxsKXtsZXQgbT1wLnRleERhdGEuZ2V0KGwuZGF0YUlkKS52YWx1ZXMsZj1wLnRleERhdGEuZ2V0KHUuZGF0YUlkKS52YWx1ZXMsZz1sLmR0eXBlPT09XCJzdHJpbmdcIj9ULmZyb21VaW50OFRvU3RyaW5nQXJyYXkobSk6bSxiPWwuZHR5cGU9PT1cInN0cmluZ1wiP1QuZnJvbVVpbnQ4VG9TdHJpbmdBcnJheShmKTpmLFt5LHhdPXIobC5zaGFwZSx1LnNoYXBlLGcsYixkKSx2PXAubWFrZVRlbnNvckluZm8oeCxkKSxJPXAudGV4RGF0YS5nZXQodi5kYXRhSWQpO3JldHVybiBJLnZhbHVlcz15LHZ9bGV0IGM9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpJiZ0IT1udWxsLGg7cmV0dXJuIGM/aD1uZXcgaHAodCxsLnNoYXBlLHUuc2hhcGUsbik6aD1uZXcga2koZSxsLnNoYXBlLHUuc2hhcGUpLHAucnVuV2ViR0xQcm9ncmFtKGgsW2wsdV0sZCl9fWZ1bmN0aW9uIENjKGUsdD0hMSl7aWYoZT09PVwibGluZWFyXCIpcmV0dXJuIHQ/ZWVlOlhRO2lmKGU9PT1cInJlbHVcIilyZXR1cm4gdD9uZWU6WlE7aWYoZT09PVwiZWx1XCIpcmV0dXJuIHQ/dGVlOllRO2lmKGU9PT1cInJlbHU2XCIpcmV0dXJuIHQ/YWVlOkpRO2lmKGU9PT1cInByZWx1XCIpcmV0dXJuIHQ/T0E6TUE7aWYoZT09PVwibGVha3lyZWx1XCIpcmV0dXJuIHQ/UkE6REE7aWYoZT09PVwic2lnbW9pZFwiKXJldHVybiB0P3JlZTpRUTt0aHJvdyBuZXcgRXJyb3IoYEFjdGl2YXRpb24gJHtlfSBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgZm9yIHRoZSBXZWJHTCBiYWNrZW5kLmApfXZhciBQQT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhPSExLHI9ITEscz0hMSxpPW51bGwsbz0hMSxsPSExKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wibWF0cml4QVwiLFwibWF0cml4QlwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXQgdT1hP2VbMV06ZVsyXSxwPU1hdGguY2VpbCh1LzIpLGQ9YT9cImkgKiAyLCByYy55XCI6XCJyYy55LCBpICogMlwiLGM9cj9cInJjLnosIGkgKiAyXCI6XCJpICogMiwgcmMuelwiLGg9YT9bXCJhLnh4eXlcIixcImEuenp3d1wiXTpbXCJhLnh4enpcIixcImEueXl3d1wiXSxtPXI/W1wiYi54enh6XCIsXCJiLnl3eXdcIl06W1wiYi54eXh5XCIsXCJiLnp3endcIl0sZj1cIlwiLGc9XCJcIjtpJiYobz9mPWB2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XG4gICAgICAgICAgdmVjNCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHtpfVxuICAgICAgICB9YDpsP2Y9YHZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRMZWFreXJlbHVBbHBoYUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHtpfVxuICAgICAgICB9YDpmPWB2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XG4gICAgICAgICAgJHtpfVxuICAgICAgICB9YCxnPVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTtsZXQgYj1zP1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7cyYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLG8mJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSxsJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImxlYWt5cmVsdUFscGhhXCIpO2xldCB5PVwicmMueFwiLHg9XCJyYy54XCI7ZVswXTx0WzBdP3k9YGltb2QocmMueCwgJHtlWzBdfSlgOnRbMF08ZVswXSYmKHg9YGltb2QocmMueCwgJHt0WzBdfSlgKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICR7Zn1cbiAgICAgIC8vIERvbid0IHVzZSB1bmlmb3JtIGZvciBzaGFyZWREaW1lbnNpb25QYWNrZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgY29uc3QgZmxvYXQgc2hhcmVkRGltZW5zaW9uID0gJHtwfS4wO1xuXG4gICAgICB2ZWM0IGRvdDJ4MkFSb3dCQ29sKGl2ZWMzIHJjKSB7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwKTtcbiAgICAgICAgaW50IGJhdGNoQSA9ICR7eX07XG4gICAgICAgIGludCBiYXRjaEIgPSAke3h9O1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7cH07IGkrKykge1xuICAgICAgICAgIHZlYzQgYSA9IGdldE1hdHJpeEEoYmF0Y2hBLCAke2R9KTtcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRNYXRyaXhCKGJhdGNoQiwgJHtjfSk7XG5cbiAgICAgICAgICAvLyBUaGVzZSBzd2l6emxlZCBwcm9kdWN0cyBuZWVkIHRvIGJlIHNlcGFyYXRlbHkgYWRkZWQuXG4gICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2lzc3Vlcy8xNzM1XG4gICAgICAgICAgcmVzdWx0ICs9ICgke2hbMF19ICogJHttWzBdfSk7XG4gICAgICAgICAgcmVzdWx0ICs9ICgke2hbMV19ICogJHttWzFdfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdDJ4MkFSb3dCQ29sKHJjKTtcblxuICAgICAgICAke2J9XG5cbiAgICAgICAgJHtnfVxuXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fSxsUz17UkVBTDpcInJldHVybiBhcmVhbCAqIGJyZWFsIC0gYWltYWcgKiBiaW1hZztcIixJTUFHOlwicmV0dXJuIGFyZWFsICogYmltYWcgKyBhaW1hZyAqIGJyZWFsO1wifSx1Uz1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFSZWFsXCIsXCJBSW1hZ1wiLFwiQlJlYWxcIixcIkJJbWFnXCJdLHRoaXMub3V0cHV0U2hhcGU9VC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh0LG4pLHRoaXMudXNlckNvZGU9YFxuICAgICAgZmxvYXQgYmluYXJ5T3BDb21wbGV4KFxuICAgICAgICAgIGZsb2F0IGFyZWFsLCBmbG9hdCBhaW1hZywgZmxvYXQgYnJlYWwsIGZsb2F0IGJpbWFnKSB7XG4gICAgICAgICR7ZX1cbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCBhcmVhbCA9IGdldEFSZWFsQXRPdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgYWltYWcgPSBnZXRBSW1hZ0F0T3V0Q29vcmRzKCk7XG4gICAgICAgIGZsb2F0IGJyZWFsID0gZ2V0QlJlYWxBdE91dENvb3JkcygpO1xuICAgICAgICBmbG9hdCBiaW1hZyA9IGdldEJJbWFnQXRPdXRDb29yZHMoKTtcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wQ29tcGxleChhcmVhbCwgYWltYWcsIGJyZWFsLCBiaW1hZykpO1xuICAgICAgfVxuICAgIGB9fSxwUz1cInJldHVybiBhICogYjtcIjtmdW5jdGlvbiBwayhlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHthLGI6cn09dCxzPVQudXBjYXN0VHlwZShhLmR0eXBlLHIuZHR5cGUpO2lmKGEuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXtsZXQgbz1uLnRleERhdGEuZ2V0KGEuZGF0YUlkKSxsPW4udGV4RGF0YS5nZXQoci5kYXRhSWQpLHU9bmV3IHVTKGxTLlJFQUwsYS5zaGFwZSxyLnNoYXBlKSxwPW5ldyB1UyhsUy5JTUFHLGEuc2hhcGUsci5zaGFwZSksZD1be2RhdGFJZDpvLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmRhdGFJZCxkdHlwZTpvLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsLmR0eXBlLHNoYXBlOmEuc2hhcGV9LHtkYXRhSWQ6by5jb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kYXRhSWQsZHR5cGU6by5jb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kdHlwZSxzaGFwZTphLnNoYXBlfSx7ZGF0YUlkOmwuY29tcGxleFRlbnNvckluZm9zLnJlYWwuZGF0YUlkLGR0eXBlOmwuY29tcGxleFRlbnNvckluZm9zLnJlYWwuZHR5cGUsc2hhcGU6ci5zaGFwZX0se2RhdGFJZDpsLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmRhdGFJZCxkdHlwZTpsLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnLmR0eXBlLHNoYXBlOnIuc2hhcGV9XSxjPW4ucnVuV2ViR0xQcm9ncmFtKHUsZCxcImZsb2F0MzJcIiksaD1uLnJ1bldlYkdMUHJvZ3JhbShwLGQsXCJmbG9hdDMyXCIpLG09JHMoe2lucHV0czp7cmVhbDpjLGltYWc6aH0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxtfWlmKG4uc2hvdWxkRXhlY3V0ZU9uQ1BVKFthLHJdKSl7bGV0IG89bi50ZXhEYXRhLmdldChhLmRhdGFJZCksbD1uLnRleERhdGEuZ2V0KHIuZGF0YUlkKSxbdSxwXT15UShhLnNoYXBlLHIuc2hhcGUsby52YWx1ZXMsbC52YWx1ZXMscyksZD1uLm1ha2VUZW5zb3JJbmZvKHAscyksYz1uLnRleERhdGEuZ2V0KGQuZGF0YUlkKTtyZXR1cm4gYy52YWx1ZXM9dSxkfWxldCBpO3JldHVybiBHKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/aT1uZXcgaHAocFMsYS5zaGFwZSxyLnNoYXBlKTppPW5ldyBraShwUyxhLnNoYXBlLHIuc2hhcGUpLG4ucnVuV2ViR0xQcm9ncmFtKGksW2Escl0scyl9dmFyIGtlZT17a2VybmVsTmFtZTpibyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpwa307ZnVuY3Rpb24gSWVlKGUsdCxuKXtsZXQgYT1bdmkoZS5zaGFwZSksLi4ud2koZS5zaGFwZSldLHI9e2R0eXBlOmUuZHR5cGUsc2hhcGU6YSxkYXRhSWQ6ZS5kYXRhSWR9LHM9W3ZpKHQpLC4uLndpKHQpXSxpPW5ldyBBQShzLGEpLG89ITAsbD1bYV0sdT1uLnJ1bldlYkdMUHJvZ3JhbShpLFtyXSxlLmR0eXBlLGwsbyk7cmV0dXJue2RhdGFJZDp1LmRhdGFJZCxzaGFwZTp0LGR0eXBlOnUuZHR5cGV9fWZ1bmN0aW9uIGNlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtzaGFwZTpzfT1hLGk9bixvPXcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKSxsPXcuaW5mZXJGcm9tSW1wbGljaXRTaGFwZShzLG8pLHU9dy5zaXplRnJvbVNoYXBlKGwpO3cuYXNzZXJ0KG89PT11LCgpPT5gVGhlIG5ldyBzaGFwZSAoJHtsfSkgaGFzICR7dX0gZWxlbWVudHMgYW5kIHRoZSBvbGQgc2hhcGUgKCR7ci5zaGFwZX0pIGhhcyAke299IGVsZW1lbnRzLiBUaGUgbmV3IHNoYXBlIGFuZCBvbGQgc2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5gKTtsZXQgcD1pLnRleERhdGEuZ2V0KHIuZGF0YUlkKTtyZXR1cm4gcC5pc1BhY2tlZCYmIVRjKHIuc2hhcGUsbCkmJiEocC50ZXh0dXJlIT09bnVsbCYmVGMocC5zaGFwZSxsKSk/SWVlKHIsbCxpKTooaS5pbmNSZWYoci5kYXRhSWQpLHtkYXRhSWQ6ci5kYXRhSWQsc2hhcGU6bCxkdHlwZTpyLmR0eXBlfSl9dmFyIFNlZT17a2VybmVsTmFtZTpSdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpjZX0sY1M9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTtsZXR7d2luZG93U2l6ZTpuLGJhdGNoU2l6ZTphLGluU2l6ZTpyLG91dFNpemU6c309ZTt0aGlzLm91dHB1dFNoYXBlPVthLHNdO2xldCBpPU1hdGguZmxvb3Iobi80KSo0LG89biU0LGw9XCJzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcIjtpZih0IT1udWxsKXtsZXQgcD0xL3Q7bD1gc3VtVmFsdWUgKz0gZG90KHZhbHVlcyAqICR7dy5pc0ludChwKT9wLnRvUHJlY2lzaW9uKDIpOnB9LCBvbmVzKTtgfWxldCB1PVwiXCI7ciVuPjAmJih1PWBcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSAke3J9KSB7XG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgYCksdGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XG5cbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XG4gICAgICAgICR7dX1cbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiAke259O1xuXG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtpfTsgaSArPSA0KSB7XG4gICAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyBpO1xuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgJHtsfVxuICAgICAgICB9XG5cbiAgICAgICAgaW50IGluSWR4ID0gaW5PZmZzZXQgKyAke2l9O1xuICAgICAgICBpZiAoJHtvPT09MX0pIHtcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSwgMC4wLCAwLjAsIDAuMCk7XG5cbiAgICAgICAgICAke2x9XG4gICAgICAgIH0gZWxzZSBpZiAoJHtvPT09Mn0pIHtcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksIDAuMCwgMC4wKTtcblxuICAgICAgICAgICR7bH1cbiAgICAgICAgfSBlbHNlIGlmICgke289PT0zfSkge1xuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLCAwLjApO1xuXG4gICAgICAgICAgJHtsfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChzdW1WYWx1ZSk7XG4gICAgICB9XG4gICAgYH19LE5lZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO2xldHt3aW5kb3dTaXplOm4sYmF0Y2hTaXplOmEsaW5TaXplOnIsb3V0U2l6ZTpzfT1lO3RoaXMub3V0cHV0U2hhcGU9W2Esc107bGV0IGk9XCIwLjBcIixvPVwiXCI7dD09PVwicHJvZFwiP2k9XCIxLjBcIjp0PT09XCJtaW5cIj8oaT1cIjEuMCAvIDFlLTIwXCIsbz1cIm1pblwiKTp0PT09XCJtYXhcIiYmKGk9XCItMS4wIC8gMWUtMjBcIixvPVwibWF4XCIpO2xldCBsPWAke3R9KCR7dH0oJHt0fShtaW5NYXhWYWx1ZVswXSwgbWluTWF4VmFsdWVbMV0pLCBtaW5NYXhWYWx1ZVsyXSksIG1pbk1heFZhbHVlWzNdKWA7dD09PVwic3VtXCI/bD1cInN1bVZhbHVlXCI6dD09PVwicHJvZFwiP2w9XCJwcm9kVmFsdWVcIjp0PT09XCJhbGxcIj9sPVwiYWxsVmFsdWVcIjp0PT09XCJhbnlcIiYmKGw9XCJhbnlWYWx1ZVwiKTtsZXQgdT1NYXRoLmZsb29yKG4vNCkqNCxwPW4lNCxkPWBcbiAgICAgIGlmICgke3Q9PT1cInN1bVwifSkge1xuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoJHt0PT09XCJwcm9kXCJ9KSB7XG4gICAgICAgIHZlYzIgdG1wID0gdmVjMih2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgKiB2ZWMyKHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcbiAgICAgICAgcHJvZFZhbHVlICo9IHRtcFswXSAqIHRtcFsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbk1heFZhbHVlID0gJHtvfSh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcbiAgICAgICAgaWYgKCR7dD09PVwibWluXCJ9IHx8ICR7dD09PVwibWF4XCJ9KSB7XG4gICAgICAgICAgbWluTWF4VmFsdWUgPSAke299KHZhbHVlcywgbWluTWF4VmFsdWUpO1xuICAgICAgICAgIGJ2ZWM0IGlzTmFOID0gaXNuYW4odmFsdWVzKTtcbiAgICAgICAgICBpZiAoaXNOYU4uciB8fCBpc05hTi5nIHx8IGlzTmFOLmIgfHwgaXNOYU4uYSkge1xuICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2ZWM0KE5BTik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgYCxjPVwidmVjNFwiO3Q9PT1cImFsbFwiPyhpPVwiMS4wXCIsZD1gXG4gICAgICAgIGJvb2wgcmVkdWNlZEFsbFZhbHVlID0gYWxsKHZhbHVlcyk7XG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPSBmbG9hdChyZWR1Y2VkQWxsVmFsdWUpO1xuICAgICAgICBhbGxWYWx1ZSA9IGZsb2F0KGFsbFZhbHVlID49IDEuMCAmJiBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID49IDEuMCk7XG4gICAgICBgLGM9XCJidmVjNFwiKTp0PT09XCJhbnlcIiYmKGk9XCIwLjBcIixkPWBcbiAgICAgICAgYm9vbCByZWR1Y2VkQW55VmFsdWUgPSBhbnkodmFsdWVzKTtcbiAgICAgICAgZmxvYXQgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA9IGZsb2F0KHJlZHVjZWRBbnlWYWx1ZSk7XG4gICAgICAgIGFueVZhbHVlID0gZmxvYXQoYW55VmFsdWUgPj0gMS4wIHx8IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPj0gMS4wKTtcbiAgICAgIGAsYz1cImJ2ZWM0XCIpO2xldCBoPVwiXCI7ciVuPjAmJihoPWBcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSAke3J9KSB7XG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGApLHRoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICR7aX07XG4gICAgICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIDEuMCk7XG5cbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XG4gICAgICAgICR7aH1cbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiAke259O1xuXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KCR7aX0pO1xuICAgICAgICBmbG9hdCBwcm9kVmFsdWUgPSAxLjA7XG4gICAgICAgIGZsb2F0IHN1bVZhbHVlID0gMC4wO1xuICAgICAgICBmbG9hdCBhbGxWYWx1ZSA9IDEuMDtcbiAgICAgICAgZmxvYXQgYW55VmFsdWUgPSAwLjA7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3V9OyBpICs9IDQpIHtcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XG4gICAgICAgICAgJHtjfSB2YWx1ZXMgPSAke2N9KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAzKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAke2R9XG4gICAgICAgIH1cblxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArICR7dX07XG4gICAgICAgIGlmICgke3A9PT0xfSkge1xuICAgICAgICAgICR7Y30gdmFsdWVzID0gJHtjfShcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgJHtkfVxuICAgICAgICB9IGVsc2UgaWYgKCR7cD09PTJ9KSB7XG4gICAgICAgICAgJHtjfSB2YWx1ZXMgPSAke2N9KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgJHtkfVxuICAgICAgICB9IGVsc2UgaWYgKCR7cD09PTN9KSB7XG4gICAgICAgICAgJHtjfSB2YWx1ZXMgPSAke2N9KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7ZH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoJHtsfSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIFRlZShlKXtsZXQgdD1bXTtmb3IoO3QubGVuZ3RoPT09MHx8dFt0Lmxlbmd0aC0xXS5vdXRTaXplIT09MTspe2xldCBuPXQubGVuZ3RoP3RbdC5sZW5ndGgtMV0ub3V0U2l6ZTplWzFdLGE9VC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUobik7dC5wdXNoKHtpblNpemU6bix3aW5kb3dTaXplOmEsb3V0U2l6ZTpNYXRoLmNlaWwobi9hKX0pfXJldHVybiB0fWZ1bmN0aW9uIGVsKGUsdCxuLGEpe2xldCByPVRlZShlLnNoYXBlKSxzPWU7Zm9yKGxldCBpPTA7aTxyLmxlbmd0aDtpKyspe2xldHtpblNpemU6byx3aW5kb3dTaXplOmwsb3V0U2l6ZTp1fT1yW2ldLHAsZDtuPT09XCJtZWFuXCI/cD1pPT09MD9uZXcgY1Moe3dpbmRvd1NpemU6bCxpblNpemU6byxiYXRjaFNpemU6ZS5zaGFwZVswXSxvdXRTaXplOnV9LG8pOm5ldyBjUyh7d2luZG93U2l6ZTpsLGluU2l6ZTpvLGJhdGNoU2l6ZTplLnNoYXBlWzBdLG91dFNpemU6dX0pOnA9bmV3IE5lZSh7d2luZG93U2l6ZTpsLGluU2l6ZTpvLGJhdGNoU2l6ZTplLnNoYXBlWzBdLG91dFNpemU6dX0sbiksZD1zLHM9YS5ydW5XZWJHTFByb2dyYW0ocCxbc10sdCksZC5kYXRhSWQhPT1lLmRhdGFJZCYmYS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhkKX1yZXR1cm4gc312YXIgQ2VlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07bGV0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyluW3NdPWVbdFtzXV07dGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aDtsZXQgYT1odCh0aGlzLnJhbmspLHI9RWVlKHQpO3RoaXMudXNlckNvZGU9YFxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICR7YX0gcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgIHNldE91dHB1dChnZXRBKCR7cn0pKTtcbiAgICB9XG4gICAgYH19O2Z1bmN0aW9uIEVlZShlKXtsZXQgdD1lLmxlbmd0aDtpZih0PjYpdGhyb3cgRXJyb3IoYFRyYW5zcG9zZSBmb3IgcmFuayAke3R9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7bGV0IG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiLFwicmVzUkMudlwiXSxhPW5ldyBBcnJheSh0KTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKylhW2Vbcl1dPW5bcl07cmV0dXJuIGEuam9pbigpfXZhciBfZWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMDtsZXQgbj1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgdT0wO3U8bi5sZW5ndGg7dSsrKW5bdV09ZVt0W3VdXTtpZih0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoLHRoaXMucmFuaz42KXRocm93IEVycm9yKGBQYWNrZWQgdHJhbnNwb3NlIGZvciByYW5rICR7dGhpcy5yYW5rfSBpcyBub3QgeWV0IHN1cHBvcnRlZC5gKTtsZXQgYT1odCh0aGlzLnJhbmspLHI9X0EoXCJyY1wiLHRoaXMucmFuaykscz1uZXcgQXJyYXkodGhpcy5yYW5rKTtmb3IobGV0IHU9MDt1PHQubGVuZ3RoO3UrKylzW3RbdV1dPXJbdV07bGV0IGk9YHZlYzIoJHtzLnNsaWNlKC0yKS5qb2luKCl9KWAsbz1gKyske3JbdGhpcy5yYW5rLTFdfSA8ICR7blt0aGlzLnJhbmstMV19YCxsPWBnZXRDaGFubmVsKGdldEEoJHtzLmpvaW4oKX0pLCAke2l9KWA7dGhpcy51c2VyQ29kZT1gXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgJHthfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcbiAgICAgIHJlc3VsdFswXSA9ICR7bH07XG4gICAgICBpZigke299KSB7XG4gICAgICAgIHJlc3VsdFsxXSA9ICR7bH07XG4gICAgICB9XG4gICAgICAtLSR7clt0aGlzLnJhbmstMV19O1xuICAgICAgaWYoKyske3JbdGhpcy5yYW5rLTJdfSA8ICR7blt0aGlzLnJhbmstMl19KSB7XG4gICAgICAgIHJlc3VsdFsyXSA9ICR7bH07XG4gICAgICAgIGlmKCR7b30pIHtcbiAgICAgICAgICByZXN1bHRbM10gPSAke2x9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICB9XG4gICAgYH19O2Z1bmN0aW9uIEJmKGUsdCxuKXtsZXQgYT1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgX2VlKGUuc2hhcGUsdCk6bmV3IENlZShlLnNoYXBlLHQpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShhLFtlXSxlLmR0eXBlKX1mdW5jdGlvbiBBZWUoZSx0LG4sYSl7bGV0IHI9dCxzPWUuc2hhcGUubGVuZ3RoLGk9dy5wYXJzZUF4aXNQYXJhbShyLGUuc2hhcGUpLG89aSxsPVQuZ2V0QXhlc1Blcm11dGF0aW9uKG8scyksdT1sIT1udWxsLHA9ZTt1JiYocD1CZihlLGwsYSksbz1ULmdldElubmVyTW9zdEF4ZXMoby5sZW5ndGgscykpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJzdW1cIixvLHMpO2xldFtkLGNdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhwLnNoYXBlLG8pLGg9ZDtuJiYoaD1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGQsaSkpO2xldCBtPXcuc2l6ZUZyb21TaGFwZShjKSxmPXcuc2l6ZUZyb21TaGFwZShlLnNoYXBlKS9tLGc9Y2Uoe2lucHV0czp7eDpwfSxhdHRyczp7c2hhcGU6W2YsbV19LGJhY2tlbmQ6YX0pLGI9TW0oZS5kdHlwZSkseT1lbChnLGIsXCJzdW1cIixhKSx4PWNlKHtpbnB1dHM6e3g6eX0sYXR0cnM6e3NoYXBlOmh9LGJhY2tlbmQ6YX0pO3JldHVybiBhLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLGEuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeSksdSYmYS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKSx4fWZ1bmN0aW9uIFZmKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YTtyZXR1cm4gQWVlKHIscyxpLG4pfXZhciBGZWU9e2tlcm5lbE5hbWU6TG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6VmZ9O2Z1bmN0aW9uIFNuKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtwZXJtOnN9PWEsaT1uLG89ci5zaGFwZS5sZW5ndGgsbD1uZXcgQXJyYXkobyk7Zm9yKGxldCBwPTA7cDxsLmxlbmd0aDtwKyspbFtwXT1yLnNoYXBlW3NbcF1dO2xldCB1O2lmKGkuc2hvdWxkRXhlY3V0ZU9uQ1BVKFtyXSkpe2xldCBwPWkudGV4RGF0YS5nZXQoci5kYXRhSWQpLnZhbHVlcyxkPW9rKHAsci5zaGFwZSxyLmR0eXBlLHMsbCk7dT1pLm1ha2VUZW5zb3JJbmZvKGwsci5kdHlwZSk7bGV0IGM9aS50ZXhEYXRhLmdldCh1LmRhdGFJZCk7Yy52YWx1ZXM9ZH1lbHNlIHU9QmYocixzLGkpO3JldHVybiB1fXZhciAkZWU9e2tlcm5lbE5hbWU6Q3IsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6U259LExBPTFlMztmdW5jdGlvbiBobSh7YTplLGI6dCx0cmFuc3Bvc2VBOm4sdHJhbnNwb3NlQjphLGJhY2tlbmQ6cixiaWFzOnM9bnVsbCxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOmk9bnVsbCxsZWFreXJlbHVBbHBoYTpvPTAsYWN0aXZhdGlvbjpsPW51bGx9KXtsZXQgdT1lLnNoYXBlLmxlbmd0aCxwPXQuc2hhcGUubGVuZ3RoLGQ9bj9lLnNoYXBlW3UtMl06ZS5zaGFwZVt1LTFdLGM9YT90LnNoYXBlW3AtMV06dC5zaGFwZVtwLTJdLGg9bj9lLnNoYXBlW3UtMV06ZS5zaGFwZVt1LTJdLG09YT90LnNoYXBlW3AtMl06dC5zaGFwZVtwLTFdLGY9ZS5zaGFwZS5zbGljZSgwLC0yKSxnPXQuc2hhcGUuc2xpY2UoMCwtMiksYj13LnNpemVGcm9tU2hhcGUoZikseT13LnNpemVGcm9tU2hhcGUoZykseD1KdS5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLnNoYXBlLnNsaWNlKDAsLTIpLHQuc2hhcGUuc2xpY2UoMCwtMikpLmNvbmNhdChbaCxtXSk7dy5hc3NlcnQoZD09PWMsKCk9PmBFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoJHtkfSkgYW5kICgke2N9KSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzICR7ZS5zaGFwZX0gYW5kICR7dC5zaGFwZX0gYW5kIHRyYW5zcG9zZUE9JHtufSBhbmQgdHJhbnNwb3NlQj0ke2F9IG11c3QgbWF0Y2guYCk7bGV0IHY9bj9bYixkLGhdOltiLGgsZF0sST1hP1t5LG0sY106W3ksYyxtXSxOPWNlKHtpbnB1dHM6e3g6ZX0sYmFja2VuZDpyLGF0dHJzOntzaGFwZTp2fX0pLEM9Y2Uoe2lucHV0czp7eDp0fSxiYWNrZW5kOnIsYXR0cnM6e3NoYXBlOkl9fSksXz1bTixDXSxGPU1hdGgubWF4KGIseSksRD1uP04uc2hhcGVbMV06Ti5zaGFwZVsyXSwkPXMhPW51bGwsUz1pIT1udWxsLE09bD09PVwibGVha3lyZWx1XCIsQj1sIT1udWxsP0NjKGwsITApOm51bGwsVT0kfHxTfHxNfHxCIT1udWxsLEg7aWYoKGg9PT0xfHxtPT09MSkmJkQ+TEEmJlU9PT0hMSl7bGV0IEs9TixaPUM7biYmKEs9U24oe2lucHV0czp7eDpOfSxiYWNrZW5kOnIsYXR0cnM6e3Blcm06WzAsMiwxXX19KSxfLnB1c2goSykpLGEmJihaPVNuKHtpbnB1dHM6e3g6Q30sYmFja2VuZDpyLGF0dHJzOntwZXJtOlswLDIsMV19fSksXy5wdXNoKFopKTtsZXQgSj1tIT09MSxlZT1tPT09MSxhZT1LO0omJihhZT1jZSh7aW5wdXRzOnt4Okt9LGJhY2tlbmQ6cixhdHRyczp7c2hhcGU6W0YsRCwxXX19KSxfLnB1c2goYWUpKTtsZXQgdGU9bT09PTE/MjoxLHNlPVo7ZWUmJihzZT1jZSh7aW5wdXRzOnt4Olp9LGJhY2tlbmQ6cixhdHRyczp7c2hhcGU6W0YsMSxEXX19KSxfLnB1c2goc2UpKTtsZXQgaWU9cGsoe2lucHV0czp7YTphZSxiOnNlfSxiYWNrZW5kOnJ9KTtIPVZmKHtpbnB1dHM6e3g6aWV9LGJhY2tlbmQ6cixhdHRyczp7YXhpczp0ZSxrZWVwRGltczohMH19KSxfLnB1c2goaWUpfWVsc2V7bGV0IEs9ZmEoZS5kdHlwZSx0LmR0eXBlKSxaPW5ldyBQQSh2LEksW0YsaCxtXSxuLGEsJCxCLFMsTSksSj1bTixDXTtpZihzIT1udWxsJiZKLnB1c2gocyksUyYmSi5wdXNoKGkpLE0pe2xldCBlZT1yLm1ha2VUZW5zb3JJbmZvKFtdLFwiZmxvYXQzMlwiLHcuY3JlYXRlU2NhbGFyVmFsdWUobyxcImZsb2F0MzJcIikpO0oucHVzaChlZSksXy5wdXNoKGVlKX1IPXIucnVuV2ViR0xQcm9ncmFtKFosSixLKX1sZXQgcT1jZSh7aW5wdXRzOnt4Okh9LGJhY2tlbmQ6cixhdHRyczp7c2hhcGU6eH19KTtfLnB1c2goSCk7Zm9yKGxldCBLIG9mIF8pci5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhLKTtyZXR1cm4gcX1mdW5jdGlvbiBEZWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHthOnIsYjpzLGJpYXM6aSxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOm99PXQse3RyYW5zcG9zZUE6bCx0cmFuc3Bvc2VCOnUsYWN0aXZhdGlvbjpwLGxlYWt5cmVsdUFscGhhOmR9PWE7cmV0dXJuIGhtKHthOnIsYjpzLHRyYW5zcG9zZUE6bCx0cmFuc3Bvc2VCOnUsYmFja2VuZDpuLGJpYXM6aSxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOm8sbGVha3lyZWx1QWxwaGE6ZCxhY3RpdmF0aW9uOnB9KX12YXIgUmVlPXtrZXJuZWxOYW1lOmlpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkRlZX0sZFM9XCJyZXR1cm4gYWJzKHgpO1wiO2Z1bmN0aW9uIE1lZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQ7aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW2FdKSYmYS5kdHlwZSE9PVwiY29tcGxleDY0XCIpe2xldCBzPW4udGV4RGF0YS5nZXQoYS5kYXRhSWQpLGk9Q0Eocy52YWx1ZXMpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKGEuc2hhcGUsYS5kdHlwZSxpKX1sZXQgcjtyZXR1cm4gRygpLmdldEJvb2woXCJXRUJHTF9QQUNLX1VOQVJZX09QRVJBVElPTlNcIik/cj1uZXcgdHMoYS5zaGFwZSxkUyk6cj1uZXcgcnIoYS5zaGFwZSxkUyksbi5ydW5XZWJHTFByb2dyYW0ocixbYV0sYS5kdHlwZSl9dmFyIE9lZT17a2VybmVsTmFtZTpZbCxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpNZWV9LFBlZT1EYStgXG4gIGlmIChhYnMoeCkgPiAxLikge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgcmV0dXJuIGFjb3MoeCk7XG5gLExlZT1aZSh7b3BTbmlwcGV0OlBlZX0pLHplZT17a2VybmVsTmFtZTpOaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpMZWV9LFdlZT1EYStgXG4gIGlmICh4IDwgMS4wKSByZXR1cm4gTkFOO1xucmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCAtIDEuMCkpO2AsQmVlPVplKHtvcFNuaXBwZXQ6V2VlfSksVmVlPXtrZXJuZWxOYW1lOlRpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkJlZX0saFM9XCJyZXR1cm4gYSArIGI7XCIsVWVlPWhuKHtvcFNuaXBwZXQ6aFMscGFja2VkT3BTbmlwcGV0OmhTLHN1cHBvcnRzQ29tcGxleDohMCxjcHVLZXJuZWxJbXBsOlo5fSksR2VlPXtrZXJuZWxOYW1lOnZzLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlVlZX0sSGVlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy52YXJpYWJsZU5hbWVzPXQubWFwKChyLHMpPT5gVCR7c31gKTtsZXQgbj1bXTt0aGlzLnZhcmlhYmxlTmFtZXMuZm9yRWFjaChyPT57bi5wdXNoKGBmbG9hdCB2JHtyfSA9IGdldCR7cn1BdE91dENvb3JkcygpO2ApfSk7bGV0IGE9dGhpcy52YXJpYWJsZU5hbWVzLm1hcChyPT5gdiR7cn1gKS5qb2luKFwiICsgXCIpO3RoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke24uam9pbihgXG4gICAgICAgIGApfVxuXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9ICR7YX07XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fSxqZWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnZhcmlhYmxlTmFtZXM9dC5tYXAoKHIscyk9PmBUJHtzfWApO2xldCBuPVtdO3RoaXMudmFyaWFibGVOYW1lcy5mb3JFYWNoKHI9PntuLnB1c2goYHZlYzQgdiR7cn0gPSBnZXQke3J9QXRPdXRDb29yZHMoKTtgKX0pO2xldCBhPXRoaXMudmFyaWFibGVOYW1lcy5tYXAocj0+YHYke3J9YCkuam9pbihcIiArIFwiKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtuLmpvaW4oYFxuICAgICAgICBgKX1cblxuICAgICAgICB2ZWM0IHJlc3VsdCA9ICR7YX07XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBCaChlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLGE9dDtpZihhLmxlbmd0aD09PTEpcmV0dXJuIHRhKHtpbnB1dHM6e3g6YVswXX0sYmFja2VuZDpufSk7aWYoYS5sZW5ndGg+RygpLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIikpe2xldCBvPU1hdGguZmxvb3IoYS5sZW5ndGgvMiksbD1CaCh7aW5wdXRzOmEuc2xpY2UoMCxvKSxiYWNrZW5kOm59KSx1PUJoKHtpbnB1dHM6YS5zbGljZShvKSxiYWNrZW5kOm59KTtyZXR1cm4gQmgoe2lucHV0czpbbCx1XSxiYWNrZW5kOm59KX1sZXQgcj1hLm1hcChvPT5vLmR0eXBlKS5yZWR1Y2UoKG8sbCk9PmZhKG8sbCkpLHM9YS5tYXAobz0+by5zaGFwZSksaT1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IGplZShhWzBdLnNoYXBlLHMpOm5ldyBIZWUoYVswXS5zaGFwZSxzKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oaSxhLHIpfXZhciBxZWU9e2tlcm5lbE5hbWU6Q2ksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Qmh9O2Z1bmN0aW9uIEtlZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGtlZXBEaW1zOml9PWEsbz1yLnNoYXBlLmxlbmd0aCxsPXcucGFyc2VBeGlzUGFyYW0ocyxyLnNoYXBlKSx1PWwscD1ULmdldEF4ZXNQZXJtdXRhdGlvbih1LG8pLGQ9cjtwIT1udWxsJiYoZD1Tbih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpwfX0pLHU9VC5nZXRJbm5lck1vc3RBeGVzKHUubGVuZ3RoLG8pKSxULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYWxsXCIsdSxvKTtsZXRbYyxoXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoZC5zaGFwZSx1KSxtPXcuc2l6ZUZyb21TaGFwZShoKSxmPWNlKHtpbnB1dHM6e3g6ZH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbLTEsbV19fSksZz1lbChmLGYuZHR5cGUsXCJhbGxcIixuKSxiO2lmKGkpe2xldCB5PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oYyxsKTtiPWNlKHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp5fX0pfWVsc2UgYj1jZSh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Y319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLHAhPW51bGwmJm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksYn12YXIgWGVlPXtrZXJuZWxOYW1lOlpsLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOktlZX07ZnVuY3Rpb24gWWVlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YSxvPXIuc2hhcGUubGVuZ3RoLGw9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLHU9bCxwPVQuZ2V0QXhlc1Blcm11dGF0aW9uKHUsbyksZD1yO3AhPW51bGwmJihkPVNuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOnB9fSksdT1ULmdldElubmVyTW9zdEF4ZXModS5sZW5ndGgsbykpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhbnlcIix1LG8pO2xldFtjLGhdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhkLnNoYXBlLHUpLG09dy5zaXplRnJvbVNoYXBlKGgpLGY9Y2Uoe2lucHV0czp7eDpkfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOlstMSxtXX19KSxnPWVsKGYsZi5kdHlwZSxcImFueVwiLG4pLGI7aWYoaSl7bGV0IHk9VC5leHBhbmRTaGFwZVRvS2VlcERpbShjLGwpO2I9Y2Uoe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnl9fSl9ZWxzZSBiPWNlKHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpjfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZykscCE9bnVsbCYmbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhkKSxifXZhciBaZWU9e2tlcm5lbE5hbWU6SmwsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6WWVlfSxKZWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO2xldHt3aW5kb3dTaXplOmEsYmF0Y2hTaXplOnIsb3V0U2l6ZTpzfT1lO258fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpLHRoaXMub3V0cHV0U2hhcGU9W3Isc107bGV0IGk9dD09PVwibWF4XCI/XCI+XCI6XCI8XCIsbz1uP1wiaW5PZmZzZXQgKyBpO1wiOlwicm91bmQoZ2V0QmVzdEluZGljZXNBKGJhdGNoLCBpbk9mZnNldCArIGkpKTtcIjt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogJHthfTtcblxuICAgICAgICBpbnQgYmVzdEluZGV4ID0gaW5PZmZzZXQ7XG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGJlc3RJbmRleCk7XG5cbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2F9OyBpKyspIHtcbiAgICAgICAgICBpbnQgaW5JZHggPSAke299O1xuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEEoYmF0Y2gsIGluSWR4KTtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlICR7aX0gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpbklkeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGJlc3RJbmRleCkpO1xuICAgICAgfVxuICAgIGB9fSxRZWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdy5hc3NlcnQoZS5sZW5ndGg+MiwoKT0+YFBhY2tlZCBhcmcke24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKX0gc3VwcG9ydHMgb25seSBpbnB1dHMgd2l0aCByYW5rIGFib3ZlIDIuYCk7bGV0IHI9ZVtlLmxlbmd0aC0xXSxzPU1hdGguY2VpbChyL3QpO3RoaXMub3V0cHV0U2hhcGU9ZS5zbGljZSgwLC0xKSxzPjEmJnRoaXMub3V0cHV0U2hhcGUucHVzaChzKSxhfHx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJlc3RJbmRpY2VzQVwiKTtsZXQgaT10aGlzLm91dHB1dFNoYXBlLG89aS5sZW5ndGgsbD1odChvKSx1PUluKFwiY29vcmRzXCIsbykscCxkO2lmKHM9PT0xKXtkPW8rMTtsZXQgQz1odChkKTtwPWBcbiAgICAgICAgJHtDfSBzb3VyY2VMb2NSID0gJHtDfSgke3Uuam9pbigpfSwgMCk7XG4gICAgICAgICsrJHt1W28tMV19O1xuICAgICAgICAke0N9IHNvdXJjZUxvY0cgPSAke0N9KCR7dS5qb2luKCl9LCAwKTtcbiAgICAgICAgKyske3Vbby0yXX07XG4gICAgICAgICR7Q30gc291cmNlTG9jQSA9ICR7Q30oJHt1LmpvaW4oKX0sIDApO1xuICAgICAgICAtLSR7dVtvLTFdfTtcbiAgICAgICAgJHtDfSBzb3VyY2VMb2NCID0gJHtDfSgke3Uuam9pbigpfSwgMCk7XG4gICAgICAgIC0tJHt1W28tMl19O2B9ZWxzZSBkPW8scD1gXG4gICAgICAgICR7bH0gc291cmNlTG9jUiA9IGNvb3JkcztcbiAgICAgICAgKyske3Vbby0xXX07XG4gICAgICAgICR7bH0gc291cmNlTG9jRyA9IGNvb3JkcztcbiAgICAgICAgKyske3Vbby0yXX07XG4gICAgICAgICR7bH0gc291cmNlTG9jQSA9IGNvb3JkcztcbiAgICAgICAgLS0ke3Vbby0xXX07XG4gICAgICAgICR7bH0gc291cmNlTG9jQiA9IGNvb3JkcztcbiAgICAgICAgLS0ke3Vbby0yXX07YDtsZXQgYz1bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAsZCksaD1cIi5cIitjW2QtMV0sbT1jLm1hcChDPT5cImludCBcIitDKSxmPUluKFwic291cmNlTG9jUlwiLGQtMSkuY29uY2F0KFwiaW5JZHguclwiKSxnPUluKFwic291cmNlTG9jR1wiLGQtMSkuY29uY2F0KFwiaW5JZHguZ1wiKSxiPUluKFwic291cmNlTG9jQlwiLGQtMSkuY29uY2F0KFwiaW5JZHguYlwiKSx5PUluKFwic291cmNlTG9jQVwiLGQtMSkuY29uY2F0KFwiaW5JZHguYVwiKSx4PW49PT1cIm1heFwiP1wiZ3JlYXRlclRoYW5cIjpcImxlc3NUaGFuXCIsdj1hP1wiXCI6YFxuICAgICAgICAgIGluSWR4ID0gcm91bmQodmVjNChnZXRCZXN0SW5kaWNlc0FDaGFubmVsKCR7Zi5qb2luKCl9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbCgke2cuam9pbigpfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoJHtiLmpvaW4oKX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKCR7eS5qb2luKCl9KSkpO2AsST1gdmVjNChcbiAgICAgICAgICAgIGdldEFDaGFubmVsKCR7Zi5qb2luKCl9KSxcbiAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBQ2hhbm5lbCgke2cuam9pbigpfSkgOiAwLixcbiAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBQ2hhbm5lbCgke2Iuam9pbigpfSkgOiAwLixcbiAgICAgICAgICAgIGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCA/IGdldEFDaGFubmVsKCR7eS5qb2luKCl9KSA6IDAuKWAsTj1hP1wiXCI6YFxuICAgICAgZmxvYXQgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbCgke20uam9pbigpfSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRCZXN0SW5kaWNlc0EoJHtjLmpvaW4oKX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2Muc2xpY2UoLTIpLmpvaW4oKX0pKTtcbiAgICAgIH1gO3RoaXMudXNlckNvZGU9YFxuICAgICAgZmxvYXQgZ2V0QUNoYW5uZWwoJHttLmpvaW4oKX0pIHtcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QSgke2Muam9pbigpfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke2Muc2xpY2UoLTIpLmpvaW4oKX0pKTtcbiAgICAgIH1cbiAgICAgICR7Tn1cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtsfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgYm9vbCBoYXNOZXh0Q29sID0gJHt1W28tMV19IDwgJHtpW28tMV0tMX07XG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9ICR7dVtvLTJdfSA8ICR7aVtvLTJdLTF9O1xuICAgICAgICAke3B9XG4gICAgICAgIGl2ZWM0IHNyY0lkeCA9IGl2ZWM0KHNvdXJjZUxvY1Ike2h9LCBzb3VyY2VMb2NHJHtofSxcbiAgICAgICAgICBzb3VyY2VMb2NCJHtofSwgc291cmNlTG9jQSR7aH0pICogJHt0fTtcbiAgICAgICAgaXZlYzQgaW5JZHggPSBzcmNJZHg7XG4gICAgICAgIHZlYzQgYmVzdEluZGV4ID0gdmVjNChpbklkeCk7XG4gICAgICAgIHZlYzQgYmVzdFZhbHVlID0gJHtJfTtcblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7dH07IGkrKykge1xuICAgICAgICAgIGluSWR4ID0gc3JjSWR4O1xuICAgICAgICAgICR7dn1cbiAgICAgICAgICB2ZWM0IGNhbmRpZGF0ZSA9ICR7SX07XG4gICAgICAgICAgYnZlYzQgbmFuID0gaXNuYW4oY2FuZGlkYXRlKTtcbiAgICAgICAgICBidmVjNCByZXBsYWNlID0gYnZlYzQoXG4gICAgICAgICAgICB2ZWM0KCR7eH0oY2FuZGlkYXRlLCBiZXN0VmFsdWUpKSAqICh2ZWM0KDEuMCkgLSB2ZWM0KG5hbikpKTtcblxuICAgICAgICAgIGJlc3RWYWx1ZSA9IHZlYzQocmVwbGFjZS54ICA/IGNhbmRpZGF0ZS54IDogYmVzdFZhbHVlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnkgID8gY2FuZGlkYXRlLnkgOiBiZXN0VmFsdWUueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UueiAgPyBjYW5kaWRhdGUueiA6IGJlc3RWYWx1ZS56LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS53ICA/IGNhbmRpZGF0ZS53IDogYmVzdFZhbHVlLncpO1xuICAgICAgICAgIGJlc3RJbmRleCA9IG1peChiZXN0SW5kZXgsIHZlYzQoaW5JZHgpLCB2ZWM0KHJlcGxhY2UpKTtcbiAgICAgICAgICBzcmNJZHgrKztcbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoYmVzdEluZGV4KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gekEoZSx0LG4sYT1udWxsKXtsZXQgcj10LnNoYXBlWzBdLHM9dC5zaGFwZVsxXTthIT1udWxsJiYocj1hLnNoYXBlWzBdLHM9YS5zaGFwZVsxXSk7bGV0IGk9VC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUocyksbz17d2luZG93U2l6ZTppLGluU2l6ZTpzLGJhdGNoU2l6ZTpyLG91dFNpemU6TWF0aC5jZWlsKHMvaSl9LGw9bmV3IEplZShvLG4sYT09bnVsbCksdT1bdF07YSE9bnVsbCYmdS5wdXNoKGEpO2xldCBwPWUucnVuV2ViR0xQcm9ncmFtKGwsdSxcImludDMyXCIpO2lmKHAuc2hhcGVbMV09PT0xKXJldHVybiBwO2xldCBkPXpBKGUsdCxuLHApO3JldHVybiBlLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApLGR9ZnVuY3Rpb24gV0EoZSx0LG4sYT1udWxsKXtsZXQgcj1hIT1udWxsP2Euc2hhcGU6dC5zaGFwZSxzPXJbci5sZW5ndGgtMV0saT1ULmNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShzKSxvPW5ldyBRZWUocixpLG4sYT09bnVsbCksbD1hPT1udWxsP1t0XTpbdCxhXSx1PWUucnVuV2ViR0xQcm9ncmFtKG8sbCxcImludDMyXCIpO2lmKHUuc2hhcGUubGVuZ3RoPT09dC5zaGFwZS5sZW5ndGgpe2xldCBwPVdBKGUsdCxuLHUpO3JldHVybiBlLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHUpLHB9cmV0dXJuIHV9ZnVuY3Rpb24gQkEoZSx0LG4sYSl7bGV0IHI9W25dO2lmKFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJhcmdcIithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSkscix0LnNoYXBlLmxlbmd0aCksIUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19SRURVQ0VcIil8fHQuc2hhcGUubGVuZ3RoPD0yKXtsZXQgcz1bXSxpPWUudGV4RGF0YS5nZXQodC5kYXRhSWQpLG89aSE9PW51bGwmJmkuaXNQYWNrZWQsbD10O28mJihsPWUudW5wYWNrVGVuc29yKHQpLHMucHVzaChsKSk7bGV0W3UscF09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGwuc2hhcGUsciksZD13LnNpemVGcm9tU2hhcGUocCksYz1jZSh7aW5wdXRzOnt4Omx9LGJhY2tlbmQ6ZSxhdHRyczp7c2hhcGU6Wy0xLGRdfX0pO3MucHVzaChjKTtsZXQgaD16QShlLGMsYSk7cy5wdXNoKGgpO2xldCBtPWNlKHtpbnB1dHM6e3g6aH0sYmFja2VuZDplLGF0dHJzOntzaGFwZTp1fX0pO3JldHVybiBzLmZvckVhY2goZj0+ZS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSksbX1yZXR1cm4gV0EoZSx0LGEpfWZ1bmN0aW9uIGV0ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzfT1hLGk9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLG89VC5nZXRBeGVzUGVybXV0YXRpb24oaSxyLnNoYXBlLmxlbmd0aCksbD1yLHU9W107byE9bnVsbCYmKGw9U24oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06b319KSx1LnB1c2gobCksaT1ULmdldElubmVyTW9zdEF4ZXMoaS5sZW5ndGgsbC5zaGFwZS5sZW5ndGgpKSxULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYXJnTWF4XCIsW2lbMF1dLGwuc2hhcGUubGVuZ3RoKTtsZXQgcD1CQShuLGwsaVswXSxcIm1heFwiKTtyZXR1cm4gdS5mb3JFYWNoKGQ9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCkpLHB9dmFyIHR0ZT17a2VybmVsTmFtZTpRbCxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpldGV9O2Z1bmN0aW9uIG50ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzfT1hLGk9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLG89VC5nZXRBeGVzUGVybXV0YXRpb24oaSxyLnNoYXBlLmxlbmd0aCksbD1yLHU9W107byE9bnVsbCYmKGw9U24oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06b319KSx1LnB1c2gobCksaT1ULmdldElubmVyTW9zdEF4ZXMoaS5sZW5ndGgsbC5zaGFwZS5sZW5ndGgpKSxULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYXJnTWluXCIsW2lbMF1dLGwuc2hhcGUubGVuZ3RoKTtsZXQgcD1CQShuLGwsaVswXSxcIm1pblwiKTtyZXR1cm4gdS5mb3JFYWNoKGQ9Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCkpLHB9dmFyIGF0ZT17a2VybmVsTmFtZTpldSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpudGV9LHJ0ZT1EYStgXG4gIGlmIChhYnMoeCkgPiAxLikge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgcmV0dXJuIGFzaW4oeCk7XG5gLHN0ZT1aZSh7b3BTbmlwcGV0OnJ0ZX0pLGl0ZT17a2VybmVsTmFtZTpFaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpzdGV9LG90ZT1EYStcInJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxLjApKTtcIixsdGU9WmUoe29wU25pcHBldDpvdGV9KSx1dGU9e2tlcm5lbE5hbWU6X2ksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6bHRlfSxwdGU9RGErYFxuICByZXR1cm4gYXRhbih4KTtcbmAsY3RlPVplKHtvcFNuaXBwZXQ6cHRlfSksZHRlPXtrZXJuZWxOYW1lOkFpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmN0ZX0saHRlPXVrK2BcbiAgcmV0dXJuIGF0YW4oYSwgYik7XG5gLG10ZT1gXG4gIHZlYzQgcmVzdWx0ID0gYXRhbihhLCBiKTtcbiAgYnZlYzQgaXNOYU5BID0gaXNuYW4oYSk7XG4gIGJ2ZWM0IGlzTmFOQiA9IGlzbmFuKGIpO1xuICBidmVjNCBpc05hTiA9IGJ2ZWM0KGlzTmFOQS54IHx8IGlzTmFOQi54LCBpc05hTkEueSB8fCBpc05hTkIueSwgaXNOYU5BLnogfHwgaXNOYU5CLnosIGlzTmFOQS53IHx8IGlzTmFOQi53KTtcbiAgYCtRbytgXG4gIHJldHVybiByZXN1bHQ7XG5gLGZ0ZT1obih7b3BTbmlwcGV0Omh0ZSxwYWNrZWRPcFNuaXBwZXQ6bXRlfSksZ3RlPXtrZXJuZWxOYW1lOiRpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ0ZX0sYnRlPURhK2BcbiAgaWYgKCh4IDwgLTEuMCkgfHwgKHggPiAxLjApKSByZXR1cm4gTkFOO1xucmV0dXJuIChsb2coMS4wICsgeCkgLSBsb2coMS4wIC0geCkpIC8gMi4wO2AseXRlPVplKHtvcFNuaXBwZXQ6YnRlfSkseHRlPXtrZXJuZWxOYW1lOkZpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnl0ZX0sRWM9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYT0hMSxyPSExKXtpZih0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0PT09XCJhdmdcIiYmbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC5cIik7bGV0IHM9ZS5maWx0ZXJXaWR0aCxpPWUuc3RyaWRlSGVpZ2h0LG89ZS5zdHJpZGVXaWR0aCxsPWUuZGlsYXRpb25IZWlnaHQsdT1lLmRpbGF0aW9uV2lkdGgscD1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxkPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsYz1lLnBhZEluZm8udG9wLGg9ZS5wYWRJbmZvLmxlZnQ7dGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlO2xldCBtPXQ9PT1cImF2Z1wiLGY9YCgoYmF0Y2ggICogJHtlLmluSGVpZ2h0fSArIHhSKSAqICR7ZS5pbldpZHRofSArIHhDKSAqICR7ZS5pbkNoYW5uZWxzfSArIGRgLGc9YCh4UiAqICR7ZS5pbldpZHRofSArIHhDKSAqICR7ZS5pbkNoYW5uZWxzfSArIGRgLGI9XCIwLjBcIjtpZihtfHwoYj1cIi0xLjAgLyAxZS0yMFwiKSxuKXtsZXQgQz1cIj49XCI7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke2l9LCAke299KTtcbiAgICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7Y30sICR7aH0pO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xuICAgICAgICAgIGZsb2F0IGF2Z1ZhbHVlID0gMC4wO1xuXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7cH07XG4gICAgICAgICAgICAgIHdSICs9ICR7bH0pIHtcbiAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XG5cbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtlLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZH07XG4gICAgICAgICAgICAgICAgd0MgKz0gJHt1fSkge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xuXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtlLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXG4gICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlICR7Q30gY3Vyck1pbk1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xuICAgICAgICAgICAgICAgIG1pbk1heFBvc2l0aW9uID0gJHthP3I/ZjpnOmB3UiAqICR7ZH0gKyB3Q2B9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICBgO3JldHVybn1sZXQgeT1cIm1heFwiLHg9YCR7dH0oJHt0fSgke3R9KG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pYDt0PT09XCJhdmdcIiYmKHg9XCJhdmdWYWx1ZSAvIG1heChjb3VudCwgMS4wKVwiKTtsZXQgdj1NYXRoLmZsb29yKHMvNCkqNCxJPXMlNCxOPWBcbiAgICAgIGlmICgke219KSB7XG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluTWF4VmFsdWUgPSAke3l9KHZhbHVlcywgbWluTWF4VmFsdWUpO1xuICAgICAgfVxuICAgIGA7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHtpfSwgJHtvfSk7XG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtjfSwgJHtofSk7XG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gJHtifTtcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcblxuICAgICAgZmxvYXQgY291bnQgPSAwLjA7XG5cbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IHhSLCBpbnQgeEMsIGludCBkKSB7XG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtlLmluV2lkdGh9KSB7XG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY291bnQgKz0gMS4wO1xuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcblxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNCgke2J9KTtcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XG4gICAgICAgIGNvdW50ID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke3B9O1xuICAgICAgICAgICAgd1IgKz0gJHtsfSkge1xuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XG5cbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49ICR7ZS5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke3Z9OyB3QyArPSA0KSB7XG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogJHt1fTtcblxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArICR7dX0sIGQpLFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqICR7dX0sIGQpLFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMyAqICR7dX0sIGQpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAke059XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyAke3Z9O1xuICAgICAgICAgIGlmICgke0k9PT0xfSkge1xuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgJHtOfVxuICAgICAgICAgIH0gZWxzZSBpZiAoJHtJPT09Mn0pIHtcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAke3V9LCBkKSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgJHtOfVxuICAgICAgICAgIH0gZWxzZSBpZiAoJHtJPT09M30pIHtcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAke3V9LCBkKSxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDIgKiAke3V9LCBkKSxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgJHtOfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoJHt4fSk7XG4gICAgICB9XG4gICAgYH19LGNrPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGE9ITEscj0hMSl7aWYodGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdD09PVwiYXZnXCImJm4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuXCIpO2xldCBzPWUuZmlsdGVyV2lkdGgsaT1lLnN0cmlkZURlcHRoLG89ZS5zdHJpZGVIZWlnaHQsbD1lLnN0cmlkZVdpZHRoLHU9ZS5kaWxhdGlvbkRlcHRoLHA9ZS5kaWxhdGlvbkhlaWdodCxkPWUuZGlsYXRpb25XaWR0aCxjPWUuZWZmZWN0aXZlRmlsdGVyRGVwdGgsaD1lLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxtPWUuZWZmZWN0aXZlRmlsdGVyV2lkdGgsZj1lLnBhZEluZm8uZnJvbnQsZz1lLnBhZEluZm8udG9wLGI9ZS5wYWRJbmZvLmxlZnQ7dGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlO2xldCB5PXQ9PT1cImF2Z1wiLHg9XCIwLjBcIjtpZih5fHwoeD1cIi0xLjAgLyAxZS0yMFwiKSxuKXtsZXQgRj1cIj49XCI7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxuICAgICAgICAgICAgaXZlYzMoJHtpfSwgJHtvfSwgJHtsfSk7XG4gICAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMygke2Z9LCAke2d9LCAke2J9KTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XG5cbiAgICAgICAgICBpdmVjMyB4Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgICBpbnQgeERDb3JuZXIgPSB4Q29ybmVyLng7XG4gICAgICAgICAgaW50IHhSQ29ybmVyID0geENvcm5lci55O1xuICAgICAgICAgIGludCB4Q0Nvcm5lciA9IHhDb3JuZXIuejtcblxuICAgICAgICAgIC8vIG1heC9taW4geCg/LCA/LCA/LCBjaCkgdG8gZ2V0IHkoeUQsIHlSLCB5QywgY2gpLlxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8ICR7Y307XG4gICAgICAgICAgICAgIHdEICs9ICR7dX0pIHtcbiAgICAgICAgICAgIGludCB4RCA9IHhEQ29ybmVyICsgd0Q7XG5cbiAgICAgICAgICAgIGlmICh4RCA8IDAgfHwgeEQgPj0gJHtlLmluRGVwdGh9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtofTtcbiAgICAgICAgICAgICAgICB3UiArPSAke3B9KSB7XG4gICAgICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XG5cbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHttfTtcbiAgICAgICAgICAgICAgICAgIHdDICs9ICR7ZH0pIHtcbiAgICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xuXG4gICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2UuaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0WChiYXRjaCwgeEQsIHhSLCB4QywgY2gpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGZsb2F0IGN1cnJNaW5NYXhWYWx1ZSA9IG1peChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJHtGfSBjdXJyTWluTWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xuICAgICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSAke2E/cj9gKCgoYmF0Y2ggKiAke2UuaW5EZXB0aH0gKyB4RCkgKiAke2UuaW5IZWlnaHR9ICsgeFIpICogJHtlLmluV2lkdGh9ICsgeEMpICogJHtlLmluQ2hhbm5lbHN9ICsgY2hgOmAoKHhEICogJHtlLmluSGVpZ2h0fSArIHhSKSAqICR7ZS5pbldpZHRofSArIHhDKSAqICR7ZS5pbkNoYW5uZWxzfSArIGNoYDpgd0QgKiAke2h9ICogJHttfSArXG4gICAgICAgICAgICAgICAgICAgICAgd1IgKiAke219ICsgd0NgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KG1pbk1heFBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgIGA7cmV0dXJufWxldCB2PVwibWF4XCIsST1gJHt0fSgke3R9KCR7dH0obWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlgO3Q9PT1cImF2Z1wiJiYoST1cImF2Z1ZhbHVlIC8gbWF4KGNvdW50LCAxLjApXCIpO2xldCBOPU1hdGguZmxvb3Iocy80KSo0LEM9cyU0LF89YFxuICAgICAgaWYgKCR7eX0pIHtcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5NYXhWYWx1ZSA9ICR7dn0odmFsdWVzLCBtaW5NYXhWYWx1ZSk7XG4gICAgICB9XG4gICAgYDt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxuICAgICAgICBpdmVjMygke2l9LCAke299LCAke2x9KTtcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMygke2Z9LCAke2d9LCAke2J9KTtcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAke3h9O1xuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xuXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcblxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgeEQsIGludCB4UiwgaW50IHhDLCBpbnQgY2gpIHtcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2UuaW5XaWR0aH0pIHtcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudCArPSAxLjA7XG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcblxuICAgICAgICBpdmVjMyB4Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgaW50IHhEQ29ybmVyID0geENvcm5lci54O1xuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4Q29ybmVyLnk7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhDb3JuZXIuejtcblxuICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgPywgZCkgdG8gZ2V0IHkoeUQsIHlSLCB5QywgY2gpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNCgke3h9KTtcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XG4gICAgICAgIGNvdW50ID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCAke2N9O1xuICAgICAgICAgICAgd0QgKz0gJHt1fSkge1xuICAgICAgICAgIGludCB4RCA9IHhEQ29ybmVyICsgd0Q7XG5cbiAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49ICR7ZS5pbkRlcHRofSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7aH07XG4gICAgICAgICAgICB3UiArPSAke3B9KSB7XG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xuXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49ICR7ZS5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke059OyB3QyArPSA0KSB7XG4gICAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0MgKiAke2R9O1xuXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QywgY2gpLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgJHtkfSwgY2gpLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMiAqICR7ZH0sIGNoKSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIDMgKiAke2R9LCBjaClcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAke199XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgJHtOfTtcbiAgICAgICAgICAgIGlmICgke0M9PT0xfSkge1xuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtDPT09Mn0pIHtcbiAgICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAke2R9LCBjaCksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgJHtffVxuICAgICAgICAgICAgfSBlbHNlIGlmICgke0M9PT0zfSkge1xuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArICR7ZH0sIGNoKSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIDIgKiAke2R9LCBjaCksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KCR7SX0pO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiB2dGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQ7bHAocixcImF2Z1Bvb2xcIik7bGV0e2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8sZGltUm91bmRpbmdNb2RlOmx9PWEsdT0xO3cuYXNzZXJ0KFQuZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGksdSksKCk9PmBFcnJvciBpbiBhdmdQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyAke2l9IGFuZCBkaWxhdGlvbnMgJyR7dX0nYCk7bGV0IHA9VC5jb21wdXRlUG9vbDJESW5mbyhyLnNoYXBlLHMsaSx1LG8sbCk7aWYocC5maWx0ZXJXaWR0aD09PTEmJnAuZmlsdGVySGVpZ2h0PT09MSYmdy5hcnJheXNFcXVhbChwLmluU2hhcGUscC5vdXRTaGFwZSkpcmV0dXJuIHRhKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpufSk7bGV0IGQ9bmV3IEVjKHAsXCJhdmdcIiwhMSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGQsW3JdLFwiZmxvYXQzMlwiKX12YXIgd3RlPXtrZXJuZWxOYW1lOkRpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnZ0ZX07ZnVuY3Rpb24ga3RlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGRpbVJvdW5kaW5nTW9kZTpsLGRhdGFGb3JtYXQ6dX09YSxwPVsxLDEsMV0sZD1ULmNvbXB1dGVQb29sM0RJbmZvKHIuc2hhcGUscyxpLHAsbyxsLHUpLGM9bmV3IGNrKGQsXCJhdmdcIiwhMSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGMsW3JdLFwiZmxvYXQzMlwiKX12YXIgSXRlPXtrZXJuZWxOYW1lOnR1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmt0ZX0sU3RlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPWUuaW5TaGFwZTtsZXQgdD1lLmZpbHRlckhlaWdodCxuPWUuZmlsdGVyV2lkdGgsYT1lLnN0cmlkZUhlaWdodCxyPWUuc3RyaWRlV2lkdGgscz1lLmRpbGF0aW9uSGVpZ2h0LGk9ZS5kaWxhdGlvbldpZHRoLG89ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsbD1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLHU9by0xLWUucGFkSW5mby50b3AscD1sLTEtZS5wYWRJbmZvLmxlZnQsZD0xLyh0Km4pO3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKCR7dX0sICR7cH0pO1xuICAgICAgY29uc3QgZmxvYXQgYXZnTXVsdGlwbGllciA9IGZsb2F0KCR7ZH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke299O1xuICAgICAgICAgICAgd1IgKz0gJHtzfSkge1xuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7YX0uMDtcblxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtsfTtcbiAgICAgICAgICAgIHdDKz0gJHtpfSkge1xuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gJHtyfS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2Uub3V0V2lkdGh9LjAgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xuXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYH19LE50ZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLmluU2hhcGU7bGV0IHQ9ZS5maWx0ZXJEZXB0aCxuPWUuZmlsdGVySGVpZ2h0LGE9ZS5maWx0ZXJXaWR0aCxyPWUuc3RyaWRlRGVwdGgscz1lLnN0cmlkZUhlaWdodCxpPWUuc3RyaWRlV2lkdGgsbz1lLmRpbGF0aW9uRGVwdGgsbD1lLmRpbGF0aW9uSGVpZ2h0LHU9ZS5kaWxhdGlvbldpZHRoLHA9ZS5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxkPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGM9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxoPXAtMS1lLnBhZEluZm8uZnJvbnQsbT1kLTEtZS5wYWRJbmZvLnRvcCxmPWMtMS1lLnBhZEluZm8ubGVmdCxnPTEvKHQqbiphKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMygke2h9LCAke219LCAke2Z9KTtcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdCgke2d9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xuXG4gICAgICAgIGl2ZWMzIGR5Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgLSBwYWRzO1xuICAgICAgICBpbnQgZHlEQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLnk7XG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci56O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgOiwgY2gpIHRvIGdldFxuICAgICAgICAvLyBkeCh4RCwgeFIsIHhDLCBjaCkuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCAke3B9O1xuICAgICAgICAgICAgd0QgKz0gJHtvfSkge1xuICAgICAgICAgIGZsb2F0IGR5RCA9IGZsb2F0KGR5RENvcm5lciArIHdEKSAvICR7cn0uMDtcblxuICAgICAgICAgIGlmIChkeUQgPCAwLjAgfHwgZHlEID49ICR7ZS5vdXREZXB0aH0uMCB8fCBmcmFjdChkeUQpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeUQgPSBpbnQoZHlEKTtcblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2R9O1xuICAgICAgICAgICAgICB3UiArPSAke2x9KSB7XG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyAke3N9LjA7XG5cbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7Y307XG4gICAgICAgICAgICAgICAgd0MgKz0gJHt1fSkge1xuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyAke2l9LjA7XG5cbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtlLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKTtcblxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIFR0ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCxpPXMse2ZpbHRlclNpemU6byxzdHJpZGVzOmwscGFkOnUsZGltUm91bmRpbmdNb2RlOnB9PWEsZD1bMSwxLDFdLGM9VC5jb21wdXRlUG9vbDNESW5mbyhpLnNoYXBlLG8sbCxkLHUscCksaD1uZXcgTnRlKGMpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShoLFtyXSxpLmR0eXBlKX12YXIgQ3RlPXtrZXJuZWxOYW1lOlJjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlR0ZX07ZnVuY3Rpb24gRXRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixpbnB1dDpzfT10LGk9cztscChbcixzXSxcImF2Z1Bvb2xHcmFkXCIpO2xldHtmaWx0ZXJTaXplOm8sc3RyaWRlczpsLHBhZDp1fT1hLHA9VC5jb21wdXRlUG9vbDJESW5mbyhpLnNoYXBlLG8sbCwxLHUpLGQ9bmV3IFN0ZShwKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oZCxbcl0saS5kdHlwZSl9dmFyIF90ZT17a2VybmVsTmFtZTpEYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpFdGV9O2Z1bmN0aW9uIEF0ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2E6cixiOnN9PXQse3RyYW5zcG9zZUE6aSx0cmFuc3Bvc2VCOm99PWE7cmV0dXJuIGhtKHthOnIsYjpzLHRyYW5zcG9zZUE6aSx0cmFuc3Bvc2VCOm8sYmFja2VuZDpufSl9dmFyIEZ0ZT17a2VybmVsTmFtZTpSaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpBdGV9LCR0ZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIscyl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIl0sVC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLHQpLFQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSxuKTtsZXQgaT1cIjAuMFwiO2EhPW51bGwmJihULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsYSksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJvZmZzZXRcIiksaT1cImdldE9mZnNldEF0T3V0Q29vcmRzKClcIik7bGV0IG89XCIxLjBcIjtyIT1udWxsJiYoVC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLHIpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwic2NhbGVcIiksbz1cImdldFNjYWxlQXRPdXRDb29yZHMoKVwiKSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldE1lYW5BdE91dENvb3JkcygpO1xuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gJHtpfTtcbiAgICAgICAgZmxvYXQgc2NhbGUgPSAke299O1xuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgZmxvYXQoJHtzfSkpO1xuICAgICAgICBzZXRPdXRwdXQoZG90KHZlYzMoeCwgLW1lYW4sIG9mZnNldCksIHZlYzMoaW52LCBpbnYsIDEpKSk7XG4gICAgICB9XG4gICAgYH19LER0ZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIscyl7dGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIm1lYW5cIixcInZhcmlhbmNlXCJdLFQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSx0KSxULmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGUsbik7bGV0IGk9XCJ2ZWM0KDAuMClcIjthIT1udWxsJiYoVC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShlLGEpLHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwib2Zmc2V0XCIpLGk9XCJnZXRPZmZzZXRBdE91dENvb3JkcygpXCIpO2xldCBvPVwidmVjNCgxLjApXCI7ciE9bnVsbCYmKFQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoZSxyKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLG89XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IG9mZnNldCA9ICR7aX07XG4gICAgICAgIHZlYzQgc2NhbGUgPSAke299O1xuXG4gICAgICAgIHZlYzQgeCA9IGdldFhBdE91dENvb3JkcygpO1xuICAgICAgICB2ZWM0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IGludiA9IHNjYWxlICogaW52ZXJzZXNxcnQodmFyaWFuY2UgKyB2ZWM0KCR7c30pKTtcblxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XG4gICAgICB9XG4gICAgYH19LFJ0ZT0oe2lucHV0czplLGJhY2tlbmQ6dCxhdHRyczpufSk9PntsZXR7eDphLG1lYW46cix2YXJpYW5jZTpzLG9mZnNldDppLHNjYWxlOm99PWU7dy5hc3NlcnQoci5zaGFwZS5sZW5ndGg9PT1zLnNoYXBlLmxlbmd0aCwoKT0+XCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHZhcmlhbmNlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCIpLHcuYXNzZXJ0KGk9PW51bGx8fHIuc2hhcGUubGVuZ3RoPT09aS5zaGFwZS5sZW5ndGgsKCk9PlwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIiksdy5hc3NlcnQobz09bnVsbHx8ci5zaGFwZS5sZW5ndGg9PT1vLnNoYXBlLmxlbmd0aCwoKT0+XCJCYXRjaCBub3JtYWxpemF0aW9uIGdyYWRpZW50IHJlcXVpcmVzIG1lYW4gYW5kIHNjYWxlIHRvIGhhdmUgZXF1YWwgcmFua3MuXCIpO2xldHt2YXJpYW5jZUVwc2lsb246bH09bjtsPT1udWxsJiYobD0uMDAxKTtsZXQgdT1bYSxyLHNdLHA9bnVsbDtpIT1udWxsJiYocD1pLnNoYXBlLHUucHVzaChpKSk7bGV0IGQ9bnVsbDtvIT1udWxsJiYoZD1vLnNoYXBlLHUucHVzaChvKSk7bGV0IGM9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIik/bmV3IER0ZShhLnNoYXBlLHIuc2hhcGUscy5zaGFwZSxwLGQsbCk6bmV3ICR0ZShhLnNoYXBlLHIuc2hhcGUscy5zaGFwZSxwLGQsbCk7cmV0dXJuIHQucnVuV2ViR0xQcm9ncmFtKGMsdSx1WzBdLmR0eXBlKX0sTXRlPXtrZXJuZWxOYW1lOkppLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlJ0ZX0sT3RlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJzb3VyY2VcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMucmFuaz1lLmxlbmd0aDtsZXQgdD1odCh0aGlzLnJhbmspO3RoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwic3RhcnRcIixhcnJheUluZGV4OnRoaXMucmFuayx0eXBlOlwiaW50XCJ9XTtsZXQgbj1QdGUodGhpcy5yYW5rKSxhLHI9ZS5tYXAoKHMsaSk9PmBzb3VyY2VMb2MuJHttdltpXX0gPSBzdGFydFske2l9XSArIGNvb3Jkcy4ke212W2ldfTtgKTthPWBcbiAgICAgICAgJHt0fSBzb3VyY2VMb2M7XG4gICAgICAgICR7dH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICR7ci5qb2luKGBcbmApfVxuICAgICAgYCx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHthfVxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKCR7bn0pKTtcbiAgICAgIH1cbiAgICBgfX0sbXY9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTtmdW5jdGlvbiBQdGUoZSl7aWYoZT09PTEpcmV0dXJuXCJzb3VyY2VMb2NcIjtpZihlPD02KXJldHVybiBtdi5zbGljZSgwLGUpLm1hcCh0PT5cInNvdXJjZUxvYy5cIit0KS5qb2luKFwiLFwiKTt0aHJvdyBFcnJvcihgU2xpY2luZyBmb3IgcmFuayAke2V9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCl9dmFyIEx0ZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnJhbms9ZS5sZW5ndGgsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJzdGFydFwiLGFycmF5SW5kZXg6dGhpcy5yYW5rLHR5cGU6XCJpbnRcIn1dO2xldCB0PWh0KHRoaXMucmFuayksbj1JbihcImNvb3Jkc1wiLHRoaXMucmFuayksYT1JbihcInNvdXJjZUxvY1wiLHRoaXMucmFuaykscj10aGlzLnJhbms9PT0xP1wic291cmNlTG9jXCI6YHZlYzIoJHthLnNsaWNlKC0yKS5qb2luKCl9KWAscz1gZ2V0Q2hhbm5lbChnZXRTb3VyY2UoJHthLmpvaW4oKX0pLCAke3J9KWAsaT1gXG4gICAgICByZXN1bHQueCA9ICR7c307XG4gICAgICBpZiAoKyske25bdGhpcy5yYW5rLTFdfSA8ICR7ZVt0aGlzLnJhbmstMV19KSB7XG4gICAgICAgICsrJHthW3RoaXMucmFuay0xXX07XG4gICAgICAgIHJlc3VsdC55ID0gJHtzfTtcbiAgICAgICAgLS0ke2FbdGhpcy5yYW5rLTFdfTtcbiAgICAgIH1cbiAgICBgLG89dGhpcy5yYW5rPT09MT9cIlwiOmBcbiAgICAgIC0tJHtuW3RoaXMucmFuay0xXX07XG4gICAgICBpZiAoKyske25bdGhpcy5yYW5rLTJdfSA8ICR7ZVt0aGlzLnJhbmstMl19KSB7XG4gICAgICAgICsrJHthW3RoaXMucmFuay0yXX07XG4gICAgICAgIHJlc3VsdC56ID0gJHtzfTtcbiAgICAgICAgaWYgKCsrJHtuW3RoaXMucmFuay0xXX0gPCAke2VbdGhpcy5yYW5rLTFdfSkge1xuICAgICAgICAgICsrJHthW3RoaXMucmFuay0xXX07XG4gICAgICAgICAgcmVzdWx0LncgPSAke3N9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYCxsPXRoaXMucmFuazw9ND9gc291cmNlTG9jID0gY29vcmRzICtcbiAgICAgICAgICAgICR7dH0oJHtlLm1hcCgodSxwKT0+YHN0YXJ0WyR7cH1dYCkuam9pbigpfSk7YDplLm1hcCgodSxwKT0+YCR7YVtwXX0gPSAke25bcF19ICsgc3RhcnRbJHtwfV07YCkuam9pbihgXG5gKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHt0fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgJHt0fSBzb3VyY2VMb2M7XG4gICAgICAgICR7bH1cbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcbiAgICAgICAgJHtpfVxuICAgICAgICAke299XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiB6dGUoZSx0LG4sYSl7bGV0IHI9YS50ZXhEYXRhLmdldChlLmRhdGFJZCkscz1hLm1ha2VUZW5zb3JJbmZvKG4sZS5kdHlwZSksaT1hLnRleERhdGEuZ2V0KHMuZGF0YUlkKTtPYmplY3QuYXNzaWduKGksciksaS5yZWZDb3VudD0xLGkuc2hhcGU9bixpLmR0eXBlPWUuZHR5cGU7bGV0IG89S3QuY29tcHV0ZUZsYXRPZmZzZXQodCx3LmNvbXB1dGVTdHJpZGVzKGUuc2hhcGUpKTtyLnNsaWNlJiYobys9ci5zbGljZS5mbGF0T2Zmc2V0KSxpLnNsaWNlPXtmbGF0T2Zmc2V0Om8sb3JpZ0RhdGFJZDpyLnNsaWNlJiZyLnNsaWNlLm9yaWdEYXRhSWR8fGUuZGF0YUlkfTtsZXQgbD1hLmRhdGFSZWZDb3VudC5nZXQoaS5zbGljZS5vcmlnRGF0YUlkKXx8MTtyZXR1cm4gYS5kYXRhUmVmQ291bnQuc2V0KGkuc2xpY2Uub3JpZ0RhdGFJZCxsKzEpLHN9ZnVuY3Rpb24gZnAoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2JlZ2luOnMsc2l6ZTppfT1hLFtvLGxdPUt0LnBhcnNlU2xpY2VQYXJhbXMocixzLGkpO2lmKEt0LmFzc2VydFBhcmFtc1ZhbGlkKHIsbyxsKSx3LnNpemVGcm9tU2hhcGUobCk9PT0wKXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGwsci5kdHlwZSxbXSk7aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW3JdKXx8ci5kdHlwZT09PVwic3RyaW5nXCIpe2xldCBkPW4udGV4RGF0YS5nZXQoci5kYXRhSWQpLGM9X1EoZC52YWx1ZXMsbyxsLHIuc2hhcGUsci5kdHlwZSk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obCxyLmR0eXBlLGMpfWxldHtpc1BhY2tlZDp1fT1uLnRleERhdGEuZ2V0KHIuZGF0YUlkKSxwPUt0LmlzU2xpY2VDb250aW5vdXMoci5zaGFwZSxvLGwpO2lmKHV8fCFwKXtsZXQgZD1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgTHRlKGwpOm5ldyBPdGUobCksYz1bb107cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGQsW3JdLHIuZHR5cGUsYyl9cmV0dXJuIG4udXBsb2FkVG9HUFUoci5kYXRhSWQpLHp0ZShyLG8sbCxuKX12YXIgV3RlPXtrZXJuZWxOYW1lOkJ1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZwfSxCdGU9ZT0+e2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtibG9ja1NoYXBlOnMsY3JvcHM6aX09YTt3LmFzc2VydChyLnNoYXBlLmxlbmd0aDw9NCwoKT0+XCJiYXRjaFRvU3BhY2VORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwiKTtsZXQgbz1zLnJlZHVjZSgoeSx4KT0+eSp4KSxsPVQuZ2V0UmVzaGFwZWQoci5zaGFwZSxzLG8pLHU9VC5nZXRQZXJtdXRlZChsLmxlbmd0aCxzLmxlbmd0aCkscD1ULmdldFJlc2hhcGVkUGVybXV0ZWQoci5zaGFwZSxzLG8pLGQ9VC5nZXRTbGljZUJlZ2luQ29vcmRzKGkscy5sZW5ndGgpLGM9VC5nZXRTbGljZVNpemUocCxpLHMubGVuZ3RoKSxoPVtdLG09Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmx9fSksZj1Tbih7aW5wdXRzOnt4Om19LGJhY2tlbmQ6bixhdHRyczp7cGVybTp1fX0pLGc9Y2Uoe2lucHV0czp7eDpmfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnB9fSksYj1mcCh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46ZCxzaXplOmN9fSk7cmV0dXJuIGgucHVzaChtKSxoLnB1c2goZiksaC5wdXNoKGcpLGguZm9yRWFjaCh5PT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpKSxifSxWdGU9e2tlcm5lbE5hbWU6bnUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6QnRlfTtmdW5jdGlvbiBVdGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsd2VpZ2h0czpzfT10LHtzaXplOml9PWEsbz1uLnJlYWRTeW5jKHIuZGF0YUlkKSxsPW4ucmVhZFN5bmMocy5kYXRhSWQpLHU9VEEobyxsLHMuZHR5cGUscy5zaGFwZSxpKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhbaV0scy5kdHlwZSx1KX12YXIgR3RlPXtrZXJuZWxOYW1lOmF1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlV0ZX0sSHRlPWBcbiAgaW50IHIgPSBpbnQoYS5yKSAmIGludChiLnIpO1xuICBpbnQgZyA9IGludChhLmcpICYgaW50KGIuZyk7XG4gIGludCByYiA9IGludChhLmIpICYgaW50KGIuYik7XG4gIGludCByYSA9IGludChhLmEpICYgaW50KGIuYSk7XG4gIHJldHVybiB2ZWM0KHIsIGcsIHJiLCByYSk7XG5gLGp0ZT1gXG4gIHJldHVybiBmbG9hdChpbnQoYS5yKSAmIGludChiLnIpKTtcbmA7ZnVuY3Rpb24gcXRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2EsYjpyfT10LHM9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpLGk9RygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik7aWYobi5zaG91bGRFeGVjdXRlT25DUFUoW2Escl0pfHxpPT09MSl7bGV0IGw9bi50ZXhEYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLHU9bi50ZXhEYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLFtwLGRdPVE5KGEuc2hhcGUsci5zaGFwZSxsLHUsYS5kdHlwZSksYz1uLm1ha2VUZW5zb3JJbmZvKGQsYS5kdHlwZSksaD1uLnRleERhdGEuZ2V0KGMuZGF0YUlkKTtyZXR1cm4gaC52YWx1ZXM9cCxjfWxldCBvO3JldHVybiBzP289bmV3IGhwKEh0ZSxhLnNoYXBlLHIuc2hhcGUsITEpOm89bmV3IGtpKGp0ZSxhLnNoYXBlLHIuc2hhcGUpLG4ucnVuV2ViR0xQcm9ncmFtKG8sW2Escl0sYS5kdHlwZSl9dmFyIEt0ZT17a2VybmVsTmFtZTpydSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpxdGV9O2Z1bmN0aW9uIFh0ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtzMDphLHMxOnJ9PXQscz1uLnJlYWRTeW5jKGEuZGF0YUlkKSxpPW4ucmVhZFN5bmMoci5kYXRhSWQpLG89VC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShBcnJheS5mcm9tKHMpLEFycmF5LmZyb20oaSkpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtvLmxlbmd0aF0sXCJpbnQzMlwiLEludDMyQXJyYXkuZnJvbShvKSl9dmFyIFl0ZT17a2VybmVsTmFtZTpNYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpYdGV9LFp0ZT1cInJldHVybiBmbG9hdChhICE9IGIpO1wiLFZBPWhuKHtvcFNuaXBwZXQ6WnRlLGNwdUtlcm5lbEltcGw6dlEsZHR5cGU6XCJib29sXCJ9KSxKdGU9e2tlcm5lbE5hbWU6RXUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6VkF9O2Z1bmN0aW9uIEZkKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2lucHV0OmF9PXQscj1uLnRleERhdGEuZ2V0KGEuZGF0YUlkKTtyZXR1cm4gdGEoe2lucHV0czp7eDpyLmNvbXBsZXhUZW5zb3JJbmZvcy5yZWFsfSxiYWNrZW5kOm59KX12YXIgUXRlPXtrZXJuZWxOYW1lOkRtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkZkfSxlbmU9XCJyZXR1cm4gZmxvYXQoaW50KHgpKTtcIjtmdW5jdGlvbiB0bmUoZSx0KXtsZXQgbj1uZXcgcnIoZS5zaGFwZSxlbmUpLGE9dC5ydW5XZWJHTFByb2dyYW0obixbZV0sXCJpbnQzMlwiKTtyZXR1cm57ZGF0YUlkOmEuZGF0YUlkLHNoYXBlOmEuc2hhcGUsZHR5cGU6YS5kdHlwZX19ZnVuY3Rpb24gZnYoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2R0eXBlOnN9PWE7aWYocz09PVwiY29tcGxleDY0XCIpe2lmKHIuZHR5cGU9PT1cImNvbXBsZXg2NFwiKXJldHVybiB0YSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO2xldCBpPUl0KHIuc2hhcGUpLG89ZnYoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e2R0eXBlOlwiZmxvYXQzMlwifX0pLGw9JHMoe2lucHV0czp7cmVhbDpvLGltYWc6aX0sYmFja2VuZDpufSk7cmV0dXJuIGkuZGlzcG9zZSgpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksbH1pZihyLmR0eXBlPT09XCJjb21wbGV4NjRcIil7bGV0IGk9RmQoe2lucHV0czp7aW5wdXQ6cn0sYmFja2VuZDpufSksbz1mdih7aW5wdXRzOnt4Oml9LGJhY2tlbmQ6bixhdHRyczp7ZHR5cGU6c319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxvfWlmKCF3Lmhhc0VuY29kaW5nTG9zcyhyLmR0eXBlLHMpKXtsZXQgaT10YSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO3JldHVybntkYXRhSWQ6aS5kYXRhSWQsc2hhcGU6aS5zaGFwZSxkdHlwZTpzfX1pZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbcl0pKXtsZXQgaT1uLnRleERhdGEuZ2V0KHIuZGF0YUlkKS52YWx1ZXMsW28sbCx1XT1lUShpLHIuc2hhcGUsci5kdHlwZSxzKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhvLGwsdSl9aWYocz09PVwiaW50MzJcIilyZXR1cm4gdG5lKHIsbik7aWYocz09PVwiYm9vbFwiKXtsZXQgaT1uLm1ha2VUZW5zb3JJbmZvKFtdLFwiYm9vbFwiLHcuZ2V0VHlwZWRBcnJheUZyb21EVHlwZShcImJvb2xcIiwxKSksbz1WQSh7aW5wdXRzOnthOnIsYjppfSxiYWNrZW5kOm59KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxvfXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gQ2FzdDogZmFpbGVkIHRvIGNhc3QgJHtyLmR0eXBlfSB0byAke3N9YCl9dmFyIG5uZT17a2VybmVsTmFtZTpNaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdn0sbVM9XCJyZXR1cm4gY2VpbCh4KTtcIixhbmU9WmUoe29wU25pcHBldDptUyxwYWNrZWRPcFNuaXBwZXQ6bVMsY3B1S2VybmVsSW1wbDp0UX0pLHJuZT17a2VybmVsTmFtZTpPaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzphbmV9LHNuZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcIm1pblZhbFwiLHR5cGU6XCJmbG9hdFwifSx7bmFtZTpcIm1heFZhbFwiLHR5cGU6XCJmbG9hdFwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XG4gICAgICAgIGlmIChpc25hbih2YWx1ZSkpIHtcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgbWluVmFsLCBtYXhWYWwpKTtcbiAgICAgIH1cbiAgICBgfX0saW5lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwibWluVmFsXCIsdHlwZTpcImZsb2F0XCJ9LHtuYW1lOlwibWF4VmFsXCIsdHlwZTpcImZsb2F0XCJ9XSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcblxuICAgICAgICBpZiAoYW55KGlzbmFuKHZhbHVlKSkpIHtcbiAgICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgdmVjNChtaW5WYWwpLCB2ZWM0KG1heFZhbCkpKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gb25lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtjbGlwVmFsdWVNaW46cyxjbGlwVmFsdWVNYXg6aX09YSxvO0coKS5nZXRCb29sKFwiV0VCR0xfUEFDS19DTElQXCIpP289bmV3IGluZShyLnNoYXBlKTpvPW5ldyBzbmUoci5zaGFwZSk7bGV0IGw9W1tzXSxbaV1dO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShvLFtyXSxyLmR0eXBlLGwpfXZhciBsbmU9e2tlcm5lbE5hbWU6d3MsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6b25lfSx1bmU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInJlYWxcIixcImltYWdcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCByZSA9IGFicyhnZXRSZWFsQXRPdXRDb29yZHMoKSk7XG4gICAgICAgIGZsb2F0IGltID0gYWJzKGdldEltYWdBdE91dENvb3JkcygpKTtcbiAgICAgICAgZmxvYXQgbXggPSBtYXgocmUsIGltKTtcblxuICAgICAgICAvLyBzYWRseSB0aGUgbGVuZ3RoIGZ1bmN0aW9uIGluIGdsc2wgaXMgbm90IHVuZGVyZmxvdy1zYWZlXG4gICAgICAgIC8vIChhdCBsZWFzdCBub3Qgb24gSW50ZWwgR1BVcykuIFNvIHRoZSBzYWZlIHNvbHV0aW9uIGlzXG4gICAgICAgIC8vIHRvIGVuc3VyZSB1bmRlcmZsb3ctc2FmZXR5IGluIGFsbCBjYXNlcy5cbiAgICAgICAgc2V0T3V0cHV0KFxuICAgICAgICAgIG14ID09IDAuMCA/IDAuMCA6IG14ICogbGVuZ3RoKHZlYzIoMSwgbWluKHJlLCBpbSkvbXgpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBmUyhlLHQpe3JldHVybntkYXRhSWQ6dC5kYXRhSWQsZHR5cGU6dC5kdHlwZSxzaGFwZTplLnNoYXBlfX1mdW5jdGlvbiBwbmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10LHI9bi50ZXhEYXRhLmdldChhLmRhdGFJZCkscz1uZXcgdW5lKGEuc2hhcGUpLGk9W2ZTKGEsci5jb21wbGV4VGVuc29ySW5mb3MucmVhbCksZlMoYSxyLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnKV07cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKHMsaSxpWzBdLmR0eXBlKX12YXIgY25lPXtrZXJuZWxOYW1lOk9jLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnBuZX0sZG5lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1ULmNvbXB1dGVPdXRTaGFwZShlLDEpLHRoaXMudmFyaWFibGVOYW1lcz1lLm1hcCgocyxpKT0+YFQke2l9YCk7bGV0IHQ9bmV3IEFycmF5KGUubGVuZ3RoLTEpO3RbMF09ZVswXVsxXTtmb3IobGV0IHM9MTtzPHQubGVuZ3RoO3MrKyl0W3NdPXRbcy0xXStlW3NdWzFdO2xldCBuPVtgaWYgKHlDIDwgJHt0WzBdfSkgc2V0T3V0cHV0KGdldFQwKHlSLCB5QykpO2BdO2ZvcihsZXQgcz0xO3M8dC5sZW5ndGg7cysrKXtsZXQgaT10W3MtMV07bi5wdXNoKGBlbHNlIGlmICh5QyA8ICR7dFtzXX0pIHNldE91dHB1dChnZXRUJHtzfSh5UiwgeUMtJHtpfSkpO2ApfWxldCBhPXQubGVuZ3RoLHI9dFt0Lmxlbmd0aC0xXTtuLnB1c2goYGVsc2Ugc2V0T3V0cHV0KGdldFQke2F9KHlSLCB5Qy0ke3J9KSk7YCksdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgeVIgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHlDID0gY29vcmRzLnk7XG5cbiAgICAgICAgJHtuLmpvaW4oYFxuICAgICAgICBgKX1cbiAgICAgIH1cbiAgICBgfX0saG5lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPVQuY29tcHV0ZU91dFNoYXBlKGUsdCk7bGV0IG49dGhpcy5vdXRwdXRTaGFwZSxhPW4ubGVuZ3RoLHI9aHQoYSkscz1JbihcImNvb3Jkc1wiLGEpLGk9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLGEpO3RoaXMudmFyaWFibGVOYW1lcz1lLm1hcCgobSxmKT0+YFQke2Z9YCk7bGV0IG89bmV3IEFycmF5KGUubGVuZ3RoLTEpO29bMF09ZVswXVt0XTtmb3IobGV0IG09MTttPG8ubGVuZ3RoO20rKylvW21dPW9bbS0xXStlW21dW3RdO2xldCBsPWlbdF0sdT1pLnNsaWNlKC0yKSxwPWkuam9pbigpLGQ9YGlmICgke2x9IDwgJHtvWzBdfSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFQwKCR7cH0pLCB2ZWMyKCR7dS5qb2luKCl9KSk7XG4gICAgICAgIH1gO2ZvcihsZXQgbT0xO208by5sZW5ndGg7bSsrKXtsZXQgZj1vW20tMV07ZCs9YFxuICAgICAgICBpZiAoJHtsfSA8ICR7b1ttXX0gICYmICR7bH0gPj0gJHtvW20tMV19KSB7XG4gICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICBnZXRUJHttfSgkeyRoKGksbCxmKX0pLFxuICAgICAgICAgICAgdmVjMigkeyRoKHUsbCxmKX0pKTtcbiAgICAgICAgfWB9bGV0IGM9by5sZW5ndGgsaD1vW28ubGVuZ3RoLTFdO2QrPWBcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgZ2V0VCR7Y30oJHskaChpLGwsaCl9KSxcbiAgICAgICAgICB2ZWMyKCR7JGgodSxsLGgpfSkpO2AsdGhpcy51c2VyQ29kZT1gXG4gICAgICBmbG9hdCBnZXRWYWx1ZSgke2kubWFwKG09PlwiaW50IFwiK20pfSkge1xuICAgICAgICAke2R9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtyfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KGdldFZhbHVlKCR7c30pLCAwLiwgMC4sIDAuKTtcblxuICAgICAgICAke3NbYS0xXX0gPSAke3NbYS0xXX0gKyAxO1xuICAgICAgICBpZiAoJHtzW2EtMV19IDwgJHtuW2EtMV19KSB7XG4gICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZSgke3N9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICR7c1thLTJdfSA9ICR7c1thLTJdfSArIDE7XG4gICAgICAgIGlmICgke3NbYS0yXX0gPCAke25bYS0yXX0pIHtcbiAgICAgICAgICByZXN1bHQuYSA9IGdldFZhbHVlKCR7c30pO1xuICAgICAgICB9XG5cbiAgICAgICAgJHtzW2EtMV19ID0gJHtzW2EtMV19IC0gMTtcbiAgICAgICAgaWYgKCR7c1thLTJdfSA8ICR7blthLTJdfSAmJlxuICAgICAgICAgICAgJHtzW2EtMV19IDwgJHtuW2EtMV19KSB7XG4gICAgICAgICAgcmVzdWx0LmIgPSBnZXRWYWx1ZSgke3N9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gJGgoZSx0LG4pe2xldCBhPWUuaW5kZXhPZih0KTtyZXR1cm4gZS5tYXAoKHIscyk9PnM9PT1hP2Ake3J9IC0gJHtufWA6cikuam9pbigpfWZ1bmN0aW9uIFVmKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2lucHV0OmF9PXQscj1uLnRleERhdGEuZ2V0KGEuZGF0YUlkKTtyZXR1cm4gdGEoe2lucHV0czp7eDpyLmNvbXBsZXhUZW5zb3JJbmZvcy5pbWFnfSxiYWNrZW5kOm59KX12YXIgbW5lPXtrZXJuZWxOYW1lOl9tLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlVmfTtmdW5jdGlvbiBvYyhlLHQsbil7bGV0IGE9ZVswXS5kdHlwZTtpZihhPT09XCJjb21wbGV4NjRcIil7bGV0IGg9ZS5tYXAoeT0+RmQoe2lucHV0czp7aW5wdXQ6eX0sYmFja2VuZDpufSkpLG09ZS5tYXAoeT0+VWYoe2lucHV0czp7aW5wdXQ6eX0sYmFja2VuZDpufSkpLGY9b2MoaCx0LG4pLGc9b2MobSx0LG4pLGI9JHMoe2lucHV0czp7cmVhbDpmLGltYWc6Z30sYmFja2VuZDpufSk7cmV0dXJuIGguZm9yRWFjaCh5PT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpKSxtLmZvckVhY2goeT0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh5KSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLGJ9bGV0IHI9bi5zaG91bGRFeGVjdXRlT25DUFUoZSk7aWYoYT09PVwic3RyaW5nXCImJihyPSEwKSxyKXtsZXQgaD1lLm1hcCh2PT57bGV0IEk9Wy0xLHcuc2l6ZUZyb21TaGFwZSh2LnNoYXBlLnNsaWNlKHQpKV07cmV0dXJuIGNlKHtpbnB1dHM6e3g6dn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpJfX0pfSksbT1oLm1hcCh2PT4oe3ZhbHM6bi5yZWFkU3luYyh2LmRhdGFJZCksc2hhcGU6di5zaGFwZX0pKSxmPVQuY29tcHV0ZU91dFNoYXBlKGgubWFwKHY9PnYuc2hhcGUpLDEpLGc9aFswXS5zaGFwZVswXT09PTEsYj1uUShtLGYsYSxnKSx5PVQuY29tcHV0ZU91dFNoYXBlKGUubWFwKHY9PnYuc2hhcGUpLHQpLHg9bi5tYWtlVGVuc29ySW5mbyh5LGEsYik7cmV0dXJuIGguZm9yRWFjaCh2PT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHYpKSx4fWxldCBzPWUuZmlsdGVyKGg9Pncuc2l6ZUZyb21TaGFwZShoLnNoYXBlKT4wKSxpPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpJiZzWzBdLnNoYXBlLmxlbmd0aD4xO2lmKHMubGVuZ3RoPT09MSl7bGV0IGg9aT9uZXcgcnIoZVswXS5zaGFwZSxZcik6bmV3IHRzKGVbMF0uc2hhcGUsWXIpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShoLGUsYSl9bGV0IG89RygpLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIik7aWYocy5sZW5ndGg+byl7bGV0IGg9W107Zm9yKGxldCBmPTA7ZjxzLmxlbmd0aDtmKz1vKXtsZXQgZz1zLnNsaWNlKGYsZitvKTtoLnB1c2gob2MoZyx0LG4pKX1sZXQgbT1vYyhoLHQsbik7Zm9yKGxldCBmIG9mIGgpbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKTtyZXR1cm4gbX1pZihpKXtsZXQgaD1uZXcgaG5lKHMubWFwKG09Pm0uc2hhcGUpLHQpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShoLHMsYSl9bGV0e3RlbnNvcnMyRDpsLG91dFNoYXBlOnV9PWZuZShzLHQsbikscD1uZXcgZG5lKGwubWFwKGg9Pmguc2hhcGUpKSxkPW4ucnVuV2ViR0xQcm9ncmFtKHAsbCxhKTtsLmZvckVhY2goaD0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSk7bGV0IGM9Y2Uoe2lucHV0czp7eDpkfSxhdHRyczp7c2hhcGU6dX0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksY31mdW5jdGlvbiBmbmUoZSx0LG4pe2xldCBhPVQuY29tcHV0ZU91dFNoYXBlKGUubWFwKHI9PnIuc2hhcGUpLHQpO3JldHVybnt0ZW5zb3JzMkQ6ZS5tYXAocj0+Y2Uoe2lucHV0czp7eDpyfSxhdHRyczp7c2hhcGU6Wy0xLHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlLnNsaWNlKHQpKV19LGJhY2tlbmQ6bn0pKSxvdXRTaGFwZTphfX1mdW5jdGlvbiBVQShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2F4aXM6cn09YSxzPXcucGFyc2VBeGlzUGFyYW0ocix0WzBdLnNoYXBlKVswXSxpPXQubWFwKHU9PnUuc2hhcGUpO1QuYXNzZXJ0UGFyYW1zQ29uc2lzdGVudChpLHMpO2xldCBvPVQuY29tcHV0ZU91dFNoYXBlKHQubWFwKHU9PnUuc2hhcGUpLHMpO2lmKHcuc2l6ZUZyb21TaGFwZShvKT09PTApcmV0dXJuIG4ubWFrZVRlbnNvckluZm8obyx0WzBdLmR0eXBlLFtdKTtsZXQgbD10LmZpbHRlcih1PT53LnNpemVGcm9tU2hhcGUodS5zaGFwZSk+MCk7cmV0dXJuIGwubGVuZ3RoPT09MT90YSh7aW5wdXRzOnt4OmxbMF19LGJhY2tlbmQ6bn0pOm9jKGwscyxuKX12YXIgZ25lPXtrZXJuZWxOYW1lOnN1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlVBfSxHQT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9ITEsbj1udWxsLGE9ITEscj0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlO2xldCBzPWUucGFkSW5mby50b3AsaT1lLnBhZEluZm8ubGVmdCxvPWUuc3RyaWRlSGVpZ2h0LGw9ZS5zdHJpZGVXaWR0aCx1PWUuZGlsYXRpb25IZWlnaHQscD1lLmRpbGF0aW9uV2lkdGgsZD1lLmZpbHRlckhlaWdodCxjPWUuZmlsdGVyV2lkdGgsaD1NYXRoLmZsb29yKGUuaW5DaGFubmVscy80KSo0LG09ZS5pbkNoYW5uZWxzJTQsZj1lLmRhdGFGb3JtYXQ9PT1cImNoYW5uZWxzTGFzdFwiLGc9Zj8xOjIsYj1mPzI6Myx5PWY/MzoxLHg9XCJcIix2PVwiXCI7biYmKGE/eD1gZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7bn1cbiAgICAgICAgfWA6cj94PWBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IGEpIHtcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7bn1cbiAgICAgICAgfWA6eD1gXG4gICAgICAgICAgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCB4KSB7XG4gICAgICAgICAgICAke259XG4gICAgICAgICAgfVxuICAgICAgICBgLHY9XCJyZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7XCIpO2xldCBJPXQ/XCJyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7XCI6XCJcIjt0JiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImJpYXNcIiksYSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzXCIpLHImJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwibGVha3lyZWx1QWxwaGFcIiksdGhpcy51c2VyQ29kZT1gXG4gICAgICAke3h9XG5cbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke299LCAke2x9KTtcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3N9LCAke2l9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZDIgPSBjb29yZHNbJHt5fV07XG5cbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID1cbiAgICAgICAgICAgIGl2ZWMyKGNvb3Jkc1ske2d9XSwgY29vcmRzWyR7Yn1dKSAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtkfTsgd1IrKykge1xuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1IgKiAke3V9O1xuXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtjfTsgd0MrKykge1xuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqICR7cH07XG5cbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtlLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgJHtofTsgZDEgKz0gNCkge1xuICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAyLCBkMiksXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMywgZDIpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCR7Zn0pIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMywgeFIsIHhDKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCR7bT09PTF9KSB7XG5cbiAgICAgICAgICAgICAgaWYgKCR7Zn0pIHtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9XG4gICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtofSkgKlxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtofSwgZDIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cbiAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgJHtofSwgeFIsIHhDKSAqXG4gICAgICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2h9LCBkMik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICgke209PT0yfSkge1xuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2h9LCBkMiksXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsICR7aH0gKyAxLCBkMilcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpZiAoJHtmfSkge1xuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aH0pLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCAke2h9ICsgMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2h9LCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgJHtofSArIDEsIHhSLCB4QylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHttPT09M30pIHtcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtofSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2h9ICsgMSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2h9ICsgMiwgZDIpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCR7Zn0pIHtcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCAke2h9KSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtofSArIDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCAke2h9ICsgMilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2h9LCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgJHtofSArIDEsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2h9ICsgMiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IGRvdFByb2Q7XG4gICAgICAgICR7SX1cbiAgICAgICAgJHt2fVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX0sYm5lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5vdXRTaGFwZTtsZXQgdD1lLnBhZEluZm8uZnJvbnQsbj1lLnBhZEluZm8udG9wLGE9ZS5wYWRJbmZvLmxlZnQscj1lLnN0cmlkZURlcHRoLHM9ZS5zdHJpZGVIZWlnaHQsaT1lLnN0cmlkZVdpZHRoLG89ZS5kaWxhdGlvbkRlcHRoLGw9ZS5kaWxhdGlvbkhlaWdodCx1PWUuZGlsYXRpb25XaWR0aCxwPWUuZmlsdGVyRGVwdGgsZD1lLmZpbHRlckhlaWdodCxjPWUuZmlsdGVyV2lkdGgsaD1NYXRoLmZsb29yKGUuaW5DaGFubmVscy80KSo0LG09ZS5pbkNoYW5uZWxzJTQ7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID0gaXZlYzMoJHtyfSwgJHtzfSwgJHtpfSk7XG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoJHt0fSwgJHtufSwgJHthfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgZDIgPSBjb29yZHMudTtcblxuICAgICAgICBpdmVjMyB4RlJDQ29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgaW50IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcblxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sID8sIGQxKSB3aXRoIHcoOiwgOiwgOiwgZDEsIGQyKSB0byBnZXRcbiAgICAgICAgLy8geSh5RiwgeVIsIHlDLCBkMikuID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbFxuICAgICAgICAvLyB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgJHtwfTsgd0YrKykge1xuICAgICAgICAgIGludCB4RiA9IHhGQ29ybmVyICsgd0YgKiAke299O1xuXG4gICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSAke2UuaW5EZXB0aH0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2R9OyB3UisrKSB7XG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogJHtsfTtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2UuaW5IZWlnaHR9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtjfTsgd0MrKykge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogJHt1fTtcblxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7ZS5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8ICR7aH07IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSwgZDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDEsIGQyKSxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAyLCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMywgZDIpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCR7bT09PTF9KSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtofSkgKlxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCAke2h9LCBkMik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHttPT09Mn0pIHtcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtofSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCAke2h9ICsgMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aH0sIGQyKSxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgJHtofSArIDEsIGQyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHttPT09M30pIHtcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtofSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCAke2h9ICsgMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCAke2h9ICsgMilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aH0sIGQyKSxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgJHtofSArIDEsIGQyKSxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgJHtofSArIDIsIGQyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fSxIQT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQ9ITEsbj1udWxsLGE9ITEscj0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJwYWRzXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcImluRGltc1wiLHR5cGU6XCJpdmVjMlwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLm91dFNoYXBlLHRoaXMuZW5hYmxlU2hhcGVVbmlmb3Jtcz12bih0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7bGV0IHM9ZS5wYWRJbmZvLmxlZnQsaT1lLnN0cmlkZVdpZHRoLG89ZS5kaWxhdGlvbldpZHRoLGw9ZS5maWx0ZXJIZWlnaHQsdT1lLmZpbHRlcldpZHRoLHA9dSxkPWBcbiAgICAgICBpbnQgeFI7IGludCB4QzsgaW50IHhDT2Zmc2V0O1xuICAgICAgIHZlYzQgd1RleGVsOyB2ZWM0IHByZXZpb3VzOyB2ZWM0IGZpbmFsO2A7Zm9yKGxldCBmPTA7Zjx1O2YrKylkKz1gXG4gICAgICAgICAgIHZlYzQgeFRleGVsQyR7ZioyfTtcbiAgICAgICAgICAgaW50IHhUZXhlbEMke2YqMn1SZWFkeTtcbiAgICAgICAgICAgdmVjNCB4VGV4ZWxDJHtmKjIrMX07XG4gICAgICAgICAgIGludCB4VGV4ZWxDJHtmKjIrMX1SZWFkeTtcbiAgICAgICAgICAgdmVjNCB4QyR7Zn07YDtkKz1gXG4gICAgIGZvciAoaW50IHIgPSAwOyByIDwgJHtsfTsgcisrKSB7XG4gICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgJHtlLmluQ2hhbm5lbHN9OyBkMSArPSAyKSB7XG4gICAgICAgYDtmb3IobGV0IGY9MDtmPHU7ZisrKWQrPWBcbiAgICAgICAgICAgeFRleGVsQyR7ZioyfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgeFRleGVsQyR7ZioyfVJlYWR5ID0gMDtcbiAgICAgICAgICAgeFRleGVsQyR7ZioyKzF9ID0gdmVjNCgwLjApO1xuICAgICAgICAgICB4VGV4ZWxDJHtmKjIrMX1SZWFkeSA9IDA7XG4gICAgICAgICAgIHhDJHtmfSA9IHZlYzQoMC4wKTtgO2QrPWBcbiAgICAgICAgIHhSID0geFJDb3JuZXIgKyByICogZGlsYXRpb25zWzBdO1xuICAgICAgICAgaWYgKHhSID49MCAmJiB4UiA8IGluRGltc1swXSkge1xuICAgICAgIGA7Zm9yKGxldCBmPTA7ZjwocCsxKS8yO2YrKyl7bGV0IGc9ZioyO2lmKGQrPWBcbiAgICAgICAgICAgeEMgPSB4Q0Nvcm5lciArICR7ZypvfTtcbiAgICAgICAgICAgYCxpPT09MSl7aWYoZzx1JiYocyUyPT09MT8oZCs9YFxuICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcbiAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Z31SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z30gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z30uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBgLG89PT0xJiZnPjA/ZCs9YFxuICAgICAgICAgICAgICAgICB4QyR7Z30gPSB2ZWM0KHhUZXhlbEMke2ctMn0uencsIHhUZXhlbEMke2d9Lnh5KTtcbiAgICAgICAgICAgICAgICAgYDpkKz1gXG4gICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSAyO1xuXG4gICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgIHhDJHtnfSA9IHZlYzQocHJldmlvdXMuencsIHhUZXhlbEMke2d9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgeEMke2d9ID0gdmVjNCgwLjAsIDAuMCwgeFRleGVsQyR7Z30ueHkpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBgKTpkKz1gXG4gICAgICAgICAgICAgICAgIGlmICh4QyA+PSAwICYmIHhDIDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2d9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHhDJHtnfSA9IHhUZXhlbEMke2d9O1xuICAgICAgICAgICAgICAgICBgLGcrMTx1KSl7bGV0IGI9cyUyPT09MD93Lm5lYXJlc3RMYXJnZXJFdmVuKG8pOm87byUyPT09MCYmcyUyPT09MXx8byUyIT09MCYmcyUyIT09MT8oZCs9YFxuICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBpbW9kKHBhZHNbMV0sIDIpICsgJHtifTtcblxuICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2crMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnKzF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2crMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIGAsbz4xP2QrPWBcbiAgICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0IC09IDI7XG4gICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgeEMke2crMX0gPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxDJHtnKzF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgeEMke2crMX0gPSB2ZWM0KDAuMCwgMC4wLCB4VGV4ZWxDJHtnKzF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIGA6ZCs9YFxuICAgICAgICAgICAgICAgICAgICAgeEMke2crMX0gPSB2ZWM0KHhUZXhlbEMke2d9Lnp3LCB4VGV4ZWxDJHtnKzF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgIGApOmI9PT0xP2QrPWBcbiAgICAgICAgICAgICAgICAgICAgIHhDJHtnKzF9ID0geFRleGVsQyR7Z307XG4gICAgICAgICAgICAgICAgICAgICBgOmQrPWBcbiAgICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAke2J9O1xuXG4gICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtnKzF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnKzF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnKzF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICB4QyR7ZysxfSA9IHhUZXhlbEMke2crMX07XG4gICAgICAgICAgICAgICAgICAgICBgfX1lbHNlIGc8dSYmKHMlMj09PTE/KGQrPWBcbiAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2d9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxuICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z31SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7ZysxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnKzF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDICsgMSwgZDEpO1xuICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICBpZiAoeEMgKyAyID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHhDJHtnfSA9IHZlYzQoeFRleGVsQyR7Z30uencsIHhUZXhlbEMke2crMX0uencpO1xuICAgICAgICAgICAgICAgYCxnKzE8dSYmKGQrPWBcbiAgICAgICAgICAgICAgICAgICBmaW5hbCA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSArIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeEMke2crMX0gPSB2ZWM0KHhUZXhlbEMke2crMX0ueHksIGZpbmFsLnh5KTtcbiAgICAgICAgICAgICAgICAgYCkpOihkKz1gXG4gICAgICAgICAgICAgICAgIGlmKHhDID49IDAgJiYgeEMgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Z31SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z30gPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z30uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2d9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7ZysxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtnKzF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2crMX0uencgPSB2ZWMyKDAuKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7ZysxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHhDJHtnfSA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Z30ueHksIHhUZXhlbEMke2crMX0ueHkpO1xuICAgICAgICAgICAgICAgYCxnKzE8dSYmKGQrPWBcbiAgICAgICAgICAgICAgICAgICB4QyR7ZysxfSA9IHZlYzQoeFRleGVsQyR7Z30uencsIHhUZXhlbEMke2crMX0uencpO1xuICAgICAgICAgICAgICAgICBgKSkpO2c8dSYmKGQrPWBcbiAgICAgICAgICAgICB3VGV4ZWwgPSBnZXRXKHIsICR7Z30sIGQxLCBkMik7XG4gICAgICAgICAgICAgZG90UHJvZCArPSB4QyR7Z30ueHh6eiAqIHZlYzQod1RleGVsLnh5LCB3VGV4ZWwueHkpO1xuICAgICAgICAgICAgIGlmKGQxICsgMSA8ICR7ZS5pbkNoYW5uZWxzfSkge1xuICAgICAgICAgICAgICAgZG90UHJvZCArPSB4QyR7Z30ueXl3dyAqIHZlYzQod1RleGVsLnp3LCB3VGV4ZWwuencpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgYCxnKzE8dSYmKGQrPWBcbiAgICAgICAgICAgICAgIHdUZXhlbCA9IGdldFcociwgJHtnKzF9LCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgZG90UHJvZCArPSB4QyR7ZysxfS54eHp6ICogdmVjNCh3VGV4ZWwueHksIHdUZXhlbC54eSk7XG4gICAgICAgICAgICAgICBpZihkMSArIDEgPCAke2UuaW5DaGFubmVsc30pIHtcbiAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4QyR7ZysxfS55eXd3ICogdmVjNCh3VGV4ZWwuencsIHdUZXhlbC56dyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgYCkpfWQrPWBcbiAgICAgfVxuICAgYCxkKz1gXG4gICAgIH1cbiAgIGAsZCs9YFxuICAgICB9XG4gICBgO2xldCBjPVwiXCIsaD1cIlwiO24mJihhP2M9YHZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcbiAgICAgICAgICAgdmVjNCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgICR7bn1cbiAgICAgICAgIH1gOnI/Yz1gdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgICB2ZWM0IGIgPSBnZXRMZWFreXJlbHVBbHBoYUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgICR7bn1cbiAgICAgICAgIH1gOmM9YHZlYzQgYWN0aXZhdGlvbih2ZWM0IHgpIHtcbiAgICAgICAgICAgJHtufVxuICAgICAgICAgfWAsaD1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7bGV0IG09dD9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO3QmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxhJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksciYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJsZWFreXJlbHVBbHBoYVwiKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICAke2N9XG5cbiAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcbiAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgIC8vaW50aWFsaXplIGRvdFByb2Qgd2l0aCBhIHNtYWxsIGVwc2lsb24gc2VlbXMgdG8gcmVkdWNlIEdQVSBhY2N1cmFjeSBsb3NzLlxuICAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLjAwMDAwMDAwMDAwMDAwMSk7XG5cbiAgICAgICAgICR7ZH1cblxuICAgICAgICAgdmVjNCByZXN1bHQgPSBkb3RQcm9kIC0gdmVjNCgwLjAwMDAwMDAwMDAwMDAwMSk7XG4gICAgICAgICAke219XG4gICAgICAgICAke2h9XG4gICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgICB9XG4gICAgIGB9fSx5bmU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcImlucHV0U2hhcGVcIix0eXBlOlwiaXZlYzRcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaXZlYzJcIn0se25hbWU6XCJzdHJpZGVcIix0eXBlOlwiaXZlYzJcIn0se25hbWU6XCJkaWxhdGlvblwiLHR5cGU6XCJpdmVjMlwifSx7bmFtZTpcImluQ2hhbm5lbHNcIix0eXBlOlwiaW50XCJ9LHtuYW1lOlwiaXRlbXNQZXJCbG9ja1Jvd1wiLHR5cGU6XCJpbnRcIn0se25hbWU6XCJvdXRXaWR0aFwiLHR5cGU6XCJpbnRcIn1dLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXM9dm4odGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpO2xldHtkYXRhRm9ybWF0Om59PXQsYT1FbigpLHI9bj09PVwiY2hhbm5lbHNMYXN0XCIscz1yPzE6MixpPXI/MjozLG89dGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zP1wiaWYoYmxvY2tJbmRleCA8IG91dFNoYXBlWzJdICYmIHBvcyA8IG91dFNoYXBlWzFdKSB7XCI6YGlmKGJsb2NrSW5kZXggPCAke2VbMl19ICYmIHBvcyA8ICR7ZVsxXX0pIHtgLGw9XCJcIjtmb3IobGV0IHU9MDt1PD0xO3UrKylmb3IobGV0IHA9MDtwPD0xO3ArKylsKz1gXG4gICAgICAgICAgYmxvY2tJbmRleCA9IHJjLnogKyAke3B9O1xuICAgICAgICAgIHBvcyA9IHJjLnkgKyAke3V9O1xuXG4gICAgICAgICAgJHtvfVxuICAgICAgICAgICAgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gb3V0V2lkdGgpICogc3RyaWRlWzBdIC0gcGFkWzBdO1xuICAgICAgICAgICAgZDAgPSBvZmZzZXRZICsgZGlsYXRpb25bMF0gKiAocG9zIC8gaXRlbXNQZXJCbG9ja1Jvdyk7XG5cbiAgICAgICAgICAgIGlmKGQwIDwgaW5wdXRTaGFwZVske3N9XSAmJiBkMCA+PSAwKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSBjdXN0b20gaW1vZCBpbnN0ZWFkIG1vZC4gT24gSW50ZWwgR1BVLCBtb2QgbWF5IGdlbmVyYXRlXG4gICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdmFsdWUuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzU0NDdcbiAgICAgICAgICAgICAgb2Zmc2V0WCA9IGltb2QoYmxvY2tJbmRleCwgb3V0V2lkdGgpICogc3RyaWRlWzFdIC0gcGFkWzFdO1xuICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyBkaWxhdGlvblsxXSAqIChpbW9kKHBvcywgaXRlbXNQZXJCbG9ja1JvdykgL1xuICAgICAgICAgICAgICAgICAgaW5DaGFubmVscyk7XG5cbiAgICAgICAgICAgICAgaWYoZDEgPCBpbnB1dFNoYXBlWyR7aX1dICYmIGQxID49IDApIHtcblxuICAgICAgICAgICAgICAgIGNoID0gaW1vZChwb3MsIGluQ2hhbm5lbHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCR7cn0pIHtcbiAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDEsIGNoKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFske3UqMitwfV0gPSBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICAgICAgICBnZXRBKHJjLngsIGQwLCBpbnQoaW5uZXJEaW1zLngpLFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMCwgZDEpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0WyR7dSoyK3B9XSA9IGdldENoYW5uZWwoXG4gICAgICAgICAgICAgICAgICAgIGdldEEocmMueCwgY2gsIGludChpbm5lckRpbXMueCksXG4gICAgICAgICAgICAgICAgICAgIGludChpbm5lckRpbXMueSkpLCBpbm5lckRpbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgYDt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XG5cbiAgICAgICAgaW50IGJsb2NrSW5kZXgsIHBvcywgb2Zmc2V0WSwgZDAsIG9mZnNldFgsIGQxLCBjaDtcbiAgICAgICAgdmVjMiBpbm5lckRpbXM7XG5cbiAgICAgICAgJHtsfVxuXG4gICAgICAgICR7YS5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBtbShlLHQpe2xldCBuPWUubGVuZ3RoO3JldHVybiBuPj0zP3Q/Wy4uLmUuc2xpY2UoMCwtMyksZVtuLTNdKmVbbi0yXSxlW24tMV1dOlsuLi5lLnNsaWNlKDAsLTMpLGVbbi0zXSxlW24tMl0qZVtuLTFdXTohdCYmbj09PTEmJmVbMF0+MT9bZVswXSwxXTpudWxsfWZ1bmN0aW9uIGpBKHt4OmUsZmlsdGVyOnQsY29udkluZm86bixiYWNrZW5kOmEsYmlhczpyPW51bGwscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpzPW51bGwsbGVha3lyZWx1QWxwaGE6aT0wLGFjdGl2YXRpb246bz1udWxsfSl7bGV0IGw9ZS5zaGFwZSx1PWEudGV4RGF0YS5nZXQoZS5kYXRhSWQpLHA9bi5pbkNoYW5uZWxzLGQ9bFswXSpsWzFdKmxbMl0sYz1uLm91dENoYW5uZWxzLGg9bi5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIixtPSExLGY9ITEsZyxiPVtdO2lmKHMhPW51bGwpe2xldCB5PW1tKHMuc2hhcGUsaCk7eSE9bnVsbCYmKHM9Y2Uoe2lucHV0czp7eDpzfSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOnl9fSksYi5wdXNoKHMpKX1pZihyIT1udWxsKXtsZXQgeT1tbShyLnNoYXBlLGgpO3khPW51bGwmJihyPWNlKHtpbnB1dHM6e3g6cn0sYmFja2VuZDphLGF0dHJzOntzaGFwZTp5fX0pLGIucHVzaChyKSl9aWYoISgoZD09PTF8fGM9PT0xKSYmcD5MQSkmJnUuaXNQYWNrZWQmJmgmJnUudGV4dHVyZSE9bnVsbCYmbFsyXSUyIT09MCYmdy5hcnJheXNFcXVhbCh1LnNoYXBlLnNsaWNlKC0zKSxsLnNsaWNlKC0zKSkpe2xldCB5PWxbMF0qbFsxXSoobFsyXSsxKSx4PXtkYXRhSWQ6ZS5kYXRhSWQsc2hhcGU6WzEseSxuLmluQ2hhbm5lbHNdLGR0eXBlOmUuZHR5cGV9LHY9dS5zaGFwZTt1LnNoYXBlPXUuc2hhcGUuc2xpY2UoKSx1LnNoYXBlW3Uuc2hhcGUubGVuZ3RoLTJdKyssdy5hc3NlcnQoVGModS5zaGFwZSx4LnNoYXBlKSwoKT0+YHBhY2tlZCByZXNoYXBlICR7dS5zaGFwZX0gdG8gJHt4LnNoYXBlfSBpc24ndCBmcmVlYCk7bGV0IEk9Y2Uoe2lucHV0czp7eDp0fSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOlsxLG4uaW5DaGFubmVscyxuLm91dENoYW5uZWxzXX19KTtiLnB1c2goSSk7bGV0IE49aG0oe2E6eCxiOkksYmFja2VuZDphLHRyYW5zcG9zZUE6bSx0cmFuc3Bvc2VCOmYsYmlhczpyLGFjdGl2YXRpb246byxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOnMsbGVha3lyZWx1QWxwaGE6aX0pLEM9YS50ZXhEYXRhLmdldChOLmRhdGFJZCk7dy5hc3NlcnQoQy5pc1BhY2tlZCwoKT0+XCJiYXRjaE1hdE11bCByZXN1bHQgaXMgZXhwZWN0ZWQgdG8gYmUgcGFja2VkXCIpLHUuc2hhcGU9dixDLnNoYXBlPW4ub3V0U2hhcGUsZz10YSh7aW5wdXRzOnt4Ok59LGJhY2tlbmQ6YX0pLGcuc2hhcGU9bi5vdXRTaGFwZSxiLnB1c2goTil9ZWxzZXtsZXQgeT1uLm91dEhlaWdodCpuLm91dFdpZHRoLHg9Y2Uoe2lucHV0czp7eDplfSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOmg/W24uYmF0Y2hTaXplLHksbi5pbkNoYW5uZWxzXTpbbi5iYXRjaFNpemUsbi5pbkNoYW5uZWxzLHldfX0pLHY9Y2Uoe2lucHV0czp7eDp0fSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOlsxLG4uaW5DaGFubmVscyxuLm91dENoYW5uZWxzXX19KSxJPWhtKHthOmg/eDp2LGI6aD92OngsdHJhbnNwb3NlQTohaCx0cmFuc3Bvc2VCOmYsYmFja2VuZDphLGJpYXM6cixhY3RpdmF0aW9uOm8scHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpzLGxlYWt5cmVsdUFscGhhOml9KTtnPWNlKHtpbnB1dHM6e3g6SX0sYmFja2VuZDphLGF0dHJzOntzaGFwZTpuLm91dFNoYXBlfX0pLGIucHVzaCh4KSxiLnB1c2godiksYi5wdXNoKEkpfWZvcihsZXQgeSBvZiBiKWEuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oeSk7cmV0dXJuIGd9ZnVuY3Rpb24gcUEoe3g6ZSxmaWx0ZXI6dCxjb252SW5mbzpuLGJhY2tlbmQ6YSxiaWFzOnI9bnVsbCxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOnM9bnVsbCxsZWFreXJlbHVBbHBoYTppPTAsYWN0aXZhdGlvbjpvPW51bGx9KXtsZXR7ZmlsdGVyV2lkdGg6bCxmaWx0ZXJIZWlnaHQ6dSxpbkNoYW5uZWxzOnAsb3V0V2lkdGg6ZCxvdXRIZWlnaHQ6YyxkYXRhRm9ybWF0Omh9PW4sbT1oPT09XCJjaGFubmVsc0xhc3RcIixmPWwqdSpwLGc9YypkLGI9W24uYmF0Y2hTaXplLGYsZ10seT0hMCx4PSExLHY9W107aWYocyE9bnVsbCl7bGV0IEs9bW0ocy5zaGFwZSxtKTtLIT1udWxsJiYocz1jZSh7aW5wdXRzOnt4OnN9LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6S319KSx2LnB1c2gocykpfWlmKHIhPW51bGwpe2xldCBLPW1tKHIuc2hhcGUsbSk7SyE9bnVsbCYmKHI9Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOmEsYXR0cnM6e3NoYXBlOkt9fSksdi5wdXNoKHIpKX1sZXQgST1jZSh7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6WzEsZix3LnNpemVGcm9tU2hhcGUodC5zaGFwZSkvZl19fSk7di5wdXNoKEkpO2xldCBOPW5ldyB5bmUoYixuKSxDPVtlLnNoYXBlLFtuLnBhZEluZm8udG9wLG4ucGFkSW5mby5sZWZ0XSxbbi5zdHJpZGVIZWlnaHQsbi5zdHJpZGVXaWR0aF0sW24uZGlsYXRpb25IZWlnaHQsbi5kaWxhdGlvbldpZHRoXSxbbi5pbkNoYW5uZWxzXSxbbi5maWx0ZXJXaWR0aCpuLmluQ2hhbm5lbHNdLFtuLm91dFdpZHRoXV0sXz1hLnJ1bldlYkdMUHJvZ3JhbShOLFtlXSxcImZsb2F0MzJcIixDKSxGPWNlKHtpbnB1dHM6e3g6X30sYmFja2VuZDphLGF0dHJzOntzaGFwZTpifX0pO3YucHVzaChfKSx2LnB1c2goRik7bGV0IEQ9ciE9bnVsbCwkPXMhPW51bGwsUz1vPT09XCJsZWFreXJlbHVcIixNPW8/Q2MobywhMCk6bnVsbCxCPW5ldyBQQShtP0Yuc2hhcGU6SS5zaGFwZSxtP0kuc2hhcGU6Ri5zaGFwZSxtP1tuLmJhdGNoU2l6ZSxnLG4ub3V0Q2hhbm5lbHNdOltuLmJhdGNoU2l6ZSxuLm91dENoYW5uZWxzLGddLHkseCxELE0sJCxTKSxVPW0/W0YsSV06W0ksRl07aWYociYmVS5wdXNoKHIpLCQmJlUucHVzaChzKSxTKXtsZXQgSz1hLm1ha2VUZW5zb3JJbmZvKFtdLFwiZmxvYXQzMlwiLHcuY3JlYXRlU2NhbGFyVmFsdWUoaSxcImZsb2F0MzJcIikpO1UucHVzaChLKSx2LnB1c2goSyl9bGV0IEg9YS5ydW5XZWJHTFByb2dyYW0oQixVLFwiZmxvYXQzMlwiKSxxPWNlKHtpbnB1dHM6e3g6SH0sYmFja2VuZDphLGF0dHJzOntzaGFwZTpuLm91dFNoYXBlfX0pO3YucHVzaChIKTtmb3IobGV0IEsgb2YgdilhLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEspO3JldHVybiBxfWZ1bmN0aW9uIHhuZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLHBhZDpvLGRhdGFGb3JtYXQ6bCxkaWxhdGlvbnM6dSxkaW1Sb3VuZGluZ01vZGU6cH09YSxkPVQuY29udmVydENvbnYyRERhdGFGb3JtYXQobCksYz1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscy5zaGFwZSxpLHUsbyxwLCExLGQpLGg7aWYoYy5maWx0ZXJIZWlnaHQ9PT0xJiZjLmZpbHRlcldpZHRoPT09MSYmYy5kaWxhdGlvbkhlaWdodD09PTEmJmMuZGlsYXRpb25XaWR0aD09PTEmJmMuc3RyaWRlSGVpZ2h0PT09MSYmYy5zdHJpZGVXaWR0aD09PTEmJihjLnBhZEluZm8udHlwZT09PVwiU0FNRVwifHxjLnBhZEluZm8udHlwZT09PVwiVkFMSURcIikpaD1qQSh7eDpyLGZpbHRlcjpzLGNvbnZJbmZvOmMsYmFja2VuZDpufSk7ZWxzZSBpZihjLnN0cmlkZVdpZHRoPD0yJiZkPT09XCJjaGFubmVsc0xhc3RcIiYmRygpLmdldEJvb2woXCJXRUJHTF9FWFBfQ09OVlwiKSl7bGV0IGY9bmV3IEhBKGMpLGc9W1tjLnBhZEluZm8udG9wLGMucGFkSW5mby5sZWZ0XSxbYy5zdHJpZGVIZWlnaHQsYy5zdHJpZGVXaWR0aF0sW2MuZGlsYXRpb25IZWlnaHQsYy5kaWxhdGlvbldpZHRoXSxbYy5pbkhlaWdodCxjLmluV2lkdGhdXTtoPW4ucnVuV2ViR0xQcm9ncmFtKGYsW3Isc10sXCJmbG9hdDMyXCIsZyl9ZWxzZSBpZihHKCkuZ2V0Qm9vbChcIldFQkdMX0NPTlZfSU0yQ09MXCIpKWg9cUEoe3g6cixmaWx0ZXI6cyxjb252SW5mbzpjLGJhY2tlbmQ6bn0pO2Vsc2V7bGV0IGY9bmV3IEdBKGMpO2g9bi5ydW5XZWJHTFByb2dyYW0oZixbcixzXSxcImZsb2F0MzJcIil9bGV0IG09Y2Uoe2lucHV0czp7eDpofSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmMub3V0U2hhcGV9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbX12YXIgdm5lPXtrZXJuZWxOYW1lOlBpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnhuZX0sd25lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPWUuZmlsdGVyU2hhcGU7bGV0IHQ9ZS5zdHJpZGVIZWlnaHQsbj1lLnN0cmlkZVdpZHRoLGE9ZS5wYWRJbmZvLnRvcCxyPWUucGFkSW5mby5sZWZ0LHM9ZS5kYXRhRm9ybWF0PT09XCJjaGFubmVsc0xhc3RcIjt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgJHtlLmJhdGNoU2l6ZX07IGIrKykge1xuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCAke2Uub3V0SGVpZ2h0fTsgeVIrKykge1xuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqICR7dH0gLSAke2F9O1xuXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49ICR7ZS5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCAke2Uub3V0V2lkdGh9OyB5QysrKSB7XG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiAke259IC0gJHtyfTtcblxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7ZS5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgJHtzP2BmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO2A6YGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBkMiwgeVIsIHlDKTtcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCBkMSwgeFIsIHhDKTtcbiAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7YH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fSxrbmU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO2xldCB0PWUuZmlsdGVySGVpZ2h0LG49ZS5maWx0ZXJXaWR0aCxhPWUuc3RyaWRlSGVpZ2h0LHI9ZS5zdHJpZGVXaWR0aCxzPWUuZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCIsaT10LTEtZS5wYWRJbmZvLnRvcCxvPW4tMS1lLnBhZEluZm8ubGVmdCxsPXM/MToyLHU9cz8yOjMscD1zPzM6MTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2l9LCAke299KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZDEgPSBjb29yZHNbJHtwfV07XG5cbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBpdmVjMihjb29yZHNbJHtsfV0sIGNvb3Jkc1ske3V9XSkgLSBwYWRzO1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHt0fTsgd1IrKykge1xuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7YX0uMDtcblxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICBpbnQgd1JQZXJtID0gJHt0fSAtIDEgLSB3UjtcblxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke259OyB3QysrKSB7XG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyAke3J9LjA7XG5cbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZS5vdXRXaWR0aH0uMCB8fFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xuXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gJHtufSAtIDEgLSB3QztcblxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7ZS5vdXRDaGFubmVsc307IGQyKyspIHtcblxuICAgICAgICAgICAgICBpZiAoJHtzfSkge1xuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgZDIsIGlkeVIsIGlkeUMpO1xuICAgICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYH19LEluZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLmZpbHRlclNoYXBlO2xldCB0PWUuc3RyaWRlRGVwdGgsbj1lLnN0cmlkZUhlaWdodCxhPWUuc3RyaWRlV2lkdGgscj1lLnBhZEluZm8uZnJvbnQscz1lLnBhZEluZm8udG9wLGk9ZS5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgd0YgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHdSID0gY29vcmRzLnk7XG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy56O1xuICAgICAgICBpbnQgZDEgPSBjb29yZHMudztcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8ICR7ZS5iYXRjaFNpemV9OyBiKyspIHtcbiAgICAgICAgICBmb3IgKGludCB5RiA9IDA7IHlGIDwgJHtlLm91dERlcHRofTsgeUYrKykge1xuICAgICAgICAgICAgaW50IHhGID0gd0YgKyB5RiAqICR7dH0gLSAke3J9O1xuXG4gICAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49ICR7ZS5pbkRlcHRofSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8ICR7ZS5vdXRIZWlnaHR9OyB5UisrKSB7XG4gICAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiAke259IC0gJHtzfTtcblxuICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49ICR7ZS5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCAke2Uub3V0V2lkdGh9OyB5QysrKSB7XG4gICAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqICR7YX0gLSAke2l9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2UuaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5RiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4RiwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fSxTbmU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO2xldCB0PWUuZmlsdGVyRGVwdGgsbj1lLmZpbHRlckhlaWdodCxhPWUuZmlsdGVyV2lkdGgscj1lLnN0cmlkZURlcHRoLHM9ZS5zdHJpZGVIZWlnaHQsaT1lLnN0cmlkZVdpZHRoLG89dC0xLWUucGFkSW5mby5mcm9udCxsPW4tMS1lLnBhZEluZm8udG9wLHU9YS0xLWUucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKCR7b30sICR7bH0sICR7dX0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnU7XG5cblxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcbiAgICAgICAgaW50IGR5RkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcblxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgJHt0fTsgd0YrKykge1xuICAgICAgICAgIGZsb2F0IGR5RiA9IGZsb2F0KGR5RkNvcm5lciArIHdGKSAvICR7cn0uMDtcblxuICAgICAgICAgIGlmIChkeUYgPCAwLjAgfHwgZHlGID49ICR7ZS5vdXREZXB0aH0uMCB8fCBmcmFjdChkeUYpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeUYgPSBpbnQoZHlGKTtcblxuICAgICAgICAgIGludCB3RlBlcm0gPSAke3R9IC0gMSAtIHdGO1xuXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7bn07IHdSKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7c30uMDtcblxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtlLm91dEhlaWdodH0uMCB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgICAgaW50IHdSUGVybSA9ICR7bn0gLSAxIC0gd1I7XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2F9OyB3QysrKSB7XG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7aX0uMDtcblxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2Uub3V0V2lkdGh9LjAgfHxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xuXG4gICAgICAgICAgICAgIGludCB3Q1Blcm0gPSAke2F9IC0gMSAtIHdDO1xuXG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCAke2Uub3V0Q2hhbm5lbHN9OyBkMisrKSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUYsIGlkeVIsIGlkeUMsIGQyKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdGUGVybSwgd1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBObmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZHk6c309dCx7c3RyaWRlczppLHBhZDpvLGRhdGFGb3JtYXQ6bCxkaW1Sb3VuZGluZ01vZGU6dSxmaWx0ZXJTaGFwZTpwfT1hLGQ9VC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChsKSxjPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxwLGksMSxvLHUsITEsZCksaD1uZXcgd25lKGMpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShoLFtyLHNdLFwiZmxvYXQzMlwiKX12YXIgVG5lPXtrZXJuZWxOYW1lOmttLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOk5uZX0sQ25lPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidmVjMlwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLmluU2hhcGUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXQgdD1lLmZpbHRlckhlaWdodCxuPWUuZmlsdGVyV2lkdGgsYT10LTEtZS5wYWRJbmZvLnRvcCxyPW4tMS1lLnBhZEluZm8ubGVmdDt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2F9LCAke3J9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XG5cbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBpdmVjMihjb29yZHNbMV0sIGNvb3Jkc1syXSkgLSBwYWRzO1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7dH07IHdSKyspIHtcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBzdHJpZGVzWzBdO1xuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG4gICAgICAgICAgaW50IHdSUGVybSA9ICR7dH0gLSAxIC0gd1I7XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtufTsgd0MrKykge1xuICAgICAgICAgICAgaW50IHdDUGVybSA9ICR7bn0gLSAxIC0gd0M7XG5cbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZXNbMV07XG4gICAgICAgICAgICBib29sIGlkeUNWYWwgPSAoZHlDID49IDAuMCkgJiYgKGR5QyA8ICR7ZS5vdXRXaWR0aH0uMClcbiAgICAgICAgICAgICAgJiYgKGZyYWN0KGR5QykgPT0gMC4wKTtcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgIGZsb2F0IGR5QzIgPSBmbG9hdChkeUNDb3JuZXIgKyB3QyArIDEpIC8gc3RyaWRlc1sxXTtcbiAgICAgICAgICAgIGJvb2wgaWR5Q1ZhbDIgPSAoZHlDMiA+PSAwLjApICYmIChkeUMyIDwgJHtlLm91dFdpZHRofS4wKVxuICAgICAgICAgICAgICAmJiAoZnJhY3QoZHlDMikgPT0gMC4wKTtcbiAgICAgICAgICAgIGludCBpZHlDMiA9IGludChkeUMyKTtcblxuICAgICAgICAgICAgaWYgKGlkeUNWYWwgJiYgaWR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7ZS5vdXRDaGFubmVsc307IGQyICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZTIgPSAoaWR5QyAvIDIgPT0gaWR5QzIgLyAyKSA/XG4gICAgICAgICAgICAgICAgICBkeVNhbXBsZSA6IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDMiwgZDIpO1xuXG4gICAgICAgICAgICAgICAgdmVjMiBkeVZhbHVlID0gbW9kKGZsb2F0KGlkeUMpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUueHkgOiBkeVNhbXBsZS56dztcbiAgICAgICAgICAgICAgICByZXN1bHQueHkgKz0gdmVjMihkb3QoZHlWYWx1ZSwgd1ZhbHVlLnh5KSxcbiAgICAgICAgICAgICAgICAgIGRvdChkeVZhbHVlLCB3VmFsdWUuencpKTtcblxuICAgICAgICAgICAgICAgIGR5VmFsdWUgPSBtb2QoZmxvYXQoaWR5QzIpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUyLnh5IDogZHlTYW1wbGUyLnp3O1xuICAgICAgICAgICAgICAgIHJlc3VsdC56dyArPSB2ZWMyKGRvdChkeVZhbHVlLCB3VmFsdWUueHkpLFxuICAgICAgICAgICAgICAgICAgZG90KGR5VmFsdWUsIHdWYWx1ZS56dykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkeUNWYWwpIHtcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7ZS5vdXRDaGFubmVsc307IGQyICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjMiBkeVZhbHVlID0gbW9kKGZsb2F0KGlkeUMpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUueHkgOiBkeVNhbXBsZS56dztcbiAgICAgICAgICAgICAgICByZXN1bHQueHkgKz0gdmVjMihkb3QoZHlWYWx1ZSwgd1ZhbHVlLnh5KSxcbiAgICAgICAgICAgICAgICAgIGRvdChkeVZhbHVlLCB3VmFsdWUuencpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpZHlDVmFsMikge1xuICAgICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgJHtlLm91dENoYW5uZWxzfTsgZDIgKz0gMikge1xuICAgICAgICAgICAgICAgIHZlYzQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICB2ZWM0IGR5U2FtcGxlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMyLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjMiBkeVZhbHVlID0gbW9kKGZsb2F0KGlkeUMyKSwgMi4pID09IDAuID9cbiAgICAgICAgICAgICAgICAgIGR5U2FtcGxlLnh5IDogZHlTYW1wbGUuenc7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lnp3ICs9IHZlYzIoZG90KGR5VmFsdWUsIHdWYWx1ZS54eSksXG4gICAgICAgICAgICAgICAgICBkb3QoZHlWYWx1ZSwgd1ZhbHVlLnp3KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIEVuZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsZmlsdGVyOnN9PXQse2lucHV0U2hhcGU6aSxzdHJpZGVzOm8scGFkOmwsZGF0YUZvcm1hdDp1LGRpbVJvdW5kaW5nTW9kZTpwfT1hLGQ9VC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdCh1KSxjPVQuY29tcHV0ZUNvbnYyREluZm8oaSxzLnNoYXBlLG8sMSxsLHAsITEsZCk7aWYoRygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0NPTlYyRFRSQU5TUE9TRVwiKSYmZD09PVwiY2hhbm5lbHNMYXN0XCIpe2xldCBoPVtbYy5zdHJpZGVIZWlnaHQsYy5zdHJpZGVXaWR0aF1dLG09bmV3IENuZShjKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0obSxbcixzXSxcImZsb2F0MzJcIixoKX1lbHNle2xldCBoPW5ldyBrbmUoYyk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGgsW3Isc10sXCJmbG9hdDMyXCIpfX12YXIgX25lPXtrZXJuZWxOYW1lOkxpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkVuZX07ZnVuY3Rpb24gQW5lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzfT10LHtzdHJpZGVzOmkscGFkOm8sZGlsYXRpb25zOmx9PWEsdT1ULmNvbXB1dGVDb252M0RJbmZvKHIuc2hhcGUscy5zaGFwZSxpLGwsbykscD1uZXcgYm5lKHUpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShwLFtyLHNdLFwiZmxvYXQzMlwiKX12YXIgRm5lPXtrZXJuZWxOYW1lOnppLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkFuZX07ZnVuY3Rpb24gJG5lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGR5OnN9PXQse3N0cmlkZXM6aSxwYWQ6byxmaWx0ZXJTaGFwZTpsfT1hLHU9VC5jb21wdXRlQ29udjNESW5mbyhyLnNoYXBlLGwsaSwxLG8pLHA9bmV3IEluZSh1KTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocCxbcixzXSxcImZsb2F0MzJcIil9dmFyIERuZT17a2VybmVsTmFtZTppdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzokbmV9O2Z1bmN0aW9uIFJuZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsZmlsdGVyOnN9PXQse3BhZDppLHN0cmlkZXM6byxpbnB1dFNoYXBlOmx9PWEsdT1ULmNvbXB1dGVDb252M0RJbmZvKGwscy5zaGFwZSxvLDEsaSkscD1uZXcgU25lKHUpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShwLFtyLHNdLFwiZmxvYXQzMlwiKX12YXIgTW5lPXtrZXJuZWxOYW1lOm91LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlJuZX0sT25lPW1wK2BcbiAgcmV0dXJuIGNvcyh4KTtcbmAsUG5lPWBcbiAgdmVjNCByZXN1bHQgPSBjb3MoeCk7XG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XG4gICR7UW99XG4gIHJldHVybiByZXN1bHQ7XG5gLExuZT1aZSh7b3BTbmlwcGV0Ok9uZSxwYWNrZWRPcFNuaXBwZXQ6UG5lfSksem5lPXtrZXJuZWxOYW1lOldpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkxuZX0sV25lPWBcbiAgZmxvYXQgZTJ4ID0gZXhwKC14KTtcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xuYCxCbmU9WmUoe29wU25pcHBldDpXbmV9KSxWbmU9e2tlcm5lbE5hbWU6QmksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Qm5lfSxVbmU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiSW1hZ2VcIixcIkJveGVzXCIsXCJCb3hJbmRcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTtsZXRbcyxpLG8sbF09ZSxbdV09dCxbcCxkXT1uO3RoaXMub3V0cHV0U2hhcGU9W3UscCxkLGxdO2xldCBjPWE9PT1cImJpbGluZWFyXCI/MTowLFtoLG1dPVtgJHtpLTF9LjBgLGAke28tMX0uMGBdLFtmLGcsYl09cD4xP1tgJHsoaS0xKS8ocC0xKX1gLFwiKHkyLXkxKSAqIGhlaWdodF9yYXRpb1wiLGB5MSoke2h9ICsgZmxvYXQoeSkqKGhlaWdodF9zY2FsZSlgXTpbXCIwLjBcIixcIjAuMFwiLGAwLjUgKiAoeTEreTIpICogJHtofWBdLFt5LHgsdl09ZD4xP1tgJHsoby0xKS8oZC0xKX1gLFwiKHgyLXgxKSAqIHdpZHRoX3JhdGlvXCIsYHgxKiR7bX0gKyBmbG9hdCh4KSood2lkdGhfc2NhbGUpYF06W1wiMC4wXCIsXCIwLjBcIixgMC41ICogKHgxK3gyKSAqICR7bX1gXTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGZsb2F0IGhlaWdodF9yYXRpbyA9IGZsb2F0KCR7Zn0pO1xuICAgICAgY29uc3QgZmxvYXQgd2lkdGhfcmF0aW8gPSBmbG9hdCgke3l9KTtcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgeSA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IHggPSBjb29yZHNbMl07XG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xuXG4gICAgICAgIC8vIGdldCBib3ggdmFsc1xuICAgICAgICBmbG9hdCB5MSA9IGdldEJveGVzKGIsMCk7XG4gICAgICAgIGZsb2F0IHgxID0gZ2V0Qm94ZXMoYiwxKTtcbiAgICAgICAgZmxvYXQgeTIgPSBnZXRCb3hlcyhiLDIpO1xuICAgICAgICBmbG9hdCB4MiA9IGdldEJveGVzKGIsMyk7XG5cbiAgICAgICAgLy8gZ2V0IGltYWdlIGluIGJhdGNoIGluZGV4XG4gICAgICAgIGludCBiSW5kID0gcm91bmQoZ2V0Qm94SW5kKGIpKTtcbiAgICAgICAgaWYoYkluZCA8IDAgfHwgYkluZCA+PSAke3N9KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgaGVpZ2h0X3NjYWxlID0gJHtnfTtcbiAgICAgICAgZmxvYXQgd2lkdGhfc2NhbGUgPSAke3h9O1xuXG4gICAgICAgIGZsb2F0IGluX3kgPSAke2J9O1xuICAgICAgICBpZiggaW5feSA8IDAuMCB8fCBpbl95ID4gJHtofSApIHtcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoJHtyfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmbG9hdCBpbl94ID0gJHt2fTtcbiAgICAgICAgaWYoIGluX3ggPCAwLjAgfHwgaW5feCA+ICR7bX0gKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KCR7cn0pKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleENSID0gdmVjMihpbl94LGluX3kpO1xuICAgICAgICBpZigke2N9ID09IDEpIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cbiAgICAgICAgICBpdmVjMiBzb3VyY2VGbG9vckNSID0gaXZlYzIoc291cmNlRnJhY0luZGV4Q1IpO1xuICAgICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxDUiA9IGl2ZWMyKGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcblxuICAgICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VGbG9vckNSLnksIHNvdXJjZUZsb29yQ1IueCwgZCk7XG4gICAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xuICAgICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XG4gICAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xuXG4gICAgICAgICAgdmVjMiBmcmFjQ1IgPSBzb3VyY2VGcmFjSW5kZXhDUiAtIHZlYzIoc291cmNlRmxvb3JDUik7XG5cbiAgICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjQ1IueDtcbiAgICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjQ1IueDtcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY0NSLnk7XG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cbiAgICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0Q1IgPSBpdmVjMihmbG9vcihcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleENSICsgdmVjMigwLjUsMC41KSkpO1xuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0SW1hZ2UoYiwgc291cmNlTmVhcmVzdENSLnksIHNvdXJjZU5lYXJlc3RDUi54LCBkKTtcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYH19LEduZT1lPT57bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZTpyLGJveGVzOnMsYm94SW5kOml9PXQse2Nyb3BTaXplOm8sbWV0aG9kOmwsZXh0cmFwb2xhdGlvblZhbHVlOnV9PWEscD1uZXcgVW5lKHIuc2hhcGUscy5zaGFwZSxvLGwsdSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKHAsW3IscyxpXSxcImZsb2F0MzJcIil9LEhuZT17a2VybmVsTmFtZTp1dSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpHbmV9LF9jOyhmdW5jdGlvbihlKXtlLlByb2Q9XCIqXCIsZS5TdW09XCIrXCJ9KShfY3x8KF9jPXt9KSk7dmFyIGdTPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEpe3RoaXMub3A9ZSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJpbmRleFwiLHR5cGU6XCJmbG9hdFwifV07bGV0IHI9dGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgscz10aGlzLm9wPT09X2MuUHJvZD9cIjEuMFwiOlwiMC4wXCIsaT1uP3M6YGdldFgoJHtiUyhyLFwiY29vcmRzXCIsdGhpcy5vcCl9KWAsbz10aGlzLm91dHB1dFNoYXBlW3RoaXMub3V0cHV0U2hhcGUubGVuZ3RoLTFdLGw9XCJcIix1PVwiXCI7bj8obD1hP2BlbmQgIT0gJHtvLTF9YDpcImVuZCAhPSAwXCIsdT1hP1wiZW5kICsgMVwiOlwiZW5kIC0gMVwiKToobD1hP2BlbmQgKyBwb3cyIDwgJHtvfWA6XCJlbmQgPj0gcG93MlwiLHU9YT9cImVuZCArIHBvdzJcIjpcImVuZCAtIHBvdzJcIiksdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7aHQocil9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgZW5kID0gJHt5UyhyLFwiY29vcmRzXCIsdGhpcy5vcCl9O1xuICAgICAgICBmbG9hdCB2YWwgPSAke2l9O1xuICAgICAgICBpbnQgcG93MiA9IGludChwb3coMi4wLCBpbmRleCkpO1xuICAgICAgICBpZiAoJHtsfSkge1xuICAgICAgICAgIGludCBpZHggPSAke3V9O1xuICAgICAgICAgICR7eVMocixcImNvb3Jkc1wiLHRoaXMub3ApfSA9IGlkeDtcbiAgICAgICAgICB2YWwgJHt0aGlzLm9wfT0gZ2V0WCgke2JTKHIsXCJjb29yZHNcIix0aGlzLm9wKX0pO1xuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBiUyhlLHQsbil7aWYoZT09PTEpcmV0dXJuYCR7dH1gO2lmKGU9PT0yKXJldHVybmAke3R9LngsICR7dH0ueWA7aWYoZT09PTMpcmV0dXJuYCR7dH0ueCwgJHt0fS55LCAke3R9LnpgO2lmKGU9PT00KXJldHVybmAke3R9LngsICR7dH0ueSwgJHt0fS56LCAke3R9LndgO3Rocm93IG5ldyBFcnJvcihgQ3VtdWxhdGl2ZSAke259IGZvciByYW5rICR7ZX0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX1mdW5jdGlvbiB5UyhlLHQsbil7aWYoZT09PTEpcmV0dXJuYCR7dH1gO2lmKGU9PT0yKXJldHVybmAke3R9LnlgO2lmKGU9PT0zKXJldHVybmAke3R9LnpgO2lmKGU9PT00KXJldHVybmAke3R9LndgO3Rocm93IG5ldyBFcnJvcihgQ3VtdWxhdGl2ZSAke259IGZvciByYW5rICR7ZX0gaXMgbm90IHlldCBzdXBwb3J0ZWRgKX1mdW5jdGlvbiBLQShlLHQsbixhLHIscyl7bGV0IGk9dC5zaGFwZS5sZW5ndGgsbz1ULmdldEF4ZXNQZXJtdXRhdGlvbihbYV0saSksbD10O28hPW51bGwmJihsPVNuKHtpbnB1dHM6e3g6dH0sYmFja2VuZDpuLGF0dHJzOntwZXJtOm99fSkpO2xldCB1PVQuZ2V0SW5uZXJNb3N0QXhlcygxLGkpWzBdO2lmKHUhPT1pLTEpdGhyb3cgbmV3IEVycm9yKGBXZWJHTCBjdW1wcm9kIHNoYWRlciBleHBlY3RzIGFuIGlubmVyLW1vc3QgYXhpcz0ke3Quc2hhcGUubGVuZ3RoLTF9IGJ1dCBnb3QgYXhpcz0ke2F9YCk7bGV0IHA9bC5zaGFwZVt1XSxkPXRhKHtpbnB1dHM6e3g6bH0sYmFja2VuZDpufSk7Zm9yKGxldCBjPTA7Yzw9TWF0aC5jZWlsKE1hdGgubG9nMihwKSktMTtjKyspe2xldCBoPW5ldyBnUyhlLGwuc2hhcGUsITEscyksbT1bW2NdXSxmPWQ7ZD1uLnJ1bldlYkdMUHJvZ3JhbShoLFtkXSxkLmR0eXBlLG0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZil9aWYocil7bGV0IGM9bmV3IGdTKGUsbC5zaGFwZSxyLHMpLGg9ZDtkPW4ucnVuV2ViR0xQcm9ncmFtKGMsW2RdLGQuZHR5cGUpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCl9aWYobyE9bnVsbCl7bGV0IGM9VC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKG8pLGg9U24oe2lucHV0czp7eDpkfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06Y319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhkKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGwpLGh9cmV0dXJuIGR9ZnVuY3Rpb24gam5lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsZXhjbHVzaXZlOmkscmV2ZXJzZTpvfT1hO3JldHVybiBLQShfYy5Qcm9kLHIsbixzLGksbyl9dmFyIHFuZT17a2VybmVsTmFtZTpsdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpqbmV9O2Z1bmN0aW9uIEtuZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7YXhpczpzLGV4Y2x1c2l2ZTppLHJldmVyc2U6b309YTtyZXR1cm4gS0EoX2MuU3VtLHIsbixzLGksbyl9dmFyIFhuZT17a2VybmVsTmFtZTpWaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpLbmV9O2Z1bmN0aW9uIFluZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cix3ZWlnaHRzOnN9PXQse3NpemU6aSxiaW5hcnlPdXRwdXQ6b309YTtpZihyLnNoYXBlLmxlbmd0aD09PTEpe2xldCBsPW4ucmVhZFN5bmMoci5kYXRhSWQpLHU9bi5yZWFkU3luYyhzLmRhdGFJZCkscD1UQShsLHUscy5kdHlwZSxzLnNoYXBlLGkpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtpXSxzLmR0eXBlLHApfWVsc2UgaWYoci5zaGFwZS5sZW5ndGg9PT0yKXtsZXQgbD1uLmJ1ZmZlclN5bmMociksdT1uLmJ1ZmZlclN5bmMocykscD1KOShsLHUsaSxvKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhwLnNoYXBlLHMuZHR5cGUscC52YWx1ZXMpfXRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gZGVuc2VCaW5jb3VudDogaW5wdXQgbXVzdCBiZSBhdCBtb3N0IHJhbmsgMiwgYnV0IGdvdCByYW5rJHtyLnNoYXBlLmxlbmd0aH0uYCl9dmFyIFpuZT17a2VybmVsTmFtZTpQYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpZbmV9LEpuZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy5ibG9ja1NpemU9dCx0aGlzLmRhdGFGb3JtYXQ9bix0aGlzLnVzZXJDb2RlPWBcbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgaW50IGggPSAke3RoaXMuZ2V0SGVpZ2h0Q29vcmRTdHJpbmcoKX07XG4gICAgICBpbnQgdyA9ICR7dGhpcy5nZXRXaWR0aENvb3JkU3RyaW5nKCl9O1xuICAgICAgaW50IGQgPSAke3RoaXMuZ2V0RGVwdGhDb29yZFN0cmluZygpfTtcblxuICAgICAgaW50IGluX2ggPSBoIC8gJHt0fTtcbiAgICAgIGludCBvZmZzZXRfaCA9IGltb2QoaCwgJHt0fSk7XG4gICAgICBpbnQgaW5fdyA9IHcgLyAke3R9O1xuICAgICAgaW50IG9mZnNldF93ID0gaW1vZCh3LCAke3R9KTtcbiAgICAgIGludCBvZmZzZXRfZCA9IChvZmZzZXRfaCAqICR7dH0gKyBvZmZzZXRfdykgKlxuICAgICAgICAke3RoaXMuZ2V0T3V0cHV0RGVwdGhTaXplKCl9O1xuICAgICAgaW50IGluX2QgPSBkICsgb2Zmc2V0X2Q7XG5cbiAgICAgIGZsb2F0IHJlc3VsdCA9ICR7dGhpcy5nZXRJbnB1dFNhbXBsaW5nU3RyaW5nKCl9O1xuICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgfVxuICBgfWdldEhlaWdodENvb3JkU3RyaW5nKCl7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiTkhXQ1wiP1wiY29vcmRzWzFdXCI6XCJjb29yZHNbMl1cIn1nZXRXaWR0aENvb3JkU3RyaW5nKCl7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiTkhXQ1wiP1wiY29vcmRzWzJdXCI6XCJjb29yZHNbM11cIn1nZXREZXB0aENvb3JkU3RyaW5nKCl7cmV0dXJuIHRoaXMuZGF0YUZvcm1hdD09PVwiTkhXQ1wiP1wiY29vcmRzWzNdXCI6XCJjb29yZHNbMV1cIn1nZXRPdXRwdXREZXB0aFNpemUoKXtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0PT09XCJOSFdDXCI/dGhpcy5vdXRwdXRTaGFwZVszXTp0aGlzLm91dHB1dFNoYXBlWzFdfWdldElucHV0U2FtcGxpbmdTdHJpbmcoKXtyZXR1cm4gdGhpcy5kYXRhRm9ybWF0PT09XCJOSFdDXCI/XCJnZXRYKGIsIGluX2gsIGluX3csIGluX2QpXCI6XCJnZXRYKGIsIGluX2QsIGluX2gsIGluX3cpXCJ9fTtmdW5jdGlvbiBRbmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2Jsb2NrU2l6ZTpzLGRhdGFGb3JtYXQ6aX09YSxvPXIuc2hhcGVbMF0sbD1pPT09XCJOSFdDXCI/ci5zaGFwZVsxXTpyLnNoYXBlWzJdLHU9aT09PVwiTkhXQ1wiP3Iuc2hhcGVbMl06ci5zaGFwZVszXSxwPWk9PT1cIk5IV0NcIj9yLnNoYXBlWzNdOnIuc2hhcGVbMV0sZD1sKnMsYz11KnMsaD1wLyhzKnMpLG09aT09PVwiTkhXQ1wiP1tvLGQsYyxoXTpbbyxoLGQsY10sZj1uZXcgSm5lKG0scyxpKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oZixbcl0sci5kdHlwZSl9dmFyIGVhZT17a2VybmVsTmFtZTpwdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpRbmV9LFhBPWNsYXNze2NvbnN0cnVjdG9yKGUsdD0hMSxuPW51bGwsYT0hMSxyPSExKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInBhZHNcIix0eXBlOlwiaXZlYzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwiaW5EaW1zXCIsdHlwZTpcIml2ZWMyXCJ9XSx0aGlzLm91dHB1dFNoYXBlPWUub3V0U2hhcGUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXQgcz1lLmZpbHRlckhlaWdodCxpPWUuZmlsdGVyV2lkdGgsbz1lLm91dENoYW5uZWxzL2UuaW5DaGFubmVscyxsPVwiXCIsdT1cIlwiO24mJihhP2w9YGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xuICAgICAgICAgIGZsb2F0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke259XG4gICAgICAgIH1gOnI/bD1gZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldExlYWt5cmVsdUFscGhhQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke259XG4gICAgICAgIH1gOmw9YFxuICAgICAgICAgIGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgeCkge1xuICAgICAgICAgICAgJHtufVxuICAgICAgICAgIH1cbiAgICAgICAgYCx1PVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTtsZXQgcD10P1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7dCYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLGEmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSxyJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcImxlYWt5cmVsdUFscGhhXCIpLHRoaXMudXNlckNvZGU9YFxuICAgICAgJHtsfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xuICAgICAgICBpbnQgZDEgPSBkMiAvICR7b307XG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqICR7b307XG5cbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgcSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICAvLyBUTyBETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke3N9OyB3UisrKSB7XG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIGRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gaW5EaW1zWzBdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtpfTsgd0MrKykge1xuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIGRpbGF0aW9uc1sxXTtcblxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCByZXN1bHQgPSBkb3RQcm9kO1xuICAgICAgICAke3B9XG4gICAgICAgICR7dX1cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19LFlBPWNsYXNze2NvbnN0cnVjdG9yKGUsdD0hMSxuPW51bGwsYT0hMSxyPSExKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInBhZHNcIix0eXBlOlwiaXZlYzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIml2ZWMyXCJ9LHtuYW1lOlwiaW5EaW1zXCIsdHlwZTpcIml2ZWMyXCJ9XSx0aGlzLm91dHB1dFNoYXBlPWUub3V0U2hhcGUsdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zPXZuKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtsZXQgcz1lLm91dENoYW5uZWxzL2UuaW5DaGFubmVscyxpPWUucGFkSW5mby5sZWZ0LG89ZS5zdHJpZGVXaWR0aCxsPWUuZGlsYXRpb25XaWR0aCx1PWUuZmlsdGVySGVpZ2h0LHA9ZS5maWx0ZXJXaWR0aCxkPXAsYz1gXG4gICAgICBpbnQgeFI7IGludCB4QzsgaW50IHhDT2Zmc2V0O1xuICAgICAgdmVjNCB3VGV4ZWw7IHZlYzQgcHJldmlvdXM7IHZlYzQgZmluYWw7YDtmb3IobGV0IGc9MDtnPHA7ZysrKWMrPWBcbiAgICAgICAgICB2ZWM0IHhUZXhlbEMke2cqMn07XG4gICAgICAgICAgaW50IHhUZXhlbEMke2cqMn1SZWFkeTtcbiAgICAgICAgICB2ZWM0IHhUZXhlbEMke2cqMisxfTtcbiAgICAgICAgICBpbnQgeFRleGVsQyR7ZyoyKzF9UmVhZHk7XG4gICAgICAgICAgdmVjNCB4QyR7Z307YDtjKz1gXG4gICAgZm9yIChpbnQgciA9IDA7IHIgPCAke3V9OyByKyspIHtcbiAgICAgIGA7Zm9yKGxldCBnPTA7ZzxwO2crKyljKz1gXG4gICAgICAgICAgeFRleGVsQyR7ZyoyfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICB4VGV4ZWxDJHtnKjJ9UmVhZHkgPSAwO1xuICAgICAgICAgIHhUZXhlbEMke2cqMisxfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICB4VGV4ZWxDJHtnKjIrMX1SZWFkeSA9IDA7XG4gICAgICAgICAgeEMke2d9ID0gdmVjNCgwLjApO2A7Yys9YFxuICAgICAgICB4UiA9IHhSQ29ybmVyICsgciAqIGRpbGF0aW9uc1swXTtcbiAgICAgICAgaWYgKHhSID49MCAmJiB4UiA8IGluRGltc1swXSkge1xuICAgICAgYDtmb3IobGV0IGc9MDtnPChkKzEpLzI7ZysrKXtsZXQgYj1nKjI7aWYoYys9YFxuICAgICAgICAgIHhDID0geENDb3JuZXIgKyAke2IqbH07XG4gICAgICAgICAgYCxvPT09MSl7aWYoYjxwJiYoaSUyPT09MT8oYys9YFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxO1xuICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2J9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Yn0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYCxsPT09MSYmYj4wP2MrPWBcbiAgICAgICAgICAgICAgICB4QyR7Yn0gPSB2ZWM0KHhUZXhlbEMke2ItMn0uencsIHhUZXhlbEMke2J9Lnh5KTtcbiAgICAgICAgICAgICAgICBgOmMrPWBcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gMjtcblxuICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeEMke2J9ID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsQyR7Yn0ueHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeEMke2J9ID0gdmVjNCgwLjAsIDAuMCwgeFRleGVsQyR7Yn0ueHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYCk6Yys9YFxuICAgICAgICAgICAgICAgIGlmICh4QyA+PSAwICYmIHhDIDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2J9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Yn0gPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgIGlmICh4QyArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Yn1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeEMke2J9ID0geFRleGVsQyR7Yn07XG4gICAgICAgICAgICAgICAgYCxiKzE8cCkpe2xldCB5PWklMj09PTA/dy5uZWFyZXN0TGFyZ2VyRXZlbihsKTpsO2wlMj09PTAmJmklMj09PTF8fGwlMiE9PTAmJmklMiE9PTE/KGMrPWBcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBpbW9kKHBhZHNbMV0sIDIpICsgJHt5fTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7YisxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7YisxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7YisxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtiKzF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYCxsPjE/Yys9YFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgIHhDJHtiKzF9ID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsQyR7YisxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICB4QyR7YisxfSA9IHZlYzQoMC4wLCAwLjAsIHhUZXhlbEMke2IrMX0ueHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGA6Yys9YFxuICAgICAgICAgICAgICAgICAgICB4QyR7YisxfSA9IHZlYzQoeFRleGVsQyR7Yn0uencsIHhUZXhlbEMke2IrMX0ueHkpO1xuICAgICAgICAgICAgICAgICAgICBgKTp5PT09MT9jKz1gXG4gICAgICAgICAgICAgICAgICAgIHhDJHtiKzF9ID0geFRleGVsQyR7Yn07XG4gICAgICAgICAgICAgICAgICAgIGA6Yys9YFxuICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgJHt5fTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtiKzF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7YisxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7YisxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHhDJHtiKzF9ID0geFRleGVsQyR7YisxfTtcbiAgICAgICAgICAgICAgICAgICAgYH19ZWxzZSBiPHAmJihpJTI9PT0xPyhjKz1gXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Yn1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHhDICsgMSA+PSAwICYmIHhDICsgMSA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtiKzF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7YisxfSA9IGdldFgoYmF0Y2gsIHhSLCB4QyArIDEsIGQxKTtcbiAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMiA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7YisxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeEMke2J9ID0gdmVjNCh4VGV4ZWxDJHtifS56dywgeFRleGVsQyR7YisxfS56dyk7XG4gICAgICAgICAgICAgIGAsYisxPHAmJihjKz1gXG4gICAgICAgICAgICAgICAgICBmaW5hbCA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxICsgc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhDJHtiKzF9ID0gdmVjNCh4VGV4ZWxDJHtiKzF9Lnh5LCBmaW5hbC54eSk7XG4gICAgICAgICAgICAgICAgYCkpOihjKz1gXG4gICAgICAgICAgICAgICAgaWYoeEMgPj0gMCAmJiB4QyA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtifVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtifS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7YisxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX0uencgPSB2ZWMyKDAuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2IrMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeEMke2J9ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2J9Lnh5LCB4VGV4ZWxDJHtiKzF9Lnh5KTtcbiAgICAgICAgICAgICAgYCxiKzE8cCYmKGMrPWBcbiAgICAgICAgICAgICAgICAgIHhDJHtiKzF9ID0gdmVjNCh4VGV4ZWxDJHtifS56dywgeFRleGVsQyR7YisxfS56dyk7XG4gICAgICAgICAgICAgICAgYCkpKTtiPHAmJihjKz1gXG4gICAgICAgICAgICB3VGV4ZWwgPSBnZXRXKHIsICR7Yn0sIGQxLCBxKTtcbiAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2J9ICogdmVjNCh3VGV4ZWwueHosIHdUZXhlbC54eik7XG4gICAgICAgICAgYCxiKzE8cCYmKGMrPWBcbiAgICAgICAgICAgICAgd1RleGVsID0gZ2V0VyhyLCAke2IrMX0sIGQxLCBxKTtcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4QyR7YisxfSAqIHZlYzQod1RleGVsLnh6LCB3VGV4ZWwueHopO1xuICAgICAgICAgICAgYCkpfWMrPWBcbiAgICB9XG4gIGAsYys9YFxuICAgICAgfVxuICAgIGA7bGV0IGg9XCJcIixtPVwiXCI7biYmKGE/aD1gdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgIHZlYzQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7bn1cbiAgICAgICAgfWA6cj9oPWB2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XG4gICAgICAgICAgdmVjNCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7bn1cbiAgICAgICAgfWA6aD1gdmVjNCBhY3RpdmF0aW9uKHZlYzQgeCkge1xuICAgICAgICAgICR7bn1cbiAgICAgICAgfWAsbT1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7bGV0IGY9dD9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO3QmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxhJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksciYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJsZWFreXJlbHVBbHBoYVwiKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgICR7aH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcbiAgICAgICAgaW50IGQxID0gZDIgLyAke3N9O1xuICAgICAgICBpbnQgcSA9IGQyIC0gZDEgKiAke3N9O1xuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgLy9pbnRpYWxpemUgZG90UHJvZCB3aXRoIGEgc21hbGwgZXBzaWxvbiBzZWVtcyB0byByZWR1Y2UgR1BVIGFjY3VyYWN5IGxvc3MuXG4gICAgICAgIHZlYzQgZG90UHJvZCA9IHZlYzQoMC4wMDAwMDAwMDAwMDAwMDEpO1xuXG4gICAgICAgICR7Y31cblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdFByb2QgLSB2ZWM0KDAuMDAwMDAwMDAwMDAwMDAxKTtcbiAgICAgICAgJHtmfVxuICAgICAgICAke219XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiB0YWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnN9PXQse3N0cmlkZXM6aSxwYWQ6byxkaWxhdGlvbnM6bCxkaW1Sb3VuZGluZ01vZGU6dX09YSxwPWw7cD09bnVsbCYmKHA9WzEsMV0pLHcuYXNzZXJ0KFQuZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGkscCksKCk9PmBFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7aX0gYW5kIGRpbGF0aW9ucyAnJHtwfSdgKTtsZXQgZD1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscy5zaGFwZSxpLHAsbyx1LCEwKSxjO0coKS5nZXRCb29sKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIpJiZkLnN0cmlkZVdpZHRoPD0yJiZkLm91dENoYW5uZWxzL2QuaW5DaGFubmVscz09PTE/Yz1uZXcgWUEoZCk6Yz1uZXcgWEEoZCk7bGV0IGg9W1tkLnBhZEluZm8udG9wLGQucGFkSW5mby5sZWZ0XSxbZC5zdHJpZGVIZWlnaHQsZC5zdHJpZGVXaWR0aF0sW2QuZGlsYXRpb25IZWlnaHQsZC5kaWxhdGlvbldpZHRoXSxbZC5pbkhlaWdodCxkLmluV2lkdGhdXTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oYyxbcixzXSxcImZsb2F0MzJcIixoKX12YXIgbmFlPXtrZXJuZWxOYW1lOlVpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnRhZX0sYWFlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPWUuZmlsdGVyU2hhcGU7bGV0IHQ9ZS5zdHJpZGVIZWlnaHQsbj1lLnN0cmlkZVdpZHRoLGE9ZS5wYWRJbmZvLnRvcCxyPWUucGFkSW5mby5sZWZ0LHM9ZS5vdXRDaGFubmVscy9lLmluQ2hhbm5lbHM7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xuICAgICAgICBpbnQgZG0gPSBjb29yZHMudztcbiAgICAgICAgaW50IGQyID0gZDEgKiAke3N9ICsgZG07XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBiYXRjaCBzaXplXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgJHtlLmJhdGNoU2l6ZX07IGIrKykge1xuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCAke2Uub3V0SGVpZ2h0fTsgeVIrKykge1xuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqICR7dH0gLSAke2F9O1xuXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49ICR7ZS5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCAke2Uub3V0V2lkdGh9OyB5QysrKSB7XG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiAke259IC0gJHtyfTtcblxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7ZS5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGB9fSxyYWU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO2xldCB0PWUuZmlsdGVySGVpZ2h0LG49ZS5maWx0ZXJXaWR0aCxhPWUuc3RyaWRlSGVpZ2h0LHI9ZS5zdHJpZGVXaWR0aCxzPXQtMS1lLnBhZEluZm8udG9wLGk9bi0xLWUucGFkSW5mby5sZWZ0LG89ZS5vdXRDaGFubmVscy9lLmluQ2hhbm5lbHM7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtzfSwgJHtpfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQxID0gY29vcmRzWzNdO1xuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcblxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke3R9OyB3UisrKSB7XG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gJHthfS4wO1xuXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtlLm91dEhlaWdodH0uMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgIGludCB3UlBlcm0gPSAke3R9IC0gMSAtIHdSO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7bn07IHdDKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7cn0uMDtcblxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtlLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSAke259IC0gMSAtIHdDO1xuXG4gICAgICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBjaGFubmVsTXVsXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgJHtvfTsgZG0rKykge1xuICAgICAgICAgICAgICBpbnQgZDIgPSBkMSAqICR7b30gKyBkbTtcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gc2FlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGR5OnN9PXQse3N0cmlkZXM6aSxkaWxhdGlvbnM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dSxmaWx0ZXJTaGFwZTpwfT1hLGQ9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHAsaSxvLGwsdSwhMCksYz1uZXcgYWFlKGQpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShjLFtyLHNdLFwiZmxvYXQzMlwiKX12YXIgaWFlPXtrZXJuZWxOYW1lOkltLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnNhZX07ZnVuY3Rpb24gb2FlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixmaWx0ZXI6c309dCx7c3RyaWRlczppLGRpbGF0aW9uczpvLHBhZDpsLGRpbVJvdW5kaW5nTW9kZTp1LGlucHV0U2hhcGU6cH09YSxkPVQuY29tcHV0ZUNvbnYyREluZm8ocCxzLnNoYXBlLGksbyxsLHUsITApLGM9bmV3IHJhZShkKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oYyxbcixzXSxcImZsb2F0MzJcIil9dmFyIGxhZT17a2VybmVsTmFtZTpTbSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpvYWV9LHVhZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiWFwiXSx0aGlzLm91dHB1dFNoYXBlPVtlLGVdLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIGZsb2F0IHZhbCA9IGNvb3Jkc1swXSA9PSBjb29yZHNbMV0gPyBnZXRYKGNvb3Jkc1swXSkgOiAwLjA7XG4gICAgICAgICAgc2V0T3V0cHV0KHZhbCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIHBhZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQscj1bLi4uYS5zaGFwZSwuLi5hLnNoYXBlXSxzPXcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSxpPWNlKHtpbnB1dHM6e3g6YX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbc119fSksbz1uZXcgdWFlKHMpLGw9bi5ydW5XZWJHTFByb2dyYW0obyxbaV0saS5kdHlwZSksdT1jZSh7aW5wdXRzOnt4Omx9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6cn19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGwpLHV9dmFyIGNhZT17a2VybmVsTmFtZTpMYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpwYWV9LGRhZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPWUub3V0U2hhcGU7bGV0e2luSGVpZ2h0OnQsaW5XaWR0aDpuLHBhZEluZm86YSxzdHJpZGVIZWlnaHQ6cixzdHJpZGVXaWR0aDpzLGZpbHRlckhlaWdodDppLGZpbHRlcldpZHRoOm8sZGlsYXRpb25IZWlnaHQ6bCxkaWxhdGlvbldpZHRoOnV9PWUse3RvcDpwLGxlZnQ6ZH09YTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke3J9LCAke3N9KTtcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3B9LCAke2R9KTtcbiAgICAgIGNvbnN0IGZsb2F0IG5lZ19pbmZpbml0eSA9IC0zLjRlMzg7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgZDEgPSBjb29yZHMudztcbiAgICAgICAgaXZlYzIgb3V0VG9wTGVmdENvcm5lciA9XG4gICAgICAgICAgICBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcbiAgICAgICAgaW50IGhCZWcgPSBvdXRUb3BMZWZ0Q29ybmVyLng7XG4gICAgICAgIGludCB3QmVnID0gb3V0VG9wTGVmdENvcm5lci55O1xuXG4gICAgICAgIGZsb2F0IGN1clZhbCA9IG5lZ19pbmZpbml0eTtcbiAgICAgICAgZm9yIChpbnQgaCA9IDA7IGggPCAke2l9OyBoKyspIHtcbiAgICAgICAgICBpbnQgaEluID0gaEJlZyArIGggKiAke2x9O1xuXG4gICAgICAgICAgaWYgKGhJbiA+PSAwICYmIGhJbiA8ICR7dH0pIHtcbiAgICAgICAgICAgIGZvciAoaW50IHcgPSAwOyB3IDwgJHtvfTsgdysrKSB7XG4gICAgICAgICAgICAgIGludCB3SW4gPSB3QmVnICsgdyAqICR7dX07XG5cbiAgICAgICAgICAgICAgaWYgKHdJbiA+PSAwICYmIHdJbiA8ICR7bn0pIHtcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsID0gZ2V0WChiYXRjaCwgaEluLCB3SW4sIGQxKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhoLCB3LCBkMSk7XG5cbiAgICAgICAgICAgICAgICBmbG9hdCB2YWwgPSB4VmFsICsgd1ZhbDtcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gY3VyVmFsKSB7XG4gICAgICAgICAgICAgICAgICBjdXJWYWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gY3VyVmFsO1xuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gaGFlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzfT10LHtzdHJpZGVzOmkscGFkOm8sZGlsYXRpb25zOmx9PWEsdT1ULmNvbXB1dGVEaWxhdGlvbjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsaSxvLFwiTkhXQ1wiLGwpLHAsZD1uZXcgZGFlKHUpO3A9bi5ydW5XZWJHTFByb2dyYW0oZCxbcixzXSxcImZsb2F0MzJcIik7bGV0IGM9Y2Uoe2lucHV0czp7eDpwfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnUub3V0U2hhcGV9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocCksY312YXIgbWFlPXtrZXJuZWxOYW1lOkdpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmhhZX07ZnVuY3Rpb24gZmFlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZXF1YXRpb246cn09YSxzPXQse2FsbERpbXM6aSxzdW1tZWREaW1zOm8saWREaW1zOmx9PVQuZGVjb2RlRWluc3VtRXF1YXRpb24ocixzLmxlbmd0aCk7VC5jaGVja0VpbnN1bURpbVNpemVzKGkubGVuZ3RoLGwscyk7bGV0e3BhdGg6dSxzdGVwczpwfT1ULmdldEVpbnN1bUNvbXB1dGVQYXRoKG8sbCksZD1wLmxlbmd0aCxjPW51bGwsaD1pLmxlbmd0aCxtPVtdO2ZvcihsZXQgZj0wO2Y8ZDsrK2Ype2ZvcihsZXQgZyBvZiBwW2ZdKXtsZXR7cGVybXV0YXRpb25JbmRpY2VzOmIsZXhwYW5kRGltczp5fT1ULmdldEVpbnN1bVBlcm11dGF0aW9uKGgsbFtnXSkseDtULmlzSWRlbnRpdHlQZXJtdXRhdGlvbihiKT94PXNbZ106KHg9U24oe2lucHV0czp7eDpzW2ddfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06Yn19KSxtLnB1c2goeCkpO2xldCB2PXguc2hhcGUuc2xpY2UoKTtmb3IobGV0IEk9MDtJPHkubGVuZ3RoOysrSSl2LnNwbGljZSh5W0ldLDAsMSk7dy5hcnJheXNFcXVhbCh4LnNoYXBlLHYpfHwoeD1jZSh7aW5wdXRzOnt4fSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnZ9fSksbS5wdXNoKHgpKSxjPT09bnVsbD9jPXg6KGM9cGsoe2lucHV0czp7YTp4LGI6Y30sYmFja2VuZDpufSksbS5wdXNoKGMpKX1mPGQtMSYmKHVbZl0+PTAmJihjPVZmKHtpbnB1dHM6e3g6Y30sYmFja2VuZDpuLGF0dHJzOntheGlzOnVbZl0tKGkubGVuZ3RoLWgpLGtlZXBEaW1zOiExfX0pLG0ucHVzaChjKSksaC0tKX1mb3IobGV0IGYgb2YgbSlmIT09YyYmbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKTtyZXR1cm4gY312YXIgZ2FlPXtrZXJuZWxOYW1lOlRtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZhZX0sYmFlPVwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCIseWFlPWBcbiAgdmVjNCByZXN1bHQ7XG5cbiAgcmVzdWx0LnIgPSAoeC5yID49IDAuMCkgPyB4LnIgOiAoZXhwKHgucikgLSAxLjApO1xuICByZXN1bHQuZyA9ICh4LmcgPj0gMC4wKSA/IHguZyA6IChleHAoeC5nKSAtIDEuMCk7XG4gIHJlc3VsdC5iID0gKHguYiA+PSAwLjApID8geC5iIDogKGV4cCh4LmIpIC0gMS4wKTtcbiAgcmVzdWx0LmEgPSAoeC5hID49IDAuMCkgPyB4LmEgOiAoZXhwKHguYSkgLSAxLjApO1xuXG4gIHJldHVybiByZXN1bHQ7XG5gLHhhZT1aZSh7b3BTbmlwcGV0OmJhZSxwYWNrZWRPcFNuaXBwZXQ6eWFlfSksdmFlPXtrZXJuZWxOYW1lOmppLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnhhZX0sd2FlPVwicmV0dXJuIChiID49IDAuMCkgPyBhIDogYSAqIChiICsgMS4wKTtcIixrYWU9YFxuICB2ZWM0IGJHVEVaZXJvID0gdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMC4pKSk7XG4gIHJldHVybiAoYkdURVplcm8gKiBhKSArICgodmVjNCgxLjApIC0gYkdURVplcm8pICogKGEgKiAoYiArIHZlYzQoMS4wKSkpKTtcbmAsSWFlPWU9PntsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtkeTphLHk6cn09dCxzPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgaHAoa2FlLGEuc2hhcGUsci5zaGFwZSk6bmV3IGtpKHdhZSxhLnNoYXBlLHIuc2hhcGUpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShzLFthLHJdLGEuZHR5cGUpfSxTYWU9e2tlcm5lbE5hbWU6Y3UsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6SWFlfSxOYWU9YFxuICByZXR1cm4gdmVjNChlcXVhbChhLCBiKSk7XG5gLFRhZT1cInJldHVybiBmbG9hdChhID09IGIpO1wiLENhZT1obih7b3BTbmlwcGV0OlRhZSxwYWNrZWRPcFNuaXBwZXQ6TmFlLGR0eXBlOlwiYm9vbFwiLGNwdUtlcm5lbEltcGw6YVF9KSxFYWU9e2tlcm5lbE5hbWU6ZHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Q2FlfSxfYWU9YFxuICAvLyBFcnJvciBmdW5jdGlvbiBpcyBjYWxjdWxhdGVkIGFwcHJveGltYXRlbHkgd2l0aCBlbGVtZW50YXJ5IGZ1bmN0aW9uLlxuICAvLyBTZWUgXCJIYW5kYm9vayBvZiBNYXRoZW1hdGljYWwgRnVuY3Rpb25zIHdpdGggRm9ybXVsYXMsXG4gIC8vIEdyYXBocywgYW5kIE1hdGhlbWF0aWNhbCBUYWJsZXNcIiwgQWJyYW1vd2l0eiBhbmQgU3RlZ3VuLlxuICBmbG9hdCBwID0gJHtULkVSRl9QfTtcbiAgZmxvYXQgYTEgPSAke1QuRVJGX0ExfTtcbiAgZmxvYXQgYTIgPSAke1QuRVJGX0EyfTtcbiAgZmxvYXQgYTMgPSAke1QuRVJGX0EzfTtcbiAgZmxvYXQgYTQgPSAke1QuRVJGX0E0fTtcbiAgZmxvYXQgYTUgPSAke1QuRVJGX0E1fTtcblxuICBmbG9hdCBzaWduID0gc2lnbih4KTtcbiAgeCA9IGFicyh4KTtcbiAgZmxvYXQgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIHJldHVybiBzaWduICogKDEuMCAtICgoKCgoYTUqdCArIGE0KSp0KSArIGEzKSp0ICsgYTIpKnQgKyBhMSkqdCpleHAoLXgqeCkpO1xuYCxBYWU9WmUoe29wU25pcHBldDpfYWV9KSxGYWU9e2tlcm5lbE5hbWU6cWksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6QWFlfSwkYWU9bXArYFxuICByZXR1cm4gZXhwKHgpO1xuYCxEYWU9YFxuICB2ZWM0IHJlc3VsdCA9IGV4cCh4KTtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcbiAgcmVzdWx0LnIgPSBpc05hTi5yID8geC5yIDogcmVzdWx0LnI7XG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiByZXN1bHQuYjtcbiAgcmVzdWx0LmEgPSBpc05hTi5hID8geC5hIDogcmVzdWx0LmE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbmAsWkE9WmUoe29wU25pcHBldDokYWUscGFja2VkT3BTbmlwcGV0OkRhZSxjcHVLZXJuZWxJbXBsOnJRLGR0eXBlOlwiZmxvYXQzMlwifSksUmFlPXtrZXJuZWxOYW1lOktpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlpBfTtmdW5jdGlvbiBndihlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse2RpbTpyfT1uLHtpbnB1dDpzfT10LGk9cy5zaGFwZS5sZW5ndGgsbz1zLnNoYXBlLnNsaWNlKCksbD1yO3JldHVybiByPDAmJih3LmFzc2VydCgtKGkrMSk8PXIsKCk9PmBBeGlzIG11c3QgYmUgaW4gdGhlIGludGVydmFsIFskey0oaSsxKX0sICR7aX1dYCksbD1pK3IrMSksby5zcGxpY2UobCwwLDEpLGNlKHtpbnB1dHM6e3g6c30sYmFja2VuZDphLGF0dHJzOntzaGFwZTpvfX0pfXZhciBNYWU9e2tlcm5lbE5hbWU6aHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Z3Z9LHhTPVwicmV0dXJuIGV4cCh4KSAtIDEuMDtcIixPYWU9WmUoe29wU25pcHBldDp4UyxwYWNrZWRPcFNuaXBwZXQ6eFMsY3B1S2VybmVsSW1wbDpzUX0pLFBhZT17a2VybmVsTmFtZTpYaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpPYWV9LHZTPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXTtsZXQgYT10WzFdO3RoaXMub3V0cHV0U2hhcGU9dDtsZXQgcj1uP2AyLjAgKiAke01hdGguUEl9YDpgLTIuMCAqICR7TWF0aC5QSX1gLHM9bj9gJHthfS4wYDpcIjEuMFwiLGk7aWYoZT09PVwicmVhbFwiKWk9XCJyZXR1cm4gcmVhbCAqIGV4cFIgLSBpbWFnICogZXhwSTtcIjtlbHNlIGlmKGU9PT1cImltYWdcIilpPVwicmV0dXJuIHJlYWwgKiBleHBJICsgaW1hZyAqIGV4cFI7XCI7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYEZGVCBjb21wb25lbnQgbXVzdCBiZSBlaXRoZXIgXCJyZWFsXCIgb3IgXCJpbWFnXCIsIGdvdCAke2V9LmApO3RoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgZmxvYXQgZXhwb25lbnRNdWx0aXBsaWVyID0gJHtyfTtcblxuICAgICAgZmxvYXQgdW5hcnlPcENvbXBsZXgoZmxvYXQgcmVhbCwgZmxvYXQgZXhwUiwgZmxvYXQgaW1hZywgZmxvYXQgZXhwSSkge1xuICAgICAgICAke2l9XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IG11bE1hdERGVChpbnQgYmF0Y2gsIGludCBpbmRleCkge1xuICAgICAgICBmbG9hdCBpbmRleFJhdGlvID0gZmxvYXQoaW5kZXgpIC8gZmxvYXQoJHthfSk7XG4gICAgICAgIGZsb2F0IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyA9XG4gICAgICAgICAgICBleHBvbmVudE11bHRpcGxpZXIgKiBpbmRleFJhdGlvO1xuXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7YX07IGkrKykge1xuICAgICAgICAgIC8vIHggPSAoLTJ8MiAqIFBJIC8gTikgKiBpbmRleCAqIGk7XG4gICAgICAgICAgZmxvYXQgeCA9IGV4cG9uZW50TXVsdGlwbGllclRpbWVzSW5kZXhSYXRpbyAqIGZsb2F0KGkpO1xuICAgICAgICAgIGZsb2F0IGV4cFIgPSBjb3MoeCk7XG4gICAgICAgICAgZmxvYXQgZXhwSSA9IHNpbih4KTtcbiAgICAgICAgICBmbG9hdCByZWFsID0gZ2V0UmVhbChiYXRjaCwgaSk7XG4gICAgICAgICAgZmxvYXQgaW1hZyA9IGdldEltYWcoYmF0Y2gsIGkpO1xuXG4gICAgICAgICAgcmVzdWx0ICs9XG4gICAgICAgICAgICAgIHVuYXJ5T3BDb21wbGV4KHJlYWwsIGV4cFIsIGltYWcsIGV4cEkpIC8gJHtzfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHNldE91dHB1dChtdWxNYXRERlQoY29vcmRzWzBdLCBjb29yZHNbMV0pKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gSkEoZSx0LG4pe2xldCBhPW4udGV4RGF0YS5nZXQoZS5kYXRhSWQpLHI9dy5zaXplRnJvbVNoYXBlKGUuc2hhcGUpLHM9ZS5zaGFwZVtlLnNoYXBlLmxlbmd0aC0xXSxpPXIvcyxvPWNlKHtpbnB1dHM6e3g6ZX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbaSxzXX19KSxsPW8uc2hhcGUsdT1uZXcgdlMoXCJyZWFsXCIsbCx0KSxwPW5ldyB2UyhcImltYWdcIixsLHQpLGQ9W3tkYXRhSWQ6YS5jb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQsZHR5cGU6YS5jb21wbGV4VGVuc29ySW5mb3MucmVhbC5kdHlwZSxzaGFwZTpsfSx7ZGF0YUlkOmEuY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkLGR0eXBlOmEuY29tcGxleFRlbnNvckluZm9zLmltYWcuZHR5cGUsc2hhcGU6bH1dLGM9bi5ydW5XZWJHTFByb2dyYW0odSxkLFwiZmxvYXQzMlwiKSxoPW4ucnVuV2ViR0xQcm9ncmFtKHAsZCxcImZsb2F0MzJcIiksbT0kcyh7aW5wdXRzOntyZWFsOmMsaW1hZzpofSxiYWNrZW5kOm59KTtuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCk7bGV0IGY9Y2Uoe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmUuc2hhcGV9fSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhtKSxmfWZ1bmN0aW9uIExhZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dDphfT10O3JldHVybiBKQShhLCExLG4pfXZhciB6YWU9e2tlcm5lbE5hbWU6Q20sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6TGFlfSxXYWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwidmFsdWVcIix0eXBlOlwiZmxvYXRcIn1dLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgLy8gSW5wdXQgY2FuIGJlIG9idGFpbmVkIGZyb20gdW5pZm9ybSB2YWx1ZS5cbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gJGQoZSl7bGV0e2JhY2tlbmQ6dCxhdHRyczpufT1lLHtzaGFwZTphLHZhbHVlOnJ9PW4se2R0eXBlOnN9PW47aWYocz1zfHx3LmluZmVyRHR5cGUocikscz09PVwic3RyaW5nXCIpe2xldCBpPXcuZ2V0QXJyYXlGcm9tRFR5cGUocyx3LnNpemVGcm9tU2hhcGUoYSkpO3JldHVybiBpLmZpbGwociksdC5tYWtlVGVuc29ySW5mbyhhLHMsaSl9ZWxzZXtsZXQgaT1uZXcgV2FlKGEsciksbz1bW3JdXTtyZXR1cm4gdC5ydW5XZWJHTFByb2dyYW0oaSxbXSxzLG8pfX12YXIgQmFlPXtrZXJuZWxOYW1lOnpjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOiRkfSxWYWU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCJdLHRoaXMub3V0cHV0U2hhcGU9W107bGV0IHQ9ZVsyXTt0aGlzLm91dHB1dFNoYXBlPWUsdGhpcy51c2VyQ29kZT1gXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcblxuICAgICAgICAgIGludCBjb29yZFggPSAke3R9IC0geCAtIDE7XG4gICAgICAgICAgZmxvYXQgb3V0cHV0VmFsdWU7XG4gICAgICAgICAgaWYoY29vcmRYID49IDAgJiYgY29vcmRYIDwgJHt0fSkge1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBnZXRJbWFnZShjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRYLCBjb29yZHNbM10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZSA9IGdldEltYWdlKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChvdXRwdXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICBgfX0sVWFlPXtrZXJuZWxOYW1lOm11LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYmFja2VuZDp0fSk9PntsZXR7aW1hZ2U6bn09ZSxhPXQscj1uZXcgVmFlKG4uc2hhcGUpO3JldHVybiBhLnJ1bldlYkdMUHJvZ3JhbShyLFtuXSxuLmR0eXBlKX19LHdTPVwicmV0dXJuIGZsb29yKHgpO1wiLEdhZT1aZSh7b3BTbmlwcGV0OndTLHBhY2tlZE9wU25pcHBldDp3UyxjcHVLZXJuZWxJbXBsOmlRfSksSGFlPXtrZXJuZWxOYW1lOllpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkdhZX0samFlPWBcbiAgZmxvYXQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xuICBpbnQgaWEgPSByb3VuZChhKTtcbiAgaW50IGliID0gcm91bmQoYik7XG4gIGlmIChpYiAhPSAwKSB7XG4gICAgLy8gV2luZG93cyAoRDNEKSB3YW50cyBndWFyYW50ZWVkIG5vbi16ZXJvIGludCBkaXZpc2lvbiBhdCBjb21waWxlLXRpbWUuXG4gICAgcmV0dXJuIGZsb2F0KGlkaXYoaWEsIGliLCBzKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuYCxxYWU9YFxuICBpdmVjNCBpYSA9IHJvdW5kKGEpO1xuICBpdmVjNCBpYiA9IHJvdW5kKGIpO1xuICBidmVjNCBjb25kID0gbm90RXF1YWwoaWIsIGl2ZWM0KDApKTtcbiAgaXZlYzQgcmVzdWx0ID0gaXZlYzQoMCk7XG4gIHZlYzQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xuXG4gIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxuICBpZiAoY29uZFswXSkge1xuICAgIHJlc3VsdFswXSA9IGlkaXYoaWFbMF0sIGliWzBdLCBzWzBdKTtcbiAgfVxuICBpZiAoY29uZFsxXSkge1xuICAgIHJlc3VsdFsxXSA9IGlkaXYoaWFbMV0sIGliWzFdLCBzWzFdKTtcbiAgfVxuICBpZiAoY29uZFsyXSkge1xuICAgIHJlc3VsdFsyXSA9IGlkaXYoaWFbMl0sIGliWzJdLCBzWzJdKTtcbiAgfVxuICBpZiAoY29uZFszXSkge1xuICAgIHJlc3VsdFszXSA9IGlkaXYoaWFbM10sIGliWzNdLCBzWzNdKTtcbiAgfVxuICByZXR1cm4gdmVjNChyZXN1bHQpO1xuYCxLYWU9aG4oe29wU25pcHBldDpqYWUscGFja2VkT3BTbmlwcGV0OnFhZSxkdHlwZTpcImludDMyXCJ9KSxYYWU9e2tlcm5lbE5hbWU6WmksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6S2FlfSxZYWU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07bGV0IHQ9RW4oKSxbbixhXT1lO3RoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCB0ZXhSID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGRlcHRoID0gY29vcmRzWzJdO1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMigke2F9LjAsICR7bn0uMCk7XG5cbiAgICAgICAgdmVjNCB2YWx1ZXMgPSAke3QudGV4dHVyZTJEfShBLCB1dik7XG4gICAgICAgIGZsb2F0IHZhbHVlO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRPdXRwdXQoZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSkpO1xuICAgICAgfVxuICAgIGB9fSxaYWU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7bGV0IHQ9RW4oKSxbbixhXT1lO3RoaXMub3V0cHV0U2hhcGU9ZSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCB0ZXhSID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcbiAgICAgICAgaW50IGRlcHRoID0gY29vcmRzWzJdO1xuXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG5cbiAgICAgICAgZm9yKGludCByb3c9MDsgcm93PD0xOyByb3crKykge1xuICAgICAgICAgIGZvcihpbnQgY29sPTA7IGNvbDw9MTsgY29sKyspIHtcbiAgICAgICAgICAgIHRleEMgPSBjb29yZHNbMV0gKyByb3c7XG4gICAgICAgICAgICBkZXB0aCA9IGNvb3Jkc1syXSArIGNvbDtcblxuICAgICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXG4gICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHthfS4wLCAke259LjApO1xuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSAke3QudGV4dHVyZTJEfShBLCB1dik7XG4gICAgICAgICAgICBmbG9hdCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdFtyb3cgKiAyICsgY29sXSA9IGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICR7dC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGB9fSxKYWU9e2tlcm5lbE5hbWU6SGgsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6UWFlfSxJbCx4eD1HKCkuZ2V0Qm9vbChcIkNBTlZBUzJEX1dJTExfUkVBRF9GUkVRVUVOVExZX0ZPUl9HUFVcIik7ZnVuY3Rpb24gUWFlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7cGl4ZWxzOnJ9PXQse251bUNoYW5uZWxzOnN9PWEsaT10eXBlb2YgSFRNTFZpZGVvRWxlbWVudCE9XCJ1bmRlZmluZWRcIiYmciBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQsbz10eXBlb2YgSFRNTEltYWdlRWxlbWVudCE9XCJ1bmRlZmluZWRcIiYmciBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsW2wsdV09aT9bci52aWRlb1dpZHRoLHIudmlkZW9IZWlnaHRdOltyLndpZHRoLHIuaGVpZ2h0XSxwPVt1LGxdLGQ9W3UsbCxzXTtpZihvfHxpKXtsZXQgZj1HKCkuZ2V0Qm9vbChcIkNBTlZBUzJEX1dJTExfUkVBRF9GUkVRVUVOVExZX0ZPUl9HUFVcIik7KElsPT1udWxsfHxmIT09eHgpJiYoeHg9ZixJbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiLHt3aWxsUmVhZEZyZXF1ZW50bHk6eHh9KSksSWwuY2FudmFzLndpZHRoPWwsSWwuY2FudmFzLmhlaWdodD11LElsLmRyYXdJbWFnZShyLDAsMCxsLHUpLHI9SWwuY2FudmFzfWxldCBjPW4ubWFrZVRlbnNvckluZm8ocCxcImludDMyXCIpO24udGV4RGF0YS5nZXQoYy5kYXRhSWQpLnVzYWdlPWNhLlBJWEVMUyxuLmdwZ3B1LnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZShuLmdldFRleHR1cmUoYy5kYXRhSWQpLHIpO2xldCBoPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgWmFlKGQpOm5ldyBZYWUoZCksbT1uLnJ1bldlYkdMUHJvZ3JhbShoLFtjXSxcImludDMyXCIpO3JldHVybiBuLmRpc3Bvc2VEYXRhKGMuZGF0YUlkKSxtfWZ1bmN0aW9uIGVyZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10LHtzdHJpZGVzOmwscGFkOnUsZGF0YUZvcm1hdDpwLGRpbGF0aW9uczpkLGRpbVJvdW5kaW5nTW9kZTpjLGFjdGl2YXRpb246aCxsZWFreXJlbHVBbHBoYTptfT1hLGY9VC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChwKSxnPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxzLnNoYXBlLGwsZCx1LGMsITEsZiksYix5PVtdLHg9aSE9bnVsbCx2PW8hPW51bGwsST1oPT09XCJsZWFreXJlbHVcIixOPSgpPT57bGV0IF89W3Isc10sRj0oRCwkKT0+e2lmKCQ9PT1cIk5DSFdcIiYmRC5zaGFwZS5sZW5ndGg9PT0xJiZELnNoYXBlWzBdIT09MSl7bGV0IFM9Y2Uoe2lucHV0czp7eDpEfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltELnNoYXBlWzBdLDEsMV19fSk7cmV0dXJuIHkucHVzaChTKSxTfXJldHVybiBEfTtpZih4JiZfLnB1c2goRihpLHApKSx2JiZfLnB1c2goRihvLHApKSxJKXtsZXQgRD1uLm1ha2VUZW5zb3JJbmZvKFtdLFwiZmxvYXQzMlwiLHcuY3JlYXRlU2NhbGFyVmFsdWUobSxcImZsb2F0MzJcIikpO18ucHVzaChEKSx5LnB1c2goRCl9cmV0dXJuIF99O2lmKGcuZmlsdGVySGVpZ2h0PT09MSYmZy5maWx0ZXJXaWR0aD09PTEmJmcuZGlsYXRpb25IZWlnaHQ9PT0xJiZnLmRpbGF0aW9uV2lkdGg9PT0xJiZnLnN0cmlkZUhlaWdodD09PTEmJmcuc3RyaWRlV2lkdGg9PT0xJiYoZy5wYWRJbmZvLnR5cGU9PT1cIlNBTUVcInx8Zy5wYWRJbmZvLnR5cGU9PT1cIlZBTElEXCIpKWI9akEoe3g6cixmaWx0ZXI6cyxjb252SW5mbzpnLGJhY2tlbmQ6bixiaWFzOmksYWN0aXZhdGlvbjpoLHByZWx1QWN0aXZhdGlvbldlaWdodHM6byxsZWFreXJlbHVBbHBoYTptfSk7ZWxzZSBpZihnLnN0cmlkZVdpZHRoPD0yJiZmPT09XCJjaGFubmVsc0xhc3RcIiYmRygpLmdldEJvb2woXCJXRUJHTF9FWFBfQ09OVlwiKSl7bGV0IF89aD9DYyhoLCEwKTpudWxsLEY9bmV3IEhBKGcseCxfLHYsSSksRD1bW2cucGFkSW5mby50b3AsZy5wYWRJbmZvLmxlZnRdLFtnLnN0cmlkZUhlaWdodCxnLnN0cmlkZVdpZHRoXSxbZy5kaWxhdGlvbkhlaWdodCxnLmRpbGF0aW9uV2lkdGhdLFtnLmluSGVpZ2h0LGcuaW5XaWR0aF1dLCQ9TigpO2I9bi5ydW5XZWJHTFByb2dyYW0oRiwkLFwiZmxvYXQzMlwiLEQpfWVsc2UgaWYoRygpLmdldEJvb2woXCJXRUJHTF9DT05WX0lNMkNPTFwiKSliPXFBKHt4OnIsZmlsdGVyOnMsY29udkluZm86ZyxiYWNrZW5kOm4sYmlhczppLGFjdGl2YXRpb246aCxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOm8sbGVha3lyZWx1QWxwaGE6bX0pO2Vsc2V7bGV0IF89aD9DYyhoLCExKTpudWxsLEY9bmV3IEdBKGcseCxfLHYsSSksRD1OKCk7Yj1uLnJ1bldlYkdMUHJvZ3JhbShGLEQsXCJmbG9hdDMyXCIpfWxldCBDPWNlKHtpbnB1dHM6e3g6Yn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpnLm91dFNoYXBlfX0pO3JldHVybiB5LnB1c2goYikseS5mb3JFYWNoKF89Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oXykpLEN9dmFyIHRyZT17a2VybmVsTmFtZTpvaSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzplcmV9O2Z1bmN0aW9uIG5yZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10LHtzdHJpZGVzOmwscGFkOnUsZGlsYXRpb25zOnAsZGltUm91bmRpbmdNb2RlOmQsYWN0aXZhdGlvbjpjLGxlYWt5cmVsdUFscGhhOmh9PWEsbT1bXSxmPXA7Zj09bnVsbCYmKGY9WzEsMV0pLHcuYXNzZXJ0KFQuZWl0aGVyU3RyaWRlc09yRGlsYXRpb25zQXJlT25lKGwsZiksKCk9PmBFcnJvciBpbiBkZXB0aHdpc2VDb252MmQ6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzICR7bH0gYW5kIGRpbGF0aW9ucyAnJHtmfSdgKTtsZXQgZz1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscy5zaGFwZSxsLGYsdSxkLCEwKSxiPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIpJiZnLnN0cmlkZVdpZHRoPD0yJiZnLm91dENoYW5uZWxzL2cuaW5DaGFubmVscz09PTEseT1jP0NjKGMsYik6bnVsbCx4PVtyLHNdLHY9aSE9bnVsbCxJPW8hPW51bGwsTj1jPT09XCJsZWFreXJlbHVcIjtpZih2JiZ4LnB1c2goaSksSSYmeC5wdXNoKG8pLE4pe2xldCBEPW4ubWFrZVRlbnNvckluZm8oW10sXCJmbG9hdDMyXCIsdy5jcmVhdGVTY2FsYXJWYWx1ZShoLFwiZmxvYXQzMlwiKSk7eC5wdXNoKEQpLG0ucHVzaChEKX1sZXQgQztiP0M9bmV3IFlBKGcsdix5LEksTik6Qz1uZXcgWEEoZyx2LHksSSxOKTtsZXQgXz1bW2cucGFkSW5mby50b3AsZy5wYWRJbmZvLmxlZnRdLFtnLnN0cmlkZUhlaWdodCxnLnN0cmlkZVdpZHRoXSxbZy5kaWxhdGlvbkhlaWdodCxnLmRpbGF0aW9uV2lkdGhdLFtnLmluSGVpZ2h0LGcuaW5XaWR0aF1dLEY9bi5ydW5XZWJHTFByb2dyYW0oQyx4LFwiZmxvYXQzMlwiLF8pO3JldHVybiBtLmZvckVhY2goRD0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhEKSksRn12YXIgYXJlPXtrZXJuZWxOYW1lOmxpLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOm5yZX0scnJlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEpe3RoaXMuc2xpY2VEaW09ZSx0aGlzLnN0cmlkZXM9dCx0aGlzLnBhcmFtc1NoYXBlPWEsdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImluZGljZXNcIl0sdGhpcy5vdXRwdXRTaGFwZT1uO2xldCByPWh0KG4ubGVuZ3RoKSxzPWBcbiAgICBpbnQgaW5kZXg7YDtmb3IobGV0IGk9MDtpPHRoaXMuc2xpY2VEaW07aSsrKXMrPWBcbiAgICAgICAgICBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzWzBdLCAke2l9KSk7XG4gICAgICAgICAgb3V0X29mX2JvdW5kcyA9IG91dF9vZl9ib3VuZHMgfHwgaW5kZXggPCAwO1xuICAgICAgICAgIG91dF9vZl9ib3VuZHMgPSBvdXRfb2ZfYm91bmRzIHx8IGluZGV4ID49ICR7dGhpcy5wYXJhbXNTaGFwZVtpXX07XG4gICAgICAgICAgZmxhdHRlbkluZGV4ICs9IGluZGV4ICogJHt0aGlzLnN0cmlkZXNbaV19O2A7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtyfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpbnQgZmxhdHRlbkluZGV4ID0gMDtcbiAgICAgICAgICBib29sIG91dF9vZl9ib3VuZHMgPSBmYWxzZTtcblxuICAgICAgICAgICR7c31cblxuICAgICAgICAgIHNldE91dHB1dChvdXRfb2ZfYm91bmRzID8gMC4wIDogZ2V0WChmbGF0dGVuSW5kZXgsIGNvb3Jkc1sxXSkpO1xuICAgICAgICB9XG4gICAgICBgfX07ZnVuY3Rpb24gc3JlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3BhcmFtczphLGluZGljZXM6cn09dCxzPXIuc2hhcGUsaT1zW3MubGVuZ3RoLTFdLG89dy5zaXplRnJvbVNoYXBlKGEuc2hhcGUpLFtsLHUscCxkXT1ULnByZXBhcmVBbmRWYWxpZGF0ZShhLHIpLGM9Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOlt1LGldfX0pLGg9Y2Uoe2lucHV0czp7eDphfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOlt3LnNpemVGcm9tU2hhcGUoYS5zaGFwZSkvcCxwXX19KTtpZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbYSxyXSl8fGEuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgYj1uLnJlYWRTeW5jKHIuZGF0YUlkKSx5PW4uYnVmZmVyU3luYyhhKSx4PW9RKGIseSxhLmR0eXBlLHUsaSxwLGQsYS5zaGFwZSxvKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhsLGEuZHR5cGUseC52YWx1ZXMpfWxldCBtPW5ldyBycmUoaSxkLFt1LHBdLGEuc2hhcGUpLGY9bi5ydW5XZWJHTFByb2dyYW0obSxbaCxjXSxoLmR0eXBlKSxnPWNlKHtpbnB1dHM6e3g6Zn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpsfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGMpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxnfXZhciBpcmU9e2tlcm5lbE5hbWU6Z3UsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6c3JlfSxvcmU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5yYW5rPXQubGVuZ3RoO2xldCBuPWh0KHRoaXMucmFuayksYT1scmUoZSwyKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtufSByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgaW5kZXggPSBpbnQoZ2V0SW5kaWNlcyhyZXNSQy54LCByZXNSQy56KSk7XG4gICAgICAgIGZsb2F0IGluQm91bmRzID0gKGluZGV4ID49IDApICYmIChpbmRleCA8ICR7ZVsyXX0pID8gMS4wIDogMC4wO1xuICAgICAgICBzZXRPdXRwdXQoaW5Cb3VuZHMgKiBnZXRBKCR7YX0pKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24gbHJlKGUsdCl7bGV0IG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiXSxhPVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXI9PT0yP2EucHVzaChcImluZGV4XCIpOmEucHVzaChgJHtuW3JdfWApO3JldHVybiBhLmpvaW4oKX1mdW5jdGlvbiBRQShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixpbmRpY2VzOnN9PXQse2F4aXM6aSxiYXRjaERpbXM6b309YSxsPXcucGFyc2VBeGlzUGFyYW0oaSxyLnNoYXBlKVswXTtpZihHKCkuZ2V0KFwiREVCVUdcIikpe2xldCB5PW4ucmVhZFN5bmMocy5kYXRhSWQpLHg9ci5zaGFwZVtsXTtmb3IobGV0IHY9MDt2PHkubGVuZ3RoOysrdil7bGV0IEk9eVt2XTt3LmFzc2VydChJPD14LTEmJkk+PTAsKCk9PmBHYXRoZXJWMjogdGhlIGluZGV4IHZhbHVlICR7SX0gaXMgbm90IGluIFswLCAke3gtMX1dYCl9fWxldCB1PVQuc2VnbWVudF91dGlsLmNvbGxlY3RHYXRoZXJPcFNoYXBlSW5mbyhyLHMsbCxvKSxwPXcuc2l6ZUZyb21TaGFwZShzLnNoYXBlKSxkPVtdLGM9Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOlt1LmJhdGNoU2l6ZSx1Lm91dGVyU2l6ZSx1LmRpbVNpemUsdS5zbGljZVNpemVdfX0pLGg9Y2Uoe2lucHV0czp7eDpzfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOlt1LmJhdGNoU2l6ZSxwL3UuYmF0Y2hTaXplXX19KTtkLnB1c2goYyksZC5wdXNoKGgpO2xldCBtPVt1LmJhdGNoU2l6ZSx1Lm91dGVyU2l6ZSxwL3UuYmF0Y2hTaXplLHUuc2xpY2VTaXplXTtpZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbcixzXSl8fHIuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgeT1uLmJ1ZmZlclN5bmMoaCkseD1uLmJ1ZmZlclN5bmMoYyksdj1sUSh4LHksbSk7cmV0dXJuIGQuZm9yRWFjaChJPT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEkpKSxuLm1ha2VUZW5zb3JJbmZvKHUub3V0cHV0U2hhcGUsdi5kdHlwZSx2LnZhbHVlcyl9bGV0IGY9bmV3IG9yZShjLnNoYXBlLG0pLGc9bi5ydW5XZWJHTFByb2dyYW0oZixbYyxoXSxjLmR0eXBlKTtkLnB1c2goZyk7bGV0IGI9Y2Uoe2lucHV0czp7eDpnfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnUub3V0cHV0U2hhcGV9fSk7cmV0dXJuIGQuZm9yRWFjaCh5PT5uLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHkpKSxifXZhciB1cmU9e2tlcm5lbE5hbWU6ZnUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6UUF9LHByZT1cInJldHVybiBmbG9hdChhID4gYik7XCIsY3JlPWBcbiAgcmV0dXJuIHZlYzQoZ3JlYXRlclRoYW4oYSwgYikpO1xuYCxkcmU9aG4oe29wU25pcHBldDpwcmUscGFja2VkT3BTbmlwcGV0OmNyZSxjcHVLZXJuZWxJbXBsOnVRLGR0eXBlOlwiYm9vbFwifSksaHJlPXtrZXJuZWxOYW1lOmJ1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmRyZX0sbXJlPVwicmV0dXJuIGZsb2F0KGEgPj0gYik7XCIsZnJlPWBcbiAgcmV0dXJuIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCBiKSk7XG5gLGdyZT1obih7b3BTbmlwcGV0Om1yZSxwYWNrZWRPcFNuaXBwZXQ6ZnJlLGR0eXBlOlwiYm9vbFwiLGNwdUtlcm5lbEltcGw6cFF9KSxicmU9e2tlcm5lbE5hbWU6UWksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Z3JlfTtmdW5jdGlvbiB5cmUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7aW5wdXQ6YX09dDtyZXR1cm4gSkEoYSwhMCxuKX12YXIgeHJlPXtrZXJuZWxOYW1lOkVtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnlyZX0sdnJlPVwicmV0dXJuIGZsb2F0KCFpc25hbih4KSAmJiAhaXNpbmYoeCkpO1wiLHdyZT1aZSh7b3BTbmlwcGV0OnZyZSxkdHlwZTpcImJvb2xcIn0pLGtyZT17a2VybmVsTmFtZTp0byxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp3cmV9LElyZT1cInJldHVybiBmbG9hdChpc2luZih4KSk7XCIsU3JlPVplKHtvcFNuaXBwZXQ6SXJlLGR0eXBlOlwiYm9vbFwifSksTnJlPXtrZXJuZWxOYW1lOm5vLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlNyZX0sVHJlPVwicmV0dXJuIGZsb2F0KGlzbmFuKHgpKTtcIixDcmU9WmUoe29wU25pcHBldDpUcmUsZHR5cGU6XCJib29sXCJ9KSxFcmU9e2tlcm5lbE5hbWU6YW8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Q3JlfSxfcmU9XCJyZXR1cm4gZmxvYXQoYSA8IGIpO1wiLEFyZT1gXG4gIHJldHVybiB2ZWM0KGxlc3NUaGFuKGEsIGIpKTtcbmAsRnJlPWhuKHtvcFNuaXBwZXQ6X3JlLHBhY2tlZE9wU25pcHBldDpBcmUsY3B1S2VybmVsSW1wbDpjUSxkdHlwZTpcImJvb2xcIn0pLCRyZT17a2VybmVsTmFtZTp5dSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpGcmV9LERyZT1cInJldHVybiBmbG9hdChhIDw9IGIpO1wiLFJyZT1gXG4gIHJldHVybiB2ZWM0KGxlc3NUaGFuRXF1YWwoYSwgYikpO1xuYCxNcmU9aG4oe29wU25pcHBldDpEcmUscGFja2VkT3BTbmlwcGV0OlJyZSxjcHVLZXJuZWxJbXBsOmRRLGR0eXBlOlwiYm9vbFwifSksT3JlPXtrZXJuZWxOYW1lOnh1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOk1yZX07ZnVuY3Rpb24gUHJlKGUpe2xldHtiYWNrZW5kOnQsYXR0cnM6bn09ZSx7c3RhcnQ6YSxzdG9wOnIsbnVtOnN9PW4saT1oUShhLHIscyk7cmV0dXJuIHQubWFrZVRlbnNvckluZm8oW2kubGVuZ3RoXSxcImZsb2F0MzJcIixpKX12YXIgTHJlPXtrZXJuZWxOYW1lOnZ1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlByZX0senJlPW1wK2BcbiAgcmV0dXJuIHggPCAwLjAgPyAwLi8wLiA6IGxvZyh4KTtcbmAsV3JlPWBcbiAgdmVjNCByZXN1bHQgPSBsb2coeCk7XG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6ICh4LnIgPCAwLjAgPyAwLi8wLiA6IHJlc3VsdC5yKTtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogKHguZyA8IDAuMCA/IDAuLzAuIDogcmVzdWx0LmcpO1xuICByZXN1bHQuYiA9IGlzTmFOLmIgPyB4LmIgOiAoeC5iIDwgMC4wID8gMC4vMC4gOiByZXN1bHQuYik7XG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6ICh4LmEgPCAwLjAgPyAwLi8wLiA6IHJlc3VsdC5hKTtcbiAgcmV0dXJuIHJlc3VsdDtcbmAsQnJlPVplKHtvcFNuaXBwZXQ6enJlLHBhY2tlZE9wU25pcHBldDpXcmUsY3B1S2VybmVsSW1wbDptUX0pLFZyZT17a2VybmVsTmFtZTpzbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpCcmV9LFVyZT1tcCtgXG4gIHJldHVybiBsb2coMS4wICsgeCk7XG5gLEdyZT1aZSh7b3BTbmlwcGV0OlVyZX0pLEhyZT17a2VybmVsTmFtZTppbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpHcmV9LGpyZT1cInJldHVybiBmbG9hdChhID49IDEuMCAmJiBiID49IDEuMCk7XCIscXJlPWBcbiAgcmV0dXJuIHZlYzQoXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICpcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgxLjApKSkpO1xuYCxLcmU9aG4oe29wU25pcHBldDpqcmUscGFja2VkT3BTbmlwcGV0OnFyZSxkdHlwZTpcImJvb2xcIn0pLFhyZT17a2VybmVsTmFtZTp3dSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpLcmV9LFlyZT1cInJldHVybiBmbG9hdCghKHggPj0gMS4wKSk7XCIsWnJlPVplKHtvcFNuaXBwZXQ6WXJlfSksSnJlPXtrZXJuZWxOYW1lOmt1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlpyZX0sUXJlPVwicmV0dXJuIGZsb2F0KGEgPj0gMS4wIHx8IGIgPj0gMS4wKTtcIixlc2U9YFxuICByZXR1cm4gbWluKFxuICAgIHZlYzQoZ3JlYXRlclRoYW5FcXVhbChhLCB2ZWM0KDEuMCkpKSArXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpLFxuICAgIHZlYzQoMS4wKSk7XG5gLHRzZT1obih7b3BTbmlwcGV0OlFyZSxwYWNrZWRPcFNuaXBwZXQ6ZXNlLGR0eXBlOlwiYm9vbFwifSksbnNlPXtrZXJuZWxOYW1lOkl1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnRzZX0sYXNlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTtsZXQgcz10LGk9ZVszXS0xO3RoaXMub3V0cHV0U2hhcGU9ZTtsZXQgbyxsPWBmbG9hdCgke259KSArIGZsb2F0KCR7YX0pICogc3VtYDtyPT09LjU/bz1gaW52ZXJzZXNxcnQoJHtsfSlgOnI9PT0xP289YDEuMC8oJHtsfSlgOm89YGV4cChsb2coJHtsfSkgKiBmbG9hdCgtJHtyfSkpO2AsdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IHIgPSBjb29yZHNbMV07XG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcbiAgICAgICAgZmxvYXQgeCA9IGdldFgoYiwgciwgYywgZCk7XG4gICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgaiA9IC0ke3N9OyBqIDw9ICR7c307IGorKykge1xuICAgICAgICAgIGludCBpZHggPSBkICsgajtcbiAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDw9ICAke2l9KSB7XG4gICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCByLCBjLCBpZHgpO1xuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbG9hdCB2YWwgPSB4ICogJHtvfTtcbiAgICAgICAgc2V0T3V0cHV0KHZhbCk7XG4gICAgICB9XG4gICAgYH19LHJzZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7bGV0IHM9dCxpPWVbM10tMTt0aGlzLm91dHB1dFNoYXBlPWU7bGV0IG8sbD1gZmxvYXQoJHtufSkgKyBmbG9hdCgke2F9KSAqIHN1bWA7cj09PS41P289YGludmVyc2VzcXJ0KCR7bH0pYDpyPT09MT9vPWAxLjAvKCR7bH0pYDpvPWBleHAobG9nKCR7bH0pICogZmxvYXQoLSR7cn0pKTtgLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHIgPSBjb29yZHMueTtcbiAgICAgICAgaW50IGMgPSBjb29yZHMuejtcbiAgICAgICAgaW50IGQgPSBjb29yZHMudztcblxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgJHt0aGlzLm91dHB1dFNoYXBlWzNdfTtcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gYyA8ICR7dGhpcy5vdXRwdXRTaGFwZVsyXX07XG5cbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuKTtcbiAgICAgICAgdmVjNCB4RnJhZ0F0T3V0cHV0Q29vcmRzID0gZ2V0WChiLCByLCBjLCBkKTtcblxuICAgICAgICB2ZWM0IHhBdE91dHB1dENvb3JkcyA9IHZlYzQoXG4gICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzLCB2ZWMyKGMsIGQpKSxcbiAgICAgICAgICBoYXNOZXh0Q29sID9cbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkICsgMSkpIDogMC4wLFxuICAgICAgICAgIGhhc05leHRSb3cgP1xuICAgICAgICAgICAgZ2V0Q2hhbm5lbCh4RnJhZ0F0T3V0cHV0Q29vcmRzICwgdmVjMihjICsgMSwgZCkpIDogMC4wLFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjICsgMSwgZCArIDEpKSA6IDAuMFxuICAgICAgICApO1xuXG4gICAgICAgIGludCBmaXJzdENoYW5uZWwgPSBkIC0gJHtzfTtcbiAgICAgICAgdmVjMiBjYWNoZSA9IHZlYzIoMC4pO1xuICAgICAgICBpZihmaXJzdENoYW5uZWwgPj0gMCl7XG4gICAgICAgICAgdmVjNCBmaXJzdENoYW5uZWxGcmFnID0gZ2V0WChiLCByLCBjLCBmaXJzdENoYW5uZWwpO1xuICAgICAgICAgIGNhY2hlLnggPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYywgZmlyc3RDaGFubmVsKSk7XG4gICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcbiAgICAgICAgICAgICAgY2FjaGUueSA9IGdldENoYW5uZWwoZmlyc3RDaGFubmVsRnJhZywgdmVjMihjICsgMSwgZmlyc3RDaGFubmVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpdmVjMiBkZXB0aCA9IGl2ZWMyKGQsIGQgKyAxKTtcbiAgICAgICAgZm9yIChpbnQgaiA9IC0gJHtzfTsgaiA8PSAke3N9OyBqKyspIHtcbiAgICAgICAgICBpdmVjMiBpZHggPSBkZXB0aCArIGo7XG4gICAgICAgICAgYnZlYzIgYWJvdmVMb3dlckJvdW5kID0gZ3JlYXRlclRoYW5FcXVhbChpZHgsIGl2ZWMyKDApKTtcbiAgICAgICAgICBidmVjMiBiZWxvd1VwcGVyQm91bmQgPSBsZXNzVGhhbkVxdWFsKGlkeCwgaXZlYzIoJHtpfSkpO1xuXG4gICAgICAgICAgYm9vbCBkZXB0aEluUmFuZ2UgPSBhYm92ZUxvd2VyQm91bmQueCAmJiBiZWxvd1VwcGVyQm91bmQueDtcbiAgICAgICAgICBib29sIGRlcHRoUGx1c09uZUluUmFuZ2UgPSBhYm92ZUxvd2VyQm91bmQueSAmJiBiZWxvd1VwcGVyQm91bmQueTtcblxuICAgICAgICAgIGlmKGRlcHRoSW5SYW5nZSB8fCBkZXB0aFBsdXNPbmVJblJhbmdlKXtcbiAgICAgICAgICAgIHZlYzQgeiA9IHZlYzQoMC4pO1xuICAgICAgICAgICAgdmVjNCB4RnJhZ0F0Q3VycmVudERlcHRoO1xuICAgICAgICAgICAgei54eiA9IGNhY2hlLnh5O1xuICAgICAgICAgICAgaWYoZGVwdGhQbHVzT25lSW5SYW5nZSAmJiBoYXNOZXh0Q29sKXtcbiAgICAgICAgICAgICAgeEZyYWdBdEN1cnJlbnREZXB0aCA9IGlkeC55ICE9IGQgP1xuICAgICAgICAgICAgICAgIGdldFgoYiwgciwgYywgaWR4LnkpIDogeEZyYWdBdE91dHB1dENvb3JkcztcbiAgICAgICAgICAgICAgei55ID0gZ2V0Q2hhbm5lbCh4RnJhZ0F0Q3VycmVudERlcHRoLCB2ZWMyKGMsIGlkeC55KSk7XG4gICAgICAgICAgICAgIGlmKGhhc05leHRSb3cpe1xuICAgICAgICAgICAgICAgIHoudyA9IGdldENoYW5uZWwoeEZyYWdBdEN1cnJlbnREZXB0aCwgdmVjMihjICsgMSwgaWR4LnkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FjaGUueHkgPSB6Lnl3O1xuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHhBdE91dHB1dENvb3JkcyAqICR7b307XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fSxzc2U9ZT0+e2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtkZXB0aFJhZGl1czpzLGJpYXM6aSxhbHBoYTpvLGJldGE6bH09YSx1PUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19OT1JNQUxJWkFUSU9OXCIpP25ldyByc2Uoci5zaGFwZSxzLGksbyxsKTpuZXcgYXNlKHIuc2hhcGUscyxpLG8sbCk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKHUsW3JdLHIuZHR5cGUpfSxpc2U9e2tlcm5lbE5hbWU6b28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6c3NlfSxvc2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiaW5wdXRJbWFnZVwiLFwib3V0cHV0SW1hZ2VcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMuZGVwdGg9ZVszXSx0aGlzLmRlcHRoUmFkaXVzPXQsdGhpcy5iaWFzPW4sdGhpcy5hbHBoYT1hLHRoaXMuYmV0YT1yLHRoaXMudXNlckNvZGU9YFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcblxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XG4gICAgICAgIGZvciAoaW50IGQgPSAwOyBkIDwgJHt0aGlzLmRlcHRofTsgKytkKSB7XG4gICAgICAgICAgaW50IGRlcHRoQmVnaW4gPSBpbnQobWF4KDAuMCwgZmxvYXQoZCAtICR7dH0pKSk7XG4gICAgICAgICAgaW50IGRlcHRoRW5kID0gaW50KG1pbihmbG9hdCgke3RoaXMuZGVwdGh9KSxcbiAgICAgICAgICAgICAgZmxvYXQoZCArICR7dH0gKyAxKSkpO1xuXG4gICAgICAgICAgY29uc3QgaW50IE1JTl9ERVBUSF9CRUdJTiA9IDA7XG4gICAgICAgICAgY29uc3QgaW50IE1BWF9ERVBUSF9FTkQgPSAke3RoaXMuZGVwdGh9O1xuXG4gICAgICAgICAgZmxvYXQgbm9ybSA9IDAuMDtcbiAgICAgICAgICBmb3IgKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKSB7XG4gICAgICAgICAgICBpZiAoayA8IGRlcHRoQmVnaW4pe1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPj0gZGVwdGhCZWdpbiAmJiBrIDwgZGVwdGhFbmQpIHtcbiAgICAgICAgICAgICAgbm9ybSArPSBnZXRJbnB1dEltYWdlKGIsIHIsIGMsIGspICogZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub3JtID0gZmxvYXQoJHthfSkgKiBub3JtICsgZmxvYXQoJHtufSk7XG5cbiAgICAgICAgICBmb3IoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spe1xuICAgICAgICAgICAgaWYgKGsgPCBkZXB0aEJlZ2luKXtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrID49IGRlcHRoQmVnaW4gJiYgayA8IGRlcHRoRW5kKXtcbiAgICAgICAgICAgICAgZmxvYXQgZHlpID0gLTIuMCAqIGZsb2F0KCR7YX0pXG4gICAgICAgICAgICAgICAgKiBmbG9hdCgke3J9KVxuICAgICAgICAgICAgICAgICogZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKSAqIGdldE91dHB1dEltYWdlKGIsIHIsIGMsIGQpXG4gICAgICAgICAgICAgICAgLyBub3JtO1xuICAgICAgICAgICAgICBpZiAoayA9PSBkKSB7XG4gICAgICAgICAgICAgICAgZHlpICs9IHBvdyhub3JtLCAtMS4wICogJHtyfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGsgPT0gY29vcmRzWzNdKSB7XG4gICAgICAgICAgICAgICAgZHlpICo9IGdldER5KGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBkeWk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgfX0sbHNlPWU9PntsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cix5OnMsZHk6aX09dCx7ZGVwdGhSYWRpdXM6byxiaWFzOmwsYWxwaGE6dSxiZXRhOnB9PWEsZD1uZXcgb3NlKHIuc2hhcGUsbyxsLHUscCk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGQsW3IscyxpXSxyLmR0eXBlKX0sdXNlPXtrZXJuZWxOYW1lOlN1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmxzZX07ZnVuY3Rpb24gcHNlKGUsdCxuLGEpe2xldCByPXcuc2l6ZUZyb21TaGFwZSh0KSxzPXcuc2l6ZUZyb21TaGFwZShlLnNoYXBlKS9yLGk9Y2Uoe2lucHV0czp7eDplfSxhdHRyczp7c2hhcGU6W3Mscl19LGJhY2tlbmQ6YX0pLG89ZWwoaSxlLmR0eXBlLFwibWF4XCIsYSksbD1jZSh7aW5wdXRzOnt4Om99LGF0dHJzOntzaGFwZTpufSxiYWNrZW5kOmF9KTtyZXR1cm4gYS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxhLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLGx9ZnVuY3Rpb24gZUYoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse3JlZHVjdGlvbkluZGljZXM6cyxrZWVwRGltczppfT1hLG89ci5zaGFwZS5sZW5ndGgsbD13LnBhcnNlQXhpc1BhcmFtKHMsci5zaGFwZSksdT1sLHA9VC5nZXRBeGVzUGVybXV0YXRpb24odSxvKSxkPXAhPW51bGwsYz1uLnNob3VsZEV4ZWN1dGVPbkNQVShbcl0pLGg9cjtpZihkKXtpZihjKXtsZXQgeT1uLnRleERhdGEuZ2V0KGguZGF0YUlkKS52YWx1ZXMseD1uZXcgQXJyYXkobyk7Zm9yKGxldCBOPTA7Tjx4Lmxlbmd0aDtOKyspeFtOXT1yLnNoYXBlW3BbTl1dO2xldCB2PW9rKHksci5zaGFwZSxyLmR0eXBlLHAseCk7aD1uLm1ha2VUZW5zb3JJbmZvKHgsci5kdHlwZSk7bGV0IEk9bi50ZXhEYXRhLmdldChoLmRhdGFJZCk7SS52YWx1ZXM9dn1lbHNlIGg9QmYocixwLG4pO3U9VC5nZXRJbm5lck1vc3RBeGVzKHUubGVuZ3RoLG8pfVQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJtYXhcIix1LG8pO2xldFttLGZdPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhoLnNoYXBlLHUpLGc9bTtpJiYoZz1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKG0sbCkpO2xldCBiO2lmKGMpe2xldCB5PW4udGV4RGF0YS5nZXQoaC5kYXRhSWQpLnZhbHVlcyx4PWZRKHksdy5zaXplRnJvbVNoYXBlKGYpLGcsci5kdHlwZSk7Yj1uLm1ha2VUZW5zb3JJbmZvKGcsci5kdHlwZSk7bGV0IHY9bi50ZXhEYXRhLmdldChiLmRhdGFJZCk7di52YWx1ZXM9eH1lbHNlIGI9cHNlKGgsZixnLG4pO3JldHVybiBkJiZuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLGJ9dmFyIGNzZT17a2VybmVsTmFtZTpsbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzplRn0sZHNlPXVrK2BcbiAgcmV0dXJuIG1heChhLCBiKTtcbmAsaHNlPWBcbiAgdmVjNCByZXN1bHQgPSB2ZWM0KG1heChhLCBiKSk7XG4gIGJ2ZWM0IGlzTmFOQSA9IGlzbmFuKGEpO1xuICBidmVjNCBpc05hTkIgPSBpc25hbihiKTtcbiAgYnZlYzQgaXNOYU4gPSBidmVjNChpc05hTkEueCB8fCBpc05hTkIueCwgaXNOYU5BLnkgfHwgaXNOYU5CLnksIGlzTmFOQS56IHx8IGlzTmFOQi56LCBpc05hTkEudyB8fCBpc05hTkIudyk7XG4gIGArUW8rYFxuICByZXR1cm4gcmVzdWx0O1xuYCxtc2U9aG4oe29wU25pcHBldDpkc2UscGFja2VkT3BTbmlwcGV0OmhzZSxjcHVLZXJuZWxJbXBsOmdRfSksZnNlPXtrZXJuZWxOYW1lOnVvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOm1zZX07ZnVuY3Rpb24gZ3NlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10O2xwKHIsXCJtYXhQb29sXCIpO2xldHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGRpbVJvdW5kaW5nTW9kZTpsfT1hLHU9MTt3LmFzc2VydChULmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShpLHUpLCgpPT5gRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtpfSBhbmQgZGlsYXRpb25zICcke3V9J2ApO2xldCBwPVQuY29tcHV0ZVBvb2wyREluZm8oci5zaGFwZSxzLGksdSxvLGwpO2lmKHAuZmlsdGVyV2lkdGg9PT0xJiZwLmZpbHRlckhlaWdodD09PTEmJncuYXJyYXlzRXF1YWwocC5pblNoYXBlLHAub3V0U2hhcGUpKXJldHVybiB0YSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO2xldCBkPW5ldyBFYyhwLFwibWF4XCIsITEpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShkLFtyXSxyLmR0eXBlKX12YXIgYnNlPXtrZXJuZWxOYW1lOnBvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmdzZX07ZnVuY3Rpb24geXNlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGRhdGFGb3JtYXQ6bCxkaW1Sb3VuZGluZ01vZGU6dX09YSxwPVsxLDEsMV0sZD1ULmNvbXB1dGVQb29sM0RJbmZvKHIuc2hhcGUscyxpLHAsbyx1LGwpLGM9bmV3IGNrKGQsXCJtYXhcIiwhMSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGMsW3JdLHIuZHR5cGUpfXZhciB4c2U9e2tlcm5lbE5hbWU6TnUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6eXNlfSx2c2U9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJtYXhQb3NcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLmluU2hhcGU7bGV0IHQ9ZS5zdHJpZGVIZWlnaHQsbj1lLnN0cmlkZVdpZHRoLGE9ZS5kaWxhdGlvbkhlaWdodCxyPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHM9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxpPXItMS1lLnBhZEluZm8udG9wLG89cy0xLWUucGFkSW5mby5sZWZ0LGw9cipzLTE7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtpfSwgJHtvfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcblxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcblxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7cn07XG4gICAgICAgICAgd1IgKz0gJHthfSkge1xuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7dH0uMDtcblxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtzfTsgd0MrKykge1xuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gJHtufS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2Uub3V0V2lkdGh9LjAgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xuICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gJHtsfSAtIGludChnZXRNYXhQb3MoYiwgaWR5UiwgaWR5QywgZCkpO1xuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXG4gICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPSB3UiAqICR7c30gKyB3QztcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XG5cbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgfX0sd3NlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9ZS5pblNoYXBlO2xldCB0PWUuc3RyaWRlRGVwdGgsbj1lLnN0cmlkZUhlaWdodCxhPWUuc3RyaWRlV2lkdGgscj1lLmRpbGF0aW9uRGVwdGgscz1lLmRpbGF0aW9uSGVpZ2h0LGk9ZS5kaWxhdGlvbldpZHRoLG89ZS5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxsPWUuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9ZS5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwPW8tMS1lLnBhZEluZm8uZnJvbnQsZD1sLTEtZS5wYWRJbmZvLnRvcCxjPXUtMS1lLnBhZEluZm8ubGVmdCxoPW8qbCp1LTE7dGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoJHtwfSwgJHtkfSwgJHtjfSk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgY2ggPSBjb29yZHMudTtcblxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcbiAgICAgICAgaW50IGR5RENvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcblxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCA/LCBjaCkgd2l0aCBwb3MgbWFzayg6LCA6LCA6LCBkKSB0byBnZXRcbiAgICAgICAgLy8gZHgoeEQsIHhSLCB4QywgY2gpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3RCA9IDA7IHdEIDwgJHtvfTtcbiAgICAgICAgICAgd0QgKz0gJHtyfSkge1xuICAgICAgICAgIGZsb2F0IGR5RCA9IGZsb2F0KGR5RENvcm5lciArIHdEKSAvICR7dH0uMDtcblxuICAgICAgICAgIGlmIChkeUQgPCAwLjAgfHwgZHlEID49ICR7ZS5vdXREZXB0aH0uMCB8fCBmcmFjdChkeUQpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeUQgPSBpbnQoZHlEKTtcblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2x9O1xuICAgICAgICAgICAgICB3UiArPSAke3N9KSB7XG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyAke259LjA7XG5cbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZS5vdXRIZWlnaHR9LjAgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7dX07XG4gICAgICAgICAgICAgICAgd0MgKz0gJHtpfSkge1xuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyAke2F9LjA7XG5cbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtlLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKTtcbiAgICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gJHtofSAtXG4gICAgICAgICAgICAgICAgICBpbnQoZ2V0TWF4UG9zKGJhdGNoLCBpZHlELCBpZHlSLCBpZHlDLCBjaCkpO1xuXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcbiAgICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxuICAgICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgd0QgKiAke2x9ICogJHt1fSArXG4gICAgICAgICAgICAgICAgICB3UiAqICR7dX0gKyB3QztcbiAgICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcblxuICAgICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIGtzZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCxpPXMse2ZpbHRlclNpemU6byxzdHJpZGVzOmwscGFkOnUsZGltUm91bmRpbmdNb2RlOnB9PWEsZD1bMSwxLDFdLGM9VC5jb21wdXRlUG9vbDNESW5mbyhpLnNoYXBlLG8sbCxkLHUscCksaD1uZXcgY2soYyxcIm1heFwiLCEwKSxtPW4ucnVuV2ViR0xQcm9ncmFtKGgsW2ldLGkuZHR5cGUpLGY9bmV3IHdzZShjKSxnPW4ucnVuV2ViR0xQcm9ncmFtKGYsW3IsbV0saS5kdHlwZSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSksZ312YXIgSXNlPXtrZXJuZWxOYW1lOkJjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmtzZX07ZnVuY3Rpb24gU3NlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixpbnB1dDpzLG91dHB1dDppfT10LG89cztscChbcyxpXSxcIm1heFBvb2xHcmFkXCIpO2xldHtmaWx0ZXJTaXplOmwsc3RyaWRlczp1LHBhZDpwLGRpbVJvdW5kaW5nTW9kZTpkfT1hLGM9VC5jb21wdXRlUG9vbDJESW5mbyhvLnNoYXBlLGwsdSwxLHAsZCksaD0hMCxtPW5ldyBFYyhjLFwibWF4XCIsaCksZj1uLnJ1bldlYkdMUHJvZ3JhbShtLFtvXSxvLmR0eXBlKSxnPW5ldyB2c2UoYyksYj1uLnJ1bldlYkdMUHJvZ3JhbShnLFtyLGZdLG8uZHR5cGUpO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLGJ9dmFyIE5zZT17a2VybmVsTmFtZTpXYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpTc2V9O2Z1bmN0aW9uIFRzZShlLHQsbixhKXtsZXQgcj1uZXcgRWMobixcIm1heFwiLCExKSxzPWEucnVuV2ViR0xQcm9ncmFtKHIsW2VdLFwiZmxvYXQzMlwiKTtyPW5ldyBFYyhuLFwibWF4XCIsITAsITAsdCk7bGV0IGk9YS5ydW5XZWJHTFByb2dyYW0ocixbZV0sXCJmbG9hdDMyXCIpO3JldHVybltzLGldfXZhciBDc2U9e2tlcm5lbE5hbWU6VmMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6KHtpbnB1dHM6ZSxhdHRyczp0LGJhY2tlbmQ6bn0pPT57bGV0e3g6YX09ZSx7ZmlsdGVyU2l6ZTpyLHN0cmlkZXM6cyxwYWQ6aSxpbmNsdWRlQmF0Y2hJbkluZGV4Om99PXQsbD1uO3cuYXNzZXJ0KGEuc2hhcGUubGVuZ3RoPT09NCwoKT0+YEVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayAke2Euc2hhcGUubGVuZ3RofS5gKTtsZXQgdT1bMSwxXTt3LmFzc2VydChULmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzLHUpLCgpPT5gRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtzfSBhbmQgZGlsYXRpb25zICcke3V9J2ApO2xldCBwPVQuY29tcHV0ZVBvb2wyREluZm8oYS5zaGFwZSxyLHMsdSxpKSxbZCxjXT1Uc2UoYSxvLHAsbCk7cmV0dXJuW2QsY119fTtmdW5jdGlvbiBFc2UoZSx0LG4sYSl7bGV0IHI9dy5zaXplRnJvbVNoYXBlKHQpLHM9dy5zaXplRnJvbVNoYXBlKGUuc2hhcGUpL3IsaT1jZSh7aW5wdXRzOnt4OmV9LGF0dHJzOntzaGFwZTpbcyxyXX0sYmFja2VuZDphfSksbz1lbChpLFwiZmxvYXQzMlwiLFwibWVhblwiLGEpLGw9Y2Uoe2lucHV0czp7eDpvfSxhdHRyczp7c2hhcGU6bn0sYmFja2VuZDphfSk7cmV0dXJuIGEuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oaSksYS5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhvKSxsfXZhciBfc2U9e2tlcm5lbE5hbWU6Y28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6KHtpbnB1dHM6ZSxhdHRyczp0LGJhY2tlbmQ6bn0pPT57bGV0e3g6YX09ZSx7a2VlcERpbXM6cixheGlzOnN9PXQsaT1uLG89YS5zaGFwZS5sZW5ndGgsbD13LnBhcnNlQXhpc1BhcmFtKHMsYS5zaGFwZSksdT1sLHA9VC5nZXRBeGVzUGVybXV0YXRpb24odSxvKSxkPXAhPW51bGwsYz1pLnNob3VsZEV4ZWN1dGVPbkNQVShbYV0pLGg9W10sbT1hO2lmKGQpe2lmKGMpe2xldCB4PWkudGV4RGF0YS5nZXQobS5kYXRhSWQpLnZhbHVlcyx2PW5ldyBBcnJheShvKTtmb3IobGV0IEM9MDtDPHYubGVuZ3RoO0MrKyl2W0NdPWEuc2hhcGVbcFtDXV07bGV0IEk9b2soeCxhLnNoYXBlLGEuZHR5cGUscCx2KTttPWkubWFrZVRlbnNvckluZm8odixhLmR0eXBlKTtsZXQgTj1pLnRleERhdGEuZ2V0KG0uZGF0YUlkKTtOLnZhbHVlcz1JfWVsc2UgbT1CZihhLHAsaSk7aC5wdXNoKG0pLHU9VC5nZXRJbm5lck1vc3RBeGVzKHUubGVuZ3RoLG8pfVQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJzdW1cIix1LG8pO2xldFtmLGddPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhtLnNoYXBlLHUpLGI9ZjtyJiYoYj1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGYsbCkpO2xldCB5PUVzZShtLGcsYixpKTtmb3IobGV0IHggb2YgaClpLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHgpO3JldHVybiB5fX07ZnVuY3Rpb24gQXNlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YSxvPXIuc2hhcGUubGVuZ3RoLGw9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpLHU9bCxwPVQuZ2V0QXhlc1Blcm11dGF0aW9uKHUsbyksZD1yO3AhPW51bGwmJihkPVNuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOnB9fSksdT1ULmdldElubmVyTW9zdEF4ZXModS5sZW5ndGgsci5zaGFwZS5sZW5ndGgpKSxULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWluXCIsdSxvKTtsZXRbYyxoXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoZC5zaGFwZSx1KSxtPXcuc2l6ZUZyb21TaGFwZShoKSxmPWNlKHtpbnB1dHM6e3g6ZH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbLTEsbV19fSksZz1lbChmLGYuZHR5cGUsXCJtaW5cIixuKSxiO2lmKGkpe2xldCB5PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oYyxsKTtiPWNlKHtpbnB1dHM6e3g6Z30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp5fX0pfWVsc2UgYj1jZSh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Y319KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGcpLHAhPW51bGwmJm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksYn12YXIgRnNlPXtrZXJuZWxOYW1lOmhvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkFzZX0sJHNlPXVrK2BcbiAgcmV0dXJuIG1pbihhLCBiKTtcbmAsRHNlPWBcbiAgdmVjNCByZXN1bHQgPSB2ZWM0KG1pbihhLCBiKSk7XG4gIGJ2ZWM0IGlzTmFOQSA9IGlzbmFuKGEpO1xuICBidmVjNCBpc05hTkIgPSBpc25hbihiKTtcbiAgYnZlYzQgaXNOYU4gPSBidmVjNChpc05hTkEueCB8fCBpc05hTkIueCwgaXNOYU5BLnkgfHwgaXNOYU5CLnksIGlzTmFOQS56IHx8IGlzTmFOQi56LCBpc05hTkEudyB8fCBpc05hTkIudyk7XG4gIGArUW8rYFxuICByZXR1cm4gcmVzdWx0O1xuYCxSc2U9aG4oe29wU25pcHBldDokc2UscGFja2VkT3BTbmlwcGV0OkRzZSxjcHVLZXJuZWxJbXBsOmJRfSksTXNlPXtrZXJuZWxOYW1lOm1vLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlJzZX0sT3NlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPXQubWFwKCh1LHApPT51WzBdK2VbcF0rdVsxXSk7bGV0IGE9ZS5sZW5ndGgscj1odChhKSxzPXQubWFwKHU9PnVbMF0pLmpvaW4oXCIsXCIpLGk9dC5tYXAoKHUscCk9PnVbMF0rZVtwXSkuam9pbihcIixcIiksbz1bXCJjb29yZHNbMF1cIixcImNvb3Jkc1sxXVwiLFwiY29vcmRzWzJdXCIsXCJjb29yZHNbM11cIl0uc2xpY2UoMCxhKSxsPW49PT1cInJlZmxlY3RcIj8wOjE7aWYoYT09PTEpe3RoaXMudXNlckNvZGU9YFxuICAgICAgICBpbnQgc3RhcnQgPSAke3N9O1xuICAgICAgICBpbnQgZW5kID0gJHtpfTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgaW50IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0KSB7XG4gICAgICAgICAgICBvdXRDID0gc3RhcnQgKiAyIC0gb3V0QyAtICR7bH07XG4gICAgICAgICAgfSBlbHNlIGlmKG91dEMgPj0gZW5kKSB7XG4gICAgICAgICAgICBvdXRDID0gKGVuZCAtIDEpICogMiAtIG91dEMgKyAke2x9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChvdXRDIC0gc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm59dGhpcy51c2VyQ29kZT1gXG4gICAgICAke3J9IHN0YXJ0ID0gJHtyfSgke3N9KTtcbiAgICAgICR7cn0gZW5kID0gJHtyfSgke2l9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke3J9IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2F9OyBpKyspIHtcbiAgICAgICAgICBpZiAob3V0Q1tpXSA8IHN0YXJ0W2ldKSB7XG4gICAgICAgICAgICBvdXRDW2ldID0gc3RhcnRbaV0gKiAyIC0gb3V0Q1tpXSAtICR7bH07XG4gICAgICAgICAgfSBlbHNlIGlmKG91dENbaV0gPj0gZW5kW2ldKSB7XG4gICAgICAgICAgICBvdXRDW2ldID0gKGVuZFtpXSAtIDEpICogMiAtIG91dENbaV0gKyAke2x9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke3J9IGNvb3JkcyA9IG91dEMgLSBzdGFydDtcbiAgICAgICAgc2V0T3V0cHV0KGdldFgoJHtvfSkpO1xuICAgICAgfVxuICAgIGB9fSxQc2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dC5tYXAoKGgsbSk9PmhbMF0rZVttXStoWzFdKTtsZXQgYT1lLmxlbmd0aCxyPWh0KGEpLHM9dC5tYXAoaD0+aFswXSkuam9pbihcIixcIiksaT10Lm1hcCgoaCxtKT0+aFswXStlW21dKS5qb2luKFwiLFwiKSxvPUluKFwicmNcIixhKSxsPUluKFwic291cmNlXCIsYSksdT1gJHtvW2EtMV19IDwgJHt0aGlzLm91dHB1dFNoYXBlW2EtMV19YCxwPWE9PT0xP1wic291cmNlXCI6YHZlYzIoJHtsLnNsaWNlKC0yKS5qb2luKCl9KWAsZD1uPT09XCJyZWZsZWN0XCI/MDoxLGM9XCJcIjtpZihhPT09MSl7bGV0IGg9YFxuICAgICAgICAke3J9IHNvdXJjZSA9IHJjO1xuICAgICAgICBpZiAoc291cmNlIDwgc3RhcnQpIHtcbiAgICAgICAgICBzb3VyY2UgPSBzdGFydCAqIDIgLSBzb3VyY2UgLSAke2R9O1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSA+PSBlbmQpIHtcbiAgICAgICAgICBzb3VyY2UgPSAoZW5kIC0gMSkgKiAyIC0gc291cmNlICsgJHtkfTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgLT0gc3RhcnQ7XG4gICAgICBgO2M9YFxuICAgICAgICAke3J9IHJjID0gb3V0cHV0TG9jO1xuICAgICAgICAke2h9XG4gICAgICAgIHJlc3VsdFswXSA9IGdldENoYW5uZWwoZ2V0WCgke2wuam9pbigpfSksICR7cH0pO1xuICAgICAgICAke29bYS0xXX0gKz0gMTtcbiAgICAgICAgaWYoJHt1fSkge1xuICAgICAgICAgICR7aH1cbiAgICAgICAgICByZXN1bHRbMV0gPSBnZXRDaGFubmVsKGdldFgoJHtsLmpvaW4oKX0pLCAke3B9KTtcbiAgICAgICAgfVxuICAgICAgYH1lbHNle2xldCBoPWBcbiAgICAgICAgJHtyfSBzb3VyY2UgPSByYztcbiAgICAgICAgJHtyfSBsdCA9ICR7cn0obGVzc1RoYW4oc291cmNlLCBzdGFydCkpO1xuICAgICAgICAke3J9IGd0ZSA9ICR7cn0oZ3JlYXRlclRoYW5FcXVhbChzb3VyY2UsIGVuZCkpO1xuICAgICAgICAke3J9IG9yaWcgPSAxIC0gKGx0ICsgZ3RlKTtcbiAgICAgICAgc291cmNlID0gb3JpZyAqIHNvdXJjZSArXG4gICAgICAgICAgICAgICAgbHQgKiAoc3RhcnQgKiAyIC0gc291cmNlIC0gJHtkfSkgK1xuICAgICAgICAgICAgICAgIGd0ZSAqICgoZW5kIC0gMSkgKiAyIC0gc291cmNlICsgJHtkfSk7XG4gICAgICAgIHNvdXJjZSAtPSBzdGFydDtcbiAgICAgIGA7Yz1gXG4gICAgICAgICR7cn0gcmMgPSBvdXRwdXRMb2M7XG4gICAgICAgICR7aH1cbiAgICAgICAgcmVzdWx0WzBdID0gZ2V0Q2hhbm5lbChnZXRYKCR7bC5qb2luKCl9KSwgJHtwfSk7XG4gICAgICAgICR7b1thLTFdfSArPSAxO1xuICAgICAgICBpZigke3V9KSB7XG4gICAgICAgICAgJHtofVxuICAgICAgICAgIHJlc3VsdFsxXSA9IGdldENoYW5uZWwoZ2V0WCgke2wuam9pbigpfSksICR7cH0pO1xuICAgICAgICB9XG4gICAgICAgIHJjID0gb3V0cHV0TG9jO1xuICAgICAgICAke29bYS0yXX0gKz0gMTtcbiAgICAgICAgaWYoJHtvW2EtMl19IDwgJHt0aGlzLm91dHB1dFNoYXBlW2EtMl19KSB7XG4gICAgICAgICAgJHtofVxuICAgICAgICAgIHJlc3VsdFsyXSA9IGdldENoYW5uZWwoZ2V0WCgke2wuam9pbigpfSksICR7cH0pO1xuICAgICAgICAgICR7b1thLTFdfSArPSAxO1xuICAgICAgICAgIGlmKCR7dX0pIHtcbiAgICAgICAgICAgICR7aH1cbiAgICAgICAgICAgIHJlc3VsdFszXSA9IGdldENoYW5uZWwoZ2V0WCgke2wuam9pbigpfSksICR7cH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYH10aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0ICR7cn0gc3RhcnQgPSAke3J9KCR7c30pO1xuICAgICAgY29uc3QgJHtyfSBlbmQgPSAke3J9KCR7aX0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7cn0gb3V0cHV0TG9jID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICAgICR7Y31cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYH19LExzZT0oe2lucHV0czplLGJhY2tlbmQ6dCxhdHRyczpufSk9PntsZXR7eDphfT1lLHtwYWRkaW5nczpyLG1vZGU6c309bixpPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBQc2UoYS5zaGFwZSxyLHMpOm5ldyBPc2UoYS5zaGFwZSxyLHMpO3JldHVybiB0LnJ1bldlYkdMUHJvZ3JhbShpLFthXSxhLmR0eXBlKX0senNlPXtrZXJuZWxOYW1lOmZvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkxzZX0sV3NlPWBpZiAoYiA9PSAwLjApIHJldHVybiBOQU47XG4gIHJldHVybiBtb2QoYSwgYik7YCxCc2U9YFxuICB2ZWM0IHJlc3VsdCA9IG1vZChhLCBiKTtcbiAgYnZlYzQgaXNOYU4gPSBlcXVhbChiLCB2ZWM0KDAuMCkpO1xuICBgK1FvK2BcbiAgcmV0dXJuIHJlc3VsdDtcbmAsVnNlPWhuKHtvcFNuaXBwZXQ6V3NlLHBhY2tlZE9wU25pcHBldDpCc2V9KSxVc2U9e2tlcm5lbE5hbWU6Z28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6VnNlfSxHc2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJwcm9ic1wiXSx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInNlZWRcIix0eXBlOlwiZmxvYXRcIn1dLHRoaXMub3V0cHV0U2hhcGU9W2Usbl0sdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG5cbiAgICAgICAgZmxvYXQgciA9IHJhbmRvbShzZWVkKTtcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHt0LTF9OyBpKyspIHtcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xuXG4gICAgICAgICAgaWYgKHIgPCBjZGYpIHtcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgZXZlbnQgaGFwcGVuZWQsIGxhc3QgZXZlbnQgaGFwcGVuZWQuXG4gICAgICAgIHNldE91dHB1dChmbG9hdCgke3QtMX0pKTtcbiAgICAgIH1cbiAgICBgfX0sSHNlPWBcbmlmIChhID09IGIpIHtcbiAgcmV0dXJuIDEuMDtcbn07XG5yZXR1cm4gYSAvIGI7YCxqc2U9YFxuICAvLyB2ZWM0IG9uZSA9IHZlYzQoZXF1YWwoYSwgYikpO1xuICAvLyByZXR1cm4gb25lICsgKHZlYzQoMS4wKSAtIG9uZSkgKiBhIC8gYjtcbiAgdmVjNCByZXN1bHQgPSBhIC8gYjtcbiAgaWYoYS54ID09IGIueCkge1xuICAgIHJlc3VsdC54ID0gMS47XG4gIH1cbiAgaWYoYS55ID09IGIueSkge1xuICAgIHJlc3VsdC55ID0gMS47XG4gIH1cbiAgaWYoYS56ID09IGIueikge1xuICAgIHJlc3VsdC56ID0gMS47XG4gIH1cbiAgaWYoYS53ID09IGIudykge1xuICAgIHJlc3VsdC53ID0gMS47XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xuYCx0Rj1obih7b3BTbmlwcGV0OkhzZSxwYWNrZWRPcFNuaXBwZXQ6anNlLGNoZWNrT3V0T2ZCb3VuZHM6ITB9KSxxc2U9e2tlcm5lbE5hbWU6SGksYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6dEZ9LGtTPVwicmV0dXJuIGEgLSBiO1wiLG5GPWhuKHtvcFNuaXBwZXQ6a1MscGFja2VkT3BTbmlwcGV0OmtTLHN1cHBvcnRzQ29tcGxleDohMCxjcHVLZXJuZWxJbXBsOkxRfSksS3NlPXtrZXJuZWxOYW1lOkJvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOm5GfTtmdW5jdGlvbiBhRihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2xvZ2l0czpyfT10LHtkaW06c309YSxpPXcucGFyc2VBeGlzUGFyYW0oW3NdLHIuc2hhcGUpLG89ZUYoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3JlZHVjdGlvbkluZGljZXM6aSxrZWVwRGltczohMX19KSxsPVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oby5zaGFwZSxpKSx1PWNlKHtpbnB1dHM6e3g6b30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpsfX0pLHA9bkYoe2lucHV0czp7YTpyLGI6dX0sYmFja2VuZDpufSksZD1aQSh7aW5wdXRzOnt4OnB9LGJhY2tlbmQ6bn0pLGM9VmYoe2lucHV0czp7eDpkfSxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6aSxrZWVwRGltczohMX19KSxoPWNlKHtpbnB1dHM6e3g6Y30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpsfX0pLG09dEYoe2lucHV0czp7YTpkLGI6aH0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh1KSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHApLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGgpLG19dmFyIFhzZT17a2VybmVsTmFtZTp6byxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzphRn07ZnVuY3Rpb24gWXNlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7bG9naXRzOnJ9PXQse251bVNhbXBsZXM6cyxzZWVkOmksbm9ybWFsaXplZDpvfT1hLGw9bz9yOmFGKHtpbnB1dHM6e2xvZ2l0czpyfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTpyLnNoYXBlLmxlbmd0aC0xfX0pLHU9bC5zaGFwZVswXSxwPWwuc2hhcGVbMV0sZD1uZXcgR3NlKHUscCxzKSxjPVtbaV1dLGg9bi5ydW5XZWJHTFByb2dyYW0oZCxbbF0sXCJpbnQzMlwiLGMpO3JldHVybiBvfHxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGwpLGh9dmFyIFpzZT17a2VybmVsTmFtZTpUdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpZc2V9LEpzZT1EYStgXG4gIHJldHVybiAteDtcbmAsUXNlPWBcbiAgdmVjNCByZXN1bHQgPSAteDtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcblxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcblxuICByZXR1cm4gcmVzdWx0O1xuYDtmdW5jdGlvbiBlaWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphfT10O2lmKG4uc2hvdWxkRXhlY3V0ZU9uQ1BVKFthXSkpe2xldCBzPW4udGV4RGF0YS5nZXQoYS5kYXRhSWQpLFtpLG9dPXhRKHMudmFsdWVzLGEuc2hhcGUsYS5kdHlwZSk7cmV0dXJuIG4ubWFrZVRlbnNvckluZm8obyxhLmR0eXBlLGkpfWxldCByO3JldHVybiBHKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKT9yPW5ldyB0cyhhLnNoYXBlLFFzZSk6cj1uZXcgcnIoYS5zaGFwZSxKc2UpLG4ucnVuV2ViR0xQcm9ncmFtKHIsW2FdLGEuZHR5cGUpfXZhciB0aWU9e2tlcm5lbE5hbWU6Q3UsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZWllfSxuaWU9bXIubm9uTWF4U3VwcHJlc3Npb25WM0ltcGw7ZnVuY3Rpb24gYWllKGUpe1Qud2FybihcInRmLm5vbk1heFN1cHByZXNzaW9uKCkgaW4gd2ViZ2wgbG9ja3MgdGhlIFVJIHRocmVhZC4gQ2FsbCB0Zi5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKCkgaW5zdGVhZFwiKTtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2JveGVzOnIsc2NvcmVzOnN9PXQse21heE91dHB1dFNpemU6aSxpb3VUaHJlc2hvbGQ6byxzY29yZVRocmVzaG9sZDpsfT1hLHU9bi5yZWFkU3luYyhyLmRhdGFJZCkscD1uLnJlYWRTeW5jKHMuZGF0YUlkKSx7c2VsZWN0ZWRJbmRpY2VzOmR9PW5pZSh1LHAsaSxvLGwpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKFtkLmxlbmd0aF0sXCJpbnQzMlwiLG5ldyBJbnQzMkFycmF5KGQpKX12YXIgcmllPXtrZXJuZWxOYW1lOl91LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmFpZX0sc2llPW1yLm5vbk1heFN1cHByZXNzaW9uVjRJbXBsO2Z1bmN0aW9uIGlpZShlKXtULndhcm4oXCJ0Zi5ub25NYXhTdXBwcmVzc2lvbigpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYubm9uTWF4U3VwcHJlc3Npb25Bc3luYygpIGluc3RlYWRcIik7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtib3hlczpyLHNjb3JlczpzfT10LHttYXhPdXRwdXRTaXplOmksaW91VGhyZXNob2xkOm8sc2NvcmVUaHJlc2hvbGQ6bCxwYWRUb01heE91dHB1dFNpemU6dX09YSxwPW4ucmVhZFN5bmMoci5kYXRhSWQpLGQ9bi5yZWFkU3luYyhzLmRhdGFJZCkse3NlbGVjdGVkSW5kaWNlczpjLHZhbGlkT3V0cHV0czpofT1zaWUocCxkLGksbyxsLHUpO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKFtjLmxlbmd0aF0sXCJpbnQzMlwiLG5ldyBJbnQzMkFycmF5KGMpKSxuLm1ha2VUZW5zb3JJbmZvKFtdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShbaF0pKV19dmFyIG9pZT17a2VybmVsTmFtZTpBdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzppaWV9LGxpZT1tci5ub25NYXhTdXBwcmVzc2lvblY1SW1wbDtmdW5jdGlvbiB1aWUoZSl7VC53YXJuKFwidGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkXCIpO2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7Ym94ZXM6cixzY29yZXM6c309dCx7bWF4T3V0cHV0U2l6ZTppLGlvdVRocmVzaG9sZDpvLHNjb3JlVGhyZXNob2xkOmwsc29mdE5tc1NpZ21hOnV9PWEscD1uLnJlYWRTeW5jKHIuZGF0YUlkKSxkPW4ucmVhZFN5bmMocy5kYXRhSWQpLGM9aSxoPW8sbT1sLGY9dSx7c2VsZWN0ZWRJbmRpY2VzOmcsc2VsZWN0ZWRTY29yZXM6Yn09bGllKHAsZCxjLGgsbSxmKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhbZy5sZW5ndGhdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShnKSksbi5tYWtlVGVuc29ySW5mbyhbYi5sZW5ndGhdLFwiZmxvYXQzMlwiLG5ldyBGbG9hdDMyQXJyYXkoYikpXX12YXIgcGllPXtrZXJuZWxOYW1lOkZ1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnVpZX0sY2llPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9W2UsdF0sdGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkcy54KSk7XG4gICAgICAgIHNldE91dHB1dChtaXgoZmxvYXQoJHthfSksIGZsb2F0KCR7bn0pLFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xuICAgICAgfVxuICAgIGB9fSxkaWU9ZT0+e2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW5kaWNlczpyfT10LHtkdHlwZTpzLGRlcHRoOmksb25WYWx1ZTpvLG9mZlZhbHVlOmx9PWEsdT13LnNpemVGcm9tU2hhcGUoci5zaGFwZSkscD1uZXcgY2llKHUsaSxvLGwpLGQ9Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOlt1XX19KSxjPW4ucnVuV2ViR0xQcm9ncmFtKHAsW2RdLHMpO24uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZCk7bGV0IGg9Wy4uLnIuc2hhcGUsaV0sbT1jZSh7aW5wdXRzOnt4OmN9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6aH19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhjKSxtfSxoaWU9e2tlcm5lbE5hbWU6eW8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6ZGllfTtmdW5jdGlvbiBmbShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQ7aWYoYS5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCByPUZkKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLHM9Zm0oe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KSxpPVVmKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLG89Zm0oe2lucHV0czp7eDppfSxiYWNrZW5kOm59KSxsPSRzKHtpbnB1dHM6e3JlYWw6cyxpbWFnOm99LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLGx9ZWxzZSByZXR1cm4gJGQoe2F0dHJzOntzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGUsdmFsdWU6YS5kdHlwZT09PVwic3RyaW5nXCI/XCJcIjowfSxiYWNrZW5kOm59KX12YXIgbWllPXtrZXJuZWxOYW1lOll1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZtfTtmdW5jdGlvbiByRihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHt4OmF9PXQ7aWYoYS5kdHlwZT09PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwib25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCB1bmRlciBzdHJpbmcgZHR5cGVcIik7aWYoYS5kdHlwZT09PVwiY29tcGxleDY0XCIpe2xldCByPUZkKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLHM9ckYoe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KSxpPVVmKHtpbnB1dHM6e2lucHV0OmF9LGJhY2tlbmQ6bn0pLG89Zm0oe2lucHV0czp7eDppfSxiYWNrZW5kOm59KSxsPSRzKHtpbnB1dHM6e3JlYWw6cyxpbWFnOm99LGJhY2tlbmQ6bn0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKHIpLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8ocyksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhpKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG8pLGx9ZWxzZSByZXR1cm4gJGQoe2F0dHJzOntzaGFwZTphLnNoYXBlLGR0eXBlOmEuZHR5cGUsdmFsdWU6MX0sYmFja2VuZDpufSl9dmFyIGZpZT17a2VybmVsTmFtZTokdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpyRn07ZnVuY3Rpb24gZ2llKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7YXhpczpyfT1hO2lmKHQubGVuZ3RoPT09MSlyZXR1cm4gZ3Yoe2lucHV0czp7aW5wdXQ6dFswXX0sYmFja2VuZDpuLGF0dHJzOntkaW06cn19KTtsZXQgcz10WzBdLnNoYXBlLGk9dFswXS5kdHlwZTt0LmZvckVhY2gocD0+e3cuYXNzZXJ0U2hhcGVzTWF0Y2gocyxwLnNoYXBlLFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBzaGFwZXNcIiksdy5hc3NlcnQoaT09PXAuZHR5cGUsKCk9PlwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBkdHlwZXNcIil9KTtsZXQgbz1bXSxsPXQubWFwKHA9PntsZXQgZD1ndih7aW5wdXRzOntpbnB1dDpwfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTpyfX0pO3JldHVybiBvLnB1c2goZCksZH0pLHU9VUEoe2lucHV0czpsLGJhY2tlbmQ6bixhdHRyczp7YXhpczpyfX0pO3JldHVybiBvLmZvckVhY2gocD0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhwKSksdX12YXIgYmllPXtrZXJuZWxOYW1lOkR1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmdpZX0seWllPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInZhbHVlXCIsdHlwZTpcImZsb2F0XCJ9XSx0aGlzLm91dHB1dFNoYXBlPXQubWFwKChsLHUpPT5sWzBdK2VbdV0rbFsxXSk7bGV0IGE9ZS5sZW5ndGgscj1odChhKSxzPXQubWFwKGw9PmxbMF0pLmpvaW4oXCIsXCIpLGk9dC5tYXAoKGwsdSk9PmxbMF0rZVt1XSkuam9pbihcIixcIiksbz1bXCJjb29yZHNbMF1cIixcImNvb3Jkc1sxXVwiLFwiY29vcmRzWzJdXCIsXCJjb29yZHNbM11cIl0uc2xpY2UoMCxhKTtpZihhPT09MSl7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgIGludCBzdGFydCA9ICR7c307XG4gICAgICAgIGludCBlbmQgPSAke2l9O1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICBpbnQgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIGlmIChvdXRDIDwgc3RhcnQgfHwgb3V0QyA+PSBlbmQpIHtcbiAgICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldE91dHB1dChnZXRYKG91dEMgLSBzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm59dGhpcy51c2VyQ29kZT1gXG4gICAgICAke3J9IHN0YXJ0ID0gJHtyfSgke3N9KTtcbiAgICAgICR7cn0gZW5kID0gJHtyfSgke2l9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke3J9IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAke3J9IGNvb3JkcyA9IG91dEMgLSBzdGFydDtcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WCgke299KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgfX0seGllPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInZhbHVlXCIsdHlwZTpcImZsb2F0XCJ9XSx0aGlzLm91dHB1dFNoYXBlPXQubWFwKChtLGYpPT5tWzBdK2VbZl0rbVsxXSk7bGV0IGE9ZS5sZW5ndGgscj1odChhKSxzPXQubWFwKG09Pm1bMF0pLmpvaW4oXCIsXCIpLGk9dC5tYXAoKG0sZik9Pm1bMF0rZVtmXSkuam9pbihcIixcIiksbz1JbihcInJjXCIsYSksbD1JbihcInNvdXJjZVwiLGEpLHU9YCR7b1thLTFdfSA8ICR7dGhpcy5vdXRwdXRTaGFwZVthLTFdfWAscD1hPT09MT9cInNvdXJjZVwiOmB2ZWMyKCR7bC5zbGljZSgtMikuam9pbigpfSlgLGQ9W2Ake3J9IHJjID0gb3V0cHV0TG9jO2AsYCR7b1thLTFdfSArPSAxO1xuICAgICAgIGlmKCR7dX0pIHtcbiAgICAgIGAsYT09PTE/XCJcIjpgfVxuICAgICAgIHJjID0gb3V0cHV0TG9jO1xuICAgICAgICR7b1thLTJdfSArPSAxO1xuICAgICAgIGlmKCR7b1thLTJdfSA8ICR7dGhpcy5vdXRwdXRTaGFwZVthLTJdfSkge2AsYT09PTE/XCJcIjpgICAke29bYS0xXX0gKz0gMTtcbiAgICAgICAgIGlmKCR7dX0pIHtgXSxjPWE9PT0xP1wicmMgPCBzdGFydCB8fCByYyA+PSBlbmRcIjpcImFueShsZXNzVGhhbihyYywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChyYywgZW5kKSlcIixoPVwiXCI7Zm9yKGxldCBtPTAsZj1hPT09MT8yOjQ7bTxmO20rKyloKz1gXG4gICAgICAgICR7ZFttXX1cbiAgICAgICAgaWYgKCR7Y30pIHtcbiAgICAgICAgICByZXN1bHRbJHttfV0gPSBmbG9hdCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHtyfSBzb3VyY2UgPSByYyAtIHN0YXJ0O1xuICAgICAgICAgIHJlc3VsdFske219XSA9IGdldENoYW5uZWwoZ2V0WCgke2wuam9pbigpfSksICR7cH0pO1xuICAgICAgICB9XG4gICAgICBgO2grPWE9PT0xP1wifSBcIjpcIn19XCIsdGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCAke3J9IHN0YXJ0ID0gJHtyfSgke3N9KTtcbiAgICAgIGNvbnN0ICR7cn0gZW5kID0gJHtyfSgke2l9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke3J9IG91dHB1dExvYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuICAgICAgICAke2h9XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGB9fSxzRj1lPT57bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse3BhZGRpbmdzOnMsY29uc3RhbnRWYWx1ZTppfT1hO2lmKHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKT09PTApe2xldCB1PXMubWFwKChwLGQpPT5wWzBdK3Iuc2hhcGVbZF0rcFsxXSk7cmV0dXJuICRkKHtiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnUsdmFsdWU6aSxkdHlwZTpyLmR0eXBlfX0pfWxldCBvPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyB4aWUoci5zaGFwZSxzLGkpOm5ldyB5aWUoci5zaGFwZSxzLGkpLGw9W1tpXV07cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKG8sW3JdLHIuZHR5cGUsbCl9LHZpZT17a2VybmVsTmFtZTp4byxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpzRn0sd2llPWBcbiAgaWYoYSA8IDAuMCAmJiBmbG9vcihiKSA8IGIpe1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGIgPT0gMC4wKSB7XG4gICAgcmV0dXJuIDEuMDtcbiAgfVxuICByZXR1cm4gKHJvdW5kKG1vZChiLCAyLjApKSAhPSAxKSA/XG4gICAgICBwb3coYWJzKGEpLCBiKSA6IHNpZ24oYSkgKiBwb3coYWJzKGEpLCBiKTtcbmAsa2llPWBcbiAgLy8gaXNNb2RSb3VuZDEgaGFzIDEgZm9yIGNvbXBvbmVudHMgd2l0aCByb3VuZChtb2QoYiwgMi4wKSkgPT0gMSwgMCBvdGhlcndpc2UuXG4gIHZlYzQgaXNNb2RSb3VuZDEgPSB2ZWM0KGVxdWFsKHJvdW5kKG1vZChiLCAyLjApKSwgaXZlYzQoMSkpKTtcbiAgdmVjNCBtdWx0aXBsaWVyID0gc2lnbihhKSAqIGlzTW9kUm91bmQxICsgKHZlYzQoMS4wKSAtIGlzTW9kUm91bmQxKTtcbiAgdmVjNCByZXN1bHQgPSBtdWx0aXBsaWVyICogcG93KGFicyhhKSwgYik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgYV4wID0gMSwgaW5jbHVkaW5nIDBeMCA9IDEgYXMgdGhpcyBjb3JyZXNwb25kIHRvIFRGIGFuZCBKU1xuICBidmVjNCBpc0V4cFplcm8gPSBlcXVhbChiLCB2ZWM0KDAuMCkpO1xuICByZXN1bHQuciA9IGlzRXhwWmVyby5yID8gMS4wIDogcmVzdWx0LnI7XG4gIHJlc3VsdC5nID0gaXNFeHBaZXJvLmcgPyAxLjAgOiByZXN1bHQuZztcbiAgcmVzdWx0LmIgPSBpc0V4cFplcm8uYiA/IDEuMCA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzRXhwWmVyby5hID8gMS4wIDogcmVzdWx0LmE7XG5cbiAgYnZlYzQgaXNOYU4xID0gbGVzc1RoYW4oYSwgdmVjNCgwLjApKTtcbiAgYnZlYzQgaXNOYU4yID0gbGVzc1RoYW4oZmxvb3IoYiksIGIpO1xuICBidmVjNCBpc05hTiA9IGJ2ZWM0KGlzTmFOMS54ICYmIGlzTmFOMi54LCBpc05hTjEueSAmJiBpc05hTjIueSwgaXNOYU4xLnogJiYgaXNOYU4yLnosIGlzTmFOMS53ICYmIGlzTmFOMi53KTtcbiAgYCtRbytgXG4gIHJldHVybiByZXN1bHQ7XG5gLElpZT1obih7b3BTbmlwcGV0OndpZSxwYWNrZWRPcFNuaXBwZXQ6a2llfSksU2llPXtrZXJuZWxOYW1lOnZvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOklpZX07ZnVuY3Rpb24gTmllKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtheGlzOnMsa2VlcERpbXM6aX09YSxvPXIuc2hhcGUubGVuZ3RoLGw9W10sdT13LnBhcnNlQXhpc1BhcmFtKHMsci5zaGFwZSkscD11LGQ9VC5nZXRBeGVzUGVybXV0YXRpb24ocCxvKSxjPXI7ZCE9bnVsbCYmKGM9U24oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06ZH19KSxwPVQuZ2V0SW5uZXJNb3N0QXhlcyhwLmxlbmd0aCxvKSxsLnB1c2goYykpLFQuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJwcm9kXCIscCxvKTtsZXQgaDtpZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbY10pKXtsZXQgbT1uLnRleERhdGEuZ2V0KGMuZGF0YUlkKS52YWx1ZXMse291dFZhbHM6ZixvdXRTaGFwZTpnLG91dER0eXBlOmJ9PXdRKGMuc2hhcGUsYy5kdHlwZSxtLHApO2g9bi5tYWtlVGVuc29ySW5mbyhnLGIsZil9ZWxzZXtsZXRbbSxmXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYy5zaGFwZSxwKSxnPXcuc2l6ZUZyb21TaGFwZShmKSxiPWNlKHtpbnB1dHM6e3g6Y30sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbLTEsZ119fSkseT1NbShyLmR0eXBlKSx4PWVsKGIseSxcInByb2RcIixuKTtoPWNlKHtpbnB1dHM6e3h9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bX19KSxsLnB1c2goYiksbC5wdXNoKHgpfWlmKGkpe2wucHVzaChoKTtsZXQgbT1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGguc2hhcGUsdSk7aD1jZSh7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bX19KX1yZXR1cm4gbC5mb3JFYWNoKG09Pm4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8obSkpLGh9dmFyIFRpZT17a2VybmVsTmFtZTprbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpOaWV9O2Z1bmN0aW9uIENpZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3BhcmFtc05lc3RlZFNwbGl0czpyLHBhcmFtc0RlbnNlVmFsdWVzOnMsaW5kaWNlczppfT10LHtvdXRwdXRSYWdnZWRSYW5rOm99PWEsbD1yLm1hcChiPT5uLnJlYWRTeW5jKGIuZGF0YUlkKSksdT1yLm1hcChiPT5iLnNoYXBlKSxwPW4ucmVhZFN5bmMocy5kYXRhSWQpLGQ9bi5yZWFkU3luYyhpLmRhdGFJZCksW2MsaCxtXT1rUShsLHUscCxzLnNoYXBlLHMuZHR5cGUsZCxpLnNoYXBlLG8pLGY9Yy5tYXAoYj0+bi5tYWtlVGVuc29ySW5mbyhbYi5sZW5ndGhdLFwiaW50MzJcIixiKSksZz1uLm1ha2VUZW5zb3JJbmZvKG0scy5kdHlwZSxoKTtyZXR1cm4gZi5jb25jYXQoW2ddKX12YXIgRWllPXtrZXJuZWxOYW1lOkFtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkNpZX07ZnVuY3Rpb24gX2llKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3N0YXJ0czphLGxpbWl0czpyLGRlbHRhczpzfT10LGk9bi5yZWFkU3luYyhhLmRhdGFJZCksbz1uLnJlYWRTeW5jKHIuZGF0YUlkKSxsPW4ucmVhZFN5bmMocy5kYXRhSWQpLFt1LHBdPUlRKGksYS5zaGFwZSxhLmR0eXBlLG8sci5zaGFwZSxsLHMuc2hhcGUpLGQ9bi5tYWtlVGVuc29ySW5mbyhbdS5sZW5ndGhdLFwiaW50MzJcIix1KSxjPW4ubWFrZVRlbnNvckluZm8oW3AubGVuZ3RoXSxhLmR0eXBlLHApO3JldHVybltkLGNdfXZhciBBaWU9e2tlcm5lbE5hbWU6Rm0sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6X2llfTtmdW5jdGlvbiBGaWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtzaGFwZTpyLHZhbHVlczpzLGRlZmF1bHRWYWx1ZTppLHJvd1BhcnRpdGlvblRlbnNvcnM6b309dCx7cm93UGFydGl0aW9uVHlwZXM6bH09YSx1PW4ucmVhZFN5bmMoci5kYXRhSWQpLHA9bi5yZWFkU3luYyhzLmRhdGFJZCksZD1uLnJlYWRTeW5jKGkuZGF0YUlkKSxjPW8ubWFwKGc9Pm4ucmVhZFN5bmMoZy5kYXRhSWQpKSxoPW8ubWFwKGc9Pmcuc2hhcGUpLFttLGZdPVNRKHUsci5zaGFwZSxwLHMuc2hhcGUscy5kdHlwZSxkLGkuc2hhcGUsYyxoLGwpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKG0scy5kdHlwZSxmKX12YXIgJGllPXtrZXJuZWxOYW1lOiRtLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkZpZX0saUY9ZT0+e2xldHtiYWNrZW5kOnQsYXR0cnM6bn09ZSx7c3RhcnQ6YSxzdG9wOnIsc3RlcDpzLGR0eXBlOml9PW4sbz1OUShhLHIscyxpKTtyZXR1cm4gdC5tYWtlVGVuc29ySW5mbyhbby5sZW5ndGhdLGksbyl9LERpZT17a2VybmVsTmFtZTpVYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzppRn0sUmllPVwicmV0dXJuIDEuMCAvIHg7XCIsTWllPVplKHtvcFNuaXBwZXQ6UmllfSksT2llPXtrZXJuZWxOYW1lOklvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOk1pZX0sUGllPURhK2BcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XG5gLExpZT1gXG4gIHZlYzQgcmVzdWx0ID0geCAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcblxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcblxuICByZXR1cm4gcmVzdWx0O1xuYCx6aWU9WmUoe29wU25pcHBldDpQaWUscGFja2VkT3BTbmlwcGV0OkxpZX0pLFdpZT17a2VybmVsTmFtZTpTbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp6aWV9LEJpZT1EYStgXG4gIHJldHVybiAoeCA8IDAuMCkgPyAwLjAgOiBtaW4oNi4wLCB4KTtcbmAsVmllPWBcbiAgdmVjNCByZXN1bHQgPSBtaW4oeCwgdmVjNCg2LikpICogdmVjNChncmVhdGVyVGhhbkVxdWFsKHgsIHZlYzQoMC4wKSkpO1xuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xuXG4gIHJlc3VsdC5yID0gaXNOYU4uciA/IHguciA6IHJlc3VsdC5yO1xuICByZXN1bHQuZyA9IGlzTmFOLmcgPyB4LmcgOiByZXN1bHQuZztcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XG4gIHJlc3VsdC5hID0gaXNOYU4uYSA/IHguYSA6IHJlc3VsdC5hO1xuXG4gIHJldHVybiByZXN1bHQ7XG5gLFVpZT1aZSh7b3BTbmlwcGV0OkJpZSxwYWNrZWRPcFNuaXBwZXQ6VmllfSksR2llPXtrZXJuZWxOYW1lOkNvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlVpZX0sSGllPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXTtsZXRbcyxpLG8sbF09ZTt0aGlzLm91dHB1dFNoYXBlPVtzLHQsbixsXTtsZXQgdT1bYSYmdD4xP2ktMTppLGEmJm4+MT9vLTE6b10scD1bYSYmdD4xP3QtMTp0LGEmJm4+MT9uLTE6bl0sZDtyP2Q9XCIodmVjMih5UkMpICsgdmVjMigwLjUpKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgLSB2ZWMyKDAuNSlcIjpkPVwidmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQ1wiLHRoaXMudXNlckNvZGU9YFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcbiAgICAgICAgICAke3VbMF0vcFswXX0sXG4gICAgICAgICAgJHt1WzFdL3BbMV19KTtcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMigke2l9LjAsICR7b30uMCk7XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xuXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gJHtkfTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cbiAgICAgICAgaXZlYzIgc291cmNlRmxvb3JSQyA9IGl2ZWMyKG1heChzb3VyY2VGcmFjSW5kZXhSQywgdmVjMigwLjApKSk7XG4gICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxSQyA9IGl2ZWMyKFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4UkMpKSk7XG5cbiAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEEoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xuICAgICAgICBmbG9hdCBib3R0b21MZWZ0ID0gZ2V0QShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xuICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEEoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKTtcblxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcblxuICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjUkMueTtcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjUkMueDtcblxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIGB9fSxqaWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPVtdO2xldFtzLGksbyxsXT1lO3RoaXMub3V0cHV0U2hhcGU9W3MsdCxuLGxdO2xldCB1PVthJiZ0PjE/aS0xOmksYSYmbj4xP28tMTpvXSxwPVthJiZ0PjE/dC0xOnQsYSYmbj4xP24tMTpuXSxkO3I/ZD1cIih2ZWMzKHlSQykgKyB2ZWMzKDAuNSkpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyAtIHZlYzMoMC41KVwiOmQ9XCJ2ZWMzKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDXCIsdGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCB2ZWMzIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMzKFxuICAgICAgICAgICR7dVswXS9wWzBdfSxcbiAgICAgICAgICAke3VbMV0vcFsxXX0sXG4gICAgICAgICAgJHt1WzFdL3BbMV19KTtcbiAgICAgIGNvbnN0IHZlYzMgaW5wdXRTaGFwZVJDID0gdmVjMygke2l9LjAsICR7b30uMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke299LjApO1xuXG4gICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IGIsIGludCByLCBpbnQgYywgaW50IGQpIHtcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoZ2V0QShiLCByLCBjLCBkKSwgdmVjMihjLCBkKSk7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHZhbHVlcyBmb3IgbmV4dCBjb2x1bW4gaW4geVJDLnouXG4gICAgICAgIGl2ZWMzIHlSQyA9IGNvb3Jkcy55enogKyBpdmVjMygwLCAwLCAxKTtcblxuICAgICAgICAvLyBGcmFjdGlvbmFsIHNvdXJjZSBpbmRleC5cbiAgICAgICAgdmVjMyBzb3VyY2VGcmFjSW5kZXhSQyA9ICR7ZH07XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXG4gICAgICAgIGl2ZWMzIHNvdXJjZUZsb29yUkMgPSBpdmVjMyhtYXgoc291cmNlRnJhY0luZGV4UkMsIHZlYzMoMC4wKSkpO1xuICAgICAgICBpdmVjMyBzb3VyY2VDZWlsUkMgPSBpdmVjMyhcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWNJbmRleFJDKSkpO1xuXG4gICAgICAgIC8vIFNob3VsZCB3ZSBjYWxjdWxhdGUgbmV4dCBjb2x1bW4gYW5kIHJvdyBlbGVtZW50cyBpbiAyeDIgcGFja2VkIGNlbGwuXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IGQgPCAke2wtMX07XG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGNvb3Jkcy56IDwgJHtuLTF9O1xuXG4gICAgICAgIC8vIEluIHBhcmFsbGVsLCBjb25zdHJ1Y3QgZm91ciBjb3JuZXJzIGZvciBhbGwgZm91ciBjb21wb25lbnRzIGluXG4gICAgICAgIC8vIHBhY2tlZCAyeDIgY2VsbC5cbiAgICAgICAgdmVjNCB0b3BMZWZ0ID0gdmVjNChcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpLFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueiwgZClcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueiwgZCArIDEpIDogMC4wKTtcblxuICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy55LCBkKSxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlRmxvb3JSQy56LCBkKVxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnosIGQgKyAxKSA6IDAuMCk7XG5cbiAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpLFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnosIGQpXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueiwgZCArIDEpIDogMC4wKTtcblxuICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy55LCBkKSxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueiwgZClcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnosIGQgKyAxKSA6IDAuMCk7XG5cbiAgICAgICAgdmVjMyBmcmFjUkMgPSBzb3VyY2VGcmFjSW5kZXhSQyAtIHZlYzMoc291cmNlRmxvb3JSQyk7XG5cbiAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGZyYWNSQy55eXp6KTtcbiAgICAgICAgdmVjNCBib3R0b20gPSBtaXgoYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIGZyYWNSQy55eXp6KTtcbiAgICAgICAgdmVjNCBuZXdWYWx1ZSA9IG1peCh0b3AsIGJvdHRvbSwgZnJhY1JDLngpO1xuXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIHFpZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlczpyfT10LHthbGlnbkNvcm5lcnM6cyxoYWxmUGl4ZWxDZW50ZXJzOmksc2l6ZTpvfT1hLFtsLHVdPW8scD1HKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfSU1BR0VfT1BFUkFUSU9OU1wiKT9uZXcgamllKHIuc2hhcGUsbCx1LHMsaSk6bmV3IEhpZShyLnNoYXBlLGwsdSxzLGkpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShwLFtyXSxcImZsb2F0MzJcIil9dmFyIEtpZT17a2VybmVsTmFtZTpUbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpxaWV9LFhpZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10O2xldFssYSxyXT10LFsscyxpXT1lLG89W24mJnM+MT9hLTE6YSxuJiZpPjE/ci0xOnJdLGw9W24mJnM+MT9zLTE6cyxuJiZpPjE/aS0xOmldLHU9b1swXS9sWzBdLHA9b1sxXS9sWzFdLGQ9MS91LGM9MS9wLGg9TWF0aC5jZWlsKGQpKjIrMixtPU1hdGguY2VpbChjKSoyKzI7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcblxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcblxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KCR7dX0pO1xuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoJHtwfSk7XG5cbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdCgke2R9KTtcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KCR7Y30pO1xuXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoJHtofSk7XG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludCgke219KTtcblxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSk7XG5cbiAgICAgICAgZmxvYXQgc3RhcnRDTGVycCA9IGZsb29yKGZsb2F0KGMpICogaW52V2lkdGhTY2FsZSk7XG4gICAgICAgIGludCBzdGFydER5QyA9IGludChzdGFydENMZXJwIC0gZmxvYXQod2luV2lkdGggLyAyKSk7XG5cbiAgICAgICAgLy8gTG9vcCBvdmVyIGR5XG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XG5cbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gJHtzfSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgZHlDT2Zmc2V0ID0gMDsgZHlDT2Zmc2V0IDwgd2luV2lkdGg7IGR5Q09mZnNldCsrKSB7XG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XG5cbiAgICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49ICR7aX0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2F0IGR4UiA9IGZsb2F0KGR5UikgKiBoZWlnaHRTY2FsZTtcbiAgICAgICAgICAgIGludCB0b3BEeFJJbmRleCA9IGludChmbG9vcihkeFIpKTtcbiAgICAgICAgICAgIGludCBib3R0b21EeFJJbmRleCA9IGludChtaW4oY2VpbChkeFIpLCAke2EtMX0uMCkpO1xuICAgICAgICAgICAgZmxvYXQgZHhSTGVycCA9IGR4UiAtIGZsb2F0KHRvcER4UkluZGV4KTtcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeFJMZXJwID0gMS4wIC0gZHhSTGVycDtcblxuICAgICAgICAgICAgZmxvYXQgZHhDID0gZmxvYXQoZHlDKSAqIHdpZHRoU2NhbGU7XG4gICAgICAgICAgICBpbnQgbGVmdER4Q0luZGV4ID0gaW50KGZsb29yKGR4QykpO1xuICAgICAgICAgICAgaW50IHJpZ2h0RHhDSW5kZXggPSBpbnQobWluKGNlaWwoZHhDKSwgJHtyLTF9LjApKTtcbiAgICAgICAgICAgIGZsb2F0IGR4Q0xlcnAgPSBkeEMgLSBmbG9hdChsZWZ0RHhDSW5kZXgpO1xuICAgICAgICAgICAgZmxvYXQgaW52ZXJzZUR4Q0xlcnAgPSAxLjAgLSBkeENMZXJwO1xuXG4gICAgICAgICAgICBpZiAociA9PSB0b3BEeFJJbmRleCAmJiBjID09IGxlZnREeENJbmRleCkge1xuICAgICAgICAgICAgICAvLyB0b3BMZWZ0XG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9XG4gICAgICAgICAgICAgICAgZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogaW52ZXJzZUR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XG4gICAgICAgICAgICAgIC8vIHRvcFJpZ2h0XG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogZHhDTGVycDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gYm90dG9tTGVmdFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyID09IGJvdHRvbUR4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xuICAgICAgICAgICAgICAvLyBib3R0b21SaWdodFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCkgKiBkeFJMZXJwICogZHhDTGVycDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5kIGxvb3Agb3ZlciBkeVxuXG4gICAgICAgIHNldE91dHB1dChhY2N1bXVsYXRvcik7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIFlpZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2ltYWdlczpyLGR5OnN9PXQse2FsaWduQ29ybmVyczppfT1hLG89bmV3IFhpZShzLnNoYXBlLHIuc2hhcGUsaSk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKG8sW3NdLHMuZHR5cGUpfXZhciBaaWU9e2tlcm5lbE5hbWU6T3UsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6WWllfSxKaWU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSxyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO2xldFtzLGksbyxsXT1lO3RoaXMub3V0cHV0U2hhcGU9W3MsdCxuLGxdO2xldCB1PVthJiZ0PjE/aS0xOmksYSYmbj4xP28tMTpvXSxwPVthJiZ0PjE/dC0xOnQsYSYmbj4xP24tMTpuXSxkPWE/XCIwLjVcIjpcIjAuMFwiLGM7cj9jPVwibWF4KCh2ZWMyKHlSQykgKyB2ZWMyKDAuNSkpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQywgdmVjMigwLjApKVwiOmM9XCJ2ZWMyKHlSQykgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDXCIsdGhpcy51c2VyQ29kZT1gXG4gICAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkMgPSB2ZWMyKFxuICAgICAgICAgICR7dVswXS9wWzBdfSxcbiAgICAgICAgICAke3VbMV0vcFsxXX0pO1xuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKCR7aX0uMCwgJHtvfS4wKTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xuICAgICAgICBpdmVjMiB5UkMgPSBjb29yZHMueXo7XG5cbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4UkMgPSAke2N9O1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxuICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0UkMgPSBpdmVjMihcbiAgICAgICAgICBtaW4oaW5wdXRTaGFwZVJDIC0gMS4wLCBmbG9vcihzb3VyY2VGcmFjSW5kZXhSQyArICR7ZH0pKSk7XG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0QShiLCBzb3VyY2VOZWFyZXN0UkMueCwgc291cmNlTmVhcmVzdFJDLnksIGQpO1xuXG4gICAgICAgIHNldE91dHB1dChuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgYH19LFFpZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9W107bGV0W3MsaSxvLGxdPWU7dGhpcy5vdXRwdXRTaGFwZT1bcyx0LG4sbF07bGV0IHU9W2EmJnQ+MT9pLTE6aSxhJiZuPjE/by0xOm9dLHA9W2EmJnQ+MT90LTE6dCxhJiZuPjE/bi0xOm5dLGQ9YT9cIjAuNVwiOlwiMC4wXCIsYztyP2M9XCJtYXgoKHZlYzMoeVJDKSArIHZlYzMoMC41KSkgKiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDLCB2ZWMzKDAuMCkpXCI6Yz1cInZlYzMoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkNcIix0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IHZlYzMgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzMoXG4gICAgICAgICAgJHt1WzBdL3BbMF19LFxuICAgICAgICAgICR7dVsxXS9wWzFdfSxcbiAgICAgICAgICAke3VbMV0vcFsxXX0pO1xuICAgICAgY29uc3QgdmVjMyBpbnB1dFNoYXBlUkMgPSB2ZWMzKCR7aX0uMCwgJHtvfS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b30uMCk7XG5cbiAgICAgIGZsb2F0IGdldEFWYWx1ZShpbnQgYiwgaW50IHIsIGludCBjLCBpbnQgZCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKGIsIHIsIGMsIGQpLCB2ZWMyKGMsIGQpKTtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWVzIGZvciBuZXh0IGNvbHVtbiBpbiB5UkMuei5cbiAgICAgICAgaXZlYzMgeVJDID0gY29vcmRzLnl6eiArIGl2ZWMzKDAsIDAsIDEpO1xuXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxuICAgICAgICB2ZWMzIHNvdXJjZUZyYWNJbmRleFJDID0gJHtjfTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cbiAgICAgICAgaXZlYzMgc291cmNlTmVhcmVzdFJDID0gaXZlYzMoXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgZmxvb3Ioc291cmNlRnJhY0luZGV4UkMgKyAke2R9KSkpO1xuXG4gICAgICAgIC8vIFNob3VsZCB3ZSBjYWxjdWxhdGUgbmV4dCBjb2x1bW4gYW5kIHJvdyBlbGVtZW50cyBpbiAyeDIgcGFja2VkIGNlbGwuXG4gICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IGQgPCAke2wtMX07XG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGNvb3Jkcy56IDwgJHtuLTF9O1xuXG4gICAgICAgIHZlYzQgbmV3VmFsdWUgPSB2ZWM0KFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VOZWFyZXN0UkMueCwgc291cmNlTmVhcmVzdFJDLnksIGQpLFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlTmVhcmVzdFJDLngsIHNvdXJjZU5lYXJlc3RSQy55LCBkICsgMSlcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlTmVhcmVzdFJDLngsIHNvdXJjZU5lYXJlc3RSQy56LCBkKVxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZU5lYXJlc3RSQy54LCBzb3VyY2VOZWFyZXN0UkMueiwgZCArIDEpIDogMC4wKTtcblxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBlb2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZXM6cn09dCx7YWxpZ25Db3JuZXJzOnMsaGFsZlBpeGVsQ2VudGVyczppLHNpemU6b309YSxbbCx1XT1vLHA9RygpLmdldEJvb2woXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIik/bmV3IFFpZShyLnNoYXBlLGwsdSxzLGkpOm5ldyBKaWUoci5zaGFwZSxsLHUscyxpKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0ocCxbcl0sci5kdHlwZSl9dmFyIHRvZT17a2VybmVsTmFtZTpObyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzplb2V9LG5vZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10O2xldFssYSxyXT10LFsscyxpXT1lLG89W24mJnM+MT9hLTE6YSxuJiZpPjE/ci0xOnJdLGw9W24mJnM+MT9zLTE6cyxuJiZpPjE/aS0xOmldLHU9b1swXS9sWzBdLHA9b1sxXS9sWzFdLGQ9MS91LGM9MS9wLGg9TWF0aC5jZWlsKGQpKjIrMixtPU1hdGguY2VpbChjKSoyKzI7dGhpcy51c2VyQ29kZT1gXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcblxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcblxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KCR7dX0pO1xuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoJHtwfSk7XG5cbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdCgke2R9KTtcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KCR7Y30pO1xuXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoJHtofSk7XG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludCgke219KTtcblxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcbiAgICAgICAgaW50IHN0YXJ0RHlSID0gaW50KGZsb29yKHN0YXJ0UkxlcnAgLSBmbG9hdCh3aW5IZWlnaHQgLyAyKSkpO1xuXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xuICAgICAgICBpbnQgc3RhcnREeUMgPSBpbnQoZmxvb3Ioc3RhcnRDTGVycCAtIGZsb2F0KHdpbldpZHRoIC8gMikpKTtcblxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xuICAgICAgICAgIGludCBkeVIgPSBkeVJPZmZzZXQgKyBzdGFydER5UjtcblxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxuICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSAke3N9KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcblxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gJHtpfSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY1JvdyA9XG4gICAgICAgICAgICAgIGZsb2F0KCR7b1swXX0pICpcbiAgICAgICAgICAgICAgICAoZmxvYXQoZHlSKSAvIGZsb2F0KCR7bFswXX0pKTtcblxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY0NvbCA9XG4gICAgICAgICAgICAgICAgZmxvYXQoJHtvWzFdfSkgKlxuICAgICAgICAgICAgICAgICAgKGZsb2F0KGR5QykgLyBmbG9hdCgke2xbMV19KSk7XG5cbiAgICAgICAgICAgIGludCBzb3VyY2VOZWFyZXN0Um93ID0gaW50KG1pbihcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoJHthfSkgLSAxKSxcbiAgICAgICAgICAgICAgICAke259ID8gZmxvYXQocm91bmQoc291cmNlRnJhY1JvdykpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdChmbG9vcihzb3VyY2VGcmFjUm93KSkpKTtcblxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RDb2wgPSBpbnQobWluKFxuICAgICAgICAgICAgICAgIGZsb2F0KGludCgke3J9KSAtIDEpLFxuICAgICAgICAgICAgICAgICR7bn0gPyBmbG9hdChyb3VuZChzb3VyY2VGcmFjQ29sKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNDb2wpKSkpO1xuXG4gICAgICAgICAgICBpZiAociA9PSBzb3VyY2VOZWFyZXN0Um93ICYmIGMgPT0gc291cmNlTmVhcmVzdENvbCkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVuZCBsb29wIG92ZXIgZHlcblxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBhb2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZXM6cixkeTpzfT10LHthbGlnbkNvcm5lcnM6aX09YSxvPW5ldyBub2Uocy5zaGFwZSxyLnNoYXBlLGkpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShvLFtzXSxzLmR0eXBlKX12YXIgcm9lPXtrZXJuZWxOYW1lOk11LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmFvZX0sc29lPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl07bGV0IG49ZS5sZW5ndGg7aWYobj40KXRocm93IG5ldyBFcnJvcihgV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLSR7bn0gdGVuc29yIGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7aWYodGhpcy5vdXRwdXRTaGFwZT1lLG49PT0xKXt0aGlzLnVzZXJDb2RlPWBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGludCBjb29yZCA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIHNldE91dHB1dChnZXRYKCR7ZVswXX0gLSBjb29yZCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgYDtyZXR1cm59bGV0IGE9aT0+dC5pbmRleE9mKGkpIT09LTEmJmVbaV0hPT0xP2Ake2VbaV19IC0gY29vcmRzWyR7aX1dIC0gMWA6YGNvb3Jkc1ske2l9XWAscj1lLm1hcCgoaSxvKT0+YShvKSkuam9pbihcIixcIikscz1odChuKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtzfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgc2V0T3V0cHV0KGdldFgoJHtyfSkpO1xuICAgICAgfVxuICAgIGB9fSxpb2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMDtsZXQgbj1lLmxlbmd0aDtpZihuPjQpdGhyb3cgbmV3IEVycm9yKGBXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstJHtufSB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRgKTt0aGlzLm91dHB1dFNoYXBlPWU7bGV0IGE9SW4oXCJyY1wiLG4pLHI9YCR7YVtuLTFdfSArIDEgPCAke3RoaXMub3V0cHV0U2hhcGVbbi0xXX1gLHM9YCR7YVtuLTJdfSArIDEgPCAke3RoaXMub3V0cHV0U2hhcGVbbi0yXX1gLGk9aHQobik7bj09PTE/dGhpcy51c2VyQ29kZT1gXG4gICAgICAgIHZvaWQgbWFpbigpe1xuICAgICAgICAgIGludCByYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XG4gICAgICAgICAgcmVzdWx0LnIgPSBnZXRDaGFubmVsKGdldFgoJHtlWzBdfSAtIHJjIC0gMSksXG4gICAgICAgICAgICAke2VbMF19IC0gcmMgLSAxKTtcbiAgICAgICAgICBpZigke3J9KXtcbiAgICAgICAgICAgICAgcmVzdWx0LmcgPSBnZXRDaGFubmVsKGdldFgoJHtlWzBdfSAtIChyYyAgKyAxKSAtIDEpLFxuICAgICAgICAgICAgICAgICR7ZVswXX0gLSAocmMgICsgMSkgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIGA6dGhpcy51c2VyQ29kZT1gXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAke2l9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcbiAgICAgICAgICByZXN1bHQuciA9ICR7byhhLnNsaWNlKCkpfTtcbiAgICAgICAgICBpZigke3J9KXtcbiAgICAgICAgICAgIHJlc3VsdC5nID0gJHtsKGEuc2xpY2UoKSl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZigke3N9KSB7XG4gICAgICAgICAgICByZXN1bHQuYiA9ICR7dShhLnNsaWNlKCkpfTtcbiAgICAgICAgICAgIGlmKCR7cn0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmEgPSAke3AoYS5zbGljZSgpKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgYDtmdW5jdGlvbiBvKGgpe3JldHVybiBkKGgpfWZ1bmN0aW9uIGwoaCl7cmV0dXJuIGhbbi0xXT1cIihcIitoW24tMV0rXCIgKyAxKVwiLGQoaCl9ZnVuY3Rpb24gdShoKXtyZXR1cm4gaFtuLTJdPVwiKFwiK2hbbi0yXStcIiArIDEpXCIsZChoKX1mdW5jdGlvbiBwKGgpe3JldHVybiBoW24tMV09XCIoXCIraFtuLTFdK1wiICsgMSlcIixoW24tMl09XCIoXCIraFtuLTJdK1wiICsgMSlcIixkKGgpfWZ1bmN0aW9uIGQoaCl7bGV0IG09ZS5tYXAoKGIseSk9PmMoeSxoKSksZj1tLmpvaW4oXCIsXCIpLGc9bS5zbGljZSgtMikuam9pbihcIixcIik7cmV0dXJuYGdldENoYW5uZWwoZ2V0WCgke2Z9KSwgdmVjMigke2d9KSlgfWZ1bmN0aW9uIGMoaCxtKXtyZXR1cm4gdC5pbmRleE9mKGgpIT09LTEmJmVbaF0hPT0xP2Ake2VbaF19IC0gJHttW2hdfSAtIDFgOmAke21baF19YH19fTtmdW5jdGlvbiBvb2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2RpbXM6c309YSxpPXIuc2hhcGUubGVuZ3RoLG89dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpO2lmKGk9PT0wKXJldHVybiB0YSh7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bn0pO2xldCBsPUcoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBpb2Uoci5zaGFwZSxvKTpuZXcgc29lKHIuc2hhcGUsbyk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGwsW3JdLHIuZHR5cGUpfXZhciBsb2U9e2tlcm5lbE5hbWU6RW8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6b29lfSx1b2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiSW1hZ2VcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLmN1c3RvbVVuaWZvcm1zPVt7bmFtZTpcInBhcmFtc1wiLHR5cGU6XCJ2ZWM0XCJ9XTtsZXQgbj1lWzFdLGE9ZVsyXTt0aGlzLm91dHB1dFNoYXBlPWU7bGV0IHI9XCJcIjt0eXBlb2YgdD09XCJudW1iZXJcIj9yPWBmbG9hdCBvdXRwdXRWYWx1ZSA9ICR7dC50b0ZpeGVkKDIpfTtgOnI9YFxuICAgICAgICB2ZWMzIGZpbGwgPSB2ZWMzKCR7dC5qb2luKFwiLFwiKX0pO1xuICAgICAgICBmbG9hdCBvdXRwdXRWYWx1ZSA9IGZpbGxbY29vcmRzWzNdXTtgLHRoaXMudXNlckNvZGU9YFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgaW50IHggPSBjb29yZHNbMl07XG4gICAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XG4gICAgICAgICAgZmxvYXQgY29vcmRYRmxvYXQgPSAoZmxvYXQoeCkgLSBwYXJhbXNbMF0pICogcGFyYW1zWzNdIC1cbiAgICAgICAgICAgIChmbG9hdCh5KSAtIHBhcmFtc1sxXSkgKiBwYXJhbXNbMl07XG4gICAgICAgICAgZmxvYXQgY29vcmRZRmxvYXQgPSAoZmxvYXQoeCkgLSBwYXJhbXNbMF0pICogcGFyYW1zWzJdICtcbiAgICAgICAgICAgIChmbG9hdCh5KSAtIHBhcmFtc1sxXSkgKiBwYXJhbXNbM107XG4gICAgICAgICAgaW50IGNvb3JkWCA9IGludChyb3VuZChjb29yZFhGbG9hdCArIHBhcmFtc1swXSkpO1xuICAgICAgICAgIGludCBjb29yZFkgPSBpbnQocm91bmQoY29vcmRZRmxvYXQgKyBwYXJhbXNbMV0pKTtcbiAgICAgICAgICAke3J9XG4gICAgICAgICAgaWYoY29vcmRYID49IDAgJiYgY29vcmRYIDwgJHthfSAmJiBjb29yZFkgPj0gMCAmJiBjb29yZFkgPCAke259KSB7XG4gICAgICAgICAgICBvdXRwdXRWYWx1ZSA9IGdldEltYWdlKGNvb3Jkc1swXSwgY29vcmRZLCBjb29yZFgsIGNvb3Jkc1szXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChvdXRwdXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICBgfX0scG9lPXtrZXJuZWxOYW1lOlp1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOih7aW5wdXRzOmUsYXR0cnM6dCxiYWNrZW5kOm59KT0+e2xldHtpbWFnZTphfT1lLHtyYWRpYW5zOnIsZmlsbFZhbHVlOnMsY2VudGVyOml9PXQsbz1uLGw9bmV3IHVvZShhLnNoYXBlLHMpLFt1LHBdPVQuZ2V0SW1hZ2VDZW50ZXIoaSxhLnNoYXBlWzFdLGEuc2hhcGVbMl0pLGQ9W1t1LHAsTWF0aC5zaW4ociksTWF0aC5jb3MocildXTtyZXR1cm4gby5ydW5XZWJHTFByb2dyYW0obCxbYV0sYS5kdHlwZSxkKX19LGNvZT1gXG4gIC8vIE9wZW5HTCBFUyBkb2VzIG5vdCBzdXBwb3J0IHJvdW5kIGZ1bmN0aW9uLlxuICAvLyBUaGUgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIGJhbmtlcidzIHJvdW5kaW5nLlxuICBmbG9hdCBiYXNlID0gZmxvb3IoeCk7XG4gIGlmICgoeCAtIGJhc2UpIDwgMC41KSB7XG4gICAgcmV0dXJuIGZsb29yKHgpO1xuICB9IGVsc2UgaWYgKCh4IC0gYmFzZSkgPiAwLjUpIHtcbiAgICByZXR1cm4gY2VpbCh4KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobW9kKGJhc2UsIDIuMCkgPT0gMC4wKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2UgKyAxLjA7XG4gICAgfVxuICB9XG5gLGRvZT1aZSh7b3BTbmlwcGV0OmNvZX0pLGhvZT17a2VybmVsTmFtZTpfbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpkb2V9LG1vZT1cInJldHVybiBpbnZlcnNlc3FydCh4KTtcIixmb2U9WmUoe29wU25pcHBldDptb2UsY3B1S2VybmVsSW1wbDpUUX0pLGdvZT17a2VybmVsTmFtZTpBbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmb2V9LGRrPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLGEscixzLGk9ITAsbz0hMSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInVwZGF0ZXNcIixcImluZGljZXNcIixcImRlZmF1bHRWYWx1ZVwiXSx0aGlzLm91dHB1dFNoYXBlPXM7bGV0IGw9aHQoci5sZW5ndGgpLHU9aHQocy5sZW5ndGgpLHA9XCJcIjtuPT09MT9wPVwiaVwiOm49PT0yJiYocD1cImksIGpcIik7bGV0IGQ9YGdldEluZGljZXMoJHtwfSlgLGM9XCJcIjthPT09MT9jPVwiaVwiOmE9PT0yJiYoYz1cImksIGNvb3Jkc1sxXVwiKTtsZXQgaD1gZ2V0VXBkYXRlcygke2N9KWAsbT1cIlwiO28mJihtPVwiY29vcmRzWzBdLCBjb29yZHNbMV1cIik7bGV0IGY9YGdldERlZmF1bHRWYWx1ZSgke219KWAsZz10PjE/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgICR7bH0gc3RyaWRlcyA9ICR7bH0oJHtyfSk7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICR7dX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xuICAgICAgICAgIGJvb2wgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7ZX07IGkrKykge1xuICAgICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHt0fTsgaisrKSB7XG4gICAgICAgICAgICAgIGludCBpbmRleCA9IHJvdW5kKCR7ZH0pO1xuICAgICAgICAgICAgICBmbGF0dGVuZWRJbmRleCArPSBpbmRleCAqICR7Z307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhdHRlbmVkSW5kZXggPT0gY29vcmRzWzBdKSB7XG4gICAgICAgICAgICAgIHN1bSArPSAke2h9O1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldE91dHB1dChtaXgoJHtmfSwgc3VtLCBmbG9hdChmb3VuZCkpKTtcbiAgICAgICAgfVxuICAgICAgYH19LGJvZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIscyxpPSEwLG89ITEpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ1cGRhdGVzXCIsXCJpbmRpY2VzXCIsXCJkZWZhdWx0VmFsdWVcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1zO2xldCBsPWh0KHIubGVuZ3RoKSx1PWh0KHMubGVuZ3RoKSxwPVwiXCI7bj09PTE/cD1cImlcIjpuPT09MiYmKHA9XCJpLCBqXCIpO2xldCBkPWBnZXRJbmRpY2VzKCR7cH0pYCxjPVwiXCI7YT09PTE/Yz1cImlcIjphPT09MiYmKGM9XCJpLCBjb29yZHNbMV1cIik7bGV0IGg9YGdldFVwZGF0ZXMoJHtjfSlgLG09XCJcIjtvJiYobT1cImNvb3Jkc1swXSwgY29vcmRzWzFdXCIpO2xldCBmPWBnZXREZWZhdWx0VmFsdWUoJHttfSlgLGc9dD4xP1wic3RyaWRlc1tqXVwiOlwic3RyaWRlc1wiLGI9dD4xP1wic3RyaWRlc1tqICsgMV1cIjpcInN0cmlkZXNcIjt0aGlzLnVzZXJDb2RlPWBcbiAgICAgICAgJHtsfSBzdHJpZGVzID0gJHtsfSgke3J9KTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHt1fSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICB2ZWM0IHN1bSA9IHZlYzQoMC4pO1xuICAgICAgICAgIHZlYzQgZm91bmQgPSB2ZWM0KDAuKTtcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7ZX07IGkrPTIpIHtcbiAgICAgICAgICAgIGl2ZWMyIGZsYXR0ZW5lZEluZGV4ID0gaXZlYzIoMCk7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7dH07IGorPTIpIHtcbiAgICAgICAgICAgICAgaXZlYzQgaW5kZXggPSByb3VuZCgke2R9KTtcbiAgICAgICAgICAgICAgZmxhdHRlbmVkSW5kZXggKz0gaW5kZXgueHogKiAke2d9O1xuICAgICAgICAgICAgICBpZiAoaiArIDEgPCAke3R9KSB7XG4gICAgICAgICAgICAgICAgZmxhdHRlbmVkSW5kZXggKz0gaW5kZXgueXcgKiAke2J9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhdHRlbmVkSW5kZXhbMF0gPT0gY29vcmRzWzBdIHx8IGZsYXR0ZW5lZEluZGV4WzFdID09IGNvb3Jkc1swXSB8fFxuICAgICAgICAgICAgICAgIGZsYXR0ZW5lZEluZGV4WzBdID09IGNvb3Jkc1swXSArIDEgfHwgZmxhdHRlbmVkSW5kZXhbMV0gPT0gY29vcmRzWzBdICsgMSkge1xuICAgICAgICAgICAgICB2ZWM0IHVwZFZhbHMgPSAke2h9O1xuICAgICAgICAgICAgICBpZiAoZmxhdHRlbmVkSW5kZXhbMF0gPT0gY29vcmRzWzBdKSB7XG4gICAgICAgICAgICAgICAgc3VtLnh5ICs9IHVwZFZhbHMueHk7XG4gICAgICAgICAgICAgICAgZm91bmQueHkgPSB2ZWMyKDEuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbGF0dGVuZWRJbmRleFswXSA9PSBjb29yZHNbMF0gKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtLnp3ICs9IHVwZFZhbHMueHk7XG4gICAgICAgICAgICAgICAgZm91bmQuencgPSB2ZWMyKDEuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhdHRlbmVkSW5kZXhbMV0gPT0gY29vcmRzWzBdKSB7XG4gICAgICAgICAgICAgICAgc3VtLnh5ICs9IHVwZFZhbHMuenc7XG4gICAgICAgICAgICAgICAgZm91bmQueHkgPSB2ZWMyKDEuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbGF0dGVuZWRJbmRleFsxXSA9PSBjb29yZHNbMF0gKyAxKSB7XG4gICAgICAgICAgICAgICAgc3VtLnp3ICs9IHVwZFZhbHMuenc7XG4gICAgICAgICAgICAgICAgZm91bmQuencgPSB2ZWMyKDEuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRPdXRwdXQobWl4KCR7Zn0sIHN1bSwgZm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgYH19O2Z1bmN0aW9uIHlvZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2luZGljZXM6cix1cGRhdGVzOnN9PXQse3NoYXBlOml9PWEse3NsaWNlUmFuazpvLG51bVVwZGF0ZXM6bCxzbGljZVNpemU6dSxzdHJpZGVzOnAsb3V0cHV0U2l6ZTpkfT1ULmNhbGN1bGF0ZVNoYXBlcyhzLHIsaSksYz1bZC91LHVdO2lmKGQ9PT0wKXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKGksci5kdHlwZSk7bGV0IGg9Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltsLG9dfX0pLG09Y2Uoe2lucHV0czp7eDpzfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltsLHVdfX0pLGY9bi5tYWtlVGVuc29ySW5mbyhbXSxcImZsb2F0MzJcIixuZXcgRmxvYXQzMkFycmF5KFswXSkpLGc7RygpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpP2c9bmV3IGJvZShsLG8saC5zaGFwZS5sZW5ndGgsbS5zaGFwZS5sZW5ndGgscCxjKTpnPW5ldyBkayhsLG8saC5zaGFwZS5sZW5ndGgsbS5zaGFwZS5sZW5ndGgscCxjKTtsZXQgYj1uLnJ1bldlYkdMUHJvZ3JhbShnLFttLGgsZl0sbS5kdHlwZSkseT1jZSh7aW5wdXRzOnt4OmJ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6aX19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oYiksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSx5fXZhciB4b2U9e2tlcm5lbE5hbWU6UHUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6eW9lfSx2b2U9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4sYSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInNvcnRlZFNlcXVlbmNlXCIsXCJ2YWx1ZXNcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJudW1JbnB1dHNcIix0eXBlOlwiaW50XCJ9XSx0aGlzLm91dHB1dFNoYXBlPVtlLG5dO2xldCByPVwid2hpbGUgKGxlZnQgPCByaWdodCkge1wiLHM9YGZvciAoaW50IGkgPSAwOyBpIDwgJHtNYXRoLmNlaWwoTWF0aC5sb2cyKHQrMSkpfTsgKytpKSB7IGlmIChsZWZ0ID49IHJpZ2h0KSBicmVhaztgLGk9RygpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik9PT0yP3I6cyxvPWE9PT1cImxlZnRcIj9cIjxcIjpcIjw9XCI7dGhpcy51c2VyQ29kZT1gXG4gICAgICAgaW50IGZpbmRCb3VuZChpbnQgYmF0Y2gsIGZsb2F0IHZhbHVlKSB7XG4gICAgICAgICBpbnQgbGVmdCA9IDA7XG4gICAgICAgICBpbnQgcmlnaHQgPSBudW1JbnB1dHM7XG4gICAgICAgICBpbnQgbWlkO1xuICAgICAgICAgJHtpfVxuICAgICAgICAgICBtaWQgPSAobGVmdCArIHJpZ2h0KSAvIDI7XG4gICAgICAgICAgIGlmIChnZXRTb3J0ZWRTZXF1ZW5jZShiYXRjaCwgbWlkKSAke299IHZhbHVlKSB7XG4gICAgICAgICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgcmlnaHQgPSBtaWQ7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICB9XG5cbiAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcbiAgICAgICAgIGludCB2YWx1ZUluZGV4ID0gY29vcmRzWzFdO1xuXG4gICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFZhbHVlcyhiYXRjaCwgdmFsdWVJbmRleCk7XG5cbiAgICAgICAgIHNldE91dHB1dChmbG9hdChmaW5kQm91bmQoYmF0Y2gsIHZhbHVlKSkpO1xuICAgICAgIH1cbiAgICAgYH19O2Z1bmN0aW9uIHdvZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NvcnRlZFNlcXVlbmNlOnIsdmFsdWVzOnN9PXQse3NpZGU6aX09YSxvPW5ldyB2b2Uoci5zaGFwZVswXSxyLnNoYXBlWzFdLHMuc2hhcGVbMV0saSksbD1bW3Iuc2hhcGVbMV1dXTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0obyxbcixzXSxcImludDMyXCIsbCl9dmFyIGtvZT17a2VybmVsTmFtZTp6dSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp3b2V9LElvZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImNcIixcImFcIixcImJcIl0sdGhpcy5vdXRwdXRTaGFwZT10O2xldCBhLHI7aWYobj40KXRocm93IEVycm9yKGBXaGVyZSBmb3IgcmFuayAke259IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7aWYobj09PTEpcj1cInJlc1JDXCIsYT1cInJlc1JDXCI7ZWxzZXtsZXQgaT1bXCJyZXNSQy54XCIsXCJyZXNSQy55XCIsXCJyZXNSQy56XCIsXCJyZXNSQy53XCJdLG89W10sbD1bXTtmb3IobGV0IHU9MDt1PHQubGVuZ3RoO3UrKylsLnB1c2goYCR7aVt1XX1gKSx1PGUmJm8ucHVzaChgJHtpW3VdfWApO2E9by5qb2luKCkscj1sLmpvaW4oKX1sZXQgcz1odChuKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtzfSByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBmbG9hdCBjVmFsID0gZ2V0Qygke2F9KTtcbiAgICAgICAgaWYgKGNWYWwgPj0gMS4wKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KGdldEEoJHtyfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldE91dHB1dChnZXRCKCR7cn0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBTb2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7Y29uZGl0aW9uOmEsdDpyLGU6c309dCxpPW5ldyBJb2UoYS5zaGFwZS5sZW5ndGgsci5zaGFwZSxyLnNoYXBlLmxlbmd0aCk7cmV0dXJuIG4ucnVuV2ViR0xQcm9ncmFtKGksW2EscixzXSxmYShyLmR0eXBlLHMuZHR5cGUpKX12YXIgTm9lPXtrZXJuZWxOYW1lOld1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlNvZX0sVG9lPWBcbiAgLy8gU3RhYmxlIGFuZCBBdHRyYWN0aW5nIEZpeGVkIFBvaW50ICgwLCAxKSBmb3IgTm9ybWFsaXplZCBXZWlnaHRzLlxuICAvLyBzZWU6IGh0dHBzOi8vYXJ4aXYub3JnL2Ficy8xNzA2LjAyNTE1XG4gIGZsb2F0IHNjYWxlQWxwaGEgPSAke1QuU0VMVV9TQ0FMRUFMUEhBfTtcbiAgZmxvYXQgc2NhbGUgPSAke1QuU0VMVV9TQ0FMRX07XG4gIHJldHVybiAoeCA+PSAwLjApID8gc2NhbGUgKiB4IDogc2NhbGVBbHBoYSAqIChleHAoeCkgLSAxLjApO1xuYCxDb2U9WmUoe29wU25pcHBldDpUb2V9KSxFb2U9e2tlcm5lbE5hbWU6Rm8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Q29lfSxfb2U9bXArYFxuICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1xuYCxBb2U9YFxuICB2ZWM0IHJlc3VsdCA9IDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHgpKTtcbiAgYnZlYzQgaXNOYU4gPSBpc25hbih4KTtcblxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcbiAgcmVzdWx0LmcgPSBpc05hTi5nID8geC5nIDogcmVzdWx0Lmc7XG4gIHJlc3VsdC5iID0gaXNOYU4uYiA/IHguYiA6IHJlc3VsdC5iO1xuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcblxuICByZXR1cm4gcmVzdWx0O1xuYCxGb2U9WmUoe29wU25pcHBldDpfb2UscGFja2VkT3BTbmlwcGV0OkFvZSxjcHVLZXJuZWxJbXBsOkVRfSksJG9lPXtrZXJuZWxOYW1lOk1vLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOkZvZX0sRG9lPWBcbiAgaWYgKGlzbmFuKHgpKSB7IHJldHVybiAwLjA7IH1cbiAgcmV0dXJuIHNpZ24oeCk7XG5gLFJvZT1aZSh7b3BTbmlwcGV0OkRvZX0pLE1vZT17a2VybmVsTmFtZTpSbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpSb2V9LE9vZT1tcCtgXG4gIHJldHVybiBzaW4oeCk7XG5gLFBvZT1gXG4gIHZlYzQgcmVzdWx0ID0gc2luKHgpO1xuICBidmVjNCBpc05hTiA9IGlzbmFuKHgpO1xuICAke1FvfVxuICByZXR1cm4gcmVzdWx0O1xuYCxMb2U9WmUoe29wU25pcHBldDpPb2UscGFja2VkT3BTbmlwcGV0OlBvZX0pLHpvZT17a2VybmVsTmFtZTokbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpMb2V9LFdvZT1gXG4gIGZsb2F0IGUyeCA9IGV4cCh4KTtcbiAgcmV0dXJuIChlMnggLSAxLjAgLyBlMngpIC8gMi4wO1xuYCxCb2U9WmUoe29wU25pcHBldDpXb2V9KSxWb2U9e2tlcm5lbE5hbWU6RG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6Qm9lfSxVb2U9YFxuICBmbG9hdCBlcHNpbG9uID0gMS4xOTIwOTI4OTU1MDc4MTI1ZS03O1xuICBmbG9hdCB0aHJlc2hvbGQgPSBsb2coZXBzaWxvbikgKyAyLjA7XG5cbiAgYm9vbCB0b29fbGFyZ2UgPSB4ID4gLXRocmVzaG9sZDtcbiAgYm9vbCB0b29fc21hbGwgPSB4IDwgdGhyZXNob2xkO1xuXG4gIGZsb2F0IHJlc3VsdDtcbiAgZmxvYXQgZXhwX3ggPSBleHAoeCk7XG5cbiAgaWYgKHRvb19sYXJnZSl7XG4gICAgcmVzdWx0ID0geDtcbiAgfVxuICBlbHNlIGlmICh0b29fc21hbGwpe1xuICAgIHJlc3VsdCA9IGV4cF94O1xuICB9XG4gIGVsc2V7XG4gICAgcmVzdWx0ID0gbG9nKGV4cF94ICsgMS4wKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xuYCxHb2U9WmUoe29wU25pcHBldDpVb2V9KSxIb2U9e2tlcm5lbE5hbWU6T28sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6R29lfSxqb2U9ZT0+e2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtibG9ja1NoYXBlOnMscGFkZGluZ3M6aX09YTt3LmFzc2VydChyLnNoYXBlLmxlbmd0aDw9NCwoKT0+XCJzcGFjZVRvQmF0Y2hORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwiKTtsZXQgbz1zLnJlZHVjZSgoYix5KT0+Yip5KSxsPVtbMCwwXV07bC5wdXNoKC4uLmkpO2ZvcihsZXQgYj0xK3MubGVuZ3RoO2I8ci5zaGFwZS5sZW5ndGg7KytiKWwucHVzaChbMCwwXSk7bGV0IHU9W10scD1zRih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7cGFkZGluZ3M6bCxjb25zdGFudFZhbHVlOjB9fSksZD1ULmdldFJlc2hhcGVkKHAuc2hhcGUscyxvLCExKSxjPVQuZ2V0UGVybXV0ZWQoZC5sZW5ndGgscy5sZW5ndGgsITEpLGg9VC5nZXRSZXNoYXBlZFBlcm11dGVkKHAuc2hhcGUscyxvLCExKSxtPWNlKHtpbnB1dHM6e3g6cH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpkfX0pLGY9U24oe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3Blcm06Y319KSxnPWNlKHtpbnB1dHM6e3g6Zn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpofX0pO3JldHVybiB1LnB1c2gocCksdS5wdXNoKG0pLHUucHVzaChmKSx1LmZvckVhY2goYj0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhiKSksZ30scW9lPXtrZXJuZWxOYW1lOlZ1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmpvZX07ZnVuY3Rpb24gS29lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2luZGljZXM6YSx2YWx1ZXM6cixkZW5zZVNoYXBlOnMsZGVmYXVsdFZhbHVlOml9PXQ7aWYocy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgRGVuc2Ugc2hhcGUgbXVzdCBiZSBhIHZlY3Rvciwgc2F3OlxuICAgICAgICAgJHtzLnNoYXBlfWApO2lmKGEuc2hhcGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgbXVzdCBiZSBhIG1hdHJpeCwgc2F3OlxuICAgICAgICAgJHthLnNoYXBlfWApO2lmKHIuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYFZhbHVlcyBtdXN0IGJlIGEgdmVjdG9yLCBzYXc6XG4gICAgICAgICAke3Iuc2hhcGV9YCk7aWYoaS5zaGFwZS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgRGVmYXVsdCB2YWx1ZSBtdXN0IGJlIGEgc2NhbGFyLCBzYXc6XG4gICAgICAgICR7aS5zaGFwZX1gKTtsZXQgbz1uLnJlYWRTeW5jKGEuZGF0YUlkKSxsPW4ucmVhZFN5bmMoci5kYXRhSWQpLHU9bi5yZWFkU3luYyhzLmRhdGFJZCkscD1uLnJlYWRTeW5jKGkuZGF0YUlkKVswXSxbZCxjLGgsbSxmXT1BUShvLGEuc2hhcGUsYS5kdHlwZSxsLHIuZHR5cGUsdSxwKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhjLGEuZHR5cGUsZCksbi5tYWtlVGVuc29ySW5mbyhbY1swXV0sci5kdHlwZSxoKSxuLm1ha2VUZW5zb3JJbmZvKFttLmxlbmd0aF0sXCJib29sXCIsbmV3IFVpbnQ4QXJyYXkobS5tYXAoZz0+TnVtYmVyKGcpKSkpLG4ubWFrZVRlbnNvckluZm8oW2YubGVuZ3RoXSxhLmR0eXBlLG5ldyBJbnQzMkFycmF5KGYpKV19dmFyIFhvZT17a2VybmVsTmFtZTpHYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpLb2V9O2Z1bmN0aW9uIFlvZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtpbnB1dEluZGljZXM6YSxpbnB1dFNoYXBlOnIsbmV3U2hhcGU6c309dDtpZihhLnNoYXBlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBpbmRpY2VzIHNob3VsZCBiZSBhIG1hdHJpeCBidXQgcmVjZWl2ZWQgc2hhcGUgJHthLnNoYXBlfWApO2lmKHIuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYElucHV0IHNoYXBlIHNob3VsZCBiZSBhIHZlY3RvciBidXQgcmVjZWl2ZWQgc2hhcGUgJHtyLnNoYXBlfWApO2lmKHMuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBzaGFwZSBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlICR7cy5zaGFwZX1gKTtsZXQgaT1BcnJheS5mcm9tKG4ucmVhZFN5bmMoci5kYXRhSWQpKSxvPW4ucmVhZFN5bmMoYS5kYXRhSWQpLGw9QXJyYXkuZnJvbShuLnJlYWRTeW5jKHMuZGF0YUlkKSksW3UscCxkXT1GUShvLGEuc2hhcGUsYS5kdHlwZSxpLGwpO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKHAsYS5kdHlwZSx1KSxuLm1ha2VUZW5zb3JJbmZvKFtkLmxlbmd0aF0scy5kdHlwZSxuZXcgSW50MzJBcnJheShkKSldfXZhciBab2U9e2tlcm5lbE5hbWU6R3UsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6WW9lfTtmdW5jdGlvbiBKb2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7ZGF0YTphLGluZGljZXM6cixzZWdtZW50SWRzOnN9PXQ7aWYoYS5zaGFwZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHNob3VsZCBiZSBhdCBsZWFzdCAxIGRpbWVuc2lvbmFsIGJ1dCByZWNlaXZlZCBzY2FsYXJcIik7aWYoci5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgSW5kaWNlcyBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAgICAgICR7ci5zaGFwZX1gKTtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBTZWdtZW50IGlkcyBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAgICAgICR7cy5zaGFwZX1gKTtsZXQgaT1uLnJlYWRTeW5jKGEuZGF0YUlkKSxvPW4ucmVhZFN5bmMoci5kYXRhSWQpLGw9bi5yZWFkU3luYyhzLmRhdGFJZCksW3UscF09RUEoaSxhLnNoYXBlLGEuZHR5cGUsbyxsLCEwKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhwLGEuZHR5cGUsdSl9dmFyIFFvZT17a2VybmVsTmFtZTpIYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpKb2V9O2Z1bmN0aW9uIGVsZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtkYXRhOmEsaW5kaWNlczpyLHNlZ21lbnRJZHM6c309dDtpZihhLnNoYXBlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkRhdGEgc2hvdWxkIGJlIGF0IGxlYXN0IDEgZGltZW5zaW9uYWwgYnV0IHJlY2VpdmVkIHNjYWxhclwiKTtpZihyLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBhIHZlY3RvciBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICAgICAke3Iuc2hhcGV9YCk7aWYocy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgU2VnbWVudCBpZHMgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZVxuICAgICAgICAgICAgICR7cy5zaGFwZX1gKTtsZXQgaT1uLnJlYWRTeW5jKGEuZGF0YUlkKSxvPW4ucmVhZFN5bmMoci5kYXRhSWQpLGw9bi5yZWFkU3luYyhzLmRhdGFJZCksW3UscF09RUEoaSxhLnNoYXBlLGEuZHR5cGUsbyxsKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhwLGEuZHR5cGUsdSl9dmFyIHRsZT17a2VybmVsTmFtZTpqYyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzplbGV9O2Z1bmN0aW9uIG5sZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NwYXJzZUluZGljZXM6cixzcGFyc2VWYWx1ZXM6cyxkZWZhdWx0VmFsdWU6aX09dCx7b3V0cHV0U2hhcGU6b309YSx7c2xpY2VSYW5rOmwsbnVtVXBkYXRlczp1LHNsaWNlU2l6ZTpwLHN0cmlkZXM6ZCxvdXRwdXRTaXplOmN9PVQuY2FsY3VsYXRlU2hhcGVzKHMscixvKSxoPSExO2lmKHMuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgYj1uLmJ1ZmZlclN5bmMocikseT1uLmJ1ZmZlclN5bmMocykseD13LmRlY29kZVN0cmluZyhuLnJlYWRTeW5jKGkuZGF0YUlkKVswXSksdj1DUShiLHksbyxjLHAsdSxsLGQseCxoKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhvLHYuZHR5cGUsdi52YWx1ZXMpfWxldCBtPW5ldyBkayh1LGwsci5zaGFwZS5sZW5ndGgscy5zaGFwZS5sZW5ndGgsZCxbYywxXSxoKSxmPW4ucnVuV2ViR0xQcm9ncmFtKG0sW3MscixpXSxzLmR0eXBlKSxnPWNlKHtpbnB1dHM6e3g6Zn0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpvfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKGYpLGd9dmFyIGFsZT17a2VybmVsTmFtZTpIdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpubGV9O2Z1bmN0aW9uIHJsZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7bnVtT3JTaXplU3BsaXRzOnMsYXhpczppfT1hLG89dy5wYXJzZUF4aXNQYXJhbShpLHIuc2hhcGUpWzBdLGw9VC5wcmVwYXJlU3BsaXRTaXplKHIscyxvKSx1PXIuc2hhcGUubGVuZ3RoLHA9bmV3IEFycmF5KHUpLmZpbGwoMCksZD1yLnNoYXBlLnNsaWNlKCk7cmV0dXJuIGwubWFwKGM9PntsZXQgaD1bLi4uZF07aFtvXT1jO2xldCBtPWZwKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntiZWdpbjpwLHNpemU6aH19KTtyZXR1cm4gcFtvXSs9YyxtfSl9dmFyIHNsZT17a2VybmVsTmFtZTpVdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpybGV9LElTPVwicmV0dXJuIHNxcnQoeCk7XCIsaWxlPVplKHtvcFNuaXBwZXQ6SVMscGFja2VkT3BTbmlwcGV0OklTLGNwdUtlcm5lbEltcGw6JFF9KSxvbGU9e2tlcm5lbE5hbWU6UG8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6aWxlfSxsbGU9XCJyZXR1cm4geCAqIHg7XCIsdWxlPVplKHtvcFNuaXBwZXQ6bGxlfSkscGxlPXtrZXJuZWxOYW1lOnFjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOnVsZX0sU1M9XCJyZXR1cm4gKGEgLSBiKSAqIChhIC0gYik7XCIsY2xlPWhuKHtvcFNuaXBwZXQ6U1MscGFja2VkT3BTbmlwcGV0OlNTfSksZGxlPXtrZXJuZWxOYW1lOldvLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmNsZX07ZnVuY3Rpb24gaGxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10O2lmKHIuZHR5cGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgb2YgZGF0YXR5cGUgc3RyaW5nXCIpO2xldCBzPW4ucmVhZFN5bmMoci5kYXRhSWQpLGk9VC5mcm9tVWludDhUb1N0cmluZ0FycmF5KHMpLG89RFEoaSxcInN0cmluZ1wiLGEpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKHIuc2hhcGUsXCJzdHJpbmdcIixvKX12YXIgbWxlPXtrZXJuZWxOYW1lOktjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmhsZX07ZnVuY3Rpb24gZmxlKHtpbnB1dHM6ZSxhdHRyczp0LGJhY2tlbmQ6bn0pe2xldHt4OmF9PWUscj1EYStgXG4gICAgcmV0dXJuIHggPiAwLjAgPyAxLjAgOiBmbG9hdCgke3QuYWxwaGF9KTtcbiAgYCxzPW5ldyBycihhLnNoYXBlLHIpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShzLFthXSxhLmR0eXBlKX12YXIgZ2xlPXtrZXJuZWxOYW1lOklzLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZsZX0sYmxlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPW47bGV0IGE9bi5sZW5ndGgscj1odChuLmxlbmd0aCkscz1odChuLmxlbmd0aCksaT1cIlwiO2lmKGE9PT0xKWk9XCJjb29yZHMgKiBzdHJpZGVzICsgYmVnaW5cIjtlbHNle2xldCBvPTA7aT1uLm1hcCgobCx1KT0+KG8rKyxuLmxlbmd0aD09PTE/YGNvb3JkcyAqIHN0cmlkZXNbJHt1fV0gKyBiZWdpblske3V9XWA6YGNvb3Jkc1ske28tMX1dICogc3RyaWRlc1ske3V9XSArIGJlZ2luWyR7dX1dYCkpLmpvaW4oXCIsXCIpfXRoaXMudXNlckNvZGU9YFxuICAgICAgJHtyfSBiZWdpbiA9ICR7cn0oJHtlfSk7XG4gICAgICAke3J9IHN0cmlkZXMgPSAke3J9KCR7dH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7c30gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHNldE91dHB1dChnZXRYKCR7aX0pKTtcbiAgICAgIH1cbiAgICBgfX07ZnVuY3Rpb24geWxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtiZWdpbjpzLGVuZDppLHN0cmlkZXM6byxiZWdpbk1hc2s6bCxlbmRNYXNrOnUsZWxsaXBzaXNNYXNrOnAsbmV3QXhpc01hc2s6ZCxzaHJpbmtBeGlzTWFzazpjfT1hLHtmaW5hbFNoYXBlU3BhcnNlOmgsZmluYWxTaGFwZTptLGlzSWRlbnRpdHk6ZixzbGljZURpbTA6Zyxpc1NpbXBsZVNsaWNlOmIsYmVnaW46eSxlbmQ6eCxzdHJpZGVzOnZ9PUt0LnNsaWNlSW5mbyhyLnNoYXBlLHMsaSxvLGwsdSxwLGQsYyksSTtpZihmKUk9Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOm19fSk7ZWxzZSBpZihnfHxiKXt3LmFzc2VydChyLnNoYXBlLmxlbmd0aD49MSwoKT0+YElucHV0IG11c3QgaGF2ZSByYW5rIGF0IGxlYXN0IDEsIGdvdDogJHtyLnNoYXBlLmxlbmd0aH1gKTtsZXQgQz1LdC5jb21wdXRlT3V0U2hhcGUoeSx4LHYpLF89ZnAoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOnksc2l6ZTpDfX0pO0k9Y2Uoe2lucHV0czp7eDpffSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOm19fSksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhfKX1lbHNlIGlmKG4uc2hvdWxkRXhlY3V0ZU9uQ1BVKFtyXSkpe2xldCBDPW4ucmVhZFN5bmMoci5kYXRhSWQpLF89T2Uoci5zaGFwZSxyLmR0eXBlLEMpLEY9UlEoaCxfLHYseSk7ST1uLm1ha2VUZW5zb3JJbmZvKG0sci5kdHlwZSxGLnZhbHVlcyl9ZWxzZXtsZXQgQz1uZXcgYmxlKHksdixoKTtJPW4ucnVuV2ViR0xQcm9ncmFtKEMsW3JdLHIuZHR5cGUpfWxldCBOPWNlKHtpbnB1dHM6e3g6SX0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTptfX0pO3JldHVybiBuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKEkpLE59dmFyIHhsZT17a2VybmVsTmFtZTpqdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp5bGV9O2Z1bmN0aW9uIHZsZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3NlcGFyYXRvcjpyLG5HcmFtV2lkdGhzOnMsbGVmdFBhZDppLHJpZ2h0UGFkOm8scGFkV2lkdGg6bCxwcmVzZXJ2ZVNob3J0U2VxdWVuY2VzOnV9PWEse2RhdGE6cCxkYXRhU3BsaXRzOmR9PXQsYz1uLnJlYWRTeW5jKHAuZGF0YUlkKSxoPW4ucmVhZFN5bmMoZC5kYXRhSWQpLFttLGZdPU1RKGMsaCxyLHMsaSxvLGwsdSk7cmV0dXJuW24ubWFrZVRlbnNvckluZm8oW20ubGVuZ3RoXSxcInN0cmluZ1wiLG0pLG4ubWFrZVRlbnNvckluZm8oZC5zaGFwZSxcImludDMyXCIsZildfXZhciB3bGU9e2tlcm5lbE5hbWU6WGMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6dmxlfTtmdW5jdGlvbiBrbGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtza2lwRW1wdHk6cn09YSx7aW5wdXQ6cyxkZWxpbWl0ZXI6aX09dDtpZihzLmR0eXBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIG9mIGRhdGF0eXBlIHN0cmluZ1wiKTtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBtdXN0IGJlIGEgdmVjdG9yLCBnb3Qgc2hhcGU6ICR7cy5zaGFwZX1gKTtpZihpLnNoYXBlLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBEZWxpbWl0ZXIgbXVzdCBiZSBhIHNjYWxhciwgZ290IHNoYXBlOiAke2kuc2hhcGV9YCk7bGV0IG89bi5yZWFkU3luYyhzLmRhdGFJZCksbD1uLnJlYWRTeW5jKGkuZGF0YUlkKVswXSxbdSxwLGRdPU9RKG8sbCxyKSxjPXAubGVuZ3RoO3JldHVybltuLm1ha2VUZW5zb3JJbmZvKFtjLDJdLFwiaW50MzJcIix1KSxuLm1ha2VUZW5zb3JJbmZvKFtjXSxcInN0cmluZ1wiLHApLG4ubWFrZVRlbnNvckluZm8oWzJdLFwiaW50MzJcIixuZXcgSW50MzJBcnJheShkKSldfXZhciBJbGU9e2tlcm5lbE5hbWU6WWMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6a2xlfTtmdW5jdGlvbiBTbGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtudW1CdWNrZXRzOnJ9PWEse2lucHV0OnN9PXQ7aWYocy5kdHlwZSE9PVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSBvZiBkYXRhdHlwZSBzdHJpbmdcIik7aWYocjw9MCl0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYnVja2V0cyBtdXN0IGJlIGF0IGxlYXN0IDFcIik7bGV0IGk9bi5yZWFkU3luYyhzLmRhdGFJZCksbz1QUShpLHIpO3JldHVybiBuLm1ha2VUZW5zb3JJbmZvKHMuc2hhcGUsXCJpbnQzMlwiLG8pfXZhciBObGU9e2tlcm5lbE5hbWU6WmMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6U2xlfSxUbGU9XCJyZXR1cm4gdGFuKHgpO1wiLENsZT1aZSh7b3BTbmlwcGV0OlRsZX0pLEVsZT17a2VybmVsTmFtZTpWbyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpDbGV9LF9sZT1gXG4gIGZsb2F0IGUyeCA9IGV4cCgtMi4wICogYWJzKHgpKTtcbiAgcmV0dXJuIHNpZ24oeCkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuYCxBbGU9WmUoe29wU25pcHBldDpfbGV9KSxGbGU9e2tlcm5lbE5hbWU6VW8sYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6QWxlfTtmdW5jdGlvbiAkbGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt0ZW5zb3I6cixpbmRpY2VzOnMsdXBkYXRlczppfT10LHt9PWEse3NsaWNlUmFuazpvLG51bVVwZGF0ZXM6bCxzbGljZVNpemU6dSxzdHJpZGVzOnAsb3V0cHV0U2l6ZTpkfT1ULmNhbGN1bGF0ZVNoYXBlcyhpLHMsci5zaGFwZSksYz1bZC91LHVdO2lmKGQ9PT0wKXJldHVybiBuLm1ha2VUZW5zb3JJbmZvKHIuc2hhcGUscy5kdHlwZSk7bGV0IGg9Y2Uoe2lucHV0czp7eDpzfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltsLG9dfX0pLG09Y2Uoe2lucHV0czp7eDppfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOltsLHVdfX0pLGY9Y2Uoe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmN9fSksZz1uZXcgZGsobCxvLGguc2hhcGUubGVuZ3RoLG0uc2hhcGUubGVuZ3RoLHAsYywhMSwhMCksYj1uLnJ1bldlYkdMUHJvZ3JhbShnLFttLGgsZl0sZi5kdHlwZSkseT1jZSh7aW5wdXRzOnt4OmJ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6ci5zaGFwZX19KTtyZXR1cm4gbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhoKSxuLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JJbmZvKG0pLG4uZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8oZiksbi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhiKSx5fXZhciBEbGU9e2tlcm5lbE5hbWU6THUsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6JGxlfSxSbGU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtsZXQgbj1uZXcgQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgcz0wO3M8bi5sZW5ndGg7cysrKW5bc109ZVtzXSp0W3NdO3RoaXMub3V0cHV0U2hhcGU9bix0aGlzLnJhbms9bi5sZW5ndGg7bGV0IGE9aHQodGhpcy5yYW5rKSxyPU1sZShlKTt0aGlzLnVzZXJDb2RlPWBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHthfSByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBzZXRPdXRwdXQoZ2V0QSgke3J9KSk7XG4gICAgICB9XG4gICAgYH19O2Z1bmN0aW9uIE1sZShlKXtsZXQgdD1lLmxlbmd0aDtpZih0PjUpdGhyb3cgRXJyb3IoYFRpbGUgZm9yIHJhbmsgJHt0fSBpcyBub3QgeWV0IHN1cHBvcnRlZGApO2lmKHQ9PT0xKXJldHVybmBpbW9kKHJlc1JDLCAke2VbMF19KWA7bGV0IG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiXSxhPVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKWEucHVzaChgaW1vZCgke25bcl19LCAke2Vbcl19KWApO3JldHVybiBhLmpvaW4oKX1mdW5jdGlvbiBvRihlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7cmVwczpzfT1hO2lmKHIuZHR5cGU9PT1cInN0cmluZ1wifHxyLnNoYXBlLmxlbmd0aD41KXtsZXQgbz1uLnJlYWRTeW5jKHIuZGF0YUlkKSxsPXIuZHR5cGU9PT1cInN0cmluZ1wiP28ubWFwKGQ9PncuZGVjb2RlU3RyaW5nKGQpKTpvLHU9T2Uoci5zaGFwZSxyLmR0eXBlLGwpLHA9elEodSxzKTtyZXR1cm4gbi5tYWtlVGVuc29ySW5mbyhwLnNoYXBlLHAuZHR5cGUscC52YWx1ZXMpfWxldCBpPW5ldyBSbGUoci5zaGFwZSxzKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oaSxbcl0sci5kdHlwZSl9dmFyIE9sZT17a2VybmVsTmFtZTprcyxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpvRn0sUGxlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJpbmRpY2VzXCJdLHRoaXMuY3VzdG9tVW5pZm9ybXM9W3tuYW1lOlwiblwiLHR5cGU6XCJpbnRcIn0se25hbWU6XCJmaXJzdFBhc3NcIix0eXBlOlwiaW50XCJ9LHtuYW1lOlwibmVnYXRpdmVJbmZcIix0eXBlOlwiZmxvYXRcIn0se25hbWU6XCJkaXJcIix0eXBlOlwiaW50XCJ9LHtuYW1lOlwiaW5jXCIsdHlwZTpcImludFwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICAgaW50IGVsZW1JZHggPSBjb29yZHNbMV07XG5cbiAgICAgICAgIC8vIFdlIGNvbXBhcmUgZWxlbWVudHMgcGFpci13aXNlIHdpdGhpbiBhIGdyb3VwIG9mIHNpemUgMiAqIGluYy5cbiAgICAgICAgIC8vIFRoZSBjb21wYXJpbmcgcnVsZSBmb3IgZWFjaCBncm91cCBhbHRlcm5hdGVzIGJldHdlZW4gYXNjZW5kaW5nXG4gICAgICAgICAvLyBhbmQgZGVzY2VuZGluZy4gV2l0aGluIGVhY2ggZ3JvdXAsIHdlIGNvbXBhcmUgZWFjaCBwYWlyIGF0XG4gICAgICAgICAvLyBwb3NpdGlvbnMgaSBhbmQgaStpbmMuIFRvIGRlY2lkZSB3aGV0aGVyIGFuIGVsZW1lbnQgYXQgcG9zaXRpb24gaVxuICAgICAgICAgLy8gaXMgeDAgb3IgeDEsIHdlIG1vZCBpdCBieSAyICogaW5jLCBpZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhblxuICAgICAgICAgLy8gaW5jLCBpdCBpcyBpbiB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgZ3JvdXAsIHdlIGRlbm90ZSBpdCBhcyB4MCxcbiAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBkZW5vdGUgaXQgYXMgeDEuXG4gICAgICAgICAvLyBGb3IgZXhhbXBsZSwgYXMgc2hvd24gaW4gdGhlIEJpdG9uaWMgdG9wIEsgcGFwZXIgcmVmZXJlbmNlZCBhYm92ZSxcbiAgICAgICAgIC8vIEZpZ3VyZTUoYSkgc2hvd3MgdGhhdCBlbGVtZW50WzFdIGlzIGluIHRoZVxuICAgICAgICAgLy8gc2Vjb25kIGhhbGYgb2YgdGhlIGdyb3VwIHdoZW4gZ3JvdXAgc2l6ZSBpcyAyLCBidXQgaXQgaXMgaW4gdGhlXG4gICAgICAgICAvLyBmaXJzdCBoYWxmIG9mIHRoZSBncm91cCB3aGVuIGdyb3VwIHNpemUgaXMgNC5cblxuICAgICAgICAgYm9vbCBpc0ZpcnN0SW5QYWlyID0gaW1vZChlbGVtSWR4LCAyICogaW5jKSA8IGluYztcbiAgICAgICAgIGludCBpID0gaXNGaXJzdEluUGFpciA/IGVsZW1JZHggOiBlbGVtSWR4IC0gaW5jO1xuXG4gICAgICAgICBpbnQgaTAgPSBmaXJzdFBhc3MgPT0gMSA/IGkgOiBpbnQoZ2V0SW5kaWNlcyhiYXRjaCwgaSkpO1xuICAgICAgICAgaW50IGkxID0gZmlyc3RQYXNzID09IDEgPyBpICsgaW5jIDogaW50KGdldEluZGljZXMoYmF0Y2gsIGkgKyBpbmMpKTtcbiAgICAgICAgIGZsb2F0IHgwID0gaTAgPCBuID8gZ2V0WChiYXRjaCwgaTApIDogbmVnYXRpdmVJbmY7XG4gICAgICAgICBmbG9hdCB4MSA9IGkxIDwgbiA/IGdldFgoYmF0Y2gsIGkxKSA6IG5lZ2F0aXZlSW5mO1xuXG4gICAgICAgICAvLyBEZW5vdGVzIHdoaWNoIGRpcmVjdGlvbiBpbmRpY2VzIGFyZSBpbiAoYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcpLlxuICAgICAgICAgYm9vbCByZXZlcnNlID0gaW1vZChlbGVtSWR4LCAyICogZGlyKSA+PSBkaXI7XG4gICAgICAgICBib29sIGlzR3JlYXRlciA9IHgwID4geDEgfHwgKHgwID09IHgxICYmIGkxID4gaTApO1xuICAgICAgICAgaWYgKHJldmVyc2UgPT0gaXNHcmVhdGVyKSB7IC8vIEVsZW1lbnRzIGluIG9wcG9zaXRlIG9yZGVyIG9mIGRpcmVjdGlvblxuICAgICAgICAgICBpbnQgaVRlbXAgPSBpMDtcbiAgICAgICAgICAgaTAgPSBpMTtcbiAgICAgICAgICAgaTEgPSBpVGVtcDtcbiAgICAgICAgIH1cbiAgICAgICAgIGlmIChpc0ZpcnN0SW5QYWlyKSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaTApKTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaTEpKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIGB9fSxMbGU9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImluZGljZXNcIl0sdGhpcy5jdXN0b21Vbmlmb3Jtcz1be25hbWU6XCJuXCIsdHlwZTpcImludFwifSx7bmFtZTpcImZpcnN0UGFzc1wiLHR5cGU6XCJpbnRcIn0se25hbWU6XCJrXCIsdHlwZTpcImludFwifV0sdGhpcy5vdXRwdXRTaGFwZT1lLHRoaXMudXNlckNvZGU9YFxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgIC8vIFRha2VzIG1heCBvZiBpbmRpY2VzICgwLCBrKSwgKDEsIGsgKyAxKSwgKDIsIGsgKyAyKSAuLi5cbiAgICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICAgaW50IGVsZW1JZHggPSBjb29yZHNbMV07XG5cbiAgICAgICAgIC8vIFRoZSBvdXRwdXQgc2l6ZSBpcyBoYWxmIG9mIHRoZSBwcmV2aW91cyBzaXplLlxuICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHNlcXVlbmNlIGlzIHwgfCB8IHwgXyBfIF8gXyAgfCB8IHwgfCAgXyBfIF8gXyAoaz00KSxcbiAgICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0byBvdXRwdXQgdGhlIGluZGljZXMgYXQgcG9zaXRpb25zIHwsIHRoZSBpbmRpY2VzIGF0XG4gICAgICAgICAvLyBwb3NpdGlvbnMgXyBjYW4gYmUgdGhyb3duIGF3YXksIHNlZSBGaWd1cmU1KGIpIEFmdGVyIFBoYXNlIDJcbiAgICAgICAgIC8vIChNZXJnZSBwaGFzZSkgaW4gdGhlIEJpdG9uaWMgVG9wIEsgcGFwZXIgcmVmZXJlbmNlZCBhYm92ZS5cbiAgICAgICAgIC8vIEZvciBleGFtcGxlLCB0aGUgcGFwZXIgc2hvd3Mgd2Ugb25seSBuZWVkIHRvIG91dHB1dCB0aGUgb3JhbmdlIGJhcnMuXG4gICAgICAgICAvLyBUaGUgb3V0cHV0IHNlcXVlbmNlIHNob3VsZCBsb29rIGxpa2UgdGhpcyB8IHwgfCB8IHwgfCB8IHwuXG4gICAgICAgICAvLyBCZWNhdXNlIHRoZSBzZXF1ZW5jZSBpcyBoYWx2ZWQsIHRvIG1hcCB0aGUgb3V0cHV0IGluZGV4IGJhY2tcbiAgICAgICAgIC8vIHRvIHRoZSBwcmV2aW91cyBzZXF1ZW5jZSB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLFxuICAgICAgICAgLy8gd2UgbmVlZCB0byBkb3VibGUgdGhlIGluZGV4LiBXaGVuIHdlIGRvdWJsZSB0aGUgaW5kZXgsXG4gICAgICAgICAvLyB3ZSBiYXNpY2FsbHkgaW50ZXJwb2xhdGUgYSBwb3NpdGlvbiwgc28gMmkgbG9va3MgbGlrZVxuICAgICAgICAgLy8gfCBfIHwgXyB8IF8gfCBfIHwgXyB8IF8gfCBfLiBXZSBtb3ZlIHRoZSB8IHRvIHRoZSBmaXJzdCBrIHBvc2l0aW9uXG4gICAgICAgICAvLyBvZiBlYWNoIDJrIHBvc2l0aW9ucyBieSAtIGVsZW1JZHggJSBrLiBFLmcuIGZvciBvdXRwdXQgYXRcbiAgICAgICAgIC8vIGluZGV4IDQsNSw2LDcsIHdlIHdhbnQgdG8gZ2V0IHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgYXRcbiAgICAgICAgIC8vIG9yaWdpbmFsIGluZGV4IDgsOSwxMCwxMSwgZm9yIG91dHB1dCBhdCBpbmRleCA4LDksMTAsMTEsXG4gICAgICAgICAvLyB3ZSB3YW50IHRvIGdldCB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50IGF0IG9yaWdpbmFsIGluZGV4XG4gICAgICAgICAvLyAxNiwxNywxOCwxOSwgc28gb24gYW5kIHNvIGZvcnRoLlxuXG4gICAgICAgICBpbnQgaSA9IGVsZW1JZHggPCBrID8gZWxlbUlkeCA6IChlbGVtSWR4ICogMiAtIGltb2QoZWxlbUlkeCwgaykpO1xuICAgICAgICAgaW50IGkwID0gZmlyc3RQYXNzID09IDEgPyBpIDogaW50KGdldEluZGljZXMoYmF0Y2gsIGkpKTtcbiAgICAgICAgIGludCBpMSA9IGZpcnN0UGFzcyA9PSAxID8gaSArIGsgOiBpbnQoZ2V0SW5kaWNlcyhiYXRjaCwgaSArIGspKTtcblxuICAgICAgICAgZmxvYXQgeDAgPSBnZXRYKGJhdGNoLCBpMCk7XG4gICAgICAgICBmbG9hdCB4MSA9IGkxIDwgbiA/IGdldFgoYmF0Y2gsIGkxKSA6IHgwO1xuXG4gICAgICAgICBzZXRPdXRwdXQoeDAgPj0geDEgPyBmbG9hdChpMCkgOiBmbG9hdChpMSkpO1xuICAgICAgIH1cbiAgICAgYH19O2Z1bmN0aW9uIHFzKGUsdCl7dCE9PW51bGwmJmUuZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odCl9ZnVuY3Rpb24gTlMoZSl7bGV0IHQ9MTtmb3IoO3Q8ZTspdCo9MjtyZXR1cm4gdH1mdW5jdGlvbiB6bGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2s6cyxzb3J0ZWQ6aX09YSxvPUcoKS5nZXROdW1iZXIoXCJUT1BLX0xBU1RfRElNX0NQVV9IQU5ET0ZGX1NJWkVfVEhSRVNIT0xEXCIpLGw9RygpLmdldE51bWJlcihcIlRPUEtfS19DUFVfSEFORE9GRl9USFJFU0hPTERcIiksdT1yLnNoYXBlLHA9dVt1Lmxlbmd0aC0xXTtpZihuLnNob3VsZEV4ZWN1dGVPbkNQVShbcl0pfHxwPG98fHM+bCl7bGV0IEY9bi5yZWFkU3luYyhyLmRhdGFJZCksW0QsJF09V1EoRix1LHIuZHR5cGUscyxpKTtyZXR1cm5bbi5tYWtlVGVuc29ySW5mbyhELnNoYXBlLEQuZHR5cGUsRC52YWx1ZXMpLG4ubWFrZVRlbnNvckluZm8oJC5zaGFwZSwkLmR0eXBlLCQudmFsdWVzKV19aWYocz09PTApcmV0dXJuIHVbdS5sZW5ndGgtMV09MCxbbi5tYWtlVGVuc29ySW5mbyh1LHIuZHR5cGUsW10pLG4ubWFrZVRlbnNvckluZm8odSxcImludDMyXCIsW10pXTtpZihwPT09MSlyZXR1cm5bciwkZCh7YXR0cnM6e3NoYXBlOnUsZHR5cGU6XCJpbnQzMlwiLHZhbHVlOjB9LGJhY2tlbmQ6bn0pXTtsZXQgZD1uLnRleERhdGEuZ2V0KHIuZGF0YUlkKSxjPWQhPT1udWxsJiZkLmlzUGFja2VkLGg9Yz9uLnVucGFja1RlbnNvcihyKTpyLG09dy5zaXplRnJvbVNoYXBlKHUpL3AsZj1jZSh7aW5wdXRzOnt4Omh9LGF0dHJzOntzaGFwZTpbbSxwXX0sYmFja2VuZDpufSk7YyYmcXMobixoKTtsZXQgZz1OUyhzKSxiPU5TKHApLHk9bnVsbCx4PSgpPT55PT09bnVsbD9bZixmXTpbZix5XSx2PShGLEQsJCk9PntsZXQgUz14KCksTT1uZXcgUGxlKCQpLEI9W1twXSxbeT09PW51bGw/MTowXSxbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXSxbRl0sW0RdXSxVPXk7eT1uLnJ1bldlYkdMUHJvZ3JhbShNLFMsXCJpbnQzMlwiLEIpLHFzKG4sVSl9O2ZvcihsZXQgRj0xO0Y8ZztGKj0yKXtsZXQgRD1GKjI7Zm9yKGxldCAkPUY7JD49MTskLz0yKXYoRCwkLFttLGJdKX1mb3IobGV0IEY9YjtGPmc7Ri89Mil7bGV0IEQ9eCgpLCQ9bmV3IExsZShbbSxGLzJdKSxTPVtbcF0sW3k9PT1udWxsPzE6MF0sW2ddXSxNPXk7eT1uLnJ1bldlYkdMUHJvZ3JhbSgkLEQsXCJpbnQzMlwiLFMpLHFzKG4sTSk7bGV0IEI9Zy8yLFU9QioyO2ZvcihsZXQgSD1CO0g+PTE7SC89Mil2KFUsSCx5LnNoYXBlKX1sZXQgST15O3k9ZnAoe2lucHV0czp7eDp5fSxiYWNrZW5kOm4sYXR0cnM6e2JlZ2luOjAsc2l6ZTpbbSxzXX19KSxxcyhuLEkpO2xldCBOPVFBKHtpbnB1dHM6e3g6ZixpbmRpY2VzOnl9LGJhY2tlbmQ6bixhdHRyczp7YXhpczoxLGJhdGNoRGltczoxfX0pO3FzKG4sZik7bGV0IEM9dS5zbGljZSgwLC0xKTtDLnB1c2gocyksST15LHk9Y2Uoe2lucHV0czp7eDp5fSxhdHRyczp7c2hhcGU6Q30sYmFja2VuZDpufSkscXMobixJKTtsZXQgXz1OO3JldHVybiBOPWNlKHtpbnB1dHM6e3g6Tn0sYXR0cnM6e3NoYXBlOkN9LGJhY2tlbmQ6bn0pLHFzKG4sXyksW04seV19dmFyIFdsZT17a2VybmVsTmFtZTpxdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzp6bGV9LEJsZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbixhLHIscyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkltYWdlXCIsXCJUcmFuc2Zvcm1zXCJdLHRoaXMub3V0cHV0U2hhcGU9cztsZXQgaT1uPT09XCJuZWFyZXN0XCI/MToyLG87c3dpdGNoKGEpe2Nhc2VcImNvbnN0YW50XCI6bz0xO2JyZWFrO2Nhc2VcInJlZmxlY3RcIjpvPTI7YnJlYWs7Y2FzZVwid3JhcFwiOm89MzticmVhaztjYXNlXCJuZWFyZXN0XCI6bz00O2JyZWFrO2RlZmF1bHQ6bz0xO2JyZWFrfXRoaXMudXNlckNvZGU9YFxuICAgICAgICAgICAgZmxvYXQgbWFwQ29vcmQoZmxvYXQgb3V0Q29vcmQsIGZsb2F0IGxlbikge1xuICAgICAgICAgICAgICBmbG9hdCBpbkNvb3JkID0gb3V0Q29vcmQ7XG4gICAgICAgICAgICAgIGlmKCR7b30gPT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChpbkNvb3JkIDwgMC4wKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGVuIDw9IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICBpbkNvb3JkID0gMC4wO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgc3oyID0gMi4wICogbGVuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5Db29yZCA8IHN6Mikge1xuICAgICAgICAgICAgICAgICAgICAgIGluQ29vcmQgPSBzejIgKiBmbG9hdChpbnQoZmxvYXQoLWluQ29vcmQgLyBzejIpKSkgK1xuICAgICAgICAgICAgICAgICAgICAgIGluQ29vcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5Db29yZCA9IGluQ29vcmQgPCAtbGVuID8gaW5Db29yZCArIHN6MiA6IC1pbkNvb3JkIC0gMS4wO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5Db29yZCA+IGxlbiAtIDEuMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxlbiA8PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Db29yZCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHN6MiA9IDIuMCAqIGxlbjtcbiAgICAgICAgICAgICAgICAgICAgaW5Db29yZCAtPSBzejIgKiBmbG9hdChpbnQoZmxvYXQoaW5Db29yZCAvIHN6MikpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluQ29vcmQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5Db29yZCA9IHN6MiAtIGluQ29vcmQgLSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYW1wKGluQ29vcmQsIDAuMCwgbGVuIC0gMS4wKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgke299ID09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Db29yZCA8IDAuMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxlbiA8PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Db29yZCA9IDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHN6ID0gbGVuIC0gMS4wO1xuICAgICAgICAgICAgICAgICAgICBpbkNvb3JkICs9IGxlbiAqIChmbG9hdChpbnQoZmxvYXQoLWluQ29vcmQgLyBzeikpKSArIDEuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbkNvb3JkID4gbGVuIC0gMS4wKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGVuIDw9IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICBpbkNvb3JkID0gMC4wO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgc3ogPSBsZW4gLSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIGluQ29vcmQgLT0gbGVuICogZmxvYXQoaW50KGZsb2F0KGluQ29vcmQgLyBzeikpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYW1wKGluQ29vcmQsIDAuMCwgbGVuIC0gMS4wKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgke299ID09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhbXAob3V0Q29vcmQsIDAuMCwgbGVuIC0gMS4wKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0Q29vcmQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxvYXQgcmVhZFdpdGhGaWxsVmFsdWUoaW50IGJhdGNoLCBpbnQgY29vcmRZLCBpbnQgY29vcmRYLFxuICAgICAgICAgICAgICBpbnQgY2hhbm5lbCkge1xuICAgICAgICAgICAgICBmbG9hdCBvdXRwdXRWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKDAgPD0gY29vcmRZICYmIGNvb3JkWSA8ICR7ZX0gJiYgMCA8PSBjb29yZFggJiYgY29vcmRYIDwgJHt0fSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSBnZXRJbWFnZShiYXRjaCwgY29vcmRZLCBjb29yZFgsIGNoYW5uZWwpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gZmxvYXQoJHtyfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgICAgICBmbG9hdCBvdXRwdXRWYWx1ZTtcbiAgICAgICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcbiAgICAgICAgICAgICAgaW50IHkgPSBjb29yZHNbMV07XG4gICAgICAgICAgICAgIGludCBjaGFubmVsID0gY29vcmRzWzNdO1xuICAgICAgICAgICAgICBmbG9hdCB4ZiA9IGZsb2F0KHgpO1xuICAgICAgICAgICAgICBmbG9hdCB5ZiA9IGZsb2F0KHkpO1xuICAgICAgICAgICAgICBmbG9hdCBhMSA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDApO1xuICAgICAgICAgICAgICBmbG9hdCBhMiA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDEpO1xuICAgICAgICAgICAgICBmbG9hdCBhMyA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDIpO1xuICAgICAgICAgICAgICBmbG9hdCBiMSA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDMpO1xuICAgICAgICAgICAgICBmbG9hdCBiMiA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDQpO1xuICAgICAgICAgICAgICBmbG9hdCBiMyA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDUpO1xuICAgICAgICAgICAgICBmbG9hdCBjMSA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDYpO1xuICAgICAgICAgICAgICBmbG9hdCBjMiA9IGdldFRyYW5zZm9ybXMoYmF0Y2gsIDcpO1xuICAgICAgICAgICAgICBmbG9hdCBwcm9qZWN0aW9uID0gYzEgKiB4ZiArIGMyICogeWYgKyAxLjA7XG4gICAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uID09IDAuMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dFZhbHVlID0gZmxvYXQoJHtyfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgaW5YID0gKGExICogeGYgKyBhMiAqIHlmICsgYTMpIC8gcHJvamVjdGlvbjtcbiAgICAgICAgICAgICAgICBmbG9hdCBpblkgPSAoYjEgKiB4ZiArIGIyICogeWYgKyBiMykgLyBwcm9qZWN0aW9uO1xuICAgICAgICAgICAgICAgIGZsb2F0IG1hcFggPSBtYXBDb29yZChpblgsIGZsb2F0KCR7dH0pKTtcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXBZID0gbWFwQ29vcmQoaW5ZLCBmbG9hdCgke2V9KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJHtpfSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICBpbnQgY29vcmRZID0gaW50KHJvdW5kKG1hcFkpKTtcbiAgICAgICAgICAgICAgICAgIGludCBjb29yZFggPSBpbnQocm91bmQobWFwWCkpO1xuICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSByZWFkV2l0aEZpbGxWYWx1ZShiYXRjaCwgY29vcmRZLCBjb29yZFgsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmbG9hdCB5Rmxvb3IgPSBmbG9vcihtYXBZKTtcbiAgICAgICAgICAgICAgICAgIGZsb2F0IHhGbG9vciA9IGZsb29yKG1hcFgpO1xuICAgICAgICAgICAgICAgICAgZmxvYXQgeUNlaWwgPSB5Rmxvb3IgKyAxLjA7XG4gICAgICAgICAgICAgICAgICBmbG9hdCB4Q2VpbCA9IHhGbG9vciArIDEuMDtcbiAgICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlWUZsb29yID0gKHhDZWlsIC0gbWFwWCkgKlxuICAgICAgICAgICAgICAgICAgcmVhZFdpdGhGaWxsVmFsdWUoYmF0Y2gsIGludCh5Rmxvb3IpLCBpbnQoeEZsb29yKSwgY2hhbm5lbCkgK1xuICAgICAgICAgICAgICAgICAgKG1hcFggLSB4Rmxvb3IpICpcbiAgICAgICAgICAgICAgICAgIHJlYWRXaXRoRmlsbFZhbHVlKGJhdGNoLCBpbnQoeUZsb29yKSwgaW50KHhDZWlsKSwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZVlDZWlsID0gKHhDZWlsIC0gbWFwWCkgKlxuICAgICAgICAgICAgICAgICAgcmVhZFdpdGhGaWxsVmFsdWUoYmF0Y2gsIGludCh5Q2VpbCksIGludCh4Rmxvb3IpLCBjaGFubmVsKSArXG4gICAgICAgICAgICAgICAgICAobWFwWCAtIHhGbG9vcikgKlxuICAgICAgICAgICAgICAgICAgcmVhZFdpdGhGaWxsVmFsdWUoYmF0Y2gsIGludCh5Q2VpbCksIGludCh4Q2VpbCksIGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgb3V0cHV0VmFsdWUgPSAoeUNlaWwgLSBtYXBZKSAqIHZhbHVlWUZsb29yICtcbiAgICAgICAgICAgICAgICAgIChtYXBZIC0geUZsb29yKSAqIHZhbHVlWUNlaWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldE91dHB1dChvdXRwdXRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGB9fTtmdW5jdGlvbiBWbGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZTpyLHRyYW5zZm9ybXM6c309dCx7aW50ZXJwb2xhdGlvbjppLGZpbGxNb2RlOm8sZmlsbFZhbHVlOmwsb3V0cHV0U2hhcGU6dX09YSxbcCxkLGMsaF09ci5zaGFwZSxbbSxmXT11IT1udWxsP3U6W2QsY10sZz1bcCxtLGYsaF0sYj1uZXcgQmxlKGQsYyxpLG8sbCxnKTtyZXR1cm4gbi5ydW5XZWJHTFByb2dyYW0oYixbcixzXSxcImZsb2F0MzJcIil9dmFyIFVsZT17a2VybmVsTmFtZTpLdSxiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpWbGV9O2Z1bmN0aW9uIEdsZShlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse2F4aXM6cn09bix7eDpzfT10O2xwKHMsXCJ1bmlxdWVcIiksY29uc29sZS53YXJuKFwiV0FSTklORzogXCIsXCJVSSBtaWdodCBiZSBsb2NrZWQgdGVtcG9yYXJpbHkgYXMgZGF0YSBpcyBiZWluZyBkb3dubG9hZGVkXCIpO2xldCBpPWEucmVhZFN5bmMocy5kYXRhSWQpLHtvdXRwdXRWYWx1ZXM6byxvdXRwdXRTaGFwZTpsLGluZGljZXM6dX09QlEoaSxyLHMuc2hhcGUscy5kdHlwZSk7cmV0dXJuW2EubWFrZVRlbnNvckluZm8obCxzLmR0eXBlLG8pLGEubWFrZVRlbnNvckluZm8oW3UubGVuZ3RoXSxcImludDMyXCIsdSldfXZhciBIbGU9e2tlcm5lbE5hbWU6SmMsYmFja2VuZE5hbWU6XCJ3ZWJnbFwiLGtlcm5lbEZ1bmM6R2xlfTtmdW5jdGlvbiBqbGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt2YWx1ZTpyfT10LHtheGlzOnN9PWE7czwwJiYocys9ci5zaGFwZS5sZW5ndGgpO2xldCBpPXIsbz1pLnNoYXBlLmxlbmd0aCxsPXIuc2hhcGVbc10sdT1uZXcgQXJyYXkoby0xKSxwPTA7Zm9yKGxldCBmPTA7ZjxvO2YrKylmIT09cyYmKHVbcCsrXT1pLnNoYXBlW2ZdKTtsZXQgZD1bXSxjPW5ldyBBcnJheShvKS5maWxsKDApLGg9aS5zaGFwZS5zbGljZSgpO2hbc109MTtsZXQgbT1uZXcgQXJyYXkobCk7Zm9yKGxldCBmPTA7ZjxtLmxlbmd0aDtmKyspe2Nbc109ZjtsZXQgZz1mcCh7aW5wdXRzOnt4Oml9LGJhY2tlbmQ6bixhdHRyczp7YmVnaW46YyxzaXplOmh9fSksYj1jZSh7aW5wdXRzOnt4Omd9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6dX19KTttW2ZdPWIsZC5wdXNoKGcpfXJldHVybiBkLmZvckVhY2goZj0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyhmKSksbX12YXIgcWxlPXtrZXJuZWxOYW1lOlh1LGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmpsZX0sS2xlPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcInNlZ21lbnRJZHNcIl07bGV0IG49ZS53aW5kb3dTaXplLGE9ZS5iYXRjaFNpemUscj1lLmluU2l6ZSxzPWUubnVtU2VnbWVudHMsaT1zKk1hdGguY2VpbChyL24pO3RoaXMub3V0cHV0U2hhcGU9W2EsaV07bGV0IG89XCIwLjBcIixsPVwic3VtVmFsdWVcIix1PU1hdGguZmxvb3Iobi80KSo0LHA9biU0LGQ9YFxuICAgICAgICBzdW1WYWx1ZSArPSBkb3QodmFsdWVzLCBzZWdGaWx0ZXIpO1xuICAgIGAsYz1cIlwiO3Ilbj4wJiYoYz1gXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gJHtyfSkge1xuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICBgKTtsZXQgaD1cIlwiO3Ilbj4wJiYoaD1gXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gJHtyfSkge1xuICAgICAgICAgIHJldHVybiAtMS4wO1xuICAgICAgICB9XG4gICAgICBgKSx0aGlzLnVzZXJDb2RlPWBcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAke299O1xuXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCBpbklkeCkge1xuICAgICAgICAke2N9XG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IGdldFNlZ21lbnRJZEF0SW5kZXgoaW50IGluSWR4KSB7XG4gICAgICAgICR7aH1cbiAgICAgICAgcmV0dXJuIGdldFNlZ21lbnRJZHMoaW5JZHgpO1xuICAgICAgfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XG4gICAgICAgIGludCBpbk9mZnNldCA9IGludChmbG9vcihmbG9hdChvdXRJZHgpIC8gZmxvYXQoXG4gICAgICAgICAgJHtzfSkpICogZmxvYXQoJHtufSkpO1xuICAgICAgICBpbnQgY3VycmVudFNlZyA9IGludChtb2QoZmxvYXQob3V0SWR4KSwgZmxvYXQoJHtzfSkpKTtcblxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7dX07IGkgKz0gNCkge1xuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAyKSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAzKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwXG4gICAgICAgICAgKTtcblxuICAgICAgICAgICR7ZH1cbiAgICAgICAgfVxuXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgJHt1fTtcbiAgICAgICAgaWYgKCR7cD09PTF9KSB7XG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpbnQgaW5JZHhTZWcgPSBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpO1xuXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgJHtkfVxuICAgICAgICB9IGVsc2UgaWYgKCR7cD09PTJ9KSB7XG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgJHtkfVxuICAgICAgICB9IGVsc2UgaWYgKCR7cD09PTN9KSB7XG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxuICAgICAgICAgICAgMFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAke2R9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KCR7bH0pO1xuICAgICAgfVxuICAgIGB9fTtmdW5jdGlvbiBYbGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsc2VnbWVudElkczpzfT10LHtudW1TZWdtZW50czppfT1hLG89ci5zaGFwZS5sZW5ndGgsbD1bXSx1PTAscD1ULmdldEF4ZXNQZXJtdXRhdGlvbihbdV0sbyksZD1yO3AhPW51bGwmJihkPVNuKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwZXJtOnB9fSksbC5wdXNoKGQpLHU9VC5nZXRJbm5lck1vc3RBeGVzKDEsbylbMF0pO2xldCBjPVQuc2VnbWVudF91dGlsLmNvbXB1dGVPdXRTaGFwZShkLnNoYXBlLHUsaSksaD13LnNpemVGcm9tU2hhcGUoW2Quc2hhcGVbdV1dKSxtPWNlKHtpbnB1dHM6e3g6ZH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTpbLTEsaF19fSk7bC5wdXNoKG0pO2xldCBmPU1tKHIuZHR5cGUpLGc9KHYsSSxOLEMsXyk9PntsZXQgRj12LnNoYXBlWzBdLEQ9di5zaGFwZVsxXSwkPVQuc2VnbWVudF91dGlsLnNlZ09wQ29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKEQsXyksUz17d2luZG93U2l6ZTokLGluU2l6ZTpELGJhdGNoU2l6ZTpGLG51bVNlZ21lbnRzOl99LE09bmV3IEtsZShTLEkpLEI9bi5jb21waWxlQW5kUnVuKE0sW3YsTl0sQyk7aWYobC5wdXNoKEIpLEIuc2hhcGVbMV09PT1fKXJldHVybiBCO2xldCBVPWlGKHtiYWNrZW5kOm4sYXR0cnM6e3N0YXJ0OjAsc3RvcDpfLHN0ZXA6MSxkdHlwZTpcImZsb2F0MzJcIn19KSxIPW9GKHtpbnB1dHM6e3g6VX0sYmFja2VuZDpuLGF0dHJzOntyZXBzOltELyRdfX0pO3JldHVybiBsLnB1c2goVSksbC5wdXNoKEgpLGcoQixJLEgsQyxfKX0sYj1nKG0sXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIixzLGYsaSkseT1jZSh7aW5wdXRzOnt4OmJ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6Y319KSx4PXk7aWYocCE9bnVsbCl7bC5wdXNoKHkpO2xldCB2PVQuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihwKTt4PVNuKHtpbnB1dHM6e3h9LGJhY2tlbmQ6bixhdHRyczp7cGVybTp2fX0pfXJldHVybiBsLmZvckVhY2godj0+bi5kaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ySW5mbyh2KSkseH12YXIgWWxlPXtrZXJuZWxOYW1lOlFjLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOlhsZX0sWmxlPVtSZWUsT2VlLHplZSxWZWUsR2VlLHFlZSxYZWUsWmVlLHR0ZSxhdGUsaXRlLHV0ZSxkdGUsZ3RlLHh0ZSx3dGUsSXRlLEN0ZSxfdGUsRnRlLE10ZSxWdGUsR3RlLEt0ZSxZdGUsbm5lLHJuZSxsbmUsYmVlLGNuZSxnbmUsdm5lLFRuZSxfbmUsRm5lLERuZSxNbmUsem5lLFZuZSxIbmUscW5lLFhuZSxabmUsZWFlLG5hZSxpYWUsbGFlLGNhZSxtYWUsZ2FlLHZhZSxTYWUsRWFlLEZhZSxSYWUsTWFlLFBhZSx6YWUsQmFlLFVhZSxIYWUsWGFlLEphZSx0cmUsYXJlLGlyZSx1cmUsaHJlLGJyZSxnZWUseHJlLG1uZSxrcmUsTnJlLEVyZSx4ZWUsJHJlLE9yZSxMcmUsVnJlLEhyZSxYcmUsSnJlLG5zZSxpc2UsdXNlLGNzZSxmc2UsYnNlLHhzZSxJc2UsTnNlLENzZSxfc2UsRnNlLE1zZSx6c2UsVXNlLFpzZSxrZWUsdGllLHJpZSxvaWUscGllLEp0ZSxoaWUsZmllLGJpZSx2aWUsU2llLHdlZSxUaWUsRWllLEFpZSwkaWUsRGllLFF0ZSxxc2UsT2llLFdpZSxHaWUsU2VlLEtpZSxaaWUsdG9lLHJvZSxsb2UscG9lLGhvZSxnb2UseG9lLGtvZSxOb2UsRW9lLCRvZSxNb2Usem9lLFZvZSxXdGUsWHNlLEhvZSxxb2UsWG9lLFpvZSxRb2UsdGxlLGFsZSxzbGUsb2xlLHBsZSxkbGUsbWxlLGdsZSx4bGUsd2xlLElsZSxObGUsS3NlLEZlZSxFbGUsRmxlLERsZSxPbGUsV2xlLFVsZSwkZWUsSGxlLHFsZSxZbGUsbWllXTtmb3IobGV0IGUgb2YgWmxlKWVkKGUpO3ZhciBRZTsoZnVuY3Rpb24oZSl7ZVtlLmZsb2F0MzI9MF09XCJmbG9hdDMyXCIsZVtlLmludDMyPTFdPVwiaW50MzJcIixlW2UuYm9vbD0yXT1cImJvb2xcIixlW2Uuc3RyaW5nPTNdPVwic3RyaW5nXCIsZVtlLmNvbXBsZXg2ND00XT1cImNvbXBsZXg2NFwifSkoUWV8fChRZT17fSkpO3ZhciBBYzsoZnVuY3Rpb24oZSl7ZVtlLmxpbmVhcj0wXT1cImxpbmVhclwiLGVbZS5yZWx1PTFdPVwicmVsdVwiLGVbZS5yZWx1Nj0yXT1cInJlbHU2XCIsZVtlLnByZWx1PTNdPVwicHJlbHVcIixlW2UubGVha3lyZWx1PTRdPVwibGVha3lyZWx1XCIsZVtlLnNpZ21vaWQ9NV09XCJzaWdtb2lkXCIsZVtlLmVsdT02XT1cImVsdVwifSkoQWN8fChBYz17fSkpO3ZhciBsRjtmdW5jdGlvbiBKbGUoZSl7bEY9ZS53YXNtLmN3cmFwKGlpLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gUWxlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7YTpyLGI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10O2lmKHIuZHR5cGUhPT1cImZsb2F0MzJcInx8cy5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihcIl9GdXNlZE1hdE11bCBmb3Igbm9uIG5vbi1mbG9hdDMyIHRlbnNvcnMgbm90IHlldCBzdXBwb3J0ZWQuXCIpO2xldHt0cmFuc3Bvc2VBOmwsdHJhbnNwb3NlQjp1LGFjdGl2YXRpb246cCxsZWFreXJlbHVBbHBoYTpkfT1hLGM9bi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxoPW4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbT0wO2lmKGkhPW51bGwpe2xldCBfPW4uZGF0YUlkTWFwLmdldChpLmRhdGFJZCk7aWYoXy5zaGFwZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihgX0Z1c2VkTWF0TXVsIG9ubHkgc3VwcG9ydHMgcmFuay0xIGJpYXMgYnV0IGdvdCByYW5rICR7Xy5zaGFwZS5sZW5ndGh9LmApO209Xy5pZH1sZXQgZj1vPT1udWxsPzA6bi5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZCxnPUFjW3BdO2lmKGc9PW51bGwpdGhyb3cgbmV3IEVycm9yKGAke3B9IGFjdGl2YXRpb24gbm90IHlldCBzdXBwb3J0ZWQgZm9yIEZ1c2VkQ29udjJEIGluIHRoZSB3YXNtIGJhY2tlbmQuYCk7bGV0IGI9bD9yLnNoYXBlWzJdOnIuc2hhcGVbMV0seT11P3Muc2hhcGVbMV06cy5zaGFwZVsyXSx4PUp1LmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHIuc2hhcGUuc2xpY2UoMCwtMikscy5zaGFwZS5zbGljZSgwLC0yKSksdj1uLm1ha2VPdXRwdXQoWy4uLngsYix5XSxyLmR0eXBlKSxJPW4uZGF0YUlkTWFwLmdldCh2LmRhdGFJZCkuaWQsTj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShyLnNoYXBlKS5idWZmZXIpLEM9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkocy5zaGFwZSkuYnVmZmVyKTtyZXR1cm4gbEYoYyxOLHIuc2hhcGUubGVuZ3RoLGgsQyxzLnNoYXBlLmxlbmd0aCxsLHUsZyxtLGYsZHx8MCxJKSx2fXZhciBldWU9e2tlcm5lbE5hbWU6aWksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkpsZSxrZXJuZWxGdW5jOlFsZX07ZnVuY3Rpb24gWGUoZSx0KXtsZXQgbjtmdW5jdGlvbiBhKHMpe249cy53YXNtLmN3cmFwKGUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiByKHMpe2xldHtiYWNrZW5kOmksaW5wdXRzOnt4Om99fT1zLGw9aS5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZCx1PWkubWFrZU91dHB1dChvLnNoYXBlLHR8fG8uZHR5cGUpLHA9aS5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZDtyZXR1cm4gdy5zaXplRnJvbVNoYXBlKHUuc2hhcGUpPT09MHx8bihsLFFlW28uZHR5cGVdLHApLHV9cmV0dXJue2tlcm5lbE5hbWU6ZSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6YSxrZXJuZWxGdW5jOnJ9fXZhciB0dWU9WGUoWWwpLG51ZT1YZShOaSksYXVlPVhlKFRpKTtmdW5jdGlvbiBVdChlLHQsbil7bGV0IGE7ZnVuY3Rpb24gcihpKXthPWkud2FzbS5jd3JhcChlLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBzKGkpe2xldHtiYWNrZW5kOm8saW5wdXRzOmx9PWkse2E6dSxiOnB9PWwsZD1vLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkLGM9by5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZCxoPW4hPW51bGw/bjp1LmR0eXBlLG09VC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSh1LnNoYXBlLHAuc2hhcGUpLGY9by5tYWtlT3V0cHV0KG0saCk7aWYody5zaXplRnJvbVNoYXBlKG0pPT09MClyZXR1cm4gZjtsZXQgZz1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh1LnNoYXBlKS5idWZmZXIpLGI9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkocC5zaGFwZSkuYnVmZmVyKSx5PW8uZGF0YUlkTWFwLmdldChmLmRhdGFJZCkuaWQ7cmV0dXJuIGEoZCxnLHUuc2hhcGUubGVuZ3RoLGMsYixwLnNoYXBlLmxlbmd0aCxRZVt1LmR0eXBlXSx5KSxmfXJldHVybntrZXJuZWxOYW1lOmUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnIsa2VybmVsRnVuYzpzfX12YXIgcnVlPSEwLHN1ZT1VdCh2cyxydWUpLHVGO2Z1bmN0aW9uIGl1ZShlKXt1Rj1lLndhc20uY3dyYXAoQ2ksbnVsbCxbXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gb3VlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUsYT1uLm1ha2VPdXRwdXQodFswXS5zaGFwZSx0WzBdLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUoYS5zaGFwZSk9PT0wKXJldHVybiBhO2xldCByPXQubWFwKG89Pm4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQpLHM9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkocikuYnVmZmVyKSxpPW4uZGF0YUlkTWFwLmdldChhLmRhdGFJZCkuaWQ7cmV0dXJuIHVGKHMsci5sZW5ndGgsUWVbYS5kdHlwZV0saSksYX12YXIgbHVlPXtrZXJuZWxOYW1lOkNpLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzppdWUsa2VybmVsRnVuYzpvdWV9O2Z1bmN0aW9uIEdmKGUpe2xldHtpbnB1dHM6e3g6dH0sYmFja2VuZDpufT1lO2lmKHQuZHR5cGU9PT1cInN0cmluZ1wiKXJldHVybiBibihuLnJlYWRTeW5jKHQuZGF0YUlkKSx0LnNoYXBlLHQuZHR5cGUpO2xldCBhPW4ubWFrZU91dHB1dCh0LnNoYXBlLHQuZHR5cGUpLHI9bi50eXBlZEFycmF5RnJvbUhlYXAodCk7cmV0dXJuIG4udHlwZWRBcnJheUZyb21IZWFwKGEpLnNldChyKSxhfXZhciB1dWU9e2tlcm5lbE5hbWU6ZW8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpHZn0scEY7ZnVuY3Rpb24gcHVlKGUpe3BGPWUud2FzbS5jd3JhcChDcixudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHlzKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSxbcixzXT1kdWUodC54LnNoYXBlLGEucGVybSksaT0hMDtmb3IobGV0IG09MDttPHMubGVuZ3RoO20rKylzW21dIT09bSYmKGk9ITEpO2xldCBvPWN1ZSh0Lnguc2hhcGUsYS5wZXJtKSxsPXtkYXRhSWQ6dC54LmRhdGFJZCxzaGFwZTpyLGR0eXBlOnQueC5kdHlwZX07aWYoaSl7bGV0IG09R2Yoe2lucHV0czp0LGJhY2tlbmQ6bn0pO3JldHVybiBtLnNoYXBlPW8sbX1sZXQgdT1uLm1ha2VPdXRwdXQobyxsLmR0eXBlKSxwPW4uZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQsZD1uLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkLGM9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkocykuYnVmZmVyKSxoPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KGwuc2hhcGUpLmJ1ZmZlcik7cmV0dXJuIHBGKHAsaCxsLnNoYXBlLmxlbmd0aCxRZVtsLmR0eXBlXSxkLGMscy5sZW5ndGgpLHV9ZnVuY3Rpb24gY3VlKGUsdCl7bGV0IG49bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IGE9MDthPG4ubGVuZ3RoO2ErKyluW2FdPWVbdFthXV07cmV0dXJuIG59ZnVuY3Rpb24gZHVlKGUsdCl7bGV0IG49W10sYT1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcillW3JdIT09MSYmbi5wdXNoKGVbcl0pLGVbdFtyXV0hPT0xJiZhLnB1c2godFtyXSk7Zm9yKGxldCByPTA7cjxhLmxlbmd0aDsrK3Ipe2xldCBzPS0xO2ZvcihsZXQgaT0wO2k8YS5sZW5ndGg7KytpKWFbaV0+PXImJihzPT09LTF8fGFbc10+YVtpXSkmJihzPWkpO2Fbc109cn1yZXR1cm5bbixhXX12YXIgaHVlPXtrZXJuZWxOYW1lOkNyLGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6eXMsc2V0dXBGdW5jOnB1ZX07ZnVuY3Rpb24gRHMoZSx0LG4pe2xldCBhPWUuc2hhcGUscj1lLnNoYXBlLmxlbmd0aCxzPXcucGFyc2VBeGlzUGFyYW0odCxhKSxpPXMsbz1ULmdldEF4ZXNQZXJtdXRhdGlvbihpLHIpLGw9bnVsbCx1PSExO2lmKG8hPW51bGwpe2xldCBwPW5ldyBBcnJheShyKTtmb3IobGV0IGM9MDtjPHAubGVuZ3RoO2MrKylwW2NdPWFbb1tjXV07aT1ULmdldElubmVyTW9zdEF4ZXMoaS5sZW5ndGgsciksbD15cyh7aW5wdXRzOnt4OmV9LGF0dHJzOntwZXJtOm99LGJhY2tlbmQ6bn0pO2xldCBkPW4uZGF0YUlkTWFwLmdldChlLmRhdGFJZCkuaWQ7bi5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZCE9PWQmJih1PSEwKX1yZXR1cm57dHJhbnNwb3NlZDpsLG9yaWdpbmFsQXhlczpzLGF4ZXM6aSxpbnB1dFdhc1RyYW5zcG9zZWQ6dX19dmFyIGNGO2Z1bmN0aW9uIG11ZShlKXtjRj1lLndhc20uY3dyYXAoWmwsbnVsbCxbXCJudW1iZXIsIG51bWJlciwgbnVtYmVyXCJdKX1mdW5jdGlvbiBmdWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtheGlzOnIsa2VlcERpbXM6c309YSx7eDppfT1uLG89dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxsPWkse3RyYW5zcG9zZWQ6dSxheGVzOnAsb3JpZ2luYWxBeGVzOmQsaW5wdXRXYXNUcmFuc3Bvc2VkOmN9PURzKGkscix0KTtpZihjKXtsZXQgeT10LmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkO2w9dSxvPXl9bGV0IGg9bC5zaGFwZS5sZW5ndGg7VC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcImFsbFwiLHAsaCk7bGV0W20sZl09VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGwuc2hhcGUscCksZz13LnNpemVGcm9tU2hhcGUoZiksYj10Lm1ha2VPdXRwdXQobSxpLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUobC5zaGFwZSkhPT0wKXtsZXQgeT10LmRhdGFJZE1hcC5nZXQoYi5kYXRhSWQpLmlkO2NGKG8sZyx5KX1pZihjJiZ0LmRpc3Bvc2VEYXRhKHUuZGF0YUlkKSxzKXtsZXQgeT1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKGIuc2hhcGUsZCk7Yi5zaGFwZT15fXJldHVybiBifXZhciBndWU9e2tlcm5lbE5hbWU6WmwsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOm11ZSxrZXJuZWxGdW5jOmZ1ZX0sZEY7ZnVuY3Rpb24gYnVlKGUpe2RGPWUud2FzbS5jd3JhcChKbCxudWxsLFtcIm51bWJlciwgbnVtYmVyLCBudW1iZXJcIl0pfWZ1bmN0aW9uIHl1ZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2F4aXM6cixrZWVwRGltczpzfT1hLHt4Oml9PW4sbz10LmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLGw9aSx7dHJhbnNwb3NlZDp1LGF4ZXM6cCxvcmlnaW5hbEF4ZXM6ZCxpbnB1dFdhc1RyYW5zcG9zZWQ6Y309RHMoaSxyLHQpO2lmKGMpe2xldCB5PXQuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQ7bD11LG89eX1sZXQgaD1sLnNoYXBlLmxlbmd0aDtULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiYW55XCIscCxoKTtsZXRbbSxmXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobC5zaGFwZSxwKSxnPXcuc2l6ZUZyb21TaGFwZShmKSxiPXQubWFrZU91dHB1dChtLGkuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZShsLnNoYXBlKSE9PTApe2xldCB5PXQuZGF0YUlkTWFwLmdldChiLmRhdGFJZCkuaWQ7ZEYobyxnLHkpfWlmKGMmJnQuZGlzcG9zZURhdGEodS5kYXRhSWQpLHMpe2xldCB5PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oYi5zaGFwZSxkKTtiLnNoYXBlPXl9cmV0dXJuIGJ9dmFyIHh1ZT17a2VybmVsTmFtZTpKbCxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6YnVlLGtlcm5lbEZ1bmM6eXVlfTtmdW5jdGlvbiBoRihlKXtsZXQgdDtmdW5jdGlvbiBuKHIpe3Q9ci53YXNtLmN3cmFwKGUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gYShyKXtsZXR7YmFja2VuZDpzLGlucHV0czppLGF0dHJzOm99PXIse2F4aXM6bH09byx7eDp1fT1pLHA9cy5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCxkPXAsYz11LHt0cmFuc3Bvc2VkOmgsYXhlczptLGlucHV0V2FzVHJhbnNwb3NlZDpmfT1Ecyh1LGwscyk7aWYoZil7bGV0IEk9cy5kYXRhSWRNYXAuZ2V0KGguZGF0YUlkKS5pZDtJIT09cCYmKGM9aCxkPUkpfWxldCBnPWMuc2hhcGUuc2xpY2UoMCwtMSksYj1zLm1ha2VPdXRwdXQoZyxcImludDMyXCIpLHk9cy5kYXRhSWRNYXAuZ2V0KGIuZGF0YUlkKS5pZCx4PXcuc2l6ZUZyb21TaGFwZShiLnNoYXBlKSx2PWMuc2hhcGVbbVswXV07cmV0dXJuIHQoZCxRZVtjLmR0eXBlXSx4LHYseSksZiYmcy5kaXNwb3NlRGF0YShoLmRhdGFJZCksYn1yZXR1cm57a2VybmVsTmFtZTplLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpuLGtlcm5lbEZ1bmM6YX19dmFyIHZ1ZT1oRihRbCksd3VlPWhGKGV1KSxrdWU9WGUoRWkpLEl1ZT1YZShfaSksU3VlPVhlKEFpKSxOdWU9VXQoJGksITEpLFR1ZT1YZShGaSksbUY7ZnVuY3Rpb24gQ3VlKGUpe21GPWUud2FzbS5jd3JhcChEaSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBFdWUoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHI9dC54LHM9YS5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCx7ZmlsdGVyU2l6ZTppLHN0cmlkZXM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dX09bixwPVQuY29tcHV0ZVBvb2wyREluZm8oci5zaGFwZSxpLG8sMSxsLHUpLGQ9cC5maWx0ZXJIZWlnaHQsYz1wLmZpbHRlcldpZHRoLGg9cC5wYWRJbmZvLnRvcCxtPXAucGFkSW5mby5yaWdodCxmPXAucGFkSW5mby5ib3R0b20sZz1wLnBhZEluZm8ubGVmdCxiPXAuc3RyaWRlSGVpZ2h0LHk9cC5zdHJpZGVXaWR0aCx4PXAuaW5DaGFubmVscztpZihwLmRhdGFGb3JtYXQhPT1cImNoYW5uZWxzTGFzdFwiKXRocm93IG5ldyBFcnJvcihgd2FzbSBiYWNrZW5kIGRvZXMgbm90IHN1cHBvcnQgZGF0YUZvcm1hdDonJHtwLmRhdGFGb3JtYXR9Jy4gUGxlYXNlIHVzZSAnY2hhbm5lbHNMYXN0Jy5gKTtpZihwLmRpbGF0aW9uV2lkdGghPT0xfHxwLmRpbGF0aW9uSGVpZ2h0IT09MSl0aHJvdyBuZXcgRXJyb3IoYHdhcyBiYWNrZW5kIG9ubHkgc3VwcG9ydHMgYXZlcmFnZSBwb29saW5nIHdpdGggZGlsYXRpb24gPSBbMSwgMV0sIGdvdCBbJHtwLmRpbGF0aW9uSGVpZ2h0fSwgJHtwLmRpbGF0aW9uV2lkdGh9XS5gKTtsZXQgdj1hLm1ha2VPdXRwdXQocC5vdXRTaGFwZSxcImZsb2F0MzJcIiksST1hLmRhdGFJZE1hcC5nZXQodi5kYXRhSWQpLmlkO3JldHVybiBtRihzLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdLGQsYyxoLG0sZixnLGIseSx4LEkpLHZ9dmFyIF91ZT17a2VybmVsTmFtZTpEaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6Q3VlLGtlcm5lbEZ1bmM6RXVlfSxmRjtmdW5jdGlvbiBBdWUoZSl7ZkY9ZS53YXNtLmN3cmFwKFwiQXZnUG9vbDNEXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEZ1ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZmlsdGVyU2l6ZTpzLHN0cmlkZXM6aSxwYWQ6byxkaW1Sb3VuZGluZ01vZGU6bCxkYXRhRm9ybWF0OnV9PWEscD1ULmNvbXB1dGVQb29sM0RJbmZvKHIuc2hhcGUscyxpLDEsbyxsLHUpLGQ9bi5tYWtlT3V0cHV0KHAub3V0U2hhcGUsci5kdHlwZSk7cmV0dXJuIGZGKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZCxwLmJhdGNoU2l6ZSxwLmluQ2hhbm5lbHMscC5pbkRlcHRoLHAuaW5IZWlnaHQscC5pbldpZHRoLHAub3V0RGVwdGgscC5vdXRIZWlnaHQscC5vdXRXaWR0aCxwLnN0cmlkZURlcHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkRlcHRoLHAuZGlsYXRpb25IZWlnaHQscC5kaWxhdGlvbldpZHRoLHAuZWZmZWN0aXZlRmlsdGVyRGVwdGgscC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQscC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwLnBhZEluZm8uZnJvbnQscC5wYWRJbmZvLnRvcCxwLnBhZEluZm8ubGVmdCksZH12YXIgJHVlPXtrZXJuZWxOYW1lOnR1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpBdWUsa2VybmVsRnVuYzpGdWV9LGdGO2Z1bmN0aW9uIER1ZShlKXtnRj1lLndhc20uY3dyYXAoXCJBdmdQb29sM0RHcmFkXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFJ1ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCx7ZmlsdGVyU2l6ZTppLHN0cmlkZXM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dX09YSxwPVQuY29tcHV0ZVBvb2wzREluZm8ocy5zaGFwZSxpLG8sMSxsLHUpLGQ9bi5tYWtlT3V0cHV0KHMuc2hhcGUscy5kdHlwZSk7cmV0dXJuIGdGKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZCxwLmJhdGNoU2l6ZSxwLmluQ2hhbm5lbHMscC5pbkRlcHRoLHAuaW5IZWlnaHQscC5pbldpZHRoLHAub3V0RGVwdGgscC5vdXRIZWlnaHQscC5vdXRXaWR0aCxwLnN0cmlkZURlcHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkRlcHRoLHAuZGlsYXRpb25IZWlnaHQscC5kaWxhdGlvbldpZHRoLHAuZWZmZWN0aXZlRmlsdGVyRGVwdGgscC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQscC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwLnBhZEluZm8uZnJvbnQscC5wYWRJbmZvLnRvcCxwLnBhZEluZm8ubGVmdCxwLmZpbHRlckRlcHRoLHAuZmlsdGVySGVpZ2h0LHAuZmlsdGVyV2lkdGgpLGR9dmFyIE11ZT17a2VybmVsTmFtZTpSYyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6RHVlLGtlcm5lbEZ1bmM6UnVlfSxiRjtmdW5jdGlvbiBPdWUoZSl7YkY9ZS53YXNtLmN3cmFwKFwiQXZnUG9vbEdyYWRcIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFB1ZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCx7ZmlsdGVyU2l6ZTppLHN0cmlkZXM6byxwYWQ6bH09YSx1PVQuY29tcHV0ZVBvb2wyREluZm8ocy5zaGFwZSxpLG8sMSxsKSxwPW4ubWFrZU91dHB1dChzLnNoYXBlLHMuZHR5cGUpO3JldHVybiBiRihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQsdS5iYXRjaFNpemUsdS5pbkNoYW5uZWxzLHUuaW5IZWlnaHQsdS5pbldpZHRoLHUub3V0SGVpZ2h0LHUub3V0V2lkdGgsdS5zdHJpZGVIZWlnaHQsdS5zdHJpZGVXaWR0aCx1LmRpbGF0aW9uSGVpZ2h0LHUuZGlsYXRpb25XaWR0aCx1LmVmZmVjdGl2ZUZpbHRlckhlaWdodCx1LmVmZmVjdGl2ZUZpbHRlcldpZHRoLHUucGFkSW5mby50b3AsdS5wYWRJbmZvLmxlZnQsdS5maWx0ZXJIZWlnaHQsdS5maWx0ZXJXaWR0aCkscH12YXIgTHVlPXtrZXJuZWxOYW1lOkRjLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpPdWUsa2VybmVsRnVuYzpQdWV9O2Z1bmN0aW9uIHpuKGUpe2xldHtpbnB1dHM6dCxhdHRyczpufT1lLHt4OmF9PXQse3NoYXBlOnJ9PW4scz13LnNpemVGcm9tU2hhcGUoYS5zaGFwZSksaT13LmluZmVyRnJvbUltcGxpY2l0U2hhcGUocixzKTtyZXR1cm4gdy5hc3NlcnQocz09PXcuc2l6ZUZyb21TaGFwZShpKSwoKT0+YG5ldyBzaGFwZTogJHtpfSwgb2xkIHNoYXBlOiAke2Euc2hhcGV9LiBOZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLmApLGUuYmFja2VuZC5pbmNSZWYoYS5kYXRhSWQpLHtkYXRhSWQ6YS5kYXRhSWQsc2hhcGU6aSxkdHlwZTphLmR0eXBlfX12YXIgenVlPXtrZXJuZWxOYW1lOlJ1LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6em59LHlGO2Z1bmN0aW9uIFd1ZShlKXt5Rj1lLndhc20uY3dyYXAoUmksbnVsbCxbXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gQnVlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7YTpyLGI6c309dCx7dHJhbnNwb3NlQTppLHRyYW5zcG9zZUI6b309YTtpZihyLmR0eXBlIT09XCJmbG9hdDMyXCJ8fHMuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE1hdE11bCBmb3Igbm9uIG5vbi1mbG9hdDMyIHRlbnNvcnMgbm90IHlldCBzdXBwb3J0ZWQuXCIpO2xldCBsPXIuc2hhcGUubGVuZ3RoLHU9cy5zaGFwZS5sZW5ndGgscD1pP3Iuc2hhcGVbbC0yXTpyLnNoYXBlW2wtMV0sZD1vP3Muc2hhcGVbdS0xXTpzLnNoYXBlW3UtMl0sYz1pP3Iuc2hhcGVbbC0xXTpyLnNoYXBlW2wtMl0saD1vP3Muc2hhcGVbdS0yXTpzLnNoYXBlW3UtMV0sbT1yLnNoYXBlLnNsaWNlKDAsLTIpLGY9cy5zaGFwZS5zbGljZSgwLC0yKSxnPXcuc2l6ZUZyb21TaGFwZShtKSxiPXcuc2l6ZUZyb21TaGFwZShmKSx5PUp1LmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHIuc2hhcGUuc2xpY2UoMCwtMikscy5zaGFwZS5zbGljZSgwLC0yKSkuY29uY2F0KFtjLGhdKTt3LmFzc2VydChwPT09ZCwoKT0+YEVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzICgke3B9KSBhbmQgKCR7ZH0pIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgJHtyLnNoYXBlfSBhbmQgJHtzLnNoYXBlfSBhbmQgdHJhbnNwb3NlQT0ke2l9IGFuZCB0cmFuc3Bvc2VCPSR7b30gbXVzdCBtYXRjaC5gKTtsZXQgeD1pP1tnLHAsY106W2csYyxwXSx2PW8/W2IsaCxkXTpbYixkLGhdLEk9em4oe2lucHV0czp7eDpyfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnh9fSksTj16bih7aW5wdXRzOnt4OnN9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6dn19KSxDPW4uZGF0YUlkTWFwLmdldChJLmRhdGFJZCkuaWQsXz1uLmRhdGFJZE1hcC5nZXQoTi5kYXRhSWQpLmlkLEY9aT9JLnNoYXBlWzJdOkkuc2hhcGVbMV0sRD1vP04uc2hhcGVbMV06Ti5zaGFwZVsyXSwkPU1hdGgubWF4KGcsYiksUz1uLm1ha2VPdXRwdXQoWyQsRixEXSxJLmR0eXBlKSxNPW4uZGF0YUlkTWFwLmdldChTLmRhdGFJZCkuaWQsQj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShJLnNoYXBlKS5idWZmZXIpLFU9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoTi5zaGFwZSkuYnVmZmVyKTtyZXR1cm4geUYoQyxCLEkuc2hhcGUubGVuZ3RoLF8sVSxOLnNoYXBlLmxlbmd0aCxpLG8sTSksbi5kaXNwb3NlRGF0YShJLmRhdGFJZCksbi5kaXNwb3NlRGF0YShOLmRhdGFJZCksUy5zaGFwZT15LFN9dmFyIFZ1ZT17a2VybmVsTmFtZTpSaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6V3VlLGtlcm5lbEZ1bmM6QnVlfTtmdW5jdGlvbiBJaShlKXtsZXR7aW5wdXRzOnt4OnR9LGF0dHJzOntiZWdpbjpuLHNpemU6YX0sYmFja2VuZDpyfT1lLFtzLGldPUt0LnBhcnNlU2xpY2VQYXJhbXModCxuLGEpLG89S3QuaXNTbGljZUNvbnRpbm91cyh0LnNoYXBlLHMsaSksbD1yLnJlYWRTeW5jKHQuZGF0YUlkKSx1PXIubWFrZU91dHB1dChpLHQuZHR5cGUpLHA9dy5jb21wdXRlU3RyaWRlcyh0LnNoYXBlKSxkPXIuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCk7aWYobyl7bGV0IG09S3QuY29tcHV0ZUZsYXRPZmZzZXQocyxwKTtyZXR1cm4gdC5kdHlwZT09PVwic3RyaW5nXCI/ZC5zdHJpbmdCeXRlcz1sLnNsaWNlKG0sbSt3LnNpemVGcm9tU2hhcGUoaSkpOnIudHlwZWRBcnJheUZyb21IZWFwKHUpLnNldChsLnN1YmFycmF5KG0sbSt3LnNpemVGcm9tU2hhcGUoaSkpKSx1fWlmKHQuZHR5cGU9PT1cInN0cmluZ1wiKXtsZXQgbT11bShsLHMsaSx0LnNoYXBlLHQuZHR5cGUpO3JldHVybiBkLnN0cmluZ0J5dGVzPW0sdX1sZXQgYz1yLnR5cGVkQXJyYXlGcm9tSGVhcCh1KSxoPXQuc2hhcGUubGVuZ3RoO2lmKGg9PT0yKVV1ZShsLHBbMF0sYyxzLGkpO2Vsc2UgaWYoaD09PTMpR3VlKGwscFswXSxwWzFdLGMscyxpKTtlbHNlIGlmKGg9PT00KUh1ZShsLHBbMF0scFsxXSxwWzJdLGMscyxpKTtlbHNle2xldCBtPXVtKGwscyxpLHQuc2hhcGUsdC5kdHlwZSk7Yy5zZXQobSl9cmV0dXJuIHV9ZnVuY3Rpb24gVXVlKGUsdCxuLGEscil7bGV0IHM9MCxpPWFbMF0sbz1hWzFdLGw9aStyWzBdO2ZvcihsZXQgdT1pO3U8bDt1Kyspe2xldCBwPXUqdCtvO24uc2V0KGUuc3ViYXJyYXkocCxwK3JbMV0pLHMpLHMrPXJbMV19fWZ1bmN0aW9uIEd1ZShlLHQsbixhLHIscyl7bGV0IGk9MCxvPXJbMF0sbD1yWzFdLHU9clsyXSxwPW8rc1swXSxkPWwrc1sxXTtmb3IobGV0IGM9bztjPHA7YysrKWZvcihsZXQgaD1sO2g8ZDtoKyspe2xldCBtPWMqdCtoKm4rdTthLnNldChlLnN1YmFycmF5KG0sbStzWzJdKSxpKSxpKz1zWzJdfX1mdW5jdGlvbiBIdWUoZSx0LG4sYSxyLHMsaSl7bGV0IG89MCxsPXNbMF0sdT1zWzFdLHA9c1syXSxkPWwraVswXSxjPXUraVsxXSxoPXAraVsyXSxtPXNbM107Zm9yKGxldCBmPWw7ZjxkO2YrKylmb3IobGV0IGc9dTtnPGM7ZysrKWZvcihsZXQgYj1wO2I8aDtiKyspe2xldCB5PWYqdCtnKm4rYiphK207ci5zZXQoZS5zdWJhcnJheSh5LHkraVszXSksbyksbys9aVszXX19dmFyIGp1ZT17a2VybmVsTmFtZTpCdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOklpfTtmdW5jdGlvbiBxdWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2Jsb2NrU2hhcGU6cyxjcm9wczppfT1hLG89cy5yZWR1Y2UoKGIseSk9PmIqeSksbD1ULmdldFJlc2hhcGVkKHIuc2hhcGUscyxvKSx1PVQuZ2V0UGVybXV0ZWQobC5sZW5ndGgscy5sZW5ndGgpLHA9VC5nZXRSZXNoYXBlZFBlcm11dGVkKHIuc2hhcGUscyxvKSxkPVQuZ2V0U2xpY2VCZWdpbkNvb3JkcyhpLHMubGVuZ3RoKSxjPVQuZ2V0U2xpY2VTaXplKHAsaSxzLmxlbmd0aCksaD16bih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6bH19KSxtPXlzKHtpbnB1dHM6e3g6aH0sYmFja2VuZDpuLGF0dHJzOntwZXJtOnV9fSksZj16bih7aW5wdXRzOnt4Om19LGJhY2tlbmQ6bixhdHRyczp7c2hhcGU6cH19KSxnPUlpKHtpbnB1dHM6e3g6Zn0sYmFja2VuZDpuLGF0dHJzOntiZWdpbjpkLHNpemU6Y319KTtyZXR1cm4gbi5kaXNwb3NlRGF0YShoLmRhdGFJZCksbi5kaXNwb3NlRGF0YShtLmRhdGFJZCksbi5kaXNwb3NlRGF0YShmLmRhdGFJZCksZ312YXIgS3VlPXtrZXJuZWxOYW1lOm51LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6cXVlfSx4RjtmdW5jdGlvbiBYdWUoZSl7eEY9ZS53YXNtLmN3cmFwKGF1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcImJvb2xlYW5cIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFl1ZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3g6cix3ZWlnaHRzOnN9PW4se3NpemU6aX09YSxvPXMuc2hhcGUucmVkdWNlKChkLGMpPT5kKmMsMSkhPT0wLGw9ci5zaGFwZS5sZW5ndGg9PT0xP1tpXTpbci5zaGFwZVswXSxpXSx1PXQubWFrZU91dHB1dChsLHMuZHR5cGUpO2Z1bmN0aW9uIHAoZCl7cmV0dXJuIHQuZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWR9cmV0dXJuIHhGKHAociksaSxvLHAocyksUWVbcy5kdHlwZV0scCh1KSksdX12YXIgWnVlPXtrZXJuZWxOYW1lOmF1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpYdWUsa2VybmVsRnVuYzpZdWV9LEp1ZT0hMCxRdWU9VXQocnUsSnVlKTtmdW5jdGlvbiBlcGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7czA6YSxzMTpyfT10LHM9bi50eXBlZEFycmF5RnJvbUhlYXAoYSksaT1uLnR5cGVkQXJyYXlGcm9tSGVhcChyKSxvPVQuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoQXJyYXkuZnJvbShzKSxBcnJheS5mcm9tKGkpKTtyZXR1cm4gbi5tYWtlT3V0cHV0KFtvLmxlbmd0aF0sXCJpbnQzMlwiLHZvaWQgMCxuZXcgSW50MzJBcnJheShvKSl9dmFyIHRwZT17a2VybmVsTmFtZTpNYyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOmVwZX07ZnVuY3Rpb24gUnMoZSl7bGV0e2lucHV0czp7eDp0fSxhdHRyczp7ZHR5cGU6bn0sYmFja2VuZDphfT1lLHI9YS5tYWtlT3V0cHV0KHQuc2hhcGUsbikscz1hLnR5cGVkQXJyYXlGcm9tSGVhcCh0KTtyZXR1cm4gYS50eXBlZEFycmF5RnJvbUhlYXAocikuc2V0KHMpLHJ9dmFyIG5wZT17a2VybmVsTmFtZTpNaSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOlJzfSxhcGU9WGUoT2kpLHZGO2Z1bmN0aW9uIHJwZShlKXt2Rj1lLndhc20uY3dyYXAod3MsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHNwZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7Y2xpcFZhbHVlTWluOnMsY2xpcFZhbHVlTWF4Oml9PWEsbz1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLGw9bi5tYWtlT3V0cHV0KHIuc2hhcGUsci5kdHlwZSksdT1uLmRhdGFJZE1hcC5nZXQobC5kYXRhSWQpLmlkO3JldHVybiB2RihvLHMsaSx1KSxsfXZhciBpcGU9e2tlcm5lbE5hbWU6d3MsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnJwZSxrZXJuZWxGdW5jOnNwZX07ZnVuY3Rpb24gd0YoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSxhPXcucGFyc2VBeGlzUGFyYW0oZS5hdHRycy5heGlzLHRbMF0uc2hhcGUpWzBdLHI9dC5tYXAoaD0+aC5zaGFwZSk7VC5hc3NlcnRQYXJhbXNDb25zaXN0ZW50KHIsYSk7bGV0IHM9VC5jb21wdXRlT3V0U2hhcGUodC5tYXAoaD0+aC5zaGFwZSksYSksaT10LmZpbHRlcihoPT53LnNpemVGcm9tU2hhcGUoaC5zaGFwZSk+MCk7aWYoaS5sZW5ndGg9PT0xKXJldHVybiBHZih7aW5wdXRzOnt4OmlbMF19LGJhY2tlbmQ6bn0pO2xldCBvPW4ubWFrZU91dHB1dChzLHRbMF0uZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZShzKT09PTApcmV0dXJuIG87aWYoaVswXS5kdHlwZT09PVwic3RyaW5nXCIpe2xldCBoPWkubWFwKHg9PntsZXQgdj1bLTEsdy5zaXplRnJvbVNoYXBlKHguc2hhcGUuc2xpY2UoYSkpXTtyZXR1cm4gem4oe2lucHV0czp7eH0sYmFja2VuZDpuLGF0dHJzOntzaGFwZTp2fX0pfSksbT1oLm1hcCh4PT4oe3ZhbHM6bi5yZWFkU3luYyh4LmRhdGFJZCksc2hhcGU6eC5zaGFwZX0pKTtzPVQuY29tcHV0ZU91dFNoYXBlKGgubWFwKHg9Pnguc2hhcGUpLDEpO2xldCBmPWhbMF0uc2hhcGVbMF09PT0xLGc9TDEobSxzLHRbMF0uZHR5cGUsZiksYj1ULmNvbXB1dGVPdXRTaGFwZShpLm1hcCh4PT54LnNoYXBlKSxhKTtvLnNoYXBlPWI7bGV0IHk9bi5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKTtyZXR1cm4geS5zdHJpbmdCeXRlcz1ULmZyb21TdHJpbmdBcnJheVRvVWludDgoZyksaC5mb3JFYWNoKHg9Pm4uZGlzcG9zZURhdGEoeC5kYXRhSWQpKSxvfWxldCBsPXcuc2l6ZUZyb21TaGFwZShpWzBdLnNoYXBlLnNsaWNlKDAsYSkpLHU9MCxwPWkubWFwKGg9PntsZXQgbT13LnNpemVGcm9tU2hhcGUoaC5zaGFwZS5zbGljZShhKSk7cmV0dXJuIHUrPW0sbX0pLGQ9aS5tYXAoaD0+bi50eXBlZEFycmF5RnJvbUhlYXAoaCkpLGM9bi50eXBlZEFycmF5RnJvbUhlYXAobyk7Zm9yKGxldCBoPTA7aDxsO2grKyl7bGV0IG09aCp1O2ZvcihsZXQgZj0wO2Y8ZC5sZW5ndGg7ZisrKXtsZXQgZz1wW2ZdLGI9aCpnLHk9ZFtmXS5zdWJhcnJheShiLGIrZyk7Yy5zZXQoeSxtKSxtKz1nfX1yZXR1cm4gb312YXIgb3BlPXtrZXJuZWxOYW1lOnN1LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6d0Z9LGtGO2Z1bmN0aW9uIGxwZShlKXtrRj1lLndhc20uY3dyYXAoUGksbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHVwZShlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse3g6cixmaWx0ZXI6c309dCxpPWEuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbz1hLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLHtzdHJpZGVzOmwsZGlsYXRpb25zOnUscGFkOnAsZGltUm91bmRpbmdNb2RlOmQsZGF0YUZvcm1hdDpjfT1uLGg9VC5jb252ZXJ0Q29udjJERGF0YUZvcm1hdChjKSxtPVQuY29tcHV0ZUNvbnYyREluZm8oci5zaGFwZSxzLnNoYXBlLGwsdSxwLGQsITEsaCksZj1tLmZpbHRlckhlaWdodCxnPW0uZmlsdGVyV2lkdGgsYj1tLnBhZEluZm8udG9wLHk9bS5wYWRJbmZvLnJpZ2h0LHg9bS5wYWRJbmZvLmJvdHRvbSx2PW0ucGFkSW5mby5sZWZ0LEk9bS5kaWxhdGlvbkhlaWdodCxOPW0uZGlsYXRpb25XaWR0aCxDPW0uc3RyaWRlSGVpZ2h0LF89bS5zdHJpZGVXaWR0aCxGPW0uaW5DaGFubmVscyxEPW0ub3V0Q2hhbm5lbHMsJD1tLnBhZEluZm8udHlwZT09PVwiU0FNRVwiPzE6MDtpZihtLmRhdGFGb3JtYXQhPT1cImNoYW5uZWxzTGFzdFwiKXRocm93IG5ldyBFcnJvcihgd2FzbSBiYWNrZW5kIENvbnYyRCBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQ6JyR7bS5kYXRhRm9ybWF0fScuIFBsZWFzZSB1c2UgJ2NoYW5uZWxzTGFzdCcuYCk7bGV0IFM9YS5tYWtlT3V0cHV0KG0ub3V0U2hhcGUsXCJmbG9hdDMyXCIpLE09YS5kYXRhSWRNYXAuZ2V0KFMuZGF0YUlkKS5pZDtyZXR1cm4ga0YoaSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0sci5zaGFwZVsyXSxvLGYsZyxiLHkseCx2LCQsSSxOLEMsXyxGLEQsTSksU312YXIgcHBlPXtrZXJuZWxOYW1lOlBpLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpscGUsa2VybmVsRnVuYzp1cGV9LElGO2Z1bmN0aW9uIGNwZShlKXtJRj1lLndhc20uY3dyYXAoTGksbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBkcGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtkeTpyLGZpbHRlcjpzfT1uLHtzdHJpZGVzOmkscGFkOm8sZGF0YUZvcm1hdDpsLGRpbVJvdW5kaW5nTW9kZTp1LGlucHV0U2hhcGU6cH09YSxkPTEsYz1ULmNvbnZlcnRDb252MkREYXRhRm9ybWF0KGwpLGg9VC5jb21wdXRlQ29udjJESW5mbyhwLHMuc2hhcGUsaSxkLG8sdSwhMSxjKSx7YmF0Y2hTaXplOm0sZmlsdGVySGVpZ2h0OmYsZmlsdGVyV2lkdGg6ZyxpbkNoYW5uZWxzOmIsaW5IZWlnaHQ6eSxpbldpZHRoOngsb3V0Q2hhbm5lbHM6dixvdXRIZWlnaHQ6SSxvdXRXaWR0aDpOLHN0cmlkZUhlaWdodDpDLHN0cmlkZVdpZHRoOl99PWgsRj1mLTEtaC5wYWRJbmZvLnRvcCxEPWctMS1oLnBhZEluZm8ubGVmdCwkPWguZGF0YUZvcm1hdD09PVwiY2hhbm5lbHNMYXN0XCIsUz13LmNvbXB1dGVTdHJpZGVzKGguaW5TaGFwZSksTT13LmNvbXB1dGVTdHJpZGVzKHIuc2hhcGUpLFtCLFUsSF09dy5jb21wdXRlU3RyaWRlcyhzLnNoYXBlKSxxPVNbMF0sSz0kP1NbMV06U1syXSxaPSQ/U1syXToxLEo9JD8xOlNbMV0sZWU9TVswXSxhZT0kP01bMV06TVsyXSx0ZT0kP01bMl06MSxzZT0kPzE6TVsxXSxpZT10Lm1ha2VPdXRwdXQoaC5pblNoYXBlLFwiZmxvYXQzMlwiKSx2ZT10LmRhdGFJZE1hcC5nZXQoaWUuZGF0YUlkKS5pZCx1ZT10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLHllPXQuZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQ7cmV0dXJuIElGKHVlLHllLG0sZixnLHkseCxiLEksTix2LEMsXyxGLEQsQixVLEgscSxLLFosSixlZSxhZSx0ZSxzZSx2ZSksaWV9dmFyIGhwZT17a2VybmVsTmFtZTpMaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6Y3BlLGtlcm5lbEZ1bmM6ZHBlfSxTRjtmdW5jdGlvbiBtcGUoZSl7U0Y9ZS53YXNtLmN3cmFwKHppLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gZnBlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzfT10LHtzdHJpZGVzOmkscGFkOm8sZGlsYXRpb25zOmx9PWE7aWYoci5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgVGVuc29yIHggbXVzdCBoYXZlIGR0eXBlIGZsb2F0MzIsIGdvdCAke3IuZHR5cGV9YCk7aWYocy5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgVGVuc29yIGZpbHRlciBtdXN0IGhhdmUgZHR5cGUgZmxvYXQzMiwgZ290ICR7cy5kdHlwZX1gKTtsZXQgdT1ULmNvbXB1dGVDb252M0RJbmZvKHIuc2hhcGUscy5zaGFwZSxpLGwsbykscD1uLm1ha2VPdXRwdXQodS5vdXRTaGFwZSxyLmR0eXBlKTtyZXR1cm4gU0Yobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQsdS5iYXRjaFNpemUsdS5pbkRlcHRoLHUuaW5IZWlnaHQsdS5pbldpZHRoLHUuaW5DaGFubmVscyx1Lm91dERlcHRoLHUub3V0SGVpZ2h0LHUub3V0V2lkdGgsdS5vdXRDaGFubmVscyx1LnN0cmlkZURlcHRoLHUuc3RyaWRlSGVpZ2h0LHUuc3RyaWRlV2lkdGgsdS5kaWxhdGlvbkRlcHRoLHUuZGlsYXRpb25IZWlnaHQsdS5kaWxhdGlvbldpZHRoLHUuZmlsdGVyRGVwdGgsdS5maWx0ZXJIZWlnaHQsdS5maWx0ZXJXaWR0aCx1LnBhZEluZm8uZnJvbnQsdS5wYWRJbmZvLnRvcCx1LnBhZEluZm8ubGVmdCkscH12YXIgZ3BlPXtrZXJuZWxOYW1lOnppLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzptcGUsa2VybmVsRnVuYzpmcGV9LE5GO2Z1bmN0aW9uIGJwZShlKXtORj1lLndhc20uY3dyYXAoaXUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB5cGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZHk6c309dCx7c3RyaWRlczppLHBhZDpvLGZpbHRlclNoYXBlOmx9PWE7aWYoci5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgVGVuc29yIGR5IG11c3QgaGF2ZSBkdHlwZSBmbG9hdDMyLCBnb3QgJHtyLmR0eXBlfWApO2lmKHMuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBmaWx0ZXIgbXVzdCBoYXZlIGR0eXBlIGZsb2F0MzIsIGdvdCAke3MuZHR5cGV9YCk7bGV0IHU9VC5jb21wdXRlQ29udjNESW5mbyhyLnNoYXBlLGwsaSwxLG8pLHA9bi5tYWtlT3V0cHV0KHUuZmlsdGVyU2hhcGUscy5kdHlwZSk7cmV0dXJuIE5GKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocC5kYXRhSWQpLmlkLHUuYmF0Y2hTaXplLHUuaW5EZXB0aCx1LmluSGVpZ2h0LHUuaW5XaWR0aCx1LmluQ2hhbm5lbHMsdS5vdXREZXB0aCx1Lm91dEhlaWdodCx1Lm91dFdpZHRoLHUub3V0Q2hhbm5lbHMsdS5zdHJpZGVEZXB0aCx1LnN0cmlkZUhlaWdodCx1LnN0cmlkZVdpZHRoLHUuZGlsYXRpb25EZXB0aCx1LmRpbGF0aW9uSGVpZ2h0LHUuZGlsYXRpb25XaWR0aCx1LmZpbHRlckRlcHRoLHUuZmlsdGVySGVpZ2h0LHUuZmlsdGVyV2lkdGgsdS5wYWRJbmZvLmZyb250LHUucGFkSW5mby50b3AsdS5wYWRJbmZvLmxlZnQpLHB9dmFyIHhwZT17a2VybmVsTmFtZTppdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6YnBlLGtlcm5lbEZ1bmM6eXBlfSxURjtmdW5jdGlvbiB2cGUoZSl7VEY9ZS53YXNtLmN3cmFwKG91LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gd3BlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7ZHk6cixmaWx0ZXI6c309dCx7cGFkOmksc3RyaWRlczpvLGlucHV0U2hhcGU6bH09YTtpZihyLmR0eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgZHkgbXVzdCBoYXZlIGR0eXBlIGZsb2F0MzIsIGdvdCAke3IuZHR5cGV9YCk7aWYocy5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihgVGVuc29yIGZpbHRlciBtdXN0IGhhdmUgZHR5cGUgZmxvYXQzMiwgZ290ICR7cy5kdHlwZX1gKTtsZXQgdT1ULmNvbXB1dGVDb252M0RJbmZvKGwscy5zaGFwZSxvLDEsaSkscD1uLm1ha2VPdXRwdXQodS5pblNoYXBlLHIuZHR5cGUpO3JldHVybiBURihuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZCx1LmJhdGNoU2l6ZSx1LmluRGVwdGgsdS5pbkhlaWdodCx1LmluV2lkdGgsdS5pbkNoYW5uZWxzLHUub3V0RGVwdGgsdS5vdXRIZWlnaHQsdS5vdXRXaWR0aCx1Lm91dENoYW5uZWxzLHUuc3RyaWRlRGVwdGgsdS5zdHJpZGVIZWlnaHQsdS5zdHJpZGVXaWR0aCx1LmRpbGF0aW9uRGVwdGgsdS5kaWxhdGlvbkhlaWdodCx1LmRpbGF0aW9uV2lkdGgsdS5maWx0ZXJEZXB0aCx1LmZpbHRlckhlaWdodCx1LmZpbHRlcldpZHRoLHUucGFkSW5mby5mcm9udCx1LnBhZEluZm8udG9wLHUucGFkSW5mby5sZWZ0KSxwfXZhciBrcGU9e2tlcm5lbE5hbWU6b3UsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnZwZSxrZXJuZWxGdW5jOndwZX0sSXBlPVhlKFdpKSxTcGU9WGUoQmkpLGJ2OyhmdW5jdGlvbihlKXtlW2UuYmlsaW5lYXI9MF09XCJiaWxpbmVhclwiLGVbZS5uZWFyZXN0PTFdPVwibmVhcmVzdFwifSkoYnZ8fChidj17fSkpO3ZhciBDRjtmdW5jdGlvbiBOcGUoZSl7Q0Y9ZS53YXNtLmN3cmFwKHV1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFRwZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse21ldGhvZDpyLGV4dHJhcG9sYXRpb25WYWx1ZTpzLGNyb3BTaXplOml9PWEse2ltYWdlOm8sYm94ZXM6bCxib3hJbmQ6dX09bixwPWwuc2hhcGVbMF0sW2QsY109aSxoPVtwLGQsYyxvLnNoYXBlWzNdXSxtPXQuZGF0YUlkTWFwLmdldChvLmRhdGFJZCksZjtvLmR0eXBlIT09XCJmbG9hdDMyXCImJihmPVJzKHtiYWNrZW5kOnQsaW5wdXRzOnt4Om99LGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KSxtPXQuZGF0YUlkTWFwLmdldChmLmRhdGFJZCkpO2xldCBnPW0uaWQsYj10LmRhdGFJZE1hcC5nZXQobC5kYXRhSWQpLmlkLHk9dC5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCx4PXQubWFrZU91dHB1dChoLFwiZmxvYXQzMlwiKSx2PXQuZGF0YUlkTWFwLmdldCh4LmRhdGFJZCkuaWQsST1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShvLnNoYXBlKS5idWZmZXIpO3JldHVybiBDRihnLGIseSxwLEksZCxjLGJ2W3JdLHMsdiksZiE9bnVsbCYmdC5kaXNwb3NlRGF0YShmLmRhdGFJZCkseH12YXIgQ3BlPXtrZXJuZWxOYW1lOnV1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpOcGUsa2VybmVsRnVuYzpUcGV9LEVGO2Z1bmN0aW9uIEVwZShlKXtFRj1lLndhc20uY3dyYXAobHUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBfcGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxleGNsdXNpdmU6aSxyZXZlcnNlOm99PWEsbD1yLnNoYXBlLmxlbmd0aDt3LmFzc2VydChyLmR0eXBlPT09XCJmbG9hdDMyXCJ8fHIuZHR5cGU9PT1cImludDMyXCIsKCk9PmBjdW1wcm9kIGRvZXMgbm90IHN1cHBvcnQgJHtyLmR0eXBlfSB0ZW5zb3JzIGluIHRoZSBXQVNNIGJhY2tlbmRgKTtsZXQgdT1ULmdldEF4ZXNQZXJtdXRhdGlvbihbc10sbCkscD1yO3UhPT1udWxsJiYocD15cyh7aW5wdXRzOnt4OnJ9LGF0dHJzOntwZXJtOnV9LGJhY2tlbmQ6bn0pKTtsZXQgZD1ULmdldElubmVyTW9zdEF4ZXMoMSxsKVswXTtULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwiY3VtcHJvZFwiLFtkXSxsKTtsZXQgYz1uLm1ha2VPdXRwdXQocC5zaGFwZSxwLmR0eXBlKSxoPXAuc2hhcGVbZF0sbT1uLmRhdGFJZE1hcC5nZXQocC5kYXRhSWQpLmlkLGY9bi5kYXRhSWRNYXAuZ2V0KGMuZGF0YUlkKS5pZDtFRihtLGk/MTowLG8/MTowLGgsZixRZVtyLmR0eXBlXSk7bGV0IGc9YztpZih1IT09bnVsbCl7bGV0IGI9VC5nZXRVbmRvQXhlc1Blcm11dGF0aW9uKHUpO2c9eXMoe2lucHV0czp7eDpjfSxhdHRyczp7cGVybTpifSxiYWNrZW5kOm59KSxuLmRpc3Bvc2VEYXRhKHAuZGF0YUlkKSxuLmRpc3Bvc2VEYXRhKGMuZGF0YUlkKX1yZXR1cm4gZ312YXIgQXBlPXtrZXJuZWxOYW1lOmx1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpFcGUsa2VybmVsRnVuYzpfcGV9LF9GO2Z1bmN0aW9uIEZwZShlKXtfRj1lLndhc20uY3dyYXAoVmksbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiAkcGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2F4aXM6cyxleGNsdXNpdmU6aSxyZXZlcnNlOm99PWEsbD1yLnNoYXBlLmxlbmd0aDt3LmFzc2VydChyLmR0eXBlPT09XCJmbG9hdDMyXCJ8fHIuZHR5cGU9PT1cImludDMyXCIsKCk9PmBjdW1zdW0gZG9lcyBub3Qgc3VwcG9ydCAke3IuZHR5cGV9IHRlbnNvcnMgaW4gdGhlIFdBU00gYmFja2VuZGApO2xldCB1PVQuZ2V0QXhlc1Blcm11dGF0aW9uKFtzXSxsKSxwPXI7dSE9PW51bGwmJihwPXlzKHtpbnB1dHM6e3g6cn0sYXR0cnM6e3Blcm06dX0sYmFja2VuZDpufSkpO2xldCBkPVQuZ2V0SW5uZXJNb3N0QXhlcygxLGwpWzBdO1QuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJjdW1zdW1cIixbZF0sbCk7bGV0IGM9bi5tYWtlT3V0cHV0KHAuc2hhcGUscC5kdHlwZSksaD1wLnNoYXBlW2RdLG09bi5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZCxmPW4uZGF0YUlkTWFwLmdldChjLmRhdGFJZCkuaWQ7X0YobSxpPzE6MCxvPzE6MCxoLGYsUWVbci5kdHlwZV0pO2xldCBnPWM7aWYodSE9PW51bGwpe2xldCBiPVQuZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbih1KTtnPXlzKHtpbnB1dHM6e3g6Y30sYXR0cnM6e3Blcm06Yn0sYmFja2VuZDpufSksbi5kaXNwb3NlRGF0YShwLmRhdGFJZCksbi5kaXNwb3NlRGF0YShjLmRhdGFJZCl9cmV0dXJuIGd9dmFyIERwZT17a2VybmVsTmFtZTpWaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6RnBlLGtlcm5lbEZ1bmM6JHBlfSxBRjtmdW5jdGlvbiBScGUoZSl7QUY9ZS53YXNtLmN3cmFwKFwiRGVuc2VCaW5jb3VudFwiLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImJvb2xlYW5cIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJib29sZWFuXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIE1wZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3g6cix3ZWlnaHRzOnN9PW4se3NpemU6aSxiaW5hcnlPdXRwdXQ6b309YSxsPXMuc2hhcGUucmVkdWNlKChjLGgpPT5jKmgsMSkhPT0wLHU9ci5zaGFwZS5sZW5ndGg9PT0xP1tpXTpbci5zaGFwZVswXSxpXSxwPXQubWFrZU91dHB1dCh1LHMuZHR5cGUpO2Z1bmN0aW9uIGQoYyl7cmV0dXJuIHQuZGF0YUlkTWFwLmdldChjLmRhdGFJZCkuaWR9cmV0dXJuIEFGKGQociksbmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoci5zaGFwZSkuYnVmZmVyKSxyLnNoYXBlLmxlbmd0aCxpLGwsZChzKSxRZVtzLmR0eXBlXSxvLGQocCkpLHB9dmFyIE9wZT17a2VybmVsTmFtZTpQYyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6UnBlLGtlcm5lbEZ1bmM6TXBlfSxGRjtmdW5jdGlvbiBQcGUoZSl7RkY9ZS53YXNtLmN3cmFwKHB1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gTHBlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7eDpyfT1uLHtibG9ja1NpemU6cyxkYXRhRm9ybWF0Oml9PWEsbz1yLnNoYXBlWzBdLGw9aT09PVwiTkhXQ1wiP3Iuc2hhcGVbMV06ci5zaGFwZVsyXSx1PWk9PT1cIk5IV0NcIj9yLnNoYXBlWzJdOnIuc2hhcGVbM10scD1pPT09XCJOSFdDXCI/ci5zaGFwZVszXTpyLnNoYXBlWzFdLGQ9bCpzLGM9dSpzLGg9cC8ocypzKSxtPWk9PT1cIk5IV0NcIj9bbyxkLGMsaF06W28saCxkLGNdLGY9dC5tYWtlT3V0cHV0KG0sXCJmbG9hdDMyXCIpLGc9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxiPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHcuY29tcHV0ZVN0cmlkZXMoci5zaGFwZSkpLmJ1ZmZlcikseT1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShtKS5idWZmZXIpLHg9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkody5jb21wdXRlU3RyaWRlcyhtKSkuYnVmZmVyKSx2PXQuZGF0YUlkTWFwLmdldChmLmRhdGFJZCkuaWQ7cmV0dXJuIEZGKGcscyxpPT09XCJOSFdDXCI/MTowLGIsci5zaGFwZS5sZW5ndGgtMSx5LHgsbS5sZW5ndGgsdiksZn12YXIgenBlPXtrZXJuZWxOYW1lOnB1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpQcGUsa2VybmVsRnVuYzpMcGV9LCRGO2Z1bmN0aW9uIFdwZShlKXskRj1lLndhc20uY3dyYXAoVWksbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEJwZShlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse3g6cixmaWx0ZXI6c309dCxpPWEuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbz1hLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLHtzdHJpZGVzOmwsZGlsYXRpb25zOnUscGFkOnAsZGltUm91bmRpbmdNb2RlOmR9PW4sYz11PT1udWxsP1sxLDFdOnUsaD1ULmNvbXB1dGVDb252MkRJbmZvKHIuc2hhcGUscy5zaGFwZSxsLGMscCxkLCEwKSxtPWguZmlsdGVySGVpZ2h0LGY9aC5maWx0ZXJXaWR0aCxnPWgucGFkSW5mby50b3AsYj1oLnBhZEluZm8ucmlnaHQseT1oLnBhZEluZm8uYm90dG9tLHg9aC5wYWRJbmZvLmxlZnQsdj1oLmRpbGF0aW9uSGVpZ2h0LEk9aC5kaWxhdGlvbldpZHRoLE49aC5zdHJpZGVIZWlnaHQsQz1oLnN0cmlkZVdpZHRoLF89aC5pbkNoYW5uZWxzLEY9aC5vdXRDaGFubmVscyxEPWgucGFkSW5mby50eXBlPT09XCJTQU1FXCI/MTowO2lmKGguZGF0YUZvcm1hdCE9PVwiY2hhbm5lbHNMYXN0XCIpdGhyb3cgbmV3IEVycm9yKGB3YXNtIGJhY2tlbmQgRGVwdGh3aXNlQ29udjJkTmF0aXZlIGRvZXMgbm90IHN1cHBvcnQgZGF0YUZvcm1hdDonJHtoLmRhdGFGb3JtYXR9Jy4gUGxlYXNlIHVzZSAnY2hhbm5lbHNMYXN0Jy5gKTtsZXQgJD1hLm1ha2VPdXRwdXQoaC5vdXRTaGFwZSxcImZsb2F0MzJcIiksUz1hLmRhdGFJZE1hcC5nZXQoJC5kYXRhSWQpLmlkO3JldHVybiAkRihpLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdLG8sbSxmLGcsYix5LHgsRCx2LEksTixDLF8sRixTKSwkfXZhciBWcGU9e2tlcm5lbE5hbWU6VWksYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOldwZSxrZXJuZWxGdW5jOkJwZX0sREY7ZnVuY3Rpb24gVXBlKGUpe0RGPWUud2FzbS5jd3JhcChcIkRpYWdcIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gR3BlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse3g6YX09dCxyPXcuc2l6ZUZyb21TaGFwZShhLnNoYXBlKSxzPW4ubWFrZU91dHB1dChbLi4uYS5zaGFwZSwuLi5hLnNoYXBlXSxhLmR0eXBlKTtyZXR1cm4gREYobi5kYXRhSWRNYXAuZ2V0KGEuZGF0YUlkKS5pZCxRZVthLmR0eXBlXSxyLG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQpLHN9dmFyIEhwZT17a2VybmVsTmFtZTpMYyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6VXBlLGtlcm5lbEZ1bmM6R3BlfSxSRjtmdW5jdGlvbiBqcGUoZSl7UkY9ZS53YXNtLmN3cmFwKEdpLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gcXBlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyLGZpbHRlcjpzfT10LHtzdHJpZGVzOmkscGFkOm8sZGlsYXRpb25zOmx9PWE7aWYoci5kdHlwZSE9PXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKGBEaWxhdGlvbjJEIGVycm9yOiB4IG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZSBhcyBmaWx0ZXIuIEdvdCAke3IuZHR5cGV9IGFuZCAke3MuZHR5cGV9YCk7bGV0IHU9VC5jb21wdXRlRGlsYXRpb24yREluZm8oci5zaGFwZSxzLnNoYXBlLGksbyxcIk5IV0NcIixsKSxwPW4ubWFrZU91dHB1dCh1Lm91dFNoYXBlLHIuZHR5cGUpO3JldHVybiBSRihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZCxRZVtyLmR0eXBlXSx1LmJhdGNoU2l6ZSx1LmluQ2hhbm5lbHMsdS5pbkhlaWdodCx1LmluV2lkdGgsdS5vdXRIZWlnaHQsdS5vdXRXaWR0aCx1LnN0cmlkZUhlaWdodCx1LnN0cmlkZVdpZHRoLHUuZGlsYXRpb25IZWlnaHQsdS5kaWxhdGlvbldpZHRoLHUuZmlsdGVySGVpZ2h0LHUuZmlsdGVyV2lkdGgsdS5wYWRJbmZvLnRvcCx1LnBhZEluZm8ubGVmdCkscH12YXIgS3BlPXtrZXJuZWxOYW1lOkdpLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpqcGUsa2VybmVsRnVuYzpxcGV9LE1GO2Z1bmN0aW9uIFhwZShlKXtNRj1lLndhc20uY3dyYXAoUmwsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFlwZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cixmaWx0ZXI6cyxkeTppfT10LHtzdHJpZGVzOm8scGFkOmwsZGlsYXRpb25zOnV9PWE7aWYoci5kdHlwZSE9PXMuZHR5cGV8fHIuZHR5cGUhPT1pLmR0eXBlKXRocm93IG5ldyBFcnJvcihgRGlsYXRpb24yREJhY2twcm9wRmlsdGVyIGVycm9yOiB4IG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZSBhcyBmaWx0ZXIgYW5kIGR5LiBHb3QgJHtyLmR0eXBlfSwgJHtzLmR0eXBlfSwgYW5kICR7aS5kdHlwZX1gKTtsZXQgcD1ULmNvbXB1dGVEaWxhdGlvbjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsbyxsLFwiTkhXQ1wiLHUpLGQ9bi5tYWtlT3V0cHV0KHMuc2hhcGUscy5kdHlwZSk7cmV0dXJuIE1GKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQsUWVbci5kdHlwZV0scC5iYXRjaFNpemUscC5pbkNoYW5uZWxzLHAuaW5IZWlnaHQscC5pbldpZHRoLHAub3V0SGVpZ2h0LHAub3V0V2lkdGgscC5zdHJpZGVIZWlnaHQscC5zdHJpZGVXaWR0aCxwLmRpbGF0aW9uSGVpZ2h0LHAuZGlsYXRpb25XaWR0aCxwLmZpbHRlckhlaWdodCxwLmZpbHRlcldpZHRoLHAucGFkSW5mby50b3AscC5wYWRJbmZvLmxlZnQpLGR9dmFyIFpwZT17a2VybmVsTmFtZTpSbCxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6WHBlLGtlcm5lbEZ1bmM6WXBlfSxPRjtmdW5jdGlvbiBKcGUoZSl7T0Y9ZS53YXNtLmN3cmFwKERsLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBRcGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIsZmlsdGVyOnMsZHk6aX09dCx7c3RyaWRlczpvLHBhZDpsLGRpbGF0aW9uczp1fT1hO2lmKHIuZHR5cGUhPT1zLmR0eXBlfHxyLmR0eXBlIT09aS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoYERpbGF0aW9uMkRCYWNrcHJvcElucHV0IGVycm9yOiB4IG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZSBhcyBmaWx0ZXIgYW5kIGR5LiBHb3QgJHtyLmR0eXBlfSwgJHtzLmR0eXBlfSwgYW5kICR7aS5kdHlwZX1gKTtsZXQgcD1ULmNvbXB1dGVEaWxhdGlvbjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsbyxsLFwiTkhXQ1wiLHUpLGQ9bi5tYWtlT3V0cHV0KHIuc2hhcGUsci5kdHlwZSk7cmV0dXJuIE9GKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQsUWVbci5kdHlwZV0scC5iYXRjaFNpemUscC5pbkNoYW5uZWxzLHAuaW5IZWlnaHQscC5pbldpZHRoLHAub3V0SGVpZ2h0LHAub3V0V2lkdGgscC5zdHJpZGVIZWlnaHQscC5zdHJpZGVXaWR0aCxwLmRpbGF0aW9uSGVpZ2h0LHAuZGlsYXRpb25XaWR0aCxwLmZpbHRlckhlaWdodCxwLmZpbHRlcldpZHRoLHAucGFkSW5mby50b3AscC5wYWRJbmZvLmxlZnQpLGR9dmFyIGVjZT17a2VybmVsTmFtZTpEbCxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6SnBlLGtlcm5lbEZ1bmM6UXBlfSx0Y2U9WGUoamkpLFBGO2Z1bmN0aW9uIG5jZShlKXtQRj1lLndhc20uY3dyYXAoY3UsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBhY2UoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7ZHk6YSx5OnJ9PXQscz1uLm1ha2VPdXRwdXQoci5zaGFwZSxcImZsb2F0MzJcIiksaT1vPT5uLmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkO3JldHVybiBQRihpKHIpLGkoYSksaShzKSksc312YXIgcmNlPXtrZXJuZWxOYW1lOmN1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpuY2Usa2VybmVsRnVuYzphY2V9LHNjZT0hMSxpY2U9VXQoZHUsc2NlLFwiYm9vbFwiKSxvY2U9WGUocWkpLGxjZT1YZShLaSxcImZsb2F0MzJcIik7ZnVuY3Rpb24geXYoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHtpbnB1dDpyfT10LHtkaW06c309bixpPXIuc2hhcGUubGVuZ3RoLG89ci5zaGFwZS5zbGljZSgpLGw9cztyZXR1cm4gczwwJiYody5hc3NlcnQoLShpKzEpPD1zLCgpPT5gQXhpcyBtdXN0IGJlIGluIHRoZSBpbnRlcnZhbCBbJHstKGkrMSl9LCAke2l9XWApLGw9aStzKzEpLG8uc3BsaWNlKGwsMCwxKSx6bih7aW5wdXRzOnt4OnJ9LGJhY2tlbmQ6YSxhdHRyczp7c2hhcGU6b319KX12YXIgdWNlPXtrZXJuZWxOYW1lOmh1LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6eXZ9LHBjZT1YZShYaSxcImZsb2F0MzJcIik7ZnVuY3Rpb24gTEYoZSl7bGV0e2F0dHJzOntzaGFwZTp0LHZhbHVlOm59LGJhY2tlbmQ6YX09ZSx7YXR0cnM6e2R0eXBlOnJ9fT1lO3I9cnx8dy5pbmZlckR0eXBlKG4pO2xldCBzPWEubWFrZU91dHB1dCh0LHIpO3JldHVybiBhLnR5cGVkQXJyYXlGcm9tSGVhcChzKS5maWxsKG4pLHN9dmFyIGNjZT17a2VybmVsTmFtZTp6YyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOkxGfSx6RjtmdW5jdGlvbiBkY2UoZSl7ekY9ZS53YXNtLmN3cmFwKG11LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gaGNlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm59PWUse2ltYWdlOmF9PXQscj1uLm1ha2VPdXRwdXQoYS5zaGFwZSxhLmR0eXBlKSxzPW4uZGF0YUlkTWFwLmdldChhLmRhdGFJZCkuaWQsaT1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLFtvLGwsdSxwXT1hLnNoYXBlO3JldHVybiB6RihzLG8sbCx1LHAsaSkscn12YXIgbWNlPXtrZXJuZWxOYW1lOm11LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6aGNlLHNldHVwRnVuYzpkY2V9LGZjZT1YZShZaSksZ2NlPSExLGJjZT1VdChaaSxnY2UpLFdGO2Z1bmN0aW9uIHljZShlKXtXRj1lLndhc20uY3dyYXAoSmksbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHhjZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3ZhcmlhbmNlRXBzaWxvbjpyfT1hLHt4OnMsbWVhbjppLHZhcmlhbmNlOm8sb2Zmc2V0Omwsc2NhbGU6dX09bixwPXQuZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsZD10LmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLGM9dC5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZCxoPWwhPW51bGw/dC5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZDowLG09dSE9bnVsbD90LmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkOjAsZj10Lm1ha2VPdXRwdXQocy5zaGFwZSxzLmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUocy5zaGFwZSk9PT0wKXJldHVybiBmO2xldCBnPXQuZGF0YUlkTWFwLmdldChmLmRhdGFJZCkuaWQ7cmV0dXJuIFdGKHAsZCxjLGgsbSxyLGcpLGZ9dmFyIHZjZT17a2VybmVsTmFtZTpKaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6eWNlLGtlcm5lbEZ1bmM6eGNlfSxCRjtmdW5jdGlvbiB3Y2UoZSl7QkY9ZS53YXNtLmN3cmFwKG9pLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGtjZShlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse3g6cixmaWx0ZXI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10LHtzdHJpZGVzOmwscGFkOnUsZGlsYXRpb25zOnAsZGF0YUZvcm1hdDpkLGRpbVJvdW5kaW5nTW9kZTpjLGFjdGl2YXRpb246aCxsZWFreXJlbHVBbHBoYTptfT1uLGY9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsbCxwLHUsYyksZz1BY1toXTtpZihnPT1udWxsKXRocm93IG5ldyBFcnJvcihgJHtofSBhY3RpdmF0aW9uIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBGdXNlZENvbnYyRCBpbiB0aGUgd2FzbSBiYWNrZW5kLmApO2xldCBiPWEuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQseT1hLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLHg9Zi5vdXRDaGFubmVscyx2PTA7aWYoaSE9bnVsbCl7bGV0IHRlPWEuZGF0YUlkTWFwLmdldChpLmRhdGFJZCk7aWYodGUuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYEZ1c2VkQ29udjJEIG9ubHkgc3VwcG9ydHMgcmFuay0xIGJpYXMgYnV0IGdvdCByYW5rICR7dGUuc2hhcGUubGVuZ3RofS5gKTtpZih0ZS5zaGFwZVswXSE9PXgpdGhyb3cgbmV3IEVycm9yKGBGdXNlZENvbnYyRCBiaWFzIHNoYXBlICgke3RlLnNoYXBlfSkgZG9lcyBub3QgbWF0Y2ggdGhlIG51bWJlciBvZiBvdXRwdXQgY2hhbm5lbHMgKCR7eH0pYCk7dj10ZS5pZH1sZXQgST1mLmZpbHRlckhlaWdodCxOPWYuZmlsdGVyV2lkdGgsQz1mLnBhZEluZm8udG9wLF89Zi5wYWRJbmZvLnJpZ2h0LEY9Zi5wYWRJbmZvLmJvdHRvbSxEPWYucGFkSW5mby5sZWZ0LCQ9Zi5kaWxhdGlvbkhlaWdodCxTPWYuZGlsYXRpb25XaWR0aCxNPWYuc3RyaWRlSGVpZ2h0LEI9Zi5zdHJpZGVXaWR0aCxVPWYuaW5DaGFubmVscyxIPWYucGFkSW5mby50eXBlPT09XCJTQU1FXCI/MTowLHE9Zi5iYXRjaFNpemUsSz1mLmluSGVpZ2h0LFo9Zi5pbldpZHRoO2lmKGQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHdhc20gYmFja2VuZCBGdXNlZENvbnYyRCBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQ6JyR7ZH0nLiBQbGVhc2UgdXNlICdOSFdDJy5gKTtsZXQgSj1hLm1ha2VPdXRwdXQoZi5vdXRTaGFwZSxcImZsb2F0MzJcIiksZWU9YS5kYXRhSWRNYXAuZ2V0KEouZGF0YUlkKS5pZCxhZT1vPT1udWxsPzA6YS5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZDtyZXR1cm4gQkYoYixxLEssWix5LEksTix2LEMsXyxGLEQsSCwkLFMsTSxCLFUseCxnLGFlLG18fDAsZWUpLEp9dmFyIEljZT17a2VybmVsTmFtZTpvaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6d2NlLGtlcm5lbEZ1bmM6a2NlfSxWRjtmdW5jdGlvbiBTY2UoZSl7VkY9ZS53YXNtLmN3cmFwKGxpLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIE5jZShlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse3g6cixmaWx0ZXI6cyxiaWFzOmkscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpvfT10LHtzdHJpZGVzOmwscGFkOnUsZGlsYXRpb25zOnAsZGF0YUZvcm1hdDpkLGRpbVJvdW5kaW5nTW9kZTpjLGFjdGl2YXRpb246aCxsZWFreXJlbHVBbHBoYTptfT1uLGY9VC5jb21wdXRlQ29udjJESW5mbyhyLnNoYXBlLHMuc2hhcGUsbCxwLHUsYywhMCksZz1BY1toXTtpZihnPT1udWxsKXRocm93IG5ldyBFcnJvcihgJHtofSBhY3RpdmF0aW9uIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBGdXNlZERlcHRod2lzZUNvbnYyRCBpbiB0aGUgd2FzbSBiYWNrZW5kLmApO2xldCBiPWEuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQseT1hLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLHg9Zi5vdXRDaGFubmVscyx2PTA7aWYoaSE9bnVsbCl7bGV0IHRlPWEuZGF0YUlkTWFwLmdldChpLmRhdGFJZCk7aWYodGUuc2hhcGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoYEZ1c2VkRGVwdGh3aXNlQ29udjJEIG9ubHkgc3VwcG9ydHMgcmFuay0xIGJpYXMgYnV0IGdvdCByYW5rICR7dGUuc2hhcGUubGVuZ3RofS5gKTtpZih0ZS5zaGFwZVswXSE9PXgpdGhyb3cgbmV3IEVycm9yKGBGdXNlZERlcHRod2lzZUNvbnYyRCBiaWFzIHNoYXBlICgke3RlLnNoYXBlfSkgZG9lcyBub3QgbWF0Y2ggdGhlIG51bWJlciBvZiBvdXRwdXQgY2hhbm5lbHMgKCR7eH0pYCk7dj10ZS5pZH1sZXQgST1mLmZpbHRlckhlaWdodCxOPWYuZmlsdGVyV2lkdGgsQz1mLnBhZEluZm8udG9wLF89Zi5wYWRJbmZvLnJpZ2h0LEY9Zi5wYWRJbmZvLmJvdHRvbSxEPWYucGFkSW5mby5sZWZ0LCQ9Zi5kaWxhdGlvbkhlaWdodCxTPWYuZGlsYXRpb25XaWR0aCxNPWYuc3RyaWRlSGVpZ2h0LEI9Zi5zdHJpZGVXaWR0aCxVPWYuaW5DaGFubmVscyxIPWYucGFkSW5mby50eXBlPT09XCJTQU1FXCI/MTowLHE9Zi5iYXRjaFNpemUsSz1mLmluSGVpZ2h0LFo9Zi5pbldpZHRoO2lmKGQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHdhc20gYmFja2VuZCBGdXNlZERlcHRod2lzZUNvbnYyRCBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQ6JyR7ZH0nLiBQbGVhc2UgdXNlICdOSFdDJy5gKTtsZXQgSj1hLm1ha2VPdXRwdXQoZi5vdXRTaGFwZSxcImZsb2F0MzJcIiksZWU9YS5kYXRhSWRNYXAuZ2V0KEouZGF0YUlkKS5pZCxhZT1vPT1udWxsPzA6YS5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZDtyZXR1cm4gVkYoYixxLEssWix5LEksTix2LEMsXyxGLEQsSCwkLFMsTSxCLFUseCxnLGFlLG18fDAsZWUpLEp9dmFyIFRjZT17a2VybmVsTmFtZTpsaSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6U2NlLGtlcm5lbEZ1bmM6TmNlfSxVRjtmdW5jdGlvbiBDY2UoZSl7VUY9ZS53YXNtLmN3cmFwKGd1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gRWNlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm59PWUse3BhcmFtczphLGluZGljZXM6cn09bixbcyxpLG8sbF09WXcucHJlcGFyZUFuZFZhbGlkYXRlKGEsciksdT10Lm1ha2VPdXRwdXQocyxhLmR0eXBlKTtpZihpPT09MClyZXR1cm4gdTtsZXQgcD1yLnNoYXBlLGQ9cFtwLmxlbmd0aC0xXSxjPXQuZGF0YUlkTWFwLmdldChhLmRhdGFJZCkuaWQsaD10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG09bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkobCkuYnVmZmVyKSxmPXQuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQ7cmV0dXJuIFVGKGMsUWVbYS5kdHlwZV0saCxpLGQsbyxtLGYpLHV9dmFyIF9jZT17a2VybmVsTmFtZTpndSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6Q2NlLGtlcm5lbEZ1bmM6RWNlfSxHRjtmdW5jdGlvbiBBY2UoZSl7R0Y9ZS53YXNtLmN3cmFwKFwiR2F0aGVyXCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEZjZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3g6cixpbmRpY2VzOnN9PW4se2F4aXM6aSxiYXRjaERpbXM6b309YSxsPXcucGFyc2VBeGlzUGFyYW0oaSxyLnNoYXBlKVswXSx1PXQucmVhZFN5bmMocy5kYXRhSWQpLHA9ci5zaGFwZVtsXTtmb3IobGV0IEM9MDtDPHUubGVuZ3RoOysrQyl7bGV0IF89dVtDXTt3LmFzc2VydChfPD1wLTEmJl8+PTAsKCk9PmBHYXRoZXJWMjogdGhlIGluZGV4IHZhbHVlICR7X30gaXMgbm90IGluIFswLCAke3AtMX1dYCl9bGV0IGQ9VC5zZWdtZW50X3V0aWwuY29sbGVjdEdhdGhlck9wU2hhcGVJbmZvKHIscyxsLG8pLGM9em4oe2lucHV0czp7eDpyfSxhdHRyczp7c2hhcGU6W2QuYmF0Y2hTaXplLGQub3V0ZXJTaXplLGQuZGltU2l6ZSxkLnNsaWNlU2l6ZV19LGJhY2tlbmQ6dH0pLGg9dy5zaXplRnJvbVNoYXBlKHMuc2hhcGUpLG09em4oe2lucHV0czp7eDpzfSxhdHRyczp7c2hhcGU6W2QuYmF0Y2hTaXplLGgvZC5iYXRjaFNpemVdfSxiYWNrZW5kOnR9KSxmPVtkLmJhdGNoU2l6ZSxkLm91dGVyU2l6ZSxoL2QuYmF0Y2hTaXplLGQuc2xpY2VTaXplXSxnPXQubWFrZU91dHB1dChmLHIuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZShyLnNoYXBlKT09PTApcmV0dXJuIGc7bGV0IGI9Yy5zaGFwZS5sZW5ndGgtMSx5PXQuZGF0YUlkTWFwLmdldChjLmRhdGFJZCkuaWQseD10LmRhdGFJZE1hcC5nZXQobS5kYXRhSWQpLmlkLHY9dC5kYXRhSWRNYXAuZ2V0KGcuZGF0YUlkKS5pZCxJPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHcuY29tcHV0ZVN0cmlkZXMoYy5zaGFwZSkpLmJ1ZmZlciksTj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh3LmNvbXB1dGVTdHJpZGVzKGYpKS5idWZmZXIpO3JldHVybiBHRih5LFFlW3IuZHR5cGVdLEksYix4LGQuYmF0Y2hTaXplLE4sdiksdC5kaXNwb3NlRGF0YShjLmRhdGFJZCksdC5kaXNwb3NlRGF0YShtLmRhdGFJZCksZy5zaGFwZT1kLm91dHB1dFNoYXBlLGd9dmFyICRjZT17a2VybmVsTmFtZTpmdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6QWNlLGtlcm5lbEZ1bmM6RmNlfSxEY2U9ITEsUmNlPVV0KGJ1LERjZSxcImJvb2xcIiksTWNlPSExLE9jZT1VdChRaSxNY2UsXCJib29sXCIpLFBjZT1YZSh0byxcImJvb2xcIiksTGNlPVhlKG5vLFwiYm9vbFwiKSx6Y2U9WGUoYW8sXCJib29sXCIpLEhGO2Z1bmN0aW9uIFdjZShlKXtIRj1lLndhc20uY3dyYXAocm8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEJjZShlKXtsZXR7aW5wdXRzOnt4OnR9LGF0dHJzOnthbHBoYTpufSxiYWNrZW5kOmF9PWUscj1hLmRhdGFJZE1hcC5nZXQodC5kYXRhSWQpLmlkLHM9YS5tYWtlT3V0cHV0KHQuc2hhcGUsXCJmbG9hdDMyXCIpO2lmKHcuc2l6ZUZyb21TaGFwZSh0LnNoYXBlKSE9PTApe2xldCBpPWEuZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQ7SEYocixRZVt0LmR0eXBlXSxuLGkpfXJldHVybiBzfXZhciBWY2U9e2tlcm5lbE5hbWU6cm8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOldjZSxrZXJuZWxGdW5jOkJjZX0sVWNlPSExLEdjZT1VdCh5dSxVY2UsXCJib29sXCIpLEhjZT0hMSxqY2U9VXQoeHUsSGNlLFwiYm9vbFwiKSxqRjtmdW5jdGlvbiBxY2UoZSl7akY9ZS53YXNtLmN3cmFwKHZ1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBLY2UoZSl7bGV0e2F0dHJzOnQsYmFja2VuZDpufT1lLHtzdGFydDphLHN0b3A6cixudW06c309dCxpPU1hdGguZmxvb3Iocyksbz1uLm1ha2VPdXRwdXQoW2ldLFwiZmxvYXQzMlwiKTtyZXR1cm4gakYobi5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZCxhLHIsaSksb312YXIgWGNlPXtrZXJuZWxOYW1lOnZ1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpxY2Usa2VybmVsRnVuYzpLY2V9LFljZT1YZShzbyksWmNlPVhlKGlvKSxKY2U9ITEsUWNlPVV0KHd1LEpjZSxcImJvb2xcIiksZWRlPVhlKGt1KSx0ZGU9ITEsbmRlPVV0KEl1LHRkZSxcImJvb2xcIiksYWRlPSExLHJkZT1VdChqUyxhZGUsXCJib29sXCIpLHFGO2Z1bmN0aW9uIHNkZShlKXtxRj1lLndhc20uY3dyYXAob28sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGlkZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZGVwdGhSYWRpdXM6cyxiaWFzOmksYWxwaGE6byxiZXRhOmx9PWE7aWYoci5kdHlwZSE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBFcnJvcihcIkxSTiBlcnJvcjogeCBtdXN0IGhhdmUgZHR5cGUgZmxvYXQzMlwiKTtsZXQgdT1uLm1ha2VPdXRwdXQoci5zaGFwZSxyLmR0eXBlKTtyZXR1cm4gcUYobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkLHIuc2hhcGVbM10scyxpLG8sbCksdX12YXIgb2RlPXtrZXJuZWxOYW1lOm9vLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpzZGUsa2VybmVsRnVuYzppZGV9LEtGO2Z1bmN0aW9uIGxkZShlKXtLRj1lLndhc20uY3dyYXAoU3UsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB1ZGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnIseTpzLGR5Oml9PXQse2RlcHRoUmFkaXVzOm8sYmlhczpsLGFscGhhOnUsYmV0YTpwfT1hO2lmKHIuZHR5cGUhPT1cImZsb2F0MzJcInx8cy5kdHlwZSE9PVwiZmxvYXQzMlwifHxpLmR0eXBlIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IEVycm9yKFwiTFJOR3JhZCBlcnJvcjogeCwgeSwgYW5kIGR5IG11c3QgaGF2ZSBkdHlwZSBmbG9hdDMyXCIpO2xldCBkPW4ubWFrZU91dHB1dChyLnNoYXBlLHIuZHR5cGUpO3JldHVybiBLRihuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkLGkuc2hhcGVbM10sbyxsLHUscCksZH12YXIgcGRlPXtrZXJuZWxOYW1lOlN1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpsZGUsa2VybmVsRnVuYzp1ZGV9LFhGO2Z1bmN0aW9uIGNkZShlKXtYRj1lLndhc20uY3dyYXAobG8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIGRkZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse3JlZHVjdGlvbkluZGljZXM6cixrZWVwRGltczpzfT1hLHt4Oml9PW4sbz10LmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLGw9aSx7dHJhbnNwb3NlZDp1LGF4ZXM6cCxvcmlnaW5hbEF4ZXM6ZCxpbnB1dFdhc1RyYW5zcG9zZWQ6Y309RHMoaSxyLHQpO2lmKGMpe2xldCB5PXQuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQ7bD11LG89eX1sZXQgaD1sLnNoYXBlLmxlbmd0aDtULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWF4XCIscCxoKTtsZXRbbSxmXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMobC5zaGFwZSxwKSxnPXcuc2l6ZUZyb21TaGFwZShmKSxiPXQubWFrZU91dHB1dChtLGkuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZShsLnNoYXBlKSE9PTApe2xldCB5PXQuZGF0YUlkTWFwLmdldChiLmRhdGFJZCkuaWQ7WEYobyxRZVtpLmR0eXBlXSxnLHkpfWlmKGMmJnQuZGlzcG9zZURhdGEodS5kYXRhSWQpLHMpe2xldCB5PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oYi5zaGFwZSxkKTtiLnNoYXBlPXl9cmV0dXJuIGJ9dmFyIGhkZT17a2VybmVsTmFtZTpsbyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6Y2RlLGtlcm5lbEZ1bmM6ZGRlfSxtZGU9ITEsZmRlPVV0KHVvLG1kZSksWUY7ZnVuY3Rpb24gZ2RlKGUpe1lGPWUud2FzbS5jd3JhcChwbyxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBiZGUoZSl7bGV0e2lucHV0czp0LGF0dHJzOm4sYmFja2VuZDphfT1lLHI9dC54LHM9YS5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZDt3LmFzc2VydChyLmR0eXBlPT09XCJmbG9hdDMyXCIsKCk9PmBFcnJvciBpbiBNYXhQb29sOiBvbmx5IGZsb2F0MzIgaW5wdXQgaXMgc3VwcG9ydGVkLiBHb3QgJHtyLmR0eXBlfS5gKTtsZXR7ZmlsdGVyU2l6ZTppLHN0cmlkZXM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dX09bixwPVQuY29tcHV0ZVBvb2wyREluZm8oci5zaGFwZSxpLG8sMSxsLHUpLGQ9cC5maWx0ZXJIZWlnaHQsYz1wLmZpbHRlcldpZHRoLGg9cC5wYWRJbmZvLnRvcCxtPXAucGFkSW5mby5yaWdodCxmPXAucGFkSW5mby5ib3R0b20sZz1wLnBhZEluZm8ubGVmdCxiPXAuZGlsYXRpb25IZWlnaHQseT1wLmRpbGF0aW9uV2lkdGgseD1wLnN0cmlkZUhlaWdodCx2PXAuc3RyaWRlV2lkdGgsST1wLmluQ2hhbm5lbHMsTj1wLm91dENoYW5uZWxzO2lmKHAuZGF0YUZvcm1hdCE9PVwiY2hhbm5lbHNMYXN0XCIpdGhyb3cgbmV3IEVycm9yKGB3YXNtIGJhY2tlbmQgZG9lcyBub3Qgc3VwcG9ydCBkYXRhRm9ybWF0Oicke3AuZGF0YUZvcm1hdH0nLiBQbGVhc2UgdXNlICdjaGFubmVsc0xhc3QnLmApO2xldCBDPWEubWFrZU91dHB1dChwLm91dFNoYXBlLFwiZmxvYXQzMlwiKSxfPWEuZGF0YUlkTWFwLmdldChDLmRhdGFJZCkuaWQ7cmV0dXJuIFlGKHMsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0sZCxjLGgsbSxmLGcsYix5LHgsdixJLE4sXyksQ312YXIgeWRlPXtrZXJuZWxOYW1lOnBvLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpnZGUsa2VybmVsRnVuYzpiZGV9LFpGO2Z1bmN0aW9uIHhkZShlKXtaRj1lLndhc20uY3dyYXAoXCJNYXhQb29sM0RcIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gdmRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7eDpyfT10LHtmaWx0ZXJTaXplOnMsc3RyaWRlczppLHBhZDpvLGRpbVJvdW5kaW5nTW9kZTpsLGRhdGFGb3JtYXQ6dX09YSxwPVQuY29tcHV0ZVBvb2wzREluZm8oci5zaGFwZSxzLGksMSxvLGwsdSksZD1uLm1ha2VPdXRwdXQocC5vdXRTaGFwZSxyLmR0eXBlKTtyZXR1cm4gWkYobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkLHAuYmF0Y2hTaXplLHAuaW5DaGFubmVscyxwLmluRGVwdGgscC5pbkhlaWdodCxwLmluV2lkdGgscC5vdXREZXB0aCxwLm91dEhlaWdodCxwLm91dFdpZHRoLHAuc3RyaWRlRGVwdGgscC5zdHJpZGVIZWlnaHQscC5zdHJpZGVXaWR0aCxwLmRpbGF0aW9uRGVwdGgscC5kaWxhdGlvbkhlaWdodCxwLmRpbGF0aW9uV2lkdGgscC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxwLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxwLmVmZmVjdGl2ZUZpbHRlcldpZHRoLHAucGFkSW5mby5mcm9udCxwLnBhZEluZm8udG9wLHAucGFkSW5mby5sZWZ0KSxkfXZhciB3ZGU9e2tlcm5lbE5hbWU6TnUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnhkZSxrZXJuZWxGdW5jOnZkZX0sSkY7ZnVuY3Rpb24ga2RlKGUpe0pGPWUud2FzbS5jd3JhcChcIk1heFBvb2wzREdyYWRcIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBJZGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtkeTpyLGlucHV0OnN9PXQse2ZpbHRlclNpemU6aSxzdHJpZGVzOm8scGFkOmwsZGltUm91bmRpbmdNb2RlOnV9PWEscD1ULmNvbXB1dGVQb29sM0RJbmZvKHMuc2hhcGUsaSxvLDEsbCx1KSxkPW4ubWFrZU91dHB1dChzLnNoYXBlLHMuZHR5cGUpO3JldHVybiBKRihuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZCxwLmJhdGNoU2l6ZSxwLmluQ2hhbm5lbHMscC5pbkRlcHRoLHAuaW5IZWlnaHQscC5pbldpZHRoLHAub3V0RGVwdGgscC5vdXRIZWlnaHQscC5vdXRXaWR0aCxwLnN0cmlkZURlcHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkRlcHRoLHAuZGlsYXRpb25IZWlnaHQscC5kaWxhdGlvbldpZHRoLHAuZWZmZWN0aXZlRmlsdGVyRGVwdGgscC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQscC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwLnBhZEluZm8uZnJvbnQscC5wYWRJbmZvLnRvcCxwLnBhZEluZm8ubGVmdCksZH12YXIgU2RlPXtrZXJuZWxOYW1lOkJjLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzprZGUsa2VybmVsRnVuYzpJZGV9LFFGO2Z1bmN0aW9uIE5kZShlKXtRRj1lLndhc20uY3dyYXAoXCJNYXhQb29sR3JhZFwiLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFRkZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2R5OnIsaW5wdXQ6c309dCx7ZmlsdGVyU2l6ZTppLHN0cmlkZXM6byxwYWQ6bCxkaW1Sb3VuZGluZ01vZGU6dX09YSxwPVQuY29tcHV0ZVBvb2wyREluZm8ocy5zaGFwZSxpLG8sMSxsLHUpLGQ9bi5tYWtlT3V0cHV0KHMuc2hhcGUscy5kdHlwZSk7cmV0dXJuIFFGKG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkLHAuYmF0Y2hTaXplLHAuaW5DaGFubmVscyxwLmluSGVpZ2h0LHAuaW5XaWR0aCxwLm91dEhlaWdodCxwLm91dFdpZHRoLHAuc3RyaWRlSGVpZ2h0LHAuc3RyaWRlV2lkdGgscC5kaWxhdGlvbkhlaWdodCxwLmRpbGF0aW9uV2lkdGgscC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQscC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwLnBhZEluZm8udG9wLHAucGFkSW5mby5sZWZ0KSxkfXZhciBDZGU9e2tlcm5lbE5hbWU6V2MsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOk5kZSxrZXJuZWxGdW5jOlRkZX0sZSQ7ZnVuY3Rpb24gRWRlKGUpe2UkPWUud2FzbS5jd3JhcChcIk1heFBvb2xXaXRoQXJnbWF4XCIsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImJvb2xlYW5cIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBfZGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2ZpbHRlclNpemU6cyxzdHJpZGVzOmkscGFkOm8saW5jbHVkZUJhdGNoSW5JbmRleDpsfT1hO3cuYXNzZXJ0KHIuc2hhcGUubGVuZ3RoPT09NCwoKT0+YEVycm9yIGluIG1heFBvb2w6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayAke3Iuc2hhcGUubGVuZ3RofS5gKTtsZXQgdT1bMSwxXTt3LmFzc2VydChULmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShpLHUpLCgpPT5gRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgJHtpfSBhbmQgZGlsYXRpb25zICcke3V9J2ApO2xldCBwPVQuY29tcHV0ZVBvb2wyREluZm8oci5zaGFwZSxzLGksWzEsMV0sbyksZD1uLm1ha2VPdXRwdXQocC5vdXRTaGFwZSxyLmR0eXBlKSxjPW4ubWFrZU91dHB1dChwLm91dFNoYXBlLFwiaW50MzJcIik7cmV0dXJuIGUkKG4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KGQuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQoYy5kYXRhSWQpLmlkLFFlW3IuZHR5cGVdLGwscC5iYXRjaFNpemUscC5pbkNoYW5uZWxzLHAuaW5IZWlnaHQscC5pbldpZHRoLHAub3V0SGVpZ2h0LHAub3V0V2lkdGgscC5zdHJpZGVIZWlnaHQscC5zdHJpZGVXaWR0aCxwLmRpbGF0aW9uSGVpZ2h0LHAuZGlsYXRpb25XaWR0aCxwLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxwLmVmZmVjdGl2ZUZpbHRlcldpZHRoLHAucGFkSW5mby50b3AscC5wYWRJbmZvLmxlZnQpLFtkLGNdfXZhciBBZGU9e2tlcm5lbE5hbWU6VmMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkVkZSxrZXJuZWxGdW5jOl9kZX0sdCQ7ZnVuY3Rpb24gRmRlKGUpe3QkPWUud2FzbS5jd3JhcChjbyxudWxsLFtcIm51bWJlciwgbnVtYmVyLCBudW1iZXJcIl0pfWZ1bmN0aW9uICRkZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2F4aXM6cixrZWVwRGltczpzfT1hLHt4Oml9PW4sbz10LmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLGw9byx1PWkse3RyYW5zcG9zZWQ6cCxheGVzOmQsb3JpZ2luYWxBeGVzOmMsaW5wdXRXYXNUcmFuc3Bvc2VkOmh9PURzKGkscix0KSxtPWQ7aWYoaCl7bGV0IHY9dC5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZDt2IT09byYmKHU9cCxsPXYsbT1ULmdldElubmVyTW9zdEF4ZXMobS5sZW5ndGgsdS5zaGFwZS5sZW5ndGgpKX1ULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwibWVhblwiLG0sdS5zaGFwZS5sZW5ndGgpO2xldFtmLGddPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh1LnNoYXBlLG0pLGI9dy5zaXplRnJvbVNoYXBlKGcpLHk9dTt1LmR0eXBlIT09XCJmbG9hdDMyXCImJih5PVJzKHtiYWNrZW5kOnQsaW5wdXRzOnt4OnV9LGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KSxsPXQuZGF0YUlkTWFwLmdldCh5LmRhdGFJZCkuaWQpO2xldCB4PXQubWFrZU91dHB1dChmLFwiZmxvYXQzMlwiKTtpZih3LnNpemVGcm9tU2hhcGUodS5zaGFwZSkhPT0wKXtsZXQgdj10LmRhdGFJZE1hcC5nZXQoeC5kYXRhSWQpLmlkO3QkKGwsYix2KX1pZihoJiZ0LmRpc3Bvc2VEYXRhKHAuZGF0YUlkKSxzKXtsZXQgdj1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKHguc2hhcGUsYyk7eC5zaGFwZT12fXJldHVybiB1LmR0eXBlIT09XCJmbG9hdDMyXCImJnQuZGlzcG9zZURhdGEoeS5kYXRhSWQpLHh9dmFyIERkZT17a2VybmVsTmFtZTpjbyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6RmRlLGtlcm5lbEZ1bmM6JGRlfSxuJDtmdW5jdGlvbiBSZGUoZSl7biQ9ZS53YXNtLmN3cmFwKGhvLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBNZGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtheGlzOnIsa2VlcERpbXM6c309YSx7eDppfT1uLG89dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxsPW8sdT1pLHt0cmFuc3Bvc2VkOnAsYXhlczpkLG9yaWdpbmFsQXhlczpjLGlucHV0V2FzVHJhbnNwb3NlZDpofT1EcyhpLHIsdCk7aWYoaCl7bGV0IHg9dC5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZDt4IT09byYmKHU9cCxsPXgpfWxldCBtPXUuc2hhcGUubGVuZ3RoO1QuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoXCJtaW5cIixkLG0pO2xldFtmLGddPVQuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh1LnNoYXBlLGQpLGI9dy5zaXplRnJvbVNoYXBlKGcpLHk9dC5tYWtlT3V0cHV0KGYsdS5kdHlwZSk7aWYody5zaXplRnJvbVNoYXBlKHUuc2hhcGUpIT09MCl7bGV0IHg9dC5kYXRhSWRNYXAuZ2V0KHkuZGF0YUlkKS5pZDtuJChsLFFlW2kuZHR5cGVdLGIseCl9aWYoaCYmdC5kaXNwb3NlRGF0YShwLmRhdGFJZCkscyl7bGV0IHg9VC5leHBhbmRTaGFwZVRvS2VlcERpbSh5LnNoYXBlLGMpO3kuc2hhcGU9eH1yZXR1cm4geX12YXIgT2RlPXtrZXJuZWxOYW1lOmhvLGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpSZGUsa2VybmVsRnVuYzpNZGV9LFBkZT0hMSxMZGU9VXQobW8sUGRlKSx4djsoZnVuY3Rpb24oZSl7ZVtlLnJlZmxlY3Q9MF09XCJyZWZsZWN0XCIsZVtlLnN5bW1ldHJpYz0xXT1cInN5bW1ldHJpY1wifSkoeHZ8fCh4dj17fSkpO3ZhciBhJDtmdW5jdGlvbiB6ZGUoZSl7YSQ9ZS53YXNtLmN3cmFwKGZvLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFdkZShlKXtsZXR7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6bixhdHRyczp7cGFkZGluZ3M6YSxtb2RlOnJ9fT1lLHM9YS5tYXAoKG0sZik9Pm1bMF0rdC5zaGFwZVtmXSttWzFdKSxpPW4uZGF0YUlkTWFwLmdldCh0LmRhdGFJZCkuaWQsbz1uLm1ha2VPdXRwdXQocyx0LmR0eXBlKSxsPW4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsdT1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh0LnNoYXBlKS5idWZmZXIpLHA9YS5tYXAobT0+bVswXSksZD1hLm1hcChtPT5tWzFdKSxjPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHApLmJ1ZmZlciksaD1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShkKS5idWZmZXIpO3JldHVybiBhJChpLHUsdC5zaGFwZS5sZW5ndGgsUWVbdC5kdHlwZV0sYyxoLHh2W3JdLGwpLG99dmFyIEJkZT17a2VybmVsTmFtZTpmbyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOldkZSxzZXR1cEZ1bmM6emRlfSxyJDtmdW5jdGlvbiBWZGUoZSl7ciQ9ZS53YXNtLmN3cmFwKHpvLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBzJChlKXtsZXR7YmFja2VuZDp0LGlucHV0czp7bG9naXRzOm59LGF0dHJzOntkaW06YX19PWUscj10LmRhdGFJZE1hcC5nZXQobi5kYXRhSWQpLmlkLHM9dC5tYWtlT3V0cHV0KG4uc2hhcGUsbi5kdHlwZSksaT10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG89bi5zaGFwZVthXSxsPXcuc2l6ZUZyb21TaGFwZShuLnNoYXBlKS9vO3JldHVybiB3LnNpemVGcm9tU2hhcGUocy5zaGFwZSk9PT0wfHxyJChyLGksbyxsKSxzfXZhciBVZGU9e2tlcm5lbE5hbWU6em8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOlZkZSxrZXJuZWxGdW5jOnMkfSxpJDtmdW5jdGlvbiBHZGUoZSl7aSQ9ZS53YXNtLmN3cmFwKFR1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gSGRlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7bG9naXRzOnJ9PXQse251bVNhbXBsZXM6cyxzZWVkOmksbm9ybWFsaXplZDpvfT1hO2lmKHIuZHR5cGUhPT1cImZsb2F0MzJcIil0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBsb2dpdHMgbXVzdCBoYXZlIGR0eXBlIGZsb2F0MzIsIGdvdCAke3IuZHR5cGV9YCk7bGV0IGw9bz9yOnMkKHtpbnB1dHM6e2xvZ2l0czpyfSxiYWNrZW5kOm4sYXR0cnM6e2RpbTpyLnNoYXBlLmxlbmd0aC0xfX0pLFt1LHBdPWwuc2hhcGUsZD1uLm1ha2VPdXRwdXQoW3Usc10sXCJpbnQzMlwiKTtyZXR1cm4gaSQobi5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZCx1LHAscyxpLG4uZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQpLG98fG4uZGlzcG9zZURhdGEobC5kYXRhSWQpLGR9dmFyIGpkZT17a2VybmVsTmFtZTpUdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6R2RlLGtlcm5lbEZ1bmM6SGRlfSxxZGU9VXQoZ28sITApLEtkZT0hMCxYZGU9VXQoYm8sS2RlKSxZZGU9WGUoQ3UpO2Z1bmN0aW9uIGhrKGUsdCl7bGV0IG49bmV3IEludDMyQXJyYXkoZS53YXNtLkhFQVBVOC5idWZmZXIsdCw0KSxhPW5bMF0scj1uWzFdLHM9blsyXSxpPW5bM107cmV0dXJuIGUud2FzbS5fZnJlZSh0KSx7cFNlbGVjdGVkSW5kaWNlczphLHNlbGVjdGVkU2l6ZTpyLHBTZWxlY3RlZFNjb3JlczpzLHBWYWxpZE91dHB1dHM6aX19dmFyIG8kO2Z1bmN0aW9uIFpkZShlKXtvJD1lLndhc20uY3dyYXAoX3UsXCJudW1iZXJcIixbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gSmRlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7aW91VGhyZXNob2xkOnIsbWF4T3V0cHV0U2l6ZTpzLHNjb3JlVGhyZXNob2xkOml9PWEse2JveGVzOm8sc2NvcmVzOmx9PW4sdT10LmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkLHA9dC5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZCxkPW8kKHUscCxzLHIsaSkse3BTZWxlY3RlZEluZGljZXM6YyxzZWxlY3RlZFNpemU6aCxwU2VsZWN0ZWRTY29yZXM6bSxwVmFsaWRPdXRwdXRzOmZ9PWhrKHQsZCk7cmV0dXJuIHQud2FzbS5fZnJlZShtKSx0Lndhc20uX2ZyZWUoZiksdC5tYWtlT3V0cHV0KFtoXSxcImludDMyXCIsYyl9dmFyIFFkZT17a2VybmVsTmFtZTpfdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6WmRlLGtlcm5lbEZ1bmM6SmRlfSxsJDtmdW5jdGlvbiBlaGUoZSl7bCQ9ZS53YXNtLmN3cmFwKEF1LFwibnVtYmVyXCIsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImJvb2xcIl0pfWZ1bmN0aW9uIHRoZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2lvdVRocmVzaG9sZDpyLG1heE91dHB1dFNpemU6cyxzY29yZVRocmVzaG9sZDppLHBhZFRvTWF4T3V0cHV0U2l6ZTpvfT1hLHtib3hlczpsLHNjb3Jlczp1fT1uLHA9dC5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZCxkPXQuZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQsYz1sJChwLGQscyxyLGksbykse3BTZWxlY3RlZEluZGljZXM6aCxzZWxlY3RlZFNpemU6bSxwU2VsZWN0ZWRTY29yZXM6ZixwVmFsaWRPdXRwdXRzOmd9PWhrKHQsYyk7dC53YXNtLl9mcmVlKGYpO2xldCBiPXQubWFrZU91dHB1dChbbV0sXCJpbnQzMlwiLGgpLHk9dC5tYWtlT3V0cHV0KFtdLFwiaW50MzJcIixnKTtyZXR1cm5bYix5XX12YXIgbmhlPXtrZXJuZWxOYW1lOkF1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzplaGUsa2VybmVsRnVuYzp0aGV9LHUkO2Z1bmN0aW9uIGFoZShlKXt1JD1lLndhc20uY3dyYXAoRnUsXCJudW1iZXJcIixbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiByaGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtpb3VUaHJlc2hvbGQ6cixtYXhPdXRwdXRTaXplOnMsc2NvcmVUaHJlc2hvbGQ6aSxzb2Z0Tm1zU2lnbWE6b309YSx7Ym94ZXM6bCxzY29yZXM6dX09bixwPXQuZGF0YUlkTWFwLmdldChsLmRhdGFJZCkuaWQsZD10LmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkLGM9dSQocCxkLHMscixpLG8pLHtwU2VsZWN0ZWRJbmRpY2VzOmgsc2VsZWN0ZWRTaXplOm0scFNlbGVjdGVkU2NvcmVzOmYscFZhbGlkT3V0cHV0czpnfT1oayh0LGMpO3Qud2FzbS5fZnJlZShnKTtsZXQgYj10Lm1ha2VPdXRwdXQoW21dLFwiaW50MzJcIixoKSx5PXQubWFrZU91dHB1dChbbV0sXCJmbG9hdDMyXCIsZik7cmV0dXJuW2IseV19dmFyIHNoZT17a2VybmVsTmFtZTpGdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6YWhlLGtlcm5lbEZ1bmM6cmhlfSxpaGU9ITEsb2hlPVV0KEV1LGloZSxcImJvb2xcIikscCQ7ZnVuY3Rpb24gbGhlKGUpe3AkPWUud2FzbS5jd3JhcCh5byxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB1aGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbmRpY2VzOnJ9PXQse2R0eXBlOnMsZGVwdGg6aSxvblZhbHVlOm8sb2ZmVmFsdWU6bH09YSx1PW4ubWFrZU91dHB1dChbLi4uci5zaGFwZSxpXSxzKSxwPW4uZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQsZD1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkO3JldHVybiBwJChkLGksbyxsLHApLHV9dmFyIHBoZT17a2VybmVsTmFtZTp5byxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6bGhlLGtlcm5lbEZ1bmM6dWhlfTtmdW5jdGlvbiBjaGUoZSl7bGV0e2lucHV0czp7eDp0fSxiYWNrZW5kOm59PWUsYT1uLm1ha2VPdXRwdXQodC5zaGFwZSx0LmR0eXBlKTtyZXR1cm4gbi50eXBlZEFycmF5RnJvbUhlYXAoYSkuZmlsbCgxKSxhfXZhciBkaGU9e2tlcm5lbE5hbWU6JHUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpjaGV9O2Z1bmN0aW9uIGhoZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse2F4aXM6cn09YTtpZih0Lmxlbmd0aD09PTEpcmV0dXJuIHl2KHtpbnB1dHM6e2lucHV0OnRbMF19LGJhY2tlbmQ6bixhdHRyczp7ZGltOnJ9fSk7bGV0IHM9dFswXS5zaGFwZSxpPXRbMF0uZHR5cGU7dC5mb3JFYWNoKHA9Pnt3LmFzc2VydFNoYXBlc01hdGNoKHMscC5zaGFwZSxcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzXCIpLHcuYXNzZXJ0KGk9PT1wLmR0eXBlLCgpPT5cIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgZHR5cGVzXCIpfSk7bGV0IG89W10sbD10Lm1hcChwPT57bGV0IGQ9eXYoe2lucHV0czp7aW5wdXQ6cH0sYmFja2VuZDpuLGF0dHJzOntkaW06cn19KTtyZXR1cm4gby5wdXNoKGQpLGR9KSx1PXdGKHtpbnB1dHM6bCxiYWNrZW5kOm4sYXR0cnM6e2F4aXM6cn19KTtyZXR1cm4gby5mb3JFYWNoKHA9Pm4uZGlzcG9zZURhdGEocC5kYXRhSWQpKSx1fXZhciBtaGU9e2tlcm5lbE5hbWU6RHUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpoaGV9LGMkO2Z1bmN0aW9uIGZoZShlKXtjJD1lLndhc20uY3dyYXAoeG8sbnVsbCxbXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gZ2hlKGUpe2xldHtpbnB1dHM6e3g6dH0sYmFja2VuZDpuLGF0dHJzOntwYWRkaW5nczphLGNvbnN0YW50VmFsdWU6cn19PWUscz1hLm1hcCgobSxmKT0+bVswXSt0LnNoYXBlW2ZdK21bMV0pO2lmKHcuc2l6ZUZyb21TaGFwZSh0LnNoYXBlKT09PTApcmV0dXJuIExGKHtiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnMsdmFsdWU6cixkdHlwZTp0LmR0eXBlfX0pO2xldCBpPW4uZGF0YUlkTWFwLmdldCh0LmRhdGFJZCkuaWQsbz1uLm1ha2VPdXRwdXQocyx0LmR0eXBlKSxsPW4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsdT1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh0LnNoYXBlKS5idWZmZXIpLHA9YS5tYXAobT0+bVswXSksZD1hLm1hcChtPT5tWzFdKSxjPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHApLmJ1ZmZlciksaD1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShkKS5idWZmZXIpO3JldHVybiBjJChpLHUsdC5zaGFwZS5sZW5ndGgsUWVbdC5kdHlwZV0sYyxoLHIsbCksb312YXIgZCQ9e2tlcm5lbE5hbWU6eG8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpnaGUsc2V0dXBGdW5jOmZoZX0sYmhlPSExLHloZT1VdCh2byxiaGUpLGgkO2Z1bmN0aW9uIHhoZShlKXtoJD1lLndhc20uY3dyYXAod28sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB2aGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bn09ZSx7eDphLGFscGhhOnJ9PXQscz1uLmRhdGFJZE1hcC5nZXQoYS5kYXRhSWQpLmlkLGk9bi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxvPXMsbD1hLHU9bDtsLmR0eXBlIT09XCJmbG9hdDMyXCImJih1PVJzKHtiYWNrZW5kOm4saW5wdXRzOnt4OmF9LGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KSxvPW4uZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWQpO2xldCBwPW4ubWFrZU91dHB1dChhLnNoYXBlLFwiZmxvYXQzMlwiKSxkPW4uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQ7cmV0dXJuIGgkKG8saSxkKSxsLmR0eXBlIT09XCJmbG9hdDMyXCImJm4uZGlzcG9zZURhdGEodS5kYXRhSWQpLHB9dmFyIHdoZT17a2VybmVsTmFtZTp3byxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6eGhlLGtlcm5lbEZ1bmM6dmhlfSxtJDtmdW5jdGlvbiBraGUoZSl7bSQ9ZS53YXNtLmN3cmFwKGtvLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiBJaGUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtheGlzOnIsa2VlcERpbXM6c309YSx7eDppfT1uLG89dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxsPW8sdT1pLHt0cmFuc3Bvc2VkOnAsYXhlczpkLG9yaWdpbmFsQXhlczpjLGlucHV0V2FzVHJhbnNwb3NlZDpofT1EcyhpLHIsdCksbT1kO2lmKGgpe2xldCB4PXQuZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQ7eCE9PW8mJih1PXAsbD14LG09VC5nZXRJbm5lck1vc3RBeGVzKG0ubGVuZ3RoLHUuc2hhcGUubGVuZ3RoKSl9VC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhcInByb2RcIixtLHUuc2hhcGUubGVuZ3RoKTtsZXRbZixnXT1ULmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXModS5zaGFwZSxtKSxiPXcuc2l6ZUZyb21TaGFwZShnKSx5PXQubWFrZU91dHB1dChmLHUuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZSh1LnNoYXBlKSE9PTApe2xldCB4PXQuZGF0YUlkTWFwLmdldCh5LmRhdGFJZCkuaWQ7bSQobCxiLFFlW3kuZHR5cGVdLHgpfWlmKGgmJnQuZGlzcG9zZURhdGEocC5kYXRhSWQpLHMpe2xldCB4PVQuZXhwYW5kU2hhcGVUb0tlZXBEaW0oeS5zaGFwZSxjKTt5LnNoYXBlPXh9cmV0dXJuIHl9dmFyIFNoZT17a2VybmVsTmFtZTprbyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6a2hlLGtlcm5lbEZ1bmM6SWhlfSxOaGU9ZT0+e2xldHtiYWNrZW5kOnQsYXR0cnM6bn09ZSx7c3RhcnQ6YSxzdG9wOnIsc3RlcDpzLGR0eXBlOml9PW4sbz1CMShhLHIscyxpKSxsPXQubWFrZU91dHB1dChbby5sZW5ndGhdLGkpO3JldHVybiB0LnR5cGVkQXJyYXlGcm9tSGVhcChsKS5zZXQobyksbH0sVGhlPXtrZXJuZWxOYW1lOlVjLGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6TmhlfSxDaGU9ITAsRWhlPVV0KEhpLENoZSksX2hlPVhlKElvKSxBaGU9WGUoU28pLEZoZT1YZShDbyksZiQ7ZnVuY3Rpb24gJGhlKGUpe2YkPWUud2FzbS5jd3JhcChUbyxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gRGhlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7aW1hZ2VzOnJ9PW4se2FsaWduQ29ybmVyczpzLGhhbGZQaXhlbENlbnRlcnM6aSxzaXplOm99PWEsW2wsdV09byxbcCxkLGMsaF09ci5zaGFwZSxtPVtwLGwsdSxoXSxmPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCksZztmLmR0eXBlIT09XCJmbG9hdDMyXCImJihnPVJzKHtiYWNrZW5kOnQsaW5wdXRzOnt4OnJ9LGF0dHJzOntkdHlwZTpcImZsb2F0MzJcIn19KSxmPXQuZGF0YUlkTWFwLmdldChnLmRhdGFJZCkpO2xldCBiPWYuaWQseT10Lm1ha2VPdXRwdXQobSxcImZsb2F0MzJcIik7aWYody5zaXplRnJvbVNoYXBlKHIuc2hhcGUpPT09MClyZXR1cm4geTtsZXQgeD10LmRhdGFJZE1hcC5nZXQoeS5kYXRhSWQpLmlkO3JldHVybiBmJChiLHAsZCxjLGgsbCx1LHM/MTowLGk/MTowLHgpLGchPW51bGwmJnQuZGlzcG9zZURhdGEoZy5kYXRhSWQpLHl9dmFyIFJoZT17a2VybmVsTmFtZTpUbyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6JGhlLGtlcm5lbEZ1bmM6RGhlfSxnJDtmdW5jdGlvbiBNaGUoZSl7ZyQ9ZS53YXNtLmN3cmFwKE91LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJib29sZWFuXCJdKX1mdW5jdGlvbiBPaGUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHtpbWFnZXM6cixkeTpzfT10LHthbGlnbkNvcm5lcnM6aX09YSxvPW4ubWFrZU91dHB1dChyLnNoYXBlLFwiZmxvYXQzMlwiKSxsPW4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCksdTtyZXR1cm4gbC5kdHlwZSE9PVwiZmxvYXQzMlwiJiYodT1Scyh7YmFja2VuZDpuLGlucHV0czp7eDpyfSxhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSksbD1uLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpKSxnJChuLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbi5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZCxuZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShyLnNoYXBlKS5idWZmZXIpLG5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHMuc2hhcGUpLmJ1ZmZlciksaSksdSE9bnVsbCYmbi5kaXNwb3NlRGF0YSh1LmRhdGFJZCksb312YXIgUGhlPXtrZXJuZWxOYW1lOk91LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpNaGUsa2VybmVsRnVuYzpPaGV9LGIkO2Z1bmN0aW9uIExoZShlKXtiJD1lLndhc20uY3dyYXAoTm8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHpoZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2ltYWdlczpyfT1uLHthbGlnbkNvcm5lcnM6cyxoYWxmUGl4ZWxDZW50ZXJzOmksc2l6ZTpvfT1hLFtsLHVdPW8sW3AsZCxjLGhdPXIuc2hhcGUsbT1bcCxsLHUsaF0sZj10Lm1ha2VPdXRwdXQobSxcImZsb2F0MzJcIik7aWYody5zaXplRnJvbVNoYXBlKHIuc2hhcGUpPT09MClyZXR1cm4gZjtsZXQgZz10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLGI7Zy5kdHlwZSE9PVwiZmxvYXQzMlwiJiYoYj1Scyh7YmFja2VuZDp0LGlucHV0czp7eDpyfSxhdHRyczp7ZHR5cGU6XCJmbG9hdDMyXCJ9fSksZz10LmRhdGFJZE1hcC5nZXQoYi5kYXRhSWQpKTtsZXQgeT1nLmlkLHg9dC5kYXRhSWRNYXAuZ2V0KGYuZGF0YUlkKS5pZDtyZXR1cm4gYiQoeSxwLGQsYyxoLGwsdSxzPzE6MCxpPzE6MCx4KSxiIT1udWxsJiZ0LmRpc3Bvc2VEYXRhKGIuZGF0YUlkKSxmfXZhciBXaGU9e2tlcm5lbE5hbWU6Tm8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkxoZSxrZXJuZWxGdW5jOnpoZX0seSQ7ZnVuY3Rpb24gQmhlKGUpe3kkPWUud2FzbS5jd3JhcChNdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJhcnJheVwiLFwiYm9vbGVhblwiXSl9ZnVuY3Rpb24gVmhlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2VzOnIsZHk6c309dCx7YWxpZ25Db3JuZXJzOml9PWEsbz1uLm1ha2VPdXRwdXQoci5zaGFwZSxcImZsb2F0MzJcIiksbD1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLHU7cmV0dXJuIGwuZHR5cGUhPT1cImZsb2F0MzJcIiYmKHU9UnMoe2JhY2tlbmQ6bixpbnB1dHM6e3g6cn0sYXR0cnM6e2R0eXBlOlwiZmxvYXQzMlwifX0pLGw9bi5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKSkseSQobi5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxuLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG4uZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQsbmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoci5zaGFwZSkuYnVmZmVyKSxuZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShzLnNoYXBlKS5idWZmZXIpLGkpLHUhPW51bGwmJm4uZGlzcG9zZURhdGEodS5kYXRhSWQpLG99dmFyIFVoZT17a2VybmVsTmFtZTpNdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6QmhlLGtlcm5lbEZ1bmM6VmhlfSx4JDtmdW5jdGlvbiBHaGUoZSl7eCQ9ZS53YXNtLmN3cmFwKEVvLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIEhoZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCx7ZGltczpzfT1hLGk9dy5wYXJzZUF4aXNQYXJhbShzLHIuc2hhcGUpO2lmKHIuc2hhcGUubGVuZ3RoPT09MClyZXR1cm4gR2Yoe2lucHV0czp7eDpyfSxiYWNrZW5kOm59KTtsZXQgbz1uLm1ha2VPdXRwdXQoci5zaGFwZSxyLmR0eXBlKSxsPW4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsdT1uLmRhdGFJZE1hcC5nZXQoby5kYXRhSWQpLmlkLHA9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoaSkuYnVmZmVyKSxkPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHIuc2hhcGUpLmJ1ZmZlcik7eCQobCxwLGkubGVuZ3RoLGQsci5zaGFwZS5sZW5ndGgsdSk7bGV0IGM9em4oe2lucHV0czp7eDpvfSxhdHRyczp7c2hhcGU6ci5zaGFwZX0sYmFja2VuZDpufSk7cmV0dXJuIG4uZGlzcG9zZURhdGEoby5kYXRhSWQpLGN9dmFyIGpoZT17a2VybmVsTmFtZTpFbyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOkhoZSxzZXR1cEZ1bmM6R2hlfSx2JDtmdW5jdGlvbiBxaGUoZSl7diQ9ZS53YXNtLmN3cmFwKFp1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gS2hlKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7aW1hZ2U6cn09dCx7cmFkaWFuczpzLGZpbGxWYWx1ZTppLGNlbnRlcjpvfT1hLGw9bi5tYWtlT3V0cHV0KHIuc2hhcGUsci5kdHlwZSksdT1uLmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLHA9bi5kYXRhSWRNYXAuZ2V0KGwuZGF0YUlkKS5pZCxbZCxjLGgsbV09ci5zaGFwZSxbZixnXT1ULmdldEltYWdlQ2VudGVyKG8sYyxoKSxiPWk9PT0wLHk9MjU1LHg9dHlwZW9mIGk9PVwibnVtYmVyXCI/W2ksaSxpLGI/MDp5XTpbLi4uaSx5XSx2PW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHgpLmJ1ZmZlcik7cmV0dXJuIHYkKHUsZCxjLGgsbSxzLGYsZyx2LHgubGVuZ3RoLHApLGx9dmFyIFhoZT17a2VybmVsTmFtZTpadSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOktoZSxzZXR1cEZ1bmM6cWhlfSxZaGU9WGUoX28pLFpoZT1YZShBbyksdyQ7ZnVuY3Rpb24gSmhlKGUpe3ckPWUud2FzbS5jd3JhcChQdSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gUWhlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7aW5kaWNlczpyLHVwZGF0ZXM6c309bix7c2hhcGU6aX09YSxvPXQubWFrZU91dHB1dChpLHMuZHR5cGUpO2lmKHcuc2l6ZUZyb21TaGFwZShpKT09PTApcmV0dXJuIG87bGV0e3NsaWNlUmFuazpsLG51bVVwZGF0ZXM6dSxzbGljZVNpemU6cCxzdHJpZGVzOmQsb3V0cHV0U2l6ZTpjfT1zZi5jYWxjdWxhdGVTaGFwZXMocyxyLGkpLGg9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxtPXQuZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsZj1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShkKS5idWZmZXIpLGc9dC5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZDtyZXR1cm4gdyQoaCxtLFFlW3MuZHR5cGVdLGwsdSxwLGYsYyxnKSxvfXZhciBlbWU9e2tlcm5lbE5hbWU6UHUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkpoZSxrZXJuZWxGdW5jOlFoZX0sayQ7ZnVuY3Rpb24gdG1lKGUpe2skPWUud2FzbS5jd3JhcCh6dSxudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImJvb2xcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gbm1lKGUpe2xldHtpbnB1dHM6dCxiYWNrZW5kOm4sYXR0cnM6YX09ZSx7c29ydGVkU2VxdWVuY2U6cix2YWx1ZXM6c309dCx7c2lkZTppfT1hO2lmKHIuZHR5cGUhPT1zLmR0eXBlKXRocm93IG5ldyBFcnJvcihgU2VhcmNoU29ydGVkIGVycm9yOiBzb3J0ZWRfc2VxdWVuY2UgbXVzdCBoYXZlIHRoZSBzYW1lIGR0eXBlIGFzIHZhbHVlcy4gR290ICR7ci5kdHlwZX0gYW5kICR7cy5kdHlwZX1gKTtsZXQgbz1uLm1ha2VPdXRwdXQocy5zaGFwZSxcImludDMyXCIpO2Z1bmN0aW9uIGwodSl7cmV0dXJuIG4uZGF0YUlkTWFwLmdldCh1LmRhdGFJZCkuaWR9cmV0dXJuIGskKGwociksbChzKSxyLnNoYXBlWzBdLHIuc2hhcGVbMV0scy5zaGFwZVsxXSxRZVtyLmR0eXBlXSxpPT09XCJsZWZ0XCIsbChvKSksb312YXIgYW1lPXtrZXJuZWxOYW1lOnp1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzp0bWUsa2VybmVsRnVuYzpubWV9LEkkO2Z1bmN0aW9uIHJtZShlKXtJJD1lLndhc20uY3dyYXAoXCJTZWxlY3RWMlwiLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHNtZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpufT1lLHtjb25kaXRpb246YSx0OnIsZTpzfT10LGk9bi5kYXRhSWRNYXAuZ2V0KGEuZGF0YUlkKS5pZCxvPW4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbD1uLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLHU9bi5tYWtlT3V0cHV0KHIuc2hhcGUsci5kdHlwZSkscD1uLmRhdGFJZE1hcC5nZXQodS5kYXRhSWQpLmlkLGQ9YS5zaGFwZS5sZW5ndGgsYz1yLnNoYXBlLmxlbmd0aCxoPWQ9PT0wfHxkPjF8fGM9PT0xPzE6dy5zaXplRnJvbVNoYXBlKHIuc2hhcGUuc2xpY2UoMSkpO3JldHVybiBJJChpLG8sbCxoLHApLHV9dmFyIGltZT17a2VybmVsTmFtZTpXdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOnNtZSxzZXR1cEZ1bmM6cm1lfSxvbWU9WGUoRm8pLFMkO2Z1bmN0aW9uIGxtZShlKXtTJD1lLndhc20uY3dyYXAoTW8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gdW1lKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOnt4Om59fT1lLGE9dC5kYXRhSWRNYXAuZ2V0KG4uZGF0YUlkKS5pZCxyPXQubWFrZU91dHB1dChuLnNoYXBlLG4uZHR5cGUpLHM9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZDtyZXR1cm4gdy5zaXplRnJvbVNoYXBlKHIuc2hhcGUpPT09MHx8UyQoYSxzKSxyfXZhciBwbWU9e2tlcm5lbE5hbWU6XCJTaWdtb2lkXCIsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOmxtZSxrZXJuZWxGdW5jOnVtZX0sY21lPVhlKFJvKSxkbWU9WGUoJG8pLGhtZT1YZShEbyksbW1lPVhlKE9vKTtmdW5jdGlvbiBmbWUoZSl7bGV0e2lucHV0czp0LGJhY2tlbmQ6bixhdHRyczphfT1lLHt4OnJ9PXQse2Jsb2NrU2hhcGU6cyxwYWRkaW5nczppfT1hLG89dy5zaXplRnJvbVNoYXBlKHMpLGw9W1swLDBdXTtsLnB1c2goLi4uaSk7Zm9yKGxldCBnPTErcy5sZW5ndGg7ZzxyLnNoYXBlLmxlbmd0aDsrK2cpbC5wdXNoKFswLDBdKTtsZXQgdT1kJC5rZXJuZWxGdW5jKHtpbnB1dHM6e3g6cn0sYmFja2VuZDpuLGF0dHJzOntwYWRkaW5nczpsLGNvbnN0YW50VmFsdWU6MH19KSxwPVQuZ2V0UmVzaGFwZWQodS5zaGFwZSxzLG8sITEpLGQ9VC5nZXRQZXJtdXRlZChwLmxlbmd0aCxzLmxlbmd0aCwhMSksYz1ULmdldFJlc2hhcGVkUGVybXV0ZWQodS5zaGFwZSxzLG8sITEpLGg9em4oe2lucHV0czp7eDp1fSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOnB9fSksbT15cyh7aW5wdXRzOnt4Omh9LGJhY2tlbmQ6bixhdHRyczp7cGVybTpkfX0pLGY9em4oe2lucHV0czp7eDptfSxiYWNrZW5kOm4sYXR0cnM6e3NoYXBlOmN9fSk7cmV0dXJuIG4uZGlzcG9zZURhdGEodS5kYXRhSWQpLG4uZGlzcG9zZURhdGEoaC5kYXRhSWQpLG4uZGlzcG9zZURhdGEobS5kYXRhSWQpLGZ9dmFyIGdtZT17a2VybmVsTmFtZTpWdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOmZtZX0sTiQ7ZnVuY3Rpb24gYm1lKGUpe04kPWUud2FzbS5jd3JhcChcIlNwYXJzZUZpbGxFbXB0eVJvd3NcIixcIm51bWJlclwiLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHltZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpufT1lLHtpbmRpY2VzOmEsdmFsdWVzOnIsZGVuc2VTaGFwZTpzLGRlZmF1bHRWYWx1ZTppfT1uLG89YS5zaGFwZVswXSxsPWEuc2hhcGVbMV0sdT10LnJlYWRTeW5jKHMuZGF0YUlkKVswXSxwPVtvK3UsbF0sZD10LmRhdGFJZE1hcC5nZXQoYS5kYXRhSWQpLmlkLGM9dC5kYXRhSWRNYXAuZ2V0KHIuZGF0YUlkKS5pZCxoPXQuZGF0YUlkTWFwLmdldChpLmRhdGFJZCkuaWQsbT10Lm1ha2VPdXRwdXQocCxhLmR0eXBlKSxmPXQuZGF0YUlkTWFwLmdldChtLmRhdGFJZCkuaWQsZz10Lm1ha2VPdXRwdXQocC5zbGljZSgwLDEpLHIuZHR5cGUpLGI9dC5kYXRhSWRNYXAuZ2V0KGcuZGF0YUlkKS5pZCx5PXQubWFrZU91dHB1dChbdV0sXCJib29sXCIpLHg9dC5kYXRhSWRNYXAuZ2V0KHkuZGF0YUlkKS5pZCx2PXQubWFrZU91dHB1dChbb10sYS5kdHlwZSksST10LmRhdGFJZE1hcC5nZXQodi5kYXRhSWQpLmlkLE49dC5tYWtlT3V0cHV0KFs0XSxcImludDMyXCIpLEM9dC5kYXRhSWRNYXAuZ2V0KE4uZGF0YUlkKS5pZCxfPU4kKGQsYyxRZVtyLmR0eXBlXSxvLHUsbCxoLGYsYix4LEksQyksRj10LnJlYWRTeW5jKE4uZGF0YUlkKSxEO3N3aXRjaChGWzBdKXtjYXNlIDE6e0Q9VC5nZXRTcGFyc2VGaWxsRW1wdHlSb3dzSW5kaWNlc0RlbnNlU2hhcGVNaXNtYXRjaChGWzFdKTticmVha31jYXNlIDI6e0Q9VC5nZXRTcGFyc2VGaWxsRW1wdHlSb3dzTmVnYXRpdmVJbmRleEVycm9yTWVzc2FnZShGWzFdLEZbMl0pO2JyZWFrfWNhc2UgMzpEPVQuZ2V0U3BhcnNlRmlsbEVtcHR5Um93c091dE9mUmFuZ2VJbmRleEVycm9yTWVzc2FnZShGWzFdLEZbMl0sRlszXSk7YnJlYWs7ZGVmYXVsdDpEPVwiXCJ9aWYodC5kaXNwb3NlRGF0YShOLmRhdGFJZCksRCl0aHJvdyB0LmRpc3Bvc2VEYXRhKG0uZGF0YUlkKSx0LmRpc3Bvc2VEYXRhKGcuZGF0YUlkKSx0LmRpc3Bvc2VEYXRhKHkuZGF0YUlkKSx0LmRpc3Bvc2VEYXRhKHYuZGF0YUlkKSxuZXcgRXJyb3IoRCk7bGV0ICQ9bSxTPWc7cmV0dXJuIF8hPT1wWzBdJiYoJD1JaSh7aW5wdXRzOnt4Om19LGF0dHJzOntiZWdpbjowLHNpemU6W18sbF19LGJhY2tlbmQ6dH0pLFM9SWkoe2lucHV0czp7eDpnfSxhdHRyczp7YmVnaW46MCxzaXplOl99LGJhY2tlbmQ6dH0pLHQuZGlzcG9zZURhdGEobS5kYXRhSWQpLHQuZGlzcG9zZURhdGEoZy5kYXRhSWQpKSxbJCxTLHksdl19dmFyIHhtZT17a2VybmVsTmFtZTpHYyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6Ym1lLGtlcm5lbEZ1bmM6eW1lfSxUJDtmdW5jdGlvbiB2bWUoZSl7VCQ9ZS53YXNtLmN3cmFwKEd1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCJdKX1mdW5jdGlvbiB3bWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bn09ZSx7aW5wdXRJbmRpY2VzOmEsaW5wdXRTaGFwZTpyLG5ld1NoYXBlOnN9PW47aWYoYS5zaGFwZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgaW5kaWNlcyBzaG91bGQgYmUgYSBtYXRyaXggYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICR7YS5zaGFwZX1gKTtpZihyLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaGFwZSBzaG91bGQgYmUgYSB2ZWN0b3IgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICR7ci5zaGFwZX1gKTtpZihzLnNoYXBlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKGBUYXJnZXQgc2hhcGUgc2hvdWxkIGJlIGEgdmVjdG9yIGJ1dCByZWNlaXZlZCBzaGFwZSAke3Muc2hhcGV9YCk7bGV0IGk9dC5kYXRhSWRNYXAuZ2V0KGEuZGF0YUlkKS5pZCxvPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsbD10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLHU9YS5zaGFwZVswXSxwPXcuc2l6ZUZyb21TaGFwZShzLnNoYXBlKSxkPXQubWFrZU91dHB1dChbdSxwXSxhLmR0eXBlKSxjPXQuZGF0YUlkTWFwLmdldChkLmRhdGFJZCkuaWQsaD10Lm1ha2VPdXRwdXQoW3BdLHMuZHR5cGUpLG09dC5kYXRhSWRNYXAuZ2V0KGguZGF0YUlkKS5pZCxmPXQubWFrZU91dHB1dChbM10sXCJpbnQzMlwiKSxnPXQuZGF0YUlkTWFwLmdldChmLmRhdGFJZCkuaWQ7VCQoaSxvLGwsdSxjLG0sZyk7bGV0IGI9dC5yZWFkU3luYyhmLmRhdGFJZCkseTtzd2l0Y2goYlswXSl7Y2FzZSAwOnt5PVQuZ2V0U3BhcnNlUmVzaGFwZU11bHRpcGxlTmVnYXRpdmVPbmVPdXRwdXREaW1FcnJvck1lc3NhZ2UoYlsxXSxiWzJdKTticmVha31jYXNlIDE6e3k9VC5nZXRTcGFyc2VSZXNoYXBlTmVnYXRpdmVPdXRwdXREaW1FcnJvck1lc3NhZ2UoYlsxXSxiWzJdKTticmVha31jYXNlIDI6eT1ULmdldFNwYXJzZVJlc2hhcGVFbXB0eVRlbnNvclplcm9PdXRwdXREaW1FcnJvck1lc3NhZ2UoKTticmVhaztjYXNlIDM6e2xldCB4PUFycmF5LmZyb20odC5yZWFkU3luYyhyLmRhdGFJZCkpLHY9QXJyYXkuZnJvbSh0LnJlYWRTeW5jKGguZGF0YUlkKSk7eT1ULmdldFNwYXJzZVJlc2hhcGVJbnB1dE91dHB1dE11bHRpcGxlRXJyb3JNZXNzYWdlKHgsdik7YnJlYWt9Y2FzZSA0OntsZXQgeD1BcnJheS5mcm9tKHQucmVhZFN5bmMoci5kYXRhSWQpKSx2PUFycmF5LmZyb20odC5yZWFkU3luYyhoLmRhdGFJZCkpO3k9VC5nZXRTcGFyc2VSZXNoYXBlSW5wdXRPdXRwdXRNaXNtYXRjaEVycm9yTWVzc2FnZSh4LHYpO2JyZWFrfWRlZmF1bHQ6eT1cIlwifWlmKHQuZGlzcG9zZURhdGEoZi5kYXRhSWQpLHkpdGhyb3cgdC5kaXNwb3NlRGF0YShkLmRhdGFJZCksdC5kaXNwb3NlRGF0YShoLmRhdGFJZCksbmV3IEVycm9yKHkpO3JldHVybltkLGhdfXZhciBrbWU9e2tlcm5lbE5hbWU6R3UsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnZtZSxrZXJuZWxGdW5jOndtZX0sQyQ7ZnVuY3Rpb24gRSQoZSl7QyQ9ZS53YXNtLmN3cmFwKFwiU3BhcnNlU2VnbWVudFJlZHVjdGlvblwiLG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gXyQoZSx0KXtsZXR7YmFja2VuZDpuLGlucHV0czphfT1lLHtkYXRhOnIsaW5kaWNlczpzLHNlZ21lbnRJZHM6aX09YSxvPXMuc2hhcGVbMF0sbD1uLnJlYWRTeW5jKGkuZGF0YUlkLG8tMSxvKVswXSx1PW8+MD9sKzE6MDtpZih1PDApdGhyb3cgbmV3IEVycm9yKFQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbk5lZ2F0aXZlU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpKTtsZXQgcD1yLnNoYXBlLnNsaWNlKCk7cFswXT11O2xldCBkPW4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsYz1uLmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLGg9bi5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxtPW4ubWFrZU91dHB1dChwLHIuZHR5cGUpLGY9bi5kYXRhSWRNYXAuZ2V0KG0uZGF0YUlkKS5pZCxnPW4ubWFrZU91dHB1dChbNF0sXCJpbnQzMlwiKSxiPW4uZGF0YUlkTWFwLmdldChnLmRhdGFJZCkuaWQ7QyQoZCxRZVtyLmR0eXBlXSxyLnNoYXBlWzBdLGMsaCxmLGIsdCwwKTtsZXQgeT1uLnJlYWRTeW5jKGcuZGF0YUlkKSx4O3N3aXRjaCh5WzBdKXtjYXNlIDA6e3g9VC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uTmVnYXRpdmVTZWdtZW50SWRzRXJyb3JNZXNzYWdlKCk7YnJlYWt9Y2FzZSAxOnt4PVQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbk5vbkluY3JlYXNpbmdTZWdtZW50SWRzRXJyb3JNZXNzYWdlKCk7YnJlYWt9Y2FzZSAyOng9VC5nZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uU2VnbWVudElkT3V0T2ZSYW5nZUVycm9yTWVzc2FnZSh5WzFdLHlbMl0pO2JyZWFrO2Nhc2UgMzp4PVQuZ2V0U3BhcnNlU2VnbWVudFJlZHVjdGlvbkluZGljZXNPdXRPZlJhbmdlRXJyb3JNZXNzYWdlKHlbMV0seVsyXSx5WzNdKTticmVhaztkZWZhdWx0Ong9XCJcIn1pZihuLmRpc3Bvc2VEYXRhKGcuZGF0YUlkKSx4KXRocm93IG4uZGlzcG9zZURhdGEobS5kYXRhSWQpLG5ldyBFcnJvcih4KTtyZXR1cm4gbX1mdW5jdGlvbiBJbWUoZSl7cmV0dXJuIF8kKGUsITApfXZhciBTbWU9e2tlcm5lbE5hbWU6SGMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkUkLGtlcm5lbEZ1bmM6SW1lfTtmdW5jdGlvbiBObWUoZSl7cmV0dXJuIF8kKGUsITEpfXZhciBUbWU9e2tlcm5lbE5hbWU6amMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOkUkLGtlcm5lbEZ1bmM6Tm1lfSxBJDtmdW5jdGlvbiBDbWUoZSl7QSQ9ZS53YXNtLmN3cmFwKEh1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gRW1lKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7c3BhcnNlSW5kaWNlczpyLHNwYXJzZVZhbHVlczpzLGRlZmF1bHRWYWx1ZTppfT1uLHtvdXRwdXRTaGFwZTpvfT1hLGw9dC5tYWtlT3V0cHV0KG8saS5kdHlwZSk7aWYody5zaXplRnJvbVNoYXBlKG8pPT09MClyZXR1cm4gbDtsZXR7c2xpY2VSYW5rOnUsbnVtVXBkYXRlczpwLHNsaWNlU2l6ZTpkLHN0cmlkZXM6YyxvdXRwdXRTaXplOmh9PVQuY2FsY3VsYXRlU2hhcGVzKHMscixvKSxtPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsZj10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLGc9dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxiPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KGMpLmJ1ZmZlcikseT10LmRhdGFJZE1hcC5nZXQobC5kYXRhSWQpLmlkO3JldHVybiBBJChtLGYscy5zaGFwZS5sZW5ndGgsZyxRZVtpLmR0eXBlXSx1LHAsZCxiLGgseSksbH12YXIgX21lPXtrZXJuZWxOYW1lOkh1LGJhY2tlbmROYW1lOlwid2FzbVwiLHNldHVwRnVuYzpDbWUsa2VybmVsRnVuYzpFbWV9O2Z1bmN0aW9uIEFtZShlKXtsZXR7aW5wdXRzOnQsYXR0cnM6bixiYWNrZW5kOmF9PWUse3g6cn09dCx7bnVtT3JTaXplU3BsaXRzOnMsYXhpczppfT1uLG89dy5wYXJzZUF4aXNQYXJhbShpLHIuc2hhcGUpWzBdLGw9VC5wcmVwYXJlU3BsaXRTaXplKHIscyxvKSx1PW5ldyBBcnJheShyLnNoYXBlLmxlbmd0aCkuZmlsbCgwKSxwPXIuc2hhcGUuc2xpY2UoKTtyZXR1cm4gbC5tYXAoZD0+e2xldCBjPVsuLi5wXTtjW29dPWQ7bGV0IGg9SWkoe2lucHV0czp7eDpyfSxhdHRyczp7YmVnaW46dSxzaXplOmN9LGJhY2tlbmQ6YX0pO3JldHVybiB1W29dKz1kLGh9KX12YXIgRm1lPXtrZXJuZWxOYW1lOlV1LGJhY2tlbmROYW1lOlwid2FzbVwiLGtlcm5lbEZ1bmM6QW1lfSwkbWU9WGUoUG8pLERtZT1YZShxYyksUm1lPSEwLE1tZT1VdChXbyxSbWUpLEYkO2Z1bmN0aW9uIE9tZShlKXtGJD1lLndhc20uY3dyYXAoSXMsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFBtZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2FscGhhOnJ9PWEse3g6c309bixpPXQuZGF0YUlkTWFwLmdldChzLmRhdGFJZCkuaWQsbz10Lm1ha2VPdXRwdXQocy5zaGFwZSxzLmR0eXBlKSxsPXQuZGF0YUlkTWFwLmdldChvLmRhdGFJZCkuaWQ7cmV0dXJuIEYkKGkscixRZVtzLmR0eXBlXSxsKSxvfXZhciBMbWU9e2tlcm5lbE5hbWU6SXMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOk9tZSxrZXJuZWxGdW5jOlBtZX0sJCQ7ZnVuY3Rpb24gem1lKGUpeyQkPWUud2FzbS5jd3JhcChqdSxudWxsLFtcIm51bWJlclwiLFwiYXJyYXlcIixcIm51bWJlclwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gV21lKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7eDpyfT1uLHtiZWdpbjpzLGVuZDppLHN0cmlkZXM6byxiZWdpbk1hc2s6bCxlbmRNYXNrOnUsZWxsaXBzaXNNYXNrOnAsbmV3QXhpc01hc2s6ZCxzaHJpbmtBeGlzTWFzazpjfT1hLHtmaW5hbFNoYXBlU3BhcnNlOmgsZmluYWxTaGFwZTptLGlzSWRlbnRpdHk6ZixzbGljZURpbTA6Zyxpc1NpbXBsZVNsaWNlOmIsYmVnaW46eSxlbmQ6eCxzdHJpZGVzOnZ9PUt0LnNsaWNlSW5mbyhyLnNoYXBlLHMsaSxvLGwsdSxwLGQsYyksSTtpZihmKUk9em4oe2lucHV0czp7eDpyfSxiYWNrZW5kOnQsYXR0cnM6e3NoYXBlOm19fSk7ZWxzZSBpZihnfHxiKXt3LmFzc2VydChyLnNoYXBlLmxlbmd0aD49MSwoKT0+YElucHV0IG11c3QgaGF2ZSByYW5rIGF0IGxlYXN0IDEsIGdvdDogJHtyLnNoYXBlLmxlbmd0aH1gKTtsZXQgTj1LdC5jb21wdXRlT3V0U2hhcGUoeSx4LHYpLEM9SWkoe2lucHV0czp7eDpyfSxiYWNrZW5kOnQsYXR0cnM6e2JlZ2luOnksc2l6ZTpOfX0pO0k9em4oe2lucHV0czp7eDpDfSxiYWNrZW5kOnQsYXR0cnM6e3NoYXBlOm19fSksdC5kaXNwb3NlRGF0YShDLmRhdGFJZCl9ZWxzZXtsZXQgTj10Lm1ha2VPdXRwdXQoaCxcImZsb2F0MzJcIiksQz10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLF89bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkody5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSkuYnVmZmVyKSxGPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHkpLmJ1ZmZlciksRD1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh4KS5idWZmZXIpLCQ9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkodikuYnVmZmVyKSxTPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KGgpLmJ1ZmZlciksTT1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheSh3LmNvbXB1dGVTdHJpZGVzKGgpKS5idWZmZXIpLEI9dC5kYXRhSWRNYXAuZ2V0KE4uZGF0YUlkKS5pZDskJChDLF8sci5zaGFwZS5sZW5ndGgsRixELCQsUyxNLGgubGVuZ3RoLEIpLEk9em4oe2lucHV0czp7eDpOfSxiYWNrZW5kOnQsYXR0cnM6e3NoYXBlOm19fSksdC5kaXNwb3NlRGF0YShOLmRhdGFJZCl9cmV0dXJuIEl9dmFyIEJtZT17a2VybmVsTmFtZTpqdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6em1lLGtlcm5lbEZ1bmM6V21lfTtmdW5jdGlvbiBWbWUoZSl7bGV0e2JhY2tlbmQ6dCxpbnB1dHM6bixhdHRyczphfT1lLHtkYXRhOnIsZGF0YVNwbGl0czpzfT1uLHtzZXBhcmF0b3I6aSxuR3JhbVdpZHRoczpvLGxlZnRQYWQ6bCxyaWdodFBhZDp1LHBhZFdpZHRoOnAscHJlc2VydmVTaG9ydFNlcXVlbmNlczpkfT1hLGM9dC5yZWFkU3luYyhyLmRhdGFJZCksaD10LnJlYWRTeW5jKHMuZGF0YUlkKSxbbSxmXT1VMShjLGgsaSxvLGwsdSxwLGQpLGc9dC5tYWtlT3V0cHV0KFttLmxlbmd0aF0sXCJzdHJpbmdcIiksYj10LmRhdGFJZE1hcC5nZXQoZy5kYXRhSWQpO2Iuc3RyaW5nQnl0ZXM9bTtsZXQgeT10Lm1ha2VPdXRwdXQocy5zaGFwZSxcImludDMyXCIpO3JldHVybiB0LnR5cGVkQXJyYXlGcm9tSGVhcCh5KS5zZXQoZiksW2cseV19dmFyIFVtZT17a2VybmVsTmFtZTpYYyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOlZtZX07ZnVuY3Rpb24gR21lKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7aW5wdXQ6cixkZWxpbWl0ZXI6c309bix7c2tpcEVtcHR5Oml9PWEsbz10LnJlYWRTeW5jKHIuZGF0YUlkKSxsPXQucmVhZFN5bmMocy5kYXRhSWQpLFt1LHAsZF09RzEobyxsWzBdLGkpLGM9cC5sZW5ndGgsaD10Lm1ha2VPdXRwdXQoW2MsMl0sXCJpbnQzMlwiKTt0LnR5cGVkQXJyYXlGcm9tSGVhcChoKS5zZXQodSk7bGV0IG09dC5tYWtlT3V0cHV0KFtjXSxcInN0cmluZ1wiKSxmPXQuZGF0YUlkTWFwLmdldChtLmRhdGFJZCk7Zi5zdHJpbmdCeXRlcz1wO2xldCBnPXQubWFrZU91dHB1dChbMl0sXCJpbnQzMlwiKTtyZXR1cm4gdC50eXBlZEFycmF5RnJvbUhlYXAoZykuc2V0KGQpLFtoLG0sZ119dmFyIEhtZT17a2VybmVsTmFtZTpZYyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOkdtZX07ZnVuY3Rpb24gam1lKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7aW5wdXQ6cn09bix7bnVtQnVja2V0czpzfT1hLGk9dC5yZWFkU3luYyhyLmRhdGFJZCksbz1IMShpLHMpLGw9dC5tYWtlT3V0cHV0KHIuc2hhcGUsXCJpbnQzMlwiKTtyZXR1cm4gdC50eXBlZEFycmF5RnJvbUhlYXAobCkuc2V0KG8pLGx9dmFyIHFtZT17a2VybmVsTmFtZTpaYyxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOmptZX0sS21lPSEwLFhtZT1VdChCbyxLbWUpLEQkO2Z1bmN0aW9uIFltZShlKXtEJD1lLndhc20uY3dyYXAoTG8sbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIFptZShlKXtsZXR7YmFja2VuZDp0LGlucHV0czpuLGF0dHJzOmF9PWUse2F4aXM6cixrZWVwRGltczpzfT1hLHt4Oml9PW4sbz10LmRhdGFJZE1hcC5nZXQoaS5kYXRhSWQpLmlkLGw9byx1PWkse3RyYW5zcG9zZWQ6cCxheGVzOmQsb3JpZ2luYWxBeGVzOmMsaW5wdXRXYXNUcmFuc3Bvc2VkOmh9PURzKGkscix0KSxtPWQ7aWYoaCl7bGV0IHg9dC5kYXRhSWRNYXAuZ2V0KHAuZGF0YUlkKS5pZDt4IT09byYmKHU9cCxsPXgsbT1ULmdldElubmVyTW9zdEF4ZXMobS5sZW5ndGgsdS5zaGFwZS5sZW5ndGgpKX1ULmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKFwic3VtXCIsbSx1LnNoYXBlLmxlbmd0aCk7bGV0W2YsZ109VC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHUuc2hhcGUsbSksYj13LnNpemVGcm9tU2hhcGUoZykseT10Lm1ha2VPdXRwdXQoZix1LmR0eXBlKTtpZih3LnNpemVGcm9tU2hhcGUodS5zaGFwZSkhPT0wKXtsZXQgeD10LmRhdGFJZE1hcC5nZXQoeS5kYXRhSWQpLmlkO0QkKGwsYixRZVt5LmR0eXBlXSx4KX1pZihoJiZ0LmRpc3Bvc2VEYXRhKHAuZGF0YUlkKSxzKXtsZXQgeD1ULmV4cGFuZFNoYXBlVG9LZWVwRGltKHkuc2hhcGUsYyk7eS5zaGFwZT14fXJldHVybiB5fXZhciBKbWU9e2tlcm5lbE5hbWU6TG8sYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOlltZSxrZXJuZWxGdW5jOlptZX0sUW1lPVhlKFZvKSxlZmU9WGUoVW8pLFIkO2Z1bmN0aW9uIHRmZShlKXtSJD1lLndhc20uY3dyYXAoTHUsbnVsbCxbXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gbmZlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7dGVuc29yOnIsaW5kaWNlczpzLHVwZGF0ZXM6aX09bix7fT1hLG89dC5tYWtlT3V0cHV0KHIuc2hhcGUsci5kdHlwZSk7aWYody5zaXplRnJvbVNoYXBlKHIuc2hhcGUpPT09MClyZXR1cm4gbztsZXR7c2xpY2VSYW5rOmwsbnVtVXBkYXRlczp1LHNsaWNlU2l6ZTpwLHN0cmlkZXM6ZCxvdXRwdXRTaXplOmN9PXNmLmNhbGN1bGF0ZVNoYXBlcyhpLHMsci5zaGFwZSksaD10LmRhdGFJZE1hcC5nZXQocy5kYXRhSWQpLmlkLG09dC5kYXRhSWRNYXAuZ2V0KGkuZGF0YUlkKS5pZCxmPXQuZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQsZz1uZXcgVWludDhBcnJheShuZXcgSW50MzJBcnJheShkKS5idWZmZXIpLGI9dC5kYXRhSWRNYXAuZ2V0KG8uZGF0YUlkKS5pZDtyZXR1cm4gUiQoaCxtLFFlW2kuZHR5cGVdLGwsdSxwLGcsYyxiLGYpLG99dmFyIGFmZT17a2VybmVsTmFtZTpMdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6dGZlLGtlcm5lbEZ1bmM6bmZlfSxNJDtmdW5jdGlvbiByZmUoZSl7TSQ9ZS53YXNtLmN3cmFwKGtzLG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfWZ1bmN0aW9uIHNmZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3g6cn09dCxzPW4uZGF0YUlkTWFwLmdldChyLmRhdGFJZCkuaWQse3JlcHM6aX09YSxvPW5ldyBBcnJheShyLnNoYXBlLmxlbmd0aCk7Zm9yKGxldCBjPTA7YzxvLmxlbmd0aDtjKyspb1tjXT1yLnNoYXBlW2NdKmlbY107bGV0IGw9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkoci5zaGFwZSkuYnVmZmVyKSx1PW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KG8pLmJ1ZmZlcikscD1uLm1ha2VPdXRwdXQobyxyLmR0eXBlKSxkPW4uZGF0YUlkTWFwLmdldChwLmRhdGFJZCkuaWQ7cmV0dXJuIE0kKHMsbCxyLnNoYXBlLmxlbmd0aCx1LG8ubGVuZ3RoLFFlW3AuZHR5cGVdLGQpLHB9dmFyIGlmZT17a2VybmVsTmFtZTprcyxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6cmZlLGtlcm5lbEZ1bmM6c2ZlfSxPJDtmdW5jdGlvbiBvZmUoZSl7TyQ9ZS53YXNtLmN3cmFwKHF1LG51bGwsW1wibnVtYmVyXCIsXCJhcnJheVwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwiYm9vbFwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pfXZhciBsZmU9KHtpbnB1dHM6ZSxiYWNrZW5kOnQsYXR0cnM6bn0pPT57bGV0e3g6YX09ZSx7azpyLHNvcnRlZDpzfT1uLGk9dC5kYXRhSWRNYXAuZ2V0KGEuZGF0YUlkKS5pZCxvPW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KGEuc2hhcGUpLmJ1ZmZlciksbD1hLnNoYXBlLnNsaWNlKCk7bFtsLmxlbmd0aC0xXT1yO2xldCB1PXQubWFrZU91dHB1dChsLGEuZHR5cGUpLHA9dC5kYXRhSWRNYXAuZ2V0KHUuZGF0YUlkKS5pZCxkPXQubWFrZU91dHB1dChsLFwiaW50MzJcIiksYz10LmRhdGFJZE1hcC5nZXQoZC5kYXRhSWQpLmlkO3JldHVybiBPJChpLG8sYS5zaGFwZS5sZW5ndGgsUWVbYS5kdHlwZV0scixzLHAsYyksW3UsZF19LHVmZT17a2VybmVsTmFtZTpxdSxiYWNrZW5kTmFtZTpcIndhc21cIixzZXR1cEZ1bmM6b2ZlLGtlcm5lbEZ1bmM6bGZlfSxQJDtmdW5jdGlvbiBwZmUoZSl7UCQ9ZS53YXNtLmN3cmFwKEt1LG51bGwsW1wibnVtYmVyXCIsXCJudW1iZXJcIixcImJvb2xcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcImFycmF5XCIsXCJudW1iZXJcIixcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIixcIm51bWJlclwiXSl9ZnVuY3Rpb24gY2ZlKGUpe2xldHtiYWNrZW5kOnQsaW5wdXRzOm4sYXR0cnM6YX09ZSx7aW1hZ2U6cix0cmFuc2Zvcm1zOnN9PW4se2ludGVycG9sYXRpb246aSxmaWxsTW9kZTpvLGZpbGxWYWx1ZTpsLG91dHB1dFNoYXBlOnV9PWEsW3AsZCxjLGhdPXIuc2hhcGUsW20sZl09dSE9bnVsbD91OltkLGNdLGc9W3AsbSxmLGhdLGI9bmV3IFVpbnQ4QXJyYXkobmV3IEludDMyQXJyYXkody5jb21wdXRlU3RyaWRlcyhyLnNoYXBlKSkuYnVmZmVyKSx5PW5ldyBVaW50OEFycmF5KG5ldyBJbnQzMkFycmF5KHcuY29tcHV0ZVN0cmlkZXMoZykpLmJ1ZmZlcikseD10Lm1ha2VPdXRwdXQoZyxyLmR0eXBlKSx2PXQuZGF0YUlkTWFwLmdldCh4LmRhdGFJZCkuaWQsST10LmRhdGFJZE1hcC5nZXQoci5kYXRhSWQpLmlkLE49dC5kYXRhSWRNYXAuZ2V0KHMuZGF0YUlkKS5pZCxDPWk9PT1cIm5lYXJlc3RcIj8xOjIsXztzd2l0Y2gobyl7Y2FzZVwiY29uc3RhbnRcIjpfPTE7YnJlYWs7Y2FzZVwicmVmbGVjdFwiOl89MjticmVhaztjYXNlXCJ3cmFwXCI6Xz0zO2JyZWFrO2Nhc2VcIm5lYXJlc3RcIjpfPTQ7YnJlYWs7ZGVmYXVsdDpfPTE7YnJlYWt9cmV0dXJuIFAkKEksTixzLnNoYXBlWzBdPjEscCxtLGYsaCxjLGQsYixyLnNoYXBlLmxlbmd0aC0xLHksZy5sZW5ndGgtMSxDLF8sbCx2KSx4fXZhciBkZmU9e2tlcm5lbE5hbWU6S3UsYmFja2VuZE5hbWU6XCJ3YXNtXCIsc2V0dXBGdW5jOnBmZSxrZXJuZWxGdW5jOmNmZX07ZnVuY3Rpb24gaGZlKGUpe2xldHtpbnB1dHM6dCxhdHRyczpuLGJhY2tlbmQ6YX09ZSx7YXhpczpyfT1uLHt4OnN9PXQse291dHB1dFZhbHVlczppLG91dHB1dFNoYXBlOm8saW5kaWNlczpsfT1xMShhLnJlYWRTeW5jKHMuZGF0YUlkKSxyLHMuc2hhcGUscy5kdHlwZSk7cmV0dXJuW2EubWFrZU91dHB1dChvLHMuZHR5cGUsdm9pZCAwLGkpLGEubWFrZU91dHB1dChbbC5sZW5ndGhdLFwiaW50MzJcIix2b2lkIDAsbCldfXZhciBtZmU9e2tlcm5lbE5hbWU6SmMsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpoZmV9O2Z1bmN0aW9uIGZmZShlKXtsZXR7aW5wdXRzOnQsYmFja2VuZDpuLGF0dHJzOmF9PWUse3ZhbHVlOnJ9PXQse2F4aXM6c309YTtzPDAmJihzKz1yLnNoYXBlLmxlbmd0aCk7bGV0IGk9ci5zaGFwZVtzXSxvPXIuc2hhcGUubGVuZ3RoLGw9bmV3IEFycmF5KG8tMSksdT0wO2ZvcihsZXQgaD0wO2g8bztoKyspaCE9PXMmJihsW3UrK109ci5zaGFwZVtoXSk7bGV0IHA9bmV3IEFycmF5KGkpLGQ9bmV3IEFycmF5KG8pLmZpbGwoMCksYz1yLnNoYXBlLnNsaWNlKCk7Y1tzXT0xO2ZvcihsZXQgaD0wO2g8cC5sZW5ndGg7aCsrKWRbc109aCxwW2hdPUlpKHtpbnB1dHM6e3g6cn0sYXR0cnM6e2JlZ2luOmQsc2l6ZTpjfSxiYWNrZW5kOm59KTtyZXR1cm4gcC5tYXAoKHtkYXRhSWQ6aCxkdHlwZTptfSk9Pih7ZGF0YUlkOmgsZHR5cGU6bSxzaGFwZTpsfSkpfXZhciBnZmU9e2tlcm5lbE5hbWU6WHUsYmFja2VuZE5hbWU6XCJ3YXNtXCIsa2VybmVsRnVuYzpmZmV9O2Z1bmN0aW9uIGJmZShlKXtsZXR7aW5wdXRzOnt4OnR9LGJhY2tlbmQ6bn09ZSxhPW4ubWFrZU91dHB1dCh0LnNoYXBlLHQuZHR5cGUpO3JldHVybiBuLnR5cGVkQXJyYXlGcm9tSGVhcChhKS5maWxsKDApLGF9dmFyIHlmZT17a2VybmVsTmFtZTpZdSxiYWNrZW5kTmFtZTpcIndhc21cIixrZXJuZWxGdW5jOmJmZX0seGZlPVtldWUsdHVlLG51ZSxhdWUsc3VlLGx1ZSxndWUseHVlLHZ1ZSx3dWUsa3VlLEl1ZSxTdWUsTnVlLFR1ZSxfdWUsTHVlLCR1ZSxNdWUsVnVlLEt1ZSxadWUsUXVlLHRwZSxucGUsYXBlLGlwZSxvcGUscHBlLGhwZSxncGUseHBlLGtwZSxJcGUsU3BlLENwZSxBcGUsRHBlLE9wZSx6cGUsVnBlLEhwZSxLcGUsWnBlLGVjZSx0Y2UscmNlLGljZSxvY2UsbGNlLHVjZSxwY2UsY2NlLG1jZSxmY2UsYmNlLHZjZSxJY2UsVGNlLF9jZSwkY2UsUmNlLE9jZSx1dWUsUGNlLExjZSx6Y2UsVmNlLEdjZSxqY2UsWGNlLFpjZSxZY2UsUWNlLGVkZSxuZGUscmRlLG9kZSxwZGUsaGRlLGZkZSx5ZGUsd2RlLFNkZSxDZGUsQWRlLERkZSxPZGUsTGRlLEJkZSxqZGUscWRlLFhkZSxZZGUsUWRlLG5oZSxzaGUsb2hlLHBoZSxkaGUsbWhlLGQkLHloZSx3aGUsU2hlLFRoZSxFaGUsX2hlLEFoZSxGaGUsenVlLFJoZSxQaGUsV2hlLFVoZSxqaGUsWGhlLFloZSxaaGUsZW1lLGFtZSxpbWUsb21lLHBtZSxjbWUsZG1lLGhtZSxqdWUsVWRlLG1tZSxnbWUseG1lLGttZSxTbWUsVG1lLF9tZSxGbWUsJG1lLERtZSxNbWUsTG1lLEJtZSxVbWUsSG1lLHFtZSxYbWUsSm1lLFFtZSxlZmUsYWZlLGlmZSx1ZmUsZGZlLGh1ZSxtZmUsZ2ZlLHlmZV07Zm9yKGxldCBlIG9mIHhmZSllZChlKTt2YXIgdnY9RygpO3Z2LnJlZ2lzdGVyRmxhZyhcIldBU01fSEFTX1NJTURfU1VQUE9SVFwiLGFzeW5jKCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCw5LDEsNywwLDY1LDAsMjUzLDE1LDI2LDExXSkpfWNhdGNoKGUpe3JldHVybiExfX0pO3Z2LnJlZ2lzdGVyRmxhZyhcIldBU01fSEFTX01VTFRJVEhSRUFEX1NVUFBPUlRcIixhc3luYygpPT57aWYodnYuZ2V0KFwiSVNfTk9ERVwiKSlyZXR1cm4hMTt0cnl7cmV0dXJuIG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKX1jYXRjaChlKXtyZXR1cm4hMX19KTt2YXIgVFM9eHMoVlIoKSksdmZlPXhzKFVSKCkpLENTPXhzKEdSKCkpLEVTPVRTLmRlZmF1bHR8fFRTLHdmZT1DUy5kZWZhdWx0fHxDUyxMJD1jbGFzcyBleHRlbmRzIEZje2NvbnN0cnVjdG9yKGUpe3N1cGVyKCksdGhpcy53YXNtPWUsdGhpcy5kYXRhSWROZXh0TnVtYmVyPTEsdGhpcy53YXNtLnRmanMuaW5pdFdpdGhUaHJlYWRzQ291bnQoeiQpLHd2PXRoaXMud2FzbS50ZmpzLmdldFRocmVhZHNDb3VudCgpLHRoaXMuZGF0YUlkTWFwPW5ldyB5bSh0aGlzLFRhKCkpfXdyaXRlKGUsdCxuKXtsZXQgYT17aWQ6dGhpcy5kYXRhSWROZXh0TnVtYmVyKyt9O3JldHVybiB0aGlzLm1vdmUoYSxlLHQsbiwxKSxhfW51bURhdGFJZHMoKXtyZXR1cm4gdGhpcy5kYXRhSWRNYXAubnVtRGF0YUlkcygpfWFzeW5jIHRpbWUoZSl7bGV0IHQ9dy5ub3coKTtyZXR1cm4gZSgpLHtrZXJuZWxNczp3Lm5vdygpLXR9fW1vdmUoZSx0LG4sYSxyKXtsZXQgcz10aGlzLmRhdGFJZE5leHROdW1iZXIrKztpZihhPT09XCJzdHJpbmdcIil7bGV0IHU9dDt0aGlzLmRhdGFJZE1hcC5zZXQoZSx7aWQ6cyxzdHJpbmdCeXRlczp1LHNoYXBlOm4sZHR5cGU6YSxtZW1vcnlPZmZzZXQ6bnVsbCxyZWZDb3VudDpyfSk7cmV0dXJufWxldCBpPXcuc2l6ZUZyb21TaGFwZShuKSxvPWkqdy5ieXRlc1BlckVsZW1lbnQoYSksbD10aGlzLndhc20uX21hbGxvYyhvKT4+PjA7dGhpcy5kYXRhSWRNYXAuc2V0KGUse2lkOnMsbWVtb3J5T2Zmc2V0Omwsc2hhcGU6bixkdHlwZTphLHJlZkNvdW50OnJ9KSx0aGlzLndhc20udGZqcy5yZWdpc3RlclRlbnNvcihzLGksbCksdCE9bnVsbCYmdGhpcy53YXNtLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LG8pLGwpfWFzeW5jIHJlYWQoZSl7cmV0dXJuIHRoaXMucmVhZFN5bmMoZSl9cmVhZFN5bmMoZSx0LG4pe2xldHttZW1vcnlPZmZzZXQ6YSxkdHlwZTpyLHNoYXBlOnMsc3RyaW5nQnl0ZXM6aX09dGhpcy5kYXRhSWRNYXAuZ2V0KGUpO2lmKHI9PT1cInN0cmluZ1wiKXJldHVybih0PT1udWxsfHx0PT09MCkmJihuPT1udWxsfHxuPj1pLmxlbmd0aCk/aTppLnNsaWNlKHQsbik7dD10fHwwLG49bnx8dy5zaXplRnJvbVNoYXBlKHMpO2xldCBvPXcuYnl0ZXNQZXJFbGVtZW50KHIpLGw9dGhpcy53YXNtLkhFQVBVOC5zbGljZShhK3QqbyxhK24qbyk7cmV0dXJuIFNmZShsLmJ1ZmZlcixyKX1kaXNwb3NlRGF0YShlLHQ9ITEpe2lmKHRoaXMuZGF0YUlkTWFwLmhhcyhlKSl7bGV0IG49dGhpcy5kYXRhSWRNYXAuZ2V0KGUpO2lmKG4ucmVmQ291bnQtLSwhdCYmbi5yZWZDb3VudD4wKXJldHVybiExO3RoaXMud2FzbS5fZnJlZShuLm1lbW9yeU9mZnNldCksdGhpcy53YXNtLnRmanMuZGlzcG9zZURhdGEobi5pZCksdGhpcy5kYXRhSWRNYXAuZGVsZXRlKGUpfXJldHVybiEwfXJlZkNvdW50KGUpe3JldHVybiB0aGlzLmRhdGFJZE1hcC5oYXMoZSk/dGhpcy5kYXRhSWRNYXAuZ2V0KGUpLnJlZkNvdW50OjB9aW5jUmVmKGUpe2xldCB0PXRoaXMuZGF0YUlkTWFwLmdldChlKTt0IT1udWxsJiZ0LnJlZkNvdW50Kyt9ZmxvYXRQcmVjaXNpb24oKXtyZXR1cm4gMzJ9Z2V0TWVtb3J5T2Zmc2V0KGUpe3JldHVybiB0aGlzLmRhdGFJZE1hcC5nZXQoZSkubWVtb3J5T2Zmc2V0fWRpc3Bvc2UoKXt0aGlzLndhc20udGZqcy5kaXNwb3NlKCksXCJQVGhyZWFkXCJpbiB0aGlzLndhc20mJnRoaXMud2FzbS5QVGhyZWFkLnRlcm1pbmF0ZUFsbFRocmVhZHMoKSx0aGlzLndhc209bnVsbH1tZW1vcnkoKXtyZXR1cm57dW5yZWxpYWJsZTohMX19bWFrZU91dHB1dChlLHQsbixhKXtsZXQgcjtpZihuPT1udWxsKXI9dGhpcy53cml0ZShhIT1udWxsP2E6bnVsbCxlLHQpO2Vsc2V7bGV0IHM9dGhpcy5kYXRhSWROZXh0TnVtYmVyKys7cj17aWQ6c30sdGhpcy5kYXRhSWRNYXAuc2V0KHIse2lkOnMsbWVtb3J5T2Zmc2V0Om4sc2hhcGU6ZSxkdHlwZTp0LHJlZkNvdW50OjF9KTtsZXQgaT13LnNpemVGcm9tU2hhcGUoZSk7dGhpcy53YXNtLnRmanMucmVnaXN0ZXJUZW5zb3IocyxpLG4pfXJldHVybntkYXRhSWQ6cixzaGFwZTplLGR0eXBlOnR9fXR5cGVkQXJyYXlGcm9tSGVhcCh7c2hhcGU6ZSxkdHlwZTp0LGRhdGFJZDpufSl7bGV0IGE9dGhpcy53YXNtLkhFQVBVOC5idWZmZXIse21lbW9yeU9mZnNldDpyfT10aGlzLmRhdGFJZE1hcC5nZXQobikscz13LnNpemVGcm9tU2hhcGUoZSk7c3dpdGNoKHQpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhLHIscyk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gbmV3IEludDMyQXJyYXkoYSxyLHMpO2Nhc2VcImJvb2xcIjpyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSxyLHMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGR0eXBlICR7dH1gKX19fTtmdW5jdGlvbiBrZmUoZSl7cmV0dXJuKHQsbik9Pih3LmZldGNoKGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oYT0+e2Eub2t8fHQuZW52LmEoYGZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyR7ZX0nYCksYS5hcnJheUJ1ZmZlcigpLnRoZW4ocj0+e1dlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHIsdCkudGhlbihzPT57bihzLmluc3RhbmNlLHMubW9kdWxlKX0pfSl9KSx7fSl9ZnVuY3Rpb24gX1MoZSx0LG4pe2lmKGdtIT1udWxsKXJldHVybiBnbTtsZXQgYT1cInRmanMtYmFja2VuZC13YXNtLndhc21cIjtyZXR1cm4gZSYmdD9hPVwidGZqcy1iYWNrZW5kLXdhc20tdGhyZWFkZWQtc2ltZC53YXNtXCI6ZSYmKGE9XCJ0ZmpzLWJhY2tlbmQtd2FzbS1zaW1kLndhc21cIiksY2MhPW51bGwmJmNjW2FdIT1udWxsP2NjW2FdOm4rYX1hc3luYyBmdW5jdGlvbiBJZmUoKXtsZXRbZSx0XT1hd2FpdCBQcm9taXNlLmFsbChbRygpLmdldEFzeW5jKFwiV0FTTV9IQVNfU0lNRF9TVVBQT1JUXCIpLEcoKS5nZXRBc3luYyhcIldBU01fSEFTX01VTFRJVEhSRUFEX1NVUFBPUlRcIildKTtyZXR1cm4gbmV3IFByb21pc2UoKG4sYSk9PntsZXQgcj17fTtyLmxvY2F0ZUZpbGU9KG8sbCk9PntpZihvLmVuZHNXaXRoKFwiLndvcmtlci5qc1wiKSl7bGV0IHU9dmZlLndhc21Xb3JrZXJDb250ZW50cy5yZXBsYWNlKC9cXG4vZyxcIlxcXFxuXCIpLHA9bmV3IEJsb2IoW3VdLHt0eXBlOlwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwifSk7cmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwocCl9cmV0dXJuIG8uZW5kc1dpdGgoXCIud2FzbVwiKT9fUyhlLHQsbGMhPW51bGw/bGM6bCk6bCtvfSxtayYmKHIuaW5zdGFudGlhdGVXYXNtPWtmZShfUyhlLHQsbGMhPW51bGw/bGM6XCJcIikpKTtsZXQgcz0hMTtyLm9uQWJvcnQ9KCk9PntzfHxkY3x8KGRjPSEwLGEoe21lc3NhZ2U6XCJNYWtlIHN1cmUgdGhlIHNlcnZlciBjYW4gc2VydmUgdGhlIGAud2FzbWAgZmlsZSByZWxhdGl2ZSB0byB0aGUgYnVuZGxlZCBqcyBmaWxlLiBGb3IgbW9yZSBkZXRhaWxzIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2Jsb2IvbWFzdGVyL3RmanMtYmFja2VuZC13YXNtL1JFQURNRS5tZCN1c2luZy1idW5kbGVyc1wifSkpfTtsZXQgaTt0JiZlJiZnbT09bnVsbD8oci5tYWluU2NyaXB0VXJsT3JCbG9iPW5ldyBCbG9iKFtcInZhciBXYXNtQmFja2VuZE1vZHVsZVRocmVhZGVkU2ltZCA9IFwiK0VTLnRvU3RyaW5nKCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSxpPUVTKHIpKTppPXdmZShyKSxpLnRoZW4obz0+e3M9ITAsZGM9ITE7bGV0IGw9bnVsbDtvLnRmanM9e2luaXQ6by5jd3JhcChcImluaXRcIixudWxsLFtdKSxpbml0V2l0aFRocmVhZHNDb3VudDpvLmN3cmFwKFwiaW5pdF93aXRoX3RocmVhZHNfY291bnRcIixudWxsLFtcIm51bWJlclwiXSksZ2V0VGhyZWFkc0NvdW50Om8uY3dyYXAoXCJnZXRfdGhyZWFkc19jb3VudFwiLFwibnVtYmVyXCIsW10pLHJlZ2lzdGVyVGVuc29yOm8uY3dyYXAoXCJyZWdpc3Rlcl90ZW5zb3JcIixudWxsLFtcIm51bWJlclwiLFwibnVtYmVyXCIsXCJudW1iZXJcIl0pLGRpc3Bvc2VEYXRhOm8uY3dyYXAoXCJkaXNwb3NlX2RhdGFcIixsLFtcIm51bWJlclwiXSksZGlzcG9zZTpvLmN3cmFwKFwiZGlzcG9zZVwiLGwsW10pfSxuKHt3YXNtOm99KX0pLmNhdGNoKGEpfSl9ZnVuY3Rpb24gU2ZlKGUsdCl7c3dpdGNoKHQpe2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShlKTtjYXNlXCJpbnQzMlwiOnJldHVybiBuZXcgSW50MzJBcnJheShlKTtjYXNlXCJib29sXCI6cmV0dXJuIG5ldyBVaW50OEFycmF5KGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGR0eXBlICR7dH1gKX19dmFyIE5mZT1bXCJ0ZmpzLWJhY2tlbmQtd2FzbS53YXNtXCIsXCJ0ZmpzLWJhY2tlbmQtd2FzbS1zaW1kLndhc21cIixcInRmanMtYmFja2VuZC13YXNtLXRocmVhZGVkLXNpbWQud2FzbVwiXSxnbT1udWxsLGxjPW51bGwsY2M9e30sZGM9ITEsbWs9ITE7ZnVuY3Rpb24gVGZlKGUsdD0hMSl7aWYoJHYoXCJzZXRXYXNtUGF0aCBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHNldFdhc21QYXRocyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXCIpLGRjKXRocm93IG5ldyBFcnJvcihcIlRoZSBXQVNNIGJhY2tlbmQgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB5b3UgY2FsbCBgc2V0V2FzbVBhdGgoKWAgYmVmb3JlIHlvdSBjYWxsIGB0Zi5zZXRCYWNrZW5kKClgIG9yIGB0Zi5yZWFkeSgpYFwiKTtnbT1lLG1rPXR9ZnVuY3Rpb24gQ2ZlKGUsdD0hMSl7aWYoZGMpdGhyb3cgbmV3IEVycm9yKFwiVGhlIFdBU00gYmFja2VuZCB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC4gTWFrZSBzdXJlIHlvdSBjYWxsIGBzZXRXYXNtUGF0aHMoKWAgYmVmb3JlIHlvdSBjYWxsIGB0Zi5zZXRCYWNrZW5kKClgIG9yIGB0Zi5yZWFkeSgpYFwiKTtpZih0eXBlb2YgZT09XCJzdHJpbmdcIilsYz1lO2Vsc2V7Y2M9ZTtsZXQgbj1OZmUuZmlsdGVyKGE9PmNjW2FdPT1udWxsKTtpZihuLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihgVGhlcmUgd2VyZSBubyBlbnRyaWVzIGZvdW5kIGZvciB0aGUgZm9sbG93aW5nIGJpbmFyaWVzOiAke24uam9pbihcIixcIil9LiBQbGVhc2UgZWl0aGVyIGNhbGwgc2V0V2FzbVBhdGhzIHdpdGggYSBtYXAgcHJvdmlkaW5nIGEgcGF0aCBmb3IgZWFjaCBiaW5hcnksIG9yIHdpdGggYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgZGlyZWN0b3J5IHdoZXJlIGFsbCB0aGUgYmluYXJpZXMgY2FuIGJlIGZvdW5kLmApfW1rPXR9dmFyIHokPS0xLHd2PS0xO2Z1bmN0aW9uIEVmZShlKXt6JD1lfWZ1bmN0aW9uIF9mZSgpe2lmKHd2PT09LTEpdGhyb3cgbmV3IEVycm9yKFwiV0FTTSBiYWNrZW5kIG5vdCBpbml0aWFsaXplZC5cIik7cmV0dXJuIHd2fXZhciBBZmU9XCI0LjIyLjBcIixGZmU9MjtPbShcIndhc21cIixhc3luYygpPT57bGV0e3dhc206ZX09YXdhaXQgSWZlKCk7cmV0dXJuIG5ldyBMJChlKX0sRmZlKTt2YXIgQVM9XCI0LjIyLjBcIiwkZmU9XCI0LjIyLjBcIixEZmU9XCI0LjIyLjBcIixSZmU9XCI0LjIyLjBcIixNZmU9XCI0LjIyLjBcIixPZmU9e3RmanM6QVMsXCJ0ZmpzLWNvcmVcIjpBUyxcInRmanMtY29udmVydGVyXCI6JGZlLFwidGZqcy1iYWNrZW5kLWNwdVwiOkRmZSxcInRmanMtYmFja2VuZC13ZWJnbFwiOlJmZSxcInRmanMtYmFja2VuZC13YXNtXCI6TWZlfTt2YXIgaUQ9e307YXgoaUQse0FuY2hvclBvc2l0aW9uOigpPT5JayxEcmF3Qm94OigpPT5PZCxEcmF3Qm94T3B0aW9uczooKT0+WGYsRHJhd0ZhY2VMYW5kbWFya3M6KCk9Pm9nLERyYXdGYWNlTGFuZG1hcmtzT3B0aW9uczooKT0+aWcsRHJhd1RleHRGaWVsZDooKT0+c2wsRHJhd1RleHRGaWVsZE9wdGlvbnM6KCk9PklwLGRyYXdDb250b3VyOigpPT5QcixkcmF3RGV0ZWN0aW9uczooKT0+VWZlLGRyYXdGYWNlRXhwcmVzc2lvbnM6KCk9PkdmZSxkcmF3RmFjZUxhbmRtYXJrczooKT0+amZlfSk7ZnVuY3Rpb24gUHIoZSx0LG49ITEpe2lmKGUuYmVnaW5QYXRoKCksdC5zbGljZSgxKS5mb3JFYWNoKCh7eDphLHk6cn0scyk9PntsZXQgaT10W3NdO2UubW92ZVRvKGkueCxpLnkpLGUubGluZVRvKGEscil9KSxuKXtsZXQgYT10W3QubGVuZ3RoLTFdLHI9dFswXTtpZighYXx8IXIpcmV0dXJuO2UubW92ZVRvKGEueCxhLnkpLGUubGluZVRvKHIueCxyLnkpfWUuc3Ryb2tlKCl9dmFyIFckPXt9O2F4KFckLHtjb21wdXRlUmVzaGFwZWREaW1lbnNpb25zOigpPT5iayxnZXRDZW50ZXJQb2ludDooKT0+YWwsaXNEaW1lbnNpb25zOigpPT5qZixpc0V2ZW46KCk9PkhmLGlzRmxvYXQ6KCk9PmdrLGlzVGVuc29yOigpPT50bCxpc1RlbnNvcjFEOigpPT5QZmUsaXNUZW5zb3IyRDooKT0+ZmssaXNUZW5zb3IzRDooKT0+THIsaXNUZW5zb3I0RDooKT0+d2EsaXNWYWxpZE51bWJlcjooKT0+WGEsaXNWYWxpZFByb2JhYmxpdGl5OigpPT5ncCxyYW5nZTooKT0+Z3Iscm91bmQ6KCk9Pm5sfSk7dmFyIGFhPWNsYXNzIGV7Y29uc3RydWN0b3IodCxuKXtpZighWGEodCl8fCFYYShuKSl0aHJvdyBuZXcgRXJyb3IoYERpbWVuc2lvbnMuY29uc3RydWN0b3IgLSBleHBlY3RlZCB3aWR0aCBhbmQgaGVpZ2h0IHRvIGJlIHZhbGlkIG51bWJlcnMsIGluc3RlYWQgaGF2ZSAke0pTT04uc3RyaW5naWZ5KHt3aWR0aDp0LGhlaWdodDpufSl9YCk7dGhpcy5fd2lkdGg9dCx0aGlzLl9oZWlnaHQ9bn1nZXQgd2lkdGgoKXtyZXR1cm4gdGhpcy5fd2lkdGh9Z2V0IGhlaWdodCgpe3JldHVybiB0aGlzLl9oZWlnaHR9cmV2ZXJzZSgpe3JldHVybiBuZXcgZSgxL3RoaXMud2lkdGgsMS90aGlzLmhlaWdodCl9fTtmdW5jdGlvbiB0bChlLHQpe3JldHVybiBlIGluc3RhbmNlb2YgQ2UmJmUuc2hhcGUubGVuZ3RoPT09dH1mdW5jdGlvbiBQZmUoZSl7cmV0dXJuIHRsKGUsMSl9ZnVuY3Rpb24gZmsoZSl7cmV0dXJuIHRsKGUsMil9ZnVuY3Rpb24gTHIoZSl7cmV0dXJuIHRsKGUsMyl9ZnVuY3Rpb24gd2EoZSl7cmV0dXJuIHRsKGUsNCl9ZnVuY3Rpb24gZ2soZSl7cmV0dXJuIGUlMSE9PTB9ZnVuY3Rpb24gSGYoZSl7cmV0dXJuIGUlMj09PTB9ZnVuY3Rpb24gbmwoZSx0PTIpe2xldCBuPTEwKip0O3JldHVybiBNYXRoLmZsb29yKGUqbikvbn1mdW5jdGlvbiBqZihlKXtyZXR1cm4gZSYmZS53aWR0aCYmZS5oZWlnaHR9ZnVuY3Rpb24gYmsoe3dpZHRoOmUsaGVpZ2h0OnR9LG4pe2xldCBhPW4vTWF0aC5tYXgodCxlKTtyZXR1cm4gbmV3IGFhKE1hdGgucm91bmQoZSphKSxNYXRoLnJvdW5kKHQqYSkpfWZ1bmN0aW9uIGFsKGUpe3JldHVybiBlLnJlZHVjZSgodCxuKT0+dC5hZGQobiksbmV3IEhlKDAsMCkpLmRpdihuZXcgSGUoZS5sZW5ndGgsZS5sZW5ndGgpKX1mdW5jdGlvbiBncihlLHQsbil7cmV0dXJuIEFycmF5KGUpLmZpbGwoMCkubWFwKChhLHIpPT50K3Iqbil9ZnVuY3Rpb24gWGEoZSl7cmV0dXJuISFlJiZlIT09MS8wJiZlIT09LTEvMCYmIU51bWJlci5pc05hTihlKXx8ZT09PTB9ZnVuY3Rpb24gZ3AoZSl7cmV0dXJuIFhhKGUpJiZlPj0wJiZlPD0xfXZhciBIZT1jbGFzcyBle2NvbnN0cnVjdG9yKHQsbil7dGhpcy5feD10LHRoaXMuX3k9bn1nZXQgeCgpe3JldHVybiB0aGlzLl94fWdldCB5KCl7cmV0dXJuIHRoaXMuX3l9YWRkKHQpe3JldHVybiBuZXcgZSh0aGlzLngrdC54LHRoaXMueSt0LnkpfXN1Yih0KXtyZXR1cm4gbmV3IGUodGhpcy54LXQueCx0aGlzLnktdC55KX1tdWwodCl7cmV0dXJuIG5ldyBlKHRoaXMueCp0LngsdGhpcy55KnQueSl9ZGl2KHQpe3JldHVybiBuZXcgZSh0aGlzLngvdC54LHRoaXMueS90LnkpfWFicygpe3JldHVybiBuZXcgZShNYXRoLmFicyh0aGlzLngpLE1hdGguYWJzKHRoaXMueSkpfW1hZ25pdHVkZSgpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KioyK3RoaXMueSoqMil9Zmxvb3IoKXtyZXR1cm4gbmV3IGUoTWF0aC5mbG9vcih0aGlzLngpLE1hdGguZmxvb3IodGhpcy55KSl9fTt2YXIgbW49Y2xhc3MgZXtzdGF0aWMgaXNSZWN0KHQpe3JldHVybiEhdCYmW3QueCx0LnksdC53aWR0aCx0LmhlaWdodF0uZXZlcnkoWGEpfXN0YXRpYyBhc3NlcnRJc1ZhbGlkQm94KHQsbixhPSExKXtpZighZS5pc1JlY3QodCkpdGhyb3cgbmV3IEVycm9yKGAke259IC0gaW52YWxpZCBib3g6ICR7SlNPTi5zdHJpbmdpZnkodCl9LCBleHBlY3RlZCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHgsIHksIHdpZHRoLCBoZWlnaHRgKTtpZighYSYmKHQud2lkdGg8MHx8dC5oZWlnaHQ8MCkpdGhyb3cgbmV3IEVycm9yKGAke259IC0gd2lkdGggKCR7dC53aWR0aH0pIGFuZCBoZWlnaHQgKCR7dC5oZWlnaHR9KSBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnNgKX1jb25zdHJ1Y3Rvcih0LG49ITApe2xldCBhPXR8fHt9LHI9W2EubGVmdCxhLnRvcCxhLnJpZ2h0LGEuYm90dG9tXS5ldmVyeShYYSkscz1bYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0XS5ldmVyeShYYSk7aWYoIXMmJiFyKXRocm93IG5ldyBFcnJvcihgQm94LmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgYm94IHRvIGJlIElCb3VuZGluZ0JveCB8IElSZWN0LCBpbnN0ZWFkIGhhdmUgJHtKU09OLnN0cmluZ2lmeShhKX1gKTtsZXRbaSxvLGwsdV09cz9bYS54LGEueSxhLndpZHRoLGEuaGVpZ2h0XTpbYS5sZWZ0LGEudG9wLGEucmlnaHQtYS5sZWZ0LGEuYm90dG9tLWEudG9wXTtlLmFzc2VydElzVmFsaWRCb3goe3g6aSx5Om8sd2lkdGg6bCxoZWlnaHQ6dX0sXCJCb3guY29uc3RydWN0b3JcIixuKSx0aGlzLl94PWksdGhpcy5feT1vLHRoaXMuX3dpZHRoPWwsdGhpcy5faGVpZ2h0PXV9Z2V0IHgoKXtyZXR1cm4gdGhpcy5feH1nZXQgeSgpe3JldHVybiB0aGlzLl95fWdldCB3aWR0aCgpe3JldHVybiB0aGlzLl93aWR0aH1nZXQgaGVpZ2h0KCl7cmV0dXJuIHRoaXMuX2hlaWdodH1nZXQgbGVmdCgpe3JldHVybiB0aGlzLnh9Z2V0IHRvcCgpe3JldHVybiB0aGlzLnl9Z2V0IHJpZ2h0KCl7cmV0dXJuIHRoaXMueCt0aGlzLndpZHRofWdldCBib3R0b20oKXtyZXR1cm4gdGhpcy55K3RoaXMuaGVpZ2h0fWdldCBhcmVhKCl7cmV0dXJuIHRoaXMud2lkdGgqdGhpcy5oZWlnaHR9Z2V0IHRvcExlZnQoKXtyZXR1cm4gbmV3IEhlKHRoaXMubGVmdCx0aGlzLnRvcCl9Z2V0IHRvcFJpZ2h0KCl7cmV0dXJuIG5ldyBIZSh0aGlzLnJpZ2h0LHRoaXMudG9wKX1nZXQgYm90dG9tTGVmdCgpe3JldHVybiBuZXcgSGUodGhpcy5sZWZ0LHRoaXMuYm90dG9tKX1nZXQgYm90dG9tUmlnaHQoKXtyZXR1cm4gbmV3IEhlKHRoaXMucmlnaHQsdGhpcy5ib3R0b20pfXJvdW5kKCl7bGV0W3QsbixhLHJdPVt0aGlzLngsdGhpcy55LHRoaXMud2lkdGgsdGhpcy5oZWlnaHRdLm1hcChzPT5NYXRoLnJvdW5kKHMpKTtyZXR1cm4gbmV3IGUoe3g6dCx5Om4sd2lkdGg6YSxoZWlnaHQ6cn0pfWZsb29yKCl7bGV0W3QsbixhLHJdPVt0aGlzLngsdGhpcy55LHRoaXMud2lkdGgsdGhpcy5oZWlnaHRdLm1hcChzPT5NYXRoLmZsb29yKHMpKTtyZXR1cm4gbmV3IGUoe3g6dCx5Om4sd2lkdGg6YSxoZWlnaHQ6cn0pfXRvU3F1YXJlKCl7bGV0e3g6dCx5Om4sd2lkdGg6YSxoZWlnaHQ6cn09dGhpcyxzPU1hdGguYWJzKGEtcik7cmV0dXJuIGE8ciYmKHQtPXMvMixhKz1zKSxyPGEmJihuLT1zLzIscis9cyksbmV3IGUoe3g6dCx5Om4sd2lkdGg6YSxoZWlnaHQ6cn0pfXJlc2NhbGUodCl7bGV0IG49amYodCk/dC53aWR0aDp0LGE9amYodCk/dC5oZWlnaHQ6dDtyZXR1cm4gbmV3IGUoe3g6dGhpcy54Km4seTp0aGlzLnkqYSx3aWR0aDp0aGlzLndpZHRoKm4saGVpZ2h0OnRoaXMuaGVpZ2h0KmF9KX1wYWQodCxuKXtsZXRbYSxyLHMsaV09W3RoaXMueC10LzIsdGhpcy55LW4vMix0aGlzLndpZHRoK3QsdGhpcy5oZWlnaHQrbl07cmV0dXJuIG5ldyBlKHt4OmEseTpyLHdpZHRoOnMsaGVpZ2h0Oml9KX1jbGlwQXRJbWFnZUJvcmRlcnModCxuKXtsZXR7eDphLHk6cixyaWdodDpzLGJvdHRvbTppfT10aGlzLG89TWF0aC5tYXgoYSwwKSxsPU1hdGgubWF4KHIsMCksdT1zLW8scD1pLWwsZD1NYXRoLm1pbih1LHQtbyksYz1NYXRoLm1pbihwLG4tbCk7cmV0dXJuIG5ldyBlKHt4Om8seTpsLHdpZHRoOmQsaGVpZ2h0OmN9KS5mbG9vcigpfXNoaWZ0KHQsbil7bGV0e3dpZHRoOmEsaGVpZ2h0OnJ9PXRoaXMscz10aGlzLngrdCxpPXRoaXMueStuO3JldHVybiBuZXcgZSh7eDpzLHk6aSx3aWR0aDphLGhlaWdodDpyfSl9cGFkQXRCb3JkZXJzKHQsbil7bGV0IGE9dGhpcy53aWR0aCsxLHI9dGhpcy5oZWlnaHQrMSxzPTEsaT0xLG89YSxsPXIsdT10aGlzLmxlZnQscD10aGlzLnRvcCxkPXRoaXMucmlnaHQsYz10aGlzLmJvdHRvbTtyZXR1cm4gZD5uJiYobz0tZCtuK2EsZD1uKSxjPnQmJihsPS1jK3QrcixjPXQpLHU8MSYmKGw9Mi11LHU9MSkscDwxJiYobD0yLXAscD0xKSx7ZHk6aSxlZHk6bCxkeDpzLGVkeDpvLHk6cCxleTpjLHg6dSxleDpkLHc6YSxoOnJ9fWNhbGlicmF0ZSh0KXtyZXR1cm4gbmV3IGUoe2xlZnQ6dGhpcy5sZWZ0K3QubGVmdCp0aGlzLndpZHRoLHRvcDp0aGlzLnRvcCt0LnRvcCp0aGlzLmhlaWdodCxyaWdodDp0aGlzLnJpZ2h0K3QucmlnaHQqdGhpcy53aWR0aCxib3R0b206dGhpcy5ib3R0b20rdC5ib3R0b20qdGhpcy5oZWlnaHR9KS50b1NxdWFyZSgpLnJvdW5kKCl9fTt2YXIgYnA9Y2xhc3MgZXh0ZW5kcyBtbntjb25zdHJ1Y3Rvcih0LG4sYSxyLHM9ITEpe3N1cGVyKHtsZWZ0OnQsdG9wOm4scmlnaHQ6YSxib3R0b206cn0scyl9fTt2YXIgeXA9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LG4sYSxyLHMpe3RoaXMuX2ltYWdlRGltcz1uZXcgYWEocy53aWR0aCxzLmhlaWdodCksdGhpcy5fc2NvcmU9dCx0aGlzLl9jbGFzc1Njb3JlPW4sdGhpcy5fY2xhc3NOYW1lPWEsdGhpcy5fYm94PW5ldyBtbihyKS5yZXNjYWxlKHRoaXMuX2ltYWdlRGltcyl9Z2V0IHNjb3JlKCl7cmV0dXJuIHRoaXMuX3Njb3JlfWdldCBjbGFzc1Njb3JlKCl7cmV0dXJuIHRoaXMuX2NsYXNzU2NvcmV9Z2V0IGNsYXNzTmFtZSgpe3JldHVybiB0aGlzLl9jbGFzc05hbWV9Z2V0IGJveCgpe3JldHVybiB0aGlzLl9ib3h9Z2V0IGltYWdlRGltcygpe3JldHVybiB0aGlzLl9pbWFnZURpbXN9Z2V0IGltYWdlV2lkdGgoKXtyZXR1cm4gdGhpcy5pbWFnZURpbXMud2lkdGh9Z2V0IGltYWdlSGVpZ2h0KCl7cmV0dXJuIHRoaXMuaW1hZ2VEaW1zLmhlaWdodH1nZXQgcmVsYXRpdmVCb3goKXtyZXR1cm4gbmV3IG1uKHRoaXMuX2JveCkucmVzY2FsZSh0aGlzLmltYWdlRGltcy5yZXZlcnNlKCkpfWZvclNpemUodCxuKXtyZXR1cm4gbmV3IGUodGhpcy5zY29yZSx0aGlzLmNsYXNzU2NvcmUsdGhpcy5jbGFzc05hbWUsdGhpcy5yZWxhdGl2ZUJveCx7d2lkdGg6dCxoZWlnaHQ6bn0pfX07dmFyIEZ0PWNsYXNzIGUgZXh0ZW5kcyB5cHtjb25zdHJ1Y3Rvcih0LG4sYSl7c3VwZXIodCx0LFwiXCIsbixhKX1mb3JTaXplKHQsbil7bGV0e3Njb3JlOmEscmVsYXRpdmVCb3g6cixpbWFnZURpbXM6c309c3VwZXIuZm9yU2l6ZSh0LG4pO3JldHVybiBuZXcgZShhLHIscyl9fTtmdW5jdGlvbiBCJChlLHQsbj0hMCl7bGV0IGE9TWF0aC5tYXgoMCxNYXRoLm1pbihlLnJpZ2h0LHQucmlnaHQpLU1hdGgubWF4KGUubGVmdCx0LmxlZnQpKSxyPU1hdGgubWF4KDAsTWF0aC5taW4oZS5ib3R0b20sdC5ib3R0b20pLU1hdGgubWF4KGUudG9wLHQudG9wKSkscz1hKnI7cmV0dXJuIG4/cy8oZS5hcmVhK3QuYXJlYS1zKTpzL01hdGgubWluKGUuYXJlYSx0LmFyZWEpfWZ1bmN0aW9uIFYkKGUpe2xldCB0PWUubWFwKG89Pm8ueCksbj1lLm1hcChvPT5vLnkpLGE9dC5yZWR1Y2UoKG8sbCk9Pmw8bz9sOm8sMS8wKSxyPW4ucmVkdWNlKChvLGwpPT5sPG8/bDpvLDEvMCkscz10LnJlZHVjZSgobyxsKT0+bzxsP2w6bywwKSxpPW4ucmVkdWNlKChvLGwpPT5vPGw/bDpvLDApO3JldHVybiBuZXcgYnAoYSxyLHMsaSl9ZnVuY3Rpb24gVSQoZSx0LG4sYT0hMCl7bGV0IHI9dC5tYXAoKGksbyk9Pih7c2NvcmU6aSxib3hJbmRleDpvfSkpLnNvcnQoKGksbyk9Pmkuc2NvcmUtby5zY29yZSkubWFwKGk9PmkuYm94SW5kZXgpLHM9W107Zm9yKDtyLmxlbmd0aD4wOyl7bGV0IGk9ci5wb3AoKTtzLnB1c2goaSk7bGV0IG89cixsPVtdO2ZvcihsZXQgdT0wO3U8by5sZW5ndGg7dSsrKXtsZXQgcD1vW3VdLGQ9ZVtpXSxjPWVbcF07bC5wdXNoKEIkKGQsYyxhKSl9cj1yLmZpbHRlcigodSxwKT0+bFtwXTw9bil9cmV0dXJuIHN9ZnVuY3Rpb24gYnIoZSx0KXtyZXR1cm4gTygoKT0+e2xldFtuLGEscl09dCxzPXluKFsuLi5lLnNoYXBlLnNsaWNlKDAsMyksMV0sbixcImZsb2F0MzJcIiksaT15bihbLi4uZS5zaGFwZS5zbGljZSgwLDMpLDFdLGEsXCJmbG9hdDMyXCIpLG89eW4oWy4uLmUuc2hhcGUuc2xpY2UoMCwzKSwxXSxyLFwiZmxvYXQzMlwiKSxsPWV0KFtzLGksb10sMyk7cmV0dXJuIHBlKGUsbCl9KX1mdW5jdGlvbiBHJChlLHQ9ITEpe3JldHVybiBPKCgpPT57bGV0W24sYV09ZS5zaGFwZS5zbGljZSgxKTtpZihuPT09YSlyZXR1cm4gZTtsZXQgcj1NYXRoLmFicyhuLWEpLHM9TWF0aC5yb3VuZChyKih0Py41OjEpKSxpPW4+YT8yOjEsbz1jPT57bGV0IGg9ZS5zaGFwZS5zbGljZSgpO3JldHVybiBoW2ldPWMseW4oaCwwLFwiZmxvYXQzMlwiKX0sbD1vKHMpLHU9ci1sLnNoYXBlW2ldLGQ9W3QmJnU/byh1KTpudWxsLGUsbF0uZmlsdGVyKGM9PiEhYykubWFwKGM9PnJlKGMsXCJmbG9hdDMyXCIpKTtyZXR1cm4gZXQoZCxpKX0pfWZ1bmN0aW9uIHkwZShlKXtsZXQgdD1lLnNsaWNlKCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj4wO24tLSl7bGV0IGE9TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihuKzEpKSxyPXRbbl07dFtuXT10W2FdLHRbYV09cn1yZXR1cm4gdH1mdW5jdGlvbiBxZihlKXtyZXR1cm4gMS8oMStNYXRoLmV4cCgtZSkpfWZ1bmN0aW9uIHYwZShlKXtyZXR1cm4gTWF0aC5sb2coZS8oMS1lKSl9dmFyIHhwPWNsYXNzIGV4dGVuZHMgbW57Y29uc3RydWN0b3IodCxuLGEscixzPSExKXtzdXBlcih7eDp0LHk6bix3aWR0aDphLGhlaWdodDpyfSxzKX19O3ZhciBMZmU9LjUsemZlPS40MyxXZmU9LjQ1LGthPWNsYXNze2NvbnN0cnVjdG9yKHQsbixhPW5ldyBIZSgwLDApKXtsZXR7d2lkdGg6cixoZWlnaHQ6c309bjt0aGlzLl9pbWdEaW1zPW5ldyBhYShyLHMpLHRoaXMuX3NoaWZ0PWEsdGhpcy5fcG9zaXRpb25zPXQubWFwKGk9PmkubXVsKG5ldyBIZShyLHMpKS5hZGQoYSkpfWdldCBzaGlmdCgpe3JldHVybiBuZXcgSGUodGhpcy5fc2hpZnQueCx0aGlzLl9zaGlmdC55KX1nZXQgaW1hZ2VXaWR0aCgpe3JldHVybiB0aGlzLl9pbWdEaW1zLndpZHRofWdldCBpbWFnZUhlaWdodCgpe3JldHVybiB0aGlzLl9pbWdEaW1zLmhlaWdodH1nZXQgcG9zaXRpb25zKCl7cmV0dXJuIHRoaXMuX3Bvc2l0aW9uc31nZXQgcmVsYXRpdmVQb3NpdGlvbnMoKXtyZXR1cm4gdGhpcy5fcG9zaXRpb25zLm1hcCh0PT50LnN1Yih0aGlzLl9zaGlmdCkuZGl2KG5ldyBIZSh0aGlzLmltYWdlV2lkdGgsdGhpcy5pbWFnZUhlaWdodCkpKX1mb3JTaXplKHQsbil7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucmVsYXRpdmVQb3NpdGlvbnMse3dpZHRoOnQsaGVpZ2h0Om59KX1zaGlmdEJ5KHQsbil7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucmVsYXRpdmVQb3NpdGlvbnMsdGhpcy5faW1nRGltcyxuZXcgSGUodCxuKSl9c2hpZnRCeVBvaW50KHQpe3JldHVybiB0aGlzLnNoaWZ0QnkodC54LHQueSl9YWxpZ24odCxuPXt9KXtpZih0KXtsZXQgcz10IGluc3RhbmNlb2YgRnQ/dC5ib3guZmxvb3IoKTpuZXcgbW4odCk7cmV0dXJuIHRoaXMuc2hpZnRCeShzLngscy55KS5hbGlnbihudWxsLG4pfWxldHt1c2VEbGliQWxpZ25tZW50OmEsbWluQm94UGFkZGluZzpyfT17dXNlRGxpYkFsaWdubWVudDohMSxtaW5Cb3hQYWRkaW5nOi4yLC4uLm59O3JldHVybiBhP3RoaXMuYWxpZ25EbGliKCk6dGhpcy5hbGlnbk1pbkJib3gocil9YWxpZ25EbGliKCl7bGV0IHQ9dGhpcy5nZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQoKSxbbixhLHJdPXQscz1kPT5yLnN1YihkKS5tYWduaXR1ZGUoKSxpPShzKG4pK3MoYSkpLzIsbz1NYXRoLmZsb29yKGkvV2ZlKSxsPWFsKHQpLHU9TWF0aC5mbG9vcihNYXRoLm1heCgwLGwueC1MZmUqbykpLHA9TWF0aC5mbG9vcihNYXRoLm1heCgwLGwueS16ZmUqbykpO3JldHVybiBuZXcgeHAodSxwLE1hdGgubWluKG8sdGhpcy5pbWFnZVdpZHRoK3UpLE1hdGgubWluKG8sdGhpcy5pbWFnZUhlaWdodCtwKSl9YWxpZ25NaW5CYm94KHQpe2xldCBuPVYkKHRoaXMucG9zaXRpb25zKTtyZXR1cm4gbi5wYWQobi53aWR0aCp0LG4uaGVpZ2h0KnQpfWdldFJlZlBvaW50c0ZvckFsaWdubWVudCgpe3Rocm93IG5ldyBFcnJvcihcImdldFJlZlBvaW50c0ZvckFsaWdubWVudCBub3QgaW1wbGVtZW50ZWQgYnkgYmFzZSBjbGFzc1wiKX19O3ZhciBIJD1jbGFzcyBleHRlbmRzIGthe2dldFJlZlBvaW50c0ZvckFsaWdubWVudCgpe2xldCB0PXRoaXMucG9zaXRpb25zO3JldHVyblt0WzBdLHRbMV0sYWwoW3RbM10sdFs0XV0pXX19O3ZhciB2cD1jbGFzcyBleHRlbmRzIGthe2dldEphd091dGxpbmUoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMCwxNyl9Z2V0TGVmdEV5ZUJyb3coKXtyZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoMTcsMjIpfWdldFJpZ2h0RXllQnJvdygpe3JldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSgyMiwyNyl9Z2V0Tm9zZSgpe3JldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSgyNywzNil9Z2V0TGVmdEV5ZSgpe3JldHVybiB0aGlzLnBvc2l0aW9ucy5zbGljZSgzNiw0Mil9Z2V0UmlnaHRFeWUoKXtyZXR1cm4gdGhpcy5wb3NpdGlvbnMuc2xpY2UoNDIsNDgpfWdldE1vdXRoKCl7cmV0dXJuIHRoaXMucG9zaXRpb25zLnNsaWNlKDQ4LDY4KX1nZXRSZWZQb2ludHNGb3JBbGlnbm1lbnQoKXtyZXR1cm5bdGhpcy5nZXRMZWZ0RXllKCksdGhpcy5nZXRSaWdodEV5ZSgpLHRoaXMuZ2V0TW91dGgoKV0ubWFwKGFsKX19O3ZhciBEZD1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4pe3RoaXMuX2xhYmVsPXQsdGhpcy5fZGlzdGFuY2U9bn1nZXQgbGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0IGRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfXRvU3RyaW5nKHQ9ITApe3JldHVybmAke3RoaXMubGFiZWx9JHt0P2AgKCR7bmwodGhpcy5kaXN0YW5jZSl9KWA6XCJcIn1gfX07dmFyIFJkPWNsYXNzIGV4dGVuZHMgbW57c3RhdGljIGFzc2VydElzVmFsaWRMYWJlbGVkQm94KHQsbil7aWYobW4uYXNzZXJ0SXNWYWxpZEJveCh0LG4pLCFYYSh0LmxhYmVsKSl0aHJvdyBuZXcgRXJyb3IoYCR7bn0gLSBleHBlY3RlZCBwcm9wZXJ0eSBsYWJlbCAoJHt0LmxhYmVsfSkgdG8gYmUgYSBudW1iZXJgKX1jb25zdHJ1Y3Rvcih0LG4pe3N1cGVyKHQpLHRoaXMuX2xhYmVsPW59Z2V0IGxhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfX07dmFyIHJsPWNsYXNzIGV7Y29uc3RydWN0b3IodCxuKXtpZih0eXBlb2YgdCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJMYWJlbGVkRmFjZURlc2NyaXB0b3JzIC0gY29uc3RydWN0b3IgZXhwZWN0ZWQgbGFiZWwgdG8gYmUgYSBzdHJpbmdcIik7aWYoIUFycmF5LmlzQXJyYXkobil8fG4uc29tZShhPT4hKGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSl0aHJvdyBuZXcgRXJyb3IoXCJMYWJlbGVkRmFjZURlc2NyaXB0b3JzIC0gY29uc3RydWN0b3IgZXhwZWN0ZWQgZGVzY3JpcHRvcnMgdG8gYmUgYW4gYXJyYXkgb2YgRmxvYXQzMkFycmF5XCIpO3RoaXMuX2xhYmVsPXQsdGhpcy5fZGVzY3JpcHRvcnM9bn1nZXQgbGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0IGRlc2NyaXB0b3JzKCl7cmV0dXJuIHRoaXMuX2Rlc2NyaXB0b3JzfXRvSlNPTigpe3JldHVybntsYWJlbDp0aGlzLmxhYmVsLGRlc2NyaXB0b3JzOnRoaXMuZGVzY3JpcHRvcnMubWFwKHQ9PkFycmF5LmZyb20odCkpfX1zdGF0aWMgZnJvbUpTT04odCl7bGV0IG49dC5kZXNjcmlwdG9ycy5tYXAoYT0+bmV3IEZsb2F0MzJBcnJheShhKSk7cmV0dXJuIG5ldyBlKHQubGFiZWwsbil9fTt2YXIgaiQ9Y2xhc3MgZXh0ZW5kcyBSZHtzdGF0aWMgYXNzZXJ0SXNWYWxpZFByZWRpY3RlZEJveCh0LG4pe2lmKFJkLmFzc2VydElzVmFsaWRMYWJlbGVkQm94KHQsbiksIWdwKHQuc2NvcmUpfHwhZ3AodC5jbGFzc1Njb3JlKSl0aHJvdyBuZXcgRXJyb3IoYCR7bn0gLSBleHBlY3RlZCBwcm9wZXJ0aWVzIHNjb3JlICgke3Quc2NvcmV9KSBhbmQgKCR7dC5jbGFzc1Njb3JlfSkgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiBbMCwgMV1gKX1jb25zdHJ1Y3Rvcih0LG4sYSxyKXtzdXBlcih0LG4pLHRoaXMuX3Njb3JlPWEsdGhpcy5fY2xhc3NTY29yZT1yfWdldCBzY29yZSgpe3JldHVybiB0aGlzLl9zY29yZX1nZXQgY2xhc3NTY29yZSgpe3JldHVybiB0aGlzLl9jbGFzc1Njb3JlfX07ZnVuY3Rpb24genIoZSl7cmV0dXJuIGUuZGV0ZWN0aW9uIGluc3RhbmNlb2YgRnR9ZnVuY3Rpb24gd3AoZSx0KXtyZXR1cm57Li4uZSwuLi57ZGV0ZWN0aW9uOnR9fX1mdW5jdGlvbiB5aygpe2xldCBlPXdpbmRvdy5mZXRjaDtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJmZXRjaCAtIG1pc3NpbmcgZmV0Y2ggaW1wbGVtZW50YXRpb24gZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRcIik7cmV0dXJue0NhbnZhczpIVE1MQ2FudmFzRWxlbWVudCxDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsSW1hZ2U6SFRNTEltYWdlRWxlbWVudCxJbWFnZURhdGEsVmlkZW86SFRNTFZpZGVvRWxlbWVudCxjcmVhdGVDYW52YXNFbGVtZW50OigpPT5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGNyZWF0ZUltYWdlRWxlbWVudDooKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSxjcmVhdGVWaWRlb0VsZW1lbnQ6KCk9PmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKSxmZXRjaDplLHJlYWRGaWxlOigpPT57dGhyb3cgbmV3IEVycm9yKFwicmVhZEZpbGUgLSBmaWxlc3lzdGVtIG5vdCBhdmFpbGFibGUgZm9yIGJyb3dzZXIgZW52aXJvbm1lbnRcIil9fX1mdW5jdGlvbiBNZCgpe3JldHVybiB0eXBlb2YgZ2xvYmFsPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2VzcyE9XCJ1bmRlZmluZWRcIiYmcHJvY2Vzcy52ZXJzaW9ucyE9bnVsbCYmcHJvY2Vzcy52ZXJzaW9ucy5ub2RlIT1udWxsfWZ1bmN0aW9uIEtmKGUpe2xldCB0PVwiXCI7aWYoIWUmJk1kKCkpdHJ5e2U9d1IoXCJmc1wiKX1jYXRjaChhKXt0PWEudG9TdHJpbmcoKX1yZXR1cm57cmVhZEZpbGU6ZT9hPT5uZXcgUHJvbWlzZSgocixzKT0+e2UucmVhZEZpbGUoYSwoaSxvKT0+aT9zKGkpOnIobykpfSk6KCk9Pnt0aHJvdyBuZXcgRXJyb3IoYHJlYWRGaWxlIC0gZmFpbGVkIHRvIHJlcXVpcmUgZnMgaW4gbm9kZWpzIGVudmlyb25tZW50IHdpdGggZXJyb3I6ICR7dH1gKX19fWZ1bmN0aW9uIHhrKCl7bGV0IGU9Z2xvYmFsLkNhbnZhc3x8Z2xvYmFsLkhUTUxDYW52YXNFbGVtZW50LHQ9Z2xvYmFsLkltYWdlfHxnbG9iYWwuSFRNTEltYWdlRWxlbWVudCxuPWdsb2JhbC5WaWRlb3x8Z2xvYmFsLkhUTUxWaWRlb0VsZW1lbnQsYT0oKT0+e2lmKGUpcmV0dXJuIG5ldyBlO3Rocm93IG5ldyBFcnJvcihcImNyZWF0ZUNhbnZhc0VsZW1lbnQgLSBtaXNzaW5nIENhbnZhcyBpbXBsZW1lbnRhdGlvbiBmb3Igbm9kZWpzIGVudmlyb25tZW50XCIpfSxyPSgpPT57aWYodClyZXR1cm4gbmV3IHQ7dGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlSW1hZ2VFbGVtZW50IC0gbWlzc2luZyBJbWFnZSBpbXBsZW1lbnRhdGlvbiBmb3Igbm9kZWpzIGVudmlyb25tZW50XCIpfSxzPSgpPT57aWYobilyZXR1cm4gbmV3IG47dGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlVmlkZW9FbGVtZW50IC0gbWlzc2luZyBWaWRlbyBpbXBsZW1lbnRhdGlvbiBmb3Igbm9kZWpzIGVudmlyb25tZW50XCIpfSxpPWdsb2JhbC5mZXRjaCxvPUtmKCk7cmV0dXJue0NhbnZhczplfHxjbGFzc3t9LENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDpnbG9iYWwuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfHxjbGFzc3t9LEltYWdlOnR8fGNsYXNze30sSW1hZ2VEYXRhOmdsb2JhbC5JbWFnZURhdGF8fGNsYXNze30sVmlkZW86Z2xvYmFsLkhUTUxWaWRlb0VsZW1lbnR8fGNsYXNze30sY3JlYXRlQ2FudmFzRWxlbWVudDphLGNyZWF0ZUltYWdlRWxlbWVudDpyLGNyZWF0ZVZpZGVvRWxlbWVudDpzLGZldGNoOmksLi4ub319ZnVuY3Rpb24gdmsoKXtyZXR1cm4gdHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIiYmdHlwZW9mIGRvY3VtZW50IT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgSFRNTEltYWdlRWxlbWVudCE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50IT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgSFRNTFZpZGVvRWxlbWVudCE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIEltYWdlRGF0YSE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCE9XCJ1bmRlZmluZWRcIn12YXIgbG47ZnVuY3Rpb24gQmZlKCl7aWYoIWxuKXRocm93IG5ldyBFcnJvcihcImdldEVudiAtIGVudmlyb25tZW50IGlzIG5vdCBkZWZpbmVkLCBjaGVjayBpc05vZGVqcygpIGFuZCBpc0Jyb3dzZXIoKVwiKTtyZXR1cm4gbG59ZnVuY3Rpb24gd2soZSl7bG49ZX1mdW5jdGlvbiBraygpe3JldHVybiB2aygpP3drKHlrKCkpOk1kKCk/d2soeGsoKSk6bnVsbH1mdW5jdGlvbiBWZmUoZSl7aWYobG58fGtrKCksIWxuKXRocm93IG5ldyBFcnJvcihcIm1vbmtleVBhdGNoIC0gZW52aXJvbm1lbnQgaXMgbm90IGRlZmluZWQsIGNoZWNrIGlzTm9kZWpzKCkgYW5kIGlzQnJvd3NlcigpXCIpO2xldHtDYW52YXM6dD1sbi5DYW52YXMsSW1hZ2U6bj1sbi5JbWFnZX09ZTtsbi5DYW52YXM9dCxsbi5JbWFnZT1uLGxuLmNyZWF0ZUNhbnZhc0VsZW1lbnQ9ZS5jcmVhdGVDYW52YXNFbGVtZW50fHwoKCk9Pm5ldyB0KSxsbi5jcmVhdGVJbWFnZUVsZW1lbnQ9ZS5jcmVhdGVJbWFnZUVsZW1lbnR8fCgoKT0+bmV3IG4pLGxuLkltYWdlRGF0YT1lLkltYWdlRGF0YXx8bG4uSW1hZ2VEYXRhLGxuLlZpZGVvPWUuVmlkZW98fGxuLlZpZGVvLGxuLmZldGNoPWUuZmV0Y2h8fGxuLmZldGNoLGxuLnJlYWRGaWxlPWUucmVhZEZpbGV8fGxuLnJlYWRGaWxlfXZhciBhdD17Z2V0RW52OkJmZSxzZXRFbnY6d2ssaW5pdGlhbGl6ZTprayxjcmVhdGVCcm93c2VyRW52OnlrLGNyZWF0ZUZpbGVTeXN0ZW06S2YsY3JlYXRlTm9kZWpzRW52OnhrLG1vbmtleVBhdGNoOlZmZSxpc0Jyb3dzZXI6dmssaXNOb2RlanM6TWR9O2trKCk7ZnVuY3Rpb24ga3AoZSl7cmV0dXJuIWF0LmlzTm9kZWpzKCkmJnR5cGVvZiBlPT1cInN0cmluZ1wiP2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpOmV9ZnVuY3Rpb24gcmEoZSl7bGV0e0NhbnZhczp0LENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDpufT1hdC5nZXRFbnYoKTtpZihlIGluc3RhbmNlb2YgbilyZXR1cm4gZTtsZXQgYT1rcChlKTtpZighKGEgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlQ29udGV4dDJkIC0gZXhwZWN0ZWQgY2FudmFzIHRvIGJlIG9mIGluc3RhbmNlIG9mIENhbnZhc1wiKTtsZXQgcj1hLmdldENvbnRleHQoXCIyZFwiLHt3aWxsUmVhZEZyZXF1ZW50bHk6ITB9KTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJyZXNvbHZlQ29udGV4dDJkIC0gY2FudmFzIDJkIGNvbnRleHQgaXMgbnVsbFwiKTtyZXR1cm4gcn12YXIgSWs9KHI9PihyLlRPUF9MRUZUPVwiVE9QX0xFRlRcIixyLlRPUF9SSUdIVD1cIlRPUF9SSUdIVFwiLHIuQk9UVE9NX0xFRlQ9XCJCT1RUT01fTEVGVFwiLHIuQk9UVE9NX1JJR0hUPVwiQk9UVE9NX1JJR0hUXCIscikpKElrfHx7fSksSXA9Y2xhc3N7Y29uc3RydWN0b3IodD17fSl7bGV0e2FuY2hvclBvc2l0aW9uOm4sYmFja2dyb3VuZENvbG9yOmEsZm9udENvbG9yOnIsZm9udFNpemU6cyxmb250U3R5bGU6aSxwYWRkaW5nOm99PXQ7dGhpcy5hbmNob3JQb3NpdGlvbj1ufHxcIlRPUF9MRUZUXCIsdGhpcy5iYWNrZ3JvdW5kQ29sb3I9YXx8XCJyZ2JhKDAsIDAsIDAsIDAuNSlcIix0aGlzLmZvbnRDb2xvcj1yfHxcInJnYmEoMjU1LCAyNTUsIDI1NSwgMSlcIix0aGlzLmZvbnRTaXplPXN8fDE0LHRoaXMuZm9udFN0eWxlPWl8fFwiR2VvcmdpYVwiLHRoaXMucGFkZGluZz1vfHw0fX0sc2w9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LG4sYT17fSl7dGhpcy50ZXh0PXR5cGVvZiB0PT1cInN0cmluZ1wiP1t0XTp0IGluc3RhbmNlb2YgZT90LnRleHQ6dCx0aGlzLmFuY2hvcj1uLHRoaXMub3B0aW9ucz1uZXcgSXAoYSl9bWVhc3VyZVdpZHRoKHQpe2xldHtwYWRkaW5nOm59PXRoaXMub3B0aW9ucztyZXR1cm4gdGhpcy50ZXh0Lm1hcChhPT50Lm1lYXN1cmVUZXh0KGEpLndpZHRoKS5yZWR1Y2UoKGEscik9PmE8cj9yOmEsMCkrMipufW1lYXN1cmVIZWlnaHQoKXtsZXR7Zm9udFNpemU6dCxwYWRkaW5nOm59PXRoaXMub3B0aW9ucztyZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aCp0KzIqbn1nZXRVcHBlckxlZnQodCxuKXtsZXR7YW5jaG9yUG9zaXRpb246YX09dGhpcy5vcHRpb25zLHI9YT09PVwiQk9UVE9NX1JJR0hUXCJ8fGE9PT1cIlRPUF9SSUdIVFwiLHM9YT09PVwiQk9UVE9NX0xFRlRcInx8YT09PVwiQk9UVE9NX1JJR0hUXCIsaT10aGlzLm1lYXN1cmVXaWR0aCh0KSxvPXRoaXMubWVhc3VyZUhlaWdodCgpLGw9cj90aGlzLmFuY2hvci54LWk6dGhpcy5hbmNob3IueCx1PXM/dGhpcy5hbmNob3IueS1vOnRoaXMuYW5jaG9yLnk7aWYobil7bGV0e3dpZHRoOnAsaGVpZ2h0OmR9PW4sYz1NYXRoLm1heChNYXRoLm1pbihsLHAtaSksMCksaD1NYXRoLm1heChNYXRoLm1pbih1LGQtbyksMCk7cmV0dXJue3g6Yyx5Omh9fXJldHVybnt4OmwseTp1fX1kcmF3KHQpe2xldCBuPWtwKHQpLGE9cmEobikse2JhY2tncm91bmRDb2xvcjpyLGZvbnRDb2xvcjpzLGZvbnRTaXplOmksZm9udFN0eWxlOm8scGFkZGluZzpsfT10aGlzLm9wdGlvbnM7YS5mb250PWAke2l9cHggJHtvfWA7bGV0IHU9dGhpcy5tZWFzdXJlV2lkdGgoYSkscD10aGlzLm1lYXN1cmVIZWlnaHQoKTthLmZpbGxTdHlsZT1yO2xldCBkPXRoaXMuZ2V0VXBwZXJMZWZ0KGEsbik7YS5maWxsUmVjdChkLngsZC55LHUscCksYS5maWxsU3R5bGU9cyx0aGlzLnRleHQuZm9yRWFjaCgoYyxoKT0+e2xldCBtPWwrZC54LGY9bCtkLnkrKGgrMSkqaTthLmZpbGxUZXh0KGMsbSxmKX0pfX07dmFyIFhmPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe2xldHtib3hDb2xvcjpuLGxpbmVXaWR0aDphLGxhYmVsOnIsZHJhd0xhYmVsT3B0aW9uczpzfT10O3RoaXMuYm94Q29sb3I9bnx8XCJyZ2JhKDAsIDAsIDI1NSwgMSlcIix0aGlzLmxpbmVXaWR0aD1hfHwyLHRoaXMubGFiZWw9cjtsZXQgaT17YW5jaG9yUG9zaXRpb246XCJCT1RUT01fTEVGVFwiLGJhY2tncm91bmRDb2xvcjp0aGlzLmJveENvbG9yfTt0aGlzLmRyYXdMYWJlbE9wdGlvbnM9bmV3IElwKHsuLi5pLC4uLnN9KX19LE9kPWNsYXNze2NvbnN0cnVjdG9yKHQsbj17fSl7dGhpcy5ib3g9bmV3IG1uKHQpLHRoaXMub3B0aW9ucz1uZXcgWGYobil9ZHJhdyh0KXtsZXQgbj1yYSh0KSx7Ym94Q29sb3I6YSxsaW5lV2lkdGg6cn09dGhpcy5vcHRpb25zLHt4OnMseTppLHdpZHRoOm8saGVpZ2h0Omx9PXRoaXMuYm94O24uc3Ryb2tlU3R5bGU9YSxuLmxpbmVXaWR0aD1yLG4uc3Ryb2tlUmVjdChzLGksbyxsKTtsZXR7bGFiZWw6dX09dGhpcy5vcHRpb25zO3UmJm5ldyBzbChbdV0se3g6cy1yLzIseTppfSx0aGlzLm9wdGlvbnMuZHJhd0xhYmVsT3B0aW9ucykuZHJhdyh0KX19O2Z1bmN0aW9uIFVmZShlLHQpeyhBcnJheS5pc0FycmF5KHQpP3Q6W3RdKS5mb3JFYWNoKGE9PntsZXQgcj1hIGluc3RhbmNlb2YgRnQ/YS5zY29yZTp6cihhKT9hLmRldGVjdGlvbi5zY29yZTp2b2lkIDAscz1hIGluc3RhbmNlb2YgRnQ/YS5ib3g6enIoYSk/YS5kZXRlY3Rpb24uYm94Om5ldyBtbihhKSxpPXI/YCR7bmwocil9YDp2b2lkIDA7bmV3IE9kKHMse2xhYmVsOml9KS5kcmF3KGUpfSl9ZnVuY3Rpb24gWWYoZSl7bGV0e0ltYWdlOnQsVmlkZW86bn09YXQuZ2V0RW52KCk7cmV0dXJuIGUgaW5zdGFuY2VvZiB0JiZlLmNvbXBsZXRlfHxlIGluc3RhbmNlb2YgbiYmZS5yZWFkeVN0YXRlPj0zfWZ1bmN0aW9uIHEkKGUpe3JldHVybiBuZXcgUHJvbWlzZSgodCxuKT0+e2lmKGUgaW5zdGFuY2VvZiBhdC5nZXRFbnYoKS5DYW52YXN8fFlmKGUpKXt0KG51bGwpO3JldHVybn1mdW5jdGlvbiBhKHMpe3MuY3VycmVudFRhcmdldCYmKHMuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLHIpLHMuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixhKSxuKHMpKX1mdW5jdGlvbiByKHMpe3MuY3VycmVudFRhcmdldCYmKHMuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLHIpLHMuY3VycmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixhKSx0KHMpKX1lLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsciksZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixhKX0pfWZ1bmN0aW9uIEskKGUpe3JldHVybiBuZXcgUHJvbWlzZSgodCxuKT0+e2UgaW5zdGFuY2VvZiBCbG9ifHxuKG5ldyBFcnJvcihcImJ1ZmZlclRvSW1hZ2UgLSBleHBlY3RlZCBidWYgdG8gYmUgb2YgdHlwZTogQmxvYlwiKSk7bGV0IGE9bmV3IEZpbGVSZWFkZXI7YS5vbmxvYWQ9KCk9Pnt0eXBlb2YgYS5yZXN1bHQhPVwic3RyaW5nXCImJm4obmV3IEVycm9yKFwiYnVmZmVyVG9JbWFnZSAtIGV4cGVjdGVkIHJlYWRlci5yZXN1bHQgdG8gYmUgYSBzdHJpbmcsIGluIG9ubG9hZFwiKSk7bGV0IHI9YXQuZ2V0RW52KCkuY3JlYXRlSW1hZ2VFbGVtZW50KCk7ci5vbmxvYWQ9KCk9PnQociksci5vbmVycm9yPW4sci5zcmM9YS5yZXN1bHR9LGEub25lcnJvcj1uLGEucmVhZEFzRGF0YVVSTChlKX0pfWZ1bmN0aW9uIFNwKGUpe2xldHtJbWFnZTp0LFZpZGVvOm59PWF0LmdldEVudigpO3JldHVybiBlIGluc3RhbmNlb2YgdD9uZXcgYWEoZS5uYXR1cmFsV2lkdGgsZS5uYXR1cmFsSGVpZ2h0KTplIGluc3RhbmNlb2Ygbj9uZXcgYWEoZS52aWRlb1dpZHRoLGUudmlkZW9IZWlnaHQpOm5ldyBhYShlLndpZHRoLGUuaGVpZ2h0KX1mdW5jdGlvbiBOcCh7d2lkdGg6ZSxoZWlnaHQ6dH0pe2xldHtjcmVhdGVDYW52YXNFbGVtZW50Om59PWF0LmdldEVudigpLGE9bigpO3JldHVybiBhLndpZHRoPWUsYS5oZWlnaHQ9dCxhfWZ1bmN0aW9uIFpmKGUsdCl7bGV0e0ltYWdlRGF0YTpufT1hdC5nZXRFbnYoKTtpZighKGUgaW5zdGFuY2VvZiBuKSYmIVlmKGUpKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUNhbnZhc0Zyb21NZWRpYSAtIG1lZGlhIGhhcyBub3QgZmluaXNoZWQgbG9hZGluZyB5ZXRcIik7bGV0e3dpZHRoOmEsaGVpZ2h0OnJ9PXR8fFNwKGUpLHM9TnAoe3dpZHRoOmEsaGVpZ2h0OnJ9KTtyZXR1cm4gZSBpbnN0YW5jZW9mIG4/cmEocykucHV0SW1hZ2VEYXRhKGUsMCwwKTpyYShzKS5kcmF3SW1hZ2UoZSwwLDAsYSxyKSxzfWFzeW5jIGZ1bmN0aW9uIFgkKGUsdCl7bGV0IG49dHx8YXQuZ2V0RW52KCkuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFthLHIsc109ZS5zaGFwZS5zbGljZSh3YShlKT8xOjApLGk9TygoKT0+ZS5hczNEKGEscixzKS50b0ludCgpKTtyZXR1cm4gYXdhaXQgcW8udG9QaXhlbHMoaSxuKSxpLmRpc3Bvc2UoKSxufWZ1bmN0aW9uIFNrKGUpe2xldHtJbWFnZTp0LENhbnZhczpuLFZpZGVvOmF9PWF0LmdldEVudigpO3JldHVybiBlIGluc3RhbmNlb2YgdHx8ZSBpbnN0YW5jZW9mIG58fGUgaW5zdGFuY2VvZiBhfWZ1bmN0aW9uIFkkKGUsdCxuPSExKXtsZXR7SW1hZ2U6YSxDYW52YXM6cn09YXQuZ2V0RW52KCk7aWYoIShlIGluc3RhbmNlb2YgYXx8ZSBpbnN0YW5jZW9mIHIpKXRocm93IG5ldyBFcnJvcihcImltYWdlVG9TcXVhcmUgLSBleHBlY3RlZCBhcmcwIHRvIGJlIEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudFwiKTtpZih0PD0wKXJldHVybiBOcCh7d2lkdGg6MSxoZWlnaHQ6MX0pO2xldCBzPVNwKGUpLGk9dC9NYXRoLm1heChzLmhlaWdodCxzLndpZHRoKSxvPWkqcy53aWR0aCxsPWkqcy5oZWlnaHQsdT1OcCh7d2lkdGg6dCxoZWlnaHQ6dH0pLHA9ZSBpbnN0YW5jZW9mIHI/ZTpaZihlKSxkPU1hdGguYWJzKG8tbCkvMixjPW4mJm88bD9kOjAsaD1uJiZsPG8/ZDowO3JldHVybiBwLndpZHRoPjAmJnAuaGVpZ2h0PjAmJnJhKHUpLmRyYXdJbWFnZShwLGMsaCxvLGwpLHV9dmFyIFdyPWNsYXNze2NvbnN0cnVjdG9yKHQsbj0hMSl7dGhpcy5faW1hZ2VUZW5zb3JzPVtdO3RoaXMuX2NhbnZhc2VzPVtdO3RoaXMuX3RyZWF0QXNCYXRjaElucHV0PSExO3RoaXMuX2lucHV0RGltZW5zaW9ucz1bXTt0aGlzLl9pbnB1dFNpemU9MDtpZighQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgRXJyb3IoYE5ldElucHV0LmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgaW5wdXRzIHRvIGJlIGFuIEFycmF5IG9mIFRSZXNvbHZlZE5ldElucHV0IG9yIHRvIGJlIGluc3RhbmNlb2YgdGYuVGVuc29yNEQsIGluc3RlYWQgaGF2ZSAke3R9YCk7dGhpcy5fdHJlYXRBc0JhdGNoSW5wdXQ9bix0aGlzLl9iYXRjaFNpemU9dC5sZW5ndGgsdC5mb3JFYWNoKChhLHIpPT57aWYoTHIoYSkpe3RoaXMuX2ltYWdlVGVuc29yc1tyXT1hLHRoaXMuX2lucHV0RGltZW5zaW9uc1tyXT1hLnNoYXBlO3JldHVybn1pZih3YShhKSl7bGV0IGk9YS5zaGFwZVswXTtpZihpIT09MSl0aHJvdyBuZXcgRXJyb3IoYE5ldElucHV0IC0gdGYuVGVuc29yNEQgd2l0aCBiYXRjaFNpemUgJHtpfSBwYXNzZWQsIGJ1dCBub3Qgc3VwcG9ydGVkIGluIGlucHV0IGFycmF5YCk7dGhpcy5faW1hZ2VUZW5zb3JzW3JdPWEsdGhpcy5faW5wdXREaW1lbnNpb25zW3JdPWEuc2hhcGUuc2xpY2UoMSk7cmV0dXJufWxldCBzPWEgaW5zdGFuY2VvZiBhdC5nZXRFbnYoKS5DYW52YXM/YTpaZihhKTt0aGlzLl9jYW52YXNlc1tyXT1zLHRoaXMuX2lucHV0RGltZW5zaW9uc1tyXT1bcy5oZWlnaHQscy53aWR0aCwzXX0pfWdldCBpbWFnZVRlbnNvcnMoKXtyZXR1cm4gdGhpcy5faW1hZ2VUZW5zb3JzfWdldCBjYW52YXNlcygpe3JldHVybiB0aGlzLl9jYW52YXNlc31nZXQgaXNCYXRjaElucHV0KCl7cmV0dXJuIHRoaXMuYmF0Y2hTaXplPjF8fHRoaXMuX3RyZWF0QXNCYXRjaElucHV0fWdldCBiYXRjaFNpemUoKXtyZXR1cm4gdGhpcy5fYmF0Y2hTaXplfWdldCBpbnB1dERpbWVuc2lvbnMoKXtyZXR1cm4gdGhpcy5faW5wdXREaW1lbnNpb25zfWdldCBpbnB1dFNpemUoKXtyZXR1cm4gdGhpcy5faW5wdXRTaXplfWdldCByZXNoYXBlZElucHV0RGltZW5zaW9ucygpe3JldHVybiBncih0aGlzLmJhdGNoU2l6ZSwwLDEpLm1hcCgodCxuKT0+dGhpcy5nZXRSZXNoYXBlZElucHV0RGltZW5zaW9ucyhuKSl9Z2V0SW5wdXQodCl7cmV0dXJuIHRoaXMuY2FudmFzZXNbdF18fHRoaXMuaW1hZ2VUZW5zb3JzW3RdfWdldElucHV0RGltZW5zaW9ucyh0KXtyZXR1cm4gdGhpcy5faW5wdXREaW1lbnNpb25zW3RdfWdldElucHV0SGVpZ2h0KHQpe3JldHVybiB0aGlzLl9pbnB1dERpbWVuc2lvbnNbdF1bMF19Z2V0SW5wdXRXaWR0aCh0KXtyZXR1cm4gdGhpcy5faW5wdXREaW1lbnNpb25zW3RdWzFdfWdldFJlc2hhcGVkSW5wdXREaW1lbnNpb25zKHQpe2lmKHR5cGVvZiB0aGlzLmlucHV0U2l6ZSE9XCJudW1iZXJcIil0aHJvdyBuZXcgRXJyb3IoXCJnZXRSZXNoYXBlZElucHV0RGltZW5zaW9ucyAtIGlucHV0U2l6ZSBub3Qgc2V0LCB0b0JhdGNoVGVuc29yIGhhcyBub3QgYmVlbiBjYWxsZWQgeWV0XCIpO2xldCBuPXRoaXMuZ2V0SW5wdXRXaWR0aCh0KSxhPXRoaXMuZ2V0SW5wdXRIZWlnaHQodCk7cmV0dXJuIGJrKHt3aWR0aDpuLGhlaWdodDphfSx0aGlzLmlucHV0U2l6ZSl9dG9CYXRjaFRlbnNvcih0LG49ITApe3JldHVybiB0aGlzLl9pbnB1dFNpemU9dCxPKCgpPT57bGV0IGE9Z3IodGhpcy5iYXRjaFNpemUsMCwxKS5tYXAocz0+e2xldCBpPXRoaXMuZ2V0SW5wdXQocyk7aWYoaSBpbnN0YW5jZW9mIENlKXtsZXQgbz13YShpKT9pOkd0KGkpO3JldHVybiBvPUckKG8sbiksKG8uc2hhcGVbMV0hPT10fHxvLnNoYXBlWzJdIT09dCkmJihvPVpuLnJlc2l6ZUJpbGluZWFyKG8sW3QsdF0sITEsITEpKSxvLmFzM0QodCx0LDMpfWlmKGkgaW5zdGFuY2VvZiBhdC5nZXRFbnYoKS5DYW52YXMpcmV0dXJuIHFvLmZyb21QaXhlbHMoWSQoaSx0LG4pKTt0aHJvdyBuZXcgRXJyb3IoYHRvQmF0Y2hUZW5zb3IgLSBhdCBiYXRjaElkeCAke3N9LCBleHBlY3RlZCBpbnB1dCB0byBiZSBpbnN0YW5jZW9mIHRmLlRlbnNvciBvciBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50LCBpbnN0ZWFkIGhhdmUgJHtpfWApfSk7cmV0dXJuIEF0KGEubWFwKHM9PnJlKHMsXCJmbG9hdDMyXCIpKSkuYXM0RCh0aGlzLmJhdGNoU2l6ZSx0LHQsMyl9KX19O2FzeW5jIGZ1bmN0aW9uIHZ0KGUpe2lmKGUgaW5zdGFuY2VvZiBXcilyZXR1cm4gZTtsZXQgdD1BcnJheS5pc0FycmF5KGUpP2U6W2VdO2lmKCF0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0b05ldElucHV0IC0gZW1wdHkgYXJyYXkgcGFzc2VkIGFzIGlucHV0XCIpO2xldCBuPXI9PkFycmF5LmlzQXJyYXkoZSk/YCBhdCBpbnB1dCBpbmRleCAke3J9OmA6XCJcIixhPXQubWFwKGtwKTtyZXR1cm4gYS5mb3JFYWNoKChyLHMpPT57aWYoIVNrKHIpJiYhTHIocikmJiF3YShyKSl0aHJvdyB0eXBlb2YgdFtzXT09XCJzdHJpbmdcIj9uZXcgRXJyb3IoYHRvTmV0SW5wdXQgLSR7bihzKX0gc3RyaW5nIHBhc3NlZCwgYnV0IGNvdWxkIG5vdCByZXNvbHZlIEhUTUxFbGVtZW50IGZvciBlbGVtZW50IGlkICR7dFtzXX1gKTpuZXcgRXJyb3IoYHRvTmV0SW5wdXQgLSR7bihzKX0gZXhwZWN0ZWQgbWVkaWEgdG8gYmUgb2YgdHlwZSBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgdGYuVGVuc29yM0QsIG9yIHRvIGJlIGFuIGVsZW1lbnQgaWRgKTtpZih3YShyKSl7bGV0IGk9ci5zaGFwZVswXTtpZihpIT09MSl0aHJvdyBuZXcgRXJyb3IoYHRvTmV0SW5wdXQgLSR7bihzKX0gdGYuVGVuc29yNEQgd2l0aCBiYXRjaFNpemUgJHtpfSBwYXNzZWQsIGJ1dCBub3Qgc3VwcG9ydGVkIGluIGlucHV0IGFycmF5YCl9fSksYXdhaXQgUHJvbWlzZS5hbGwoYS5tYXAocj0+U2socikmJnEkKHIpKSksbmV3IFdyKGEsQXJyYXkuaXNBcnJheShlKSl9YXN5bmMgZnVuY3Rpb24gUGQoZSx0KXtsZXR7Q2FudmFzOm59PWF0LmdldEVudigpLGE9ZTtpZighKGUgaW5zdGFuY2VvZiBuKSl7bGV0IGk9YXdhaXQgdnQoZSk7aWYoaS5iYXRjaFNpemU+MSl0aHJvdyBuZXcgRXJyb3IoXCJleHRyYWN0RmFjZXMgLSBiYXRjaFNpemUgPiAxIG5vdCBzdXBwb3J0ZWRcIik7bGV0IG89aS5nZXRJbnB1dCgwKTthPW8gaW5zdGFuY2VvZiBuP286YXdhaXQgWCQobyl9bGV0IHI9cmEoYSk7cmV0dXJuIHQubWFwKGk9PmkgaW5zdGFuY2VvZiBGdD9pLmZvclNpemUoYS53aWR0aCxhLmhlaWdodCkuYm94LmZsb29yKCk6aSkubWFwKGk9PmkuY2xpcEF0SW1hZ2VCb3JkZXJzKGEud2lkdGgsYS5oZWlnaHQpKS5tYXAoKHt4OmkseTpvLHdpZHRoOmwsaGVpZ2h0OnV9KT0+e2xldCBwPU5wKHt3aWR0aDpsLGhlaWdodDp1fSk7cmV0dXJuIGw+MCYmdT4wJiZyYShwKS5wdXRJbWFnZURhdGEoci5nZXRJbWFnZURhdGEoaSxvLGwsdSksMCwwKSxwfSl9YXN5bmMgZnVuY3Rpb24gTGQoZSx0KXtpZighTHIoZSkmJiF3YShlKSl0aHJvdyBuZXcgRXJyb3IoXCJleHRyYWN0RmFjZVRlbnNvcnMgLSBleHBlY3RlZCBpbWFnZSB0ZW5zb3IgdG8gYmUgM0Qgb3IgNERcIik7aWYod2EoZSkmJmUuc2hhcGVbMF0+MSl0aHJvdyBuZXcgRXJyb3IoXCJleHRyYWN0RmFjZVRlbnNvcnMgLSBiYXRjaFNpemUgPiAxIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIE8oKCk9PntsZXRbbixhLHJdPWUuc2hhcGUuc2xpY2Uod2EoZSk/MTowKTtyZXR1cm4gdC5tYXAobz0+byBpbnN0YW5jZW9mIEZ0P28uZm9yU2l6ZShhLG4pLmJveDpvKS5tYXAobz0+by5jbGlwQXRJbWFnZUJvcmRlcnMoYSxuKSkuZmlsdGVyKG89Pm8ud2lkdGg+MCYmby5oZWlnaHQ+MCkubWFwKCh7eDpvLHk6bCx3aWR0aDp1LGhlaWdodDpwfSk9PkhvKGUuYXMzRChuLGEsciksW2wsbywwXSxbcCx1LHJdKSl9KX1hc3luYyBmdW5jdGlvbiBNcyhlLHQpe2xldHtmZXRjaDpufT1hdC5nZXRFbnYoKSxhPWF3YWl0IG4oZSx0KTtpZighKGEuc3RhdHVzPDQwMCkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gZmV0Y2g6ICgke2Euc3RhdHVzfSkgJHthLnN0YXR1c1RleHR9LCBmcm9tIHVybDogJHthLnVybH1gKTtyZXR1cm4gYX1hc3luYyBmdW5jdGlvbiBzSWUoZSl7bGV0IHQ9YXdhaXQgTXMoZSksbj1hd2FpdCB0LmJsb2IoKTtpZighbi50eXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpdGhyb3cgbmV3IEVycm9yKGBmZXRjaEltYWdlIC0gZXhwZWN0ZWQgYmxvYiB0eXBlIHRvIGJlIG9mIHR5cGUgaW1hZ2UvKiwgaW5zdGVhZCBoYXZlOiAke24udHlwZX0sIGZvciB1cmw6ICR7dC51cmx9YCk7cmV0dXJuIEskKG4pfWFzeW5jIGZ1bmN0aW9uIFokKGUpe3JldHVybihhd2FpdCBNcyhlKSkuanNvbigpfWFzeW5jIGZ1bmN0aW9uIHBJZShlKXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhd2FpdChhd2FpdCBNcyhlKSkuYXJyYXlCdWZmZXIoKSl9ZnVuY3Rpb24gSiQoZSl7cmV0dXJuIG5ldyBQcm9taXNlKCh0LG4pPT57ZSBpbnN0YW5jZW9mIEJsb2J8fG4obmV3IEVycm9yKFwiYnVmZmVyVG9WaWRlbyAtIGV4cGVjdGVkIGJ1ZiB0byBiZSBvZiB0eXBlOiBCbG9iXCIpKTtsZXQgYT1hdC5nZXRFbnYoKS5jcmVhdGVWaWRlb0VsZW1lbnQoKTthLm9uY2FucGxheT0oKT0+dChhKSxhLm9uZXJyb3I9bixhLnBsYXlzSW5saW5lPSEwLGEubXV0ZWQ9ITAsYS5zcmM9VVJMLmNyZWF0ZU9iamVjdFVSTChlKSxhLnBsYXkoKX0pfWFzeW5jIGZ1bmN0aW9uIGdJZShlKXtsZXQgdD1hd2FpdCBNcyhlKSxuPWF3YWl0IHQuYmxvYigpO2lmKCFuLnR5cGUuc3RhcnRzV2l0aChcInZpZGVvL1wiKSl0aHJvdyBuZXcgRXJyb3IoYGZldGNoVmlkZW8gLSBleHBlY3RlZCBibG9iIHR5cGUgdG8gYmUgb2YgdHlwZSB2aWRlby8qLCBpbnN0ZWFkIGhhdmU6ICR7bi50eXBlfSwgZm9yIHVybDogJHt0LnVybH1gKTtyZXR1cm4gSiQobil9ZnVuY3Rpb24gSmYoZSx0KXtsZXQgbj1gJHt0fS13ZWlnaHRzX21hbmlmZXN0Lmpzb25gO2lmKCFlKXJldHVybnttb2RlbEJhc2VVcmk6XCJcIixtYW5pZmVzdFVyaTpufTtpZihlPT09XCIvXCIpcmV0dXJue21vZGVsQmFzZVVyaTpcIi9cIixtYW5pZmVzdFVyaTpgLyR7bn1gfTtsZXQgYT1lLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpP1wiaHR0cDovL1wiOmUuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpP1wiaHR0cHM6Ly9cIjpcIlwiO2U9ZS5yZXBsYWNlKGEsXCJcIik7bGV0IHI9ZS5zcGxpdChcIi9cIikuZmlsdGVyKG89Pm8pLHM9ZS5lbmRzV2l0aChcIi5qc29uXCIpP3Jbci5sZW5ndGgtMV06bixpPWErKGUuZW5kc1dpdGgoXCIuanNvblwiKT9yLnNsaWNlKDAsci5sZW5ndGgtMSk6cikuam9pbihcIi9cIik7cmV0dXJuIGk9ZS5zdGFydHNXaXRoKFwiL1wiKT9gLyR7aX1gOmkse21vZGVsQmFzZVVyaTppLG1hbmlmZXN0VXJpOmk9PT1cIi9cIj9gLyR7c31gOmAke2l9LyR7c31gfX1hc3luYyBmdW5jdGlvbiBRJChlLHQpe2xldHttYW5pZmVzdFVyaTpuLG1vZGVsQmFzZVVyaTphfT1KZihlLHQpLHI9YXdhaXQgWiQobik7cmV0dXJuIGp0LmxvYWRXZWlnaHRzKHIsYSl9ZnVuY3Rpb24gSUllKGUsdCxuPSExKXtsZXR7d2lkdGg6YSxoZWlnaHQ6cn09bj9TcCh0KTp0O3JldHVybiBlLndpZHRoPWEsZS5oZWlnaHQ9cix7d2lkdGg6YSxoZWlnaHQ6cn19dmFyIGZuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuX3BhcmFtcz12b2lkIDA7dGhpcy5fcGFyYW1NYXBwaW5ncz1bXTt0aGlzLl9uYW1lPXR9Z2V0IHBhcmFtcygpe3JldHVybiB0aGlzLl9wYXJhbXN9Z2V0IHBhcmFtTWFwcGluZ3MoKXtyZXR1cm4gdGhpcy5fcGFyYW1NYXBwaW5nc31nZXQgaXNMb2FkZWQoKXtyZXR1cm4hIXRoaXMucGFyYW1zfWdldFBhcmFtRnJvbVBhdGgodCl7bGV0e29iajpuLG9ialByb3A6YX09dGhpcy50cmF2ZXJzZVByb3BlcnR5UGF0aCh0KTtyZXR1cm4gblthXX1yZWFzc2lnblBhcmFtRnJvbVBhdGgodCxuKXtsZXR7b2JqOmEsb2JqUHJvcDpyfT10aGlzLnRyYXZlcnNlUHJvcGVydHlQYXRoKHQpO2Fbcl0uZGlzcG9zZSgpLGFbcl09bn1nZXRQYXJhbUxpc3QoKXtyZXR1cm4gdGhpcy5fcGFyYW1NYXBwaW5ncy5tYXAoKHtwYXJhbVBhdGg6dH0pPT4oe3BhdGg6dCx0ZW5zb3I6dGhpcy5nZXRQYXJhbUZyb21QYXRoKHQpfSkpfWdldFRyYWluYWJsZVBhcmFtcygpe3JldHVybiB0aGlzLmdldFBhcmFtTGlzdCgpLmZpbHRlcih0PT50LnRlbnNvciBpbnN0YW5jZW9mIG9zKX1nZXRGcm96ZW5QYXJhbXMoKXtyZXR1cm4gdGhpcy5nZXRQYXJhbUxpc3QoKS5maWx0ZXIodD0+ISh0LnRlbnNvciBpbnN0YW5jZW9mIG9zKSl9dmFyaWFibGUoKXt0aGlzLmdldEZyb3plblBhcmFtcygpLmZvckVhY2goKHtwYXRoOnQsdGVuc29yOm59KT0+e3RoaXMucmVhc3NpZ25QYXJhbUZyb21QYXRoKHQsbi52YXJpYWJsZSgpKX0pfWZyZWV6ZSgpe3RoaXMuZ2V0VHJhaW5hYmxlUGFyYW1zKCkuZm9yRWFjaCgoe3BhdGg6dCx0ZW5zb3I6bn0pPT57bGV0IGE9Ym4obi5kYXRhU3luYygpKTtuLmRpc3Bvc2UoKSx0aGlzLnJlYXNzaWduUGFyYW1Gcm9tUGF0aCh0LGEpfSl9ZGlzcG9zZSh0PSEwKXt0aGlzLmdldFBhcmFtTGlzdCgpLmZvckVhY2gobj0+e2lmKHQmJm4udGVuc29yLmlzRGlzcG9zZWQpdGhyb3cgbmV3IEVycm9yKGBwYXJhbSB0ZW5zb3IgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBmb3IgcGF0aCAke24ucGF0aH1gKTtuLnRlbnNvci5kaXNwb3NlKCl9KSx0aGlzLl9wYXJhbXM9dm9pZCAwfXNlcmlhbGl6ZVBhcmFtcygpe3JldHVybiBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZ2V0UGFyYW1MaXN0KCkubWFwKCh7dGVuc29yOnR9KT0+QXJyYXkuZnJvbSh0LmRhdGFTeW5jKCkpKS5yZWR1Y2UoKHQsbik9PnQuY29uY2F0KG4pKSl9YXN5bmMgbG9hZCh0KXtpZih0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXt0aGlzLmV4dHJhY3RXZWlnaHRzKHQpO3JldHVybn1hd2FpdCB0aGlzLmxvYWRGcm9tVXJpKHQpfWFzeW5jIGxvYWRGcm9tVXJpKHQpe2lmKHQmJnR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgJHt0aGlzLl9uYW1lfS5sb2FkRnJvbVVyaSAtIGV4cGVjdGVkIG1vZGVsIHVyaWApO2xldCBuPWF3YWl0IFEkKHQsdGhpcy5nZXREZWZhdWx0TW9kZWxOYW1lKCkpO3RoaXMubG9hZEZyb21XZWlnaHRNYXAobil9YXN5bmMgbG9hZEZyb21EaXNrKHQpe2lmKHQmJnR5cGVvZiB0IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgJHt0aGlzLl9uYW1lfS5sb2FkRnJvbURpc2sgLSBleHBlY3RlZCBtb2RlbCBmaWxlIHBhdGhgKTtsZXR7cmVhZEZpbGU6bn09YXQuZ2V0RW52KCkse21hbmlmZXN0VXJpOmEsbW9kZWxCYXNlVXJpOnJ9PUpmKHQsdGhpcy5nZXREZWZhdWx0TW9kZWxOYW1lKCkpLHM9dT0+UHJvbWlzZS5hbGwodS5tYXAocD0+bihwKS50aGVuKGQ9PnR5cGVvZiBkPT1cInN0cmluZ1wiP0J1ZmZlci5mcm9tKGQpOmQuYnVmZmVyKSkpLGk9anQud2VpZ2h0c0xvYWRlckZhY3Rvcnkocyksbz1KU09OLnBhcnNlKChhd2FpdCBuKGEpKS50b1N0cmluZygpKSxsPWF3YWl0IGkobyxyKTt0aGlzLmxvYWRGcm9tV2VpZ2h0TWFwKGwpfWxvYWRGcm9tV2VpZ2h0TWFwKHQpe2xldHtwYXJhbU1hcHBpbmdzOm4scGFyYW1zOmF9PXRoaXMuZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCk7dGhpcy5fcGFyYW1NYXBwaW5ncz1uLHRoaXMuX3BhcmFtcz1hfWV4dHJhY3RXZWlnaHRzKHQpe2xldHtwYXJhbU1hcHBpbmdzOm4scGFyYW1zOmF9PXRoaXMuZXh0cmFjdFBhcmFtcyh0KTt0aGlzLl9wYXJhbU1hcHBpbmdzPW4sdGhpcy5fcGFyYW1zPWF9dHJhdmVyc2VQcm9wZXJ0eVBhdGgodCl7aWYoIXRoaXMucGFyYW1zKXRocm93IG5ldyBFcnJvcihcInRyYXZlcnNlUHJvcGVydHlQYXRoIC0gbW9kZWwgaGFzIG5vIGxvYWRlZCBwYXJhbXNcIik7bGV0IG49dC5zcGxpdChcIi9cIikucmVkdWNlKChzLGkpPT57aWYoIXMubmV4dE9iai5oYXNPd25Qcm9wZXJ0eShpKSl0aHJvdyBuZXcgRXJyb3IoYHRyYXZlcnNlUHJvcGVydHlQYXRoIC0gb2JqZWN0IGRvZXMgbm90IGhhdmUgcHJvcGVydHkgJHtpfSwgZm9yIHBhdGggJHt0fWApO3JldHVybntvYmo6cy5uZXh0T2JqLG9ialByb3A6aSxuZXh0T2JqOnMubmV4dE9ialtpXX19LHtuZXh0T2JqOnRoaXMucGFyYW1zfSkse29iajphLG9ialByb3A6cn09bjtpZighYXx8IXJ8fCEoYVtyXWluc3RhbmNlb2YgQ2UpKXRocm93IG5ldyBFcnJvcihgdHJhdmVyc2VQcm9wZXJ0eVBhdGggLSBwYXJhbWV0ZXIgaXMgbm90IGEgdGVuc29yLCBmb3IgcGF0aCAke3R9YCk7cmV0dXJue29iajphLG9ialByb3A6cn19fTtmdW5jdGlvbiBVbihlLHQsbil7cmV0dXJuIE8oKCk9PntsZXQgYT1fcyhlLHQuZGVwdGh3aXNlX2ZpbHRlcix0LnBvaW50d2lzZV9maWx0ZXIsbixcInNhbWVcIik7cmV0dXJuIGE9WChhLHQuYmlhcyksYX0pfWZ1bmN0aW9uIFFmKGUsdCxuPSExKXtyZXR1cm4gTygoKT0+e2xldCBhPUtlKG4/WCgkdChlLHQuY29udjAuZmlsdGVycyxbMiwyXSxcInNhbWVcIiksdC5jb252MC5iaWFzKTpVbihlLHQuY29udjAsWzIsMl0pKSxyPVVuKGEsdC5jb252MSxbMSwxXSkscz1LZShYKGEscikpLGk9VW4ocyx0LmNvbnYyLFsxLDFdKTtyZXR1cm4gS2UoWChhLFgocixpKSkpfSl9ZnVuY3Rpb24gemQoZSx0LG49ITEsYT0hMCl7cmV0dXJuIE8oKCk9PntsZXQgcj1LZShuP1goJHQoZSx0LmNvbnYwLmZpbHRlcnMsYT9bMiwyXTpbMSwxXSxcInNhbWVcIiksdC5jb252MC5iaWFzKTpVbihlLHQuY29udjAsYT9bMiwyXTpbMSwxXSkpLHM9VW4ocix0LmNvbnYxLFsxLDFdKSxpPUtlKFgocixzKSksbz1VbihpLHQuY29udjIsWzEsMV0pLGw9S2UoWChyLFgocyxvKSkpLHU9VW4obCx0LmNvbnYzLFsxLDFdKTtyZXR1cm4gS2UoWChyLFgocyxYKG8sdSkpKSl9KX1mdW5jdGlvbiBpbChlLHQsbj1cInNhbWVcIixhPSExKXtyZXR1cm4gTygoKT0+e2xldCByPVgoJHQoZSx0LmZpbHRlcnMsWzEsMV0sbiksdC5iaWFzKTtyZXR1cm4gYT9LZShyKTpyfSl9ZnVuY3Rpb24gX24oZSx0KXtPYmplY3Qua2V5cyhlKS5mb3JFYWNoKG49Pnt0LnNvbWUoYT0+YS5vcmlnaW5hbFBhdGg9PT1uKXx8ZVtuXS5kaXNwb3NlKCl9KX1mdW5jdGlvbiBUcChlLHQpe3JldHVybihuLGEscixzKT0+e2xldCBpPUZhKGUobiphKnIqciksW3IscixuLGFdKSxvPWplKGUoYSkpO3JldHVybiB0LnB1c2goe3BhcmFtUGF0aDpgJHtzfS9maWx0ZXJzYH0se3BhcmFtUGF0aDpgJHtzfS9iaWFzYH0pLHtmaWx0ZXJzOmksYmlhczpvfX19ZnVuY3Rpb24gZWcoZSx0KXtyZXR1cm4obixhLHIpPT57bGV0IHM9RWEoZShuKmEpLFtuLGFdKSxpPWplKGUoYSkpO3JldHVybiB0LnB1c2goe3BhcmFtUGF0aDpgJHtyfS93ZWlnaHRzYH0se3BhcmFtUGF0aDpgJHtyfS9iaWFzYH0pLHt3ZWlnaHRzOnMsYmlhczppfX19dmFyIFdkPWNsYXNze2NvbnN0cnVjdG9yKHQsbixhKXt0aGlzLmRlcHRod2lzZV9maWx0ZXI9dDt0aGlzLnBvaW50d2lzZV9maWx0ZXI9bjt0aGlzLmJpYXM9YX19O2Z1bmN0aW9uIENwKGUsdCl7cmV0dXJuKG4sYSxyKT0+e2xldCBzPUZhKGUoOSpuKSxbMywzLG4sMV0pLGk9RmEoZShuKmEpLFsxLDEsbixhXSksbz1qZShlKGEpKTtyZXR1cm4gdC5wdXNoKHtwYXJhbVBhdGg6YCR7cn0vZGVwdGh3aXNlX2ZpbHRlcmB9LHtwYXJhbVBhdGg6YCR7cn0vcG9pbnR3aXNlX2ZpbHRlcmB9LHtwYXJhbVBhdGg6YCR7cn0vYmlhc2B9KSxuZXcgV2QocyxpLG8pfX1mdW5jdGlvbiBFcChlKXtyZXR1cm4gdD0+e2xldCBuPWUoYCR7dH0vZGVwdGh3aXNlX2ZpbHRlcmAsNCksYT1lKGAke3R9L3BvaW50d2lzZV9maWx0ZXJgLDQpLHI9ZShgJHt0fS9iaWFzYCwxKTtyZXR1cm4gbmV3IFdkKG4sYSxyKX19ZnVuY3Rpb24gc2EoZSx0KXtyZXR1cm4obixhLHIpPT57bGV0IHM9ZVtuXTtpZighdGwocyxhKSl0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHdlaWdodE1hcFske259XSB0byBiZSBhIFRlbnNvciR7YX1ELCBpbnN0ZWFkIGhhdmUgJHtzfWApO3JldHVybiB0LnB1c2goe29yaWdpbmFsUGF0aDpuLHBhcmFtUGF0aDpyfHxufSksc319ZnVuY3Rpb24gQW4oZSl7bGV0IHQ9ZTtmdW5jdGlvbiBuKHIpe2xldCBzPXQuc2xpY2UoMCxyKTtyZXR1cm4gdD10LnNsaWNlKHIpLHN9ZnVuY3Rpb24gYSgpe3JldHVybiB0fXJldHVybntleHRyYWN0V2VpZ2h0czpuLGdldFJlbWFpbmluZ1dlaWdodHM6YX19ZnVuY3Rpb24gdGcoZSx0KXtsZXQgbj1UcChlLHQpLGE9Q3AoZSx0KTtmdW5jdGlvbiByKGksbyxsLHU9ITEpe2xldCBwPXU/bihpLG8sMyxgJHtsfS9jb252MGApOmEoaSxvLGAke2x9L2NvbnYwYCksZD1hKG8sbyxgJHtsfS9jb252MWApLGM9YShvLG8sYCR7bH0vY29udjJgKTtyZXR1cm57Y29udjA6cCxjb252MTpkLGNvbnYyOmN9fWZ1bmN0aW9uIHMoaSxvLGwsdT0hMSl7bGV0e2NvbnYwOnAsY29udjE6ZCxjb252MjpjfT1yKGksbyxsLHUpLGg9YShvLG8sYCR7bH0vY29udjNgKTtyZXR1cm57Y29udjA6cCxjb252MTpkLGNvbnYyOmMsY29udjM6aH19cmV0dXJue2V4dHJhY3REZW5zZUJsb2NrM1BhcmFtczpyLGV4dHJhY3REZW5zZUJsb2NrNFBhcmFtczpzfX1mdW5jdGlvbiBlRChlKXtsZXQgdD1bXSx7ZXh0cmFjdFdlaWdodHM6bixnZXRSZW1haW5pbmdXZWlnaHRzOmF9PUFuKGUpLHtleHRyYWN0RGVuc2VCbG9jazRQYXJhbXM6cn09dGcobix0KSxzPXIoMywzMixcImRlbnNlMFwiLCEwKSxpPXIoMzIsNjQsXCJkZW5zZTFcIiksbz1yKDY0LDEyOCxcImRlbnNlMlwiKSxsPXIoMTI4LDI1NixcImRlbnNlM1wiKTtpZihhKCkubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYHdlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiAke2EoKS5sZW5ndGh9YCk7cmV0dXJue3BhcmFtTWFwcGluZ3M6dCxwYXJhbXM6e2RlbnNlMDpzLGRlbnNlMTppLGRlbnNlMjpvLGRlbnNlMzpsfX19ZnVuY3Rpb24gbmcoZSl7cmV0dXJuIHQ9PntsZXQgbj1lKGAke3R9L2ZpbHRlcnNgLDQpLGE9ZShgJHt0fS9iaWFzYCwxKTtyZXR1cm57ZmlsdGVyczpuLGJpYXM6YX19fWZ1bmN0aW9uIGFnKGUsdCl7bGV0IG49c2EoZSx0KSxhPW5nKG4pLHI9RXAobik7ZnVuY3Rpb24gcyhvLGw9ITEpe2xldCB1PWw/YShgJHtvfS9jb252MGApOnIoYCR7b30vY29udjBgKSxwPXIoYCR7b30vY29udjFgKSxkPXIoYCR7b30vY29udjJgKTtyZXR1cm57Y29udjA6dSxjb252MTpwLGNvbnYyOmR9fWZ1bmN0aW9uIGkobyxsPSExKXtsZXQgdT1sP2EoYCR7b30vY29udjBgKTpyKGAke299L2NvbnYwYCkscD1yKGAke299L2NvbnYxYCksZD1yKGAke299L2NvbnYyYCksYz1yKGAke299L2NvbnYzYCk7cmV0dXJue2NvbnYwOnUsY29udjE6cCxjb252MjpkLGNvbnYzOmN9fXJldHVybntleHRyYWN0RGVuc2VCbG9jazNQYXJhbXM6cyxleHRyYWN0RGVuc2VCbG9jazRQYXJhbXM6aX19ZnVuY3Rpb24gdEQoZSl7bGV0IHQ9W10se2V4dHJhY3REZW5zZUJsb2NrNFBhcmFtczpufT1hZyhlLHQpLGE9e2RlbnNlMDpuKFwiZGVuc2UwXCIsITApLGRlbnNlMTpuKFwiZGVuc2UxXCIpLGRlbnNlMjpuKFwiZGVuc2UyXCIpLGRlbnNlMzpuKFwiZGVuc2UzXCIpfTtyZXR1cm4gX24oZSx0KSx7cGFyYW1zOmEscGFyYW1NYXBwaW5nczp0fX12YXIgX3A9Y2xhc3MgZXh0ZW5kcyBmbntjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiRmFjZUZlYXR1cmVFeHRyYWN0b3JcIil9Zm9yd2FyZElucHV0KHQpe2xldHtwYXJhbXM6bn09dGhpcztpZighbil0aHJvdyBuZXcgRXJyb3IoXCJGYWNlRmVhdHVyZUV4dHJhY3RvciAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZVwiKTtyZXR1cm4gTygoKT0+e2xldCBhPXJlKHQudG9CYXRjaFRlbnNvcigxMTIsITApLFwiZmxvYXQzMlwiKSxzPWJyKGEsWzEyMi43ODIsMTE3LjAwMSwxMDQuMjk4XSkuZGl2KDI1NSksaT16ZChzLG4uZGVuc2UwLCEwKTtyZXR1cm4gaT16ZChpLG4uZGVuc2UxKSxpPXpkKGksbi5kZW5zZTIpLGk9emQoaSxuLmRlbnNlMyksaT15YShpLFs3LDddLFsyLDJdLFwidmFsaWRcIiksaX0pfWFzeW5jIGZvcndhcmQodCl7cmV0dXJuIHRoaXMuZm9yd2FyZElucHV0KGF3YWl0IHZ0KHQpKX1nZXREZWZhdWx0TW9kZWxOYW1lKCl7cmV0dXJuXCJmYWNlX2ZlYXR1cmVfZXh0cmFjdG9yX21vZGVsXCJ9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIHREKHQpfWV4dHJhY3RQYXJhbXModCl7cmV0dXJuIGVEKHQpfX07ZnVuY3Rpb24gQmQoZSx0KXtyZXR1cm4gTygoKT0+WCgkZShlLHQud2VpZ2h0cyksdC5iaWFzKSl9ZnVuY3Rpb24gbkQoZSx0LG4pe2xldCBhPVtdLHtleHRyYWN0V2VpZ2h0czpyLGdldFJlbWFpbmluZ1dlaWdodHM6c309QW4oZSksbz1lZyhyLGEpKHQsbixcImZjXCIpO2lmKHMoKS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgd2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6ICR7cygpLmxlbmd0aH1gKTtyZXR1cm57cGFyYW1NYXBwaW5nczphLHBhcmFtczp7ZmM6b319fWZ1bmN0aW9uIGFEKGUpe2xldCB0PVtdLG49c2EoZSx0KTtmdW5jdGlvbiBhKHMpe2xldCBpPW4oYCR7c30vd2VpZ2h0c2AsMiksbz1uKGAke3N9L2JpYXNgLDEpO3JldHVybnt3ZWlnaHRzOmksYmlhczpvfX1sZXQgcj17ZmM6YShcImZjXCIpfTtyZXR1cm4gX24oZSx0KSx7cGFyYW1zOnIscGFyYW1NYXBwaW5nczp0fX1mdW5jdGlvbiByZyhlKXtsZXQgdD17fSxuPXt9O3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGE9PntsZXQgcj1hLnN0YXJ0c1dpdGgoXCJmY1wiKT9uOnQ7clthXT1lW2FdfSkse2ZlYXR1cmVFeHRyYWN0b3JNYXA6dCxjbGFzc2lmaWVyTWFwOm59fXZhciBBcD1jbGFzcyBleHRlbmRzIGZue2NvbnN0cnVjdG9yKHQsbil7c3VwZXIodCksdGhpcy5fZmFjZUZlYXR1cmVFeHRyYWN0b3I9bn1nZXQgZmFjZUZlYXR1cmVFeHRyYWN0b3IoKXtyZXR1cm4gdGhpcy5fZmFjZUZlYXR1cmVFeHRyYWN0b3J9cnVuTmV0KHQpe2xldHtwYXJhbXM6bn09dGhpcztpZighbil0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fbmFtZX0gLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VgKTtyZXR1cm4gTygoKT0+e2xldCBhPXQgaW5zdGFuY2VvZiBXcj90aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmZvcndhcmRJbnB1dCh0KTp0O3JldHVybiBCZChhLmFzMkQoYS5zaGFwZVswXSwtMSksbi5mYyl9KX1kaXNwb3NlKHQ9ITApe3RoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZGlzcG9zZSh0KSxzdXBlci5kaXNwb3NlKHQpfWxvYWRDbGFzc2lmaWVyUGFyYW1zKHQpe2xldHtwYXJhbXM6bixwYXJhbU1hcHBpbmdzOmF9PXRoaXMuZXh0cmFjdENsYXNzaWZpZXJQYXJhbXModCk7dGhpcy5fcGFyYW1zPW4sdGhpcy5fcGFyYW1NYXBwaW5ncz1hfWV4dHJhY3RDbGFzc2lmaWVyUGFyYW1zKHQpe3JldHVybiBuRCh0LHRoaXMuZ2V0Q2xhc3NpZmllckNoYW5uZWxzSW4oKSx0aGlzLmdldENsYXNzaWZpZXJDaGFubmVsc091dCgpKX1leHRyYWN0UGFyYW1zRnJvbVdlaWdodE1hcCh0KXtsZXR7ZmVhdHVyZUV4dHJhY3Rvck1hcDpuLGNsYXNzaWZpZXJNYXA6YX09cmcodCk7cmV0dXJuIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IubG9hZEZyb21XZWlnaHRNYXAobiksYUQoYSl9ZXh0cmFjdFBhcmFtcyh0KXtsZXQgbj10aGlzLmdldENsYXNzaWZpZXJDaGFubmVsc0luKCksYT10aGlzLmdldENsYXNzaWZpZXJDaGFubmVsc091dCgpLHI9YSpuK2Escz10LnNsaWNlKDAsdC5sZW5ndGgtciksaT10LnNsaWNlKHQubGVuZ3RoLXIpO3JldHVybiB0aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmV4dHJhY3RXZWlnaHRzKHMpLHRoaXMuZXh0cmFjdENsYXNzaWZpZXJQYXJhbXMoaSl9fTt2YXIgckQ9W1wibmV1dHJhbFwiLFwiaGFwcHlcIixcInNhZFwiLFwiYW5ncnlcIixcImZlYXJmdWxcIixcImRpc2d1c3RlZFwiLFwic3VycHJpc2VkXCJdLE9zPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMubmV1dHJhbD0wO3RoaXMuaGFwcHk9MDt0aGlzLnNhZD0wO3RoaXMuYW5ncnk9MDt0aGlzLmZlYXJmdWw9MDt0aGlzLmRpc2d1c3RlZD0wO3RoaXMuc3VycHJpc2VkPTA7aWYodC5sZW5ndGghPT03KXRocm93IG5ldyBFcnJvcihgRmFjZUV4cHJlc3Npb25zLmNvbnN0cnVjdG9yIC0gZXhwZWN0ZWQgcHJvYmFiaWxpdGllcy5sZW5ndGggdG8gYmUgNywgaGF2ZTogJHt0Lmxlbmd0aH1gKTtyRC5mb3JFYWNoKChuLGEpPT57dGhpc1tuXT10W2FdfSl9YXNTb3J0ZWRBcnJheSgpe3JldHVybiByRC5tYXAodD0+KHtleHByZXNzaW9uOnQscHJvYmFiaWxpdHk6dGhpc1t0XX0pKS5zb3J0KCh0LG4pPT5uLnByb2JhYmlsaXR5LXQucHJvYmFiaWxpdHkpfX07dmFyIHNnPWNsYXNzIGV4dGVuZHMgQXB7Y29uc3RydWN0b3IodD1uZXcgX3Ape3N1cGVyKFwiRmFjZUV4cHJlc3Npb25OZXRcIix0KX1mb3J3YXJkSW5wdXQodCl7cmV0dXJuIE8oKCk9PnFhKHRoaXMucnVuTmV0KHQpKSl9YXN5bmMgZm9yd2FyZCh0KXtyZXR1cm4gdGhpcy5mb3J3YXJkSW5wdXQoYXdhaXQgdnQodCkpfWFzeW5jIHByZWRpY3RFeHByZXNzaW9ucyh0KXtsZXQgbj1hd2FpdCB2dCh0KSxhPWF3YWl0IHRoaXMuZm9yd2FyZElucHV0KG4pLHI9YXdhaXQgUHJvbWlzZS5hbGwoZHQoYSkubWFwKGFzeW5jIGk9PntsZXQgbz1pLmRhdGFTeW5jKCk7cmV0dXJuIGkuZGlzcG9zZSgpLG99KSk7YS5kaXNwb3NlKCk7bGV0IHM9ci5tYXAoaT0+bmV3IE9zKGkpKTtyZXR1cm4gbi5pc0JhdGNoSW5wdXQ/czpzWzBdfWdldERlZmF1bHRNb2RlbE5hbWUoKXtyZXR1cm5cImZhY2VfZXhwcmVzc2lvbl9tb2RlbFwifWdldENsYXNzaWZpZXJDaGFubmVsc0luKCl7cmV0dXJuIDI1Nn1nZXRDbGFzc2lmaWVyQ2hhbm5lbHNPdXQoKXtyZXR1cm4gN319O2Z1bmN0aW9uIHNEKGUpe3JldHVybiBlLmV4cHJlc3Npb25zIGluc3RhbmNlb2YgT3N9ZnVuY3Rpb24gTmsoZSx0KXtyZXR1cm57Li4uZSwuLi57ZXhwcmVzc2lvbnM6dH19fWZ1bmN0aW9uIEdmZShlLHQsbj0uMSxhKXsoQXJyYXkuaXNBcnJheSh0KT90Olt0XSkuZm9yRWFjaChzPT57bGV0IGk9cyBpbnN0YW5jZW9mIE9zP3M6c0Qocyk/cy5leHByZXNzaW9uczp2b2lkIDA7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiZHJhd0ZhY2VFeHByZXNzaW9ucyAtIGV4cGVjdGVkIGZhY2VFeHByZXNzaW9ucyB0byBiZSBGYWNlRXhwcmVzc2lvbnMgfCBXaXRoRmFjZUV4cHJlc3Npb25zPHt9PiBvciBhcnJheSB0aGVyZW9mXCIpO2xldCBsPWkuYXNTb3J0ZWRBcnJheSgpLmZpbHRlcihkPT5kLnByb2JhYmlsaXR5Pm4pLHU9enIocyk/cy5kZXRlY3Rpb24uYm94LmJvdHRvbUxlZnQ6YXx8bmV3IEhlKDAsMCk7bmV3IHNsKGwubWFwKGQ9PmAke2QuZXhwcmVzc2lvbn0gKCR7bmwoZC5wcm9iYWJpbGl0eSl9KWApLHUpLmRyYXcoZSl9KX1mdW5jdGlvbiBGcChlKXtyZXR1cm4genIoZSkmJmUubGFuZG1hcmtzIGluc3RhbmNlb2Yga2EmJmUudW5zaGlmdGVkTGFuZG1hcmtzIGluc3RhbmNlb2Yga2EmJmUuYWxpZ25lZFJlY3QgaW5zdGFuY2VvZiBGdH1mdW5jdGlvbiBIZmUoZSl7bGV0IHQ9bD0+bCoxODAvTWF0aC5QSSxuPShsLHUpPT5NYXRoLnNxcnQoKGwueC11LngpKioyKyhsLnktdS55KSoqMiksYT17cm9sbDp2b2lkIDAscGl0Y2g6dm9pZCAwLHlhdzp2b2lkIDB9LHI9KGwsdSxwKT0+e2xldCBkPU1hdGguZmxvb3IobC54LXUueCksYz1NYXRoLmZsb29yKHUueC1wLngpO3JldHVybiBkLWN9LHM9KGwsdSk9PntsZXQgcD1NYXRoLmh5cG90KHUueC1sLngsdS55LWwueSksZD11LnktbC55LGM9TWF0aC5hc2luKGQvcCksaD10KGMpLG09TWF0aC5mbG9vcig5MC1oKSxmPXUueC1sLng8MD8tMToxO3JldHVybiBtKmZ9LGk9KGwsdSxwKT0+e2xldCBkPW4obCxwKSxjPW5ldyBIZSgobC54K3AueCkvMiwobC55K3AueSkvMiksaD1uKHUsYyksbT1NYXRoLmF0YW4oaC9kKSxmPU1hdGguZmxvb3IodChtKSksZz1jLnktdS55PDA/LTE6MTtyZXR1cm4gZipnfTtpZighZXx8IWUucG9zaXRpb25zfHxlLnBvc2l0aW9ucy5sZW5ndGghPT02OClyZXR1cm4gYTtsZXQgbz1lLnBvc2l0aW9ucztyZXR1cm4gYS5yb2xsPXMob1syN10sb1s2Nl0pLGEucGl0Y2g9aShvWzE0XSxvWzMwXSxvWzJdKSxhLnlhdz1yKG9bMTRdLG9bMzNdLG9bMl0pLGF9ZnVuY3Rpb24gVmQoZSx0KXtsZXR7Ym94Om59PWUuZGV0ZWN0aW9uLGE9dC5zaGlmdEJ5KG4ueCxuLnkpLHI9YS5hbGlnbigpLHtpbWFnZURpbXM6c309ZS5kZXRlY3Rpb24saT1uZXcgRnQoZS5kZXRlY3Rpb24uc2NvcmUsci5yZXNjYWxlKHMucmV2ZXJzZSgpKSxzKSxvPUhmZSh0KTtyZXR1cm57Li4uZSwuLi57bGFuZG1hcmtzOmEsdW5zaGlmdGVkTGFuZG1hcmtzOnQsYWxpZ25lZFJlY3Q6aSxhbmdsZTpvfX19dmFyIGlnPWNsYXNze2NvbnN0cnVjdG9yKHQ9e30pe2xldHtkcmF3TGluZXM6bj0hMCxkcmF3UG9pbnRzOmE9ITAsbGluZVdpZHRoOnIsbGluZUNvbG9yOnMscG9pbnRTaXplOmkscG9pbnRDb2xvcjpvfT10O3RoaXMuZHJhd0xpbmVzPW4sdGhpcy5kcmF3UG9pbnRzPWEsdGhpcy5saW5lV2lkdGg9cnx8MSx0aGlzLnBvaW50U2l6ZT1pfHwyLHRoaXMubGluZUNvbG9yPXN8fFwicmdiYSgwLCAyNTUsIDI1NSwgMSlcIix0aGlzLnBvaW50Q29sb3I9b3x8XCJyZ2JhKDI1NSwgMCwgMjU1LCAxKVwifX0sb2c9Y2xhc3N7Y29uc3RydWN0b3IodCxuPXt9KXt0aGlzLmZhY2VMYW5kbWFya3M9dCx0aGlzLm9wdGlvbnM9bmV3IGlnKG4pfWRyYXcodCl7bGV0IG49cmEodCkse2RyYXdMaW5lczphLGRyYXdQb2ludHM6cixsaW5lV2lkdGg6cyxsaW5lQ29sb3I6aSxwb2ludFNpemU6byxwb2ludENvbG9yOmx9PXRoaXMub3B0aW9ucztpZihhJiZ0aGlzLmZhY2VMYW5kbWFya3MgaW5zdGFuY2VvZiB2cCYmKG4uc3Ryb2tlU3R5bGU9aSxuLmxpbmVXaWR0aD1zLFByKG4sdGhpcy5mYWNlTGFuZG1hcmtzLmdldEphd091dGxpbmUoKSksUHIobix0aGlzLmZhY2VMYW5kbWFya3MuZ2V0TGVmdEV5ZUJyb3coKSksUHIobix0aGlzLmZhY2VMYW5kbWFya3MuZ2V0UmlnaHRFeWVCcm93KCkpLFByKG4sdGhpcy5mYWNlTGFuZG1hcmtzLmdldE5vc2UoKSksUHIobix0aGlzLmZhY2VMYW5kbWFya3MuZ2V0TGVmdEV5ZSgpLCEwKSxQcihuLHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRSaWdodEV5ZSgpLCEwKSxQcihuLHRoaXMuZmFjZUxhbmRtYXJrcy5nZXRNb3V0aCgpLCEwKSkscil7bi5zdHJva2VTdHlsZT1sLG4uZmlsbFN0eWxlPWw7bGV0IHU9cD0+e24uYmVnaW5QYXRoKCksbi5hcmMocC54LHAueSxvLDAsMipNYXRoLlBJKSxuLmZpbGwoKX07dGhpcy5mYWNlTGFuZG1hcmtzLnBvc2l0aW9ucy5mb3JFYWNoKHUpfX19O2Z1bmN0aW9uIGpmZShlLHQpeyhBcnJheS5pc0FycmF5KHQpP3Q6W3RdKS5mb3JFYWNoKGE9PntsZXQgcj1hIGluc3RhbmNlb2Yga2E/YTpGcChhKT9hLmxhbmRtYXJrczp2b2lkIDA7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiZHJhd0ZhY2VMYW5kbWFya3MgLSBleHBlY3RlZCBmYWNlRXhwcmVzc2lvbnMgdG8gYmUgRmFjZUxhbmRtYXJrcyB8IFdpdGhGYWNlTGFuZG1hcmtzPFdpdGhGYWNlRGV0ZWN0aW9uPHt9Pj4gb3IgYXJyYXkgdGhlcmVvZlwiKTtuZXcgb2cocikuZHJhdyhlKX0pfXZhciBvRD1cIjEuNy4xNVwiO2Z1bmN0aW9uIFhmZShlLHQpe2xldCBuPVRwKGUsdCksYT1DcChlLHQpO2Z1bmN0aW9uIHIoaSxvLGwpe2xldCB1PWEoaSxvLGAke2x9L3NlcGFyYWJsZV9jb252MGApLHA9YShvLG8sYCR7bH0vc2VwYXJhYmxlX2NvbnYxYCksZD1uKGksbywxLGAke2x9L2V4cGFuc2lvbl9jb252YCk7cmV0dXJue3NlcGFyYWJsZV9jb252MDp1LHNlcGFyYWJsZV9jb252MTpwLGV4cGFuc2lvbl9jb252OmR9fWZ1bmN0aW9uIHMoaSxvKXtsZXQgbD1hKGksaSxgJHtvfS9zZXBhcmFibGVfY29udjBgKSx1PWEoaSxpLGAke299L3NlcGFyYWJsZV9jb252MWApLHA9YShpLGksYCR7b30vc2VwYXJhYmxlX2NvbnYyYCk7cmV0dXJue3NlcGFyYWJsZV9jb252MDpsLHNlcGFyYWJsZV9jb252MTp1LHNlcGFyYWJsZV9jb252MjpwfX1yZXR1cm57ZXh0cmFjdENvbnZQYXJhbXM6bixleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczphLGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtczpyLGV4dHJhY3RNYWluQmxvY2tQYXJhbXM6c319ZnVuY3Rpb24gbEQoZSx0KXtsZXQgbj1bXSx7ZXh0cmFjdFdlaWdodHM6YSxnZXRSZW1haW5pbmdXZWlnaHRzOnJ9PUFuKGUpLHtleHRyYWN0Q29udlBhcmFtczpzLGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zOmksZXh0cmFjdFJlZHVjdGlvbkJsb2NrUGFyYW1zOm8sZXh0cmFjdE1haW5CbG9ja1BhcmFtczpsfT1YZmUoYSxuKSx1PXMoMywzMiwzLFwiZW50cnlfZmxvdy9jb252X2luXCIpLHA9bygzMiw2NCxcImVudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzBcIiksZD1vKDY0LDEyOCxcImVudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzFcIiksYz17Y29udl9pbjp1LHJlZHVjdGlvbl9ibG9ja18wOnAscmVkdWN0aW9uX2Jsb2NrXzE6ZH0saD17fTtncih0LDAsMSkuZm9yRWFjaChiPT57aFtgbWFpbl9ibG9ja18ke2J9YF09bCgxMjgsYG1pZGRsZV9mbG93L21haW5fYmxvY2tfJHtifWApfSk7bGV0IG09bygxMjgsMjU2LFwiZXhpdF9mbG93L3JlZHVjdGlvbl9ibG9ja1wiKSxmPWkoMjU2LDUxMixcImV4aXRfZmxvdy9zZXBhcmFibGVfY29udlwiKSxnPXtyZWR1Y3Rpb25fYmxvY2s6bSxzZXBhcmFibGVfY29udjpmfTtpZihyKCkubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYHdlaWdodHMgcmVtYWluZyBhZnRlciBleHRyYWN0OiAke3IoKS5sZW5ndGh9YCk7cmV0dXJue3BhcmFtTWFwcGluZ3M6bixwYXJhbXM6e2VudHJ5X2Zsb3c6YyxtaWRkbGVfZmxvdzpoLGV4aXRfZmxvdzpnfX19ZnVuY3Rpb24gWWZlKGUsdCl7bGV0IG49c2EoZSx0KSxhPW5nKG4pLHI9RXAobik7ZnVuY3Rpb24gcyhvKXtsZXQgbD1yKGAke299L3NlcGFyYWJsZV9jb252MGApLHU9cihgJHtvfS9zZXBhcmFibGVfY29udjFgKSxwPWEoYCR7b30vZXhwYW5zaW9uX2NvbnZgKTtyZXR1cm57c2VwYXJhYmxlX2NvbnYwOmwsc2VwYXJhYmxlX2NvbnYxOnUsZXhwYW5zaW9uX2NvbnY6cH19ZnVuY3Rpb24gaShvKXtsZXQgbD1yKGAke299L3NlcGFyYWJsZV9jb252MGApLHU9cihgJHtvfS9zZXBhcmFibGVfY29udjFgKSxwPXIoYCR7b30vc2VwYXJhYmxlX2NvbnYyYCk7cmV0dXJue3NlcGFyYWJsZV9jb252MDpsLHNlcGFyYWJsZV9jb252MTp1LHNlcGFyYWJsZV9jb252MjpwfX1yZXR1cm57ZXh0cmFjdENvbnZQYXJhbXM6YSxleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczpyLGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtczpzLGV4dHJhY3RNYWluQmxvY2tQYXJhbXM6aX19ZnVuY3Rpb24gdUQoZSx0KXtsZXQgbj1bXSx7ZXh0cmFjdENvbnZQYXJhbXM6YSxleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczpyLGV4dHJhY3RSZWR1Y3Rpb25CbG9ja1BhcmFtczpzLGV4dHJhY3RNYWluQmxvY2tQYXJhbXM6aX09WWZlKGUsbiksbz1hKFwiZW50cnlfZmxvdy9jb252X2luXCIpLGw9cyhcImVudHJ5X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXzBcIiksdT1zKFwiZW50cnlfZmxvdy9yZWR1Y3Rpb25fYmxvY2tfMVwiKSxwPXtjb252X2luOm8scmVkdWN0aW9uX2Jsb2NrXzA6bCxyZWR1Y3Rpb25fYmxvY2tfMTp1fSxkPXt9O2dyKHQsMCwxKS5mb3JFYWNoKGY9PntkW2BtYWluX2Jsb2NrXyR7Zn1gXT1pKGBtaWRkbGVfZmxvdy9tYWluX2Jsb2NrXyR7Zn1gKX0pO2xldCBjPXMoXCJleGl0X2Zsb3cvcmVkdWN0aW9uX2Jsb2NrXCIpLGg9cihcImV4aXRfZmxvdy9zZXBhcmFibGVfY29udlwiKSxtPXtyZWR1Y3Rpb25fYmxvY2s6YyxzZXBhcmFibGVfY29udjpofTtyZXR1cm4gX24oZSxuKSx7cGFyYW1zOntlbnRyeV9mbG93OnAsbWlkZGxlX2Zsb3c6ZCxleGl0X2Zsb3c6bX0scGFyYW1NYXBwaW5nczpufX1mdW5jdGlvbiBwRChlLHQsbil7cmV0dXJuIFgoJHQoZSx0LmZpbHRlcnMsbixcInNhbWVcIiksdC5iaWFzKX1mdW5jdGlvbiBUayhlLHQsbj0hMCl7bGV0IGE9bj9LZShlKTplO3JldHVybiBhPVVuKGEsdC5zZXBhcmFibGVfY29udjAsWzEsMV0pLGE9VW4oS2UoYSksdC5zZXBhcmFibGVfY29udjEsWzEsMV0pLGE9RHQoYSxbMywzXSxbMiwyXSxcInNhbWVcIiksYT1YKGEscEQoZSx0LmV4cGFuc2lvbl9jb252LFsyLDJdKSksYX1mdW5jdGlvbiBaZmUoZSx0KXtsZXQgbj1VbihLZShlKSx0LnNlcGFyYWJsZV9jb252MCxbMSwxXSk7cmV0dXJuIG49VW4oS2UobiksdC5zZXBhcmFibGVfY29udjEsWzEsMV0pLG49VW4oS2UobiksdC5zZXBhcmFibGVfY29udjIsWzEsMV0pLG49WChuLGUpLG59dmFyIGxnPWNsYXNzIGV4dGVuZHMgZm57Y29uc3RydWN0b3IodCl7c3VwZXIoXCJUaW55WGNlcHRpb25cIiksdGhpcy5fbnVtTWFpbkJsb2Nrcz10fWZvcndhcmRJbnB1dCh0KXtsZXR7cGFyYW1zOm59PXRoaXM7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVGlueVhjZXB0aW9uIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlXCIpO3JldHVybiBPKCgpPT57bGV0IGE9cmUodC50b0JhdGNoVGVuc29yKDExMiwhMCksXCJmbG9hdDMyXCIpLHM9YnIoYSxbMTIyLjc4MiwxMTcuMDAxLDEwNC4yOThdKS5kaXYoMjU1KSxpPUtlKHBEKHMsbi5lbnRyeV9mbG93LmNvbnZfaW4sWzIsMl0pKTtyZXR1cm4gaT1UayhpLG4uZW50cnlfZmxvdy5yZWR1Y3Rpb25fYmxvY2tfMCwhMSksaT1UayhpLG4uZW50cnlfZmxvdy5yZWR1Y3Rpb25fYmxvY2tfMSksZ3IodGhpcy5fbnVtTWFpbkJsb2NrcywwLDEpLmZvckVhY2gobz0+e2k9WmZlKGksbi5taWRkbGVfZmxvd1tgbWFpbl9ibG9ja18ke299YF0pfSksaT1UayhpLG4uZXhpdF9mbG93LnJlZHVjdGlvbl9ibG9jayksaT1LZShVbihpLG4uZXhpdF9mbG93LnNlcGFyYWJsZV9jb252LFsxLDFdKSksaX0pfWFzeW5jIGZvcndhcmQodCl7cmV0dXJuIHRoaXMuZm9yd2FyZElucHV0KGF3YWl0IHZ0KHQpKX1nZXREZWZhdWx0TW9kZWxOYW1lKCl7cmV0dXJuXCJ0aW55X3hjZXB0aW9uX21vZGVsXCJ9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIHVEKHQsdGhpcy5fbnVtTWFpbkJsb2Nrcyl9ZXh0cmFjdFBhcmFtcyh0KXtyZXR1cm4gbEQodCx0aGlzLl9udW1NYWluQmxvY2tzKX19O2Z1bmN0aW9uIGNEKGUpe2xldCB0PVtdLHtleHRyYWN0V2VpZ2h0czpuLGdldFJlbWFpbmluZ1dlaWdodHM6YX09QW4oZSkscj1lZyhuLHQpLHM9cig1MTIsMSxcImZjL2FnZVwiKSxpPXIoNTEyLDIsXCJmYy9nZW5kZXJcIik7aWYoYSgpLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGB3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogJHthKCkubGVuZ3RofWApO3JldHVybntwYXJhbU1hcHBpbmdzOnQscGFyYW1zOntmYzp7YWdlOnMsZ2VuZGVyOml9fX19ZnVuY3Rpb24gZEQoZSl7bGV0IHQ9W10sbj1zYShlLHQpO2Z1bmN0aW9uIGEocyl7bGV0IGk9bihgJHtzfS93ZWlnaHRzYCwyKSxvPW4oYCR7c30vYmlhc2AsMSk7cmV0dXJue3dlaWdodHM6aSxiaWFzOm99fWxldCByPXtmYzp7YWdlOmEoXCJmYy9hZ2VcIiksZ2VuZGVyOmEoXCJmYy9nZW5kZXJcIil9fTtyZXR1cm4gX24oZSx0KSx7cGFyYW1zOnIscGFyYW1NYXBwaW5nczp0fX12YXIgQ2s9KG49PihuLkZFTUFMRT1cImZlbWFsZVwiLG4uTUFMRT1cIm1hbGVcIixuKSkoQ2t8fHt9KTt2YXIgdWc9Y2xhc3MgZXh0ZW5kcyBmbntjb25zdHJ1Y3Rvcih0PW5ldyBsZygyKSl7c3VwZXIoXCJBZ2VHZW5kZXJOZXRcIiksdGhpcy5fZmFjZUZlYXR1cmVFeHRyYWN0b3I9dH1nZXQgZmFjZUZlYXR1cmVFeHRyYWN0b3IoKXtyZXR1cm4gdGhpcy5fZmFjZUZlYXR1cmVFeHRyYWN0b3J9cnVuTmV0KHQpe2xldHtwYXJhbXM6bn09dGhpcztpZighbil0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fbmFtZX0gLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VgKTtyZXR1cm4gTygoKT0+e2xldCBhPXQgaW5zdGFuY2VvZiBXcj90aGlzLmZhY2VGZWF0dXJlRXh0cmFjdG9yLmZvcndhcmRJbnB1dCh0KTp0LHI9eWEoYSxbNyw3XSxbMiwyXSxcInZhbGlkXCIpLmFzMkQoYS5zaGFwZVswXSwtMSkscz1CZChyLG4uZmMuYWdlKS5hczFEKCksaT1CZChyLG4uZmMuZ2VuZGVyKTtyZXR1cm57YWdlOnMsZ2VuZGVyOml9fSl9Zm9yd2FyZElucHV0KHQpe3JldHVybiBPKCgpPT57bGV0e2FnZTpuLGdlbmRlcjphfT10aGlzLnJ1bk5ldCh0KTtyZXR1cm57YWdlOm4sZ2VuZGVyOnFhKGEpfX0pfWFzeW5jIGZvcndhcmQodCl7cmV0dXJuIHRoaXMuZm9yd2FyZElucHV0KGF3YWl0IHZ0KHQpKX1hc3luYyBwcmVkaWN0QWdlQW5kR2VuZGVyKHQpe2xldCBuPWF3YWl0IHZ0KHQpLGE9YXdhaXQgdGhpcy5mb3J3YXJkSW5wdXQobikscj1kdChhLmFnZSkscz1kdChhLmdlbmRlciksaT1yLm1hcCgobCx1KT0+KHthZ2VUZW5zb3I6bCxnZW5kZXJUZW5zb3I6c1t1XX0pKSxvPWF3YWl0IFByb21pc2UuYWxsKGkubWFwKGFzeW5jKHthZ2VUZW5zb3I6bCxnZW5kZXJUZW5zb3I6dX0pPT57bGV0IHA9bC5kYXRhU3luYygpWzBdLGQ9dS5kYXRhU3luYygpWzBdLGM9ZD4uNSxoPWM/XCJtYWxlXCI6XCJmZW1hbGVcIixtPWM/ZDoxLWQ7cmV0dXJuIGwuZGlzcG9zZSgpLHUuZGlzcG9zZSgpLHthZ2U6cCxnZW5kZXI6aCxnZW5kZXJQcm9iYWJpbGl0eTptfX0pKTtyZXR1cm4gYS5hZ2UuZGlzcG9zZSgpLGEuZ2VuZGVyLmRpc3Bvc2UoKSxuLmlzQmF0Y2hJbnB1dD9vOm9bMF19Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwiYWdlX2dlbmRlcl9tb2RlbFwifWRpc3Bvc2UodD0hMCl7dGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5kaXNwb3NlKHQpLHN1cGVyLmRpc3Bvc2UodCl9bG9hZENsYXNzaWZpZXJQYXJhbXModCl7bGV0e3BhcmFtczpuLHBhcmFtTWFwcGluZ3M6YX09dGhpcy5leHRyYWN0Q2xhc3NpZmllclBhcmFtcyh0KTt0aGlzLl9wYXJhbXM9bix0aGlzLl9wYXJhbU1hcHBpbmdzPWF9ZXh0cmFjdENsYXNzaWZpZXJQYXJhbXModCl7cmV0dXJuIGNEKHQpfWV4dHJhY3RQYXJhbXNGcm9tV2VpZ2h0TWFwKHQpe2xldHtmZWF0dXJlRXh0cmFjdG9yTWFwOm4sY2xhc3NpZmllck1hcDphfT1yZyh0KTtyZXR1cm4gdGhpcy5mYWNlRmVhdHVyZUV4dHJhY3Rvci5sb2FkRnJvbVdlaWdodE1hcChuKSxkRChhKX1leHRyYWN0UGFyYW1zKHQpe2xldCBhPXQuc2xpY2UoMCx0Lmxlbmd0aC0xNTM5KSxyPXQuc2xpY2UodC5sZW5ndGgtMTUzOSk7cmV0dXJuIHRoaXMuZmFjZUZlYXR1cmVFeHRyYWN0b3IuZXh0cmFjdFdlaWdodHMoYSksdGhpcy5leHRyYWN0Q2xhc3NpZmllclBhcmFtcyhyKX19O3ZhciAkcD1jbGFzcyBleHRlbmRzIEFwe3Bvc3RQcm9jZXNzKHQsbixhKXtsZXQgcj1hLm1hcCgoe3dpZHRoOmksaGVpZ2h0Om99KT0+e2xldCBsPW4vTWF0aC5tYXgobyxpKTtyZXR1cm57d2lkdGg6aSpsLGhlaWdodDpvKmx9fSkscz1yLmxlbmd0aDtyZXR1cm4gTygoKT0+e2xldCBpPShkLGMpPT5BdChbeW4oWzY4XSxkLFwiZmxvYXQzMlwiKSx5bihbNjhdLGMsXCJmbG9hdDMyXCIpXSwxKS5hczJEKDEsMTM2KS5hczFEKCksbz0oZCxjKT0+e2xldHt3aWR0aDpoLGhlaWdodDptfT1yW2RdO3JldHVybiBjKGgsbSk/TWF0aC5hYnMoaC1tKS8yOjB9LGw9ZD0+byhkLChjLGgpPT5jPGgpLHU9ZD0+byhkLChjLGgpPT5oPGMpO3JldHVybiB0Lm11bCh5bihbcywxMzZdLG4sXCJmbG9hdDMyXCIpKS5zdWIoQXQoQXJyYXkuZnJvbShBcnJheShzKSwoZCxjKT0+aShsKGMpLHUoYykpKSkpLmRpdihBdChBcnJheS5mcm9tKEFycmF5KHMpLChkLGMpPT5pKHJbY10ud2lkdGgscltjXS5oZWlnaHQpKSkpfSl9Zm9yd2FyZElucHV0KHQpe3JldHVybiBPKCgpPT57bGV0IG49dGhpcy5ydW5OZXQodCk7cmV0dXJuIHRoaXMucG9zdFByb2Nlc3Mobix0LmlucHV0U2l6ZSx0LmlucHV0RGltZW5zaW9ucy5tYXAoKFthLHJdKT0+KHtoZWlnaHQ6YSx3aWR0aDpyfSkpKX0pfWFzeW5jIGZvcndhcmQodCl7cmV0dXJuIHRoaXMuZm9yd2FyZElucHV0KGF3YWl0IHZ0KHQpKX1hc3luYyBkZXRlY3RMYW5kbWFya3ModCl7bGV0IG49YXdhaXQgdnQodCksYT1PKCgpPT5kdCh0aGlzLmZvcndhcmRJbnB1dChuKSkpLHI9YXdhaXQgUHJvbWlzZS5hbGwoYS5tYXAoYXN5bmMocyxpKT0+e2xldCBvPUFycmF5LmZyb20ocy5kYXRhU3luYygpKSxsPW8uZmlsdGVyKChwLGQpPT5IZihkKSksdT1vLmZpbHRlcigocCxkKT0+IUhmKGQpKTtyZXR1cm4gbmV3IHZwKEFycmF5KDY4KS5maWxsKDApLm1hcCgocCxkKT0+bmV3IEhlKGxbZF0sdVtkXSkpLHtoZWlnaHQ6bi5nZXRJbnB1dEhlaWdodChpKSx3aWR0aDpuLmdldElucHV0V2lkdGgoaSl9KX0pKTtyZXR1cm4gYS5mb3JFYWNoKHM9PnMuZGlzcG9zZSgpKSxuLmlzQmF0Y2hJbnB1dD9yOnJbMF19Z2V0Q2xhc3NpZmllckNoYW5uZWxzT3V0KCl7cmV0dXJuIDEzNn19O3ZhciBEcD1jbGFzcyBleHRlbmRzICRwe2NvbnN0cnVjdG9yKHQ9bmV3IF9wKXtzdXBlcihcIkZhY2VMYW5kbWFyazY4TmV0XCIsdCl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwiZmFjZV9sYW5kbWFya182OF9tb2RlbFwifWdldENsYXNzaWZpZXJDaGFubmVsc0luKCl7cmV0dXJuIDI1Nn19O2Z1bmN0aW9uIGhEKGUpe2xldCB0PVtdLHtleHRyYWN0RGVuc2VCbG9jazNQYXJhbXM6bn09YWcoZSx0KSxhPXtkZW5zZTA6bihcImRlbnNlMFwiLCEwKSxkZW5zZTE6bihcImRlbnNlMVwiKSxkZW5zZTI6bihcImRlbnNlMlwiKX07cmV0dXJuIF9uKGUsdCkse3BhcmFtczphLHBhcmFtTWFwcGluZ3M6dH19ZnVuY3Rpb24gbUQoZSl7bGV0IHQ9W10se2V4dHJhY3RXZWlnaHRzOm4sZ2V0UmVtYWluaW5nV2VpZ2h0czphfT1BbihlKSx7ZXh0cmFjdERlbnNlQmxvY2szUGFyYW1zOnJ9PXRnKG4sdCkscz1yKDMsMzIsXCJkZW5zZTBcIiwhMCksaT1yKDMyLDY0LFwiZGVuc2UxXCIpLG89cig2NCwxMjgsXCJkZW5zZTJcIik7aWYoYSgpLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGB3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogJHthKCkubGVuZ3RofWApO3JldHVybntwYXJhbU1hcHBpbmdzOnQscGFyYW1zOntkZW5zZTA6cyxkZW5zZTE6aSxkZW5zZTI6b319fXZhciBwZz1jbGFzcyBleHRlbmRzIGZue2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3JcIil9Zm9yd2FyZElucHV0KHQpe2xldHtwYXJhbXM6bn09dGhpcztpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUaW55RmFjZUZlYXR1cmVFeHRyYWN0b3IgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VcIik7cmV0dXJuIE8oKCk9PntsZXQgYT1yZSh0LnRvQmF0Y2hUZW5zb3IoMTEyLCEwKSxcImZsb2F0MzJcIikscz1icihhLFsxMjIuNzgyLDExNy4wMDEsMTA0LjI5OF0pLmRpdigyNTUpLGk9UWYocyxuLmRlbnNlMCwhMCk7cmV0dXJuIGk9UWYoaSxuLmRlbnNlMSksaT1RZihpLG4uZGVuc2UyKSxpPXlhKGksWzE0LDE0XSxbMiwyXSxcInZhbGlkXCIpLGl9KX1hc3luYyBmb3J3YXJkKHQpe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwiZmFjZV9mZWF0dXJlX2V4dHJhY3Rvcl90aW55X21vZGVsXCJ9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIGhEKHQpfWV4dHJhY3RQYXJhbXModCl7cmV0dXJuIG1EKHQpfX07dmFyIGNnPWNsYXNzIGV4dGVuZHMgJHB7Y29uc3RydWN0b3IodD1uZXcgcGcpe3N1cGVyKFwiRmFjZUxhbmRtYXJrNjhUaW55TmV0XCIsdCl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwiZmFjZV9sYW5kbWFya182OF90aW55X21vZGVsXCJ9Z2V0Q2xhc3NpZmllckNoYW5uZWxzSW4oKXtyZXR1cm4gMTI4fX07dmFyIGZEPWNsYXNzIGV4dGVuZHMgRHB7fTtmdW5jdGlvbiBnRChlLHQpe3JldHVybiBYKHooZSx0LndlaWdodHMpLHQuYmlhc2VzKX1mdW5jdGlvbiBFayhlLHQsbixhLHI9XCJzYW1lXCIpe2xldHtmaWx0ZXJzOnMsYmlhczppfT10LmNvbnYsbz0kdChlLHMsbixyKTtyZXR1cm4gbz1YKG8saSksbz1nRChvLHQuc2NhbGUpLGE/S2Uobyk6b31mdW5jdGlvbiBiRChlLHQpe3JldHVybiBFayhlLHQsWzEsMV0sITApfWZ1bmN0aW9uIF9rKGUsdCl7cmV0dXJuIEVrKGUsdCxbMSwxXSwhMSl9ZnVuY3Rpb24gZGcoZSx0KXtyZXR1cm4gRWsoZSx0LFsyLDJdLCEwLFwidmFsaWRcIil9ZnVuY3Rpb24gSmZlKGUsdCl7ZnVuY3Rpb24gbihvLGwsdSl7bGV0IHA9ZShvKSxkPXAubGVuZ3RoLyhsKnUqdSk7aWYoZ2soZCkpdGhyb3cgbmV3IEVycm9yKGBkZXB0aCBoYXMgdG8gYmUgYW4gaW50ZWdlcjogJHtkfSwgd2VpZ2h0cy5sZW5ndGg6ICR7cC5sZW5ndGh9LCBudW1GaWx0ZXJzOiAke2x9LCBmaWx0ZXJTaXplOiAke3V9YCk7cmV0dXJuIE8oKCk9PkRlKEZhKHAsW2wsZCx1LHVdKSxbMiwzLDEsMF0pKX1mdW5jdGlvbiBhKG8sbCx1LHApe2xldCBkPW4obyxsLHUpLGM9amUoZShsKSk7cmV0dXJuIHQucHVzaCh7cGFyYW1QYXRoOmAke3B9L2ZpbHRlcnNgfSx7cGFyYW1QYXRoOmAke3B9L2JpYXNgfSkse2ZpbHRlcnM6ZCxiaWFzOmN9fWZ1bmN0aW9uIHIobyxsKXtsZXQgdT1qZShlKG8pKSxwPWplKGUobykpO3JldHVybiB0LnB1c2goe3BhcmFtUGF0aDpgJHtsfS93ZWlnaHRzYH0se3BhcmFtUGF0aDpgJHtsfS9iaWFzZXNgfSkse3dlaWdodHM6dSxiaWFzZXM6cH19ZnVuY3Rpb24gcyhvLGwsdSxwKXtsZXQgZD1hKG8sbCx1LGAke3B9L2NvbnZgKSxjPXIobCxgJHtwfS9zY2FsZWApO3JldHVybntjb252OmQsc2NhbGU6Y319ZnVuY3Rpb24gaShvLGwsdSxwLGQ9ITEpe2xldCBjPXMoKGQ/LjU6MSkqbyxsLHUsYCR7cH0vY29udjFgKSxoPXMobyxsLHUsYCR7cH0vY29udjJgKTtyZXR1cm57Y29udjE6Yyxjb252MjpofX1yZXR1cm57ZXh0cmFjdENvbnZMYXllclBhcmFtczpzLGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zOml9fWZ1bmN0aW9uIHlEKGUpe2xldHtleHRyYWN0V2VpZ2h0czp0LGdldFJlbWFpbmluZ1dlaWdodHM6bn09QW4oZSksYT1bXSx7ZXh0cmFjdENvbnZMYXllclBhcmFtczpyLGV4dHJhY3RSZXNpZHVhbExheWVyUGFyYW1zOnN9PUpmZSh0LGEpLGk9cig0NzA0LDMyLDcsXCJjb252MzJfZG93blwiKSxvPXMoOTIxNiwzMiwzLFwiY29udjMyXzFcIiksbD1zKDkyMTYsMzIsMyxcImNvbnYzMl8yXCIpLHU9cyg5MjE2LDMyLDMsXCJjb252MzJfM1wiKSxwPXMoMzY4NjQsNjQsMyxcImNvbnY2NF9kb3duXCIsITApLGQ9cygzNjg2NCw2NCwzLFwiY29udjY0XzFcIiksYz1zKDM2ODY0LDY0LDMsXCJjb252NjRfMlwiKSxoPXMoMzY4NjQsNjQsMyxcImNvbnY2NF8zXCIpLG09cygxNDc0NTYsMTI4LDMsXCJjb252MTI4X2Rvd25cIiwhMCksZj1zKDE0NzQ1NiwxMjgsMyxcImNvbnYxMjhfMVwiKSxnPXMoMTQ3NDU2LDEyOCwzLFwiY29udjEyOF8yXCIpLGI9cyg1ODk4MjQsMjU2LDMsXCJjb252MjU2X2Rvd25cIiwhMCkseT1zKDU4OTgyNCwyNTYsMyxcImNvbnYyNTZfMVwiKSx4PXMoNTg5ODI0LDI1NiwzLFwiY29udjI1Nl8yXCIpLHY9cyg1ODk4MjQsMjU2LDMsXCJjb252MjU2X2Rvd25fb3V0XCIpLEk9TygoKT0+RGUoRWEodCgyNTYqMTI4KSxbMTI4LDI1Nl0pLFsxLDBdKSk7aWYoYS5wdXNoKHtwYXJhbVBhdGg6XCJmY1wifSksbigpLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGB3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogJHtuKCkubGVuZ3RofWApO3JldHVybntwYXJhbXM6e2NvbnYzMl9kb3duOmksY29udjMyXzE6byxjb252MzJfMjpsLGNvbnYzMl8zOnUsY29udjY0X2Rvd246cCxjb252NjRfMTpkLGNvbnY2NF8yOmMsY29udjY0XzM6aCxjb252MTI4X2Rvd246bSxjb252MTI4XzE6Zixjb252MTI4XzI6Zyxjb252MjU2X2Rvd246Yixjb252MjU2XzE6eSxjb252MjU2XzI6eCxjb252MjU2X2Rvd25fb3V0OnYsZmM6SX0scGFyYW1NYXBwaW5nczphfX1mdW5jdGlvbiBRZmUoZSx0KXtsZXQgbj1zYShlLHQpO2Z1bmN0aW9uIGEoaSl7bGV0IG89bihgJHtpfS9zY2FsZS93ZWlnaHRzYCwxKSxsPW4oYCR7aX0vc2NhbGUvYmlhc2VzYCwxKTtyZXR1cm57d2VpZ2h0czpvLGJpYXNlczpsfX1mdW5jdGlvbiByKGkpe2xldCBvPW4oYCR7aX0vY29udi9maWx0ZXJzYCw0KSxsPW4oYCR7aX0vY29udi9iaWFzYCwxKSx1PWEoaSk7cmV0dXJue2NvbnY6e2ZpbHRlcnM6byxiaWFzOmx9LHNjYWxlOnV9fWZ1bmN0aW9uIHMoaSl7cmV0dXJue2NvbnYxOnIoYCR7aX0vY29udjFgKSxjb252MjpyKGAke2l9L2NvbnYyYCl9fXJldHVybntleHRyYWN0Q29udkxheWVyUGFyYW1zOnIsZXh0cmFjdFJlc2lkdWFsTGF5ZXJQYXJhbXM6c319ZnVuY3Rpb24geEQoZSl7bGV0IHQ9W10se2V4dHJhY3RDb252TGF5ZXJQYXJhbXM6bixleHRyYWN0UmVzaWR1YWxMYXllclBhcmFtczphfT1RZmUoZSx0KSxyPW4oXCJjb252MzJfZG93blwiKSxzPWEoXCJjb252MzJfMVwiKSxpPWEoXCJjb252MzJfMlwiKSxvPWEoXCJjb252MzJfM1wiKSxsPWEoXCJjb252NjRfZG93blwiKSx1PWEoXCJjb252NjRfMVwiKSxwPWEoXCJjb252NjRfMlwiKSxkPWEoXCJjb252NjRfM1wiKSxjPWEoXCJjb252MTI4X2Rvd25cIiksaD1hKFwiY29udjEyOF8xXCIpLG09YShcImNvbnYxMjhfMlwiKSxmPWEoXCJjb252MjU2X2Rvd25cIiksZz1hKFwiY29udjI1Nl8xXCIpLGI9YShcImNvbnYyNTZfMlwiKSx5PWEoXCJjb252MjU2X2Rvd25fb3V0XCIpLHtmYzp4fT1lO2lmKHQucHVzaCh7b3JpZ2luYWxQYXRoOlwiZmNcIixwYXJhbVBhdGg6XCJmY1wifSksIWZrKHgpKXRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgd2VpZ2h0TWFwW2ZjXSB0byBiZSBhIFRlbnNvcjJELCBpbnN0ZWFkIGhhdmUgJHt4fWApO2xldCB2PXtjb252MzJfZG93bjpyLGNvbnYzMl8xOnMsY29udjMyXzI6aSxjb252MzJfMzpvLGNvbnY2NF9kb3duOmwsY29udjY0XzE6dSxjb252NjRfMjpwLGNvbnY2NF8zOmQsY29udjEyOF9kb3duOmMsY29udjEyOF8xOmgsY29udjEyOF8yOm0sY29udjI1Nl9kb3duOmYsY29udjI1Nl8xOmcsY29udjI1Nl8yOmIsY29udjI1Nl9kb3duX291dDp5LGZjOnh9O3JldHVybiBfbihlLHQpLHtwYXJhbXM6dixwYXJhbU1hcHBpbmdzOnR9fWZ1bmN0aW9uIFlhKGUsdCl7bGV0IG49YkQoZSx0LmNvbnYxKTtyZXR1cm4gbj1fayhuLHQuY29udjIpLG49WChuLGUpLG49S2Uobiksbn1mdW5jdGlvbiBVZChlLHQpe2xldCBuPWRnKGUsdC5jb252MSk7bj1fayhuLHQuY29udjIpO2xldCBhPXlhKGUsMiwyLFwidmFsaWRcIikscj1JdChhLnNoYXBlKSxzPWEuc2hhcGVbM10hPT1uLnNoYXBlWzNdO2lmKGEuc2hhcGVbMV0hPT1uLnNoYXBlWzFdfHxhLnNoYXBlWzJdIT09bi5zaGFwZVsyXSl7bGV0IG89Wy4uLm4uc2hhcGVdO29bMV09MTtsZXQgbD1JdChvKTtuPWV0KFtuLGxdLDEpO2xldCB1PVsuLi5uLnNoYXBlXTt1WzJdPTE7bGV0IHA9SXQodSk7bj1ldChbbixwXSwyKX1yZXR1cm4gYT1zP2V0KFthLHJdLDMpOmEsbj1YKGEsbiksbj1LZShuKSxufXZhciBScD1jbGFzcyBleHRlbmRzIGZue2NvbnN0cnVjdG9yKCl7c3VwZXIoXCJGYWNlUmVjb2duaXRpb25OZXRcIil9Zm9yd2FyZElucHV0KHQpe2xldHtwYXJhbXM6bn09dGhpcztpZighbil0aHJvdyBuZXcgRXJyb3IoXCJGYWNlUmVjb2duaXRpb25OZXQgLSBsb2FkIG1vZGVsIGJlZm9yZSBpbmZlcmVuY2VcIik7cmV0dXJuIE8oKCk9PntsZXQgYT1yZSh0LnRvQmF0Y2hUZW5zb3IoMTUwLCEwKSxcImZsb2F0MzJcIikscz1icihhLFsxMjIuNzgyLDExNy4wMDEsMTA0LjI5OF0pLmRpdigyNTUpLGk9ZGcocyxuLmNvbnYzMl9kb3duKTtpPUR0KGksMywyLFwidmFsaWRcIiksaT1ZYShpLG4uY29udjMyXzEpLGk9WWEoaSxuLmNvbnYzMl8yKSxpPVlhKGksbi5jb252MzJfMyksaT1VZChpLG4uY29udjY0X2Rvd24pLGk9WWEoaSxuLmNvbnY2NF8xKSxpPVlhKGksbi5jb252NjRfMiksaT1ZYShpLG4uY29udjY0XzMpLGk9VWQoaSxuLmNvbnYxMjhfZG93biksaT1ZYShpLG4uY29udjEyOF8xKSxpPVlhKGksbi5jb252MTI4XzIpLGk9VWQoaSxuLmNvbnYyNTZfZG93biksaT1ZYShpLG4uY29udjI1Nl8xKSxpPVlhKGksbi5jb252MjU2XzIpLGk9VWQoaSxuLmNvbnYyNTZfZG93bl9vdXQpO2xldCBvPWkubWVhbihbMSwyXSk7cmV0dXJuICRlKG8sbi5mYyl9KX1hc3luYyBmb3J3YXJkKHQpe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSl9YXN5bmMgY29tcHV0ZUZhY2VEZXNjcmlwdG9yKHQpe3ZhciBzO2lmKChzPXQ9PW51bGw/dm9pZCAwOnQuc2hhcGUpIT1udWxsJiZzLnNvbWUoaT0+aTw9MCkpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMTI4KTtsZXQgbj1hd2FpdCB2dCh0KSxhPU8oKCk9PmR0KHRoaXMuZm9yd2FyZElucHV0KG4pKSkscj1hd2FpdCBQcm9taXNlLmFsbChhLm1hcChpPT5pLmRhdGEoKSkpO3JldHVybiBhLmZvckVhY2goaT0+aS5kaXNwb3NlKCkpLG4uaXNCYXRjaElucHV0P3I6clswXX1nZXREZWZhdWx0TW9kZWxOYW1lKCl7cmV0dXJuXCJmYWNlX3JlY29nbml0aW9uX21vZGVsXCJ9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIHhEKHQpfWV4dHJhY3RQYXJhbXModCl7cmV0dXJuIHlEKHQpfX07ZnVuY3Rpb24gWTJlKGUpe2xldCB0PW5ldyBScDtyZXR1cm4gdC5leHRyYWN0V2VpZ2h0cyhlKSx0fWZ1bmN0aW9uIEFrKGUsdCl7cmV0dXJuey4uLmUsLi4ue2Rlc2NyaXB0b3I6dH19fWZ1bmN0aW9uIGVDZShlKXtyZXR1cm4gdHlwZW9mIGUuYWdlPT1cIm51bWJlclwifWZ1bmN0aW9uIEZrKGUsdCl7cmV0dXJuey4uLmUsLi4ue2FnZTp0fX19ZnVuY3Rpb24gckNlKGUpe3JldHVybihlLmdlbmRlcj09PVwibWFsZVwifHxlLmdlbmRlcj09PVwiZmVtYWxlXCIpJiZncChlLmdlbmRlclByb2JhYmlsaXR5KX1mdW5jdGlvbiAkayhlLHQsbil7cmV0dXJuey4uLmUsLi4ue2dlbmRlcjp0LGdlbmRlclByb2JhYmlsaXR5Om59fX1mdW5jdGlvbiBlZ2UoZSx0KXtmdW5jdGlvbiBuKGwsdSl7bGV0IHA9RmEoZSg5KmwpLFszLDMsbCwxXSksZD1qZShlKGwpKSxjPWplKGUobCkpLGg9amUoZShsKSksbT1qZShlKGwpKTtyZXR1cm4gdC5wdXNoKHtwYXJhbVBhdGg6YCR7dX0vZmlsdGVyc2B9LHtwYXJhbVBhdGg6YCR7dX0vYmF0Y2hfbm9ybV9zY2FsZWB9LHtwYXJhbVBhdGg6YCR7dX0vYmF0Y2hfbm9ybV9vZmZzZXRgfSx7cGFyYW1QYXRoOmAke3V9L2JhdGNoX25vcm1fbWVhbmB9LHtwYXJhbVBhdGg6YCR7dX0vYmF0Y2hfbm9ybV92YXJpYW5jZWB9KSx7ZmlsdGVyczpwLGJhdGNoX25vcm1fc2NhbGU6ZCxiYXRjaF9ub3JtX29mZnNldDpjLGJhdGNoX25vcm1fbWVhbjpoLGJhdGNoX25vcm1fdmFyaWFuY2U6bX19ZnVuY3Rpb24gYShsLHUscCxkLGMpe2xldCBoPUZhKGUobCp1KnAqcCksW3AscCxsLHVdKSxtPWplKGUodSkpO3JldHVybiB0LnB1c2goe3BhcmFtUGF0aDpgJHtkfS9maWx0ZXJzYH0se3BhcmFtUGF0aDpgJHtkfS8ke2M/XCJiYXRjaF9ub3JtX29mZnNldFwiOlwiYmlhc1wifWB9KSx7ZmlsdGVyczpoLGJpYXM6bX19ZnVuY3Rpb24gcihsLHUscCxkKXtsZXR7ZmlsdGVyczpjLGJpYXM6aH09YShsLHUscCxkLCEwKTtyZXR1cm57ZmlsdGVyczpjLGJhdGNoX25vcm1fb2Zmc2V0Omh9fWZ1bmN0aW9uIHMobCx1LHApe2xldCBkPW4obCxgJHtwfS9kZXB0aHdpc2VfY29udmApLGM9cihsLHUsMSxgJHtwfS9wb2ludHdpc2VfY29udmApO3JldHVybntkZXB0aHdpc2VfY29udjpkLHBvaW50d2lzZV9jb252OmN9fWZ1bmN0aW9uIGkoKXtsZXQgbD1yKDMsMzIsMyxcIm1vYmlsZW5ldHYxL2NvbnZfMFwiKSx1PXMoMzIsNjQsXCJtb2JpbGVuZXR2MS9jb252XzFcIikscD1zKDY0LDEyOCxcIm1vYmlsZW5ldHYxL2NvbnZfMlwiKSxkPXMoMTI4LDEyOCxcIm1vYmlsZW5ldHYxL2NvbnZfM1wiKSxjPXMoMTI4LDI1NixcIm1vYmlsZW5ldHYxL2NvbnZfNFwiKSxoPXMoMjU2LDI1NixcIm1vYmlsZW5ldHYxL2NvbnZfNVwiKSxtPXMoMjU2LDUxMixcIm1vYmlsZW5ldHYxL2NvbnZfNlwiKSxmPXMoNTEyLDUxMixcIm1vYmlsZW5ldHYxL2NvbnZfN1wiKSxnPXMoNTEyLDUxMixcIm1vYmlsZW5ldHYxL2NvbnZfOFwiKSxiPXMoNTEyLDUxMixcIm1vYmlsZW5ldHYxL2NvbnZfOVwiKSx5PXMoNTEyLDUxMixcIm1vYmlsZW5ldHYxL2NvbnZfMTBcIikseD1zKDUxMiw1MTIsXCJtb2JpbGVuZXR2MS9jb252XzExXCIpLHY9cyg1MTIsMTAyNCxcIm1vYmlsZW5ldHYxL2NvbnZfMTJcIiksST1zKDEwMjQsMTAyNCxcIm1vYmlsZW5ldHYxL2NvbnZfMTNcIik7cmV0dXJue2NvbnZfMDpsLGNvbnZfMTp1LGNvbnZfMjpwLGNvbnZfMzpkLGNvbnZfNDpjLGNvbnZfNTpoLGNvbnZfNjptLGNvbnZfNzpmLGNvbnZfODpnLGNvbnZfOTpiLGNvbnZfMTA6eSxjb252XzExOngsY29udl8xMjp2LGNvbnZfMTM6SX19ZnVuY3Rpb24gbygpe2xldCBsPXIoMTAyNCwyNTYsMSxcInByZWRpY3Rpb25fbGF5ZXIvY29udl8wXCIpLHU9cigyNTYsNTEyLDMsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfMVwiKSxwPXIoNTEyLDEyOCwxLFwicHJlZGljdGlvbl9sYXllci9jb252XzJcIiksZD1yKDEyOCwyNTYsMyxcInByZWRpY3Rpb25fbGF5ZXIvY29udl8zXCIpLGM9cigyNTYsMTI4LDEsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfNFwiKSxoPXIoMTI4LDI1NiwzLFwicHJlZGljdGlvbl9sYXllci9jb252XzVcIiksbT1yKDI1Niw2NCwxLFwicHJlZGljdGlvbl9sYXllci9jb252XzZcIiksZj1yKDY0LDEyOCwzLFwicHJlZGljdGlvbl9sYXllci9jb252XzdcIiksZz1hKDUxMiwxMiwxLFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzAvYm94X2VuY29kaW5nX3ByZWRpY3RvclwiKSxiPWEoNTEyLDksMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8wL2NsYXNzX3ByZWRpY3RvclwiKSx5PWEoMTAyNCwyNCwxLFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzEvYm94X2VuY29kaW5nX3ByZWRpY3RvclwiKSx4PWEoMTAyNCwxOCwxLFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzEvY2xhc3NfcHJlZGljdG9yXCIpLHY9YSg1MTIsMjQsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8yL2JveF9lbmNvZGluZ19wcmVkaWN0b3JcIiksST1hKDUxMiwxOCwxLFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzIvY2xhc3NfcHJlZGljdG9yXCIpLE49YSgyNTYsMjQsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8zL2JveF9lbmNvZGluZ19wcmVkaWN0b3JcIiksQz1hKDI1NiwxOCwxLFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzMvY2xhc3NfcHJlZGljdG9yXCIpLF89YSgyNTYsMjQsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl80L2JveF9lbmNvZGluZ19wcmVkaWN0b3JcIiksRj1hKDI1NiwxOCwxLFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzQvY2xhc3NfcHJlZGljdG9yXCIpLEQ9YSgxMjgsMjQsMSxcInByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl81L2JveF9lbmNvZGluZ19wcmVkaWN0b3JcIiksJD1hKDEyOCwxOCwxLFwicHJlZGljdGlvbl9sYXllci9ib3hfcHJlZGljdG9yXzUvY2xhc3NfcHJlZGljdG9yXCIpO3JldHVybntjb252XzA6bCxjb252XzE6dSxjb252XzI6cCxjb252XzM6ZCxjb252XzQ6Yyxjb252XzU6aCxjb252XzY6bSxjb252Xzc6Zixib3hfcHJlZGljdG9yXzA6e2JveF9lbmNvZGluZ19wcmVkaWN0b3I6ZyxjbGFzc19wcmVkaWN0b3I6Yn0sYm94X3ByZWRpY3Rvcl8xOntib3hfZW5jb2RpbmdfcHJlZGljdG9yOnksY2xhc3NfcHJlZGljdG9yOnh9LGJveF9wcmVkaWN0b3JfMjp7Ym94X2VuY29kaW5nX3ByZWRpY3Rvcjp2LGNsYXNzX3ByZWRpY3RvcjpJfSxib3hfcHJlZGljdG9yXzM6e2JveF9lbmNvZGluZ19wcmVkaWN0b3I6TixjbGFzc19wcmVkaWN0b3I6Q30sYm94X3ByZWRpY3Rvcl80Ontib3hfZW5jb2RpbmdfcHJlZGljdG9yOl8sY2xhc3NfcHJlZGljdG9yOkZ9LGJveF9wcmVkaWN0b3JfNTp7Ym94X2VuY29kaW5nX3ByZWRpY3RvcjpELGNsYXNzX3ByZWRpY3RvcjokfX19cmV0dXJue2V4dHJhY3RNb2JpbGVuZXRWMVBhcmFtczppLGV4dHJhY3RQcmVkaWN0aW9uTGF5ZXJQYXJhbXM6b319ZnVuY3Rpb24gdkQoZSl7bGV0IHQ9W10se2V4dHJhY3RXZWlnaHRzOm4sZ2V0UmVtYWluaW5nV2VpZ2h0czphfT1BbihlKSx7ZXh0cmFjdE1vYmlsZW5ldFYxUGFyYW1zOnIsZXh0cmFjdFByZWRpY3Rpb25MYXllclBhcmFtczpzfT1lZ2Uobix0KSxpPXIoKSxvPXMoKSx1PXtleHRyYV9kaW06eGQobig1MTE4KjQpLFsxLDUxMTgsNF0pfTtpZih0LnB1c2goe3BhcmFtUGF0aDpcIm91dHB1dF9sYXllci9leHRyYV9kaW1cIn0pLGEoKS5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgd2VpZ2h0cyByZW1haW5nIGFmdGVyIGV4dHJhY3Q6ICR7YSgpLmxlbmd0aH1gKTtyZXR1cm57cGFyYW1zOnttb2JpbGVuZXR2MTppLHByZWRpY3Rpb25fbGF5ZXI6byxvdXRwdXRfbGF5ZXI6dX0scGFyYW1NYXBwaW5nczp0fX1mdW5jdGlvbiB0Z2UoZSx0KXtsZXQgbj1zYShlLHQpO2Z1bmN0aW9uIGEodSxwLGQpe2xldCBjPW4oYCR7dX0vQ29udjJkXyR7cH1fcG9pbnR3aXNlL3dlaWdodHNgLDQsYCR7ZH0vZmlsdGVyc2ApLGg9bihgJHt1fS9Db252MmRfJHtwfV9wb2ludHdpc2UvY29udm9sdXRpb25fYm5fb2Zmc2V0YCwxLGAke2R9L2JhdGNoX25vcm1fb2Zmc2V0YCk7cmV0dXJue2ZpbHRlcnM6YyxiYXRjaF9ub3JtX29mZnNldDpofX1mdW5jdGlvbiByKHUpe2xldCBwPWBtb2JpbGVuZXR2MS9jb252XyR7dX1gLGQ9YE1vYmlsZW5ldFYxL0NvbnYyZF8ke3V9X2RlcHRod2lzZWAsYz1gJHtwfS9kZXB0aHdpc2VfY29udmAsaD1gJHtwfS9wb2ludHdpc2VfY29udmAsbT1uKGAke2R9L2RlcHRod2lzZV93ZWlnaHRzYCw0LGAke2N9L2ZpbHRlcnNgKSxmPW4oYCR7ZH0vQmF0Y2hOb3JtL2dhbW1hYCwxLGAke2N9L2JhdGNoX25vcm1fc2NhbGVgKSxnPW4oYCR7ZH0vQmF0Y2hOb3JtL2JldGFgLDEsYCR7Y30vYmF0Y2hfbm9ybV9vZmZzZXRgKSxiPW4oYCR7ZH0vQmF0Y2hOb3JtL21vdmluZ19tZWFuYCwxLGAke2N9L2JhdGNoX25vcm1fbWVhbmApLHk9bihgJHtkfS9CYXRjaE5vcm0vbW92aW5nX3ZhcmlhbmNlYCwxLGAke2N9L2JhdGNoX25vcm1fdmFyaWFuY2VgKTtyZXR1cm57ZGVwdGh3aXNlX2NvbnY6e2ZpbHRlcnM6bSxiYXRjaF9ub3JtX3NjYWxlOmYsYmF0Y2hfbm9ybV9vZmZzZXQ6ZyxiYXRjaF9ub3JtX21lYW46YixiYXRjaF9ub3JtX3ZhcmlhbmNlOnl9LHBvaW50d2lzZV9jb252OmEoXCJNb2JpbGVuZXRWMVwiLHUsaCl9fWZ1bmN0aW9uIHMoKXtyZXR1cm57Y29udl8wOmEoXCJNb2JpbGVuZXRWMVwiLDAsXCJtb2JpbGVuZXR2MS9jb252XzBcIiksY29udl8xOnIoMSksY29udl8yOnIoMiksY29udl8zOnIoMyksY29udl80OnIoNCksY29udl81OnIoNSksY29udl82OnIoNiksY29udl83OnIoNyksY29udl84OnIoOCksY29udl85OnIoOSksY29udl8xMDpyKDEwKSxjb252XzExOnIoMTEpLGNvbnZfMTI6cigxMiksY29udl8xMzpyKDEzKX19ZnVuY3Rpb24gaSh1LHApe2xldCBkPW4oYCR7dX0vd2VpZ2h0c2AsNCxgJHtwfS9maWx0ZXJzYCksYz1uKGAke3V9L2JpYXNlc2AsMSxgJHtwfS9iaWFzYCk7cmV0dXJue2ZpbHRlcnM6ZCxiaWFzOmN9fWZ1bmN0aW9uIG8odSl7bGV0IHA9aShgUHJlZGljdGlvbi9Cb3hQcmVkaWN0b3JfJHt1fS9Cb3hFbmNvZGluZ1ByZWRpY3RvcmAsYHByZWRpY3Rpb25fbGF5ZXIvYm94X3ByZWRpY3Rvcl8ke3V9L2JveF9lbmNvZGluZ19wcmVkaWN0b3JgKSxkPWkoYFByZWRpY3Rpb24vQm94UHJlZGljdG9yXyR7dX0vQ2xhc3NQcmVkaWN0b3JgLGBwcmVkaWN0aW9uX2xheWVyL2JveF9wcmVkaWN0b3JfJHt1fS9jbGFzc19wcmVkaWN0b3JgKTtyZXR1cm57Ym94X2VuY29kaW5nX3ByZWRpY3RvcjpwLGNsYXNzX3ByZWRpY3RvcjpkfX1mdW5jdGlvbiBsKCl7cmV0dXJue2NvbnZfMDphKFwiUHJlZGljdGlvblwiLDAsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfMFwiKSxjb252XzE6YShcIlByZWRpY3Rpb25cIiwxLFwicHJlZGljdGlvbl9sYXllci9jb252XzFcIiksY29udl8yOmEoXCJQcmVkaWN0aW9uXCIsMixcInByZWRpY3Rpb25fbGF5ZXIvY29udl8yXCIpLGNvbnZfMzphKFwiUHJlZGljdGlvblwiLDMsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfM1wiKSxjb252XzQ6YShcIlByZWRpY3Rpb25cIiw0LFwicHJlZGljdGlvbl9sYXllci9jb252XzRcIiksY29udl81OmEoXCJQcmVkaWN0aW9uXCIsNSxcInByZWRpY3Rpb25fbGF5ZXIvY29udl81XCIpLGNvbnZfNjphKFwiUHJlZGljdGlvblwiLDYsXCJwcmVkaWN0aW9uX2xheWVyL2NvbnZfNlwiKSxjb252Xzc6YShcIlByZWRpY3Rpb25cIiw3LFwicHJlZGljdGlvbl9sYXllci9jb252XzdcIiksYm94X3ByZWRpY3Rvcl8wOm8oMCksYm94X3ByZWRpY3Rvcl8xOm8oMSksYm94X3ByZWRpY3Rvcl8yOm8oMiksYm94X3ByZWRpY3Rvcl8zOm8oMyksYm94X3ByZWRpY3Rvcl80Om8oNCksYm94X3ByZWRpY3Rvcl81Om8oNSl9fXJldHVybntleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXM6cyxleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zOmx9fWZ1bmN0aW9uIHdEKGUpe2xldCB0PVtdLHtleHRyYWN0TW9iaWxlbmV0VjFQYXJhbXM6bixleHRyYWN0UHJlZGljdGlvbkxheWVyUGFyYW1zOmF9PXRnZShlLHQpLHI9ZVtcIk91dHB1dC9leHRyYV9kaW1cIl07aWYodC5wdXNoKHtvcmlnaW5hbFBhdGg6XCJPdXRwdXQvZXh0cmFfZGltXCIscGFyYW1QYXRoOlwib3V0cHV0X2xheWVyL2V4dHJhX2RpbVwifSksIUxyKHIpKXRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgd2VpZ2h0TWFwWydPdXRwdXQvZXh0cmFfZGltJ10gdG8gYmUgYSBUZW5zb3IzRCwgaW5zdGVhZCBoYXZlICR7cn1gKTtsZXQgcz17bW9iaWxlbmV0djE6bigpLHByZWRpY3Rpb25fbGF5ZXI6YSgpLG91dHB1dF9sYXllcjp7ZXh0cmFfZGltOnJ9fTtyZXR1cm4gX24oZSx0KSx7cGFyYW1zOnMscGFyYW1NYXBwaW5nczp0fX1mdW5jdGlvbiBSYShlLHQsbil7cmV0dXJuIE8oKCk9PntsZXQgYT0kdChlLHQuZmlsdGVycyxuLFwic2FtZVwiKTtyZXR1cm4gYT1YKGEsdC5iYXRjaF9ub3JtX29mZnNldCksYW4oYSwwLDYpfSl9dmFyIG5nZT0uMDAxMDAwMDAwMDQ3NDk3NDUxMztmdW5jdGlvbiBhZ2UoZSx0LG4pe3JldHVybiBPKCgpPT57bGV0IGE9VHMoZSx0LmZpbHRlcnMsbixcInNhbWVcIik7cmV0dXJuIGE9TnMoYSx0LmJhdGNoX25vcm1fbWVhbix0LmJhdGNoX25vcm1fdmFyaWFuY2UsdC5iYXRjaF9ub3JtX29mZnNldCx0LmJhdGNoX25vcm1fc2NhbGUsbmdlKSxhbihhLDAsNil9KX1mdW5jdGlvbiByZ2UoZSl7cmV0dXJuWzIsNCw2LDEyXS5zb21lKHQ9PnQ9PT1lKT9bMiwyXTpbMSwxXX1mdW5jdGlvbiBrRChlLHQpe3JldHVybiBPKCgpPT57bGV0IG4sYT1SYShlLHQuY29udl8wLFsyLDJdKTtpZihbdC5jb252XzEsdC5jb252XzIsdC5jb252XzMsdC5jb252XzQsdC5jb252XzUsdC5jb252XzYsdC5jb252XzcsdC5jb252XzgsdC5jb252XzksdC5jb252XzEwLHQuY29udl8xMSx0LmNvbnZfMTIsdC5jb252XzEzXS5mb3JFYWNoKChzLGkpPT57bGV0IG89aSsxLGw9cmdlKG8pO2E9YWdlKGEscy5kZXB0aHdpc2VfY29udixsKSxhPVJhKGEscy5wb2ludHdpc2VfY29udixbMSwxXSksbz09PTExJiYobj1hKX0pLG49PT1udWxsKXRocm93IG5ldyBFcnJvcihcIm1vYmlsZU5ldFYxIC0gb3V0cHV0IG9mIGNvbnYgbGF5ZXIgMTEgaXMgbnVsbFwiKTtyZXR1cm57b3V0OmEsY29udjExOm59fSl9ZnVuY3Rpb24gc2dlKGUsdCxuKXtsZXQgYT1lLmFycmF5U3luYygpLHI9TWF0aC5taW4oYVt0XVswXSxhW3RdWzJdKSxzPU1hdGgubWluKGFbdF1bMV0sYVt0XVszXSksaT1NYXRoLm1heChhW3RdWzBdLGFbdF1bMl0pLG89TWF0aC5tYXgoYVt0XVsxXSxhW3RdWzNdKSxsPU1hdGgubWluKGFbbl1bMF0sYVtuXVsyXSksdT1NYXRoLm1pbihhW25dWzFdLGFbbl1bM10pLHA9TWF0aC5tYXgoYVtuXVswXSxhW25dWzJdKSxkPU1hdGgubWF4KGFbbl1bMV0sYVtuXVszXSksYz0oaS1yKSooby1zKSxoPShwLWwpKihkLXUpO2lmKGM8PTB8fGg8PTApcmV0dXJuIDA7bGV0IG09TWF0aC5tYXgocixsKSxmPU1hdGgubWF4KHMsdSksZz1NYXRoLm1pbihpLHApLGI9TWF0aC5taW4obyxkKSx5PU1hdGgubWF4KGctbSwwKSpNYXRoLm1heChiLWYsMCk7cmV0dXJuIHkvKGMraC15KX1mdW5jdGlvbiBJRChlLHQsbixhLHIpe2xldCBzPWUuc2hhcGVbMF0saT1NYXRoLm1pbihuLHMpLG89dC5tYXAoKHAsZCk9Pih7c2NvcmU6cCxib3hJbmRleDpkfSkpLmZpbHRlcihwPT5wLnNjb3JlPnIpLnNvcnQoKHAsZCk9PmQuc2NvcmUtcC5zY29yZSksbD1wPT5wPD1hPzE6MCx1PVtdO3JldHVybiBvLmZvckVhY2gocD0+e2lmKHUubGVuZ3RoPj1pKXJldHVybjtsZXQgZD1wLnNjb3JlO2ZvcihsZXQgYz11Lmxlbmd0aC0xO2M+PTA7LS1jKXtsZXQgaD1zZ2UoZSxwLmJveEluZGV4LHVbY10pO2lmKGghPT0wJiYocC5zY29yZSo9bChoKSxwLnNjb3JlPD1yKSlicmVha31kPT09cC5zY29yZSYmdS5wdXNoKHAuYm94SW5kZXgpfSksdX1mdW5jdGlvbiBpZ2UoZSl7bGV0IHQ9ZHQoRGUoZSxbMSwwXSkpLG49W3BlKHRbMl0sdFswXSkscGUodFszXSx0WzFdKV0sYT1bWCh0WzBdLGhlKG5bMF0sMikpLFgodFsxXSxoZShuWzFdLDIpKV07cmV0dXJue3NpemVzOm4sY2VudGVyczphfX1mdW5jdGlvbiBvZ2UoZSx0KXtsZXR7c2l6ZXM6bixjZW50ZXJzOmF9PWlnZShlKSxyPWR0KERlKHQsWzEsMF0pKSxzPWhlKHooZG4oaGUoclsyXSw1KSksblswXSksMiksaT1YKHooaGUoclswXSwxMCksblswXSksYVswXSksbz1oZSh6KGRuKGhlKHJbM10sNSkpLG5bMV0pLDIpLGw9WCh6KGhlKHJbMV0sMTApLG5bMV0pLGFbMV0pO3JldHVybiBEZShBdChbcGUoaSxzKSxwZShsLG8pLFgoaSxzKSxYKGwsbyldKSxbMSwwXSl9ZnVuY3Rpb24gU0QoZSx0LG4pe3JldHVybiBPKCgpPT57bGV0IGE9ZS5zaGFwZVswXSxyPW9nZShXKE9uKG4uZXh0cmFfZGltLFthLDEsMV0pLFstMSw0XSksVyhlLFstMSw0XSkpO3I9VyhyLFthLHIuc2hhcGVbMF0vYSw0XSk7bGV0IHM9aGEoVmUodCxbMCwwLDFdLFstMSwtMSwtMV0pKSxpPVZlKHMsWzAsMCwwXSxbLTEsLTEsMV0pO2k9VyhpLFthLGkuc2hhcGVbMV1dKTtsZXQgbz1kdChyKSxsPWR0KGkpO3JldHVybntib3hlczpvLHNjb3JlczpsfX0pfWZ1bmN0aW9uIG9sKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj1lLnNoYXBlWzBdLGE9VyhpbChlLHQuYm94X2VuY29kaW5nX3ByZWRpY3RvciksW24sLTEsMSw0XSkscj1XKGlsKGUsdC5jbGFzc19wcmVkaWN0b3IpLFtuLC0xLDNdKTtyZXR1cm57Ym94UHJlZGljdGlvbkVuY29kaW5nOmEsY2xhc3NQcmVkaWN0aW9uOnJ9fSl9ZnVuY3Rpb24gTkQoZSx0LG4pe3JldHVybiBPKCgpPT57bGV0IGE9UmEoZSxuLmNvbnZfMCxbMSwxXSkscj1SYShhLG4uY29udl8xLFsyLDJdKSxzPVJhKHIsbi5jb252XzIsWzEsMV0pLGk9UmEocyxuLmNvbnZfMyxbMiwyXSksbz1SYShpLG4uY29udl80LFsxLDFdKSxsPVJhKG8sbi5jb252XzUsWzIsMl0pLHU9UmEobCxuLmNvbnZfNixbMSwxXSkscD1SYSh1LG4uY29udl83LFsyLDJdKSxkPW9sKHQsbi5ib3hfcHJlZGljdG9yXzApLGM9b2woZSxuLmJveF9wcmVkaWN0b3JfMSksaD1vbChyLG4uYm94X3ByZWRpY3Rvcl8yKSxtPW9sKGksbi5ib3hfcHJlZGljdG9yXzMpLGY9b2wobCxuLmJveF9wcmVkaWN0b3JfNCksZz1vbChwLG4uYm94X3ByZWRpY3Rvcl81KSxiPWV0KFtkLmJveFByZWRpY3Rpb25FbmNvZGluZyxjLmJveFByZWRpY3Rpb25FbmNvZGluZyxoLmJveFByZWRpY3Rpb25FbmNvZGluZyxtLmJveFByZWRpY3Rpb25FbmNvZGluZyxmLmJveFByZWRpY3Rpb25FbmNvZGluZyxnLmJveFByZWRpY3Rpb25FbmNvZGluZ10sMSkseT1ldChbZC5jbGFzc1ByZWRpY3Rpb24sYy5jbGFzc1ByZWRpY3Rpb24saC5jbGFzc1ByZWRpY3Rpb24sbS5jbGFzc1ByZWRpY3Rpb24sZi5jbGFzc1ByZWRpY3Rpb24sZy5jbGFzc1ByZWRpY3Rpb25dLDEpO3JldHVybntib3hQcmVkaWN0aW9uczpiLGNsYXNzUHJlZGljdGlvbnM6eX19KX12YXIgTWE9Y2xhc3N7Y29uc3RydWN0b3Ioe21pbkNvbmZpZGVuY2U6dCxtYXhSZXN1bHRzOm59PXt9KXt0aGlzLl9uYW1lPVwiU3NkTW9iaWxlbmV0djFPcHRpb25zXCI7aWYodGhpcy5fbWluQ29uZmlkZW5jZT10fHwuNSx0aGlzLl9tYXhSZXN1bHRzPW58fDEwMCx0eXBlb2YgdGhpcy5fbWluQ29uZmlkZW5jZSE9XCJudW1iZXJcInx8dGhpcy5fbWluQ29uZmlkZW5jZTw9MHx8dGhpcy5fbWluQ29uZmlkZW5jZT49MSl0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fbmFtZX0gLSBleHBlY3RlZCBtaW5Db25maWRlbmNlIHRvIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMWApO2lmKHR5cGVvZiB0aGlzLl9tYXhSZXN1bHRzIT1cIm51bWJlclwiKXRocm93IG5ldyBFcnJvcihgJHt0aGlzLl9uYW1lfSAtIGV4cGVjdGVkIG1heFJlc3VsdHMgdG8gYmUgYSBudW1iZXJgKX1nZXQgbWluQ29uZmlkZW5jZSgpe3JldHVybiB0aGlzLl9taW5Db25maWRlbmNlfWdldCBtYXhSZXN1bHRzKCl7cmV0dXJuIHRoaXMuX21heFJlc3VsdHN9fTt2YXIgbGw9Y2xhc3MgZXh0ZW5kcyBmbntjb25zdHJ1Y3Rvcigpe3N1cGVyKFwiU3NkTW9iaWxlbmV0djFcIil9Zm9yd2FyZElucHV0KHQpe2xldHtwYXJhbXM6bn09dGhpcztpZighbil0aHJvdyBuZXcgRXJyb3IoXCJTc2RNb2JpbGVuZXR2MSAtIGxvYWQgbW9kZWwgYmVmb3JlIGluZmVyZW5jZVwiKTtyZXR1cm4gTygoKT0+e2xldCBhPXJlKHQudG9CYXRjaFRlbnNvcig1MTIsITEpLFwiZmxvYXQzMlwiKSxyPXBlKGhlKGEsMTI3LjUpLDEpLHM9a0QocixuLm1vYmlsZW5ldHYxKSx7Ym94UHJlZGljdGlvbnM6aSxjbGFzc1ByZWRpY3Rpb25zOm99PU5EKHMub3V0LHMuY29udjExLG4ucHJlZGljdGlvbl9sYXllcik7cmV0dXJuIFNEKGksbyxuLm91dHB1dF9sYXllcil9KX1hc3luYyBmb3J3YXJkKHQpe3JldHVybiB0aGlzLmZvcndhcmRJbnB1dChhd2FpdCB2dCh0KSl9YXN5bmMgbG9jYXRlRmFjZXModCxuPXt9KXtsZXR7bWF4UmVzdWx0czphLG1pbkNvbmZpZGVuY2U6cn09bmV3IE1hKG4pLHM9YXdhaXQgdnQodCkse2JveGVzOmksc2NvcmVzOm99PXRoaXMuZm9yd2FyZElucHV0KHMpLGw9aVswXSx1PW9bMF07Zm9yKGxldCB4PTE7eDxpLmxlbmd0aDt4KyspaVt4XS5kaXNwb3NlKCksb1t4XS5kaXNwb3NlKCk7bGV0IHA9QXJyYXkuZnJvbSh1LmRhdGFTeW5jKCkpLGM9SUQobCxwLGEsLjUsciksaD1zLmdldFJlc2hhcGVkSW5wdXREaW1lbnNpb25zKDApLG09cy5pbnB1dFNpemUsZj1tL2gud2lkdGgsZz1tL2guaGVpZ2h0LGI9bC5hcnJheVN5bmMoKSx5PWMubWFwKHg9PntsZXRbdixJXT1bTWF0aC5tYXgoMCxiW3hdWzBdKSxNYXRoLm1pbigxLGJbeF1bMl0pXS5tYXAoXz0+XypnKSxbTixDXT1bTWF0aC5tYXgoMCxiW3hdWzFdKSxNYXRoLm1pbigxLGJbeF1bM10pXS5tYXAoXz0+XypmKTtyZXR1cm4gbmV3IEZ0KHBbeF0sbmV3IHhwKE4sdixDLU4sSS12KSx7aGVpZ2h0OnMuZ2V0SW5wdXRIZWlnaHQoMCksd2lkdGg6cy5nZXRJbnB1dFdpZHRoKDApfSl9KTtyZXR1cm4gbC5kaXNwb3NlKCksdS5kaXNwb3NlKCkseX1nZXREZWZhdWx0TW9kZWxOYW1lKCl7cmV0dXJuXCJzc2RfbW9iaWxlbmV0djFfbW9kZWxcIn1leHRyYWN0UGFyYW1zRnJvbVdlaWdodE1hcCh0KXtyZXR1cm4gd0QodCl9ZXh0cmFjdFBhcmFtcyh0KXtyZXR1cm4gdkQodCl9fTtmdW5jdGlvbiBsZ2UoZSl7bGV0IHQ9bmV3IGxsO3JldHVybiB0LmV4dHJhY3RXZWlnaHRzKGUpLHR9ZnVuY3Rpb24gWUNlKGUpe3JldHVybiBsZ2UoZSl9dmFyIFREPWNsYXNzIGV4dGVuZHMgbGx7fTt2YXIgQ0Q9LjQsRUQ9W25ldyBIZSguNzM4NzY4LC44NzQ5NDYpLG5ldyBIZSgyLjQyMjA0LDIuNjU3MDQpLG5ldyBIZSg0LjMwOTcxLDcuMDQ0OTMpLG5ldyBIZSgxMC4yNDYsNC41OTQyOCksbmV3IEhlKDEyLjY4NjgsMTEuODc0MSldLF9EPVtuZXcgSGUoMS42MDMyMzEsMi4wOTQ0NjgpLG5ldyBIZSg2LjA0MTE0Myw3LjA4MDEyNiksbmV3IEhlKDIuODgyNDU5LDMuNTE4MDYxKSxuZXcgSGUoNC4yNjY5MDYsNS4xNzg4NTcpLG5ldyBIZSg5LjA0MTc2NSwxMC42NjMwOCldLEFEPVsxMTcuMDAxLDExNC42OTcsOTcuNDA0XSxGRD1cInRpbnlfeW9sb3YyX21vZGVsXCIsJEQ9XCJ0aW55X3lvbG92Ml9zZXBhcmFibGVfY29udl9tb2RlbFwiO3ZhciBoZz1lPT50eXBlb2YgZT09XCJudW1iZXJcIjtmdW5jdGlvbiBERChlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29uZmlnOiAke2V9YCk7aWYodHlwZW9mIGUud2l0aFNlcGFyYWJsZUNvbnZzIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYGNvbmZpZy53aXRoU2VwYXJhYmxlQ29udnMgaGFzIHRvIGJlIGEgYm9vbGVhbiwgaGF2ZTogJHtlLndpdGhTZXBhcmFibGVDb252c31gKTtpZighaGcoZS5pb3VUaHJlc2hvbGQpfHxlLmlvdVRocmVzaG9sZDwwfHxlLmlvdVRocmVzaG9sZD4xKXRocm93IG5ldyBFcnJvcihgY29uZmlnLmlvdVRocmVzaG9sZCBoYXMgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiBbMCwgMV0sIGhhdmU6ICR7ZS5pb3VUaHJlc2hvbGR9YCk7aWYoIUFycmF5LmlzQXJyYXkoZS5jbGFzc2VzKXx8IWUuY2xhc3Nlcy5sZW5ndGh8fCFlLmNsYXNzZXMuZXZlcnkodD0+dHlwZW9mIHQ9PVwic3RyaW5nXCIpKXRocm93IG5ldyBFcnJvcihgY29uZmlnLmNsYXNzZXMgaGFzIHRvIGJlIGFuIGFycmF5IGNsYXNzIG5hbWVzOiBzdHJpbmdbXSwgaGF2ZTogJHtKU09OLnN0cmluZ2lmeShlLmNsYXNzZXMpfWApO2lmKCFBcnJheS5pc0FycmF5KGUuYW5jaG9ycyl8fCFlLmFuY2hvcnMubGVuZ3RofHwhZS5hbmNob3JzLm1hcCh0PT50fHx7fSkuZXZlcnkodD0+aGcodC54KSYmaGcodC55KSkpdGhyb3cgbmV3IEVycm9yKGBjb25maWcuYW5jaG9ycyBoYXMgdG8gYmUgYW4gYXJyYXkgb2YgeyB4OiBudW1iZXIsIHk6IG51bWJlciB9LCBoYXZlOiAke0pTT04uc3RyaW5naWZ5KGUuYW5jaG9ycyl9YCk7aWYoZS5tZWFuUmdiJiYoIUFycmF5LmlzQXJyYXkoZS5tZWFuUmdiKXx8ZS5tZWFuUmdiLmxlbmd0aCE9PTN8fCFlLm1lYW5SZ2IuZXZlcnkoaGcpKSl0aHJvdyBuZXcgRXJyb3IoYGNvbmZpZy5tZWFuUmdiIGhhcyB0byBiZSBhbiBhcnJheSBvZiBzaGFwZSBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGhhdmU6ICR7SlNPTi5zdHJpbmdpZnkoZS5tZWFuUmdiKX1gKX1mdW5jdGlvbiBNcChlKXtyZXR1cm4gTygoKT0+e2xldCB0PXooZSx4ZSguMTAwMDAwMDAxNDkwMTE2MTIpKTtyZXR1cm4gWChLZShwZShlLHQpKSx0KX0pfWZ1bmN0aW9uIEJyKGUsdCl7cmV0dXJuIE8oKCk9PntsZXQgbj14YShlLFtbMCwwXSxbMSwxXSxbMSwxXSxbMCwwXV0pO3JldHVybiBuPSR0KG4sdC5jb252LmZpbHRlcnMsWzEsMV0sXCJ2YWxpZFwiKSxuPXBlKG4sdC5ibi5zdWIpLG49eihuLHQuYm4udHJ1ZWRpdiksbj1YKG4sdC5jb252LmJpYXMpLE1wKG4pfSl9ZnVuY3Rpb24gVnIoZSx0KXtyZXR1cm4gTygoKT0+e2xldCBuPXhhKGUsW1swLDBdLFsxLDFdLFsxLDFdLFswLDBdXSk7cmV0dXJuIG49X3Mobix0LmRlcHRod2lzZV9maWx0ZXIsdC5wb2ludHdpc2VfZmlsdGVyLFsxLDFdLFwidmFsaWRcIiksbj1YKG4sdC5iaWFzKSxNcChuKX0pfWZ1bmN0aW9uIHVnZShlLHQpe2xldCBuPVRwKGUsdCk7ZnVuY3Rpb24gYShpLG8pe2xldCBsPWplKGUoaSkpLHU9amUoZShpKSk7cmV0dXJuIHQucHVzaCh7cGFyYW1QYXRoOmAke299L3N1YmB9LHtwYXJhbVBhdGg6YCR7b30vdHJ1ZWRpdmB9KSx7c3ViOmwsdHJ1ZWRpdjp1fX1mdW5jdGlvbiByKGksbyxsKXtsZXQgdT1uKGksbywzLGAke2x9L2NvbnZgKSxwPWEobyxgJHtsfS9ibmApO3JldHVybntjb252OnUsYm46cH19bGV0IHM9Q3AoZSx0KTtyZXR1cm57ZXh0cmFjdENvbnZQYXJhbXM6bixleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXM6cixleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczpzfX1mdW5jdGlvbiBSRChlLHQsbixhKXtsZXR7ZXh0cmFjdFdlaWdodHM6cixnZXRSZW1haW5pbmdXZWlnaHRzOnN9PUFuKGUpLGk9W10se2V4dHJhY3RDb252UGFyYW1zOm8sZXh0cmFjdENvbnZXaXRoQmF0Y2hOb3JtUGFyYW1zOmwsZXh0cmFjdFNlcGFyYWJsZUNvbnZQYXJhbXM6dX09dWdlKHIsaSkscDtpZih0LndpdGhTZXBhcmFibGVDb252cyl7bGV0W2QsYyxoLG0sZixnLGIseSx4XT1hLHY9dC5pc0ZpcnN0TGF5ZXJDb252MmQ/byhkLGMsMyxcImNvbnYwXCIpOnUoZCxjLFwiY29udjBcIiksST11KGMsaCxcImNvbnYxXCIpLE49dShoLG0sXCJjb252MlwiKSxDPXUobSxmLFwiY29udjNcIiksXz11KGYsZyxcImNvbnY0XCIpLEY9dShnLGIsXCJjb252NVwiKSxEPXk/dShiLHksXCJjb252NlwiKTp2b2lkIDAsJD14P3UoeSx4LFwiY29udjdcIik6dm9pZCAwLFM9byh4fHx5fHxiLDUqbiwxLFwiY29udjhcIik7cD17Y29udjA6dixjb252MTpJLGNvbnYyOk4sY29udjM6Qyxjb252NDpfLGNvbnY1OkYsY29udjY6RCxjb252NzokLGNvbnY4OlN9fWVsc2V7bGV0W2QsYyxoLG0sZixnLGIseSx4XT1hLHY9bChkLGMsXCJjb252MFwiKSxJPWwoYyxoLFwiY29udjFcIiksTj1sKGgsbSxcImNvbnYyXCIpLEM9bChtLGYsXCJjb252M1wiKSxfPWwoZixnLFwiY29udjRcIiksRj1sKGcsYixcImNvbnY1XCIpLEQ9bChiLHksXCJjb252NlwiKSwkPWwoeSx4LFwiY29udjdcIiksUz1vKHgsNSpuLDEsXCJjb252OFwiKTtwPXtjb252MDp2LGNvbnYxOkksY29udjI6Tixjb252MzpDLGNvbnY0Ol8sY29udjU6Rixjb252NjpELGNvbnY3OiQsY29udjg6U319aWYocygpLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGB3ZWlnaHRzIHJlbWFpbmcgYWZ0ZXIgZXh0cmFjdDogJHtzKCkubGVuZ3RofWApO3JldHVybntwYXJhbXM6cCxwYXJhbU1hcHBpbmdzOml9fWZ1bmN0aW9uIHBnZShlLHQpe2xldCBuPXNhKGUsdCk7ZnVuY3Rpb24gYShvKXtsZXQgbD1uKGAke299L3N1YmAsMSksdT1uKGAke299L3RydWVkaXZgLDEpO3JldHVybntzdWI6bCx0cnVlZGl2OnV9fWZ1bmN0aW9uIHIobyl7bGV0IGw9bihgJHtvfS9maWx0ZXJzYCw0KSx1PW4oYCR7b30vYmlhc2AsMSk7cmV0dXJue2ZpbHRlcnM6bCxiaWFzOnV9fWZ1bmN0aW9uIHMobyl7bGV0IGw9cihgJHtvfS9jb252YCksdT1hKGAke299L2JuYCk7cmV0dXJue2NvbnY6bCxibjp1fX1sZXQgaT1FcChuKTtyZXR1cm57ZXh0cmFjdENvbnZQYXJhbXM6cixleHRyYWN0Q29udldpdGhCYXRjaE5vcm1QYXJhbXM6cyxleHRyYWN0U2VwYXJhYmxlQ29udlBhcmFtczppfX1mdW5jdGlvbiBNRChlLHQpe2xldCBuPVtdLHtleHRyYWN0Q29udlBhcmFtczphLGV4dHJhY3RDb252V2l0aEJhdGNoTm9ybVBhcmFtczpyLGV4dHJhY3RTZXBhcmFibGVDb252UGFyYW1zOnN9PXBnZShlLG4pLGk7aWYodC53aXRoU2VwYXJhYmxlQ29udnMpe2xldCBvPXQuZmlsdGVyU2l6ZXMmJnQuZmlsdGVyU2l6ZXMubGVuZ3RofHw5O2k9e2NvbnYwOnQuaXNGaXJzdExheWVyQ29udjJkP2EoXCJjb252MFwiKTpzKFwiY29udjBcIiksY29udjE6cyhcImNvbnYxXCIpLGNvbnYyOnMoXCJjb252MlwiKSxjb252MzpzKFwiY29udjNcIiksY29udjQ6cyhcImNvbnY0XCIpLGNvbnY1OnMoXCJjb252NVwiKSxjb252NjpvPjc/cyhcImNvbnY2XCIpOnZvaWQgMCxjb252NzpvPjg/cyhcImNvbnY3XCIpOnZvaWQgMCxjb252ODphKFwiY29udjhcIil9fWVsc2UgaT17Y29udjA6cihcImNvbnYwXCIpLGNvbnYxOnIoXCJjb252MVwiKSxjb252MjpyKFwiY29udjJcIiksY29udjM6cihcImNvbnYzXCIpLGNvbnY0OnIoXCJjb252NFwiKSxjb252NTpyKFwiY29udjVcIiksY29udjY6cihcImNvbnY2XCIpLGNvbnY3OnIoXCJjb252N1wiKSxjb252ODphKFwiY29udjhcIil9O3JldHVybiBfbihlLG4pLHtwYXJhbXM6aSxwYXJhbU1hcHBpbmdzOm59fXZhciB5cj1jbGFzc3tjb25zdHJ1Y3Rvcih7aW5wdXRTaXplOnQsc2NvcmVUaHJlc2hvbGQ6bn09e30pe3RoaXMuX25hbWU9XCJUaW55WW9sb3YyT3B0aW9uc1wiO2lmKHRoaXMuX2lucHV0U2l6ZT10fHw0MTYsdGhpcy5fc2NvcmVUaHJlc2hvbGQ9bnx8LjUsdHlwZW9mIHRoaXMuX2lucHV0U2l6ZSE9XCJudW1iZXJcInx8dGhpcy5faW5wdXRTaXplJTMyIT09MCl0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5fbmFtZX0gLSBleHBlY3RlZCBpbnB1dFNpemUgdG8gYmUgYSBudW1iZXIgZGl2aXNpYmxlIGJ5IDMyYCk7aWYodHlwZW9mIHRoaXMuX3Njb3JlVGhyZXNob2xkIT1cIm51bWJlclwifHx0aGlzLl9zY29yZVRocmVzaG9sZDw9MHx8dGhpcy5fc2NvcmVUaHJlc2hvbGQ+PTEpdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuX25hbWV9IC0gZXhwZWN0ZWQgc2NvcmVUaHJlc2hvbGQgdG8gYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxYCl9Z2V0IGlucHV0U2l6ZSgpe3JldHVybiB0aGlzLl9pbnB1dFNpemV9Z2V0IHNjb3JlVGhyZXNob2xkKCl7cmV0dXJuIHRoaXMuX3Njb3JlVGhyZXNob2xkfX07dmFyIG1nPWNsYXNzIG1nIGV4dGVuZHMgZm57Y29uc3RydWN0b3IodCl7c3VwZXIoXCJUaW55WW9sb3YyXCIpLEREKHQpLHRoaXMuX2NvbmZpZz10fWdldCBjb25maWcoKXtyZXR1cm4gdGhpcy5fY29uZmlnfWdldCB3aXRoQ2xhc3NTY29yZXMoKXtyZXR1cm4gdGhpcy5jb25maWcud2l0aENsYXNzU2NvcmVzfHx0aGlzLmNvbmZpZy5jbGFzc2VzLmxlbmd0aD4xfWdldCBib3hFbmNvZGluZ1NpemUoKXtyZXR1cm4gNSsodGhpcy53aXRoQ2xhc3NTY29yZXM/dGhpcy5jb25maWcuY2xhc3Nlcy5sZW5ndGg6MCl9cnVuVGlueVlvbG92Mih0LG4pe2xldCBhPUJyKHQsbi5jb252MCk7cmV0dXJuIGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1CcihhLG4uY29udjEpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1CcihhLG4uY29udjIpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1CcihhLG4uY29udjMpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1CcihhLG4uY29udjQpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1CcihhLG4uY29udjUpLGE9RHQoYSxbMiwyXSxbMSwxXSxcInNhbWVcIiksYT1CcihhLG4uY29udjYpLGE9QnIoYSxuLmNvbnY3KSxpbChhLG4uY29udjgsXCJ2YWxpZFwiLCExKX1ydW5Nb2JpbGVuZXQodCxuKXtsZXQgYT10aGlzLmNvbmZpZy5pc0ZpcnN0TGF5ZXJDb252MmQ/TXAoaWwodCxuLmNvbnYwLFwidmFsaWRcIiwhMSkpOlZyKHQsbi5jb252MCk7cmV0dXJuIGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1WcihhLG4uY29udjEpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1WcihhLG4uY29udjIpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1WcihhLG4uY29udjMpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1WcihhLG4uY29udjQpLGE9RHQoYSxbMiwyXSxbMiwyXSxcInNhbWVcIiksYT1WcihhLG4uY29udjUpLGE9RHQoYSxbMiwyXSxbMSwxXSxcInNhbWVcIiksYT1uLmNvbnY2P1ZyKGEsbi5jb252Nik6YSxhPW4uY29udjc/VnIoYSxuLmNvbnY3KTphLGlsKGEsbi5jb252OCxcInZhbGlkXCIsITEpfWZvcndhcmRJbnB1dCh0LG4pe2xldHtwYXJhbXM6YX09dGhpcztpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJUaW55WW9sb3YyIC0gbG9hZCBtb2RlbCBiZWZvcmUgaW5mZXJlbmNlXCIpO3JldHVybiBPKCgpPT57bGV0IHI9cmUodC50b0JhdGNoVGVuc29yKG4sITEpLFwiZmxvYXQzMlwiKTtyZXR1cm4gcj10aGlzLmNvbmZpZy5tZWFuUmdiP2JyKHIsdGhpcy5jb25maWcubWVhblJnYik6cixyPXIuZGl2KDI1NSksdGhpcy5jb25maWcud2l0aFNlcGFyYWJsZUNvbnZzP3RoaXMucnVuTW9iaWxlbmV0KHIsYSk6dGhpcy5ydW5UaW55WW9sb3YyKHIsYSl9KX1hc3luYyBmb3J3YXJkKHQsbil7cmV0dXJuIHRoaXMuZm9yd2FyZElucHV0KGF3YWl0IHZ0KHQpLG4pfWFzeW5jIGRldGVjdCh0LG49e30pe2xldHtpbnB1dFNpemU6YSxzY29yZVRocmVzaG9sZDpyfT1uZXcgeXIobikscz1hd2FpdCB2dCh0KSxpPWF3YWl0IHRoaXMuZm9yd2FyZElucHV0KHMsYSksbz1PKCgpPT5kdChpKVswXS5leHBhbmREaW1zKCkpLGw9e3dpZHRoOnMuZ2V0SW5wdXRXaWR0aCgwKSxoZWlnaHQ6cy5nZXRJbnB1dEhlaWdodCgwKX0sdT1hd2FpdCB0aGlzLmV4dHJhY3RCb3hlcyhvLHMuZ2V0UmVzaGFwZWRJbnB1dERpbWVuc2lvbnMoMCkscik7aS5kaXNwb3NlKCksby5kaXNwb3NlKCk7bGV0IHA9dS5tYXAoZz0+Zy5ib3gpLGQ9dS5tYXAoZz0+Zy5zY29yZSksYz11Lm1hcChnPT5nLmNsYXNzU2NvcmUpLGg9dS5tYXAoZz0+dGhpcy5jb25maWcuY2xhc3Nlc1tnLmxhYmVsXSk7cmV0dXJuIFUkKHAubWFwKGc9PmcucmVzY2FsZShhKSksZCx0aGlzLmNvbmZpZy5pb3VUaHJlc2hvbGQsITApLm1hcChnPT5uZXcgeXAoZFtnXSxjW2ddLGhbZ10scFtnXSxsKSl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVyblwiXCJ9ZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl7cmV0dXJuIE1EKHQsdGhpcy5jb25maWcpfWV4dHJhY3RQYXJhbXModCl7bGV0IG49dGhpcy5jb25maWcuZmlsdGVyU2l6ZXN8fG1nLkRFRkFVTFRfRklMVEVSX1NJWkVTLGE9bj9uLmxlbmd0aDp2b2lkIDA7aWYoYSE9PTcmJmEhPT04JiZhIT09OSl0aHJvdyBuZXcgRXJyb3IoYFRpbnlZb2xvdjIgLSBleHBlY3RlZCA3IHwgOCB8IDkgY29udm9sdXRpb25hbCBmaWx0ZXJzLCBidXQgZm91bmQgJHthfSBmaWx0ZXJTaXplcyBpbiBjb25maWdgKTtyZXR1cm4gUkQodCx0aGlzLmNvbmZpZyx0aGlzLmJveEVuY29kaW5nU2l6ZSxuKX1hc3luYyBleHRyYWN0Qm94ZXModCxuLGEpe2xldHt3aWR0aDpyLGhlaWdodDpzfT1uLGk9TWF0aC5tYXgocixzKSxvPWkvcixsPWkvcyx1PXQuc2hhcGVbMV0scD10aGlzLmNvbmZpZy5hbmNob3JzLmxlbmd0aCxbZCxjLGhdPU8oKCk9PntsZXQgYj10LnJlc2hhcGUoW3UsdSxwLHRoaXMuYm94RW5jb2RpbmdTaXplXSkseT1iLnNsaWNlKFswLDAsMCwwXSxbdSx1LHAsNF0pLHg9Yi5zbGljZShbMCwwLDAsNF0sW3UsdSxwLDFdKSx2PXRoaXMud2l0aENsYXNzU2NvcmVzP3FhKGIuc2xpY2UoWzAsMCwwLDVdLFt1LHUscCx0aGlzLmNvbmZpZy5jbGFzc2VzLmxlbmd0aF0pLDMpOnhlKDApO3JldHVyblt5LHgsdl19KSxtPVtdLGY9YXdhaXQgYy5hcnJheSgpLGc9YXdhaXQgZC5hcnJheSgpO2ZvcihsZXQgYj0wO2I8dTtiKyspZm9yKGxldCB5PTA7eTx1O3krKylmb3IobGV0IHg9MDt4PHA7eCsrKXtsZXQgdj1xZihmW2JdW3ldW3hdWzBdKTtpZighYXx8dj5hKXtsZXQgST0oeStxZihnW2JdW3ldW3hdWzBdKSkvdSpvLE49KGIrcWYoZ1tiXVt5XVt4XVsxXSkpL3UqbCxDPU1hdGguZXhwKGdbYl1beV1beF1bMl0pKnRoaXMuY29uZmlnLmFuY2hvcnNbeF0ueC91Km8sXz1NYXRoLmV4cChnW2JdW3ldW3hdWzNdKSp0aGlzLmNvbmZpZy5hbmNob3JzW3hdLnkvdSpsLEY9SS1DLzIsRD1OLV8vMiwkPXtyb3c6Yixjb2w6eSxhbmNob3I6eH0se2NsYXNzU2NvcmU6UyxsYWJlbDpNfT10aGlzLndpdGhDbGFzc1Njb3Jlcz9hd2FpdCB0aGlzLmV4dHJhY3RQcmVkaWN0ZWRDbGFzcyhoLCQpOntjbGFzc1Njb3JlOjEsbGFiZWw6MH07bS5wdXNoKHtib3g6bmV3IGJwKEYsRCxGK0MsRCtfKSxzY29yZTp2LGNsYXNzU2NvcmU6dipTLGxhYmVsOk0sLi4uJH0pfX1yZXR1cm4gZC5kaXNwb3NlKCksYy5kaXNwb3NlKCksaC5kaXNwb3NlKCksbX1hc3luYyBleHRyYWN0UHJlZGljdGVkQ2xhc3ModCxuKXtsZXR7cm93OmEsY29sOnIsYW5jaG9yOnN9PW4saT1hd2FpdCB0LmFycmF5KCk7cmV0dXJuIEFycmF5KHRoaXMuY29uZmlnLmNsYXNzZXMubGVuZ3RoKS5maWxsKDApLm1hcCgobyxsKT0+aVthXVtyXVtzXVtsXSkubWFwKChvLGwpPT4oe2NsYXNzU2NvcmU6byxsYWJlbDpsfSkpLnJlZHVjZSgobyxsKT0+by5jbGFzc1Njb3JlPmwuY2xhc3NTY29yZT9vOmwpfX07bWcuREVGQVVMVF9GSUxURVJfU0laRVM9WzMsMTYsMzIsNjQsMTI4LDI1Niw1MTIsMTAyNCwxMDI0XTt2YXIgT3A9bWc7dmFyIFBwPWNsYXNzIGV4dGVuZHMgT3B7Y29uc3RydWN0b3IodD0hMCl7bGV0IG49e3dpdGhTZXBhcmFibGVDb252czp0LGlvdVRocmVzaG9sZDpDRCxjbGFzc2VzOltcImZhY2VcIl0sLi4udD97YW5jaG9yczpfRCxtZWFuUmdiOkFEfTp7YW5jaG9yczpFRCx3aXRoQ2xhc3NTY29yZXM6ITB9fTtzdXBlcihuKX1nZXQgd2l0aFNlcGFyYWJsZUNvbnZzKCl7cmV0dXJuIHRoaXMuY29uZmlnLndpdGhTZXBhcmFibGVDb252c31nZXQgYW5jaG9ycygpe3JldHVybiB0aGlzLmNvbmZpZy5hbmNob3JzfWFzeW5jIGxvY2F0ZUZhY2VzKHQsbil7cmV0dXJuKGF3YWl0IHRoaXMuZGV0ZWN0KHQsbikpLm1hcChyPT5uZXcgRnQoci5zY29yZSxyLnJlbGF0aXZlQm94LHt3aWR0aDpyLmltYWdlV2lkdGgsaGVpZ2h0OnIuaW1hZ2VIZWlnaHR9KSl9Z2V0RGVmYXVsdE1vZGVsTmFtZSgpe3JldHVybiB0aGlzLndpdGhTZXBhcmFibGVDb252cz8kRDpGRH1leHRyYWN0UGFyYW1zRnJvbVdlaWdodE1hcCh0KXtyZXR1cm4gc3VwZXIuZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl9fTtmdW5jdGlvbiBCRWUoZSx0PSEwKXtsZXQgbj1uZXcgUHAodCk7cmV0dXJuIG4uZXh0cmFjdFdlaWdodHMoZSksbn12YXIgZmc9Y2xhc3MgZXh0ZW5kcyB5cntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyk7dGhpcy5fbmFtZT1cIlRpbnlGYWNlRGV0ZWN0b3JPcHRpb25zXCJ9fTt2YXIgT2E9Y2xhc3N7YXN5bmMgdGhlbih0KXtyZXR1cm4gdChhd2FpdCB0aGlzLnJ1bigpKX1hc3luYyBydW4oKXt0aHJvdyBuZXcgRXJyb3IoXCJDb21wb3NhYmxlVGFzayAtIHJ1biBpcyBub3QgaW1wbGVtZW50ZWRcIil9fTthc3luYyBmdW5jdGlvbiB1bChlLHQsbixhLHI9KHthbGlnbmVkUmVjdDpzfSk9PnMpe2xldCBzPWUubWFwKGw9PkZwKGwpP3IobCk6bC5kZXRlY3Rpb24pLGk9YXx8KHQgaW5zdGFuY2VvZiBDZT9hd2FpdCBMZCh0LHMpOmF3YWl0IFBkKHQscykpLG89YXdhaXQgbihpKTtyZXR1cm4gaS5mb3JFYWNoKGw9PmwgaW5zdGFuY2VvZiBDZSYmbC5kaXNwb3NlKCkpLG99YXN5bmMgZnVuY3Rpb24gTHAoZSx0LG4sYSxyKXtyZXR1cm4gdWwoW2VdLHQsYXN5bmMgcz0+bihzWzBdKSxhLHIpfXZhciBPRD0uNCxQRD1bbmV3IEhlKDEuNjAzMjMxLDIuMDk0NDY4KSxuZXcgSGUoNi4wNDExNDMsNy4wODAxMjYpLG5ldyBIZSgyLjg4MjQ1OSwzLjUxODA2MSksbmV3IEhlKDQuMjY2OTA2LDUuMTc4ODU3KSxuZXcgSGUoOS4wNDE3NjUsMTAuNjYzMDgpXSxMRD1bMTE3LjAwMSwxMTQuNjk3LDk3LjQwNF07dmFyIHpwPWNsYXNzIGV4dGVuZHMgT3B7Y29uc3RydWN0b3IoKXtsZXQgdD17d2l0aFNlcGFyYWJsZUNvbnZzOiEwLGlvdVRocmVzaG9sZDpPRCxjbGFzc2VzOltcImZhY2VcIl0sYW5jaG9yczpQRCxtZWFuUmdiOkxELGlzRmlyc3RMYXllckNvbnYyZDohMCxmaWx0ZXJTaXplczpbMywxNiwzMiw2NCwxMjgsMjU2LDUxMl19O3N1cGVyKHQpfWdldCBhbmNob3JzKCl7cmV0dXJuIHRoaXMuY29uZmlnLmFuY2hvcnN9YXN5bmMgbG9jYXRlRmFjZXModCxuKXtyZXR1cm4oYXdhaXQgdGhpcy5kZXRlY3QodCxuKSkubWFwKHI9Pm5ldyBGdChyLnNjb3JlLHIucmVsYXRpdmVCb3gse3dpZHRoOnIuaW1hZ2VXaWR0aCxoZWlnaHQ6ci5pbWFnZUhlaWdodH0pKX1nZXREZWZhdWx0TW9kZWxOYW1lKCl7cmV0dXJuXCJ0aW55X2ZhY2VfZGV0ZWN0b3JfbW9kZWxcIn1leHRyYWN0UGFyYW1zRnJvbVdlaWdodE1hcCh0KXtyZXR1cm4gc3VwZXIuZXh0cmFjdFBhcmFtc0Zyb21XZWlnaHRNYXAodCl9fTt2YXIgcnQ9e3NzZE1vYmlsZW5ldHYxOm5ldyBsbCx0aW55RmFjZURldGVjdG9yOm5ldyB6cCx0aW55WW9sb3YyOm5ldyBQcCxmYWNlTGFuZG1hcms2OE5ldDpuZXcgRHAsZmFjZUxhbmRtYXJrNjhUaW55TmV0Om5ldyBjZyxmYWNlUmVjb2duaXRpb25OZXQ6bmV3IFJwLGZhY2VFeHByZXNzaW9uTmV0Om5ldyBzZyxhZ2VHZW5kZXJOZXQ6bmV3IHVnfSxjZ2U9KGUsdCk9PnJ0LnNzZE1vYmlsZW5ldHYxLmxvY2F0ZUZhY2VzKGUsdCksYl9lPShlLHQpPT5ydC50aW55RmFjZURldGVjdG9yLmxvY2F0ZUZhY2VzKGUsdCkseV9lPShlLHQpPT5ydC50aW55WW9sb3YyLmxvY2F0ZUZhY2VzKGUsdCksZGdlPWU9PnJ0LmZhY2VMYW5kbWFyazY4TmV0LmRldGVjdExhbmRtYXJrcyhlKSx4X2U9ZT0+cnQuZmFjZUxhbmRtYXJrNjhUaW55TmV0LmRldGVjdExhbmRtYXJrcyhlKSx2X2U9ZT0+cnQuZmFjZVJlY29nbml0aW9uTmV0LmNvbXB1dGVGYWNlRGVzY3JpcHRvcihlKSx3X2U9ZT0+cnQuZmFjZUV4cHJlc3Npb25OZXQucHJlZGljdEV4cHJlc3Npb25zKGUpLGtfZT1lPT5ydC5hZ2VHZW5kZXJOZXQucHJlZGljdEFnZUFuZEdlbmRlcihlKSxoZ2U9ZT0+cnQuc3NkTW9iaWxlbmV0djEubG9hZChlKSxJX2U9ZT0+cnQudGlueUZhY2VEZXRlY3Rvci5sb2FkKGUpLFNfZT1lPT5ydC50aW55WW9sb3YyLmxvYWQoZSksTl9lPWU9PnJ0LmZhY2VMYW5kbWFyazY4TmV0LmxvYWQoZSksVF9lPWU9PnJ0LmZhY2VMYW5kbWFyazY4VGlueU5ldC5sb2FkKGUpLENfZT1lPT5ydC5mYWNlUmVjb2duaXRpb25OZXQubG9hZChlKSxFX2U9ZT0+cnQuZmFjZUV4cHJlc3Npb25OZXQubG9hZChlKSxfX2U9ZT0+cnQuYWdlR2VuZGVyTmV0LmxvYWQoZSksQV9lPWhnZSxGX2U9Y2dlLCRfZT1kZ2U7dmFyIGdnPWNsYXNzIGV4dGVuZHMgT2F7Y29uc3RydWN0b3IobixhLHIpe3N1cGVyKCk7dGhpcy5wYXJlbnRUYXNrPW47dGhpcy5pbnB1dD1hO3RoaXMuZXh0cmFjdGVkRmFjZXM9cn19LHBsPWNsYXNzIGV4dGVuZHMgZ2d7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgdGhpcy5wYXJlbnRUYXNrLG49YXdhaXQgdWwodCx0aGlzLmlucHV0LGFzeW5jIGE9PlByb21pc2UuYWxsKGEubWFwKHI9PnJ0LmZhY2VFeHByZXNzaW9uTmV0LnByZWRpY3RFeHByZXNzaW9ucyhyKSkpLHRoaXMuZXh0cmFjdGVkRmFjZXMpO3JldHVybiB0Lm1hcCgoYSxyKT0+TmsoYSxuW3JdKSl9d2l0aEFnZUFuZEdlbmRlcigpe3JldHVybiBuZXcgZGwodGhpcyx0aGlzLmlucHV0KX19LGNsPWNsYXNzIGV4dGVuZHMgZ2d7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgdGhpcy5wYXJlbnRUYXNrO2lmKCF0KXJldHVybjtsZXQgbj1hd2FpdCBMcCh0LHRoaXMuaW5wdXQsYT0+cnQuZmFjZUV4cHJlc3Npb25OZXQucHJlZGljdEV4cHJlc3Npb25zKGEpLHRoaXMuZXh0cmFjdGVkRmFjZXMpO3JldHVybiBOayh0LG4pfXdpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IGhsKHRoaXMsdGhpcy5pbnB1dCl9fSxQcz1jbGFzcyBleHRlbmRzIHBse3dpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IHpzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEZhY2VEZXNjcmlwdG9ycygpe3JldHVybiBuZXcgQnModGhpcyx0aGlzLmlucHV0KX19LExzPWNsYXNzIGV4dGVuZHMgY2x7d2l0aEFnZUFuZEdlbmRlcigpe3JldHVybiBuZXcgV3ModGhpcyx0aGlzLmlucHV0KX13aXRoRmFjZURlc2NyaXB0b3IoKXtyZXR1cm4gbmV3IFZzKHRoaXMsdGhpcy5pbnB1dCl9fTt2YXIgYmc9Y2xhc3MgZXh0ZW5kcyBPYXtjb25zdHJ1Y3RvcihuLGEscil7c3VwZXIoKTt0aGlzLnBhcmVudFRhc2s9bjt0aGlzLmlucHV0PWE7dGhpcy5leHRyYWN0ZWRGYWNlcz1yfX0sZGw9Y2xhc3MgZXh0ZW5kcyBiZ3thc3luYyBydW4oKXtsZXQgdD1hd2FpdCB0aGlzLnBhcmVudFRhc2ssbj1hd2FpdCB1bCh0LHRoaXMuaW5wdXQsYXN5bmMgYT0+UHJvbWlzZS5hbGwoYS5tYXAocj0+cnQuYWdlR2VuZGVyTmV0LnByZWRpY3RBZ2VBbmRHZW5kZXIocikpKSx0aGlzLmV4dHJhY3RlZEZhY2VzKTtyZXR1cm4gdC5tYXAoKGEscik9PntsZXR7YWdlOnMsZ2VuZGVyOmksZ2VuZGVyUHJvYmFiaWxpdHk6b309bltyXTtyZXR1cm4gRmsoJGsoYSxpLG8pLHMpfSl9d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgcGwodGhpcyx0aGlzLmlucHV0KX19LGhsPWNsYXNzIGV4dGVuZHMgYmd7YXN5bmMgcnVuKCl7bGV0IHQ9YXdhaXQgdGhpcy5wYXJlbnRUYXNrO2lmKCF0KXJldHVybjtsZXR7YWdlOm4sZ2VuZGVyOmEsZ2VuZGVyUHJvYmFiaWxpdHk6cn09YXdhaXQgTHAodCx0aGlzLmlucHV0LHM9PnJ0LmFnZUdlbmRlck5ldC5wcmVkaWN0QWdlQW5kR2VuZGVyKHMpLHRoaXMuZXh0cmFjdGVkRmFjZXMpO3JldHVybiBGaygkayh0LGEsciksbil9d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgY2wodGhpcyx0aGlzLmlucHV0KX19LHpzPWNsYXNzIGV4dGVuZHMgZGx7d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgUHModGhpcyx0aGlzLmlucHV0KX13aXRoRmFjZURlc2NyaXB0b3JzKCl7cmV0dXJuIG5ldyBCcyh0aGlzLHRoaXMuaW5wdXQpfX0sV3M9Y2xhc3MgZXh0ZW5kcyBobHt3aXRoRmFjZUV4cHJlc3Npb25zKCl7cmV0dXJuIG5ldyBMcyh0aGlzLHRoaXMuaW5wdXQpfXdpdGhGYWNlRGVzY3JpcHRvcigpe3JldHVybiBuZXcgVnModGhpcyx0aGlzLmlucHV0KX19O3ZhciB5Zz1jbGFzcyBleHRlbmRzIE9he2NvbnN0cnVjdG9yKG4sYSl7c3VwZXIoKTt0aGlzLnBhcmVudFRhc2s9bjt0aGlzLmlucHV0PWF9fSxCcz1jbGFzcyBleHRlbmRzIHlne2FzeW5jIHJ1bigpe2xldCB0PWF3YWl0IHRoaXMucGFyZW50VGFzaztyZXR1cm4oYXdhaXQgdWwodCx0aGlzLmlucHV0LGE9PlByb21pc2UuYWxsKGEubWFwKHI9PnJ0LmZhY2VSZWNvZ25pdGlvbk5ldC5jb21wdXRlRmFjZURlc2NyaXB0b3IocikpKSxudWxsLGE9PmEubGFuZG1hcmtzLmFsaWduKG51bGwse3VzZURsaWJBbGlnbm1lbnQ6ITB9KSkpLm1hcCgoYSxyKT0+QWsodFtyXSxhKSl9d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgUHModGhpcyx0aGlzLmlucHV0KX13aXRoQWdlQW5kR2VuZGVyKCl7cmV0dXJuIG5ldyB6cyh0aGlzLHRoaXMuaW5wdXQpfX0sVnM9Y2xhc3MgZXh0ZW5kcyB5Z3thc3luYyBydW4oKXtsZXQgdD1hd2FpdCB0aGlzLnBhcmVudFRhc2s7aWYoIXQpcmV0dXJuO2xldCBuPWF3YWl0IExwKHQsdGhpcy5pbnB1dCxhPT5ydC5mYWNlUmVjb2duaXRpb25OZXQuY29tcHV0ZUZhY2VEZXNjcmlwdG9yKGEpLG51bGwsYT0+YS5sYW5kbWFya3MuYWxpZ24obnVsbCx7dXNlRGxpYkFsaWdubWVudDohMH0pKTtyZXR1cm4gQWsodCxuKX13aXRoRmFjZUV4cHJlc3Npb25zKCl7cmV0dXJuIG5ldyBMcyh0aGlzLHRoaXMuaW5wdXQpfXdpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IFdzKHRoaXMsdGhpcy5pbnB1dCl9fTt2YXIgeGc9Y2xhc3MgZXh0ZW5kcyBPYXtjb25zdHJ1Y3RvcihuLGEscil7c3VwZXIoKTt0aGlzLnBhcmVudFRhc2s9bjt0aGlzLmlucHV0PWE7dGhpcy51c2VUaW55TGFuZG1hcmtOZXQ9cn1nZXQgbGFuZG1hcmtOZXQoKXtyZXR1cm4gdGhpcy51c2VUaW55TGFuZG1hcmtOZXQ/cnQuZmFjZUxhbmRtYXJrNjhUaW55TmV0OnJ0LmZhY2VMYW5kbWFyazY4TmV0fX0sdmc9Y2xhc3MgZXh0ZW5kcyB4Z3thc3luYyBydW4oKXtsZXQgdD1hd2FpdCB0aGlzLnBhcmVudFRhc2ssbj10Lm1hcChpPT5pLmRldGVjdGlvbiksYT10aGlzLmlucHV0IGluc3RhbmNlb2YgQ2U/YXdhaXQgTGQodGhpcy5pbnB1dCxuKTphd2FpdCBQZCh0aGlzLmlucHV0LG4pLHI9YXdhaXQgUHJvbWlzZS5hbGwoYS5tYXAoaT0+dGhpcy5sYW5kbWFya05ldC5kZXRlY3RMYW5kbWFya3MoaSkpKTtyZXR1cm4gYS5mb3JFYWNoKGk9PmkgaW5zdGFuY2VvZiBDZSYmaS5kaXNwb3NlKCkpLHQuZmlsdGVyKChpLG8pPT5yW29dKS5tYXAoKGksbyk9PlZkKGkscltvXSkpfXdpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IFBzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEFnZUFuZEdlbmRlcigpe3JldHVybiBuZXcgenModGhpcyx0aGlzLmlucHV0KX13aXRoRmFjZURlc2NyaXB0b3JzKCl7cmV0dXJuIG5ldyBCcyh0aGlzLHRoaXMuaW5wdXQpfX0sd2c9Y2xhc3MgZXh0ZW5kcyB4Z3thc3luYyBydW4oKXtsZXQgdD1hd2FpdCB0aGlzLnBhcmVudFRhc2s7aWYoIXQpcmV0dXJuO2xldHtkZXRlY3Rpb246bn09dCxhPXRoaXMuaW5wdXQgaW5zdGFuY2VvZiBDZT9hd2FpdCBMZCh0aGlzLmlucHV0LFtuXSk6YXdhaXQgUGQodGhpcy5pbnB1dCxbbl0pLHI9YXdhaXQgdGhpcy5sYW5kbWFya05ldC5kZXRlY3RMYW5kbWFya3MoYVswXSk7cmV0dXJuIGEuZm9yRWFjaChzPT5zIGluc3RhbmNlb2YgQ2UmJnMuZGlzcG9zZSgpKSxWZCh0LHIpfXdpdGhGYWNlRXhwcmVzc2lvbnMoKXtyZXR1cm4gbmV3IExzKHRoaXMsdGhpcy5pbnB1dCl9d2l0aEFnZUFuZEdlbmRlcigpe3JldHVybiBuZXcgV3ModGhpcyx0aGlzLmlucHV0KX13aXRoRmFjZURlc2NyaXB0b3IoKXtyZXR1cm4gbmV3IFZzKHRoaXMsdGhpcy5pbnB1dCl9fTt2YXIga2c9Y2xhc3MgZXh0ZW5kcyBPYXtjb25zdHJ1Y3RvcihuLGE9bmV3IE1hKXtzdXBlcigpO3RoaXMuaW5wdXQ9bjt0aGlzLm9wdGlvbnM9YX19LEdkPWNsYXNzIGV4dGVuZHMga2d7YXN5bmMgcnVuKCl7bGV0e2lucHV0OnQsb3B0aW9uczpufT10aGlzLGE7aWYobiBpbnN0YW5jZW9mIGZnKWE9cnQudGlueUZhY2VEZXRlY3Rvci5sb2NhdGVGYWNlcyh0LG4pO2Vsc2UgaWYobiBpbnN0YW5jZW9mIE1hKWE9cnQuc3NkTW9iaWxlbmV0djEubG9jYXRlRmFjZXModCxuKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiB5cilhPXJ0LnRpbnlZb2xvdjIubG9jYXRlRmFjZXModCxuKTtlbHNlIHRocm93IG5ldyBFcnJvcihcImRldGVjdEZhY2VzIC0gZXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBpbnN0YW5jZSBvZiBUaW55RmFjZURldGVjdG9yT3B0aW9ucyB8IFNzZE1vYmlsZW5ldHYxT3B0aW9ucyB8IFRpbnlZb2xvdjJPcHRpb25zXCIpO3JldHVybiBhfXJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9ucygpe3JldHVybiBuZXcgUHJvbWlzZSgodCxuKT0+e3RoaXMucnVuKCkudGhlbihhPT50KGEubWFwKHI9PndwKHt9LHIpKSkpLmNhdGNoKGE9Pm4oYSkpfSl9d2l0aEZhY2VMYW5kbWFya3ModD0hMSl7cmV0dXJuIG5ldyB2Zyh0aGlzLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9ucygpLHRoaXMuaW5wdXQsdCl9d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgcGwodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbnMoKSx0aGlzLmlucHV0KX13aXRoQWdlQW5kR2VuZGVyKCl7cmV0dXJuIG5ldyBkbCh0aGlzLnJ1bkFuZEV4dGVuZFdpdGhGYWNlRGV0ZWN0aW9ucygpLHRoaXMuaW5wdXQpfX0sSWc9Y2xhc3MgZXh0ZW5kcyBrZ3thc3luYyBydW4oKXtsZXQgdD1hd2FpdCBuZXcgR2QodGhpcy5pbnB1dCx0aGlzLm9wdGlvbnMpLG49dFswXTtyZXR1cm4gdC5mb3JFYWNoKGE9PnthLnNjb3JlPm4uc2NvcmUmJihuPWEpfSksbn1ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbigpe3JldHVybiBuZXcgUHJvbWlzZShhc3luYyB0PT57bGV0IG49YXdhaXQgdGhpcy5ydW4oKTt0KG4/d3Aoe30sbik6dm9pZCAwKX0pfXdpdGhGYWNlTGFuZG1hcmtzKHQ9ITEpe3JldHVybiBuZXcgd2codGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbigpLHRoaXMuaW5wdXQsdCl9d2l0aEZhY2VFeHByZXNzaW9ucygpe3JldHVybiBuZXcgY2wodGhpcy5ydW5BbmRFeHRlbmRXaXRoRmFjZURldGVjdGlvbigpLHRoaXMuaW5wdXQpfXdpdGhBZ2VBbmRHZW5kZXIoKXtyZXR1cm4gbmV3IGhsKHRoaXMucnVuQW5kRXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24oKSx0aGlzLmlucHV0KX19O2Z1bmN0aW9uIF9BZShlLHQ9bmV3IE1hKXtyZXR1cm4gbmV3IElnKGUsdCl9ZnVuY3Rpb24gRGsoZSx0PW5ldyBNYSl7cmV0dXJuIG5ldyBHZChlLHQpfWFzeW5jIGZ1bmN0aW9uIG1nZShlLHQpe3JldHVybiBEayhlLG5ldyBNYSh0P3ttaW5Db25maWRlbmNlOnR9Ont9KSkud2l0aEZhY2VMYW5kbWFya3MoKS53aXRoRmFjZURlc2NyaXB0b3JzKCl9YXN5bmMgZnVuY3Rpb24gTUFlKGUsdD17fSl7cmV0dXJuIERrKGUsbmV3IHlyKHQpKS53aXRoRmFjZUxhbmRtYXJrcygpLndpdGhGYWNlRGVzY3JpcHRvcnMoKX12YXIgT0FlPW1nZTtmdW5jdGlvbiB6RChlLHQpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZXVjbGlkZWFuRGlzdGFuY2U6IGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aFwiKTtsZXQgbj1BcnJheS5mcm9tKGUpLGE9QXJyYXkuZnJvbSh0KTtyZXR1cm4gTWF0aC5zcXJ0KG4ubWFwKChyLHMpPT5yLWFbc10pLnJlZHVjZSgocixzKT0+citzKnMsMCkpfXZhciBXRD1jbGFzcyBle2NvbnN0cnVjdG9yKHQsbj0uNil7dGhpcy5fZGlzdGFuY2VUaHJlc2hvbGQ9bjtsZXQgYT1BcnJheS5pc0FycmF5KHQpP3Q6W3RdO2lmKCFhLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGYWNlUmVjb2duaXplci5jb25zdHJ1Y3RvciAtIGV4cGVjdGVkIGF0bGVhc3Qgb25lIGlucHV0XCIpO2xldCByPTEscz0oKT0+YHBlcnNvbiAke3IrK31gO3RoaXMuX2xhYmVsZWREZXNjcmlwdG9ycz1hLm1hcChpPT57aWYoaSBpbnN0YW5jZW9mIHJsKXJldHVybiBpO2lmKGkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpcmV0dXJuIG5ldyBybChzKCksW2ldKTtpZihpLmRlc2NyaXB0b3ImJmkuZGVzY3JpcHRvciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSlyZXR1cm4gbmV3IHJsKHMoKSxbaS5kZXNjcmlwdG9yXSk7dGhyb3cgbmV3IEVycm9yKFwiRmFjZVJlY29nbml6ZXIuY29uc3RydWN0b3IgLSBleHBlY3RlZCBpbnB1dHMgdG8gYmUgb2YgdHlwZSBMYWJlbGVkRmFjZURlc2NyaXB0b3JzIHwgV2l0aEZhY2VEZXNjcmlwdG9yPGFueT4gfCBGbG9hdDMyQXJyYXkgfCBBcnJheTxMYWJlbGVkRmFjZURlc2NyaXB0b3JzIHwgV2l0aEZhY2VEZXNjcmlwdG9yPGFueT4gfCBGbG9hdDMyQXJyYXk+XCIpfSl9Z2V0IGxhYmVsZWREZXNjcmlwdG9ycygpe3JldHVybiB0aGlzLl9sYWJlbGVkRGVzY3JpcHRvcnN9Z2V0IGRpc3RhbmNlVGhyZXNob2xkKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlVGhyZXNob2xkfWNvbXB1dGVNZWFuRGlzdGFuY2UodCxuKXtyZXR1cm4gbi5tYXAoYT0+ekQoYSx0KSkucmVkdWNlKChhLHIpPT5hK3IsMCkvKG4ubGVuZ3RofHwxKX1tYXRjaERlc2NyaXB0b3IodCl7cmV0dXJuIHRoaXMubGFiZWxlZERlc2NyaXB0b3JzLm1hcCgoe2Rlc2NyaXB0b3JzOm4sbGFiZWw6YX0pPT5uZXcgRGQoYSx0aGlzLmNvbXB1dGVNZWFuRGlzdGFuY2UodCxuKSkpLnJlZHVjZSgobixhKT0+bi5kaXN0YW5jZTxhLmRpc3RhbmNlP246YSl9ZmluZEJlc3RNYXRjaCh0KXtsZXQgbj10aGlzLm1hdGNoRGVzY3JpcHRvcih0KTtyZXR1cm4gbi5kaXN0YW5jZTx0aGlzLl9kaXN0YW5jZVRocmVzaG9sZD9uOm5ldyBEZChcInVua25vd25cIixuLmRpc3RhbmNlKX10b0pTT04oKXtyZXR1cm57ZGlzdGFuY2VUaHJlc2hvbGQ6dGhpcy5fZGlzdGFuY2VUaHJlc2hvbGQsbGFiZWxlZERlc2NyaXB0b3JzOnRoaXMuX2xhYmVsZWREZXNjcmlwdG9ycy5tYXAodD0+dC50b0pTT04oKSl9fXN0YXRpYyBmcm9tSlNPTih0KXtsZXQgbj10LmxhYmVsZWREZXNjcmlwdG9ycy5tYXAoYT0+cmwuZnJvbUpTT04oYSkpO3JldHVybiBuZXcgZShuLHQuZGlzdGFuY2VUaHJlc2hvbGQpfX07ZnVuY3Rpb24gZUZlKGUpe2xldCB0PW5ldyB6cDtyZXR1cm4gdC5leHRyYWN0V2VpZ2h0cyhlKSx0fWZ1bmN0aW9uIGZnZShlLHQpe2xldHt3aWR0aDpuLGhlaWdodDphfT1uZXcgYWEodC53aWR0aCx0LmhlaWdodCk7aWYobjw9MHx8YTw9MCl0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZVJlc3VsdHMgLSBpbnZhbGlkIGRpbWVuc2lvbnM6ICR7SlNPTi5zdHJpbmdpZnkoe3dpZHRoOm4saGVpZ2h0OmF9KX1gKTtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlLm1hcChyPT5mZ2Uocix7d2lkdGg6bixoZWlnaHQ6YX0pKTtpZihGcChlKSl7bGV0IHI9ZS5kZXRlY3Rpb24uZm9yU2l6ZShuLGEpLHM9ZS51bnNoaWZ0ZWRMYW5kbWFya3MuZm9yU2l6ZShyLmJveC53aWR0aCxyLmJveC5oZWlnaHQpO3JldHVybiBWZCh3cChlLHIpLHMpfXJldHVybiB6cihlKT93cChlLGUuZGV0ZWN0aW9uLmZvclNpemUobixhKSk6ZSBpbnN0YW5jZW9mIGthfHxlIGluc3RhbmNlb2YgRnQ/ZS5mb3JTaXplKG4sYSk6ZX12YXIgY0ZlPW9EO2V4cG9ydHt1ZyBhcyBBZ2VHZW5kZXJOZXQsYnAgYXMgQm91bmRpbmdCb3gsbW4gYXMgQm94LE9hIGFzIENvbXBvc2FibGVUYXNrLEJzIGFzIENvbXB1dGVBbGxGYWNlRGVzY3JpcHRvcnNUYXNrLHlnIGFzIENvbXB1dGVGYWNlRGVzY3JpcHRvcnNUYXNrQmFzZSxWcyBhcyBDb21wdXRlU2luZ2xlRmFjZURlc2NyaXB0b3JUYXNrLHZnIGFzIERldGVjdEFsbEZhY2VMYW5kbWFya3NUYXNrLEdkIGFzIERldGVjdEFsbEZhY2VzVGFzayx4ZyBhcyBEZXRlY3RGYWNlTGFuZG1hcmtzVGFza0Jhc2Usa2cgYXMgRGV0ZWN0RmFjZXNUYXNrQmFzZSx3ZyBhcyBEZXRlY3RTaW5nbGVGYWNlTGFuZG1hcmtzVGFzayxJZyBhcyBEZXRlY3RTaW5nbGVGYWNlVGFzayxhYSBhcyBEaW1lbnNpb25zLHJEIGFzIEZBQ0VfRVhQUkVTU0lPTl9MQUJFTFMsRnQgYXMgRmFjZURldGVjdGlvbixURCBhcyBGYWNlRGV0ZWN0aW9uTmV0LHNnIGFzIEZhY2VFeHByZXNzaW9uTmV0LE9zIGFzIEZhY2VFeHByZXNzaW9ucyxEcCBhcyBGYWNlTGFuZG1hcms2OE5ldCxjZyBhcyBGYWNlTGFuZG1hcms2OFRpbnlOZXQsZkQgYXMgRmFjZUxhbmRtYXJrTmV0LGthIGFzIEZhY2VMYW5kbWFya3MsSCQgYXMgRmFjZUxhbmRtYXJrczUsdnAgYXMgRmFjZUxhbmRtYXJrczY4LERkIGFzIEZhY2VNYXRjaCxXRCBhcyBGYWNlTWF0Y2hlcixScCBhcyBGYWNlUmVjb2duaXRpb25OZXQsQ2sgYXMgR2VuZGVyLFJkIGFzIExhYmVsZWRCb3gscmwgYXMgTGFiZWxlZEZhY2VEZXNjcmlwdG9ycyxXciBhcyBOZXRJbnB1dCxmbiBhcyBOZXVyYWxOZXR3b3JrLHlwIGFzIE9iamVjdERldGVjdGlvbixIZSBhcyBQb2ludCxqJCBhcyBQcmVkaWN0ZWRCb3gseHAgYXMgUmVjdCxsbCBhcyBTc2RNb2JpbGVuZXR2MSxNYSBhcyBTc2RNb2JpbGVuZXR2MU9wdGlvbnMsenAgYXMgVGlueUZhY2VEZXRlY3RvcixmZyBhcyBUaW55RmFjZURldGVjdG9yT3B0aW9ucyxQcCBhcyBUaW55WW9sb3YyLHlyIGFzIFRpbnlZb2xvdjJPcHRpb25zLE9BZSBhcyBhbGxGYWNlcyxtZ2UgYXMgYWxsRmFjZXNTc2RNb2JpbGVuZXR2MSxNQWUgYXMgYWxsRmFjZXNUaW55WW9sb3YyLHEkIGFzIGF3YWl0TWVkaWFMb2FkZWQsSyQgYXMgYnVmZmVyVG9JbWFnZSx2X2UgYXMgY29tcHV0ZUZhY2VEZXNjcmlwdG9yLE5wIGFzIGNyZWF0ZUNhbnZhcyxaZiBhcyBjcmVhdGVDYW52YXNGcm9tTWVkaWEsWUNlIGFzIGNyZWF0ZUZhY2VEZXRlY3Rpb25OZXQsWTJlIGFzIGNyZWF0ZUZhY2VSZWNvZ25pdGlvbk5ldCxsZ2UgYXMgY3JlYXRlU3NkTW9iaWxlbmV0djEsZUZlIGFzIGNyZWF0ZVRpbnlGYWNlRGV0ZWN0b3IsQkVlIGFzIGNyZWF0ZVRpbnlZb2xvdjIsRGsgYXMgZGV0ZWN0QWxsRmFjZXMsZGdlIGFzIGRldGVjdEZhY2VMYW5kbWFya3MseF9lIGFzIGRldGVjdEZhY2VMYW5kbWFya3NUaW55LCRfZSBhcyBkZXRlY3RMYW5kbWFya3MsX0FlIGFzIGRldGVjdFNpbmdsZUZhY2UsaUQgYXMgZHJhdyxhdCBhcyBlbnYsekQgYXMgZXVjbGlkZWFuRGlzdGFuY2UsRmsgYXMgZXh0ZW5kV2l0aEFnZSxBayBhcyBleHRlbmRXaXRoRmFjZURlc2NyaXB0b3Isd3AgYXMgZXh0ZW5kV2l0aEZhY2VEZXRlY3Rpb24sTmsgYXMgZXh0ZW5kV2l0aEZhY2VFeHByZXNzaW9ucyxWZCBhcyBleHRlbmRXaXRoRmFjZUxhbmRtYXJrcywkayBhcyBleHRlbmRXaXRoR2VuZGVyLExkIGFzIGV4dHJhY3RGYWNlVGVuc29ycyxQZCBhcyBleHRyYWN0RmFjZXMsc0llIGFzIGZldGNoSW1hZ2UsWiQgYXMgZmV0Y2hKc29uLHBJZSBhcyBmZXRjaE5ldFdlaWdodHMsTXMgYXMgZmV0Y2hPclRocm93LGdJZSBhcyBmZXRjaFZpZGVvLHJhIGFzIGdldENvbnRleHQyZE9yVGhyb3csU3AgYXMgZ2V0TWVkaWFEaW1lbnNpb25zLFgkIGFzIGltYWdlVGVuc29yVG9DYW52YXMsWSQgYXMgaW1hZ2VUb1NxdWFyZSx2MGUgYXMgaW52ZXJzZVNpZ21vaWQsQiQgYXMgaW91LFNrIGFzIGlzTWVkaWFFbGVtZW50LFlmIGFzIGlzTWVkaWFMb2FkZWQsZUNlIGFzIGlzV2l0aEFnZSx6ciBhcyBpc1dpdGhGYWNlRGV0ZWN0aW9uLHNEIGFzIGlzV2l0aEZhY2VFeHByZXNzaW9ucyxGcCBhcyBpc1dpdGhGYWNlTGFuZG1hcmtzLHJDZSBhcyBpc1dpdGhHZW5kZXIsX19lIGFzIGxvYWRBZ2VHZW5kZXJNb2RlbCxBX2UgYXMgbG9hZEZhY2VEZXRlY3Rpb25Nb2RlbCxFX2UgYXMgbG9hZEZhY2VFeHByZXNzaW9uTW9kZWwsTl9lIGFzIGxvYWRGYWNlTGFuZG1hcmtNb2RlbCxUX2UgYXMgbG9hZEZhY2VMYW5kbWFya1RpbnlNb2RlbCxDX2UgYXMgbG9hZEZhY2VSZWNvZ25pdGlvbk1vZGVsLGhnZSBhcyBsb2FkU3NkTW9iaWxlbmV0djFNb2RlbCxJX2UgYXMgbG9hZFRpbnlGYWNlRGV0ZWN0b3JNb2RlbCxTX2UgYXMgbG9hZFRpbnlZb2xvdjJNb2RlbCxRJCBhcyBsb2FkV2VpZ2h0TWFwLEZfZSBhcyBsb2NhdGVGYWNlcyxJSWUgYXMgbWF0Y2hEaW1lbnNpb25zLFYkIGFzIG1pbkJib3gscnQgYXMgbmV0cyxVJCBhcyBub25NYXhTdXBwcmVzc2lvbixiciBhcyBub3JtYWxpemUsRyQgYXMgcGFkVG9TcXVhcmUsa19lIGFzIHByZWRpY3RBZ2VBbmRHZW5kZXIsd19lIGFzIHJlY29nbml6ZUZhY2VFeHByZXNzaW9ucyxmZ2UgYXMgcmVzaXplUmVzdWx0cyxrcCBhcyByZXNvbHZlSW5wdXQseTBlIGFzIHNodWZmbGVBcnJheSxxZiBhcyBzaWdtb2lkLGNnZSBhcyBzc2RNb2JpbGVuZXR2MSxQZSBhcyB0ZixiX2UgYXMgdGlueUZhY2VEZXRlY3Rvcix5X2UgYXMgdGlueVlvbG92Mix2dCBhcyB0b05ldElucHV0LFckIGFzIHV0aWxzLEREIGFzIHZhbGlkYXRlQ29uZmlnLGNGZSBhcyB2ZXJzaW9ufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhY2UtYXBpLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@vladmandic/face-api/dist/face-api.esm.js\n");

/***/ })

};
;